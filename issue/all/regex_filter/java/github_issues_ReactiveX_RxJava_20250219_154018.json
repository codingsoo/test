[
  {
    "number": 7835,
    "title": "Issue with Flowable.zip of shared sources subscribed in the background thread",
    "created_at": "2025-02-14T10:44:15Z",
    "closed_at": "2025-02-14T13:59:45Z",
    "labels": [
      "Question",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7835",
    "body": "Running the following test, I would expect all assertions to pass \n```\nimport com.google.common.base.Preconditions;\nimport com.google.common.truth.Truth;\nimport io.reactivex.rxjava3.core.Flowable;\nimport io.reactivex.rxjava3.schedulers.Schedulers;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.IntStream;\nimport org.junit.jupiter.api.Test;\n\npublic class ZipSharedTest {\n\n\n  @Test\n  public void testConcurrentZip() {\n    int elementCount = 10;\n    int sourceCopies = 10000;\n    Flowable<Integer> source = Flowable.fromArray(IntStream.range(0, elementCount).boxed().toArray(Integer[]::new));\n\n    io.reactivex.rxjava3.functions.Function<Object[], List<Object>> zipper = objects -> {\n      Preconditions.checkArgument(Arrays.stream(objects).allMatch(o -> o.equals(objects[0])), \"Elements should all be equal\");\n      return List.of(objects);\n    };\n\n    // A: independent sources, sequential\n    {\n      Iterable<List<Object>> results = Flowable.zip(Collections.nCopies(sourceCopies, source), zipper).blockingIterable();\n      Truth.assertThat(results).hasSize(elementCount);\n    }\n\n    // B: multicast sources (c.f. share operator), sequential\n    {\n      Iterable<List<Object>> results = Flowable.zip(Collections.nCopies(sourceCopies, source.share()), zipper)\n          .blockingIterable();\n      Truth.assertThat(results).hasSize(elementCount);\n    }\n\n    // C: independent sources, parallel\n    {\n      Iterable<List<Object>> results = Flowable.zip(Collections.nCopies(sourceCopies, source.subscribeOn(Schedulers.io())), zipper)\n          .blockingIterable();\n      Truth.assertThat(results).hasSize(elementCount);\n    }\n\n    // D: multicast sources (c.f. share operator), parallel\n    {\n      Iterable<List<Object>> results = Flowable.zip(Collections.nCopies(sourceCopies, source.share().subscribeOn(Schedulers.io())), zipper)\n          .blockingIterable();\n      Truth.assertThat(results).hasSize(elementCount);\n    }\n  }\n}\n\n``` \n\nHowever, variant D fails either by throwing an exception in the `zipper` or without any elements. Looking into the implementation of `FlowableZip`, I would assume this is a race-condition in the loop of subscribing the inner `ZipSubscriber`. As soon as the first establishes a subscription, it requests data from the shared upstream, which then in turn makes all other `ZipSubscriber` miss out on some/all upstream elements.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7835/comments",
    "author": "fplein",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2025-02-14T11:06:31Z",
        "body": "Yes, the synchronous nature of the source causes the sequence to get relalized and thus the other subscribers will non-deterministically see possibly completed sequence, thus no full row of items to zip."
      },
      {
        "user": "fplein",
        "created_at": "2025-02-14T11:12:38Z",
        "body": "Does this mean that this behaviour is expected? \n\nOur use-case is of course not as trivial as the example I have provided, but our data goes through multiple steps where similar to the above multicasting is happening (each step mapping data to some transformation/computation). We then zip the results back together to get the full list of computations. Since streaming the source data and doing the computations is potentially expensive, we want to keep the multicast. Do you have any suggestions on how to get variant D of the OP to work, so that we do not miss any elements in the zipping? Thinking of only requesting from zip sources, once all subscribers have there subscription established?"
      },
      {
        "user": "akarnokd",
        "created_at": "2025-02-14T12:55:49Z",
        "body": "If you know the number of consumers (n) of the shared source, you can use `publish().autoConnect(n)`. If you can line up any number of consumers on a `publish()`-ed source, call `ConnectableFlowable::connect` when you are ready to run everyone. \n\nOtherwise, it may not work and you'd have to rethink your dataflow."
      },
      {
        "user": "fplein",
        "created_at": "2025-02-14T13:41:20Z",
        "body": "So I cannot determine the number of consumers beforehand. I did though always use a manual connect logic. I used some hacky transformer to automatically connect the sources before a `blockingSubscribe`. Basically I transform the upstream of the blocking subscribe using the following: \n```\nprivate static class ConnectingFlowable<T, Connectable> extends Flowable<T> {\n\n    @Nonnull\n    private final Flowable<T> source;\n    @Nonnull\n    private final Connectable connectable;\n    @Nonnull\n    private final java.util.function.Consumer<Connectable> connector;\n\n    @Override\n    protected void subscribeActual(@NonNull Subscriber<? super T> subscriber) {\n      source.subscribe(subscriber);\n      // important to call AFTER the subscription chain, since this ensures that the full flowable assembly is subscribed before emitting data\n      connector.accept(connectable);\n    }\n  }\n```\n\nHowever, my comment on the connecting still does not hold. This still connects sources too early and is flaky. Any advise on how I could detect that everything is properly subscribed before calling the connect? "
      },
      {
        "user": "akarnokd",
        "created_at": "2025-02-14T13:46:21Z",
        "body": "Avoid using `subscribeOn`. Move the processing away from the emitting thread via `observeOn`."
      },
      {
        "user": "fplein",
        "created_at": "2025-02-14T13:48:12Z",
        "body": "Would the `observeOn` then still achieve some form of \"concurrent\" zip? I am looking to have `zip` behave similar to `merge` where sources can emit in parallel, rather than buffering them sequentially."
      },
      {
        "user": "akarnokd",
        "created_at": "2025-02-14T13:59:32Z",
        "body": "Yes."
      }
    ]
  },
  {
    "number": 7834,
    "title": "DistinctUntilChanged doesn't work on API level 29",
    "created_at": "2025-02-13T18:38:13Z",
    "closed_at": "2025-02-17T08:24:11Z",
    "labels": [
      "Question",
      "Android"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7834",
    "body": "Running this code on API level 25, `t1` and `t2` are different when typing in the edit text.  \nHowever, on API level 29, the `t1 == t2` condition always evaluates to true.\n\n```\nfun TextInputLayout.priceInput(\n    maxValue: Long = Constants.max_value_receipt.toLong(),\n    skipInitialValue: Boolean = false): Observable<CharSequence> {\n\n    var animation: ValueAnimator? = null\n\n    errorIconDrawable = null\n\n    editText!!.inputType =\n        EditorInfo.TYPE_NUMBER_FLAG_DECIMAL\n    editText!!.keyListener =\n        DigitsKeyListener.getInstance(\"0123456789,\")\n\n    editText!!.setOnTouchListener { _, motionEvent ->\n        if (motionEvent.action == MotionEvent.ACTION_UP) {\n            editText!!.showSoftKeyboard()\n        }\n        return@setOnTouchListener true\n    }\n\n    editText!!.setOnFocusChangeListener { _, hasFocus ->\n        if (hasFocus) editText!!.selectAtTheEnd()\n    }\n\n    val afterTextChangeEvents = editText!!.textChanges().let {\n        if (skipInitialValue)\n            it.skipInitialValue()\n        else\n            it.skip(0)\n    }\n    return afterTextChangeEvents\n        .distinctUntilChanged { t1, t2 ->\n            t1 == t2\n        }\n        .concatMap {\n            Observable.fromCallable {\n                val toString = it.toEmptyIfNull().toString()\n                if (toString.isEmpty())\n                    return@fromCallable toString\n                val withoutComma = toString.replace(\",\", \"\")\n                val value = try {\n                    withoutComma.toLong()\n                } catch (e: Exception) {\n                    return@fromCallable (editText!!).text.delete(\n                            editText!!.text.length - 1,\n                            editText!!.text.length)\n                }\n                if (value > maxValue) {\n                    if (animation == null || animation!!.isRunning.not()) {\n                        animation = createAnimationError(editText!!)\n                        animation!!.start()\n                    }\n                    return@fromCallable editText!!.text.delete(\n                            editText!!.text.length - 1,\n                            editText!!.text.length)\n                }\n                val result = Formats.convertPrice_LongToStringWithComma(value)\n                Logger.d { \"formatted: $result\" }\n                if (toString != result)\n                    editText!!.text.replace(0, editText!!.text.length, result)\n                return@fromCallable result\n            }\n                .onErrorReturnItem(\"\")\n        }\n}\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7834/comments",
    "author": "Jacek-Gawel",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2025-02-13T18:46:06Z",
        "body": "As far as I remember, text change events use a mutable `CharSequence`, thus you may be checking the contents of the same reference object.\n\nTry mapping the text changes into Strings\n\n```kotlin\neditText!!.textChanges().map { it.toString() }.let {\n```"
      },
      {
        "user": "Jacek-Gawel",
        "created_at": "2025-02-17T07:59:21Z",
        "body": "Mapping `textChanges()` to `String` resolves issue.\nThx"
      }
    ]
  },
  {
    "number": 7732,
    "title": "Observable<T>.scan accumulator seems to be called twice",
    "created_at": "2024-07-14T16:09:17Z",
    "closed_at": "2024-07-14T17:36:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7732",
    "body": "I am currently debugging why the scan {} accumulator lambda is getting invoked twice, even when only one event is getting emitted. It will however produce the correct result, because t will take correct previous count probably, resulting in the same updated count. I am developing an Android app but I don't know if that matters. Here's the logs:\r\n\r\n```\r\n2024-07-14 18:04:47.640  8672-8672  xyz                     app.example                          D  onEvent\r\n2024-07-14 18:04:47.640  8672-8672  xyz                     app.example                          D  new event: Increment\r\n2024-07-14 18:04:47.640  8672-8672  xyz                     app.example                          D  new event: Increment\r\n2024-07-14 18:04:47.649  8672-8672  xyz                     app.example                          D  got state: CounterState(count=1, message=Counter is greater than 0)\r\n```\r\n\r\nAnd the relevant parts of my codebase:\r\n\r\n```kotlin\r\nabstract class Presenter<S : State<out Event>> {\r\n\r\n  protected val subscriptions = CompositeDisposable()\r\n\r\n  protected val eventSink = PublishSubject.create<CounterEvent>()\r\n\r\n  abstract val mStateObservable: Observable<S>\r\n\r\n  fun onEvent(event: CounterEvent) {\r\n    Log.d(\"xyz\", \"onEvent\")\r\n    eventSink.onNext(event)\r\n  }\r\n}\r\n\r\nclass CounterPresenter : Presenter<CounterState>() {\r\n\r\n  private val count = eventSink.scan(0L) { count, event ->\r\n    Log.d(\"xyz\", \"new event: $event\")\r\n    when (event) {\r\n      CounterEvent.Increment -> count + 1\r\n      CounterEvent.Decrement -> count - 1\r\n    }\r\n  }\r\n\r\n  // ...\r\n\r\n  override val mStateObservable = Observable\r\n    .combineLatest(count, message) { count, message -> \r\n        CounterState(count, message) \r\n    }\r\n}\r\n```\r\n\r\n- version 3.1.8",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7732/comments",
    "author": "itsandreramon",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2024-07-14T16:48:33Z",
        "body": "Is `onEvent` being called from multiple threads? Is the `count` Observable used more than once?\r\n\r\nIf neither, I suggest logging the stacktrace for the \"new event\" logs and see what chain triggered that particular call."
      },
      {
        "user": "itsandreramon",
        "created_at": "2024-07-14T17:35:09Z",
        "body": "yes It's mapped to another observable like this:\r\n\r\n```kotlin\r\n  private val message = count.map { count ->\r\n    when {\r\n      count < 0 -> \"Counter is less than 0\"\r\n      count > 0 -> \"Counter is greater than 0\"\r\n      else -> \"Counter is 0\"\r\n    }\r\n  }\r\n```\r\n\r\nremoving this code block results in the desired result. didn't expect it to call into accumulator again. thanks for the quick response!"
      },
      {
        "user": "akarnokd",
        "created_at": "2024-07-14T17:37:47Z",
        "body": "`.publish().autoConnect()`"
      }
    ]
  },
  {
    "number": 7713,
    "title": "Some Schedulers along with lockingGet will make the application hang",
    "created_at": "2024-05-19T06:10:41Z",
    "closed_at": "2024-05-19T06:22:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7713",
    "body": "Verified hanging in both 2.x and 3.x versions.\r\n\r\nThis is the minimal code to reproduce the bug:\r\n```\r\nList<Integer> res = Observables\r\n    .fromIterable(List.of(1, 2, 3, 4, 5))\r\n    .subscribeOn(Schedulers.from(Executors.newFixedThreadPool(10))\r\n    .map(x -> x * 2)\r\n    .toList()\r\n    .blockingGet();\r\n\r\nres.foreach(x -> System.out.println(\"res\" + x));\r\n```\r\n\r\nRunning this code will still successfully print out everything in res, but it will hang the application and will not exit.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7713/comments",
    "author": "floodfill",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2024-05-19T06:22:43Z",
        "body": "Not an RxJava issue. You have to shutdown the executor you created as it uses non-daemon threads that prevent the JVM from quitting."
      }
    ]
  },
  {
    "number": 7613,
    "title": "3.x: Items dropped by observeOn without backpressure errors",
    "created_at": "2023-10-19T16:29:53Z",
    "closed_at": "2023-10-19T17:13:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7613",
    "body": "RxJava version: 3.1.8\r\n\r\nI'm processing messages from `PublishProcessor` in parallel. On failure, items are put back to the processor for re-processing. I've noticed that events go missing randomly.\r\n\r\nReproduction:\r\n\r\n```java\r\nprocessor\r\n    .doOnNext(s -> logger.trace(\"next: {}\", s)) // item is here\r\n    .onBackpressureDrop(s -> { // never called\r\n        logger.error(\"!!!!!!! DROP {}\", s);\r\n        throw new RuntimeException(\"drop\");\r\n    })\r\n    .observeOn(Schedulers.single()) // switch to single thread\r\n    .doOnNext(s -> logger.trace(\"next single: {}\", s)) // item is missing here\r\n    .parallel()\r\n    .runOn(Schedulers.io())\r\n    .map(s -> { // run in parallel\r\n        logger.info(\"Processing {}\", s);\r\n        Thread.sleep(50);\r\n        logger.warn(\"Processing completed, reprocessing: {}\", s);\r\n        processor.onNext(s); // put item back\r\n        return s;\r\n    })\r\n    .sequential()\r\n    .subscribe();\r\n\r\nprocessor.onNext(\"aaa\");\r\nprocessor.onNext(\"XXX\");\r\n```\r\n\r\nRunning it gives results in under a minute, often quicker - after some time, only one of the items is being processed, the other is lost.\r\n\r\nI'm switching to `Schedulers.single()` for computation I've removed for brevity, and then process items in parallel. I found that items are lost on the `observeOn()` step - item is logged before it, and not logged after.\r\n\r\nI've read the backpressure notice for the `observeOn()`, but as I understand, in case of the backpressure problem the `MissingBackpressureException` should be thrown. That's not happening.\r\n\r\nAlso the `onBackpressureDrop()` callback is never called.\r\n\r\nReplacing `observeOn()` with `delay(0, TimeUnit.SECONDS, Schedulers.single())` seems to solve the problem, however I don't think quietly dropping items by `observeOn()` is expected here?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7613/comments",
    "author": "m-radzikowski",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2023-10-19T16:35:40Z",
        "body": "Did you serialize the `processor`? You are accessing it from possibly many threads."
      },
      {
        "user": "m-radzikowski",
        "created_at": "2023-10-19T17:13:12Z",
        "body": "No 🤦‍♂️\r\n\r\nI did not notice that Publishers are not all methods are thread-safe by default. Serializing it solves the issue. Sorry."
      }
    ]
  },
  {
    "number": 7555,
    "title": "3.x: Different behavior between blockingForEach and forEach",
    "created_at": "2023-04-17T13:54:15Z",
    "closed_at": "2023-04-18T07:21:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7555",
    "body": "Hello,\r\n\r\nI'm surprise to see that the observable:\r\n```java\r\nObservable.just(0, 1, 2)\r\n    .doOnSubscribe(ignored -> LOG.info(\"On subscribe\"))\r\n    .doOnTerminate(() -> LOG.info(\"On terminate\"))\r\n```\r\n\r\nproduce the following result with `.forEach(i -> LOG.info(\"Data: {}\", i));`:\r\n```\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - On subscribe\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - Data: 0\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - Data: 1\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - Data: 2\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - On terminate\r\n```\r\n\r\nand with `.blockingForEach(i -> LOG.info(\"Data: {}\", i));`:\r\n```\r\n15:32:04.932 [main] INFO manual.BlockingTest - On subscribe\r\n15:32:04.934 [main] INFO manual.BlockingTest - On terminate\r\n15:32:04.935 [main] INFO manual.BlockingTest - Data: 0\r\n15:32:04.936 [main] INFO manual.BlockingTest - Data: 1\r\n15:32:04.936 [main] INFO manual.BlockingTest - Data: 2\r\n```\r\n\r\nI expected to have the same result (subscribe, datas, terminate) with `blockingForEach` as with `forEach` without using any scheduler. I have the same result with `subscribe`.\r\n\r\nI tested with versions 3.1.3 and 3.1.6.\r\n\r\nThe documentation does not mention any difference between the two behaviors except that the blocking behavior blocks the current thread (which is what I want).\r\n\r\nDid I not understand correctly the difference between the two or it is a bug?\r\n\r\nThanks for your time.\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7555/comments",
    "author": "JaquierM",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2023-04-17T14:05:18Z",
        "body": "Not a bug. `blockingForEach` has an internal blocking buffer that can fill up before the control reaches its consumer callbacks.\r\n\r\nIn such synchronous cases, the upstream produces all items plus the terminal signal upon subscription, before `blockingForEach` switches to its consumer loop. With asynchronous sources, the production will usually happen on some other thread so the switch to the consumer loop pretty much immediately."
      },
      {
        "user": "JaquierM",
        "created_at": "2023-04-18T07:21:58Z",
        "body": "Ok, thanks for the answer.\r\n\r\nI was not expecting that difference. I will just move my logic from `doOnTerminate` after the blocking call."
      }
    ]
  },
  {
    "number": 7487,
    "title": "Split Observable & Flowable interfaces ",
    "created_at": "2022-11-26T16:55:31Z",
    "closed_at": "2022-11-26T18:16:34Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7487",
    "body": "Currently, the Observable & Flowable classes contain 15k+ lines of code each. This makes navigation difficult and even IntelliJ struggles handling the large file.\r\n\r\nWould it make sense to split the classes into subclasses/subinterfaces where some logical grouping is followed?\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7487/comments",
    "author": "Desislav-Petrov",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2022-11-26T18:09:29Z",
        "body": "No. This has been considered a long time ago and doesn't work. \r\n\r\nThe main reason is that discoverability becomes even worse because now you have to remember the categories of operators; your logic for grouping can be different from other people's or even ours thus there is no one good way of doing it for all. Second, it adds a lot of pollution to the codebase and the typebase of the library."
      }
    ]
  },
  {
    "number": 7476,
    "title": "[3.x] Synchronized Subject by Composition instead of Delegation",
    "created_at": "2022-10-13T10:37:10Z",
    "closed_at": "2022-11-07T22:08:14Z",
    "labels": [
      "Question",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7476",
    "body": "Version: 3.1.5\r\nRelated (old) issue: #1748 (discussing Subject.toSerialized() for v 1.x)\r\n\r\nIn my use-case, I have several Subjects; some model state (`BehaviourSubject`) and some events (`PublishSubject`). Both, new states and new events, may result from different threads. According to the docs, it is advised to call Subject.toSerialized() then, which returns a `SerializedSubject` (as `Subject`), wrapping the original subject.\r\n\r\nThis isn't ideal for me out of three reasons:\r\n1) I loose the original subject's signature, for example `BehaviousSubject.getValue()`. \r\n2) Having only `Subject`s, the distinction between Replaying one, all or none of the previous events, will be clear only from the docs or some other context, but not from the subject's type itself.\r\n3) The need to call toSerialized() isn't obvious; it's in the docs, but it would be better (and more convenient) to have it in the Subject's signature, for example `BehaviourSubject.createSerialized() → BehaviourSubject`. This would make the distinction clear as soon as the IDE of choice provides the auto-completion for available methods.\r\n\r\nFor the implementation I'd suggest to move away from the `SerializedSubject`, but compose it's synchronization inside the respective original subjects, if created as serialized subject. For the API this would be transparent, as currently only `Subject` is returned and returning the original subject's type from `toSerialized()`would not break this.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7476/comments",
    "author": "brainbytes42",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2022-10-13T11:13:37Z",
        "body": "Hi.\r\n\r\n1. `getValue()` is thread-safe thus if you keep the `BehaviorSubject` next to the `SerializedSubject`, you can still get to it.\r\n2. This can't be reasonably encoded in types. Again, if you need this information, keep it around the subject.\r\n3. This is a general issue of things that have to be learned once. No clever type signatures or API can help if those have to be learned about too. People don't read docs and don't tend to scroll through a lot of methods.\r\n\r\n> but compose it's synchronization inside the respective original subjects\r\n\r\nNo. This has been discussed before. If you are emitting from the same thread, the serialization is an overhead for no good reason.\r\n"
      }
    ]
  },
  {
    "number": 7475,
    "title": "repeatWhen bocking",
    "created_at": "2022-10-09T07:41:26Z",
    "closed_at": "2022-10-16T09:55:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7475",
    "body": "Observable.just(1)\r\n  .repeatWhen(o->o.flatMap(os->Observable.empty()))\r\n  .blockingIterable().forEach(System.out::println);\r\n\r\n// blocking on here\r\n\r\nSystem.out.println(\"Complete\");\r\n\r\nnot print Complete",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7475/comments",
    "author": "VectorWen",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2022-10-09T09:17:30Z",
        "body": "What where you trying to achieve? \r\n\r\nIn order to stop repeating, the inner sequence has to be completed, however, `flatMap`ping an empty source does not complete the sequence. You need some kind of `takeUntil` inside `repeatWhen` to trigger a completion."
      },
      {
        "user": "VectorWen",
        "created_at": "2022-10-12T03:23:18Z",
        "body": "@akarnokd e.g.\r\n\r\n```java\r\npublic class RepeatWhenMain {\r\n    private static int i = 0;\r\n\r\n    public static void main(String[] args) {\r\n        Observable.just(0)\r\n                .map(o -> i)\r\n                .repeatWhen(o -> o.flatMap(s -> {\r\n                    if (i < 15) {\r\n                        i++;\r\n                        return Observable.just(1);\r\n                    }\r\n                    //need complete, but  not completed\r\n                    return Observable.empty();\r\n                }))\r\n                .blockingIterable().forEach(System.out::println);\r\n    }\r\n}\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2022-10-12T05:43:03Z",
        "body": "Try `o.takeUntil(v -> v == 15).flatMap(etc.)`."
      },
      {
        "user": "VectorWen",
        "created_at": "2022-10-14T04:00:38Z",
        "body": "@akarnokd thank you"
      }
    ]
  },
  {
    "number": 7447,
    "title": "Firebase reporting crashes but when I try to reproduce it just logs System.err",
    "created_at": "2022-07-07T18:36:12Z",
    "closed_at": "2022-08-08T07:41:38Z",
    "labels": [
      "Question",
      "Android",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7447",
    "body": "Hello, thank you for your time, I am having crashes reported to firebase that I cannot figure out how to solve.\r\n\r\n  - [x] Please include the library version number, including the minor and patch version, in the issue text. In addition, if you'd include the major version in the title (such as `3.x`) that would be great.\r\n  rxJavaVersion = \"1.3.8\"\r\n    rxAndroidVersion = \"1.2.1\"\r\n\r\nI started looking into this crash\r\n```\r\nFatal Exception: java.lang.IllegalStateException\r\nException thrown on Scheduler.Worker thread. Add `onError` handling.\r\n```\r\n\r\nBut in our Application subclass we are doing this in onCreate()\r\n\r\n```\r\nRxJavaPlugins rxJavaPlugins = RxJavaPlugins.getInstance();\r\n        rxJavaPlugins.reset();\r\n        rxJavaPlugins.registerErrorHandler(new RxJavaErrorHandler() {\r\n            @Override\r\n            public void handleError(Throwable e) {\r\n     \r\n                e.printStackTrace();\r\n              \r\n            }\r\n        });\r\n```\r\n\r\nThe observable that is reporting this crash is\r\n\r\n```\r\nObservable.just(mSearchCriteria)\r\n                        .map((Func1<AbstractSearchCriteria, Void>) abstractSearchCriteria -> {\r\n                            mRecentSearchManager.save((FormSearchCriteria) abstractSearchCriteria);\r\n                            return null;\r\n                        })\r\n                        .compose(RxTransformer.applyLowPriorityScheduler())\r\n                        .subscribe();\r\n```\r\n\r\nI noticed that this crash is also in Firebase which could be related\r\n\r\nFatal Exception: java.lang.RuntimeException\r\nUnable to create application com.mypackage.MainApplication: java.lang.IllegalStateException: Another strategy was already registered: rx.plugins.RxJavaPlugins$1@a86d388\r\n\r\nPlease if you can provide me with a way to figure out what is going on here, when I tried to reproduce the first crash with the same exception it is logged in Logcat as System.err and it seems that the onError is never even called. But the app never crashes and Firebase is reporting as a crash.  And I never get the onErrorNotImplemented part of the crash, the substacktrace of it is IllegalStateException which I can reproduce only logs, doesnt crash app.\r\n\r\nI need to know if this is really a crash like Firebase says it is, or if RxJava is just reporting it to firebase as a crash when its really a log.\r\n\r\nThank you for your time",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7447/comments",
    "author": "jrowan3",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2022-07-07T19:01:03Z",
        "body": "You have a crash which is then not observed, hence the \"Add `onError` handling.\" message. Add an `onError` consumer to your `subscribe` methods.\r\n\r\n\"Another strategy was already registered\" happens when you call `registerErrorHandler` without a preceding `reset` or call it twice.\r\n\r\n"
      },
      {
        "user": "jrowan3",
        "created_at": "2022-07-07T19:10:57Z",
        "body": "So the registerErrorHandler doesnt catch all of the other onErrors for you @akarnokd ??"
      },
      {
        "user": "jrowan3",
        "created_at": "2022-07-07T19:13:12Z",
        "body": "also, when I run the app with the same conditions that cause the exception in the subscribe method, the app doesnt crash and it just logs the exception"
      },
      {
        "user": "akarnokd",
        "created_at": "2022-07-07T19:23:44Z",
        "body": "No. The handler receives only errors that would otherwise get lost.\r\n\r\nI can't tell why you see or don't see the logs because Android sometimes ignores \"chatty\" log sources. If `mRecentSearchManager.save` crashes, put a try-catch around it and log the exception there.\r\n\r\nBtw, RxJava 1.x is no longer supported and has all sorts of inconsistencies regarding the error handling. Please consider upgrading to RxJava 3."
      },
      {
        "user": "jrowan3",
        "created_at": "2022-07-07T19:30:26Z",
        "body": "Ok, thanks for the advice, one more thing, in the app we are only calling this once in Application onCreate, any ideas about that?\r\n```\r\nRxJavaPlugins rxJavaPlugins = \r\nRxJavaPlugins.getInstance();\r\n        rxJavaPlugins.reset();\r\n        rxJavaPlugins.registerErrorHandler(new RxJavaErrorHandler() {}\r\n\r\n```"
      },
      {
        "user": "jrowan3",
        "created_at": "2022-07-07T19:31:25Z",
        "body": "We are currently working on updating to RxJava 3, but our app is so big, the refactor is taking time."
      },
      {
        "user": "jrowan3",
        "created_at": "2022-07-07T19:34:24Z",
        "body": "Maybe i should replace it with RxJavaHooks? could you tell me the equivalent for registerErrorHandler?"
      },
      {
        "user": "akarnokd",
        "created_at": "2022-07-07T19:36:54Z",
        "body": "> onCreate, any ideas about that?\r\n\r\nNo idea, maybe you call it concurrently with other Rx code? You'd probably need to put a breakpoint on the reset line and see why it doesn't stay null for the register call.\r\n\r\n> could you tell me the equivalent for registerErrorHandler?\r\n\r\n`setOnError`"
      },
      {
        "user": "jrowan3",
        "created_at": "2022-07-07T19:58:57Z",
        "body": "@akarnokd One more question, do I have to call RxJavaHooks reset() or clear() before i setOnError for the replacement of registerErrorHandler, is it the same as RxJavaPlugins like will it still cause the \"Another strategy was already registered\" error?"
      },
      {
        "user": "akarnokd",
        "created_at": "2022-07-07T20:25:31Z",
        "body": "`setOnError`  won't cause that error, you can set multiple times."
      },
      {
        "user": "jrowan3",
        "created_at": "2022-07-07T20:27:21Z",
        "body": "@akarnokd Thank you so much!!! Ill make these changes and hopefully that resolves these crashes in Firebase although they dont really crash the app."
      }
    ]
  },
  {
    "number": 7446,
    "title": "Rxjava3 reduce with Observable",
    "created_at": "2022-07-02T02:32:47Z",
    "closed_at": "2022-08-08T11:58:33Z",
    "labels": [
      "Question",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7446",
    "body": "hello\r\n\r\nreduce function only support synchronized value.\r\n```\r\n    public final <@NonNull R> Single<R> reduce(R seed, @NonNull BiFunction<R, ? super T, R> reducer) {\r\n```\r\n\r\ncan you support async value?\r\n```\r\n    public final <@NonNull R> Single<R> reduce(R seed, @NonNull BiFunction<R, ? super T, ? extends ObservableSource<? extends R>> reducer) {\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7446/comments",
    "author": "jiqimaogou",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2022-07-02T06:24:29Z",
        "body": "Not in the plans.\r\n\r\nCan't you just use concatMap + the current reducer?"
      },
      {
        "user": "akarnokd",
        "created_at": "2022-07-02T08:16:36Z",
        "body": "Here is a way to implement it on your end:\r\n\r\n```java\r\npublic static <T, R> Single<R> reduceSingle(Observable<T> source, R seed, \r\n        BiFunction<R, ? super T, ? extends Single<? extends R>> reducer) {\r\n    return Single.defer(() -> {\r\n        AtomicReference<R> ref = new AtomicReference<R>(seed);\r\n\r\n        return source.concatMapSingle(t -> {\r\n             return reducer.apply(ref.get(), t)\r\n                           .doOnSuccess(ref::set);\r\n        })\r\n        .ignoreElements()\r\n        .andThen(Single.fromCallable(ref::get));\r\n    });\r\n}\r\n```"
      },
      {
        "user": "jiqimaogou",
        "created_at": "2022-08-20T05:39:16Z",
        "body": "is it suitable to call single.blockingget() in reduce?"
      },
      {
        "user": "jiqimaogou",
        "created_at": "2022-08-20T05:39:38Z",
        "body": "> Here is a way to implement it on your end:\r\n> \r\n> ```java\r\n> public static <T, R> Single<R> reduceSingle(Observable<T> source, R seed, \r\n>         BiFunction<R, ? super T, ? extends Single<? extends R>> reducer) {\r\n>     return Single.defer(() -> {\r\n>         AtomicReference<R> ref = new AtomicReference<R>(seed);\r\n> \r\n>         return source.concatMapSingle(t -> {\r\n>              return reducer.apply(ref.get(), t)\r\n>                            .doOnSuccess(ref::set);\r\n>         })\r\n>         .ignoreElements()\r\n>         .andThen(Single.fromCallable(ref::get));\r\n>     });\r\n> }\r\n> ```\r\n\r\n\r\nis it suitable to call single.blockingget() in reduce?\r\n\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2022-08-20T07:17:31Z",
        "body": "It can lead to non responsiveness because `blockingGet` is disconnected from the reduce sequence. I don't recommend using it."
      },
      {
        "user": "jiqimaogou",
        "created_at": "2022-08-20T08:14:12Z",
        "body": "> It can lead to non responsiveness because `blockingGet` is disconnected from the reduce sequence. I don't recommend using it.\r\n\r\nCan you please help with an example to describe the above bad practice?\r\n\r\nI also feel that all Observables should be connected, it's bad practice to use `blockingGet` to convert async to sync. But I don't know why, can you help to explain it?\r\n\r\nnot only `reduce`, but `scan`, `combinelatest`, `zip`..., why we should not call `blockingGet` in these functions?"
      },
      {
        "user": "akarnokd",
        "created_at": "2022-08-20T08:24:17Z",
        "body": "Sequences are connected if one sequence knows about the `Disposable` in another sequence(s), or vice versa, hence if one sequence gets disposed, it can notify the other sequence(s).\r\n\r\nIf you use `blockingGet`, you have to manage cancellations via other operators (`timeout`, `takeUntil`) or make sure the `blockingGet` runs on a scheduler that can be interrupted.\r\n \r\nAlso, most of the time the behavior of the secondary sequence can be joined up with the primary sequence via standard operators (e.g., `flatMap`) or combinations of standard operators.\r\n\r\nBlocking can also cause deadlocks or memory leaks in certain `Scheduler`s. Reasoning about blocking is not that easy, reasoning about a mixture of blocking and non-blocking execution requires a lot of experience and thought. So simply avoid blocking with Rx as much as possible."
      },
      {
        "user": "jiqimaogou",
        "created_at": "2022-08-20T08:27:12Z",
        "body": "> Sequences are connected if one sequence knows about the `Disposable` in another sequence(s), or vice versa, hence if one sequence gets disposed, it can notify the other sequence(s).\r\n> \r\n> If you use `blockingGet`, you have to manage cancellations via other operators (`timeout`, `takeUntil`) or make sure the `blockingGet` runs on a scheduler that can be interrupted.\r\n> \r\n> Also, most of the time the behavior of the secondary sequence can be joined up with the primary sequence via standard operators (e.g., `flatMap`) or combinations of standard operators.\r\n> \r\n> Blocking can also cause deadlocks or memory leaks in certain `Scheduler`s. Reasoning about blocking is not that easy, reasoning about a mixture of blocking and non-blocking execution requires a lot of experience and thought. So simply avoid blocking with Rx as much as possible.\r\n\r\nvery clear, thanks!"
      },
      {
        "user": "jiqimaogou",
        "created_at": "2022-08-20T08:39:51Z",
        "body": "> > Here is a way to implement it on your end:\r\n> > ```java\r\n> > public static <T, R> Single<R> reduceSingle(Observable<T> source, R seed, \r\n> >         BiFunction<R, ? super T, ? extends Single<? extends R>> reducer) {\r\n> >     return Single.defer(() -> {\r\n> >         AtomicReference<R> ref = new AtomicReference<R>(seed);\r\n> > \r\n> >         return source.concatMapSingle(t -> {\r\n> >              return reducer.apply(ref.get(), t)\r\n> >                            .doOnSuccess(ref::set);\r\n> >         })\r\n> >         .ignoreElements()\r\n> >         .andThen(Single.fromCallable(ref::get));\r\n> >     });\r\n> > }\r\n> > ```\r\n> \r\n> is it suitable to call single.blockingget() in reduce?\r\n\r\nHello my last question?\r\nwhy use defer here? what's the different with:\r\n\r\n```java\r\npublic static <T, R> Single<R> reduceSingle(Observable<T> source, R seed, \r\n        BiFunction<R, ? super T, ? extends Single<? extends R>> reducer) {\r\n        AtomicReference<R> ref = new AtomicReference<R>(seed);\r\n\r\n        return source.concatMapSingle(t -> {\r\n             return reducer.apply(ref.get(), t)\r\n                           .doOnSuccess(ref::set);\r\n        })\r\n        .ignoreElements()\r\n        .andThen(Single.fromCallable(ref::get));\r\n}\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2022-08-20T08:42:42Z",
        "body": "It makes the use of `ref` limited to any particular subscription. I.e., if you subscribed to the resulting `Single` twice, my code would behave correctly. Without `defer`, the second subscription would use the very same `ref` and overwrite each other's intermediate values."
      }
    ]
  },
  {
    "number": 7429,
    "title": "Sponsoring option on GitHub",
    "created_at": "2022-05-30T13:41:16Z",
    "closed_at": "2024-02-01T19:33:55Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7429",
    "body": "Would you be open to make it possible to sponsor this project on GitHub like I've seen other projects do?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7429/comments",
    "author": "mjovanc",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2022-05-30T14:21:13Z",
        "body": "Hi and thanks for the suggestion.\r\n\r\nAs long as GitHub doesn't want money from the project for GHA time or other services, we are fine."
      }
    ]
  },
  {
    "number": 7416,
    "title": "merge() not work as expected when invoke onError() method in ObservableEmitter",
    "created_at": "2022-05-09T04:06:03Z",
    "closed_at": "2022-05-09T07:47:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7416",
    "body": "............................System Info......................................\r\nRxJava version:2.2.7\r\nRxAndroid version:2.1.1\r\nIDE:Android Studio\r\nOS:Manjaro Linux\r\nJDK:OpenJDK 8\r\n...................................................................\r\n\r\nWhen i execute code below,i get confuse results。\r\n```\r\n     //step1:prepare sources\r\n     Observable<Integer> source1 = Observable.create(new ObservableOnSubscribe<Integer>() {\r\n            @Override\r\n            public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\r\n                Log.d(\"ConbineActivity\", \"Source1: emitting from \" + Thread.currentThread().getName());\r\n                emitter.onNext(1);\r\n                emitter.onNext(2);\r\n                emitter.onError(new Exception(\"No Network\"));\r\n                emitter.onNext(3);\r\n                emitter.onComplete();\r\n            }\r\n        }).subscribeOn(Schedulers.io());\r\n\r\n        Observable<Integer> source2 = Observable.create(new ObservableOnSubscribe<Integer>() {\r\n            @Override\r\n            public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\r\n                Log.d(\"ConbineActivity\", \"Source2: emitting from \" + Thread.currentThread().getName());\r\n                emitter.onNext(4);\r\n                emitter.onNext(5);\r\n                emitter.onNext(6);\r\n                emitter.onComplete();\r\n            }\r\n        });\r\n  \r\n        \r\n       //step2:merge\r\n       Observable.merge(source1, source2)\r\n                .subscribe(new Observer<Integer>() {\r\n                    @Override\r\n                    public void onSubscribe(Disposable d) {\r\n                        Log.d(\"ConbineActivity\", \"onSubscribe\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(Integer i) {\r\n\r\n                        try {\r\n                            Thread.sleep(500);\r\n                        } catch (InterruptedException e) {\r\n                            e.printStackTrace();\r\n                        }\r\n\r\n                        Log.d(\"ConbineActivity\", i + \" \" + Thread.currentThread().getName());\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(Throwable e) {\r\n                        e.printStackTrace();\r\n                        Log.d(\"ConbineActivity\", \"onError\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onComplete() {\r\n                        Log.d(\"ConbineActivity\", \"onComplete\");\r\n                    }\r\n                });\r\n    }\r\n```\r\noutput1:\r\n```\r\n onSubscribe\r\n Source2: emitting from main\r\n Source1: emitting from RxCachedThreadScheduler-1\r\n 4 main\r\n  W/System.err: java.lang.Exception: No Network\r\n //some exception output code\r\n D/ConbineActivity: onError\r\n```\r\n**Question1:Why onNext(1) and onNext(2) is not output before exception output ?**\r\n\r\n\r\nThere maybe another output。\r\noutput2:\r\n``` onSubscribe\r\n Source1: emitting from RxCachedThreadScheduler-1\r\n Source2: emitting from main\r\n 1 RxCachedThreadScheduler-1\r\n 4 RxCachedThreadScheduler-1\r\n 5 RxCachedThreadScheduler-1\r\n 6 RxCachedThreadScheduler-1\r\n 2 RxCachedThreadScheduler-1\r\n 3 RxCachedThreadScheduler-1\r\n W/System.err: java.lang.Exception: No Network\r\n //some exception code\r\n D/ConbineActivity: onError\r\n```\r\nIn that output2 print is all on RxCachedThreadScheduler-1,but in output1 \"4\" is printed on main thread.\r\n\r\n**Question2:Why output sometimes print on RxCachedThreadScheduler-1 thread sometimes on main thead?**\r\n......................................................\r\nThanks!",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7416/comments",
    "author": "1322739583",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2022-05-09T07:47:52Z",
        "body": "A1) By default, errors can cut ahead of items. `merge` reuses the emitting thread and if that thread is blocked down the line, other sources may run to termination. When `merge` can run again, it will first check for errors and ignore any value from any source.\r\n\r\nA2) Depends on which source wins as you are racing the main thread with the background thread."
      }
    ]
  },
  {
    "number": 7415,
    "title": "3.x can RxJava support concatMapEagerSingle?",
    "created_at": "2022-04-22T10:15:47Z",
    "closed_at": "2022-04-22T11:00:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7415",
    "body": "Hello, Rxjava has`concatMapEager`\r\n\r\n```\r\n    public final <R> Observable<R> concatMapEager(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper) {\r\n```\r\n\r\nthe mapper returns an ObservableSource.\r\n\r\nin my case\r\nmapper returns a Single.\r\n```\r\n    public final <R> Observable<R> concatMapEagerSingle(@NonNull Function<? super T, ? extends SingleSource<? extends R>> mapper) {\r\n```\r\n\r\ncan RxJava support `concatMapEagerSingle`?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7415/comments",
    "author": "jiqimaogou",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2022-04-22T11:00:33Z",
        "body": "There are no plans to support this type of conversion. Use the `toObservable` to convert your `Single`."
      }
    ]
  },
  {
    "number": 7394,
    "title": "Is it possible to use backpressure with parallel?",
    "created_at": "2022-02-18T16:04:46Z",
    "closed_at": "2022-03-10T09:13:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7394",
    "body": "        Flowable.fromIterable(items)\r\n                .parallel()\r\n                .runOn(Schedulers.io())\r\n                .map(someFunction())\r\n                .sequential()\r\n                .subscribe(someSubscriber);\r\n\r\nIf i run this code, map function will process asynchronously in 12 threads (or in other count of threads, depends on pc), but subscription will be in one thread. The problem is that 12 threads wait for the subscription finished, and only then they will take other 12 items\r\n\r\nI need someFunction not to wait subscriber, and at the same time, i need it to work asynchronously.\r\n\r\nAt the same time, i need subscriber to work in one thread\r\n\r\nHow to solve such a problem?\r\n\r\n ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7394/comments",
    "author": "ArsenyClean",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2022-02-18T16:16:58Z",
        "body": "What you are seeing is the effect of backpressure on `sequential`. Apply `observeOn` after it with another scheduler to not bog down the parallel threads."
      }
    ]
  },
  {
    "number": 7370,
    "title": "Update the object emitted by Single in async way",
    "created_at": "2021-12-07T13:19:56Z",
    "closed_at": "2021-12-07T13:33:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7370",
    "body": "Hello, Could you please clarify whether I can update the object emitted by Single in async way by several methods?\r\nI have the folliwing code:\r\n```\r\nreturn Single.just(order)\r\n                .flatMap(o -> updateProducerInfo(o))\r\n                .flatMap(o -> updateCustomerInfo(o));\r\n\r\nprivate Single<Order> updateProducerInfo(Order order) {\r\n        // takes a long time\r\n    }\r\nprivate Single<Order> updateCustomerInfo(Order order) {\r\n        // takes a long time\r\n    }\r\n```\r\nIs there a way to execute these methods in parallel to reduce the overall execution time?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7370/comments",
    "author": "YauheniZarembin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-12-07T13:31:22Z",
        "body": "Yes, provided both update methods touch independent parts of `Order`:\r\n\r\n```java\r\nreturn Single.zip(\r\n              updateProducerInfo(order).subscribeOn(Schedulers.io()),\r\n              updateCustomerinfo(order).subscribeOn(Schedulers.io()),\r\n              (a, b) -> order);\r\n```"
      },
      {
        "user": "YauheniZarembin",
        "created_at": "2021-12-07T13:33:24Z",
        "body": "@akarnokd Thanks a lot!"
      }
    ]
  },
  {
    "number": 7327,
    "title": "How can I check completion of saving which is processed  in async way?",
    "created_at": "2021-08-26T13:36:31Z",
    "closed_at": "2021-08-26T16:16:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7327",
    "body": "Hi. could you please clarify how I can wait async execution of saving?\r\nI Have the following methods in repository class.\r\n```\r\npublic Completable save(Book book) {\r\n        // logic to save book in DB\r\n    }\r\n\r\npublic Single<Boolean> exist(Book book) {\r\n        // logic to check if book exists in DB\r\n    }\r\n```\r\nAnd there is method in service that uses _save_ method from repository\r\n```\r\npublic Single<Book> saveBook(Book book) {\r\n        bookRepo.save(book);\r\n        return Sing.just(book);\r\n    }\r\n```\r\n\r\nThe problem is that after _saveBook_ method execution the book may not be in the database as saving is processed  in async way.\r\nHow can I change me _saveBook_ method using _exist_ method to be sure that after _saveBook_ method execution I will have the book in DB?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7327/comments",
    "author": "YauheniZarembin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-08-26T13:53:24Z",
        "body": "You can compose them via `flatMapCompletable`, for example:\r\n\r\n```java\r\npublic Single<Book> saveBook(Book book) {\r\n    return exist(book)\r\n           .flatMapCompletable(exists -> exists ? Completable.complete() : bookRepo.save(book))\r\n           .andThen(Single.just(book));\r\n```"
      },
      {
        "user": "YauheniZarembin",
        "created_at": "2021-08-26T14:03:26Z",
        "body": "No, maybe I should clarify my case.\r\n\r\nAt First I have nothing in DB. Then I save book by _saveBook_ method from service.\r\nAfter that I want to update this book.\r\nBut when I try to receive book from DB for update I have nothing, as save is still executing very long in asycn way and DB is empty.\r\n\r\nSo in _saveBook_ method I want to wait to be sure that when I need to update book it will be in DB."
      },
      {
        "user": "akarnokd",
        "created_at": "2021-08-26T14:11:39Z",
        "body": "It depends on how you structured your save-update workflow.\r\n\r\nOne possibility is to cache the `saveBook` above; it will make sure the save runs at most once and there will be a value ready after, indicating the save completed.\r\n\r\n```java\r\nSingle<Book> bookCached = saveBook(book).cache();\r\nbookCached.subscribe(/* trigger the save */);\r\n\r\n// later\r\nbookCached\r\n  .flatMap(book -> updateBook(book))\r\n  .subscribe(/* trigger update */)\r\n```"
      },
      {
        "user": "YauheniZarembin",
        "created_at": "2021-08-26T14:59:49Z",
        "body": "Thanks!"
      },
      {
        "user": "YauheniZarembin",
        "created_at": "2021-08-26T15:05:32Z",
        "body": "@akarnokd Maybe I foung what I want.\r\nCould you please review is that a good way to check?\r\n\r\n```\r\npublic Single<Book> saveBook(Book book) {\r\n        bookRepo.save(book);\r\n        \r\n        boolean saved = Single.defer(() -> bookRepo.exist(book))\r\n                .repeat()\r\n                .takeUntil(b -> b)\r\n                .ignoreElements()\r\n                .blockingAwait(10000, TimeUnit.MILLISECONDS);\r\n                \r\n        if (saved) {\r\n            return Single.just(book);\r\n        } else {\r\n            //error\r\n        }\r\n  \r\n    }\r\n```\r\n\r\nСan this code be simplified?"
      },
      {
        "user": "akarnokd",
        "created_at": "2021-08-26T15:44:28Z",
        "body": "That repeat will be very eagle, perhaps waiting a second may be preferable: `repeatWhen(o -> o.delay(1, TimeUnit.SECONDS))`.\r\n\r\nIf you block, there is no value in returning a `Single`. Also depending on where this code runs, you may not be allowed to block."
      },
      {
        "user": "YauheniZarembin",
        "created_at": "2021-08-26T16:16:30Z",
        "body": "Thanks a lot!"
      }
    ]
  },
  {
    "number": 7317,
    "title": "What‘s the reason that \"relaying the upstream's Disposable directly is not allowed in RxJava\"?",
    "created_at": "2021-08-24T08:24:13Z",
    "closed_at": "2021-08-24T15:50:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7317",
    "body": "Thanks check my question.\r\nWhen I implement `ObservableOperator`, find the comment \"Note that relaying the upstream's Disposable directly is not allowed in RxJava\" above observable operator `lift` sample.\r\nI searched net, but found nobody explains the reason.  If i follow the sample for `lift`， the class seems complex a little bit, but relay the upstream's Disposable,  the class seems more clean.\r\n```\r\npublic final class CustomObserver<T> implements Observer<T>, Disposable {\r\n\r\n     final Observer<? super String> downstream;\r\n\r\n     Disposable upstream;\r\n\r\n     public CustomObserver(Observer<? super String> downstream) {\r\n         this.downstream = downstream;\r\n     }\r\n\r\n     // In the subscription phase, the upstream sends a Disposable to this class\r\n     // and subsequently this class has to send a Disposable to the downstream.\r\n     // Note that relaying the upstream's Disposable directly is not allowed in RxJava\r\n     @Override\r\n     public void onSubscribe(Disposable d) {\r\n         if (upstream != null) {\r\n             d.dispose();\r\n         } else {\r\n             upstream = d;\r\n             downstream.onSubscribe(this);\r\n         }\r\n     }\r\n\r\n     @Override\r\n     public void onNext(T item) {\r\n         ... do something...\r\n     }\r\n\r\n     @Override\r\n     public void onError(Throwable throwable) {\r\n         downstream.onError(throwable);\r\n     }\r\n\r\n     @Override\r\n     public void onComplete() {\r\n         downstream.onComplete();\r\n     }\r\n\r\n     @Override\r\n     public void dispose() {\r\n         upstream.dispose();\r\n     }\r\n\r\n     @Override\r\n     public boolean isDisposed() {\r\n         return upstream.isDisposed();\r\n     }\r\n }\r\n\r\n```\r\n\r\n```\r\npublic final class CustomObserver<T> implements Observer<T>, Disposable {\r\n\r\n     final Observer<? super String> downstream;\r\n\r\n     Disposable upstream;\r\n\r\n     public CustomObserver(Observer<? super String> downstream) {\r\n         this.downstream = downstream;\r\n     }\r\n\r\n     // Not follow sample says\r\n     @Override\r\n     public void onSubscribe(Disposable d) {\r\n         downstream.onSubscribe(d);\r\n     }\r\n\r\n     @Override\r\n     public void onNext(T item) {\r\n         ... do something...\r\n     }\r\n\r\n     @Override\r\n     public void onError(Throwable throwable) {\r\n         downstream.onError(throwable);\r\n     }\r\n\r\n     @Override\r\n     public void onComplete() {\r\n         downstream.onComplete();\r\n     }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7317/comments",
    "author": "chxchen",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-08-24T10:17:14Z",
        "body": "It breaks operator fusion, which is detected by checking the `Disposable` sent via `onSubscribe`. If, for example, the upstream supports fusion and you relay that `Disposable` to the downstream, it will skip your operator and will talk to the upstream directly.\r\n\r\nIn general, it is rare not to intercept `dispose()` in an operator."
      },
      {
        "user": "chxchen",
        "created_at": "2021-08-24T11:14:32Z",
        "body": "> It breaks operator fusion, which is detected by checking the `Disposable` sent via `onSubscribe`. If, for example, the upstream supports fusion and you relay that `Disposable` to the downstream, it will skip your operator and will talk to the upstream directly.\r\n> \r\n> In general, it is rare not to intercept `dispose()` in an operator.\r\n\r\nThank you!\r\nDo you mean if an custom operator by `lift` is very simple, Relaying the upsteam's disposable does not make hidden error, but recommand to implement `Disposable` and delivery `this` to downstream?  (The simple operator just pass values to downstream.)"
      },
      {
        "user": "akarnokd",
        "created_at": "2021-08-24T11:28:03Z",
        "body": "Yes."
      },
      {
        "user": "chxchen",
        "created_at": "2021-08-24T15:50:47Z",
        "body": "> Yes.\r\nThanks a lot\r\n"
      }
    ]
  },
  {
    "number": 7310,
    "title": "o.reactivex.rxjava3.exceptions.CompositeException$ExceptionOverview    3.X",
    "created_at": "2021-08-09T03:48:17Z",
    "closed_at": "2021-08-09T07:02:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7310",
    "body": "Multiple exceptions (2) |-- java.util.NoSuchElementException: null at java.util.Vector.lastElement(Vector.java:503) |-- java.util.NoSuchElementException: null at java.util.Vector.lastElement(Vector.java:503)\r\n\r\nio.reactivex.rxjava3.exceptions.CompositeException:2 exceptions occurred.\r\nio.reactivex.rxjava3.internal.observers.LambdaObserver.onError(LambdaObserver.java:80)\r\n......\r\nCaused  \r\nio.reactivex.rxjava3.exceptions.CompositeException$ExceptionOverview:Multiple exceptions (2)\r\njava.util.NoSuchElementException: null\r\nat java.util.Vector.lastElement(Vector.java:503)\r\njava.util.NoSuchElementException: null\r\nat java.util.Vector.lastElement(Vector.java:503)",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7310/comments",
    "author": "MrEricChen",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-08-09T07:02:27Z",
        "body": "This is not an issue with RxJava. You have Vector somewhere that is empty thus no last element."
      }
    ]
  },
  {
    "number": 7288,
    "title": "Using withLatestFrom completes without values if other publisher is delayed",
    "created_at": "2021-07-01T17:29:38Z",
    "closed_at": "2021-07-05T11:27:49Z",
    "labels": [
      "Question",
      "Documentation",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7288",
    "body": "**Version**:  3.0.12\r\n\r\nI am not sure if this is per-design and specification (could not find this), but is it really expected that:\r\n\r\n```\r\n      Flowable<Integer> integerFlowable = Flowable.just(1, 2, 3);\r\n      Flowable<Integer> delayedFlowable = Flowable.just(10).delay(1, TimeUnit.SECONDS);\r\n\r\n      integerFlowable.withLatestFrom(delayedFlowable, Integer::sum)\r\n              .test()\r\n              .assertValueCount(3)\r\n              .assertComplete();\r\n```     \r\n\r\nfails with:\r\n\r\n```\r\njava.lang.AssertionError: Value counts differ; expected: 3 but was: 0 (latch = 0, values = 0, errors = 0, completions = 1)\r\nExpected :3\r\nActual   :0 (latch = 0, values = 0, errors = 0, completions = 1)\r\n<Click to see difference>\r\n```\r\n\r\nIf it is, then Javadoc needs to be improved, it is not stated anywhere that this will complete with no values of the other publisher is emitting item after a delay. Of course this is a simple example, but you get the point. If these would be two database calls and second comes emits after the first one, you get nothing? :confused: \r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7288/comments",
    "author": "ivansenic",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-07-01T17:37:58Z",
        "body": "It is by design. If the upstream ends before any of the other sources had a chance to signal, the outcome is an empty sequence."
      },
      {
        "user": "ivansenic",
        "created_at": "2021-07-02T08:45:28Z",
        "body": "Thanks @akarnokd. I was checking the PR you made and you said this behavior is unlike the `combineLatest`, but in the test I did I also get similar error for:\r\n\r\n```\r\n      Flowable<Integer> integerFlowable = Flowable.just(1, 2, 3);\r\n      Flowable<Integer> delayedFlowable = Flowable.just(10).delay(1, TimeUnit.SECONDS);\r\n\r\n      Flowable.combineLatest(integerFlowable, delayedFlowable, Integer::sum)\r\n              .test()\r\n              .assertValueCount(3)\r\n              .assertComplete();\r\n```\r\n```\r\njava.lang.AssertionError: Value counts differ; expected: 3 but was: 0 (latch = 1, values = 0, errors = 0, completions = 0)\r\nExpected :3\r\nActual   :0 (latch = 1, values = 0, errors = 0, completions = 0)\r\n```\r\nOK here latch is reported as 1 and not the completion. So is this also expected per design? \r\n\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2021-07-02T08:58:07Z",
        "body": "Since you run with async flows, you have to use `.awaitDone(5, TimeUnit.SECONDS)` before asserting to let the code finish.\r\n\r\nAlso I don't think `combineLatest` would fit your intentions. `integerFlowable` would rush to \"3\" and you'd only get one combination of \"3-10\".\r\n\r\nIf you want all combinations, such as \"1-10\", \"2-10\", \"3-10\", you'll need `concatMap` and cached secondary flow:\r\n\r\n```java\r\nFlowable<Integer> integerFlowable = Flowable.just(1, 2, 3);\r\nFlowable<Integer> delayedFlowable = Flowable.just(10).delay(1, TimeUnit.SECONDS).cache();\r\n\r\nintegerFlowable.concatMap(main -> delayedFlowable.map(other -> Integer.sum(main, other)))\r\n              .test()\r\n              .awaitDone(5, TimeUnit.SECONDS)\r\n              .assertResult(11, 12, 13);\r\n```"
      },
      {
        "user": "ivansenic",
        "created_at": "2021-07-02T09:00:35Z",
        "body": "Thanks a lot @akarnokd, very informative. :+1: "
      }
    ]
  },
  {
    "number": 7281,
    "title": "Methos to() requires mock in unit test",
    "created_at": "2021-06-08T16:17:32Z",
    "closed_at": "2021-06-09T07:39:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7281",
    "body": "Hi. could you please clarify question?\r\nI Have the following method\r\n```\r\npublic Single<Book> load(String bookName, String author) {\r\n        return bookRepo.load(bookName)\r\n                .switchIfEmpty(Observable.error(EntityNotFoundException::new))\r\n                .toList()\r\n                .flatMap(books-> bookService.loadbookByAuthor(Observable.fromIterable(books), autor)\r\n                        .switchIfEmpty(Maybe.error(() -> new ValidationErrorException()))\r\n                        .toSingle());\r\n    }\r\n```\r\n\r\nAnd I have unit test for this method. which works\r\n```\r\npublic void shouldValidatePolicyExists() {\r\n        when(bookRepo.load(any())).thenReturn(Observable.empty());\r\n\r\n        testObject.load(request).test()\r\n                .assertError(EntityNotFoundException.class)\r\n    }\r\n```\r\n\r\nI want to get rid of toList() in my method and found the following way\r\n```\r\npublic Single<Book> load(String bookName, String author) {\r\n        return bookRepo.load(bookName)\r\n                .switchIfEmpty(Observable.error(EntityNotFoundException::new))\r\n                .to(books-> bookService.loadbookByAuthor(books, autor)\r\n                        .switchIfEmpty(Maybe.error(() -> new ValidationErrorException()))\r\n                        .toSingle());\r\n    }\r\n```\r\nBut unit test does not work for this method implementation.\r\nIt does not return EntityNotFoundException and requires bookService is mocked.\r\nCould you please clarify why ?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7281/comments",
    "author": "YauheniZarembin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-06-08T16:43:48Z",
        "body": "How is `loadbookByAuthor` implemented?\r\n\r\nSince your original used `flatMap`, the error just skipped the `loadbookByAuthor` entirely. With `to`, it is always executed and receives the error via `books`."
      },
      {
        "user": "YauheniZarembin",
        "created_at": "2021-06-08T17:02:41Z",
        "body": "@akarnokd \r\n`loadbookByAuthor` just filters observable\r\n\r\n```\r\npublic Maybe<Book> loadbookByAuthor (Observable<Book> books, String author) {\r\n        return books\r\n                .filter(txInTerm -> TransactionRoutine.isEffectiveOnDate(txInTerm, onDate))\r\n                .firstElement();\r\n    }\r\n```\r\nBut, the problem is that I can't change it.\r\n\r\nThen I will reformulate the question : \r\nHow can I change the first method to get rid of toList() without changing `loadbookByAuthor ` ?\r\n\r\nNow I convert Observable `toList()` and then make from it Observable again. For many books I suppose It will affect performance.\r\n\r\nThank you!\r\n\r\n\r\n\r\n\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2021-06-08T17:46:54Z",
        "body": "It is a bit convoluted to do it. Try\r\n\r\n```java\r\nbookRepo.load(bookName)\r\n    .switchIfEmpty(Observable.error(EntityNotFoundException::new))\r\n    .publish(o -> \r\n        o.take(1)\r\n        .flatMap(v -> \r\n            bookService.loadbookByAuthor(o.startWith(v), autor)   \r\n            .switchIfEmpty(Maybe.error(() -> new ValidationErrorException()))\r\n            .toObservable()\r\n        )\r\n    )\r\n    .toSingle()\r\n```"
      },
      {
        "user": "YauheniZarembin",
        "created_at": "2021-06-09T07:39:53Z",
        "body": "Thank you!"
      }
    ]
  },
  {
    "number": 7242,
    "title": "Flowable.fromPublisher work called on wrong thread",
    "created_at": "2021-04-20T15:33:18Z",
    "closed_at": "2021-04-26T09:38:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7242",
    "body": "Hello! I need to implement some custom behavior in my code. I need to emit new data in my `Flowable` every time when some event occurred. To get this working I wrote the next logic:\r\n```\r\nval signalProcessor = BehaviorProcessor.createDefault(Unit)\r\n\r\nfun getData(id: Int): Flowable<Int> {\r\n      return Flowable.fromPuiblisher(signalProcessor).map { \r\n          Log.d(TAG, \"$id Current work thread name: ${Thread.currentThread().name}\")\r\n          // Some logic with id parameter here\r\n          id\r\n      }.subscribeOn(Schedulers.io())\r\n}\r\n\r\nfun sendSignal() {\r\n    signalProcessor.onNext(Unit)\r\n}\r\n\r\nfun testSubscibe() {\r\n    getData(0).subscribe {\r\n        // Some logic with result\r\n        Log.d(TAG, \"$it Result received\")\r\n    }\r\n    getData(1).subscribe {\r\n        // Some logic with result\r\n        Log.d(TAG, \"$it Result received\")\r\n    }\r\n    val thread1 = Thread {\r\n        Log.d(TAG, \"Signal from Thread1\")\r\n        sendSignal()\r\n    }.apply {\r\n        name = \"Thread1\"\r\n    }\r\n    val thread2 = Thread {\r\n        Log.d(TAG, \"Signal from Thread2\")\r\n        sendSignal()\r\n    }.apply {\r\n        name = \"Thread2\"\r\n    }\r\n\r\n    Thread.sleep(100)\r\n    thread1.start()\r\n    Thread.sleep(100)\r\n    thread2.start()\r\n}\r\n```\r\n\r\n## Expected result:\r\n```\r\n0 Current work thread name: RxCachedThread-****\r\n0 Result received\r\n1 Current work thread name: RxCachedThread-****\r\n1 Result received\r\nSignal from Thread1\r\n0 Current work thread name: RxCachedThread-****\r\n0 Result received\r\n1 Current work thread name: RxCachedThread-****\r\n1 Result received\r\nSignal from Thread2\r\n0 Current work thread name: RxCachedThread-****\r\n0 Result received\r\n1 Current work thread name: RxCachedThread-****\r\n1 Result received\r\n```\r\n## Real result:\r\n```\r\n0 Current work thread name: RxCachedThread-****\r\n0 Result received\r\n1 Current work thread name: RxCachedThread-****\r\n1 Result received\r\nSignal from Thread1\r\n0 Current work thread name: Thread1\r\n0 Result received\r\n1 Current work thread name: Thread1\r\n1 Result received\r\nSignal from Thread2\r\n0 Current work thread name: Thread2\r\n0 Result received\r\n1 Current work thread name: Thread2\r\n1 Result received\r\n```\r\n\r\nWhen `subscribe` method called the worker thread started from `Schedulers.io()` as expected. But when `sendSignal` called all work in `map` always runs on a thread from which `sendSignal` was called and `subscribeOn` is ignored.\r\n\r\n## Environment\r\n**RxJava version**: 3.0.11",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7242/comments",
    "author": "personshelldon",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-04-20T16:06:11Z",
        "body": "`subscribeOn` affects where the subscription side-effect happen and not generally where the emission happens, especially with subjects and processors. You have to use `observeOn`.\r\n\r\nIn your case, `subscribeOn`'s side-effect is to emit the initial value of the `BehaviorProcessor` on the IO thread. Since `subscribeOn` does not affect `onNext` calls and `BehaviorProcessor` emits on whatever thread calls `onNext`, you see the non-io threads in the log.\r\n\r\nTwo more notes:\r\n- `BehaviorProcessor` is already a `Flowable` thus `Flowable.fromPublisher` has no effect.\r\n- You should not call `onNext` from multiple threads without proper serialization; use `toSerialized()` on the processor ensure this."
      }
    ]
  },
  {
    "number": 7221,
    "title": "IllegalAccessError: FlowableDoOnLifecycle: 2.2.3",
    "created_at": "2021-04-06T04:44:17Z",
    "closed_at": "2021-04-06T06:16:20Z",
    "labels": [
      "Question",
      "Android"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7221",
    "body": "I am getting the following **crash only for the release versions** of my app in Firebase:\r\n\r\n**Illegal class access: 'io.reactivex.internal.operators.flowable.e$a' attempting to access 'io.reactivex.internal.functions.Functions$d' (declaration of 'io.reactivex.internal.operators.flowable.e$a' appears in base.apk!classes2.dex)**\r\n\r\nI get this crash on `subscribe` method call while trying to create a flowable for uploading image to the server in Android, i.e. :\r\n\r\ncompositeDisposable.add(createFlowable(accessToken, multipartBodyPart, imageUploadForAuditRequestBody)\r\n                .subscribeOn(schedulerProvider.io())\r\n                .debounce(200, TimeUnit.MILLISECONDS)\r\n                .observeOn(schedulerProvider.ui())\r\n                .doOnSubscribe { mvpView.showLoading(\"Uploading image...\") }\r\n                .subscribe(  // Crashing here\r\n                        {\r\n                           // do something\r\n                        },\r\n                        { throwable: Throwable? ->\r\n                            // do something\r\n                        }\r\n                ))\r\n\r\nprivate fun createFlowable(accessToken: String, multipartBodyPart: MultipartBody.Part, imageUploadForAuditRequestBody: MutableMap<String, RequestBody>): Flowable<ResponseBody> {\r\n        return Flowable.create(\r\n                { emitter: FlowableEmitter<ResponseBody> ->\r\n                    try {\r\n                        val response = RestClient.getRestClient().get().onFileUpload(\r\n                                \"Bearer \" + accessToken,\r\n                                imageUploadForAuditRequestBody, multipartBodyPart).blockingGet()\r\n                        emitter.onNext(response)\r\n                    } catch (e: Exception) {\r\n                        Timber.e(\"Exception %s\", e.localizedMessage)\r\n                        emitter.tryOnError(e)\r\n                    }\r\n                }, BackpressureStrategy.LATEST)\r\n    }\r\n\r\n\r\nPlease refer the following stack trace:\r\nFatal Exception: java.lang.IllegalAccessError: Illegal class access: 'io.reactivex.internal.operators.flowable.e$a' attempting to access 'io.reactivex.internal.functions.Functions$d' (declaration of 'io.reactivex.internal.operators.flowable.e$a' appears in base.apk!classes2.dex)\r\n       at io.reactivex.internal.operators.flowable.FlowableDoOnLifecycle$SubscriptionLambdaSubscriber.request(FlowableDoOnLifecycle.java:101)\r\n       at io.reactivex.internal.subscribers.LambdaSubscriber.request(LambdaSubscriber.java:114)\r\n       at io.reactivex.internal.operators.flowable.FlowableInternalHelper$RequestMax.accept(FlowableInternalHelper.java:220)\r\n       at io.reactivex.internal.operators.flowable.FlowableInternalHelper$RequestMax.accept(FlowableInternalHelper.java:216)\r\n       at io.reactivex.internal.subscribers.LambdaSubscriber.onSubscribe(LambdaSubscriber.java:52)\r\n       at io.reactivex.internal.operators.flowable.FlowableDoOnLifecycle$SubscriptionLambdaSubscriber.onSubscribe(FlowableDoOnLifecycle.java:73)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.onSubscribe(FlowableObserveOn.java:294)\r\n       at io.reactivex.subscribers.SerializedSubscriber.onSubscribe(SerializedSubscriber.java:70)\r\n       at io.reactivex.internal.operators.flowable.FlowableDebounceTimed$DebounceTimedSubscriber.onSubscribe(FlowableDebounceTimed.java:78)\r\n       at io.reactivex.internal.operators.flowable.FlowableSubscribeOn.subscribeActual(FlowableSubscribeOn.java:46)\r\n       at io.reactivex.Flowable.subscribe(Flowable.java:14805)\r\n       at io.reactivex.internal.operators.flowable.FlowableDebounceTimed.subscribeActual(FlowableDebounceTimed.java:45)\r\n       at io.reactivex.Flowable.subscribe(Flowable.java:14805)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn.subscribeActual(FlowableObserveOn.java:56)\r\n       at io.reactivex.Flowable.subscribe(Flowable.java:14805)\r\n       at io.reactivex.internal.operators.flowable.FlowableDoOnLifecycle.subscribeActual(FlowableDoOnLifecycle.java:38)\r\n       at io.reactivex.Flowable.subscribe(Flowable.java:14805)\r\n       at io.reactivex.Flowable.subscribe(Flowable.java:14742)\r\n       at io.reactivex.Flowable.subscribe(Flowable.java:14661)\r\n       at com.yulu.ops.yuzenapp.newYuzen.ui.audit.AuditPresenter.uploadImageForAuditFailData(AuditPresenter.java:77)",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7221/comments",
    "author": "otto-25",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-04-06T06:16:20Z",
        "body": "This is likely an issue with configuration of your multidex release. We are a Java library and can't help much in such Android matters. Please ask this question on StackOverflow"
      }
    ]
  },
  {
    "number": 7180,
    "title": "2.1.9 version - java.lang.ArrayIndexOutOfBoundsException in RxJavaPlugins.java",
    "created_at": "2021-02-04T09:25:53Z",
    "closed_at": "2021-02-13T09:11:44Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7180",
    "body": "Process: com.trimble.ag.precisioniq.g12.tnl, PID: 1822\r\nb.a.c.f: java.lang.ArrayIndexOutOfBoundsException: length=0; index=0\r\nat b.a.g.a.a(RxJavaPlugins.java:366)\r\nat b.a.h.a(Observable.java:11201)\r\nat b.c.d.a.runscreen.ui.c.a(xxxx.java:36)\r\nat c.a.d.h(xxxx.java:124)\r\nat androidx.lifecycle.LiveData$ObserverWrapper.activeStateChanged(LiveData.java:436)\r\nat androidx.lifecycle.LiveData$LifecycleBoundObserver.onStateChanged(LiveData.java:394)\r\nat androidx.lifecycle.LifecycleRegistry$ObserverWithState.dispatchEvent(LifecycleRegistry.java:361)\r\nat androidx.lifecycle.LifecycleRegistry.forwardPass(LifecycleRegistry.java:300)\r\nat androidx.lifecycle.LifecycleRegistry.sync(LifecycleRegistry.java:339)\r\nat androidx.lifecycle.LifecycleRegistry.moveToState(LifecycleRegistry.java:145)\r\nat androidx.lifecycle.LifecycleRegistry.handleLifecycleEvent(LifecycleRegistry.java:131)\r\nat androidx.fragment.app.Fragment.performStart(Fragment.java:2637)",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7180/comments",
    "author": "JayasreePattabiraman",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-02-04T10:50:10Z",
        "body": "Looks like you have a custom Observable implementation that fails at subscription time with `ArrayIndexOutOfBoundsException`."
      }
    ]
  },
  {
    "number": 7158,
    "title": "intervalRange behaviour",
    "created_at": "2021-01-23T18:25:25Z",
    "closed_at": "2021-01-24T13:25:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7158",
    "body": "As per documentation `intervalRange` : \r\n>The sequence completes immediately after the last value (start + count - 1) has been reached.\r\n\r\nWhich mean `doOnComplete` is called directly once the last interval is reached (and not _completed_)\r\n\r\n```\r\nprivate fun launchQuestionGame() {\r\n        Flowable\r\n            .fromIterable(mQuestions.asIterable()) // mQuestions contains 3 items\r\n\r\n            .zipWith(\r\n                startTimeIntervalAndCancelItUponUnUneButtonClick(mQuestions.size + 1)\r\n\r\n                    .observeOn(AndroidSchedulers.mainThread())\r\n                    .doOnEach {\r\n                        onEachIntervalEmittion(it)\r\n                    }\r\n\r\n                    .repeat(mQuestions.size.toLong()), // repeat the interval mQuestions.size.toLong() times.\r\n\r\n                BiFunction { t1: Question, _: Long ->\r\n                    Timber.d(t1.toString())\r\n                    doOnCompleteEachFile(t1)\r\n                })\r\n\r\n            .doOnComplete {\r\n                Timber.d(\"doOnComplete\")\r\n                doOnCompleteAllFiles()\r\n            }\r\n\r\n            .subscribe()\r\n    }\r\n```\r\n\r\n2021-01-23 18:38:49.526 17549-17549/ Item 1\r\n2021-01-23 18:38:53.531 17549-17549/ Item 2\r\n2021-01-23 18:38:57.527 17549-17549/ Item 3\r\n2021-01-23 18:38:57.544 17549-17549/ doOnComplete\r\n\r\nI tried to delay before `doOnComplete` but it doesn't work.\r\n\r\nIs there anyway to have `doOnComplete` called after the last interval is finished ?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7158/comments",
    "author": "cloudshooterhuman",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-01-23T19:11:42Z",
        "body": "I don't understand your question. If you want to execute `doOnComplete` with a similar delay as between the items, append a timer:\r\n\r\n```kotlin\r\n\r\n     .zipWith ( ... )\r\n     .concatWith(Completable.timer(4, TimeUnit.SECONDS))\r\n     .doOnComplete {\r\n           Timber.d(\"doOnComplete\")\r\n           doOnCompleteAllFiles()\r\n      }\r\n```"
      },
      {
        "user": "cloudshooterhuman",
        "created_at": "2021-01-23T19:56:19Z",
        "body": "Thank you it did  work gracfully. just curious, why `delay` didn't have the same effect as ` .concatWith(Completable.timer(4, TimeUnit.SECONDS))` ?\r\n"
      }
    ]
  },
  {
    "number": 7156,
    "title": "[question] Multiple doFinally and their order",
    "created_at": "2021-01-22T07:13:16Z",
    "closed_at": "2021-01-22T09:00:28Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7156",
    "body": "Hi all,\r\n\r\nConsider the following:\r\n```\r\nObservable.just(1,  2, 3)\r\n\t    \t.map(s -> {\r\n\t    \t\tif (s == 2) {\r\n\t    \t\t\tthrow new RuntimeException();\r\n\t    \t\t}\r\n\t    \t\treturn s;\r\n\t    \t})\r\n    \t\t.doFinally(() -> System.out.println(\"error 1\"))\r\n    \t\t.doFinally(() -> System.out.println(\"error 2\"))\r\n    \t\t.blockingSubscribe();\r\n```\r\n\r\nThis prints:\r\n```\r\nerror 2\r\nerror 1\r\n```\r\n\r\nIf I move the `map` operator after the two `doFinally`, it prints:\r\n```\r\nerror 1\r\nerror 2\r\n```\r\n\r\nI would expect that, no matter where the `map` operator is placed, I should have always get the second printout of errorX (error1 and error2 in that order). Can somebody explain this behavior?\r\n\r\nI 'm using RxJava 2.2.16",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7156/comments",
    "author": "dmandalidis",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-01-22T09:00:28Z",
        "body": "When `map` is after `finally`, the crash will first cancel the upstream, and on the return angle, it invokes the finally actions top-down:\r\n\r\n```\r\nmap.crash\r\n    map.cancel\r\n        doFinally.cancel // 2nd\r\n            doFinally.cancel // 1st\r\n                just.cancel\r\n            doFinally.action -> print error 1\r\n        doFinally.action -> print error 2\r\n    map.onError\r\n        observer.onError\r\n```\r\n\r\nWhen the `map` is before the finally's, the error is propagated to the end observer and the finally actions are invoked bottom-up.\r\n\r\n```\r\nmap.crash\r\n    map.cancel\r\n        just.cancel\r\n    map.onError\r\n        doFinally.onError // 1st\r\n            doFinally.onError // 2nd\r\n                observer.onError\r\n            doFinally.action -> print error 2\r\n        doFinally.action -> print error 1\r\n```"
      }
    ]
  },
  {
    "number": 7137,
    "title": "2.x: Question about threading and doFinally()",
    "created_at": "2020-12-22T10:34:42Z",
    "closed_at": "2020-12-22T12:07:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7137",
    "body": "I am using RxJava 2 on Android. The modifyUi() function inside doFinally() should be called from main thread only.\r\n```\r\ntask_1\r\n    .subscribeOn(Schedulers.io())\r\n    .doOnSuccess { ... }\r\n    .flatMap { \r\n        task_2\r\n            .subscribeOn(Schedulers.io()) \r\n    }\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .doFinally { modifyUi() }\r\n```\r\nHowever, there are certain edge cases where observeOn() is ignored and doFinally() is fired in background.\r\n\r\nQuestion 1: What these cases can be? So far, I've discovered only one of them - a very fast disposing of the chain. If I add\r\n```\r\n.doOnSubscribe { it.dispose() }\r\n```\r\nright after doFinally(), observeOn() becomes ignored, so doFinally() is fired from background. Why is that and what the other cases can be?\r\n\r\nQuestion 2: Is there any reliable way to clean up the chain once it's done that can be set to a particular thread? As I see, doFinally() fails in some cases. Should I resort to duplicating the cleanup code in onSuccess() and onError() methods of the observer/consumer in subscribe()?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7137/comments",
    "author": "BorisLaskov",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-12-22T10:51:43Z",
        "body": "`doFinally` can run when the downstream disposes on whatever thread it is on, thus `observeOn` has likely no effect. You can apply `unsubscribeOn` after `doFinally` to make sure any dispose call is routed to the desired thread."
      },
      {
        "user": "BorisLaskov",
        "created_at": "2020-12-22T12:07:10Z",
        "body": "Thank you for the clarification :)"
      }
    ]
  },
  {
    "number": 7078,
    "title": "RxJava Branching/Conditional operators [question][feature]",
    "created_at": "2020-09-18T15:45:41Z",
    "closed_at": "2020-09-18T18:48:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7078",
    "body": "We had this problem a while ago that we wanted to have branches for our flow. To set an example:\r\n\r\n```\r\nupstream\r\n    .filter{ condition }\r\n    .map {...}\r\n    .filter { !condition }\r\n    .map {...}\r\n    .subscribe(...) // both maps generate same type of output\r\n```\r\nWhich obviously does not work. Because the conditions are simply contradictory to each other. But we needed to process all the items but in different ways.\r\n\r\nI am aware of grouping and other operators that can help with this need but all of them come down to having if else statements somewhere in the code.\r\n\r\nSo I have one question and one suggestion.\r\n1) Is there any operator that can help branch the item flows in a linear way? (Not having inner blocks with if statements)\r\n2) Is it a good idea to create a branching (or conditional) operator (like `parallel()/sequential()` in Flowable) that creates branches of the flow and merges them in the end? I wanted to contribute by adding this feature but thought it might be a good idea to ask first. Something like the following for the above example:\r\n```\r\nupstream\r\n    .branch()\r\n    .if { condition }\r\n    .then {...}\r\n    .if { !condition }\r\n    .then {...}\r\n    .else {...}\r\n    .merge()\r\n    .subscribe(...) // both maps generate same type of output\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7078/comments",
    "author": "saeedntt",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-09-18T15:59:30Z",
        "body": "You can use `publish` to split the flow and merge them back:\r\n\r\n```java\r\n\r\nsource.publish(shared ->\r\n   merge(shared.filter()..., shared.filter()...)\r\n)\r\n```"
      },
      {
        "user": "saeedntt",
        "created_at": "2020-09-18T16:11:06Z",
        "body": "That's Great.\r\nSo you don't think adding a branch operator is a good idea? It keeps the stream creation linear."
      },
      {
        "user": "akarnokd",
        "created_at": "2020-09-18T18:48:54Z",
        "body": "Not a good idea, the usage pattern differs from the generic RxJava approach.\r\n\r\nAt least you seem to be on Kotlin so you can add any DSL you see fit via extension methods."
      }
    ]
  },
  {
    "number": 7068,
    "title": "Flowable.range() operator drops intermediate events",
    "created_at": "2020-08-31T10:29:46Z",
    "closed_at": "2020-08-31T11:11:05Z",
    "labels": [
      "Question",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7068",
    "body": "RxJava version: 3.0.6\r\nKotlin version: 1.4.0\r\nJava version: OpenJDK 1.8.0_265\r\n\r\nIt seems that RxJava drops intermediate range events when mapping using an asynchronous flatMap with a 100ms delay. This cannot be the intended behaviour as events should never be dropped except I specify it. This also happens when using Observable<T>. It happens in Java aswell. If I remove the delay, it does not skip events.\r\n\r\n```kotlin\r\nimport io.reactivex.rxjava3.core.Flowable\r\nimport java.util.concurrent.TimeUnit\r\n\r\nfun main() {\r\n    Flowable.range(0, 10)\r\n        .doOnNext { println(\"run: $it\") }\r\n        .concatMap {\r\n            Flowable.range(0, 1000)\r\n                .flatMap { stubFunction(it) }\r\n                .doOnNext { println(\"iteration: $it\") }\r\n        }\r\n        .blockingSubscribe()\r\n}\r\n\r\nprivate fun stubFunction(iteration: Int) : Flowable<Int> {\r\n    return Flowable.just(iteration)\r\n        .delay(100, TimeUnit.MILLISECONDS)\r\n}\r\n```\r\n\r\n```java\r\nimport io.reactivex.rxjava3.core.Flowable;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class App {\r\n    public static void main(String[] args) {\r\n        Flowable.range(0, 20)\r\n                .doOnNext(run -> System.out.println(\"run: \" + run))\r\n                .concatMap(run -> Flowable.range(0, 1000)\r\n                        .flatMap(App::stubFunction)\r\n                        .doOnNext(iteration -> System.out.println(\"iteration: \" + iteration))\r\n                        .subscribeOn(Schedulers.io()))\r\n                .blockingSubscribe();\r\n    }\r\n\r\n    private static Flowable<Integer> stubFunction(int iteration) {\r\n        return Flowable.just(iteration)\r\n                .delay(100, TimeUnit.MILLISECONDS);\r\n    }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7068/comments",
    "author": "itsandreramon",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-08-31T11:11:05Z",
        "body": "There is no event loss but because of `flatMap` and `delay`, you see the `iteration: ` printed out of order. You can see this by changing `blockingSubscribe` to:\r\n\r\n```java\r\n   .count()\r\n   .blockingSubscribe(v -> System.out.printf(\"%n%n---------%n%s\", v));\r\n```\r\n\r\nWhich prints the expected 20 * 1000 = 20000."
      }
    ]
  },
  {
    "number": 7056,
    "title": "3.x: Observable.window(count, skip) completes windows when there are no observers",
    "created_at": "2020-08-16T18:36:01Z",
    "closed_at": "2020-08-20T08:28:00Z",
    "labels": [
      "Question",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7056",
    "body": "RxJava version: 3.0.5\r\nOS: Android\r\n\r\nHi, in addition to #7048. Here are two failed test cases:\r\n\r\n**Test case 1:**\r\n```kotlin\r\n@Test\r\npublic void cancelAfterAbandonmentSize() {\r\n    PublishSubject<Integer> ps = PublishSubject.create();\r\n    AtomicReference<Observable<Integer>> firstWindow = new AtomicReference<>();\r\n    TestObserver<Observable<Integer>> to = ps.window(3, 1)\r\n            .doOnNext((window) -> {\r\n                if (!firstWindow.compareAndSet(null, window)) {\r\n                    window.subscribe();\r\n                }\r\n            })\r\n            .test();\r\n\r\n    assertTrue(ps.hasObservers());\r\n\r\n    ps.onNext(1);\r\n    ps.onNext(2);\r\n\r\n    to.dispose();\r\n\r\n    firstWindow.get()\r\n            .test()\r\n            .assertValues(1, 2);\r\n}\r\n```\r\n\r\nThis test will fail with following description:\r\n`Value count differs; expected: 2 [1, 2] but was: 1 [1] (latch = 0, values = 1, errors = 0, completions = 1)`\r\n\r\n**Test case 2:**\r\n```kotlin\r\n@Test\r\npublic void cancelAfterAbandonmentSize() {\r\n    PublishSubject<Integer> ps = PublishSubject.create();\r\n\r\n    TestObserver<Integer> to = ps.window(3)\r\n            .flatMap((window) -> window.delaySubscription(1, TimeUnit.SECONDS))\r\n            .test();\r\n\r\n    ps.onNext(1);\r\n    ps.onNext(2);\r\n    ps.onNext(3);\r\n\r\n    to.dispose();\r\n\r\n    to.assertValues(1, 2, 3);\r\n}\r\n```\r\n\r\nThis test will fail with following description:\r\n`Value count differs; expected: 3 [1, 2, 3] but was: 0 [] (latch = 1, values = 0, errors = 0, completions = 0, disposed!)`\r\n\r\n**Question**\r\nThis is correct behavior?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7056/comments",
    "author": "amihusb",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-08-16T19:47:33Z",
        "body": "Test case 1 does not subscribe to the first window in time thus the window gets abandoned and completed. This is the expected behavior.\r\n\r\nTest case 2 disposes the sequence and thus the abandoned windows will have no opportunity to emit their only item."
      },
      {
        "user": "arkivanov",
        "created_at": "2020-08-28T19:12:45Z",
        "body": "@akarnokd There is a notice in the JavaDocs:\r\n\r\n> Note that ignoring windows or subscribing later (i.e., on another thread) will result in\r\n> so-called window abandonment where a window may not contain any elements. In this case, subsequent\r\n> elements will be dropped until the condition for the next window boundary is satisfied. The behavior is\r\n> a trade-off for ensuring upstream cancellation can happen under some race conditions.\r\n\r\nCould you kindly describe in more detail what kind of race conditions? From my point of view we can consider windows \"active\" once emitted, and care only about disposal of windows. And since they are `UnicastSubject`s, there can be only one subscription and only one disposal per window. E.g. if downstream is disposed but there is an \"active\" window, then upstream stays subscribed, unless the last window is (possibly subscribed) and disposed.\r\n\r\nI would appreciate your comments here."
      },
      {
        "user": "akarnokd",
        "created_at": "2020-08-28T19:26:42Z",
        "body": "> there can be only one subscription\r\n\r\nUp to one subscription. If such subscription ever happens then the upstream may never know it has to stop sending events. The race can happen in some operators, such as `flatMap` for example, which hard-cuts its `onNext` processing upon an asynchronous cancellation, thus the emitted inner window may never see an observer/subscriber.\r\n\r\n"
      },
      {
        "user": "arkivanov",
        "created_at": "2020-08-28T19:50:12Z",
        "body": "Thanks for such a good explanation, now it's clear."
      }
    ]
  },
  {
    "number": 7054,
    "title": "The worker thread failed to start work using subscribeOn(Schedulers.computation())",
    "created_at": "2020-08-14T01:34:18Z",
    "closed_at": "2020-08-15T06:52:54Z",
    "labels": [
      "Question",
      "Android",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7054",
    "body": "**The libraries** that I included:\r\n\r\n    implementation 'io.reactivex.rxjava3:rxandroid:3.0.0'\r\n    implementation 'io.reactivex.rxjava3:rxjava:3.0.5'\r\n    implementation 'com.trello.rxlifecycle4:rxlifecycle-components:4.0.0'\r\n\r\n**My code** is just like this:\r\n\r\n```Java\r\n    private void doLogin() {\r\n        Observable.create((ObservableOnSubscribe<Boolean>) emitter -> {\r\n            Log.i(\"starting\");\r\n            while (true) {\r\n                try {\r\n                    boolean success = mLoginModule.login();\r\n                    if (!success) {\r\n                        KLog.d(\"login failed! No. \" + mLoginTimes + \", \" + ToolKits.getLastError());\r\n\r\n                        mLoginTimes++;\r\n                        emitter.onNext(false);\r\n                    } else {\r\n                        emitter.onNext(true);\r\n                        emitter.onComplete();\r\n                        break;\r\n                    }\r\n\r\n                    if (mLoginTimes > 100) {\r\n                        emitter.onComplete();\r\n                        break;\r\n                    }\r\n\r\n                    Thread.sleep(1000);\r\n                } catch (Exception e) {\r\n                }\r\n            }\r\n        }).subscribeOn(Schedulers.computation())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .compose(bindToLifecycle())\r\n                .subscribe(new Observer<Boolean>() {\r\n                    @Override\r\n                    public void onSubscribe(@NonNull Disposable d) {\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(@NonNull Boolean result) {\r\n                        onLoginResult(result);\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(@NonNull Throwable e) {\r\n                        Log.i(\"onError\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onComplete() {\r\n                        Log.i(\"onComplete\");\r\n                    }\r\n                });\r\n    }\r\n\r\npublic class MyActivity extends RxAppCompatActivity {\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n          ..........\r\n                 doLogin();\r\n          ..........\r\n\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**What I encountered** was sometimes the login work just failed to start, even the log output \"starting\" did not come out. But when the activity was destroyed, onComplete got printed out. So I guess there's something wrong with Schedulers.computation. Then I changed it to subscribeOn(Schedulers.newThread()) and it seemed just ok.\r\n\r\nWhat's the problem? Did I misuse something or is there a bug in RxJava or RxAndroid?\r\nThanks!\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7054/comments",
    "author": "lancewoo",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-08-14T07:01:49Z",
        "body": "`Schedulers.computation` is the wrong kind of scheduler to be used with blocking operations. It has a limited number of threads so when it is exhausted by blocking flows, you'll end up with hangs."
      },
      {
        "user": "lancewoo",
        "created_at": "2020-08-15T01:31:56Z",
        "body": "> \r\n> \r\n> `Schedulers.computation` is the wrong kind of scheduler to be used with blocking operations. It has a limited number of threads so when it is exhausted by blocking flows, you'll end up with hangs.\r\n\r\nYes, login() is a blocking method.\r\nThat's the only place where I used RxJava in the whole application, nowhere else. Does it concern with other threads created in other Android ways? Which scheduler would be suggested then in this situation, `Schedulers.newThread()` or `Schedulers.io()`?\r\nThanks!"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-08-15T06:52:54Z",
        "body": "The io scheduler."
      }
    ]
  },
  {
    "number": 7045,
    "title": "Is it possible to run a multistage pipeline in parallel?",
    "created_at": "2020-08-02T05:25:22Z",
    "closed_at": "2020-08-02T15:22:18Z",
    "labels": [
      "Question",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7045",
    "body": "Hi, suppose I have a query that entails a multi-stage pipeline of operations (e.g., `map(x -> intenseComputation(x)).map(...).map(...)...`)\r\nIs it possible to implement such a query using multiple threads where each thread handles a stage of the computation (e.g., a single `map`)?\r\n\r\nTo illustrate,\r\ninput items -> map1 (assigned to thread1) -> map2 (thread2) -> map3 (thread3) ... -> Observer\r\n\r\nI read the documentation of RxJava and checked many related materials, but now I only found codes and tutorials that taught me how to distribute the input items to multiple threads, where each thread runs the same query (e.g., using `flatMap(o -> ...subscribeOn(...))`).\r\n\r\nCan someone help me to answer this question or refer me to some related materials? \r\nThanks a lot!\r\n\r\nBTW, I am using RxJava version 3.05.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7045/comments",
    "author": "Ohyoukillkenny",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-08-02T06:51:45Z",
        "body": "Put `observeOn` between the stages."
      },
      {
        "user": "Ohyoukillkenny",
        "created_at": "2020-08-02T15:22:18Z",
        "body": "thanks a lot. I confuse the usage of observeOn with subscribeOn where `observeOn` acts only downstream."
      }
    ]
  },
  {
    "number": 7044,
    "title": "Are observers also disposed when combineLatest(iterable) is disposed?",
    "created_at": "2020-08-01T04:13:52Z",
    "closed_at": "2020-08-01T06:43:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7044",
    "body": "I used combineLatest with List<Observerable>\r\ndisposable = Observable.combineLatest(observerList)\r\n\r\nMy question is that When I dispose disposable,\r\nobservables in observerList are also disposed?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7044/comments",
    "author": "wolru",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-08-01T06:43:11Z",
        "body": "Yes."
      }
    ]
  },
  {
    "number": 7037,
    "title": "3.x: Why merge(ObservableSource<ObservableSource>> sources) is different from merge(Iterable<ObservableSource>> sources) or mergeArray(ObservableSource... sources)?",
    "created_at": "2020-07-22T02:41:36Z",
    "closed_at": "2020-07-22T05:12:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7037",
    "body": "Hi.\r\nmerge(Iterable<ObservableSource>> sources) redicts to fromIterable(sources).flatMap(Functions.identity()) and\r\nmergeArray(ObservableSource... sources) redicts to fromArray(sources).flatMap(Functions.identity()).\r\n\r\nSimilarly i think  that merge(ObservableSource<ObservableSource>> sources) can redirect to sources.flatMap(Functions.identity()).\r\n\r\nIs there a reason that method use ObservableFlatMap directly?\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7037/comments",
    "author": "suribada",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-07-22T05:12:58Z",
        "body": "It has already the right type and thus can be directly fed into the flatMap implementation."
      }
    ]
  },
  {
    "number": 7036,
    "title": "Subscribe to Flowable using Subscriber and return Completable that completes when subscription is done",
    "created_at": "2020-07-20T12:52:37Z",
    "closed_at": "2020-07-20T19:16:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7036",
    "body": "I'm trying to implement the following:\r\n\r\nGiven a `src` `Flowable` and a `dst` `Subscriber`, create a `write` method that forwards all the emissions from `src` to `dst` and returns a `Completable`. That is:\r\n\r\n```java\r\nFlowable<T> src = ...\r\nSubscriber<T> dst = ...\r\nCompletable completable = write(src, dst); // How to implement this?\r\n```\r\n\r\nThe returned `Completable` should behave as follows:\r\n\r\n- Complete when `src` completes\r\n- Fail when `src` fails\r\n- Fail when `src` gets disposed\r\n- When disposed, cause `dst` to fail (i.e. 'canceling' the write operation)\r\n\r\nSo pretty much like the standard `Publisher#subscribe(Subscriber)` method, but returning a hot `Completable` capable of tracking the subscription state.\r\n\r\n**Is there a simple way to do this** (i.e. by using a couple of operators)?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7036/comments",
    "author": "gabrielhuff",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-07-20T16:37:25Z",
        "body": "No. Your requirements make the signal coordination complicated. You can try with subjects, `doOnX` and `merge` methods to wire up the signals and outcomes.\r\n\r\nSuch arrangement is quite uncommon and I wonder why don't you simply use `subscribe(Consumer, Consumer, Action)` so that you can cancel it and capture the terminal signals?"
      },
      {
        "user": "gabrielhuff",
        "created_at": "2020-07-20T19:16:58Z",
        "body": "Fair enough. It is indeed a very specific use case. Thanks for the help nevertheless."
      }
    ]
  },
  {
    "number": 7026,
    "title": "toList accepts an empty observable",
    "created_at": "2020-07-12T17:57:44Z",
    "closed_at": "2020-07-12T18:39:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7026",
    "body": "`V 3.0.4`\r\n\r\ni have this situation where there is an empty Observable:\r\n\r\n```kotlin\r\nObservable.fromCallable {\r\n    dataController.getImages() // empty array.\r\n}\r\n    .subscribeOn(Schedulers.io())\r\n    .filter { it.isNotEmpty() }\r\n    .doOnNext { images ->\r\n        Log.i(\"RxText\", images.toString()) // not passed \r\n        ...\r\n    }\r\n    .concatMap { Observable.fromIterable(it) }\r\n    .map { image ->\r\n        Log.i(\"RxText\", image.toString()) // not passed \r\n        ...\r\n    }\r\n    .toList()\r\n    .toObservable()\r\n    .map {\r\n        Log.i(\"RxText\", it.toString()) // pass, Empty array !\r\n        ...\r\n    }\r\n    ...\r\n```\r\n\r\nas you can see, transforming operation `toList` has accepted an empty observable as empty array, but that not what we expected.\r\n\r\nhere is a question for `toList` operation, should it accepts an empty Observable?\r\nit's Ok to say that `toList` operation returned a `Single` that should have `onSuccess` or `onError` event so it must returned an empty list because `Single` does't have `Single.empty()` anyway, and that lead us to the second question:\r\n\r\nwhy `filter` operation _(in the code above)_ dose't cut the sequence and stop the down stream?\r\n\r\nis it a normal behavior for filtering and `to` operations!",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7026/comments",
    "author": "anastr",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-07-12T18:39:41Z",
        "body": "`toList` always produces a list, an empty list if its upstream is empty. Thus even if you filtered out items before it, `toList` will still create an empty list. You have to filter this empty list out after if you don't need it:\r\n\r\n```kotlin\r\n.toList()\r\n.toObservable()\r\n.filter { it.isNotEmpty() }\r\n.map {\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 7022,
    "title": "Keep alive subscription to the Observable after exception occurred in the Consumer",
    "created_at": "2020-07-04T03:42:57Z",
    "closed_at": "2020-07-04T06:47:19Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7022",
    "body": "_RxJava version: 2.2.19_\r\n\r\nThis code:\r\n\r\n```java\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.functions.Consumer;\r\n\r\npublic class Main {\r\n\r\n  public static void main(String[] args) {\r\n    Observable.range(0, 6).subscribe(new Consumer<Integer>() {\r\n      public void accept(Integer integer) throws Exception {\r\n        if (integer != 3) {\r\n          System.out.println(\"Integer: \" + integer);\r\n        } else {\r\n          someOperation();\r\n        }\r\n      }\r\n    }, new Consumer<Throwable>() {\r\n      public void accept(Throwable throwable) throws Exception {\r\n        System.out.println(\"Error!\");\r\n        throwable.printStackTrace();\r\n      }\r\n    });\r\n  }\r\n\r\n  static void someOperation() {\r\n    throw new IllegalStateException(\"error in consumer\");\r\n  }\r\n}\r\n```\r\n\r\nThis is the log:\r\n\r\n```java\r\nInteger: 0\r\nInteger: 1\r\nInteger: 2\r\nError!\r\njava.lang.IllegalStateException: error in consumer\r\n\tat com.rx.test.Main$1.accept(Main.java:14)\r\n\tat com.rx.test.Main$1.accept(Main.java:9)\r\n\tat io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:63)\r\n\tat io.reactivex.internal.operators.observable.ObservableRetryPredicate$RepeatObserver.onNext(ObservableRetryPredicate.java:69)\r\n\tat io.reactivex.internal.operators.observable.ObservableRange$RangeDisposable.run(ObservableRange.java:64)\r\n\tat io.reactivex.internal.operators.observable.ObservableRange.subscribeActual(ObservableRange.java:35)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:12284)\r\n\tat io.reactivex.internal.operators.observable.ObservableRetryPredicate$RepeatObserver.subscribeNext(ObservableRetryPredicate.java:112)\r\n\tat io.reactivex.internal.operators.observable.ObservableRetryPredicate.subscribeActual(ObservableRetryPredicate.java:41)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:12284)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:12270)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:12198)\r\n\tat com.rx.test.Main.main(Main.java:9)\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n- Is it possible to keep the observable subscription alive after the exception?\r\n\r\n- Is there any way to continue consuming the stream?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7022/comments",
    "author": "felipeska",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-07-04T06:47:19Z",
        "body": "> Is it possible to keep the observable subscription alive after the exception?\r\n\r\nNo. Exceptions terminate the flow.\r\n\r\n> Is there any way to continue consuming the stream?\r\n\r\nYes, do not crash into RxJava. Wrap your call into try-catch."
      }
    ]
  },
  {
    "number": 7021,
    "title": "StackOverflowError: stack size 1038KB",
    "created_at": "2020-07-01T06:17:24Z",
    "closed_at": "2020-07-13T18:31:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7021",
    "body": "FATAL EXCEPTION: OkHttp Dispatcher\r\n    Process: com.tatweer.vehicledashboardapp.dev, PID: 20773\r\n    java.lang.StackOverflowError: stack size 1038KB\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n        at io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(SingleFlatMapCompletable.java:102)\r\n    \tat io.reactivex.internal.operators.single.SingleFlatMapCompletable$FlatMapCompletableObserver.onComplete(Single",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7021/comments",
    "author": "Elswah",
    "comments": [
      {
        "user": "Elswah",
        "created_at": "2020-07-01T06:18:30Z",
        "body": "dependency\r\n'io.reactivex.rxjava2:rxjava:2.2.3'\r\n'com.squareup.okhttp3:okhttp:3.11.0'"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-07-01T09:29:25Z",
        "body": "If you chain too many synchronous operations, you may end up with such StackOverflowErrors. What is your code trying to do?"
      }
    ]
  },
  {
    "number": 7019,
    "title": "App Crash when ObserveOn Android main thread",
    "created_at": "2020-06-28T07:54:41Z",
    "closed_at": "2020-06-28T08:00:53Z",
    "labels": [
      "Question",
      "Android",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7019",
    "body": "**Issue** \r\nI try to implement observeOn **AndroidSchedulers.mainThread()** But it always crash \r\nif I remove this line it working fine \r\n\r\n       myObservable = Observable.fromArray(intArray);\r\n       myObservable.subscribeOn(Schedulers.io())\r\n        .observeOn(AndroidSchedulers.mainThread()).\r\n         subscribeWith(getObserver());\r\n\r\n**Error Log** \r\n\r\n        java.lang.BootstrapMethodError: Exception from call site #1 bootstrap method\r\n        at io.reactivex.rxjava3.android.schedulers.AndroidSchedulers.<clinit>(AndroidSchedulers.java:33)\r\n        at io.reactivex.rxjava3.android.schedulers.AndroidSchedulers.mainThread(AndroidSchedulers.java:44)\r\n        at com.example.rxjavasample.SecondActivity.onCreate(SecondActivity.java:38)\r\n\r\n\r\n**Gradle dependencies** \r\n\r\n\r\n    implementation \"io.reactivex.rxjava3:rxjava:3.0.4\"\r\n    implementation 'io.reactivex.rxjava3:rxandroid:3.0.0' ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7019/comments",
    "author": "RanjithTawari",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-06-28T08:00:53Z",
        "body": "You probably have to set your project to Java 8 mode:\r\n\r\n```groovy\r\ncompileOptions {\r\n    sourceCompatibility JavaVersion.VERSION_1_8\r\n    targetCompatibility JavaVersion.VERSION_1_8\r\n}\r\n```"
      },
      {
        "user": "RanjithTawari",
        "created_at": "2020-06-29T08:34:36Z",
        "body": "yes its fixed "
      }
    ]
  },
  {
    "number": 7015,
    "title": "Rxjava documents can be written in more detail. The hierarchical relationship is not very clear",
    "created_at": "2020-06-26T11:56:45Z",
    "closed_at": "2020-06-26T13:17:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7015",
    "body": "Rxjava documents can be written in more detail. The hierarchical relationship is not very clear",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7015/comments",
    "author": "pengzhengfa",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-06-26T12:06:46Z",
        "body": "> Rxjava documents can be written in more detail.\r\n\r\nThere exist several books that do a great job of explaining RxJava. I suggest reading any of them.\r\n\r\n> The hierarchical relationship is not very clear\r\n\r\nWhat hierarchical relationships?\r\n\r\n"
      },
      {
        "user": "pengzhengfa",
        "created_at": "2020-06-26T12:54:25Z",
        "body": "stay README.md The documents in the document are not written clearly, which can be optimized or an official document website can be opened"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-06-26T13:12:49Z",
        "body": "You are welcome to improve any of our documents or create a website that describes RxJava from your desired perspective."
      }
    ]
  },
  {
    "number": 7008,
    "title": "3.x: UndeliverableException when using mergeArray",
    "created_at": "2020-06-11T13:25:14Z",
    "closed_at": "2020-06-29T05:34:37Z",
    "labels": [
      "Question",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7008",
    "body": "I came across an issue in neXenio/RxAndroidBleServer#4 and I think it's a bug in RxJava and not an issue with how I use it. Please consider the following example:\r\n\r\n```java\r\n@Test\r\npublic void test() throws Exception {\r\n    doMultipleFailingTasks()\r\n            .test()\r\n            .await(1, TimeUnit.SECONDS);\r\n}\r\n\r\nprivate Completable doMultipleFailingTasks() {\r\n    return Completable.mergeArray(doFailingTask(\"A\"), doFailingTask(\"B\"))\r\n            .doOnSubscribe(disposable -> System.out.println(\"Starting multiple tasks\"))\r\n            .doOnError(throwable -> System.out.println(\"Error: \" + throwable))\r\n            .doFinally(() -> System.out.println(\"Stopped multiple tasks\"));\r\n}\r\n\r\nprivate Completable doFailingTask(String name) {\r\n    return Completable.error(IllegalStateException::new)\r\n            .subscribeOn(Schedulers.io())\r\n            .doOnSubscribe(disposable -> System.out.println(\"Starting task \" + name))\r\n            .doFinally(() -> System.out.println(\"Stopped task \" + name));\r\n}\r\n```\r\n\r\nThis would result in an unhandled `IllegalStateException` with the following output:\r\n\r\n```\r\nStarting multiple tasks\r\nStarting task A\r\nStarting task B\r\nError: java.lang.IllegalStateException\r\nStopped task A\r\nStopped multiple tasks\r\nStopped task B\r\njava.lang.IllegalStateException  <-- unhandled\r\n```\r\n\r\nThe same code however works as expected when removing the `.subscribeOn(Schedulers.io())` line from `doFailingTask` with the following output:\r\n\r\n```\r\nStarting multiple tasks\r\nStarting task A\r\nStopped task A\r\nError: java.lang.IllegalStateException\r\nStopped multiple tasks\r\n```\r\n\r\nThe problem seems to be a race condition when two or more errors are emitted at the same time in different threads. I do know about `Completable.mergeArrayDelayError`, however that does not work for my use case as the merged completables are ongoing tasks that never complete (if no error occurs). ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7008/comments",
    "author": "Steppschuh",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-06-11T17:08:20Z",
        "body": "This is not a bug in RxJava. When sources race with errors, `mergeArray` probabilistically picks one of them to emit and the other goes to the global error handler.\r\n\r\nYou have to decide what to do with the excess error that can't be delivered, for example:\r\n- install a global error handler and log/suppress it,\r\n- add an error handler operator to the `doFailingTask` that turns the error into a value or completion,\r\n- create an union of (value, error) as the flow type and work with those."
      }
    ]
  },
  {
    "number": 6998,
    "title": "3.x Amb operator is not cancelling the other sources once one source completes",
    "created_at": "2020-05-26T22:01:16Z",
    "closed_at": "2020-05-27T15:48:34Z",
    "labels": [
      "Question",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6998",
    "body": "Using library io.reactivex.rxjava3:rxjava:3.0.3\r\n\r\nDepending on the order you declare the sources on the amb operator, the source gets cancelled or not. See code snippet below:\r\n```Kotlin\r\n@Test\r\nfun ambTest() {\r\n  var just = Maybe.just(\"test\")\r\n  val cancellable = object : Cancellable {\r\n    var cancelled = false\r\n    override fun cancel() {\r\n      cancelled = true\r\n    }\r\n  }\r\n  val never = Maybe.create<String> { it.setCancellable(cancellable) }\r\n  var value: String? = null\r\n  // This doesn't work\r\n  Maybe.amb(listOf(just, never)).subscribe { value = it }\r\n  // But this works\r\n  // Maybe.amb(listOf(never, just)).subscribe { value = it }\r\n  assertThat(value).isEqualTo(\"test\")\r\n  // The following line fails if you declare just first instead of never.\r\n  assertThat(cancellable.cancelled).isTrue()\r\n}\r\n```\r\nI would expect that regardless of the order in which you pass the MaybeSources to the `amb` operator, whenever one of them completes, the other are cancelled.\r\n\r\nI found this bug by accident when writing another unit test which sometimes worked and sometimes didn't work. It seemed like a race condition but when I reduced it to the above example it is no longer random. In my case I think it was random because I was building the list from a HashSet so maybe the order was randomly changing each time.\r\n\r\nIf there is a workaround for this, that would be great. Maybe using some schedulers fixes it?\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6998/comments",
    "author": "JurgenCruz",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-05-27T07:57:24Z",
        "body": "If a source completes while the subscriptions are still going on, those sources will not be subscribed and thus not get cancelled.\r\n\r\nWhat is your use case that needs your sources to always start?"
      },
      {
        "user": "JurgenCruz",
        "created_at": "2020-05-27T15:22:32Z",
        "body": "So you are saying that the sources that are not cancelled are also not subscribed and thus should not be active anyway? I had not considered that.\r\n\r\nThe use case in my program was that the sources might be hot sources that are waiting for a cancelation signal to cleanup. Also, even if it is not hot, if the method has side effects, even if it is not subscribed, the side effects will be called. This can be mitigated with a `defer` I guess.\r\n\r\nIs there a way to test if `never` was actually never subscribed to? if I can do an `or` such that it was never subscribed or was cancelled, my unit test will pass."
      },
      {
        "user": "akarnokd",
        "created_at": "2020-05-27T15:25:02Z",
        "body": "There is the `doOnSubscribe` operator that gets called if a subscription is passing through."
      },
      {
        "user": "JurgenCruz",
        "created_at": "2020-05-27T15:26:10Z",
        "body": "Thanks, I'll give it a try and update with my findings.\r\nEdit:\r\n\r\nIt works as expeted. new Unit Test:\r\n\r\n```kotlin\r\n  @Test\r\n  fun ambTest() {\r\n    val just = Maybe.just(\"test\")\r\n    var cancelled = false\r\n    var subscribed = false\r\n    val never = Maybe.create<String> {\r\n      it.setCancellable { cancelled = true }\r\n    }.doOnSubscribe { subscribed = true }\r\n    var value: String? = null\r\n    // This works\r\n    Maybe.amb(listOf(just, never)).subscribe { value = it }\r\n    // This also works\r\n    // Maybe.amb(listOf(never, just)).subscribe { value = it }\r\n    assertThat(value).isEqualTo(\"test\")\r\n    assertThat(cancelled || !subscribed).isTrue()\r\n  }\r\n```"
      }
    ]
  },
  {
    "number": 6986,
    "title": "Cache First approach with Rx",
    "created_at": "2020-05-17T07:48:02Z",
    "closed_at": "2020-05-17T08:04:53Z",
    "labels": [
      "Question",
      "Android"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6986",
    "body": "I have to load appointments in two different places, one is in Dashboard and the other is on the Listing page.  \r\n\r\nThese are the product requirements. \r\n\r\n1.  Every login needs to make an appointment call update the DB and if you have any appointment in the DB show the stale first. \r\n2. When the user switches to the  Listing while requests in flight, there shouldn't be a new request, use the request in flight and update the DB and shows the result. \r\n3. If you are displaying stale data, if there is a request in flight, then I need to show a spinner on top of the appointments.  This gives the user an indication that you are seeing is stale one but there is something happening. \r\n\r\n4. After successful update the DB, now on use the cache.  Only update the cache, if the appointment cancel or rescheduled or force refresh happens. \r\n\r\nTo save the costly operation, I had decided to use publish() and connect().\r\n\r\nAll I can think of is this. \r\n\r\n\r\n\r\n```\r\nobject DataSourceManager {\r\n    private var subject = BehaviorSubject.create<Result<AppointmentWrapper>>()\r\n    private var stream: ConnectableObservable<List<AppointmentModel>>? = null\r\n    private var compositeDisposable = CompositeDisposable()\r\n\r\n    private fun fetchFromDb(): Observable<List<AppointmentModel>> {\r\n        return Observable.fromCallable {\r\n            Thread.sleep(1000 * 30)\r\n            return@fromCallable arrayListOf(AppointmentModel(\"1\"), AppointmentModel(\"2\"))\r\n        }\r\n    }\r\n\r\n    private fun writeToDb(): Observable<Boolean> {\r\n        return Observable.fromCallable {\r\n            Thread.sleep(1000 * 30)\r\n            return@fromCallable true\r\n        }\r\n    }\r\n\r\n    private fun fetchFromNetwork(): Observable<List<AppointmentModel>> {\r\n        return Observable.fromCallable {\r\n            Thread.sleep(1000 * 60)\r\n            return@fromCallable arrayListOf(\r\n                AppointmentModel(\"1\"),\r\n                AppointmentModel(\"2\"),\r\n                AppointmentModel(\"3\")\r\n            )\r\n        }\r\n    }\r\n\r\n    fun fetchAppointments(): BehaviorSubject<Result<AppointmentWrapper>> {\r\n        // you don't have a steam then create one\r\n        if (stream == null) {\r\n            stream = fetchFromDb()\r\n                .subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .doOnNext {\r\n                    subject.onNext(\r\n                        Result.Success(\r\n                            AppointmentWrapper(\r\n                                isLoading = true,\r\n                                source = Source.CACHE,\r\n                                payload = it\r\n                            )\r\n                        )\r\n                    )\r\n                }.observeOn(Schedulers.io())\r\n                .flatMap { fetchFromNetwork() }\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .doOnNext {\r\n                    subject.onNext(\r\n                        Result.Success(\r\n                            AppointmentWrapper(\r\n                                isLoading = true,\r\n                                source = Source.NETWORK,\r\n                                payload = it\r\n                            )\r\n                        )\r\n                    )\r\n                }.observeOn(Schedulers.io())\r\n                .flatMap { writeToDb() }\r\n                .flatMap { fetchFromDb() }\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .doOnNext {\r\n                    subject.onNext(\r\n                        Result.Success(\r\n                            AppointmentWrapper(\r\n                                isLoading = false,\r\n                                source = Source.NETWORK,\r\n                                payload = it\r\n                            )\r\n                        )\r\n                    )\r\n                }.publish()\r\n        }\r\n\r\n        stream?.let {\r\n            it.connect()\r\n            compositeDisposable.add(it.subscribe())\r\n        }\r\n\r\n        return subject\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n```\r\ndata class AppointmentWrapper(\r\n    // Steam is still in Progress\r\n    val isLoading: Boolean = false,\r\n    val source: Source,\r\n    val payload: List<AppointmentModel>\r\n)\r\n\r\nenum class Source {\r\n    CACHE, NETWORK\r\n}\r\n\r\n```\r\n\r\n\r\n```\r\nDataSourceManager.fetchAppointments().subscribe {\r\n          Log.d(TAG, \" fetchAppointments:  $it\")\r\n      }\r\n\r\n```\r\n\r\nOne thing, I'm not liking this approach is that I'm not able to create a single stream to handle this. I feel like its hack to get it done, not truly reactive, looks like it is creating side effects. \r\n\r\nAlso, I need to know how can I split the observable.  \r\n\r\nIf the cache is empty then. -> Make the API call - > update the cache -> return the result from DB\r\nIf the cache is not empty -> return the result from DB\r\n\r\nis there is any way to do it via a single stream? \r\n\r\nAny help here, I really appreciate that.  Apologies for posting it here instead of StackOverflow.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6986/comments",
    "author": "pollux-",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-05-17T08:04:53Z",
        "body": "Please ask such questions on StackOverflow."
      }
    ]
  },
  {
    "number": 6984,
    "title": "Nested blockingSubscribe() with .subscribeOn()",
    "created_at": "2020-05-13T19:08:40Z",
    "closed_at": "2020-06-29T05:35:23Z",
    "labels": [
      "Question",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6984",
    "body": "**Version** `3.0.2`\r\n\r\nTrying to achieve get parallel IO-thread work done then back to the caller thread with `blockingSubscribe()`, code below is what I have investigated according threads so far:\r\n```\r\nfunctionA() {               - Main Thread\r\n   mainNetworkCall()        - RxCachedThreadScheduler-1\r\n    .buffer(500, TimeUnit.MILLISECONDS, 200)\r\n    .flatMap(functionB())   - RxComputationThreadPool-2\r\n    // ... other operators\r\n    .subscribeOn(Schedulers.io())\r\n    .blockingSubscribe()\r\n \r\n}\r\n\r\nfunctionB() {               - RxComputationThreadPool-2\r\n    subNetworkCall()        - RxCachedThreadScheduler-2\r\n    // ... other operators\r\n    .subscribeOn(Schedulers.io())\r\n    .blockingSubscribe()\r\n    logger.log(\"functionB finished.\") - RxComputationThreadPool-2\r\n}\r\n\r\nFlowable mainNetworkCall() / subNetworkCall() {\r\n   return Flowable.range()\r\n               .concatMap()  - RxCachedThreadScheduler-1/2 (depends on functionA or B)\r\n               .takeWhile()\r\n               .flatMap()\r\n}\r\n```\r\nEven `functionB()` is used with `blockingSubscribe()`, \r\n`functionB()` still possible propagates (\"functionB finished.\") on **RxComputationThreadPool-2** without waiting any response  triggered by first `subNetworkCall()` on **RxCachedThreadScheduler-2**.\r\n\r\nwhich against that it should block the **RxComputationThreadPool-2** till upstream (RxCachedThreadScheduler-2) terminates, according to the document of `blockingSubscribe()`. \r\n\r\nTherefore, will `blockingSubscribe()` block the caller thread no matter its upstream emitted by IO or other thread?  if so, how did this case happen?\r\n\r\nOtherwise, to achieve blocking a caller thread till all the parallel IO thread work done then back to caller thread, what is a suggested way?\r\n\r\nThanks in advance. \r\n\r\n_Side Note_:\r\n`.subscribeOn(Schedulers.io())` in `functionA` seems could not control the flatMap operation, inner flatMap is till happening on **RxComputationThreadPool-2**.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6984/comments",
    "author": "donlingliang",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-05-13T19:14:58Z",
        "body": "`blockingSubscribe` blocks whatever thread is running on so if you nest it onto the IO thread, it will block a worker there too. Do not block in `functionB` but return the `Flowable` to be composed over via `flatMap` in `functionA`.\r\n\r\nAlso it is unclear what main thread are you using; are you trying to develop an Android application?"
      },
      {
        "user": "donlingliang",
        "created_at": "2020-05-13T21:10:03Z",
        "body": "> `blockingSubscribe` blocks whatever thread is running on so if you nest it onto the IO thread, it will block a worker there too. Do not block in `functionB` but return the `Flowable` to be composed over via `flatMap` in `functionA`.\r\n\r\nI see. And are you saying that `blockingSubscribe()` blocks the way like below?: \r\n```\r\nnetworkcall()\r\n      .operatorA()    - IO thread or whatever nested worker thread\r\n      .operatorB()    - IO thread or whatever nested worker thread\r\n      .subscribeOn(Schedulers.io())\r\n      .blockingSubscribe(Observer);  - This unblock the caller thread until operatorA() and operatorB()\r\n                                       both finished and let Observer handles the emitted items.              \r\n```\r\n\r\nActually my whole `functionB` logic is like below, that `functionA` **buffer** a list of data from network call, then passes down to `functionB` to do an extra network call if type matched with certain types :\r\n```\r\nFlowable functionB(List<Data> dataList, String type) {   \r\n  if (type.equals(certainType)) {\r\n     List<Data> subDataList;\r\n     DisposableSubscriber<DataObject> disposableSubscriber = new DisposableSubscriber<>() { \r\n               @Override\r\n               public void onNext(Data subData) {\r\n                   subDataList.add(subData);\r\n               }\r\n     ...\r\n     };\r\n\r\n     subNetworkCall()        \r\n       // ... other operators\r\n       .subscribeOn(Schedulers.io())\r\n       .blockingSubscribe(disposableSubscriber)\r\n     logger.log(\"functionB finished.\") - RxComputationThreadPool-2\r\n\r\n     // combine dataList with subDataList, then convert as combinedata\r\n     return Flowable.fromIterable(combinedData);\r\n\r\n  } else {\r\n     // convert dataList to combinedata\r\n     return Flowable.fromIterable(combinedData);\r\n  }            \r\n    \r\n}\r\n```\r\nI think in this case, back to the original question, `logger.log(\"functionB finished.\")` and ` // convert dataList with subDataList to combinedata` will happen in `functionB` **IF** block, before the subNetworkCall response and `DisposableSubscriber` onNext got triggered. 🤔, even using `blockingSubscribe()`.\r\n\r\n\r\n> Also it is unclear what main thread are you using; are you trying to develop an Android application?\r\n\r\nThis is not an Android application, general server java application.\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-05-14T06:41:02Z",
        "body": "Methods with `blocking` in their name block the thread they are called on.\r\n\r\n> subDataList.add(subData);\r\n\r\nAs I said, use composition and existing non-blocking operators, such as `toList`, `doOnNext` etc. for your example."
      }
    ]
  },
  {
    "number": 6978,
    "title": "Single and Callable",
    "created_at": "2020-05-11T02:31:10Z",
    "closed_at": "2020-06-29T05:35:53Z",
    "labels": [
      "Question",
      "2.x",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6978",
    "body": "I was trying to figure out why a benchmark I was running had `Observable`'s `flatMap` to an `Observable.just` with one element running faster than `flatMapSingle` to a `Single.just`, and concluded after adding some `hide`s that it's because of `Callable` optimizations. `MaybeJust`, `MaybeEmpty`, `MaybeFromAction`, and `MaybeFromCallable` all implement `Callable`, as do the equivalents for `Observable` and `Flowable`. Why don't the equivalent `Single` operators also implement `Callable` so that operators like `ObservableFlatMapSingle` can have similar optimizations to `ObservableFlatMap`?\r\n\r\n(I've been looking at the 2.x library, 3.x has the same structure, but using `Supplier` instead of `Callable`.)",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6978/comments",
    "author": "derektom14",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-05-11T05:53:58Z",
        "body": "It was very common to use flatMap with just before, therefore, it received the optimizations. With such shortcuts, one has to beware not to worsen the more common non-shortcut path."
      },
      {
        "user": "derektom14",
        "created_at": "2020-05-11T07:24:27Z",
        "body": "Alright, but why is `Single` left out of these optimizations? Was it observed that `Single.just` was used in `flatMapSingle` significantly more rarely?"
      },
      {
        "user": "derektom14",
        "created_at": "2020-05-11T07:36:07Z",
        "body": "This also leads to the strange scenario where, if one writes a `flatMapSingle` that has a very common `Single.just` path, it can be faster if rewritten as `flatMapMaybe`, despite the lack of an absent case. "
      },
      {
        "user": "akarnokd",
        "created_at": "2020-05-11T07:40:04Z",
        "body": "What is your use case that involves `flatMapSingle` with `Single.just`?"
      },
      {
        "user": "derektom14",
        "created_at": "2020-05-11T07:46:22Z",
        "body": "I don't have a specific one right now (just found this quirk while comparing `firstElement()` versus `take(1)`, but the scenario would be something where a key may be mapped to either a value that is already locally available (hence using `Single.just`) or a value that must be calculated by a separate process (hence using a different `Single`). Otherwise, it would be simpler as `map`."
      },
      {
        "user": "akarnokd",
        "created_at": "2020-05-11T07:54:51Z",
        "body": "`flatMapMaybe` was optimized because there were use cases that mixed scalar and async inner sources or used just/empty to perform mapping and filtering at the same time. Therefore, it was worth introducing the shortcuts. With `flatMapSingle`, mixed use was uncommon enough so no optimization is implemented."
      },
      {
        "user": "derektom14",
        "created_at": "2020-05-11T08:02:37Z",
        "body": "Ah, ok. From my benchmarking, on an `Observable`, using `flatMapMaybe` performs significantly worse than using `filter` followed by `map` (most likely due to the creation of new objects for every value as well as the greater complication of the `ObservableFlatMapMaybe`). I would need to switch to 3.x to see how `flatMapOptional` compares."
      },
      {
        "user": "derektom14",
        "created_at": "2020-05-19T19:53:02Z",
        "body": "With another benchmark, I've determined that on an `Observable`, using `flatMap` to a 0-or-1 `Observable` is significantly faster than using the equivalent `flatMapMaybe`. This is mostly explained by the fact that `ObservableFlatMap` tries the `Callable` optimization while `ObservableFlatMapMaybe` (but it's unclear why it doesn't), but even when I had `hide()` to bypass the `Callable` optimization, it still performs significantly worse, though not as significantly worse. By all appearances, `ObservableFlatMapMaybe` is a simpler operator than `ObservableFlatMap`, so why this performance difference, and why doesn't it apply the same `Callable` optimization? (I'm still looking at 2.x, perhaps this changed in 3.x.)"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-05-19T20:59:47Z",
        "body": "Not all possible optimizations have been applied to all the operators. If users are experiencing performance problems, their use case and the operators are investigated. Benchmarks showing such intended use help a lot in determining what actions to take."
      },
      {
        "user": "derektom14",
        "created_at": "2020-05-20T02:56:59Z",
        "body": "I'm surprised that `Observable.flatMap(Observable)` received this optimization while `Observable.flatMapMaybe(Maybe)` and `Maybe.flatMap(Maybe)` did not, then, and that it's more frequent for `flatMap` to involve an `Observable.just` or `Observable.empty` than for `flatMapMaybe` to involve `Maybe.just` or `Maybe.empty`, considering that `Observable` is usually used when multiple items are involved, and if it emits multiple items it can never be treated as a `Callable`.\r\n\r\nAnd I'm still surprised that even when I remove optimizations with `hide()`, `flatMap` is still faster than `flatMapMaybe`, I'll need to turn to the debugger to see how it's taking fewer effective steps.\r\n\r\nThe benchmarks I'm running are just to directly compare `flatMapMaybe` versus `flatMap`, so they aren't directly reflecting intended use, although I do see many uses of `flatMapMaybe` that can only be `Maybe.just` and `Maybe.empty`, despite being an order of magnitude faster as `flatMapOptional`."
      }
    ]
  },
  {
    "number": 6939,
    "title": "doOnSubscribe don't work as expected.",
    "created_at": "2020-03-19T08:25:50Z",
    "closed_at": "2020-03-19T12:26:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6939",
    "body": "RxJava 2.2.19\r\nMy code(sample):\r\n```\r\nclass Foo {\r\n\r\n\tprivate val someCachedData = listOf(1, 2, 3)\r\n\r\n\tprivate val publisher = PublishProcessor.create<Int>()\r\n\r\n\tfun getPublisher(): Flowable<Int> = publisher.onBackpressureBuffer().publish().refCount()\r\n\r\n\tfun subscribe() {\r\n\t\tprintln(\"subscribe called\")\r\n\r\n\t\tsomeCachedData.forEach(publisher::onNext)\r\n\t}\r\n }\r\n\r\n fun main() {\r\n\r\n\tval foo = Foo()\r\n\r\n\tfoo.getPublisher()\r\n\t\t.subscribeOn(Schedulers.computation())\r\n\t\t.doOnSubscribe {\r\n\t\t\tprintln(\"doOnSubscribe called\")\r\n\t\t\tfoo.subscribe()\r\n\t\t}\r\n\t\t.subscribe { print(it) }\r\n\r\n\tThread.sleep(10000)\r\n}\r\n```\r\n\r\nOutput:\r\n```\r\ndoOnSubscribe called\r\nsubscribe called\r\n\r\nProcess finished with exit code 0\r\n```\r\nIf i add some delay to call `foo.subscribe()`, App works fine.\r\nThe following code works fine:\r\n```\r\nfoo.getPublisher()\r\n\t\t.subscribeOn(Schedulers.computation())\r\n\t\t.doOnSubscribe {\r\n\t\t\tprintln(\"doOnSubscribe called\")\r\n\t\t\tSingle.just(true)\r\n\t\t\t\t.subscribeOn(Schedulers.single())\r\n\t\t\t\t.delay(1, TimeUnit.SECONDS)\r\n\t\t\t\t.subscribe { _ ->\r\n\t\t\t\t\tfoo.subscribe()\r\n\t\t\t\t}\r\n\t\t}\r\n\t\t.subscribe { print(it) }\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6939/comments",
    "author": "VovaStelmashchuk",
    "comments": [
      {
        "user": "VovaStelmashchuk",
        "created_at": "2020-03-19T08:31:12Z",
        "body": "Maybe, I do something wrong. Can you provide some fix? Ad Hoc solution welcome."
      },
      {
        "user": "akarnokd",
        "created_at": "2020-03-19T08:32:40Z",
        "body": "In your setup, `doOnSubscribe` runs just before the `PublishProcessor` finishes the registration of the subscriber and thus when you try to signal the values then, the processor simply won't see the subscriber. Also such re-entrant use is not encouraged.\r\n\r\n> Can you provide some fix?\r\n\r\nWhat were you trying to achieve there? If you want a source to signal when a subscriber arrives, use a cold source."
      },
      {
        "user": "VovaStelmashchuk",
        "created_at": "2020-03-19T08:47:52Z",
        "body": "In my case, I connect to socket. Some data load from cache, another from the real socket. I want to emit cached data immediately after consumer subscribe.  How i can implement this?"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-03-19T08:57:18Z",
        "body": "Use `startWith` for example."
      },
      {
        "user": "VovaStelmashchuk",
        "created_at": "2020-03-19T12:26:35Z",
        "body": "Thx, I fix my problem."
      }
    ]
  },
  {
    "number": 6933,
    "title": "Merge delay error for multiple API calls.",
    "created_at": "2020-03-14T19:05:20Z",
    "closed_at": "2020-03-16T17:32:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6933",
    "body": "```\r\nlaunchJob {\r\n            Observable.mergeDelayError(\r\n                    getCareUseCase.getAllGetCareItems().toObservable(),\r\n                    appointmentUseCase.getAllAppointment().toObservable()\r\n                        .mergeWith(\r\n                            prescriptionRefillsUseCase.getAllPrescriptionRefills())\r\n                            .mergeWith(billUseCase.getAllPayBills())\r\n                        .mergeWith(careTeamUseCase.getMyCareTeam())\r\n                        .mergeWith(favoriteFacilitiesUseCase.getAllFavoriteFacilities())\r\n                ).iOSubscribeMainThreadObserve()\r\n                .subscribe({\r\n                    mapSection(it)\r\n                    flattenAndEmit()\r\n                }, {\r\n                   Log.e(TAG, \"Failed to load dashboard contents\")\r\n                })\r\n        }\r\n\r\n\r\n```\r\n\r\nIf any of the API is failing entire stream is failing.  Any one knows why?\r\n\r\nThis is my requirement, I want to make all the API calls parallel,  I don't care about the order in which response arrives, I don't care if one fails, which one come fast, I just display in the order that receives. ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6933/comments",
    "author": "pollux-",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-03-14T19:25:19Z",
        "body": "`mergeWith` doesn't delay errors so if any of those fails, the subsequence will fail. Looks like you can simply use use `mergeArrayDelayError` with those 6 sources direclty:\r\n\r\n```java\r\nObservable.mergeArrayDelayError(\r\n    getCareUseCase.getAllGetCareItems().toObservable(),\r\n    appointmentUseCase.getAllAppointment().toObservable(),\r\n    prescriptionRefillsUseCase.getAllPrescriptionRefills(),\r\n    billUseCase.getAllPayBills(),\r\n    careTeamUseCase.getMyCareTeam(),\r\n    favoriteFacilitiesUseCase.getAllFavoriteFacilities()\r\n)\r\n.iOSubscribeMainThreadObserve()\r\n```"
      },
      {
        "user": "pollux-",
        "created_at": "2020-03-14T19:53:27Z",
        "body": "@akarnokd  \r\n\r\nI ran into an issue.  Observable.mergeArrayDelayError() give me compilation error when I add more than 4 observable? I know this a super dumb question. As per signature it should work though?\r\n\r\n**_mergeArrayDelayError(ObservableSource<? extends T>... sources)_**\r\n\r\n   ```\r\nObservable.mergeDelayError(\r\n            getCareUseCase.getAllGetCareItems().toObservable(),\r\n            getCareUseCase.getAllGetCareItems().toObservable(),\r\n            getCareUseCase.getAllGetCareItems().toObservable(),\r\n            getCareUseCase.getAllGetCareItems().toObservable(),\r\n            getCareUseCase.getAllGetCareItems().toObservable()\r\n        )\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-03-14T20:07:46Z",
        "body": "What is the error?"
      },
      {
        "user": "pollux-",
        "created_at": "2020-03-14T20:15:48Z",
        "body": "\r\n_None of the following functions can be called with the arguments supplied: \r\npublic final fun <T : Any!> mergeDelayError(p0: ((Observer<in (???..???)>) -> Unit)!, p1: ((Observer<in (???..???)>) -> Unit)!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic final fun <T : Any!> mergeDelayError(p0: ((Observer<in (???..???)>) -> Unit)!, p1: ((Observer<in (???..???)>) -> Unit)!, p2: ((Observer<in (???..???)>) -> Unit)!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic final fun <T : Any!> mergeDelayError(p0: ((Observer<in (???..???)>) -> Unit)!, p1: ((Observer<in (???..???)>) -> Unit)!, p2: ((Observer<in (???..???)>) -> Unit)!, p3: ((Observer<in (???..???)>) -> Unit)!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic final fun <T : Any!> mergeDelayError(p0: ((Observer<in ObservableSource<out (???..???)>!>) -> Unit)!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic final fun <T : Any!> mergeDelayError(p0: ((Observer<in ObservableSource<out (???..???)>!>) -> Unit)!, p1: Int): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: ObservableSource<out ObservableSource<out (???..???)>!>!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: ObservableSource<out ObservableSource<out (???..???)>!>!, p1: Int): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p1: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!): Observable<Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p1: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p2: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!): Observable<Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p1: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p2: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p3: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!): Observable<Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: (Mutable)Iterable<ObservableSource<out (???..???)>!>!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: (Mutable)Iterable<ObservableSource<out (???..???)>!>!, p1: Int): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: (Mutable)Iterable<ObservableSource<out (???..???)>!>!, p1: Int, p2: Int): Observable<(???..???)>! defined in io.reactivex.Observable\r\n\r\nFAILURE: Build failed with an exception._\r\n\r\n* What went wrong:\r\nExecution failed for task ':kpflagshipapp:compileRefreshKotlin'.\r\n> Compilation error. See log for more details\r\n\r\n* Try:\r\n\r\n\r\n```\r\nval dashboardObservables = listOf(\r\n            getCareUseCase.getAllGetCareItems().toObservable(),\r\n            appointmentUseCase.getAllAppointment().toObservable(),\r\n            prescriptionRefillsUseCase.getAllPrescriptionRefills(\r\n                application.getString(R.string.prescription_refills_title),\r\n                application.getString(R.string.prescription_refills_subtitle),\r\n                R.drawable.ic_prescription_refill\r\n            ),\r\n            billUseCase.getAllPayBills().toObservable(),\r\n            careTeamUseCase.getMyCareTeam().toObservable(),\r\n            favoriteFacilitiesUseCase.getAllFavoriteFacilities().toObservable()\r\n        )\r\n\r\n        launchJob {\r\n            Observable.mergeDelayError(dashboardObservables)\r\n                .iOSubscribeMainThreadObserve()\r\n                .subscribe({\r\n                    mapSection(it)\r\n                    flattenAndEmit()\r\n                }, {\r\n                   Log.e(TAG, \"Failed to load dashboard contents\")\r\n                })\r\n        }\r\n```\r\n\r\n@akarnokd  thank you so much for responding. \r\n\r\nThe above should work,  or do you see any issue with that?"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-03-14T20:25:07Z",
        "body": "I wrote: `mergeArrayDelayError()`\r\nYou had: `mergeDelayError()`\r\nSee the difference?"
      },
      {
        "user": "pollux-",
        "created_at": "2020-03-16T17:32:14Z",
        "body": "ya .. my bad .. thanks :) "
      }
    ]
  },
  {
    "number": 6926,
    "title": "2.x  emitter.onNext() is never delivered to subscriber if emitter.onError() is called afterwards",
    "created_at": "2020-03-05T15:51:09Z",
    "closed_at": "2021-01-27T09:18:23Z",
    "labels": [
      "Question",
      "2.x",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6926",
    "body": "code sample:\r\n```.Java\r\n        Observable.create(emitter -> {\r\n            emitter.setCancellable(() -> {\r\n                Timber.w(\"[emitter] setCancellable is called\");\r\n            });\r\n\r\n\r\n            Timber.i(\"[emitter] sending ok1\");\r\n            emitter.onNext(\"ok1 from emitter\");\r\n\r\n            Timber.i(\"[emitter] sending ok2\");\r\n            emitter.onNext(\"ok2 from emitter\");\r\n\r\n\r\n\r\n            Timber.i(\"[emitter] sending Error\");\r\n            emitter.onError(new IllegalStateException(\"error from emitter\"));\r\n//            Timber.i(\"[emitter] sending Complete\");\r\n//            emitter.onComplete();\r\n        })\r\n            .subscribeOn(AndroidSchedulers.mainThread())\r\n            .observeOn(AndroidSchedulers.mainThread())\r\n            .subscribe(\r\n                    result -> Timber.e(\"[subscriber] result: \" + result),\r\n                    e -> Timber.e(e, \"[subscriber] error\"),\r\n                    () -> Timber.e(\"[subscriber] completed\")\r\n            );\r\n```\r\n\r\nIn the output I **don't see** _onNext()_ Consumer to be invoked if I ever call _onError()_ in emitter .\r\n\r\nThe output  is following:\r\n```\r\nI/: [emitter] sending ok1\r\nI/: [emitter] sending ok2\r\nI/: [emitter] sending Error\r\nW/: [emitter] setCancellable is called\r\nE/: [subscriber] error\r\n    java.lang.IllegalStateException: error from emitter\r\n        at   ...\r\n```\r\n\r\nIf I replace _emitter.onError()_ with _emitter.onComplete()_ I **see** all the _onNext()_ events delivered:\r\n\r\n```\r\nI/: [emitter] sending ok1\r\nI/: [emitter] sending ok2\r\nI/: [emitter] sending Complete\r\nW/: [emitter] setCancellable is called\r\nE/: [subscriber] result: ok1 from emitter\r\nE/: [subscriber] result: ok2 from emitter\r\nE/: [subscriber] completed\r\n```\r\n\r\nI also **see** them when I use _emitter.onError()_ but two different Schedulers like following:\r\n\r\n```.Java\r\n            .subscribeOn(Schedulers.io())\r\n            .observeOn(Schedulers.computation())\r\n```\r\n\r\nthe output is following:\r\n\r\n```\r\n I/: [emitter] sending ok1\r\n I/: [emitter] sending ok2\r\n E/: [subscriber] result: ok1 from emitter\r\n I/: [emitter] sending Error\r\n E/: [subscriber] result: ok2 from emitter\r\n W/: [emitter] setCancellable is called\r\n E/: [subscriber] error\r\n    java.lang.IllegalStateException: error from emitter\r\n        at ...\r\n```\r\n\r\nQuestion: is it expected behaviour that onNext events _sometimes_ **not** delivered to subscriber if onError is called?\r\n\r\nRxJava version: _2.2.18_",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6926/comments",
    "author": "AlexTrotsenko",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-03-05T16:00:07Z",
        "body": "Yes. Errors can cut ahead if they are held back by backpressure or async boundary. There is currently no option to change this with `create` but other operators you can use an overload with `delayError` in name or as parameter."
      }
    ]
  },
  {
    "number": 6906,
    "title": "2.x Observable.concat firstElement and firstOrError calls subsequent methods after returning a valid observable",
    "created_at": "2020-02-13T14:42:40Z",
    "closed_at": "2020-02-14T08:47:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6906",
    "body": "Hi, I'm using version 2.2.17 but I've tried several other versions and result is the same.\r\n\r\n```kotlin\r\nObservable.concat(\r\n            Observable.just(\"source1\"),\r\n            getSource2()\r\n    ).firstOrError()\r\n```\r\nFrom what I understand this example should produce observable \"source1\" and then end the stream. Nevertheless it produces \"source1\" and then it invokes method \"getSource2\". Same thing happens when I call .firstElement() instead of firstOrError(). Same result when I try Maybe.concat or Single.concat with .firstElement() or .firstOrError().\r\n\r\nIf I put more observable sources into picture, the result is the same. The method \"getSource4\" is still invoked.\r\n\r\n```kotlin\r\nObservable.concat(\r\n            Observable.just(\"source1\"),\r\n            Observable.just(\"source2\"),\r\n            Observable.just(\"source3\"),\r\n            getSource4()\r\n    ).firstOrError()\r\n```\r\nIs it required behaviour or a bug? I'm implementing repository pattern in which I don't want to make unnecessary network API call when I've got the data cached.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6906/comments",
    "author": "jurajTomko",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-02-13T19:33:48Z",
        "body": "How did you implement `getSource2()`?\r\n\r\nIt's the Java runtime that invokes your method, not RxJava.\r\n\r\nPlease think about this. If I refactor your code, is `getSource2()` invoked?\r\n\r\n```java\r\nObservable<Integer> source2 = getSource2();\r\n\r\nObservable.concat(\r\n            Observable.just(\"source1\"),\r\n            source2\r\n    ).firstOrError()\r\n```\r\n\r\nHow about now?\r\n\r\n```java\r\nObservable<Integer> source2 = getSource2();\r\n\r\n/*\r\nObservable.concat(\r\n            Observable.just(\"source1\"),\r\n            source2\r\n    ).firstOrError()\r\n*/\r\n```\r\n"
      }
    ]
  },
  {
    "number": 6793,
    "title": "3.x: NonNull type argument annotations",
    "created_at": "2019-12-24T10:09:15Z",
    "closed_at": "2020-01-02T10:23:14Z",
    "labels": [
      "Question",
      "Discussion",
      "3.x",
      "Java 8"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6793",
    "body": "Now that we can add annotations to type arguments and type use, the functional interfaces can be defaulted and overridden as necessary.\r\n\r\nHowever, I'm not familiar how the tooling (IDEs and Kotlin) is able to handle the changes.\r\n\r\nFor example, given `public interface ObservableSource<@NonNull T> {}`.\r\n\r\n- Should `class Observable<T> implements ObservableSource<T>` repeat `@NonNull`?\r\n- Does the use of `T`, such as `subscribe(Observer<? super T> observer)` inherit `@NonNull`?\r\n- Does the introduction of a new argument `R` get the nullness propagated: `<R> Observable<R> map(Function<? super T, ? extends R> mapper)` where `R` is implicitly `@NonNull`?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6793/comments",
    "author": "akarnokd",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-01-02T10:23:14Z",
        "body": "Asking around a bit, `public interface ObservableSource<@NonNull T> {}` should be enough to set the default on `T`."
      },
      {
        "user": "valeriyo",
        "created_at": "2020-01-19T19:46:22Z",
        "body": "@akarnokd If it's not too much effort, perhaps 3.x annotation improvements should be backported to 2.x? For example, `public interface Consumer<T>` is missing `\\@NonNull` in 2.x and Kotlin compiler issues unnecessary warnings. Not sure how much effort that would be, maybe it doesn't make sense in 2.x, that's why I'm asking. And thank you so much for your continued excellent work!!!"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-01-19T19:59:44Z",
        "body": "Can't do it properly in Java 6."
      }
    ]
  },
  {
    "number": 6763,
    "title": "rxjava considers the thread free after the call dispose()",
    "created_at": "2019-12-16T16:31:02Z",
    "closed_at": "2019-12-16T16:51:19Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6763",
    "body": "Thanks for using RxJava but before you post an issue, please consider the following points:\r\n\r\n- library version io.reactivex.rxjava2:rxjava:2.2.16\r\n\r\n```kotlin\r\nimport io.reactivex.Observable\r\nimport io.reactivex.schedulers.Schedulers\r\n\r\nfun main() {\r\n    val chain1 = Observable.create<Unit> {\r\n        println(\"enter here\")\r\n\r\n        //Block thread\r\n        while (true) {\r\n            try {\r\n                Thread.sleep(1000)\r\n            } catch (e: InterruptedException) {\r\n\r\n            }\r\n        }\r\n    }.subscribeOn(Schedulers.io())\r\n\r\n    val chain2 = Observable.create<Unit> {\r\n        println(\"THIS CODE NEVER INVOKE!\")\r\n    }.subscribeOn(Schedulers.io())\r\n\r\n    val chain3 = Observable.create<Unit> {\r\n        println(\"This code invoke!\")\r\n    }.subscribeOn(Schedulers.io())\r\n\r\n    \r\n    println(\"This code invoke\")\r\n    val subscribe = chain1.subscribe()\r\n    Thread.sleep(50)// Prevent thread race\r\n    // If not call dispose so work good\r\n    subscribe.dispose()\r\n\r\n    chain2.subscribe()\r\n    Thread.sleep(50)// Prevent thread race\r\n    chain3.blockingFirst()\r\n}\r\n```\r\n\r\n\r\nthe library is trying to run chain 2 on the same thread as chain 1.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6763/comments",
    "author": "VladislavSumin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-12-16T16:51:19Z",
        "body": "This is a limitation and tradeoff of the `io` scheduler when running code that doesn't respond to interruption (vs. creating an endless amount of threads). For such sources, try using `newThread` instead or change the code so it checks for interruptions or dispose calls."
      }
    ]
  },
  {
    "number": 6749,
    "title": "Incorrect number of requests",
    "created_at": "2019-12-06T14:17:15Z",
    "closed_at": "2019-12-10T09:41:20Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6749",
    "body": "``subscription.request(200);`` but ``long requested = emitter.requested();`` is always 128.\r\n\r\n```\r\n@Test\r\n    public void test2() throws InterruptedException {\r\n        Scheduler productThread = Schedulers.from(Executors.newSingleThreadExecutor());\r\n        Scheduler consumerThread = Schedulers.from(Executors.newSingleThreadExecutor());\r\n\r\n        Flowable.create(new FlowableOnSubscribe<String>() {\r\n            @Override\r\n            public void subscribe(FlowableEmitter<String> emitter) throws Exception {\r\n                if (!emitter.isCancelled()) {\r\n                    long requested = emitter.requested();\r\n                    logger.info(\"consumer requested:\" + requested);\r\n                    for (int i = 0; i < requested; i++) {\r\n                        emitter.onNext(\"data \" + i);\r\n                    }\r\n                }\r\n            }\r\n        }, BackpressureStrategy.BUFFER)\r\n                .subscribeOn(productThread)\r\n                .observeOn(consumerThread)\r\n                .subscribe(new FlowableSubscriber<String>() {\r\n                    @Override\r\n                    public void onSubscribe(Subscription subscription) {\r\n                        subscription.request(200);\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(String s) {\r\n                        logger.info(\"consumer data:\" + s);\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(Throwable t) {\r\n                        t.printStackTrace();\r\n                    }\r\n\r\n                    @Override\r\n                    public void onComplete() {\r\n\r\n                    }\r\n                });\r\n\r\n        Thread.sleep(20000000);\r\n    }\r\n\r\n```\r\nHere is the printed log\r\n\r\n```\r\n22:17:43.344 [pool-1-thread-1] INFO com.example.reactor.RxJavaSchedulerTest - consumer requested:128\r\n22:17:43.348 [pool-3-thread-1] INFO com.example.reactor.RxJavaSchedulerTest - consumer data:data 0\r\n22:17:43.348 [pool-3-thread-1] INFO com.example.reactor.RxJavaSchedulerTest - consumer data:data 1\r\n22:17:43.348 [pool-3-thread-1] INFO com.example.reactor.RxJavaSchedulerTest - consumer data:data 2\r\n22:17:43.348 [pool-3-thread-1] INFO com.example.reactor.RxJavaSchedulerTest - consumer data:data 3\r\n22:17:43.348 [pool-3-thread-1] INFO com.example.reactor.RxJavaSchedulerTest - consumer data:data 4\r\n22:17:43.348 [pool-3-thread-1] INFO com.example.reactor.RxJavaSchedulerTest - consumer data:data 5\r\n..............................................................\r\n22:11:21.246 [pool-3-thread-1] INFO com.example.reactor.RxJavaSchedulerTest - consumer data:data 126\r\n22:11:21.246 [pool-3-thread-1] INFO com.example.reactor.RxJavaSchedulerTest - consumer data:data 127\r\n```\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6749/comments",
    "author": "brucelwl",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-12-06T14:27:39Z",
        "body": "Request amounts are not preserved between async stages, such as `observeOn`, because those manage their own buffers and request patterns. A limited workaround is to use `delay` which does not interfere with the request amounts passing through it.\r\n\r\nIn general backpressure is not for doing request-response type item generation across multiple stages. For that, you have to use an open loop of a subject/processor, send it the request object and build a chain with `flatMap` or `concatMap` doing the response value generation."
      }
    ]
  },
  {
    "number": 6725,
    "title": "[Suggestion/Question] Replace wildcard imports?",
    "created_at": "2019-11-21T20:16:13Z",
    "closed_at": "2019-11-21T20:20:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6725",
    "body": "I just noticed that wildcard imports are heavily used in this project. Is there a good reason for doing that? I think most people agree that using wildcard imports is a bad practice.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6725/comments",
    "author": "slisaasquatch",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-11-21T20:20:49Z",
        "body": "We use wildcard imports to reduce the noise in PRs. It was especially bad with the main java files (`Flowable`, etc.) as multiple PRs targeting the same file would conflict on import changes most of the time."
      }
    ]
  },
  {
    "number": 6724,
    "title": "Observable vs Flowable on Interfaces With Unknown Implementations",
    "created_at": "2019-11-20T18:06:06Z",
    "closed_at": "2019-11-20T21:13:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6724",
    "body": "We have a base library which provides interfaces for repository / database access and some basic implementations. In the case of getOne, insert, update, and delete, these all make sense as singles / maybes. However in the case of getAll for instance, this could be a ```Single<List<Model>>``` or ```Observable<Model>```. We considered using single, since that's usually how our data is consumed, but these interfaces could hold implementations that support streaming, so using single would essentially prevent those types of implementations from being realized. The consumer can always use the ```toList``` operator if they dont want to consume it like a stream or need all the results for business logic. \r\n\r\nSo now where we are stuck is whether or not these interfaces should return Observables or Flowables. From what I understand, the main difference between the two is that Flowables have added overhead which allow a Consumer to control the rate at which a Producer emits items, where as an Observable does not and will just emit as quickly as possible.\r\n\r\nWould it make sense then to always return lower overhead Observables from these interfaces, and to leave it up to the consumer to use ```toFlowable``` if they need control over the rate of the Producer? Would this even work or would the Observable consume memory with its unbounded buffer (potential out of memory issues) before being converted to a Flowable which has bounded buffers?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6724/comments",
    "author": "pixelshaded",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-11-20T18:23:39Z",
        "body": "You can always unbound `Flowable` or turn it into a `Single`. Rebounding an `Observable` will be still prone to excessive memory usage. There isn't that much of an overhead difference between `Flowable` and `Observable` otherwise."
      },
      {
        "user": "pixelshaded",
        "created_at": "2019-11-20T18:35:14Z",
        "body": "It seems then, based on docs, that Flowable is essentially what Observable was in rxjava1, and now Observables are just an alternative to something like Java8 streams. Is that accurate?"
      },
      {
        "user": "akarnokd",
        "created_at": "2019-11-20T18:40:51Z",
        "body": "> Flowable is essentially what Observable was in rxjava1\r\n\r\nYes.\r\n\r\n> Observables are just an alternative to something like Java8 streams\r\n\r\nNo, they are for cases where there can't be a reasonable backpressure (UI events) or backpressure doesn't matter due to short sequences.\r\n"
      },
      {
        "user": "pixelshaded",
        "created_at": "2019-11-20T21:13:13Z",
        "body": "Thanks for the quick replies."
      }
    ]
  },
  {
    "number": 6701,
    "title": "Java 11 support",
    "created_at": "2019-11-04T12:36:11Z",
    "closed_at": "2019-11-04T12:48:49Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6701",
    "body": "Hello,\r\nWe are currently using the rxjava.jar version 1.2.4 in our project. This version as well as the latest version (1.3.8) are not safe to use with Java 11. Following is the jdeps report:\r\nrx.internal.util.unsafe                            -> sun.misc                                           JDK internal API (jdk.unsupported)\r\n\r\nIs there any plan for java 11 support in upcoming library version?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6701/comments",
    "author": "vinayak-kuchekar",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-11-04T12:48:49Z",
        "body": "RxJava 1.x is no longer supported. There was a system property to disable unsafe usage: `rx.unsafe-disable` at runtime.\r\n\r\nRxJava 2.x onward doesn't use unofficial APIs and thus is safe for newer JDKs. "
      }
    ]
  },
  {
    "number": 6624,
    "title": "Work on Completable and if OnError perform other Completable and return this result",
    "created_at": "2019-08-21T09:28:06Z",
    "closed_at": "2019-08-21T09:35:16Z",
    "labels": [
      "Question",
      "2.x",
      "StackOverflow"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6624",
    "body": "  - library version \r\n     'io.reactivex.rxjava2:rxandroid:2.1.1'\r\n     'io.reactivex.rxjava2:rxjava:2.2.6'\r\n\r\nExecute the first Completable: \r\nif no error returns it\r\non error, execute the second Completable return result of this Completable. \r\n\r\n I am doing like this, but no success as this returns asap first Completable return error, so \r\n\r\n```\r\nreturn cartDao.insert(order)\r\n            .doOnError {\r\n\r\n                val orderRow = cartDao.getOrderById(order.productId, order.productVariant.variantId)\r\n                orderRow.qty = orderRow.qty + order.qty\r\n\r\n                //second Completable, never calls\r\n                cartDao.update(orderRow).subscribeOn(Schedulers.io())\r\n                    .doOnComplete {\r\n                        Timber.e(it)\r\n                    }\r\n                    .doOnError {\r\n                        Timber.e(it)\r\n                    }\r\n            }\r\n```\r\n\r\nhelp me to execute the second Completable over onError and return this Completable result.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6624/comments",
    "author": "JitainSharma",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-08-21T09:35:16Z",
        "body": "Please ask such questions on StackOverflow."
      }
    ]
  },
  {
    "number": 6623,
    "title": "Observers run order issue while using observeOn() `2.x`",
    "created_at": "2019-08-19T09:30:56Z",
    "closed_at": "2019-08-19T09:55:30Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6623",
    "body": "Library version 2.2.11\r\nI have two `PublishSubject`s and two `Observer`s subscribed respectively. Between `PubslishSubject` and `Subscriber` I switch from [main] thread to [RxSingleScheduler] thread using `observeOn(Schedulers.single())`. I start to publish (`PubslishSubject.onNext()`) on both `PublishSubject`s inside the loop.\r\n\r\n    publishSubject1.onNext(\"next\");\r\n    publishSubject2.onNext(\"next\");\r\nWhat I expected was the both subscribers run in the same order as emissions were published but the results I get is completely different. Subsriber1 handles all it's emissions and then Subscriber2 handles all it's emissions.\r\nI expected emission scheduled and run in publish order. Is there any way to achive this?\r\n```java\r\nimport java.util.concurrent.TimeUnit;\r\n\r\nimport io.reactivex.schedulers.Schedulers;\r\nimport io.reactivex.subjects.PublishSubject;\r\n\r\npublic class ObserveOnApp {\r\n    \r\n    public static void main(String[] args) {\r\n        PublishSubject<String> publishSubject1 = PublishSubject.create();\r\n        PublishSubject<String> publishSubject2 = PublishSubject.create();\r\n        \r\n        publishSubject1\r\n        .observeOn(Schedulers.single())\r\n        .subscribe(next -> {\r\n            System.out.println(\"Subscriber1\");\r\n        });\r\n        \r\n        publishSubject2\r\n        .observeOn(Schedulers.single())\r\n        .subscribe(next -> {\r\n            System.out.println(\"Subscriber2\");\r\n        });\r\n        \r\n        for (int i= 0; i < 10; i++) {\r\n            publishSubject1.onNext(\"next\");\r\n            publishSubject2.onNext(\"next\");\r\n        }\r\n        \r\n        try {\r\n            TimeUnit.SECONDS.sleep(2);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6623/comments",
    "author": "pkrysztofiak",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-08-19T09:38:58Z",
        "body": "`Schedulers.single` uses a single thread and both of your subjects post work to this one thread. `observeOn` keeps working as long as it sees events so if you post events fast enough, the first subscription will get as much work done as it can, hence you don't see perfect interleaving of the two consumers.\r\n\r\nYou can try `delay(0, TimeUnit.SECONDS, Schedulers.single())` instead which posts events one by one.\r\n"
      },
      {
        "user": "pkrysztofiak",
        "created_at": "2019-08-19T09:49:29Z",
        "body": "delay() works but I'm extremly confused. Isn't it should be the default behaviour? When calling\r\n```\r\npublishSubject1.onNext(\"next\");\r\npublishSubject2.onNext(\"next\");\r\n```\r\nfirst line should schedule an execution. The second line should do the same and since I use the same scheduler subscriptions should interleave perfectly."
      },
      {
        "user": "akarnokd",
        "created_at": "2019-08-19T09:55:30Z",
        "body": "No. Any operator with a queue does as much work as it can in one run, including `observeOn`. Delay has to post events individually as it has to apply an user-defined delay to each, and there is no queue involved in RxJava for that. The underlying `ScheduledExecutorService` will interleave tasks in its own queue. Posting items individually to a thread pool is really inefficient as it causes a lot of extra allocation per task. The way RxJava does this is automatically coalescing nearby events and have one task serving them at once."
      }
    ]
  },
  {
    "number": 6617,
    "title": "ConcatMap caches value from upstream",
    "created_at": "2019-08-14T09:24:53Z",
    "closed_at": "2019-08-21T15:54:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6617",
    "body": "This issue was reproduces on RX-Java v2.2.6 and v3.0.0-RC1\r\n\r\nI have this piece of code:\r\n\r\n```java\r\n@Test\r\npublic void concatMapCachedValueTest() throws InterruptedException {\r\n  Flowable\r\n    .interval(0, 1000, TimeUnit.MILLISECONDS, Schedulers.io())\r\n    .onBackpressureDrop()\r\n    .concatMap(aLong -> Flowable.just(aLong)\r\n        .delay(3500, TimeUnit.MILLISECONDS, Schedulers.io())\r\n    )\r\n    .subscribe(aLong -> System.out.println(aLong));\r\n    Thread.sleep(18000);\r\n}\r\n```\r\n\r\nWhen I run it it prints:\r\n0\r\n1\r\n4\r\n5\r\n11\r\n\r\nI would expect it to print:\r\n0\r\n4\r\n8\r\n12\r\n16\r\n\r\nBut it seems that concatMap is caching another value from the upstream while starting processing the Flowable returned by current value.\r\nThis happens even if you set the prefetch parameter of concatMap to 1, setting it to 0 is illegal.\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6617/comments",
    "author": "adrian-linca",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-08-14T09:37:49Z",
        "body": "Yes, `concatMap` has always a buffer to store one upstream element even if the inner source is still active. Try `flatMap` with `maxConcurrency = 1`."
      },
      {
        "user": "akarnokd",
        "created_at": "2019-08-14T09:40:02Z",
        "body": "Also if you are unfamiliar with markdown, please check my edits on your post so that you can format code properly."
      },
      {
        "user": "adrian-linca",
        "created_at": "2019-08-14T15:06:05Z",
        "body": "Thanks."
      }
    ]
  },
  {
    "number": 6568,
    "title": "2.2.10: Flowable do not use correct scheduler once bufferSize is reached",
    "created_at": "2019-07-11T10:00:41Z",
    "closed_at": "2019-07-11T11:59:11Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6568",
    "body": "Hi, I was playing with Flowable to get a deep understanding on how to handle backpressure without dropping events and running the following code I noticed that the flowable starts to emit events on the subscriber scheduler once bufferSize given to observeOn method is reached.\r\n\r\nHere's the code :\r\n\r\n```\r\n    public static void main(String[] args) throws InterruptedException {\r\n        int maxI = 12;\r\n        int bufferSize = 5;\r\n        CountDownLatch waitForIt = new CountDownLatch(1);\r\n        CompositeDisposable compositeDisposable = new CompositeDisposable();\r\n\r\n        Flowable<Integer> integerFlow = Flowable.<Integer, Integer>generate(\r\n                () -> 0,\r\n                (i, emitter) -> {\r\n                    if (i < maxI) {\r\n                        log(\"Emitting: \" + i);\r\n                        emitter.onNext(i);\r\n                    } else {\r\n                        emitter.onComplete();\r\n                    }\r\n                    return i + 1;\r\n                }).observeOn(Schedulers.io(), false, bufferSize);\r\n\r\n        compositeDisposable.add(\r\n                integerFlow\r\n                        .subscribeOn(Schedulers.computation())\r\n                        .subscribeWith(new DisposableSubscriber<Integer>() {\r\n\r\n                            @Override\r\n                            public void onNext(Integer i) {\r\n                                try {\r\n                                    log(\"Receiving: \" + i);\r\n                                    Thread.sleep(10L);\r\n                                } catch (InterruptedException e) {\r\n                                    e.printStackTrace();\r\n                                }\r\n                            }\r\n\r\n                            @Override\r\n                            public void onError(Throwable throwable) {\r\n\r\n                            }\r\n\r\n                            @Override\r\n                            public void onComplete() {\r\n                                compositeDisposable.remove(this);\r\n                                waitForIt.countDown();\r\n                            }\r\n                        }));\r\n\r\n        System.out.println(compositeDisposable.size());\r\n        log(\"Waiting for finish\");\r\n        waitForIt.await();\r\n        System.out.println(compositeDisposable.size());\r\n    }\r\n\r\n    private static void log(String message) {\r\n        System.out.println(message + String.format(\" (%s)\", Thread.currentThread().getName()));\r\n    }\r\n```\r\nHere's the output:\r\n\r\n```\r\n1\r\nWaiting for finish (main)\r\nEmitting: 0 (RxComputationThreadPool-1)\r\nEmitting: 1 (RxComputationThreadPool-1)\r\nEmitting: 2 (RxComputationThreadPool-1)\r\nEmitting: 3 (RxComputationThreadPool-1)\r\nEmitting: 4 (RxComputationThreadPool-1)\r\nReceiving: 0 (RxCachedThreadScheduler-1)\r\nReceiving: 1 (RxCachedThreadScheduler-1)\r\nReceiving: 2 (RxCachedThreadScheduler-1)\r\nReceiving: 3 (RxCachedThreadScheduler-1)\r\nEmitting: 5 (RxCachedThreadScheduler-1)\r\nEmitting: 6 (RxCachedThreadScheduler-1)\r\nEmitting: 7 (RxCachedThreadScheduler-1)\r\nEmitting: 8 (RxCachedThreadScheduler-1)\r\nReceiving: 4 (RxCachedThreadScheduler-1)\r\nReceiving: 5 (RxCachedThreadScheduler-1)\r\nReceiving: 6 (RxCachedThreadScheduler-1)\r\nReceiving: 7 (RxCachedThreadScheduler-1)\r\nEmitting: 9 (RxCachedThreadScheduler-1)\r\nEmitting: 10 (RxCachedThreadScheduler-1)\r\nEmitting: 11 (RxCachedThreadScheduler-1)\r\nReceiving: 8 (RxCachedThreadScheduler-1)\r\nReceiving: 9 (RxCachedThreadScheduler-1)\r\nReceiving: 10 (RxCachedThreadScheduler-1)\r\nReceiving: 11 (RxCachedThreadScheduler-1)\r\n0\r\n```\r\nI would expect all `Emitting: ...`  log lines to be in an RxComputationThreadPool-x. But once `bufferSize` events have been emitted (and the subscriber starts working), the flowable emits in the same thread has the subscriber.\r\n\r\nIs this normal behavior ?\r\n\r\nThanks, regards",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6568/comments",
    "author": "gauthierj",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-07-11T10:46:33Z",
        "body": "This is an allowed behavior. The `generate` responds to requests on whatever thread the request comes from. Initially, the first batch is triggered on the computation thread due to `subscribeOn`. Later on, `observeOn` takes over with requesting from its IO thread and thus generator runs on the IO thread too. \r\n\r\nThe main problem in your code is the position of `subscribeOn`. If you put it just after `generate`, the operator will make sure the subscription and subsequent requests happen on the designated thread."
      },
      {
        "user": "gauthierj",
        "created_at": "2019-07-11T11:59:07Z",
        "body": "OK, thanks for the quick answer !"
      }
    ]
  },
  {
    "number": 6553,
    "title": "Stack info doesn't show where OnErrorNotImplementedException happened",
    "created_at": "2019-07-03T10:06:43Z",
    "closed_at": "2019-07-04T07:48:14Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6553",
    "body": "Hi there, I got this crash issue from Fabric, it shows that I didn't handle `onError` in some cases. But i'm not sure how to find those cases since they didn't show in the stack info. Can i get any suggestion form you guys? Thanks.\r\n\r\n```\r\n\r\n#0. Crashed: main\r\n       at rx.android.schedulers.LooperScheduler$ScheduledAction.run + 112(LooperScheduler.java:112)\r\n       at android.os.Handler.handleCallback + 746(Handler.java:746)\r\n       at android.os.Handler.dispatchMessage + 95(Handler.java:95)\r\n       at android.os.Looper.loop + 148(Looper.java:148)\r\n       at android.app.ActivityThread.main + 5443(ActivityThread.java:5443)\r\n       at java.lang.reflect.Method.invoke(Method.java)\r\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run + 728(ZygoteInit.java:728)\r\n       at com.android.internal.os.ZygoteInit.main + 618(ZygoteInit.java:618)\r\n\r\n--\r\n\r\nFatal Exception: java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\r\n       at rx.android.schedulers.LooperScheduler$ScheduledAction.run + 112(LooperScheduler.java:112)\r\n       at android.os.Handler.handleCallback + 746(Handler.java:746)\r\n       at android.os.Handler.dispatchMessage + 95(Handler.java:95)\r\n       at android.os.Looper.loop + 148(Looper.java:148)\r\n       at android.app.ActivityThread.main + 5443(ActivityThread.java:5443)\r\n       at java.lang.reflect.Method.invoke(Method.java)\r\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run + 728(ZygoteInit.java:728)\r\n       at com.android.internal.os.ZygoteInit.main + 618(ZygoteInit.java:618)\r\n\r\nCaused by rx.exceptions.OnErrorNotImplementedException\r\n       at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call + 386(InternalObservableUtils.java:386)\r\n       at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call + 383(InternalObservableUtils.java:383)\r\n       at rx.internal.util.ActionSubscriber.onError + 44(ActionSubscriber.java:44)\r\n       at rx.observers.SafeSubscriber._onError + 153(SafeSubscriber.java:153)\r\n       at rx.observers.SafeSubscriber.onError + 115(SafeSubscriber.java:115)\r\n       at rx.internal.operators.OnSubscribeDoOnEach$DoOnEachSubscriber.onError + 87(OnSubscribeDoOnEach.java:87)\r\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated + 273(OperatorObserveOn.java:273)\r\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call + 216(OperatorObserveOn.java:216)\r\n       at rx.android.schedulers.LooperScheduler$ScheduledAction.run + 107(LooperScheduler.java:107)\r\n       at android.os.Handler.handleCallback + 746(Handler.java:746)\r\n       at android.os.Handler.dispatchMessage + 95(Handler.java:95)\r\n       at android.os.Looper.loop + 148(Looper.java:148)\r\n       at android.app.ActivityThread.main + 5443(ActivityThread.java:5443)\r\n       at java.lang.reflect.Method.invoke(Method.java)\r\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run + 728(ZygoteInit.java:728)\r\n       at com.android.internal.os.ZygoteInit.main + 618(ZygoteInit.java:618)\r\n\r\nCaused by rx.exceptions.MissingBackpressureException\r\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext + 160(OperatorObserveOn.java:160)\r\n       at rx.internal.operators.OperatorSubscribeOn$SubscribeOnSubscriber.onNext + 74(OperatorSubscribeOn.java:74)\r\n       at rx.internal.operators.OnSubscribeTimerPeriodically$1.call + 52(OnSubscribeTimerPeriodically.java:52)\r\n       at rx.internal.schedulers.SchedulePeriodicHelper$1.call + 72(SchedulePeriodicHelper.java:72)\r\n       at rx.internal.schedulers.EventLoopsScheduler$EventLoopWorker$2.call + 189(EventLoopsScheduler.java:189)\r\n       at rx.internal.schedulers.ScheduledAction.run + 55(ScheduledAction.java:55)\r\n       at java.util.concurrent.Executors$RunnableAdapter.call + 423(Executors.java:423)\r\n       at java.util.concurrent.FutureTask.run + 237(FutureTask.java:237)\r\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run + 269(ScheduledThreadPoolExecutor.java:269)\r\n       at java.util.concurrent.ThreadPoolExecutor.runWorker + 1113(ThreadPoolExecutor.java:1113)\r\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run + 588(ThreadPoolExecutor.java:588)\r\n       at java.lang.Thread.run + 818(Thread.java:818)\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6553/comments",
    "author": "RonaldWang2",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-07-03T10:11:24Z",
        "body": "Do a method reference search on `Observable.subscribe()` and `Observable.subscribe(Action1)`.\r\n\r\nPlease note that 1.x is no longer supported or maintained."
      }
    ]
  },
  {
    "number": 6552,
    "title": "Flowable publish not working (2.2.10)",
    "created_at": "2019-06-30T16:05:00Z",
    "closed_at": "2019-07-08T11:24:01Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6552",
    "body": "The order that the flowables are concat'ed inside the publish function affects the output. I'm not blocked on this because I worked around the issue by using `tags.cache()`.\r\n\r\nTest code to reproduce the issue.\r\n\r\n```java\r\npackage io.reactivex;\r\n\r\nimport static org.junit.jupiter.api.Assertions.assertEquals;\r\n\r\nimport java.util.Collections;\r\nimport java.util.HashSet;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Objects;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.UUID;\r\nimport java.util.stream.Collectors;\r\n\r\nimport org.junit.jupiter.api.Test;\r\n\r\nclass FlowablePublishTest {\r\n    static class TagEntry {\r\n        private final String key;\r\n        private final String value;\r\n        private final Set<UUID> ids;\r\n\r\n        public TagEntry(String key, String value, Set<UUID> ids) {\r\n            this.key = key;\r\n            this.value = value;\r\n            this.ids = ids;\r\n        }\r\n\r\n        public String getKey() {\r\n            return key;\r\n        }\r\n\r\n        public Set<UUID> getIds() {\r\n            return ids;\r\n        }\r\n\r\n        @Override\r\n        public int hashCode() {\r\n            return Objects.hash(key, value, ids);\r\n        }\r\n\r\n        @Override\r\n        public boolean equals(Object obj) {\r\n            if (this == obj)\r\n                return true;\r\n            if (obj == null)\r\n                return false;\r\n            if (getClass() != obj.getClass())\r\n                return false;\r\n            TagEntry that = (TagEntry) obj;\r\n            return Objects.equals(this.key, that.key) &&//\r\n                    Objects.equals(this.value, that.value) &&//\r\n                    Objects.equals(this.ids, that.ids);\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return key + \"=\" + value + \": \" + ids;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    void test() {\r\n        UUID a = UUID.randomUUID();\r\n        UUID b = UUID.randomUUID();\r\n\r\n        HashSet<TagEntry> expected = new HashSet<>();\r\n        expected.add(new TagEntry(\"hello\", null, Collections.singleton(b)));\r\n        expected.add(new TagEntry(\"hello\", \"world\", Collections.singleton(a)));\r\n\r\n        HashSet<TagEntry> actual = addUntagged(Flowable.just(new TagEntry(\"hello\", \"world\", Collections.singleton(a))),\r\n                Flowable.just(a, b)).collectInto(new HashSet<TagEntry>(), HashSet::add)\r\n                    .blockingGet();\r\n\r\n        assertEquals(expected, actual);\r\n    }\r\n\r\n    private Flowable<TagEntry> addUntagged(Flowable<TagEntry> tags, Flowable<UUID> allIds) {\r\n        Single<List<UUID>> allRootIds = allIds.toList()\r\n            .cache();\r\n\r\n        return tags.publish(pubTags -> {\r\n            Single<Map<String, Set<UUID>>> taggedRootIdsByDim = pubTags.collect(TreeMap::new, (map, entry) -> {\r\n                map.computeIfAbsent(entry.getKey(), (k) -> new TreeSet<>())\r\n                    .addAll(entry.getIds());\r\n            });\r\n\r\n            Flowable<TagEntry> untags = taggedRootIdsByDim.zipWith(allRootIds, this::generateUntags)\r\n                .flattenAsFlowable(x -> x);\r\n\r\n            return pubTags.concatWith(untags); // only return pubTags\r\n            // return untags.concatWith(pubTags); // only return untags\r\n        });\r\n    }\r\n\r\n    private List<TagEntry> generateUntags(Map<String, Set<UUID>> taggedRootIdsByDim, List<UUID> allRootIds) {\r\n        return taggedRootIdsByDim.entrySet()\r\n            .stream()\r\n            .map((entry) -> {\r\n                // substract the two sets to find root ids that are don't have this tag\r\n                TreeSet<UUID> untagged = new TreeSet<>(allRootIds);\r\n                untagged.removeAll(entry.getValue());\r\n\r\n                return new TagEntry(entry.getKey(), null, untagged);\r\n            })\r\n            .collect(Collectors.toList());\r\n    }\r\n}\r\n```\r\n\r\nThe results that I saw when I ran it.\r\n\r\nwith line 92 commented out\r\n```\r\norg.opentest4j.AssertionFailedError:\r\nexpected: <[hello=world: [9dc92d08-9e43-49a7-b30c-dde3060226c0], hello=null: [2aaa21e8-61de-4cec-b8ad-1e964cc62418]]>\r\nbut was: <[hello=world: [9dc92d08-9e43-49a7-b30c-dde3060226c0]]>\r\n\tat org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:55)\r\n\tat org.junit.jupiter.api.AssertionUtils.failNotEqual(AssertionUtils.java:62)\r\n\tat org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182)\r\n\tat org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177)\r\n\tat org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1124)\r\n\tat io.reactivex.FlowablePublishTest.test(FlowablePublishTest.java:76)\r\n```\r\n\r\nwith line 93 commented out\r\n```\r\norg.opentest4j.AssertionFailedError:\r\nexpected: <[hello=null: [ca32468d-48d6-4ad5-bd61-33f7ccb59088], hello=world: [0ec2a954-ad6f-4d4b-b342-633f3c809ca8]]>\r\nbut was: <[hello=null: [ca32468d-48d6-4ad5-bd61-33f7ccb59088]]>\r\n\tat org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:55)\r\n\tat org.junit.jupiter.api.AssertionUtils.failNotEqual(AssertionUtils.java:62)\r\n\tat org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182)\r\n\tat org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177)\r\n\tat org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1124)\r\n\tat io.reactivex.FlowablePublishTest.test(FlowablePublishTest.java:76)\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6552/comments",
    "author": "abersnaze",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-06-30T16:50:24Z",
        "body": "I don't think there is a bug in the operator but a misunderstanding.\r\n\r\nWith `return pubTags.concatWith(untags)`, the shared source `pubTags` is fully consumed in its entirety, then `concatWith` switches to `untags` which now tries to work with a completed `pubTags`.\r\n\r\nWith `return untags.concatWith(pubTags)`, the `untags` consumes the shared `pubTags` to completion and `concatWith` switches to a now terminated `pubTags`.\r\n\r\nLooks like you wanted to have the original sequence and a processed variants of it, but `concatWith` won't let you do both at the same time. `replay(Function)` would cache all items for whatever the second reprocessing would be."
      },
      {
        "user": "abersnaze",
        "created_at": "2019-06-30T17:38:42Z",
        "body": "I thought the point of ‘publish’ was to allow multiple subscriptions to the same`Flowable`.\r\n\r\n> selector - a function that can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all notifications of the source from the time of the subscription forward."
      },
      {
        "user": "akarnokd",
        "created_at": "2019-06-30T17:43:54Z",
        "body": "> Subscribers to the given source will receive all notifications of the source from **the time of the subscription forward.**\r\n\r\nThis is the key phrase. `concatWith` will trigger a new subscription when the shared source has ended, thus it won't receive anything other than the terminal event. The operator is analogous how `PublishProcessor`/`PublishSubject` multicasts items where late consumers will not see previous items."
      }
    ]
  },
  {
    "number": 6509,
    "title": "ConnectableFlowable doesn't start emitting on connect()",
    "created_at": "2019-06-17T13:09:47Z",
    "closed_at": "2019-06-19T11:59:08Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6509",
    "body": "Version used `io.reactivex.rxjava2:rxjava:2.2.9`\r\n\r\nExample code:\r\n\r\n```Kotlin\r\nval connectable = Flowable.just(\"\")\r\n            .map { println(\"map\") }\r\n            .replay(1)\r\n\r\nconnectable.connect()\r\nprintln(\"connect\")\r\nconnectable.test()\r\n```\r\n\r\nOutput: \r\n```\r\nconnect\r\nmap\r\n```\r\n\r\nExpected output:\r\n```\r\nmap\r\nconnect\r\n```\r\n\r\nThe same example with `publish` instead of `replay(1)` works as expected:\r\n\r\n```Kotlin\r\nval connectable = Flowable.just(\"\")\r\n            .map { println(\"map\") }\r\n            .publish()\r\n\r\nconnectable.connect()\r\nprintln(\"connect\")\r\nconnectable.test()\r\n```\r\n\r\nOutput: \r\n```\r\nmap\r\nconnect\r\n```\r\n\r\nThe same example with `Observable` works as expected:\r\n\r\n```Kotlin\r\nval connectable = Observable.just(\"\")\r\n            .map { println(\"map\") }\r\n            .replay(1)\r\n\r\nconnectable.connect()\r\nprintln(\"connect\")\r\nconnectable.test()\r\n```\r\n\r\nOutput:\r\n``` \r\nmap\r\nconnect\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6509/comments",
    "author": "Dimezis",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-06-17T13:16:32Z",
        "body": "This is by design and a consequence of backpressure support. Without it, a connect and a bounded buffer would probably run through all items and by the time subscribers arrive, they'd only get the very last items."
      },
      {
        "user": "Dimezis",
        "created_at": "2019-06-17T13:41:02Z",
        "body": "Hm, but does it even matter that subscribers will miss the items, if we are dealing with a connectable flowable/observable?\r\nI mean, they are missing the items anyway if they subscribe after the `connect()`, except of those in the replay buffer.\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2019-06-17T13:49:24Z",
        "body": "We can't know in general. This behavior can be worked around via a dummy unbounded consumer, i.e., `subscribe()`. If it were the other way around, you couldn't prevent it from rushing though."
      }
    ]
  },
  {
    "number": 6495,
    "title": "SwitchIfEmpty on a Subject",
    "created_at": "2019-06-04T07:43:33Z",
    "closed_at": "2019-06-04T07:57:52Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6495",
    "body": "I have an issue with the Observable.switchIfEmpty operator. It’s not called properly. See sample code\r\n\r\n```kotlin\r\nclass TestObs {\r\n\r\n    @Test\r\n    fun testSwitchIfEmpty() {\r\n        val subject = BehaviorSubject.create<List<String>>()\r\n        subject.onNext(listOf(\"a\"))\r\n        subject.test().assertValueCount(1)\r\n\r\n        // works\r\n//        Observable.create<List<String>> { emitter ->\r\n//            emitter.onNext(listOf(\"a\"))\r\n//            emitter.onComplete()\r\n//        }\r\n\r\n        // fails\r\n        subject\r\n            .flatMapIterable { it }\r\n            .filter { it == \"c\" }\r\n            .switchIfEmpty(Observable.create { emitter ->\r\n                emitter.onNext(\"c\")\r\n                emitter.onComplete()\r\n            })\r\n            .test()\r\n            .assertValue(\"c\")\r\n    }\r\n}\r\n```\r\n\r\nI just want to filter \"c\" and if there is no \"c\" switch to a new Observable an emit a \"c\". \r\n\r\nThis works if the origin of my rx chain starts with an Observable, but my test fails if my source is a subject. Does this make any sense to you?\r\n\r\nThanks!\r\n\r\nrxJavaVersion = '2.2.6'",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6495/comments",
    "author": "Voto",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-06-04T07:57:52Z",
        "body": "An observable is empty if doesn't signal onNext but only `onComplete`. Your code doesn't call `onComplete` and thus the `Subject` is infinite, preventing `switchIfEmpty` to function as you expected."
      },
      {
        "user": "Voto",
        "created_at": "2019-06-04T08:01:49Z",
        "body": "Oh sure! Thanks for helping me out"
      },
      {
        "user": "Voto",
        "created_at": "2019-06-04T11:26:19Z",
        "body": "For those interested in this issue. I made a workaround like this:\r\n\r\n```kotlin\r\n    @Test\r\n    fun testSwitchIfEmpty() {\r\n        val subject = BehaviorSubject.create<List<String>>()\r\n        subject.onNext(listOf(\"a\"))\r\n        // works\r\n        Maybe.create<List<String>> { emitter ->\r\n            if (subject.value != null) {\r\n                subject.value?.let {\r\n                    emitter.onSuccess(it)\r\n                }\r\n            } else {\r\n                emitter.onComplete()\r\n            }\r\n        }\r\n            .toObservable()\r\n            .flatMapIterable { it }\r\n            .filter { it == \"c\" }\r\n            .switchIfEmpty(Observable.create { emitter ->\r\n                emitter.onNext(\"c\")\r\n                emitter.onComplete()\r\n            })\r\n            .test()\r\n            .assertValue(\"c\")\r\n    }\r\n```"
      }
    ]
  },
  {
    "number": 6492,
    "title": "Observable.merge doesn't complete after completion of all observables",
    "created_at": "2019-05-31T17:33:48Z",
    "closed_at": "2019-06-05T07:38:49Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6492",
    "body": "Hi.\r\nWe encountered bug in **Observable.merge**, when it doesn't completes after complete of all observable. Also not all items, that were emitted by inner observables, emit from \"merge\" observable (elements lost somewhere)\r\n\r\nI attached log, and test to reproduce this issue. Test slightly big, cause we needed a lot of logging for catch issue. \r\n\r\nI tested this issue on RxJava2 2.2.9 \r\nI wrote test on Kotlin, but issues also reproduce on Java 8.\r\n\r\nNote, that emitting items goes from different threads (we using timer for this).\r\n\r\nHere the log:\r\n```\r\nSubject is processing 257 ms. Items count=24000\r\nMerge is processing 304 ms. Items count=20000\r\nSubject is processing 261 ms. Items count=25000\r\nSubject: onComplete. Total time=263 ms. Total items count=25552\r\nMerge is processing 1044 ms. Items count=20553\r\nMerge is processing 2044 ms. Items count=20553\r\n```\r\nin this example we lost about 5000 items, and merge observable did't completed.\r\n\r\nHere the test for reproduce this issue (sometimes you need run in 2-3 times for receiving bug):\r\n```\r\n @Test\r\n    fun observableMergeTest() {\r\n\r\n        val subjectItemsCount = AtomicInteger(0)\r\n        val mergeItemsCount = AtomicInteger(0)\r\n\r\n        val subject = PublishSubject.create<Int>()\r\n\r\n        //##### here the code with issue\r\n        Observable\r\n                .merge(\r\n                        Observable.empty(),\r\n                        subject.lift<Int> { observer -> LogProgressObserver(\"Subject\", 1000, 1000, observer) }\r\n                )\r\n                .lift<Int> { observer -> LogProgressObserver(\"Merge\", 1000, 1000, observer) }\r\n                .doOnNext { mergeItemsCount.incrementAndGet() }\r\n                .subscribe()\r\n        //#####\r\n\r\n\r\n        val completed = AtomicBoolean()\r\n        Observable\r\n                .range(0, Integer.MAX_VALUE)\r\n                .flatMapCompletable {\r\n                    Completable.timer(100, TimeUnit.MICROSECONDS)\r\n                            .andThen(Completable.fromAction {\r\n                                if (subjectItemsCount.getAndIncrement() - 5000 < mergeItemsCount.get())\r\n                                    subject.onNext(subjectItemsCount.get())\r\n                                else if (!completed.getAndSet(true))\r\n                                    subject.onComplete()\r\n                            })\r\n                }\r\n                .subscribe {}\r\n    }\r\n```\r\n\r\n\r\n\r\nfor logging we used small wrapper(LogProgressObserver):\r\n```\r\nclass LogProgressObserver(private val name: String, private val logPeriod: Long, private val logItemsCount: Long, private val observer: Observer<in Int>) : Observer<Int> {\r\n        private val itemsCount = AtomicLong()\r\n        private var subscribeTimestamp: Long = 0\r\n        private var timerDisposable: Disposable? = null\r\n        private val totalTimeString: String\r\n            get() {\r\n                val totalMillis = System.currentTimeMillis() - subscribeTimestamp\r\n                return \"$totalMillis ms\"\r\n            }\r\n\r\n        override fun onSubscribe(d: Disposable) {\r\n            subscribeTimestamp = System.currentTimeMillis()\r\n            println(\"$name: onSubscribe\")\r\n            timerDisposable = Observable\r\n                    .interval(logPeriod, TimeUnit.MILLISECONDS)\r\n                    .subscribe {\r\n                        println(getProcessingMessage(itemsCount.get()))\r\n                    }\r\n\r\n            observer.onSubscribe(d)\r\n        }\r\n\r\n        override fun onNext(o: Int) {\r\n            val count = itemsCount.incrementAndGet()\r\n            if (count % logItemsCount == 0L) {\r\n                val message = getProcessingMessage(count)\r\n                println(message)\r\n            }\r\n            observer.onNext(o)\r\n        }\r\n\r\n        override fun onError(e: Throwable) {\r\n            timerDisposable?.dispose()\r\n            val totalTimeString = totalTimeString\r\n            println(name + \": onError. Total time=\" + totalTimeString + \". Total items count=\" + itemsCount.get())\r\n            observer.onError(e)\r\n        }\r\n\r\n        override fun onComplete() {\r\n            timerDisposable?.dispose()\r\n            val totalTimeString = totalTimeString\r\n            println(name + \": onComplete. Total time=\" + totalTimeString + \". Total items count=\" + itemsCount.get())\r\n            observer.onComplete()\r\n        }\r\n\r\n        private fun getProcessingMessage(itemsCount: Long): String {\r\n            return \"$name is processing $totalTimeString. Items count=$itemsCount\"\r\n        }\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6492/comments",
    "author": "ArtemShaban",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-05-31T18:12:55Z",
        "body": "You are invoking `onNext` concurrently on an unserialized subject, which leads to undefined behavior. This requirement is stated in the javadocs:\r\n\r\n> Calling onNext(Object), onError(Throwable) and onComplete() is required to be serialized (called from the same thread or called non-overlappingly from different threads through external means of serialization). The Subject.toSerialized() method available to all Subjects provides such serialization and also protects against reentrance (i.e., when a downstream Observer consuming this subject also wants to call onNext(Object) on this subject recursively).\r\n\r\nUse `PublishSubject.create().toSerialized()` and see if you still lose events. Also that two atomic integer modified and compared with each other is somewhat suspicious."
      }
    ]
  },
  {
    "number": 6478,
    "title": "Endless loop on flatMap chain",
    "created_at": "2019-05-17T22:10:38Z",
    "closed_at": "2019-05-17T22:34:07Z",
    "labels": [
      "Question",
      "Android",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6478",
    "body": "I have this method for retrieving objects from Room database\r\n\r\n    @Query(\"SELECT * FROM cars\")\r\n    Flowable<CarListData> getCarsFromCache();\r\n\r\nand this method for making a network call\r\n\r\n    @GET(\"list_cars.json\")\r\n    Flowable<CarListSchema> getCarsFromNetwork(@Query(\"page\") int page);\r\n\r\nI am trying to implement some kind of caching strategy, so after **getCarsFromCache()** completes, I call **getCarsFromNetwork()** and then I do some extra stuff for caching the returned network data.\r\n\r\n    public Flowable<CarItemSchema> getPopularCars(String car) {\r\n        return getCarsFromCache().flatMap(new Function<CarListData, Publisher<CarListData>>() {\r\n            @Override\r\n            public Publisher<CarListData> apply(CarListData carListData) throws Exception {\r\n                return Flowable.just(carListData);\r\n            }\r\n        }).flatMap(new Function<CarListData, Publisher<CarListSchema>>() {\r\n            @Override\r\n            public Publisher<CarListSchema> apply(CarListData carListData) throws Exception {\r\n                return getCarsFromNetwork(carListData.getCurrentPage);\r\n            }\r\n        }, new BiFunction<CarListData, CarListSchema, List<CarItemSchema>>() {\r\n            @Override\r\n            public List<CarItemSchema> apply(CarListData carListData, CarListSchema carListSchema) throws Exception {\r\n                List<CarItemSchema> cars = carListData.getCars();\r\n                cars.addAll(carListSchema.getData().getCars());\r\n    \r\n                // TODO save cars to cache ...\r\n                return cars;\r\n            }\r\n        }).flatMap(new Function<List<CarItemSchema>, Publisher<CarItemSchema>>() {\r\n            @Override\r\n            public Publisher<CarItemSchema> apply(List<CarItemSchema> carItemSchema) throws Exception {\r\n                return Flowable.fromIterable(carItemSchema);\r\n            }\r\n        });\r\n    }\r\n\r\nThat method is called from this one\r\n\r\n    @Override\r\n    public Flowable<Car> onLoadCar(String brand) {\r\n        return getCarData(brand).map(new Function<CarItemSchema, Car>() {\r\n            @Override\r\n            public Car apply(CarItemSchema carItemSchema) throws Exception {\r\n                return new Car(carItemSchema.getModel(), carItemSchema.getCoverImage());\r\n            }\r\n        });\r\n    }\r\n\r\nand here I perform the subscription\r\n\r\n    public void loadCars() {\r\n        mSubscription = onLoadCar(\"fiat\").subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribeWith(new ResourceSubscriber<Car>() {\r\n    \r\n            @Override\r\n            public void onNext(Car car) {\r\n                mView.updateData(car);\r\n            }\r\n    \r\n            @Override\r\n            public void onError(Throwable e) {}\r\n    \r\n            @Override\r\n            public void onComplete() {}\r\n        });\r\n    }\r\n\r\nbut the problem is that **getCarsFromCache** and **getCarsFromNetwork** methods get called automatically for ever on an endless loop.\r\n\r\nMaybe I am using flatMap the wrong way. \r\nI just want to call **getCarsFromCache**, use it's response on **getCarsFromNetwork** method and then return the items to the view.\r\n\r\nWhat am I doing wrong?\r\n\r\nThanks in advance!\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6478/comments",
    "author": "aggressive-perfector",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-05-17T22:34:07Z",
        "body": "I don't understand the question. What is doing an endless loop? Flowable Bridges to Android databases are usually never ending and can keep signaling more items if the database gets updated. Please ask this question on StackOverflow."
      }
    ]
  },
  {
    "number": 6472,
    "title": "Stateful Service sessioning",
    "created_at": "2019-05-03T13:19:50Z",
    "closed_at": "2019-05-03T15:53:31Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6472",
    "body": "Hey, this is rather a question then issue... In my project I want to have multiple clients connecting to a service. I am currently using the java Rsocket implementation.\r\n\r\nThe service should maintain a state for each client. Now at this point I either can manage the clients by some identifier. This option I have already implemented. But I do not want to manage the session manually using strings.\r\n\r\nSo another idea is to identify the clients by the Rsocket connection. Is there a way to use ReactiveX in my use-case for identification of a specific client?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6472/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-05-03T13:55:16Z",
        "body": "RxJava works with in memory objects so you either access shared state or composite context information with each item flowing through. I don't know what RSocket can give you so you should ask such questions on their issue list or on Stackoverflow."
      },
      {
        "user": "ghost",
        "created_at": "2019-05-03T14:23:36Z",
        "body": "@akarnokd thank you for your response. Like lets say in my application, the server is holding an integer value for each client. Now each client will establish a channel with the server, and fire some increments , decrement commands. The server at this point should execute the commands on the integer value of the specific client who fired the command. \r\nTo identify the client on the server I either can use a string identifier or maybe (the fancy idea) the channel. The question is wether i can use Reactivex for that... If not, than what could i use anyway?\r\n\r\nNow to your comment. I have in memory integer values which are being changed by the server as it gets the command from a client. So RxJava should be able to work with those? How would RxJava identify which client's integer field is accessed?"
      },
      {
        "user": "akarnokd",
        "created_at": "2019-05-03T15:53:31Z",
        "body": "I don't know, it is outside of the scope of RxJava as we don't do networking, flow context or sessioning. Please ask this question on StackOverflow or on the RSocket forums/issue list."
      }
    ]
  },
  {
    "number": 6456,
    "title": "Subject not notified when using IO scheduler?",
    "created_at": "2019-04-09T20:05:01Z",
    "closed_at": "2019-04-09T20:34:56Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6456",
    "body": "In the following snippet:\r\n\r\n```kotlin\r\nval myObs = Observable.just(1)\r\nval mySubject = PublishSubject.create<Int>()\r\n\r\nmySubject\r\n    .doOnNext { Log.d(\"mydebug\", \"called on next\") }\r\n    .subscribeOn(Schedulers.io())\r\n    .doOnError { Log.d(\"mydebug\", \"error: $it\") }\r\n    .subscribe { Log.d(\"mydebug\", \"event: $it\") }\r\n\r\nmyObs.subscribe(mySubject)\r\n```\r\n\r\nExpected behavior:\r\nObserver is notified. The logs \"called on next\" and \"event: $it\" appear.\r\n\r\nActual behavior:\r\nNo logs. The observer seems to not be notified.\r\n\r\nNotes:\r\nApparently the combination of using a subject and the IO scheduler causes this. Either removing`.subscribeOn(Schedulers.io())` or subscribing directly to `myObs` produces the expected behavior.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6456/comments",
    "author": "ivnsch",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-04-09T20:34:56Z",
        "body": "`subscribeOn` on a `Subject` has no practical effect. It moves the subscription to another thread and you drive the subject still from the main thread. There is a race and thus the `subscribe { Log.d(\"mydebug\", \"event: $it\") }` may not happen in time to see the value from `myObs`. Use `ReplaySubject` or `UnicastSubject` to ensure a late subscriber still gets all events."
      }
    ]
  },
  {
    "number": 6444,
    "title": "Terminating app due to an uncaught exception 'java.lang.UnsupportedOperationException', reason: 'Exceeded maximum number of wifi locks'",
    "created_at": "2019-03-26T09:41:53Z",
    "closed_at": "2019-03-26T10:15:13Z",
    "labels": [
      "Question",
      "2.x",
      "StackOverflow"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6444",
    "body": "\r\nLast Exception Backtrace\r\n--\r\n0 | io.reactivex.exceptions.OnErrorNotImplementedException: Exceeded maximum number of wifi locks\r\n1 | at io.reactivex.internal.functions.Functions$ag.a(SourceFile:704)\r\n2 | at io.reactivex.internal.functions.Functions$ag.accept(SourceFile:701)\r\n3 | at io.reactivex.internal.observers.LambdaObserver.onError(SourceFile:77)\r\n4 | at io.reactivex.internal.observers.LambdaObserver.onNext(SourceFile:67)\r\n5 | at io.reactivex.internal.operators.observable.ObservableSubscribeOn$a.onNext(SourceFile:58)\r\n6 | at io.reactivex.internal.operators.observable.ObservableObserveOn$a.b(SourceFile:200)\r\n7 | at io.reactivex.internal.operators.observable.ObservableObserveOn$a.run(SourceFile:252)\r\n8 | at io.reactivex.internal.schedulers.ScheduledRunnable.run(SourceFile:66)\r\n9 | at io.reactivex.internal.schedulers.ScheduledRunnable.call(SourceFile:57)\r\n10 | at java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n11 | at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:301)\r\n12 | at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\r\n13 | at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\r\n14 | at java.lang.Thread.run(Thread.java:764)\r\n15 | Caused by: java.lang.UnsupportedOperationException: Exceeded maximum number of wifi locks\r\n16 | at android.net.wifi.WifiManager$MulticastLock.acquire(WifiManager.java:4910)\r\n17 | at com.android.netgeargenie.utils.nsdpdiscovery.SendNSDPPacket.callBroadcast(SourceFile:88)\r\n18 | at com.android.netgeargenie.control.ScanManagerControl$4.a(SourceFile:496)\r\n19 | at com.android.netgeargenie.control.ScanManagerControl$4.accept(SourceFile:488)\r\n20 | at io.reactivex.internal.observers.LambdaObserver.onNext(SourceFile:63)\r\n21 | at io.reactivex.internal.operators.observable.ObservableSubscribeOn$a.onNext(SourceFile:58)\r\n22 | at io.reactivex.internal.operators.observable.ObservableObserveOn$a.b(SourceFile:200)\r\n23 | at io.reactivex.internal.operators.observable.ObservableObserveOn$a.run(SourceFile:252)\r\n24 | at io.reactivex.internal.schedulers.ScheduledRunnable.run(SourceFile:66)\r\n25 | at io.reactivex.internal.schedulers.ScheduledRunnable.call(SourceFile:57)\r\n26 | at java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n27 | at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:301)\r\n28 | at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\r\n29 | at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\r\n30 | at java.lang.Thread.run(Thread.java:764)\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6444/comments",
    "author": "KumariAnjuThakur",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-03-26T10:15:13Z",
        "body": "You did not implement an onError handler in your subscribe method and hence the crash.\r\n\r\nAlso, please do not post a \"core dump\" without any context or example what you were doing and please post Android related problems on StackOverflow. Thanks."
      }
    ]
  },
  {
    "number": 6440,
    "title": "Can I use .observeOn(Schedulers.newThread(\"read-thread\"))， .observeOn(Schedulers.newThread(\"write-thread\")) to appoint two thread to read and write?i hope i can do this",
    "created_at": "2019-03-21T15:19:00Z",
    "closed_at": "2019-03-21T16:00:54Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6440",
    "body": "Can I use .observeOn(Schedulers.newThread(\"read-thread\"))， .observeOn(Schedulers.newThread(\"write-thread\")) to appoint two thread to read and write?i hope i can do this. when \"read-thread\" is not available ,it will be created,otherwise , use \"read-thread\" that available.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6440/comments",
    "author": "wrrgit",
    "comments": [
      {
        "user": "wrrgit",
        "created_at": "2019-03-21T15:21:38Z",
        "body": "Can I use .observeOn(Schedulers.newThread(\"read-thread\"))， .observeOn(Schedulers.newThread(\"write-thread\")) to appoint two thread to read and write?i hope i can do this. when \"read-thread\" is not available ,it will be created,otherwise , use \"read-thread\" that available."
      },
      {
        "user": "akarnokd",
        "created_at": "2019-03-21T16:00:54Z",
        "body": "No. Consider using `Schedulers.from` with a ExecutorService configured as you see fit."
      }
    ]
  },
  {
    "number": 6418,
    "title": "2.2.0 test failed : FlowableBackpressureTests. testOnBackpressureBuffer ， ObservableRefCountTest. publishNoLeak",
    "created_at": "2019-02-21T03:28:09Z",
    "closed_at": "2019-02-21T07:50:59Z",
    "labels": [
      "Question",
      "Test-Failures",
      "2.x",
      "Missing-Details"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6418",
    "body": "> org.junit.runners.model.TestTimedOutException: test timed out after 2000 milliseconds\r\n\r\n\tat sun.misc.Unsafe.park(Native Method)\r\n\tat java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\r\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)\r\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)\r\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)\r\n\tat java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)\r\n\tat io.reactivex.observers.BaseTestConsumer.await(BaseTestConsumer.java:213)\r\n\tat io.reactivex.observers.BaseTestConsumer.awaitTerminalEvent(BaseTestConsumer.java:702)\r\n\tat io.reactivex.flowable.FlowableBackpressureTests.testOnBackpressureBuffer(FlowableBackpressureTests.java:658)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:497)\r\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\r\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\r\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\r\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\r\n\tat org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:298)\r\n\tat org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:292)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\n\r\n> java.lang.AssertionError: 8,414,032 -> 108,340,920\r\n\r\n\tat org.junit.Assert.fail(Assert.java:88)\r\n\tat org.junit.Assert.assertTrue(Assert.java:41)\r\n\tat io.reactivex.internal.operators.observable.ObservableRefCountTest.publishNoLeak(ObservableRefCountTest.java:726)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:497)\r\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\r\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\r\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\r\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\r\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\r\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\r\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\r\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\r\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\r\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\r\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\r\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\r\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\r\n\tat org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:114)\r\n\tat org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:57)\r\n\tat org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:66)\r\n\tat org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)\r\n\tat sun.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:497)\r\n\tat org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\r\n\tat org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\r\n\tat org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\r\n\tat org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\r\n\tat com.sun.proxy.$Proxy1.processTestClass(Unknown Source)\r\n\tat org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:108)\r\n\tat sun.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:497)\r\n\tat org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\r\n\tat org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\r\n\tat org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:146)\r\n\tat org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:128)\r\n\tat org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:404)\r\n\tat org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)\r\n\tat org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\r\n\tat org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)\r\n\tat java.lang.Thread.run(Thread.java:745)",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6418/comments",
    "author": "cmder",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-02-21T06:51:36Z",
        "body": "How, when, what's the context, why were you running our unit tests on what machine? Why 2.2.0 when we are at 2.2.6?"
      },
      {
        "user": "cmder",
        "created_at": "2019-02-21T07:21:06Z",
        "body": "> How, when, what's the context, why were you running our unit tests on what machine? Why 2.2.0 when we are at 2.2.6?\r\n\r\nI just follow the recommended steps .\r\n`$ git clone git@github.com:ReactiveX/RxJava.git`\r\n`$ cd RxJava/`\r\n`$ ./gradlew build`\r\nand it generated three .jar files under /build/libs\r\nbuild/libs/rxjava-2.2.0-SNAPSHOT.jar\r\nbuild/libs/rxjava-2.2.0-SNAPSHOT-javadoc.jar\r\nbuild/libs/rxjava-2.2.0-SNAPSHOT-sources.jar\r\nbut 2 tests failed"
      },
      {
        "user": "akarnokd",
        "created_at": "2019-02-21T07:50:59Z",
        "body": "Some unit tests may run slower on some machines if that machine is also doing something heavy at the same time, hence the timeout. The current values are good enough for Travis and a Haswell+ CPUs. I don't see any action is needed on RxJava's part."
      }
    ]
  },
  {
    "number": 6413,
    "title": "Flowable(or Observable) is blocked when thread pool executor throws RejectedExecutionException",
    "created_at": "2019-02-19T20:11:56Z",
    "closed_at": "2019-05-06T12:33:27Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6413",
    "body": "Hello,\r\n\r\nI just started using javarx2(version 2.2.6) and faced the next issue(or not, but it would be good to know what I'm doing not right): Flowable or observable is blocked forever on every blocking operation like blockingFirst or blockingSubscribe when Scheduler throws RejectedExecutionException.\r\nHere is slightly modified example from your README that reproduce the issue:\r\n\r\n```java\r\nThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1,\r\n        10, TimeUnit.MINUTES, new LinkedBlockingQueue<>(1));\r\ntry {\r\n    Scheduler scheduler = Schedulers.from(executor);\r\n    Flowable.range(1, 10)\r\n           .flatMap(v ->\r\n                    Flowable.just(v)\r\n                            .subscribeOn(scheduler)\r\n                            .map(w -> w * w)\r\n            )\r\n            .blockingSubscribe(System.out::println, System.err::println);\r\n} finally {\r\n    executor.shutdown();\r\n}\r\n```\r\n\r\nSo it would be good to know how to deal with the situation when executor throws RejectedExecutionException.\r\n\r\nThank you.\r\nMax.\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6413/comments",
    "author": "mshabunin77",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-02-19T20:40:36Z",
        "body": "It's not possible to handle this case from within RxJava. Operators try to schedule emissions/processing and if it is rejected, we can't do anything about it. Signaling onError may run concurrently with existing emissions running on the scheduler in the chain and thus violate the protocol requirements or thread expectations. Don't shut down an executor before stopping flows that depend on it."
      },
      {
        "user": "mshabunin77",
        "created_at": "2019-02-19T23:48:57Z",
        "body": "Hm, interesting - I tried this scenario with javarx1 and everything is working - I'm getting onError event that I can handle. \r\n\r\nSo what do you mean by 'violating protocol requirements or thread expectation'? \r\nDo you mean that onError will have to use the same executor(or specified in observeOn method) that also may reject?  \r\nIn that case I would rethrow rejection exception from observable rather than blocking it, or at least gave the possibility to configure such behaviour. IMHO from thread expectation perspective it's more fair not to hide rejection exception especially when the result is blocking thread.\r\n\r\nSolving this may help in cases like this: imagine we have a service with limited thread pool for handling incoming requests and a simple circuit breaker to call another service. This circuit breaker is implemented by rejecting tasks in separate thread pool when the queue is bigger than some threshold or the waiting time in queue exceeded timeout value. In this situation we quickly run out of threads on our service because of this blocking situation and entire service will be down.\r\nI know that hystrix uses similar approach with javarx1. \r\n\r\nAlso RejectedExecutionException is valid exception that may be thrown from executors - this fact makes it dangerous to use(or switch to) different executors while using blocking method. \r\n\r\nAt my work many developers use javarx1 (mostly simple cases - Single's returned from feign-hystrix and combined by zip or merge) and I was looking at possibility to upgrade to newer stack like resilience4j and javarx2. \r\nSo dealing with this issue would be really helpful and more details would be really appreciated.\r\n\r\nThank you.\r\nMax.\r\n\r\nPS. About executor#shutdown - sorry that I included it in my example, it's irrelevant to this situation and by the way it's doing what is expected - every observable emit single event and then blockingSubscribe waiting for completion. After this executor can be shut down."
      },
      {
        "user": "akarnokd",
        "created_at": "2019-02-20T00:00:14Z",
        "body": "> I'm getting onError event that I can handle.\r\nThat was an invalid behavior in RxJava 1. RxJava 1 is no longer supported.\r\n\r\n> Do you mean that onError will have to use the same executor(or specified in observeOn method) that also may reject?\r\nAmong other things, yes.\r\n\r\n> In that case I would rethrow rejection exception from observable rather than blocking it,\r\nDoesn't work. The flow execution is generally disconnected from the location you are blocking. Also if it were to throw, you lost the flow entirely so no way to retry.\r\n\r\n> This circuit breaker is implemented by rejecting tasks in separate thread pool when the queue is bigger than some threshold or the waiting time in queue exceeded timeout value.\r\nThis undermines the fundamental expectation that a scheduler can run tasks when the flow is not disposed. Bounded-queue executors will most likely deadlock the flow anyway. Use backpressure and maxConcurrency settings instead.\r\n\r\n> while using blocking method\r\nThere is rarely any reason to block.\r\n"
      },
      {
        "user": "svishnyakoff",
        "created_at": "2019-04-09T10:48:33Z",
        "body": "We faced a similar issue in production when under high load we got the **entire system stuck**. In our case we tried to isolate rxJava logic in a single class without exposing rxJava type outside, thus had to use blocking operation. \r\n\r\nRight now the library silently ignores `subscribe` operation when we got out of threads, that leads to some kind of deadlock. As a user, if I had to choose to ignore lack of threads error and thus get deadlock or got notified in the current thread about error in `onError` method (but violate thread expectations), I would choose the second option, though it is quite subjective\r\n\r\nBlocking operations are perfectly legitimate to use based on the existing API, or at least I have not seen any javadoc discouraging that nor @Depracated annotation. It is very scaring to see that existing API consider the possiblity of deadlock situations which usually occur under high load, and we not going to provide some generic solution that would fix it or at least make it fail fast\r\n\r\nExample of the code which wait forever\r\n```java\r\nThreadPoolExecutor executor = new ThreadPoolExecutor(0, 5, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());\r\n\r\n        Observable.range(1, 100)\r\n                .flatMap(index -> Observable.just(index)\r\n                        .map(i -> {\r\n                            TimeUnit.SECONDS.sleep(5);\r\n                            return i;\r\n                        })\r\n                        .subscribeOn(Schedulers.from(executor))\r\n                )\r\n                .toList()\r\n                .blockingGet();\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2019-04-09T11:08:03Z",
        "body": "Again, we can't handle this type of resource exhaustion from within RxJava. Avoid blocking and limit concurrency to a level that your entire application is comfortable with."
      },
      {
        "user": "ashwing",
        "created_at": "2019-07-08T23:40:52Z",
        "body": "This is an issue even for non blocking subscribe. In our application we have seen the subscribe call failing silently making the application to get stuck and onNexct calls failing silently causing data loss issues. At bare minimum we expect the execute() exceptions like RejectedExecutionException to be propagated back to the caller thread so that we can catch the exception and take appropriate action."
      }
    ]
  },
  {
    "number": 6401,
    "title": "[2.x] - Question - Flowable.intervalRange().subcribeOn behavior",
    "created_at": "2019-02-06T12:34:40Z",
    "closed_at": "2019-02-06T14:48:52Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6401",
    "body": "Hi,\r\nI have encountered a strange behavior when combining Flowable.intervalRange with subscribeOn.\r\nI have noticed that the sequence generated by Flowable.intervalRange starts to be produced by a thread from RxComputationThreadPool (as expected) but sometimes it switches to the thread of the scheduler set by subcribeOn and after a while goes back to the original thread.\r\n\r\nMy example code of this behavior:\r\n\r\n          \r\n```java\r\nTestSubscriber<String> subscriber = new TestSubscriber<>();\r\n\r\nFlowable.intervalRange(1,4000,0,1,TimeUnit.NANOSECONDS)\r\n        .onBackpressureBuffer()\r\n        .subscribeOn(Schedulers.newThread())\r\n        .map( value -> Thread.currentThread().getName())\r\n        .distinct()\r\n        .subscribe(subscriber);\r\n\r\nsubscriber.awaitTerminalEvent();\r\nsubscriber.assertComplete();\r\nassertEquals(1, subscriber.valueCount());\r\n```\r\n\r\nSo my guestion is, is this the desired behaviour?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6401/comments",
    "author": "damianofontana85",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-02-06T14:48:52Z",
        "body": "This is a legal behavior. Using `subscribeOn` with `intervalRange` has no practical effect as `intervalRange` generates items on the computation scheduler by default and has no subscription side-effect to be moved elsewhere by `subscribeOn`. In addition, you are using `onBackpressureBuffer` which may push through an item from the sender thread (computation) or buffer and get replayed by the requestor thread, which in this case is driven by `subscribeOn` and happens on the new thread worker.\r\n\r\nPlease in the future, ask such questions on StackOverflow."
      }
    ]
  },
  {
    "number": 6396,
    "title": "2.2.6 groupBy().flatMap() error handling",
    "created_at": "2019-02-05T16:42:44Z",
    "closed_at": "2019-02-13T09:54:52Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6396",
    "body": "Hi,\r\nI have encountered what I think is wrong behavior when combining groupBy and flatMap operator.\r\n\r\nMy example code of this behavior:\r\n\r\n   \r\n\r\n       val sequence = PublishSubject.create<Int>()\r\n        sequence.groupBy { it / 3 }.flatMap { it }.subscribe({\r\n            println(it)\r\n        }, {\r\n            //I thought the exception will be handeled here and that will be the end of it.\r\n            println(it.message)\r\n        })\r\n        sequence.onNext(1)\r\n        sequence.onNext(2)\r\n        sequence.onNext(3)\r\n        sequence.onNext(4)\r\n        sequence.onNext(5)\r\n        sequence.onNext(6)\r\n        sequence.onNext(7)\r\n        sequence.onNext(8)\r\n        sequence.onError(Exception(\"Exception that is handled and also will ruin my day\"))\r\n\r\nI assumed once there is an error in sequence, it will be propagated once and handeled where I marked it in code.\r\n\r\nThe reality is that the excepion is propagated to every sequence created by groupBy, one is handeled and second one crashes the app with UndeliverableException.\r\n\r\nIf I look at the flatMap operator without groupBy, the behaviour is as expected:\r\n\r\n``` val observableArray = Observable.fromArray(\r\n                Observable.just(\"TEST1\"),\r\n                Observable.error<String>(Exception(\"first\")),\r\n                Observable.just(\"TEST2\"),\r\n                Observable.error<String>(Exception(\"second\")),\r\n                Observable.just(\"TEST3\"),\r\n                Observable.just(\"TEST4\"),\r\n                Observable.error<String>(Exception(\"third\")),\r\n                Observable.error<String>(Exception(\"fourth\")),\r\n                Observable.just(\"TEST5\"),\r\n                Observable.error<String>(Exception(\"fifth\"))\r\n        )\r\n\r\n        observableArray.flatMap { it }.subscribe({\r\n            println(it)\r\n        }, {\r\n            println(it.message)\r\n        })\r\n```\r\nOutput of this is:\r\n\r\n```\r\nTEST1\r\nfirst\r\n```\r\n\r\n\r\nSo my guestion is, is this the desired behaviour? How can I handle the exception correctly?\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6396/comments",
    "author": "balakzde",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-02-05T17:38:04Z",
        "body": "This is the expected behavior: `groupBy` notifies all active groups and the main output of the same error, `flatMap` handles only the very first error and routes any other errors into the global error handler. Use the `delayError` option with `flatMap` and/or install a global error handler in `RxJavaPlugins` to prevent crashes."
      }
    ]
  },
  {
    "number": 6394,
    "title": "[2.x] Flowable.parallel() consumes and produces excessive elements.",
    "created_at": "2019-02-05T10:45:04Z",
    "closed_at": "2019-02-13T09:52:59Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6394",
    "body": "Flowable.parallel() produces more elements than requested and consumes even more, even if `prefetch` is set to 1.\r\n\r\nSample:\r\n```java\r\nimport io.reactivex.Maybe;\r\nimport io.reactivex.schedulers.Schedulers;\r\n\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\npublic class TestPrefetch {\r\n    public static void main(String[] args) {\r\n        AtomicInteger i = new AtomicInteger(0);\r\n        Maybe<Integer> maybeSource = Maybe.create(emitter -> emitter.onSuccess(i.incrementAndGet()));\r\n        maybeSource\r\n                .repeat()\r\n                .parallel(30, 1)\r\n                .runOn(Schedulers.io(), 1)\r\n                .map(Object::toString)\r\n                .sequential(1)\r\n                .take(100)\r\n                .blockingSubscribe(System.out::println);\r\n        System.out.println(\"Consumed: \" + i.get());\r\n    }\r\n}\r\n```\r\n\r\nActual output:\r\n```plain\r\n1\r\n2\r\n3\r\n...\r\n104\r\nConsumed: 145\r\n```\r\n\r\nExpected output:\r\n```plain\r\n1\r\n2\r\n...\r\n100\r\nConsumed: 100\r\n```\r\n\r\nTested on versions 2.2.5 and 2.2.6.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6394/comments",
    "author": "daemas",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-02-05T11:06:40Z",
        "body": "This behavior is acceptable. There are two effects in play here:\r\n\r\n1) The parallelism introduces an asynchrony between the decision to stop the sequence and the requesting for more items. 29 of the 30 rails in the sequence can go ahead more before they get eventually cancelled by the 1 rail servicing `take()`. Try with different parallelism level and see it will produce a bit more.\r\n\r\n2) If you index the result values you'll see that you get 100 items, but their order can be arbitrary as it may get values from rails that went above 100 due to reason 1). Try this and you see there are no more than 100 item printouts:\r\n\r\n```java\r\nAtomicInteger j = new AtomicInteger(0);\r\nAtomicInteger i = new AtomicInteger(0);\r\nMaybe<Integer> maybeSource = Maybe.create(emitter -> emitter.onSuccess(i.incrementAndGet()));\r\nmaybeSource\r\n.repeat()\r\n.parallel(30, 1)\r\n.runOn(Schedulers.io(), 1)\r\n.map(Object::toString)\r\n.sequential(1)\r\n.take(100)\r\n.blockingSubscribe(v -> System.out.println(j.incrementAndGet() + \" - \" + v));\r\n\r\nSystem.out.println(\"Consumed: \" + i.get());\r\n```"
      },
      {
        "user": "daemas",
        "created_at": "2019-02-05T11:30:34Z",
        "body": "Thank you for your answer @akarnokd.\r\n1. So is there currently no option to fetch from the source the exact amount of items requested by the subscriber and process them in parallel? I tried to do it the \"old-fashioned\" way with flatMap(), but it also seem to fetch a little bit more than requested.\r\n2. Oh, sure, how could I overlook the fact that the order of items is not guaranteed if they are processed in parallel."
      },
      {
        "user": "akarnokd",
        "created_at": "2019-02-05T11:43:06Z",
        "body": "There is no way to use the backpressure across multiple operators and async stages to request from a source. Use a feedback loop with `PublishProcessor` where you trigger requests whenever you call onNext regardless of the backpressure status of other stages."
      },
      {
        "user": "daemas",
        "created_at": "2019-02-05T20:31:26Z",
        "body": "> There is no way to use the backpressure across multiple operators and async stages to request from a source.\r\n\r\nWell, I'm trying to understand why, and I'm failing to. I think of a reactive pull-based pipeline. To simplify, let's imagine there are only a producer and a consumer of the items. The consumer asks for (pulls) exactly one item, processes it, and after that asks for another one. The producer does not emit the next item unless the consumer asks for it. Right? If we introduce an intermediate stage, it becomes a producer for the last stage and a consumer for the first one. So when the last stage requests an item the intermediate stage just passes the request to the first stage, and then receives and processes the item and passes the result to the last stage. Then why in my example the very first producer (`maybeSource`) produces more items then requested by the very last consumer? Who requests them in the chain of operators, and why?"
      },
      {
        "user": "akarnokd",
        "created_at": "2019-02-05T20:40:27Z",
        "body": "Don't think of it as one entity. A flow is assembled from multiple stages and backpressure is negotiated on a stage boundary where individual stages can decide on the request pattern themselves. Some don't interfere, some batch and some keep prefetching when the downstream's `onNext` returns. This is a non-trivial topic and requires a lot of experience to be able to fully understand the consequences. Many times, 1:1 is not even clear to begin with, i.e., when merging two async sources, requesting 1 should request an item from which source?"
      },
      {
        "user": "daemas",
        "created_at": "2019-02-06T10:43:19Z",
        "body": "> Some don't interfere, some batch and some keep prefetching when the downstream's `onNext` returns.\r\n\r\nWell, many operators accept `bufferSize` argument, so I supposed I would be able to control the prefetching and batching behaviour with it's help. Looks like it's not the case.\r\n\r\n> This is a non-trivial topic and requires a lot of experience to be able to fully understand the consequences.\r\n\r\nIndeed, I am not too experienced with the RX library. I came from Scala's `Future` world, where there are no means of controlling backpressure \"out of the box\", so I had to control and fine-tune it manually in the places where it was necessary. Hence is my surprise to find I cannot fine-tune it the same way with RX, even if I specify mentioned `bufferSize` parameters.\r\n\r\n> Many times, 1:1 is not even clear to begin with, i.e., when merging two async sources, requesting 1 should request an item from which source?\r\n\r\nWell, there are several commonly used balancing scenarios. Round-robin is my favorite for it's simplicity and general applicability :) Also users might choose one of pre-defined strategies or implement and provide a custom one.\r\n\r\nAnyway, thank you for explaining all these aspects to me. Like I said, I'm new to the RX world, and just getting used to it. So I feel I'm just trying to use my old habits within the new environment, and I have to find another way."
      }
    ]
  },
  {
    "number": 6391,
    "title": "I don't know why Schedulers class NewThreadTask implements Callable ",
    "created_at": "2019-01-29T11:39:52Z",
    "closed_at": "2019-01-29T11:58:28Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6391",
    "body": "static final class NewThreadTask implements Callable<Scheduler> {\r\n        @Override\r\n        public Scheduler call() throws Exception {\r\n            return NewThreadHolder.DEFAULT;\r\n        }\r\n    }\r\n\r\nchange to\r\n\r\ngetInstance(){\r\n return NewThreadHolder.DEFAULT;\r\n}\r\n\r\nthe first What are the benefits?\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6391/comments",
    "author": "guohaiping521",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-01-29T11:58:28Z",
        "body": "It works around a problem with premature initialization of schedulers when they are overridden but the default implementation is not required nor is desirable to get initialized in the first place. This several indirections allow this to happen.\r\n\r\nYou can follow the Git Blame to find the relevant PRs/issues, such as #4585."
      },
      {
        "user": "guohaiping521",
        "created_at": "2019-01-30T02:14:18Z",
        "body": "Thank you very much"
      }
    ]
  },
  {
    "number": 6387,
    "title": "set timeout for each observable and not global",
    "created_at": "2019-01-27T16:55:01Z",
    "closed_at": "2019-01-27T17:23:42Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6387",
    "body": "Hi My observable is this:\r\n\r\n```\r\npublic Observable<String> getPingObservable(String url) {\r\n\r\n\r\n    return Observable.create(subscriber -> {\r\n\r\n        connectionsManager.checkProxy(time -> {\r\n            subscriber.onNext(time);\r\n        }\r\n\r\n        );\r\n    });\r\n\r\n}\r\n```\r\nand i set timeout\r\n\r\n  ```\r\nObservable.from(urlList)\r\n            .subscribeOn(Schedulers.io())\r\n\r\n            .flatMap(url -> {\r\n                return getPingObservable(url)\r\n                        .subscribeOn(Schedulers.io())\r\n                        .timeout(500, TimeUnit.MILLISECONDS)\r\n                        .onErrorResumeNext(throwable -> Observable.empty());\r\n\r\n            })\r\n            .toList()\r\n           .subscribe();\r\n```\r\nafter 500 MILLISECONDS all Observables emit onError method but i want to\r\n\r\nuse timeout for each Observable not global and do not terminate and\r\n\r\nemit onError for other Observable",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6387/comments",
    "author": "AhmadNemati",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-01-27T17:23:42Z",
        "body": "Because of `flatMap`, all your URLs run pretty much at the same time. Use `concatMap` to have them run one after the other or use `flatMap`'s `maxConcurrency` parameter to limit the active inner flows.\r\n\r\nAlso I recommend asking such questions on StackOverflow in the future."
      }
    ]
  },
  {
    "number": 6385,
    "title": "Possible race condition in doOnLifeCycle and add doOnLifeCycle to Single",
    "created_at": "2019-01-26T00:03:08Z",
    "closed_at": "2019-02-13T09:55:33Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6385",
    "body": "Hi,\r\n\r\nI am wondering why we do not make onSubscribe and onDispose actions synchronized, to avoid possible race condition? My case is we would like to prepare some resources on subscription and release them onDispose. Without synchronization it's easy to get a leak since the resource may not be ready when dispose() is triggered. \r\n\r\nAlso, why there's no doOnLifeCycle in Single?\r\n\r\nThank you!",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6385/comments",
    "author": "xblwyc",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-01-26T08:13:21Z",
        "body": "Their purpose is to side-effect those lifecycle events. It is up to you to coordinate between them if you need, but your use case implies anoter operator exactly for that type.of work: `using()`."
      }
    ]
  },
  {
    "number": 6382,
    "title": "Completable dispose maybe not work",
    "created_at": "2019-01-23T06:52:48Z",
    "closed_at": "2019-02-13T09:56:38Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6382",
    "body": "# Question is:\r\nWhen dispose the completable ,the observer onComplete method should not be run, but it did  run.\r\n\r\n# rxjava version  2.2.4\r\n\r\n# reproduct code\r\n```java\r\n    @Test(expected = AssertionError.class)\r\n    public void notWork2() throws Throwable {\r\n        final AtomicReference<Throwable> exceptionReference = new AtomicReference<>();\r\n\r\n        AtomicReference<Disposable> disposableAtomicReference = new AtomicReference<>();\r\n        Completable.complete()\r\n                .doOnComplete(new Action() {\r\n                    @Override\r\n                    public void run() throws Exception {\r\n                        log(\"DisposeTest.run1\");\r\n                        String a = null;\r\n                        for (int i = 0; i < 4000; i++) {\r\n                            a += String.valueOf(i);\r\n                        }\r\n                        log(\"DisposeTest.run2\");\r\n                    }\r\n                })\r\n                .subscribeOn(Schedulers.io())\r\n                .subscribe(new CompletableObserver() {\r\n                    @Override\r\n                    public void onSubscribe(Disposable d) {\r\n                        disposableAtomicReference.set(d);\r\n                        log(\"DisposeTest.onSubscribe\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onComplete() {\r\n                        log(\"DisposeTest.onComplete\");\r\n                        exceptionReference.set(new AssertionError(\"There should not be executed\"));\r\n\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(Throwable e) {\r\n                        e.printStackTrace();\r\n                        log(\"DisposeTest.onError\");\r\n                        exceptionReference.set(e);\r\n\r\n                    }\r\n                });\r\n\r\n        log(\"DisposeTest.main\");\r\n        disposableAtomicReference.get().dispose();\r\n        TimeUnit.SECONDS.sleep(3);\r\n        if (exceptionReference.get() != null) {\r\n            throw exceptionReference.get();\r\n        }\r\n    }\r\n\r\n    static void log(String message) {\r\n        System.out.println(\"[\" + System.currentTimeMillis() + \"] (\" + Thread.currentThread().getName() + \") \" + message);\r\n    }\r\n```\r\n\r\n\r\n# result log\r\n```\r\n[1548226136014] (main) DisposeTest.onSubscribe\r\n[1548226136017] (main) DisposeTest.main\r\n[1548226136019] (RxCachedThreadScheduler-1) DisposeTest.run1\r\n[1548226136067] (RxCachedThreadScheduler-1) DisposeTest.run2\r\n[1548226136067] (RxCachedThreadScheduler-1) DisposeTest.onComplete\r\n\r\nProcess finished with exit code 0\r\n```\r\n\r\n\r\nIf you run this code fragment. Unit test should  pass;\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6382/comments",
    "author": "Xigong93",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-01-23T07:43:15Z",
        "body": "Some completable stages don't react to dispose eagerly. Apply `onTerminateDetach` before the subscribe and try again."
      }
    ]
  },
  {
    "number": 6369,
    "title": "Flowable.java just methods",
    "created_at": "2019-01-15T16:24:17Z",
    "closed_at": "2019-01-15T16:28:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6369",
    "body": "I was wondering is there any reason why **just** method in Flowable class is reimplemented 10 times? I mean why not using varargs instead ?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6369/comments",
    "author": "wathek",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-01-15T16:28:35Z",
        "body": "Avoids the unchecked warnings you get with a varargs and generic argument types, for example `List<T>...` gets flagged in Java 6. The most common simple usages of `just` require 1..10 direct arguments, hence the overloads."
      }
    ]
  },
  {
    "number": 6354,
    "title": "2.2.5: observeOn might not work for Completable.andThen(Completable)",
    "created_at": "2019-01-02T16:08:36Z",
    "closed_at": "2019-01-12T18:06:24Z",
    "labels": [
      "Question",
      "PR welcome",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6354",
    "body": "  - RxJava 2.2.5\r\n\r\nIt seems that Completable passed to `Completable.andThen(...)` is not run on scheduler passed to observeOn. So\r\n```\r\n        Completable.fromAction(() -> System.out.println(\"subscribing in thread \" + Thread.currentThread().getName()))\r\n                .observeOn(Schedulers.io())\r\n                .andThen(Completable.fromAction(() -> System.out.println(\"and then in thread \" + Thread.currentThread().getName())))\r\n                .subscribe(() -> System.out.println(\"observing in thread \" + Thread.currentThread().getName()));\r\n```\r\nmight produce\r\n```\r\nsubscribing in thread main\r\nand then in thread main\r\nobserving in thread main\r\n```\r\nI don't know if it's by design or not, but it seems to be caused by 'race condition' in `CompletableConcatArray` where we have do {...} while() loop, when next() method is run second time from io() thread and bumps up the atomic counter, and then second iteration of do/while loop starts, and executes completable from andThen operator from main thread. It can be easily reproduced if you add some work to that loop before checking condition in while clause so in `CompletableConcatArray`:\r\n```\r\n                a[idx].subscribe(this);\r\n                // spin the cpu for a while to make ObserveOnCompletable run this next() method\r\n                int i = 0, j = 0;\r\n                while (i < 1000_000) {\r\n                    i++;\r\n                    while (j < 1000_000) {\r\n                        j++;\r\n                    }\r\n                }\r\n            } while (decrementAndGet() != 0);\r\n``` ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6354/comments",
    "author": "pjastrz",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-01-02T17:07:38Z",
        "body": "Yes, the trampoline inside `andThen`/`CompletableConcatArray` has this property which prevents reentrance/large stacks on the same thread.\r\n\r\nThis is the effect of operators which are also potential asynchronous boundaries but do not enforce a scheduler by themselves.\r\n\r\nTo solve your case, use `subscribeOn` to make sure the subscription side-effect of `fromAction` happens on the desired thread."
      },
      {
        "user": "pjastrz",
        "created_at": "2019-01-02T17:17:18Z",
        "body": "I think I understand why `CompletableConcatArray` is done that way, since it can have multiple sources etc., but from Completable.andThen(...) perspective it's inconsistent with andThen(SingleSource), andThen(MaybeSource) because those will work properly on observeOn scheduler. Maybe it's worth to not rely on concat() inside andThen(CompletableSource) and implement something similar to `SingleDelayWithCompletable/MaybeDelayWithCompletable` which are used for other `Completable.andThen` methods?"
      },
      {
        "user": "akarnokd",
        "created_at": "2019-01-02T17:57:29Z",
        "body": "> it's inconsistent with andThen(SingleSource), andThen(MaybeSource)\r\n\r\nConsistency is important so PR welcome."
      }
    ]
  },
  {
    "number": 6352,
    "title": "Prettify the error message of TestObserver",
    "created_at": "2018-12-31T15:07:28Z",
    "closed_at": "2018-12-31T16:04:00Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6352",
    "body": "Version: 2.2.5\r\n\r\nIt may be better if the **Expected** message and **Actual** one are printed on its **OWN** line instead of contacting them. It's a hard time to find out what the difference is.\r\n\r\n```java\r\njava.lang.AssertionError: Values at position 0 differ; Expected: MobileNumberState(isErrorMsgVisible=false, isNextButtonVisible=false, isNextButtonEnabled=false, selectedCountry=Country(name=China, code=86), mobileNumber=, navigation=null) (class: MobileNumberState), Actual: MobileNumberState(isErrorMsgVisible=false, isNextButtonVisible=false, isNextButtonEnabled=false, selectedCountry=Country(name=HK, code=852), mobileNumber=, navigation=null) (class: MobileNumberState) (latch = 1, values = 1, errors = 0, completions = 0)\r\n```\r\n\r\nWhat I expect is\r\n```java\r\njava.lang.AssertionError: Values at position 0 differ;\r\nExpected: MobileNumberState(isErrorMsgVisible=false....\r\nActual:   MobileNumberState(isErrorMsgVisible=false....\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6352/comments",
    "author": "jaychang0917",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-12-31T15:21:23Z",
        "body": "I don't know how IntelliJ Idea handles multiline exceptions with its diff viewer. If you are not on IntelliJ, I recommend using Notepad++ or alike to disect such long messages. Or you could always have your own test comparisons that print your objects formatted."
      },
      {
        "user": "jaychang0917",
        "created_at": "2018-12-31T15:32:16Z",
        "body": "I'm using IntelliJ, the above error message is shown on the console when my test case failed. It seems doesn't relate to diff viewer."
      },
      {
        "user": "jaychang0917",
        "created_at": "2018-12-31T15:40:40Z",
        "body": "The source code of `BaseTestConsumer.assertValues()`:\r\n\r\n```java\r\n//...\r\nthrow fail(\"Values at position \" + i + \" differ; Expected: \" + valueAndClass(u) + \", Actual: \" + valueAndClass(v));\r\n```\r\n\r\nChanging the format of that string with newline operator will solve the long message issue, doesn't it? Am I missing something?"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-12-31T15:45:04Z",
        "body": "See #6262. Also you could include a newline in your `toString` representation."
      }
    ]
  },
  {
    "number": 6340,
    "title": "one observable subscribe multiple Observer ",
    "created_at": "2018-12-14T08:42:53Z",
    "closed_at": "2018-12-14T08:53:02Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6340",
    "body": "I am using 2.2.4.\r\nI want to konw how one observable subscribe multiple Observer. \r\nBeause when I get data back,I have multiple observers response to it.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6340/comments",
    "author": "CreazyBlade",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-12-14T08:53:02Z",
        "body": "Please read about `Subject`s and ask such questions on StackOverflow next time."
      }
    ]
  },
  {
    "number": 6339,
    "title": "Delayed events do not keep order doOnNext and doOnComplete (groupBy with publish) ",
    "created_at": "2018-12-14T07:40:12Z",
    "closed_at": "2018-12-14T08:36:34Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6339",
    "body": "Hi,\r\nI'm a bit confused about how doOnComplete works in example below. \r\nrxjava version: 2.2.4\r\n\r\n```java\r\nFlowable<String> emitter = Flowable.just(\"aa\", \"ba\", \"ab\", \"bb\", \"ac\")\r\n                .doOnComplete(() -> logger.info(\"End emit\"));\r\n\r\n        Flowable<GroupedFlowable<Character, String>> groupBy = emitter.groupBy(s -> s.charAt(0));\r\n\r\n        groupBy.flatMap(characterStringGroupedFlowable -> stats(characterStringGroupedFlowable)\r\n                .publish(stringFlowable -> stringFlowable.concatMap(s -> \r\n                     Flowable.just(s).delay(100, TimeUnit.MILLISECONDS))))\r\n                .subscribeOn(Schedulers.from(Executors.newFixedThreadPool(1)))\r\n                .test()\r\n                .await();\r\n```\r\n```java\r\nprivate Flowable<String> stats(GroupedFlowable<Character, String> groupedFlowable) {\r\n        return groupedFlowable.compose(upstream -> {\r\n            AtomicLong count = new AtomicLong(0);\r\n            return upstream\r\n                    .doOnNext(s -> {\r\n                        count.incrementAndGet();\r\n                        logger.info(\"Group: {} - stats - [{}] - count: {}\", \r\n                        groupedFlowable.getKey(), s, count.get());\r\n                    })\r\n                    .doOnComplete(() -> {\r\n                        logger.info(\"Group: {} - stats - complete - count: {}\", \r\n                        groupedFlowable.getKey(), count.get());\r\n                    });\r\n\r\n        });\r\n    }\r\n```\r\nOutput:\r\n```\r\n08:13:39.349 | INFO  | pool-1-thread-1 | Group: a - stats - [aa] - count: 1\r\n08:13:39.355 | INFO  | pool-1-thread-1 | Group: b - stats - [ba] - count: 1\r\n08:13:39.356 | INFO  | pool-1-thread-1 | Group: a - stats - [ab] - count: 2\r\n08:13:39.356 | INFO  | pool-1-thread-1 | Group: b - stats - [bb] - count: 2\r\n08:13:39.356 | INFO  | pool-1-thread-1 | End emit\r\n08:13:39.356 | INFO  | pool-1-thread-1 | Group: a - stats - complete - count: 2\r\n08:13:39.356 | INFO  | pool-1-thread-1 | Group: b - stats - complete - count: 2\r\n08:13:39.459 | INFO  | RxComputationThreadPool-1 | Group: a - stats - [ac] - count: 3\r\n```\r\nI expected that this line `Group: a - stats - [ac] - count: 3` will be before that line `Group: a - stats - complete - count: 2`. I think it is a bug, of course I can be wrong. Removing `publish` operator solving a problem but in real world I need it to my business logic.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6339/comments",
    "author": "lukaszguz",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-12-14T08:36:34Z",
        "body": "Sometimes due to backpressure, `publish` may emit on the requestor thread, in this case the thread `delay` uses. To ensure proper ordering, use `observeOn` and then log."
      },
      {
        "user": "lukaszguz",
        "created_at": "2018-12-14T11:51:16Z",
        "body": "You mean something like that?\r\n```\r\nScheduler scheduler = Schedulers.from(Executors.newFixedThreadPool(1));\r\ngroupBy.flatMap(characterStringGroupedFlowable -> stats(characterStringGroupedFlowable)\r\n                        .publish(stringFlowable -> stringFlowable.observeOn(scheduler).concatMap(s -> Flowable.just(s).delay(100, TimeUnit.MILLISECONDS))))\r\n                        .subscribeOn(scheduler)\r\n                        .test()\r\n                        .await();\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-12-14T12:03:03Z",
        "body": "Try `characterStringGroupedFlowable.observeOn(scheduler)`."
      },
      {
        "user": "lukaszguz",
        "created_at": "2018-12-14T14:28:46Z",
        "body": "```\r\ngroupBy.flatMap(characterStringGroupedFlowable -> stats(characterStringGroupedFlowable)\r\n                .observeOn(scheduler)\r\n                .publish(stringFlowable -> stringFlowable.concatMap(s -> Flowable.just(s).delay(100, TimeUnit.MILLISECONDS))))\r\n                .subscribeOn(scheduler)\r\n                .test()\r\n                .await();\r\n```\r\nAwesome. Thanks for hints! :)"
      }
    ]
  },
  {
    "number": 6319,
    "title": "What's the purpose of having to, as, and compose?",
    "created_at": "2018-11-20T23:32:56Z",
    "closed_at": "2018-11-21T00:06:49Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6319",
    "body": "From what I understand, `to` and `as` are exactly the same thing, minus the functional interface of course. `compose` is not the same, but where `compose` can be used, `to` or `as` can also be used (not the other way around).\r\n\r\nSo what's the reason behind these 3 methods? Is there any benefit of having all 3 of them instead of just 1?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6319/comments",
    "author": "slisaasquatch",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-11-21T00:06:49Z",
        "body": "See #5729."
      }
    ]
  },
  {
    "number": 6315,
    "title": "IO Thread Purge policy",
    "created_at": "2018-11-19T20:55:25Z",
    "closed_at": "2018-12-03T11:25:28Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6315",
    "body": "Hi,\r\n\r\nwe use RX 1.2.7 and we are trying to debug an issue where we see an abnormally high count of idle RxIoScheduler threads (up to 16k) in some boxes even though traffic type and load to all the boxes are evenly distributed. The variance in those boxes can range from hundreds to the abovementioned 16k.\r\n\r\nIs this a normal thing to observe for the CachedThreadScheduler in 1.2.7? We don't use 2.x but is this also a common thing for IOScheduler in 2.x?\r\n\r\nWe have tried different things to troubleshoot the root cause.\r\n\r\n1) Shortening the keep alive time of the ThreadWorkers in CachedThreadScheduler gives us mixed results and we are concerned that too aggressively evicting ThreadWorkers could be counterproductive since starting new ThreadWorkers should be more expensive than reusing existing ones in as much as possible, right? We don't want to solve a performance problem by creating another one. More importantly, since production traffic varies, there's a big question mark on what the optimal keep alive time should be and how could we could be forced to keep adjusting the keep alive time frequently. We had hoped that the IO scheduler thread pool should elastically grow and shrink automatically by itself.\r\n\r\n2) Another thought is to upgrade to 2.x where we noticed that the purge thread is turned on by default. \r\nWhat is the correct way to purge idle IO scheduler threads in 1.2.7 or 1.x? We are wondering if perhaps some code in our application caused the ThreadWorker lifecycle to not terminate correctly and thus hold on too longer than was necessary but we are not sure what. One potential suspect is the onCompleted call. We noticed that different types of clean up happens in onCompleted in 1.x and onComplete in 2.x.  However, we also noticed that the IO scheduler threads are not ended if onCompleted is not called on the Observer in 1.2.7, but they are ended regardless in 2.x even if onComplete is not called, why is this so? Would it be a safe thing to end a ThreadWorker if onComplete was not called on the Observer.\r\n\r\nIn a nutshell, what is the right way to keep the number of idle RxIoScheduler threads low in 1.x?\r\n\r\nThanks in advance for any pointers that you can share to help us.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6315/comments",
    "author": "pp112018",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-11-19T23:05:56Z",
        "body": "> Is this a normal thing to observe for the CachedThreadScheduler in 1.2.7\r\n\r\nNo. You have a scheduler leak somewhere. This could be custom operators, manual `Scheduler.createWorker` usages or never ending sources running on those schedulers.\r\n\r\nWhat are you using the IO threads for?\r\n\r\n> purge thread is turned on by default\r\n\r\nThe purge thread removes timed but cancelled tasks which Java doesn't do by default. It has nothing to do with recycling IO scheduler threads.\r\n\r\n> Thanks in advance for any pointers that you can share to help us.\r\n\r\n- Use `Schedulers.from` with a dedicated `ThreadPoolExecutor` where you control the maximum number of threads.\r\n- You are running a pretty old version, the latest of 1.x is 1.3.8.\r\n- 1.x is no longer supported and 2.x fixed many internal inconsistencies that could have lead to leaks."
      },
      {
        "user": "pp112018",
        "created_at": "2018-11-20T02:23:57Z",
        "body": "We use the IO threads mainly for making asynchronous service calls between services. Many times, these calls are also wrapped in Hystrix, and we provide this as a platform to hundreds of services in production. We found that many of these services are affected, but each extent varies, the severe case in thousands up to 15k. Inspection of the thread dumps show that the idle IO threads were long-lived but did very, very little CPU work.\r\n\r\nCan you help us understand the move from setting the removal on cancel policy in 1.x to a dedicated purge thread in 2.x? What is behind the decision to using a dedicated thread in 2.x? \r\n\r\nI also apologize for not making clear our example. So we also surmised that there was some kind of leakage somewhere and one of the testings that we did was to observe what happens if the onCompleted call was not made in 1.x versus the onComplete call not being made in 2.x because we suspected (rightly or wrongly) that this was missing in some of the application code. Our test code is very simple, we use the Observable create factory method to create an Observable and then two Observers that subscribe to that Observable using the io scheduler. We deliberately leave out onCompleted/onComplete when creating the observable and we let the main thread idle for a few minutes to give the evictor thread more than one chance to run after the IO threads complete their work. What we saw was the IO threads forcibly being removed in 2.x but not in 1.x, that was what we meant by the \"purging\" in 2.x, that the behavior has changed"
      },
      {
        "user": "pp112018",
        "created_at": "2018-11-20T05:13:15Z",
        "body": "Please ignore the last paragraph in the last comment, on diving deep into the code, we see what has happened in that test case, onCompleted was required by the SafeSubscriber in 1.x to unsubscribe which will eventually release the thread back to the queue, since this was missing in the flow created by the test code, those IO threads never get released and evicted; in 2.x, the parent Scheduler parent class wraps the work to be done within a DisposeTask that guarantees that the IO thread gets released back to the queue for eviction. The subscription list approach seems quite complex and the DisposeTask very elegant.\r\n\r\nSo, closing comments from you David, for the sake of repeating for our benefit, given how complex this one example is, there's no telling what foibles exist in our application code, the upgrade to 2.x would be best thing to do for us, correct?\r\n\r\nAlso, please don't forget to enlighten us on the design decision to use a dedicated purge thread instead of remove on cancel policy?"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-11-20T09:04:15Z",
        "body": "In general, without seeing your code, it could be both a programming error on your part or a corner case/quirk of RxJava 1.\r\n\r\n> Can you help us understand the move from setting the removal on cancel policy in 1.x to a dedicated purge thread in 2.x? What is behind the decision to using a dedicated thread in 2.x?\r\n\r\nIt needed reflection as it was a Java 7+ feature. Certain phones mess up reflection for one. The secondary reason is that `purge` is overall more efficient and is available to Java 6+.\r\n\r\nYou can wrap an `ExecutorService` via `Schedulers.from` that has this policy enabled if you really need it.\r\n\r\n> 2.x would be best thing to do for us, correct?\r\n\r\n1.x is end of life so there won't be any support, changes, fixes etc. to it. 2.x has architectural, performance and API benefits over 1.x. I recommend upgrading to 2.x; most other libraries have upgraded as well by now so it shouldn't be much of a problem."
      },
      {
        "user": "pp112018",
        "created_at": "2018-11-20T14:29:00Z",
        "body": "We would love to share the code with you if we have even the possibility of narrowing it down to a few suspects, the problem that we face is we use RX so widely in our ecosystem and idle thread behavior is so pervasive that it is hard to pinpoint exactly what might be responsible. Some high traffic services suffer the problem more severely than others so the one thing that we are certain of is that it is load induced. Also, since we use RX at all levels and given how common the problem is, what we can reasonably surmise is that it must be some library code. However, it is hard to ascertain if it is a quirk of RX 1.2.7 at high load, or whether a bug exists in how we use 1.2.7 in either our platform or application code as you say. The only thing that is certain from looking at the 1.2.7 code is for some reason, those large number of idle threads were not released back to the queue, because for if they were, the evictor should have multiple chances to reclaim them given how long-lived the threads were.\r\n\r\nThis was what prompted us to create the abovementioned test case for we saw that the only way a ThreadWorker would be released back to the queue is if onCompleted was called on the subscriber at which unsubscription would happen; or if onError happened.\r\n\r\nJust one minor question that I have, it seems like several layers of subscriptions can be created through the SubscriptionList and CompositeSubscription model even for our simple test case, and the code has to work through a bit of unwinding to do before it is able to get to the subscription to effectively release the worker back to the queue. We also noticed that the work to unsubscribe is submitted as a different task to the same executor that handles the work request for the thread worker unlike the DisposeTask which wraps the work request and dispose task within the same runnable. In the face of high load and multiple context switching, does the possibility of race conditions exist for 1.2.7? We have searched quite thoroughly for why onCompleted would not be called in our code and in the absence of any concrete findings, we are wondering if race conditions under high load might somewhat be responsible."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-11-20T16:22:07Z",
        "body": "> We also noticed that the work to unsubscribe is submitted to the same executor that handles the work request for the thread worker.\r\n\r\nThis may lead to a same-pool deadlock if the scheduler is blocked on non-interruptible code, unsubscription may never run.\r\n\r\n> In the face of high load and multiple context switching, does the possibility of race conditions exist?\r\n\r\nNo.\r\n\r\nYou could have a wrapper `Scheduler` that tracks the calls to `createWorker` and `Worker.unsubscribe` before delegating, so you could log what created those workers."
      },
      {
        "user": "pp112018",
        "created_at": "2018-11-20T16:26:23Z",
        "body": "> > We also noticed that the work to unsubscribe is submitted to the same executor that handles the work request for the thread worker.\r\n> \r\n> This may lead to a same-pool deadlock if the scheduler is blocked on non-interruptible code, unsubscription may never run.\r\n> \r\n> > In the face of high load and multiple context switching, does the possibility of race conditions exist?\r\n> \r\n> No.\r\n\r\nWhat makes you certain about that? We are trying to figure out why the problem is exacerbated in the face of high load\r\n> \r\n> You could have a wrapper `Scheduler` that tracks the calls to `createWorker` and `Worker.unsubscribe` before delegating, so you could log what created those workers.\r\n\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-11-20T17:19:04Z",
        "body": "> What makes you certain about that?\r\n\r\nRace condition inside the schedulers manifested themselves pretty soon during development of RxJava. If the JVM is not broken, there is no way to have a race condition within the schedulers.\r\n\r\n> We are trying to figure out why the problem is exacerbated in the face of high load\r\n\r\nYou could do a thread dump to see what's going on. If threads are waiting in the `LockSupport.park` pretty close to a `ScheduledThreadPoolExecutor`, you don't end the sequences properly. If they are blocked somewhere in user code or external API call, you have likely non-interruptible task.\r\n\r\nYou can switch to an `ExecutorService` with a maximum number of threads and use `Schedulers.from`, but note that this will eventually hang if all threads get blocked an never unblock.\r\n\r\n"
      },
      {
        "user": "pp112018",
        "created_at": "2018-11-20T17:28:31Z",
        "body": "> > What makes you certain about that?\r\n> \r\n> Race condition inside the schedulers manifested themselves pretty soon during development of RxJava. If the JVM is not broken, there is no way to have a race condition within the schedulers.\r\n> \r\n> > We are trying to figure out why the problem is exacerbated in the face of high load\r\n> \r\n> You could do a thread dump to see what's going on. If threads are waiting in the `LockSupport.park` pretty close to a `ScheduledThreadPoolExecutor`, you don't end the sequences properly. If they are blocked somewhere in user code or external API call, you have likely non-interruptible task.\r\n> \r\n> You can switch to an `ExecutorService` with a maximum number of threads and use `Schedulers.from`, but note that this will eventually hang if all threads get blocked an never unblock.\r\n\r\nWe did that, they are all waiting in LockSupport.park which made us contrive the test case that did not call onCompleted in 1.2.7. We were also able to replicate this in 1.3.8 but the problem disappears when we update the test to use 2.2.3. \r\n\r\nMany thanks for your time, I think that in the face of so many uncertain probable root causes in 1.x against the guarantees that we saw with the DisposeTask in 2.2.3, we really have no option but to upgrade.\r\n\r\nPlease feel free to close this issue. Once again, many thanks!"
      }
    ]
  },
  {
    "number": 6306,
    "title": "SwitchMap guaranteeing atleast 1 emission",
    "created_at": "2018-11-14T03:39:01Z",
    "closed_at": "2018-12-14T06:33:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6306",
    "body": "Hi, I have trouble figuring this one out, I even check the extensions library. \r\n\r\nMy usecase is I have upstream of states which I switchMap into contacts observable. Turns out I need my downstream to always see all states (after the switchmapped observable), i.e. all of upstream, where they might get omitted via switchMap.\r\n\r\nconcatMap doesnt seem to work, because the contactsObservable never completes.\r\n\r\n```\r\nval statesObservable = Observable.just(A, B, C, D)\r\nstatesObservable\r\n   .switchMap { state -> contactsObservable\r\n                                        .map { contact -> pairOf(state, contact}\r\n   }\r\n   .subsrcibe { \r\n     // Needs to see every state emitted, for example (A, Contact1), (A, Contact2), B(Contact1), C(Contact1), D(Contact2)\r\n   }\r\n```\r\n\r\nIs there a way I can guarantee alteast 1 emission of mapped observable with switchMap? I.e. queue upstream states until atleast 1 contact emit per state.\r\n\r\nOr, contactMap takeUntil new upstream value?\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6306/comments",
    "author": "ursusursus",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-11-14T08:10:27Z",
        "body": "You can't do that with `switchMap`. Your best bet is to rethink your flow or write a custom operator."
      }
    ]
  },
  {
    "number": 6292,
    "title": "How to not resubscribe switchMap unnecessarily?",
    "created_at": "2018-11-08T02:54:09Z",
    "closed_at": "2018-11-14T03:30:04Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6292",
    "body": "Hi, I am having trouble figuring this one out.\r\n\r\nI have a stream of call states, where each call state carries username on it. Username is then queried for Contact object in the database. So basically what I have is a transformation of CallState(username) -> DifferentCallState(contact).\r\n\r\nDatabase queries are observables as they can change. So far I have this, pretty straight forward\r\n\r\n ```kotlin\r\nsipCallManager.callStateObservable\r\n                   .switchMap { callState ->\r\n                       contactRepository.contactByUsernameObservable(callState.username)\r\n                            .map { contact ->\r\n                                DifferentCallState(contact)\r\n                            }\r\n                   }\r\n```\r\n\r\nHowever, most of the time username will by the same, and therefore contactByUsernameObservable being resubscribed for no reason.\r\n\r\nHow could I optimize this away? I was thinking of mapping the callState to username, distinctUntilChanged to only get changes and then switchmap to contact query, but how can I join this, i.e. preserve the upstream call state, so I still can map FooCallState to FooDifferentCallState?\r\n\r\nMaybe somehow with publish that takes observable?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6292/comments",
    "author": "ursusursus",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-11-08T08:55:10Z",
        "body": "What if the contact changed for the username? Generally you could introduce a cache (with time-to-live properties) and query/update that:\r\n\r\n```java\r\nConcurrentMap<String, List<Contact>> cache = ...\r\n\r\ncallStateObservable\r\n.switchMap( callState -> {\r\n    List<Contact> contacts = cache.get(callState.username);\r\n    Observable<Contact> contactObservable;\r\n    if (contacts == null) {\r\n        contactObservable = contactRepository.contactByUsernameObservable(callState.username)\r\n            .toList()\r\n            .doOnSuccess(list -> cache.put(callState.username, list));\r\n            .flattenAsObservable(list -> list);\r\n    } else {\r\n        contactObservable = Obervable.fromIterable(contacts);\r\n    }\r\n    return contactObservable.map(contact -> new DifferentCallState(contact));\r\n});\r\n```"
      },
      {
        "user": "ursusursus",
        "created_at": "2018-11-08T14:12:52Z",
        "body": "Hmm its not quite right, Id basically like to cache the contacts observable not the contact objects, since contact observable can emit n times while subscribed, not just once, so fromIterable wont do"
      },
      {
        "user": "ursusursus",
        "created_at": "2018-11-08T14:16:49Z",
        "body": "If I were to cache the contacts observable in a variable outside of the stream, i.e. creating it eagerly, then just return this reference inside a switchMap, to avoid retriggering Id need to make it completly hot + replay 1 (no refCount) and then disconnecting it manually in some onDestroy right? (or ofc when username changes, then creating a new one)"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-11-08T14:20:10Z",
        "body": "If you have a hot `contactByUsernameObservable`, how should a state change trigger a different call state it the `contactByUsernameObservable` does not change after it produced items the previous time?"
      },
      {
        "user": "ursusursus",
        "created_at": "2018-11-08T14:30:55Z",
        "body": "I was thinking replay(1)\r\n\r\n```\r\nvar cachedContactsObservable\r\n\r\n//\r\n\r\n.switchMap { callState -> \r\n    if callState.username same as before\r\n        cachedContactsObservable\r\n    else \r\n        cachedContactsObservable?.disconnect()\r\n        cachedContactsObservable = coldContactsObservable.replay(1)\r\n}\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-11-09T21:26:37Z",
        "body": "I can't tell, could work for your specific case."
      }
    ]
  },
  {
    "number": 6285,
    "title": "CheckReturnValue at subscribe",
    "created_at": "2018-11-05T03:06:21Z",
    "closed_at": "2018-11-05T08:49:21Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6285",
    "body": "rxjava version : `2.2.0`\r\n\r\nThe `subscribe` functions of the `Observable` class have `@CheckReturnValue`.\r\nMaybe that's why I should not miss `Disposable` and dispose it at the right time.\r\nHowever, there is no `@CheckReturnValue` for the `subscribe` function without arguments.\r\nI wonder if this is what was intended.\r\nIf rxjava is not intended to do this, could I make a PR?\r\n\r\n```java\r\n//Observable.java\r\n...\r\n     // there is no @CheckReturnValue. only here!\r\n    @SchedulerSupport(\"none\")\r\n    public final Disposable subscribe() {\r\n        return this.subscribe(Functions.emptyConsumer(), Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, Functions.emptyConsumer());\r\n    }\r\n\r\n    @CheckReturnValue\r\n    @SchedulerSupport(\"none\")\r\n    public final Disposable subscribe(Consumer<? super T> onNext) {\r\n        return this.subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, Functions.emptyConsumer());\r\n    }\r\n\r\n    @CheckReturnValue\r\n    @SchedulerSupport(\"none\")\r\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {\r\n        return this.subscribe(onNext, onError, Functions.EMPTY_ACTION, Functions.emptyConsumer());\r\n    }\r\n\r\n    @CheckReturnValue\r\n    @SchedulerSupport(\"none\")\r\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) {\r\n        return this.subscribe(onNext, onError, onComplete, Functions.emptyConsumer());\r\n    }\r\n\r\n    @CheckReturnValue\r\n    @SchedulerSupport(\"none\")\r\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, Consumer<? super Disposable> onSubscribe) {\r\n        ObjectHelper.requireNonNull(onNext, \"onNext is null\");\r\n        ObjectHelper.requireNonNull(onError, \"onError is null\");\r\n        ObjectHelper.requireNonNull(onComplete, \"onComplete is null\");\r\n        ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\");\r\n        LambdaObserver<T> ls = new LambdaObserver(onNext, onError, onComplete, onSubscribe);\r\n        this.subscribe((Observer)ls);\r\n        return ls;\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6285/comments",
    "author": "JSpiner",
    "comments": [
      {
        "user": "vanniktech",
        "created_at": "2018-11-05T08:23:03Z",
        "body": "It was a deliberate decision. Can't seem to think of the reason though. I think it was decided against since you don't care about anything when you're using that method hence it wasn't added. "
      },
      {
        "user": "akarnokd",
        "created_at": "2018-11-05T08:49:21Z",
        "body": "This was discussed a long ago in  #4878. We didn't add it as this subscribe overload is the \"I don't care\" anyway."
      }
    ]
  },
  {
    "number": 6265,
    "title": "2.x: subscribeOn does not work when Emitter's onNext called on another thread.",
    "created_at": "2018-10-28T18:34:28Z",
    "closed_at": "2018-10-28T19:40:55Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6265",
    "body": "Let's assume we have following code structure\r\n```\r\nimport kotlin.concurrent.thread\r\n\r\nval dataLayer = Single.create<Unit>{ emitter ->\r\n    thread(name = \"John\") {\r\n        emitter.onSuccess(Unit)\r\n    }\r\n}\r\n\r\nval domainLayer = dataLayer\r\n    .flatMap {\r\n        someHeavyOperation(it)\r\n    }\r\n\r\nval presentationLayer = domainLayer\r\n    .subscribeOn(Schedulers.io())\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .subscribe()\r\n```\r\nAnd the problem is that `someHeavyOperation` is called on the thread called _\"John\"_ instead of a thread provided by IO scheduler. \r\n**I expect calling `subscribeOn` would switch back to given thread type even if `SingleOnSubscribe` changes thread underneath.**\r\nIf that works as designed is there a possibility to wrap code that is called on other thread that does not affect the rest of created stream? I tried a solution similar to:\r\n\r\n```\r\nSingle.create<Unit>{ emitter ->\r\n    val countDownLatch = CountDownLatch(1)\r\n    var result : Unit? = null\r\n    thread(name = \"John\") {\r\n        result = Unit\r\n        countDownLatch.countDown()\r\n    }\r\n    countDownLatch.await()\r\n    emitter.onSuccess(Unit)\r\n}\r\n``` \r\nbut it gets complicated when using `emitter.setCancellable{ }` and I wasn't able to think of similar solution for `Observable` type.\r\n\r\nI've seen comments in #941, but I can't to write any thread managing code outside `presentation` layer",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6265/comments",
    "author": "mateuszkwiecinski",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-10-28T19:40:55Z",
        "body": "Please, next time ask such questions on StackOverflow.\r\n\r\n`subscribeOn` is for moving the subscription side effect to some other thread. Your subscription side-effect in `create` is to start another thread which will then drive the downstream, thus `someHeavyOperation`. `observeOn` should be used to move the success value back to a desired thread, which then will trigger `flatMap`:\r\n\r\n```kotlin\r\nimport kotlin.concurrent.thread\r\n\r\nval dataLayer = Single.create<Unit>{ emitter ->\r\n    thread(name = \"John\") {\r\n        emitter.onSuccess(Unit)\r\n    }\r\n}\r\n\r\nval domainLayer = dataLayer\r\n    .observeOn(Schedulers.io())\r\n    .flatMap {\r\n        someHeavyOperation(it)\r\n    }\r\n\r\nval presentationLayer = domainLayer\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .subscribe()\r\n```"
      }
    ]
  },
  {
    "number": 6261,
    "title": "Proposal: Make NonBlockingThread public",
    "created_at": "2018-10-25T22:35:52Z",
    "closed_at": "2018-10-26T06:59:04Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6261",
    "body": "The `NonBlockingThread` plugin control is pretty cool, but becomes unusable when using a custom `ThreadFactory` since it's internal. Would you be open to making this interface public so that custom provided threads could indicate that they should not be blocking as well?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6261/comments",
    "author": "ZacSweers",
    "comments": [
      {
        "user": "ZacSweers",
        "created_at": "2018-10-26T05:32:35Z",
        "body": "Alternatively - a plugin hook like `onBlockingOperator` such that we can basically perform our own check. That would allow for failing on threads we maybe don't control, such as the main thread on Android"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-10-26T06:35:36Z",
        "body": "There is the RxJavaPlugins.setOnBeforeBlocking hook for the case where existing threading can be checked."
      },
      {
        "user": "ZacSweers",
        "created_at": "2018-10-26T06:59:03Z",
        "body": "Ah! I misread the logic here\r\n\r\n```java\r\nThread.currentThread() instanceof NonBlockingThread\r\n                        || RxJavaPlugins.onBeforeBlocking()\r\n```\r\n\r\nand thought it was `&&` 🙄 . That covers it then!"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-10-26T07:31:18Z",
        "body": "I thought about such scenarios back then because of Android main thread which you don't control type-vise."
      },
      {
        "user": "ZacSweers",
        "created_at": "2018-10-26T07:45:42Z",
        "body": "yep it makes a lot of sense to have. Thanks again"
      }
    ]
  },
  {
    "number": 6256,
    "title": "2.1.6 PublishProcessor.debounce() is interrupting previous operation.",
    "created_at": "2018-10-19T13:59:02Z",
    "closed_at": "2018-11-05T12:51:30Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6256",
    "body": "RxJava 2.1.6 in Android.\r\n\r\nI have processor which offers a search text which is followed by debounce in order not to do search request each time a character of search phrase changes. I realized it doesn't work, when I type characters faster than BETWEEN_SEARCHES_INTERVAL = 300 millis. What is happening is that OkHttp throws interrupted exception from inside of searchRepository.searchInNetwork() method.\r\n\r\n```\r\ntRestFSOperation: java.io.InterruptedIOException: thread interrupted\r\ntRestFSOperation:     at okio.Timeout.throwIfReached(Timeout.java:145)\r\ntRestFSOperation:     at okio.Okio$2.read(Okio.java:137)\r\n```\r\n\r\nI guess that debounce is interrupting the thread on which previous emission is running. I think it's unintended behaviour. At least it's not documented.\r\n\r\n```\r\n    fun subscribeToSearch() {\r\n        if (disposables.size() == 0) {\r\n            disposables.add(\r\n                searchPublishProcessor\r\n                    .debounce(BETWEEN_SEARCHES_INTERVAL, TimeUnit.MILLISECONDS, Schedulers.io())\r\n                    // .throttleLast(BETWEEN_SEARCHES_INTERVAL, TimeUnit.MILLISECONDS, Schedulers.io())\r\n                    .distinctUntilChanged()\r\n                    .filter { it.searchPhrase.isNotBlank() }\r\n                    .flatMap {\r\n                        searchForPhraseInFolder(it)\r\n                    }\r\n                    .subscribeOn(Schedulers.io())\r\n                    .onErrorReturn { e: Throwable ->\r\n                        Timber.w(e, \"Error in search request\")\r\n                        SearchState.Builder(searchState)\r\n                            .setState(LoadingState.ERROR)\r\n                            .setException(Unique(e))\r\n                            .build()\r\n\r\n                    }\r\n                    .observeOn(AndroidSchedulers.mainThread())\r\n                    .subscribe({ newSearchState: SearchState? -> publishState(newSearchState!!) },\r\n                        { e: Throwable? ->\r\n                            Timber.e(e, \"Error while search\")\r\n                            CrashInfo.submitHandledCrash(e, \"SearchViewModel.search() broken\")\r\n                        }))\r\n        }\r\n    }\r\n\r\n    private fun searchForPhraseInFolder(it: SearchQuery): Flowable<SearchState>? {\r\n        return Flowable.fromCallable { searchRepository.searchInNetwork(it.searchPhrase, it.folderResourceId) }\r\n            .map { resources: List<Resource> ->\r\n                SearchState.Builder(searchState)\r\n                    .setResources(resources)\r\n                    .setState(if (resources.isEmpty()) LoadingState.EMPTY else LoadingState.DONE)\r\n                    .build()\r\n            }\r\n            .startWith(\r\n                SearchState.Builder(searchState)\r\n                    .setState(LoadingState.LOADING)\r\n                    .build()\r\n            )\r\n            .subscribeOn(Schedulers.io())\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6256/comments",
    "author": "Malachiasz",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-10-19T15:51:21Z",
        "body": "This can happen if the processing of the item after debounce takes too long. You should move the computation to another thread from the debouncer thread to avoid this, for example, by moving the `subscribeOn` next to the api call:\r\n\r\n```kotlin\r\n.flatMap {\r\n    searchForPhraseInFolder(it)\r\n       .subscribeOn(Schedulers.io())\r\n}\r\n// .subscribeOn(Schedulers.io())\r\n```"
      },
      {
        "user": "Malachiasz",
        "created_at": "2018-10-21T09:48:26Z",
        "body": "Thank you for explanation. What about writing it in java docs of the debounce() method?"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-10-21T10:22:11Z",
        "body": "PR welcome."
      }
    ]
  },
  {
    "number": 6248,
    "title": "Why does delay() with function require ObservableSource, not SingleSource.",
    "created_at": "2018-10-16T19:29:50Z",
    "closed_at": "2018-10-17T07:30:11Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6248",
    "body": "I'm Using this `delay()` operator:\r\n\r\n```\r\npublic final <U> Observable<T> delay(final Function<? super T, ? extends ObservableSource<U>> itemDelay) {\r\n```\r\n\r\nWhy does this function return an `ObservableSource` instead of a `SingleSource`?\r\n\r\nIf I understand correctly these two streams are the same (i.e. emitting two items in `itemDelay` does the same thing as emitting one item):\r\n\r\n\r\n    Observable.just(\"a\", \"b\", \"c\")\r\n            .delay(string -> {\r\n                if (shouldDelay()) {\r\n                    Thread.sleep(1000);\r\n                    return Observable.just(1);\r\n                } else {\r\n                    // don't delay, return immediately\r\n                    return Observable.just(1);\r\n                }\r\n    \r\n            });\r\n\r\n\r\n    Observable.just(\"a\", \"b\", \"c\")\r\n            .delay(string -> {\r\n                if (shouldDelay()) {\r\n                    Thread.sleep(1000);\r\n                    return Observable.just(1, 2);\r\n                } else {\r\n                    // don't delay, return immediately\r\n                    return Observable.just(1, 2);\r\n                }\r\n    \r\n            });\r\n\r\nSo why not just require a `SingleSource`? \r\n\r\n_I realize this is a general \"why did this get built this way?\" question. I don't expect the API to change._",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6248/comments",
    "author": "tir38",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-10-16T20:08:10Z",
        "body": "The signature of `delay` was established way before `Single` has been added to the library. Besides, the inner `ObservableSource` is expected to signal an item or completion in order for `delay` to signal the associated item. Consequently, you don't have to define that inner flow in a way to always produce an item."
      },
      {
        "user": "tir38",
        "created_at": "2018-10-17T00:45:13Z",
        "body": "thanks. What do you mean \"you don't have to define that inner flow in a way to always produce an item.\"?"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-10-17T07:30:11Z",
        "body": "It means you don't have to add more transformations and defaults just to have an item emitted."
      }
    ]
  },
  {
    "number": 6240,
    "title": "2.0: Operator for specifying used scheduler for all operators downstream",
    "created_at": "2018-10-08T22:57:21Z",
    "closed_at": "2018-10-09T20:47:20Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6240",
    "body": "**Question/Enhancement**\r\n\r\nWhy there is no operator that would enable specifying scheduler used by all operators downstream?\r\nWith assumption that `scheduleOn` and `observeOn` would still keep working as they were so far.\r\n \r\n**Problem/Background**\r\nRecently I learned that there isn't really a concise, reliable way to specify on which scheduler actions from operators like eg. `doOnDispose` or `doOnSubscribe` will be executed. \r\nFurthermore, position of these operators in chain influences scheduler used by them, which seems logical, but how it's determined is rather unclear - at least from perspective of API. \r\n\r\nEsentially I would like to be able to write code like:\r\n```\r\nrepository.getProducts()\r\n    ...\r\n    .subscribeOn(schedulers.io)\r\n    ...\r\n    .observeOn(schedulers.main)\r\n    ...\r\n    .doOnSubscribe {\r\n        products.value = Resource.loading(emptyList())\r\n    }.subscribe({\r\n        products.value = Resource.success(it)\r\n    }, {\r\n        products.value = Resource.error(it.message)\r\n    })\r\n```\r\nand feel safe that `doOnSubscribe` will be executed on main thread.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6240/comments",
    "author": "PawlikMichal25",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-10-09T07:46:00Z",
        "body": "> Why there is no operator that would enable specifying scheduler used by all operators downstream?\r\n\r\nBecause it is not possible. Operators can't have such reach.\r\n\r\n> which scheduler actions from operators like eg. doOnDispose\r\n\r\n`unsubscribeOn` affects where the `dispose()` call of its upstream will be called.\r\n\r\n> doOnSubscribe\r\n\r\nThere is no direct support for moving `doOnSubscribe` onto another thread but you can side-effect a different a preceding sequence.\r\n\r\n```java\r\nsource\r\n.startWith(\r\n    Completable.fromAction(() -> { /* your onSubscribe */ })\r\n    .subscribeOn(mainThread())\r\n    .toObservable()\r\n)\r\n.subscribe(/* ... */);\r\n```\r\n\r\nWith Kotlin, you can even create an extension method for the `startWith` part."
      },
      {
        "user": "PawlikMichal25",
        "created_at": "2018-10-09T20:20:35Z",
        "body": "Thanks for clarifying, just one more question then:\r\n\r\n> Because it is not possible. Operators can't have such reach.\r\n\r\nso the fact that sometimes eg. action from `doOnSubscribe` is executed on different schedulers  should be considered as a \"side effect\"?"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-10-09T20:26:03Z",
        "body": "The `doOnXXX` operators allow you to insert side effect at various points into a flow. They are not predicated on schedulers."
      },
      {
        "user": "PawlikMichal25",
        "created_at": "2018-10-09T20:47:20Z",
        "body": "Ok, thanks for responding, \r\nI will close the issue now"
      }
    ]
  },
  {
    "number": 6233,
    "title": "2.2.0 - Question - Flowable.GroupBy Memory Usage",
    "created_at": "2018-09-30T18:12:41Z",
    "closed_at": "2018-09-30T22:13:11Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6233",
    "body": "I have some questions about the groupBy operator and its memory usage.\r\n\r\n1. Does Flowable.groupBy begin to emit GroupedFlowables as the groupBy keys are encountered or are they held back until the full set of groupBy keys can be identified?  How much buffering of source emissions does Flowable.groupBy do?  Or is it more like a situation where Flowable.groupBy publishes to the GroupedFlowable for a corresponding groupBy key as it's encountered?\r\n2. If I have a very long source Flowable (millions of emissions) which emits its items in sorted order of the value I want to use as a groupBy key, should I be concerned about memory issues (OutOfMemoryError, etc.) with using Flowable.groupBy()?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6233/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-09-30T18:43:58Z",
        "body": "> Does Flowable.groupBy begin to emit GroupedFlowables as the groupBy keys are encountered\r\n\r\nYes.\r\n\r\n> How much buffering of source emissions does Flowable.groupBy\r\n\r\nNone.\r\n\r\n> Flowable.groupBy publishes to the GroupedFlowable for a corresponding groupBy key as it's encountered?\r\n\r\nYes.\r\n\r\n> If I have a very long source Flowable (millions of emissions) which emits its items in sorted order of the value I want to use as a groupBy key, should I be concerned about memory issues (OutOfMemoryError, etc.) with using Flowable.groupBy()?\r\n\r\nYes, groups live until they are individually no longer observed or when the source terminates.\r\n"
      },
      {
        "user": "ghost",
        "created_at": "2018-09-30T19:12:50Z",
        "body": "Thanks so much for the response, I really appreciate it.  I have some follow up questions if you'd be so kind, then I will close the issue.\r\n> Yes, groups live until they are individually no longer observed or when the source terminates.\r\n\r\nWhen does a GroupedFlowable signal completion?  Only when the source terminates?  In the scenario I described where the source emissions come in the order of the groupBy key, what would happen if I applied a .take(n) operator to inner GroupedFlowables specifying an upper bound?  Would the GroupedFlowables be disposed in that case and then recreated if/when the groupBy key is seen again, or are they still kept alive?\r\n\r\nThanks again"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-09-30T19:18:25Z",
        "body": "> When does a GroupedFlowable signal completion? Only when the source terminates?\r\n\r\nYes.\r\n\r\n> what would happen if I applied a .take(n) operator to inner GroupedFlowables specifying an upper bound?\r\n\r\nAssuming you have strictly ordered keys, a take would end a group, freeing the associated resources and the operator would not create another one.\r\n\r\n> Would the GroupedFlowables be disposed in that case and then recreated if/when the groupBy key is seen again\r\n\r\nYes."
      },
      {
        "user": "ghost",
        "created_at": "2018-09-30T22:13:11Z",
        "body": "Perfect, thank you."
      }
    ]
  },
  {
    "number": 6229,
    "title": "SchedulerPoolFactory.java null pointer",
    "created_at": "2018-09-29T06:09:42Z",
    "closed_at": "2018-09-29T08:23:58Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6229",
    "body": "Location: RxJava/src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java\r\nClass: SchedulerPoolFactory.java\r\nLine: 69\r\nStatement: if (PURGE_THREAD.compareAndSet(curr, next)) \r\nProblem: Above this line, it checks if curr is NOT null, and if it is not null, it returns. If it does equal null, it will continue to this line where it passes curr. This can result in a null pointer exception.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6229/comments",
    "author": "Xenios91",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-09-29T08:23:58Z",
        "body": "No. The line tries to set `PURGE_THREAD` to the `next` value atomically if the its current value is still `null`. If successful, the purge task is started and the loop quits. If unsuccessful, the helper pool just created is shut down and the loop repeats. There is no circumstance there could be a `NullPointerException` in this method."
      }
    ]
  },
  {
    "number": 6228,
    "title": "How to make chain atomic?",
    "created_at": "2018-09-29T04:27:13Z",
    "closed_at": "2018-10-18T09:20:24Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6228",
    "body": "Hi,\r\nId like advice on idiomatic way of doing this. \r\n\r\nSay I have a async senquence of operations, for example logout = request + clear user token + clear all local data.\r\n\r\nrequest()\r\n.flatmap { clearUserData() }\r\n.flatmap { clearAllData() }\r\n.subscribeOn(io)\r\n\r\nMy issue is if I model this via flatmaps, then stream is cancelable also mid way. That means disposable can be disposed of when the stream is at the \"clear user data\" observable, meaning \"clear all data\" will not get executed, which is a problem.\r\n\r\nBy atomicity I dont mean being rollback but atleast guaranteeing it will run whole, i.e. not being able to cancel.\r\n\r\nHonestly the cleanest would be to leave is synchronous via Completable.fromAction { requestSync() clearUserDataSync().\r\nclearAllDataSync() },\r\n\r\nHowever lets say those calls are part of public api so pretend they cant be changed.\r\n\r\nIs blockingGet() instead good idea? \r\n\r\nCompletable.fromAction {\r\n   request().blockingGet()\r\n   clearUserData().blockingGet()\r\n   clearAllData().blockingGet()\r\n}\r\n\r\nHow about making the flatmapped stream hot via publish().autoconnect()? That should ignore the cancels when subscriber goes away right?\r\n\r\nBtw if you like the publish approach. Is then a way to make it cold again? I.e. guaranteeing those 3 operations will finish but then fourth wont run, if stream was disposed at the time of 2nd operation forexample",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6228/comments",
    "author": "ursusursus",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-09-29T08:29:01Z",
        "body": "Is there a case where the flow should be disposed? If you always want it to go through, don't dispose the subscription to it."
      },
      {
        "user": "ursusursus",
        "created_at": "2018-09-29T14:30:43Z",
        "body": "When for example caller has a lifecycle, and needs to dispose to free to subsricber reference so it doesnt leak"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-09-29T14:36:49Z",
        "body": "I'm not sure what you want to do. Do you want the operations to always execute or do you want the sequence to be stoppable? If you want to prevent cancellation for the duration of some set of operators, that requires a custom operator (i.e., you need to intercept the dispose call and delay it until dispose is enabled again). "
      },
      {
        "user": "ursusursus",
        "created_at": "2018-09-29T14:46:31Z",
        "body": "Yes to the latter, id like for certain part of the chain to be basically unstoppable explicitly.\r\n\r\nguaranteed {\r\n   fooObservsble()\r\n      .flatmap { barObservable() }\r\n      .flatmap { quaxObservable() }\r\n}\r\n...\r\n.whatever()\r\n...\r\n.subscribe()\r\n\r\nSo part of chain in guaranteed is uncancelable once running, but downstream from it is, so subscriber doesnt leak (so yea subscriber is no longer there and guaranteed chain continues until its completion)\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-09-29T14:57:35Z",
        "body": "What would be the start and end of such non-disposable region? I.e., the first item in and the terminal signal out or would it be in a form of an API (i.e., beginNonDisposable(), endNonDisposable())? \r\n\r\nAlso even if a region is non disposable, should the upstream to that region be disposable? For example, you have a source that keeps emitting the input to the non-disposable region. You want to prevent disposing while the current item is processed but you'd still want to stop the generation of those original items."
      },
      {
        "user": "ursusursus",
        "created_at": "2018-09-29T15:08:48Z",
        "body": "Yes I like first in and terminal out. I.e. if it started running, block dispose until onComplete. So the second question is now the same I think: If it was not running at the time of disposal or already completed, dispose works as usual, upstream disposed also. \r\n\r\nNow that I think about it, its precisely like executor shutdown, refuse new stuff and let running stuff finish and only then really finish self"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-09-29T15:15:52Z",
        "body": "But that would make only a small window between subscription and the first item so that the flow could be stopped. You can do that via `takeUntil(PublishSubject)` before the non-disposable region and simply not dispose the subscription at the end. If you wanted the source to be stopped, signal an item to that `PublishSubject` that will eventually make the sequence stop."
      },
      {
        "user": "ursusursus",
        "created_at": "2018-09-29T15:22:54Z",
        "body": "right, but wouldnt that leak the subscriber? Simpler but possibly stupid example is making a request in the UI. After request you save the data to database. In this case you dont want to cancel the request when ui goes away (back press)\r\n\r\n```\r\nclass UI  {\r\n   fun click() {\r\n      disposable = fooRequestSingle()\r\n         .flatmap { databaseSaveSingle(it) }\r\n         .subscribe {\r\n            viewShowToast()\r\n         }\r\n   }\r\n\r\n   fun onDestroy() {\r\n      disposable.dispose()\r\n   }\r\n}\r\n```\r\n\r\nHere Id always want to save the data, but showing toast is not necessary when UI went away.\r\nI know the better alternative is to not make request in ui but delegate to some singletone, but for sake of argument.."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-09-29T15:27:33Z",
        "body": "You can also separate out the non-disposable part into its own sequence and communicate with it via subjects:\r\n\r\n```java\r\nSubject<T> input = PublishSubject.create();\r\nSubject<R> output = PublishSubject.create();\r\n\r\n// the non-disposable sequence of transformations\r\ninput\r\n  .flatMap(v -> operation1())\r\n  .flatMap(w -> operation2())\r\n  .subscribe(output);\r\n\r\n// prepare handling the output of the non-disposable part\r\nDisposable d1 = output\r\n  .observeOn()\r\n  .doOnNext()\r\n  .subscribe();\r\n\r\n// connect the main source of values to be processed non-disposable\r\nDisposable d2 = mainSource.subscribe(input);\r\n\r\n// stop generating and stop listening to items\r\n// the non-disposable sequence will not be affected\r\nd1.dispose();\r\nd2.dispose();\r\n```"
      },
      {
        "user": "ursusursus",
        "created_at": "2018-09-29T15:40:29Z",
        "body": "Looks good, is there any chance I could compact this into single extension function? Probably not since I need the references to subjects in order to input values. Operator possibly?\r\n\r\nBtw, isnt the \r\n// the non-disposable sequence of transformations\r\n```\r\ninput\r\n  .flatMap(v -> operation1())\r\n  .flatMap(w -> operation2())\r\n  .subscribe(output);\r\n```\r\nleaking `this` in the flatmap lambdas if its not disposed? Or is it smart enough to not have this if its not capturing lambda?"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-09-29T16:40:01Z",
        "body": "You can have a transformer:\r\n\r\n```java\r\nObservableTransformer<T, R> nonDisposableWork = upstream -> Observable.defer(() -> {\r\n\r\n  Subject<T> input = PublishSubject.create();\r\n  Subject<R> output = PublishSubject.create();\r\n\r\n  input\r\n  .flatMap(v -> operation1())\r\n  .flatMap(w -> operation2())\r\n  .subscribe(output);\r\n\r\n  Disposable d = upstream.subscribe(input);\r\n\r\n  return output.doFinally(() -> d.dispose());\r\n});\r\n\r\nsomeSource.compose(nonDisposableWork)\r\n.observeOn()\r\n.doOnNext()\r\n.subscribe();\r\n```\r\n\r\n> leaking this in the flatmap lambdas if its not disposed?\r\n\r\nAfaik, Android lambda compilers should be smart enough to not capture `this` unnecessarily. If you put the transformer into a static method and only have static methods inside the lambda, there should be no `this` captured."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-10-18T09:20:24Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 6225,
    "title": "2.x: migration from Rx1 to Rx2",
    "created_at": "2018-09-25T16:12:44Z",
    "closed_at": "2018-09-25T16:30:51Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6225",
    "body": "Hi! how to implement this using Rx 2.x ?\r\n\r\n```java\r\npublic class NotifEvent {\r\n\r\n    public static NotifEvent instance = new NotifEvent();\r\n    private final Subject<Object, Object> mSubject = new SerializedSubject<>(PublishSubject.create());\r\n\r\n    public static NotifEvent getInstance() {\r\n        return instance;\r\n    }\r\n\r\n    public <T> Subscription register(final Class<T> tClass, Action1<T> onNext, Action1<Throwable> onError) {\r\n        return mSubject\r\n                .subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .filter(o -> o.getClass().equals(tClass))\r\n                .map(o -> (T) o)\r\n                .subscribe(onNext, onError);\r\n    }\r\n\r\n    public void unregister(Subscription subscription) {\r\n        subscription.unsubscribe();\r\n        Log.d(this.getClass().getName(), \"unregister: \" + subscription.isUnsubscribed());\r\n    }\r\n\r\n    public void post(Object event) {\r\n        mSubject.onNext(event);\r\n    }\r\n    \r\n}\r\n```\r\n\r\nthanks!",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6225/comments",
    "author": "isfaaghyth",
    "comments": [
      {
        "user": "isfaaghyth",
        "created_at": "2018-09-25T16:19:08Z",
        "body": "done!\r\n\r\n```kotlin\r\nobject NotificationEvent {\r\n\r\n    private val subject: Subject<Any> = PublishSubject.create()\r\n    \r\n    fun <T> register(tClass: Class<T>, onNext: Consumer<T>, onError: Consumer<Throwable>): Disposable \r\n            = subject\r\n            .subscribeOn(Schedulers.io())\r\n            .observeOn(AndroidSchedulers.mainThread())\r\n            .filter { o -> o.javaClass == tClass }\r\n            .map { o -> o as T }\r\n            .subscribe(onNext, onError)\r\n    \r\n    fun unregister(disposable: Disposable) = disposable.dispose()\r\n    \r\n    fun post(event: Any) = subject.onNext(event)\r\n\r\n}\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-09-25T16:30:51Z",
        "body": "Looks like you got it! Except you might want to appy `toSerialized` to that `PublishSubject.create()`."
      }
    ]
  },
  {
    "number": 6214,
    "title": "RxJava 2.2.2 startsWith subscribes the subsequence streams without subscribing to the upper stream",
    "created_at": "2018-09-16T14:58:16Z",
    "closed_at": "2018-09-16T16:42:26Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6214",
    "body": "Hi, I'm not sure if this is a bug or an expected behavior. \r\nSee an example below:\r\n```\r\n        PublishSubject<Integer> subject = PublishSubject.create();\r\n        AtomicBoolean bool = new AtomicBoolean();\r\n        subject\r\n                .doOnSubscribe(s->{}) << not called\r\n                .doOnNext(s->{}) << not called\r\n                .startWith(0)\r\n                .switchMap(o -> Observable\r\n                        .empty()\r\n                        .doOnSubscribe(s -> {\r\n                            if (!bool.get()) {\r\n                                subject.onNext(1); << called\r\n                            }\r\n                        }))\r\n                .subscribe();\r\n```\r\nScenario:\r\nIn my use case, I subscribed to a source that chained with a #startWith operator.\r\nI performed a switchMap, expecting the next value terminates it and starts a new one. \r\nSubject emits something during the switchmap. Happens on both Observable/Flowable.\r\n\r\nExpected: receive the new event\r\nActual: receive nothing due to subject not subscribed yet.\r\n\r\nHave not tested on other version.\r\n\r\nThanks\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6214/comments",
    "author": "ykinuse",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-09-16T16:03:59Z",
        "body": "This is a valid behavior. The `PublishSubject` is not subscribed at that time because `startWith` hasn't finished yet switching to it. Consider using `BehaviorSubject.create(0)` instead and not doing that reentrant `onNext` call."
      },
      {
        "user": "ykinuse",
        "created_at": "2018-09-16T16:06:44Z",
        "body": "Thanks for the clarification. PublishSubject was used as an example of some source. So I'm assuming doOnSubscribe() chained after startWith does not guaranteed subscription established to the source? Was expecting a guaranteed subscription to source before startWith emits. "
      },
      {
        "user": "akarnokd",
        "created_at": "2018-09-16T16:21:06Z",
        "body": "No. StartWith is like concat, subscribes the next source after the previous source has completed, thus no `doOnSubscribe` is called on the next source until that."
      },
      {
        "user": "ykinuse",
        "created_at": "2018-09-16T16:30:33Z",
        "body": "Cleared my doubts. Thanks for the swift & clear response!"
      }
    ]
  },
  {
    "number": 6208,
    "title": "About the concatArray question  ",
    "created_at": "2018-09-12T13:30:33Z",
    "closed_at": "2018-09-12T13:34:18Z",
    "labels": [
      "Question",
      "2.x",
      "StackOverflow"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6208",
    "body": "Use version ：2.1.3   \r\ndemand：Read the cache to update the UI, and then request the network to update the UI\r\nexample code：\r\n```\r\n    Observable.concatArray(cache,netWork)\r\n                .subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(new Observer<Patient>() {\r\n                    @Override\r\n                    public void onSubscribe(Disposable d) {\r\n\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(Patient patient) {\r\n\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(Throwable e) {\r\n\r\n                    }\r\n\r\n                    @Override\r\n                    public void onComplete() {\r\n\r\n                    }\r\n                });\r\n```\r\nCached data is available locally，phones don't have Internet，The above code Inject Activity#onCreat call\r\n\r\nExpect to get the cache fill UI and prompt the user for error information\r\n\r\nbut，no get the cache fill UI,Just prompt for error.\r\n\r\nwhy? How to solve?\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6208/comments",
    "author": "XiFanYin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-09-12T13:34:18Z",
        "body": "Please ask such questions on StackOverflow, especially regarding Android usages."
      },
      {
        "user": "XiFanYin",
        "created_at": "2018-09-13T01:30:33Z",
        "body": "@akarnokd  You're sure it's not a library bug?"
      }
    ]
  },
  {
    "number": 6201,
    "title": "toList + blockingGet got No instance field actual of type",
    "created_at": "2018-09-04T09:41:08Z",
    "closed_at": "2018-09-04T09:45:02Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6201",
    "body": "Hello.\r\n\r\n  -Rx java version 2.2.1\r\n\r\n  - Sample code ```Observable.fromIterable(Collections.asList(1,2,3,4,5).map(it->String.valuesOf(it)).toList().blockinGet()```\r\n\r\nIn version 2.2.0 this code works fine, but after update i got ```No instance field actual of type Lio/reactivex/Observer; in class Lcom/tspoon/traceur/ObservableOnAssembly$OnAssemblyObserver; or its superclasses (declaration of 'com.tspoon.traceur.ObservableOnAssembly$OnAssemblyObserver' appears in /data/app/<package>-70wiK-18tepU--Vcj9Vf3A==/base.apk!classes5.dex)```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6201/comments",
    "author": "andruy94",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-09-04T09:45:02Z",
        "body": "This is a problem with `com.tspoon.traceur.ObservableOnAssembly`, not RxJava. Please contact the maintainers of that library."
      },
      {
        "user": "andruy94",
        "created_at": "2018-09-04T10:01:43Z",
        "body": "@akarnokd  thanks for answer"
      }
    ]
  },
  {
    "number": 6190,
    "title": "Why doesn't Flowable#buffer(long, TimeUnit, int) support backpressure?",
    "created_at": "2018-08-31T19:16:59Z",
    "closed_at": "2018-08-31T19:55:53Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6190",
    "body": "Why doesn't Flowable#buffer(long, TimeUnit, int) support backpressure?\r\n\r\nI'm using version 2.2.1, and here's the code for my experiment:\r\n```java\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tFlowable.range(0, 10000)\r\n\t\t.buffer(5, TimeUnit.SECONDS, 100)\r\n//\t\t.onBackpressureBuffer()\r\n\t\t.concatMap(list -> {\r\n\t\t\tSystem.out.println(list.size());\r\n\t\t\treturn Flowable.just(list).delaySubscription(500, TimeUnit.MILLISECONDS);\r\n\t\t})\r\n\t\t.blockingSubscribe();\r\n\t}\r\n```\r\nThe code above will cause a `MissingBackpressureException` unless I add `.onBackpressureBuffer()` after `.buffer(5, TimeUnit.SECONDS, 100)`, which is to be expected because the Javadoc for `Flowable#buffer(long, TimeUnit, int)` says `This operator does not support backpressure as it uses time`.\r\n\r\nSo here are my questions:\r\n1. I understand why a size based buffer can support backpressure while a time based buffer cannot. But why can't a time and size based buffer support backpressure like a purely size based buffer does?\r\n2. Is there a way to achieve a backpressured size based buffer with a time based \"kick\"?\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6190/comments",
    "author": "slisaasquatch",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-08-31T19:26:38Z",
        "body": "> But why can't a time and size based buffer support backpressure like a purely size based buffer does\r\n\r\nBecause the time part makes it backpressure incompatible and backpressuring would result in time not being honored.\r\n\r\n> Is there a way to achieve a backpressured size based buffer with a time based \"kick\"?\r\n\r\nWhat if the downstream is not ready to receive a buffer when this \"kick\" happens? Apply one of the `onBackpressureXXX` operators to decide what should happen."
      },
      {
        "user": "slisaasquatch",
        "created_at": "2018-08-31T19:55:53Z",
        "body": "Thanks for your quick reply! I think I understand now. I'll close the issue."
      }
    ]
  },
  {
    "number": 6184,
    "title": "flatmap from observable to completable,onComplete Action no call!",
    "created_at": "2018-08-29T09:44:07Z",
    "closed_at": "2018-08-29T09:54:41Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6184",
    "body": "RxJava version:2.1.12\r\n\r\ncode:\r\n``` kotlin\r\nObservable.create<Unit> { it.onNext(Unit) }\r\n                    .observeOn(Schedulers.io())\r\n                    .flatMap { Observable.create<Unit> { it.onNext(Unit) } }\r\n                    .flatMap { Observable.create<Unit> { it.onNext(Unit) } }\r\n                    .flatMap { Observable.create<Unit> { it.onNext(Unit) } }\r\n                    .flatMapCompletable {\r\n                        Completable.create {\r\n                            Thread.sleep(3000)\r\n                            //do something\r\n                            it.onComplete()\r\n                        }\r\n                    }\r\n                    .observeOn(AndroidSchedulers.mainThread())\r\n                    .subscribe(Action {\r\n                        //no call\r\n                        print(\"11111\")\r\n                    }, Consumer {\r\n                        print(\"1111\")\r\n                    })\r\n```\r\nI don't know why, the final onComplete Action is not called. Is there a problem with my usage?\r\nIf you replace all Observable.create with Observable.just() , the final onComplete Action will be called. Why?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6184/comments",
    "author": "linzhengloser",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-08-29T09:54:41Z",
        "body": "You need a finite sequence in each `create` in order for the various `flatMap`s to complete at which point the entire sequence completes and you get that Action call.\r\n\r\nPlease, next time ask such questions on StackOverflow."
      },
      {
        "user": "linzhengloser",
        "created_at": "2018-08-30T01:14:44Z",
        "body": "Thank you very much!"
      }
    ]
  },
  {
    "number": 6177,
    "title": "2.x: Completable.takeUntil() behavior suggestion",
    "created_at": "2018-08-27T07:14:17Z",
    "closed_at": "2018-08-27T08:44:48Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6177",
    "body": "I recently found that `Completable.takeUntil()` had been added since RxJava 2.1.17.\r\nIt calls downstream's `onComplete()` when `other` completes before source completes, but in my opinion that's not reasonable.\r\nBecause `onComplete()` of `Completable` is conceptually more like an emission rather than just a termination signal, I think it should call `onError(CancellationException)` instead of `onComplete()`, just like `Single.takeUntil()`.\r\n\r\nWhen I write some logic inside the first callback of `subscribe()`, the logic is not called for other stream types such as `Single` or `Observable` when a stream given to `takeUntil()` terminates, but only `Completable` calls the logic with the same form of code.\r\n\r\n```kotlin\r\nsingle.takeUntil(terminationSignal)\r\n    .subscribe {\r\n        // this is not called when terminationSignal terminates earlier\r\n    }\r\n\r\nobservable.takeUntil(terminationSignal)\r\n    .subscribe {\r\n        // this is also not called when terminationSignal terminates before any emission\r\n    }\r\n\r\ncompletable.takeUntil(terminationSignal)\r\n    .subscribe {\r\n        // this is called even when terminationSignal terminates earlier\r\n    }\r\n```\r\n\r\nThis is pretty confusing and looks like not consistent, so I suggest to make `takeUntil()` call `onError(CancellationException)` rather than `onComplete()`.\r\nPlease consider this issue. Thank you.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6177/comments",
    "author": "skgmn",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-08-27T07:56:13Z",
        "body": "> This is pretty confusing and looks like not consistent\r\n\r\nPlease consider that the operators have to work with the specific protocols of the participating reactive types. For example, there is no `onComplete` in `Single` thus a `takeUntil` can't complete a `Single` like it would an `Observable`.\r\n\r\n> make takeUntil() call onError(CancellationException)\r\n\r\nNothing is preventing you from getting `onError` called on `terminationSignal`:\r\n\r\n```java\r\nCompletableSubject terminationSignal = CompletableSubject.create();\r\n\r\ncompletable.takeUntil(terminationSignal)\r\n    .subscribe(() -> {\r\n        System.out.println(\"Should not be called\");\r\n    }, e -> {\r\n        e.printStackTrace();\r\n    });\r\n\r\nterminationSignal.onError(new CancellationException());\r\n```\r\n\r\nor, if you have a cold termination signal, compose in the exception:\r\n\r\n```java\r\nCompletable terminationSignal = ...\r\n\r\ncompletable.takeUntil(\r\n        terminationSignal.andThen(\r\n            Completable.fromAction(() -> { throw new CancellationException(); })\r\n        )\r\n    )\r\n    .subscribe(() -> {\r\n        System.out.println(\"Should not be called\");\r\n    }, e -> {\r\n        e.printStackTrace();\r\n    });\r\n```"
      },
      {
        "user": "skgmn",
        "created_at": "2018-08-27T08:44:48Z",
        "body": "I had already been doing that way even before `Completable.takeUntil()` was added (using `ambWith()`), but it had been pretty uncomfortable because that made code longer or required me to write my own extension methods (for kotlin) or transformers (for java).\r\nSo I hoped the standard `Completable.takeUntil()` to make it easier when it came out, but it was different than I expected. That's why I made my suggestion, but it's ok to be rejected if you have a firm philosophy for designing APIs.\r\nThank you for the answer."
      }
    ]
  },
  {
    "number": 6169,
    "title": "Give Flowable.sequenceEqual()/BiPredicate the option to use Single<Boolean> instead of boolean",
    "created_at": "2018-08-23T09:15:45Z",
    "closed_at": "2018-08-31T19:29:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6169",
    "body": "I need to compare two `Flowable`s, that unfortunaley, due to `groupBy()` do not complete until all items it contains are subscribed to. \r\n\r\nCurrently, this is not possible since test() in the BiPredicate you can implement for `sequenceEqual()` can only return a `boolean`, it expects the `Flowable` to be comparable one by one. I suggest to overload `test()` so that it can also return `Single<Boolean>` - thus allowing the comparison to happen for all elements of the `Flowable` before expecting it to complete, which lets every item be subscribed to.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6169/comments",
    "author": "Namnodorel",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-08-23T09:24:41Z",
        "body": "I'm not sure what you try to achieve here. `sequenceEqual` compares item by item when both sources have at least one item ready for comparison."
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-23T09:36:01Z",
        "body": "@akarnokd Yes. And this one-after-the-other comparison doesn't work if the items are (or come from a Flowable that was a) `GroupedFlowable`s. In that case, the first item won't complete until all the other items are subscribed to. But currently, `sequenceEqual()` waits until the first item comparison completes until it moves on to the next one. For this to work, `sequenceEqual()` would need to be able to compare the `Flowable`s asynchronously."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-23T09:42:43Z",
        "body": "Please show some actual code that demonstrates your issue."
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-23T09:56:50Z",
        "body": "Given a class `ValueGroup` with an object `key` and a `Flowable`. I want to squash multiple `ValueGroup`s with the same key together, like this:\r\n```\r\nFlowable<ValueGroup> myFlowable = ...;\r\nmyFlowable\r\n.groupBy(ValueGroup::getKey)\r\n    .map(groupedValueGroups -> new ValueGroup(\r\n        groupedValueGroups.getKey(),\r\n        groupedValueGroups\r\n            .flatMap((Function<ValueGroup, Publisher<? extends Value>>) ValueGroup::getFlowable)\r\n))\r\n```\r\nAt some point later in the code, I then use\r\n```\r\nFlowable.sequenceEqual(myFlowable, anotherFlowable)\r\n```\r\n(`anotherFlowable` is basically the same as `myFlowable`)\r\n\r\nWhat then happens, is: `sequenceEqual()` takes the first item of both Flowables, tries to compare them, and... gets stuck. Because to compare the `ValueGroup`s, the `Flowable`s inside them also need to be compared. But they don't complete, because all the other elements have not yet been subscribed to."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-23T10:03:49Z",
        "body": "You have to consume the groups in order for them to make progress. A Single predicate won't help your case as it is too late by then. Turn the groups into Lists and compare that way."
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-23T10:15:03Z",
        "body": "Turning `Flowable`s into a `List` is in th category of \"it technically works, but it's not really a clean solution\"...\r\n\r\nI honestly don't quite understand why it wouldn't work for `sequenceEqual()` to call `test()` asynchronously for all objects that it will compare. That way, all `Flowable`s would be subscribed to \"at once\", and could properly complete. The groups would be consumed in the sense that their comparison emits a `Single<Boolean>`."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-23T10:33:17Z",
        "body": "> I honestly don't quite understand why it wouldn't work \r\n\r\n`Flowable.groupBy` has backpressure and in order to have the sequence progress at all, you have to consume all groups it creates. Thus you can't just save up an inner `Flowable` to be compared later.\r\n\r\n> call test() asynchronously \r\n\r\nDoesn't work, the operator would subscribe to that `Single` and then hang as well because of the above.\r\n\r\nYou could try and adapt the following:\r\n\r\n```java\r\nFlowable<Flowable<Integer>> seq1 = ...;\r\nFlowable<Flowable<Integer>> seq2 = ...;\r\n\r\nFlowable.zip(seq1, seq2, (a, b) -> \r\n    return Flowable.sequenceEqual(a, b);\r\n)\r\n.flatMapSingle(v -> v)\r\n.all(v -> v);\r\n```"
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-23T10:48:12Z",
        "body": ">Flowable.groupBy has backpressure and in order to have the sequence progress at all, you have to consume all groups it creates. Thus you can't just save up an inner Flowable to be compared later.\r\n\r\nI know, that's not what I'm having trouble with understanding.\r\n>Doesn't work, the operator would subscribe to that `Single` and then hang as well because of the above.\r\n\r\nThat would happen if it subscribed to only one `Single` at a time. But because it is async, it wouldn't need to wait for the first `Single` to complete, but could instead go on and subscribe to the rest of them as well. Until at some point, it has subscribed to all, and then they'll be able to complete.\r\n\r\nI'll try your example."
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-28T13:21:45Z",
        "body": "Example is also stuck. "
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-28T13:27:26Z",
        "body": "Try with an `Observable`-based setup."
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-31T19:20:36Z",
        "body": "Nevermind, the first example was actually correct, and I made a mistake in implementing it (my actual scenario is a little more complex, but that isn't relevant to the problem itself).\r\n\r\nThe issue I had is thus solved, however I'd still like to keep the suggestion: Implement this as an alternative to the existing `sequenceEqual()` so that it works with data that can't be compared one after the other for one reason or the other. "
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-31T19:29:46Z",
        "body": "> Nevermind, the first example was actually correct\r\n\r\nGreat!\r\n\r\n> Implement this as an alternative\r\n\r\nI'm not convinced this is common enough to add it to RxJava. What if the structure is different? What if other properties are different? What if the operation should be different?"
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-31T19:47:16Z",
        "body": "Structure? Of what? The elements held in the compared Flowable/Observable? I think that is specific to my case, what's on my mind is more something that is just capable of comparing sequences not \"in order\".\r\n\r\nBasically a `sequenceEqual()` that does what your example did, but instead of returning `Flowable.sequenceEqual(a, b)` in `zip()` accessing an interface similar to `BiPredicate`, with the change of returning a `Single<Boolean>`. The elements themselves would be compared like usual; if they contain (or are) nested Flowables/Observables, you'll need a custom implementation of the comparing interface one way or the other.\r\n\r\nRegarding being common... Well, to me it sounds like it could be common enough to be included, but - well, you're the expert :D"
      }
    ]
  },
  {
    "number": 6166,
    "title": "2.2.0: Improvement. Observable#onErrorReturnItem should return Single",
    "created_at": "2018-08-22T10:42:24Z",
    "closed_at": "2018-08-22T10:44:02Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6166",
    "body": "**Version 2.2.0**\r\n\r\nPlease look at current method declaration:\r\n` public final Observable<T> onErrorReturnItem(final T item) {\r\n        ObjectHelper.requireNonNull(item, \"item is null\");\r\n        return onErrorReturn(Functions.justFunction(item));\r\n    }`\r\n\r\nAccording to the documentation & behaviour it _instructs an ObservableSource to emit an item (returned by a specified function) rather than invoking Observer#onError if it encounters an error. It is emitted along with a regular onComplete._ \r\n\r\nThat falls under the description of Single.\r\n\r\nSo my suggestion is to make this method return `Single<T>` to avoid confusing in usage. \r\nSame for `onErrorReturn` methods\r\nAlso consider to add method like `onErrorReturnItemAndPropagateError` to emit the item followed with the error. But of course it could be achieved with `onErrorResumeNext` manually",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6166/comments",
    "author": "BelooS",
    "comments": [
      {
        "user": "BelooS",
        "created_at": "2018-08-22T10:44:33Z",
        "body": "sorry, it is impossible, because in regular case it works like observable"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-22T10:51:16Z",
        "body": "Changing the return type of any operator is a binary incompatible change and thus they can only happen at major version chages."
      }
    ]
  },
  {
    "number": 6163,
    "title": "Why rx throws OnErrorNotImplementedException when I have doOnError",
    "created_at": "2018-08-18T02:40:36Z",
    "closed_at": "2018-08-18T02:47:28Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6163",
    "body": "version:\r\n2.2.0\r\n\r\nThe code:\r\n\r\n```java\r\n        Observable.create(new ObservableOnSubscribe<String>() {\r\n            @Override\r\n            public void subscribe(ObservableEmitter<String> emitter) throws Exception {\r\n                Log.d(TAG, \"subscribe: \" + \" 111111111\");\r\n                emitter.onNext(\"success\");\r\n                emitter.onError(new Throwable(\"2222222\"));\r\n            }\r\n        })\r\n                .doOnNext(new Consumer<String>() {\r\n                    @Override\r\n                    public void accept(String s) throws Exception {\r\n                        Log.d(TAG, \"accept: doOnNext \" + s);\r\n                    }\r\n                })\r\n                .doOnError(new Consumer<Throwable>() {\r\n                    @Override\r\n                    public void accept(Throwable throwable) throws Exception {\r\n                        Log.d(TAG, \"accept: doOnError \" + throwable);\r\n                    }\r\n                })\r\n               .subscribe();\r\n```\r\nThe Exception:\r\n\r\nio.reactivex.exceptions.OnErrorNotImplementedException: 2222222\r\n\r\nIf the `doOnError` can not handle the exception, the `doOnError` is design for what?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6163/comments",
    "author": "anatta-feng",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2018-08-18T02:43:12Z",
        "body": "It's for side-effects (e.g., logging). If you want to handle the error, add something which can handle errors to the `subscribe` call."
      },
      {
        "user": "anatta-feng",
        "created_at": "2018-08-18T02:47:25Z",
        "body": "ok, thanks."
      }
    ]
  },
  {
    "number": 6161,
    "title": "2.x: Value loss with BehaviorSubject",
    "created_at": "2018-08-17T16:55:13Z",
    "closed_at": "2018-08-17T17:41:51Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6161",
    "body": "RxJava version: `2.2.0`\r\nJava version: `java version \"1.8.0_181\"`\r\nKotlin version: `1.2.60`\r\n\r\nBasically the following test simulates a sort of like producer-consumer-like logic. There's a `requestPublisher` which emits a bunch of events as numbers. `requestPublisher` is the producer here. Then there's a consumer `processRequest` which will wait till the `whenConnected` emits true to process the requests from `resultPublisher`. The `processRequest` consumer will transform a request as a number into a string.\r\n\r\n**Expected**: The number of results that `resultObserver` has received should be `requestCount`.\r\n**Actual**: Sometimes the number of results that `resultObserver` has received is smaller than `requestCount`.\r\n\r\n```kotlin\r\npackage thuy.androidsamples\r\n\r\nimport io.reactivex.Observable\r\nimport io.reactivex.Single\r\nimport io.reactivex.observers.BaseTestConsumer\r\nimport io.reactivex.schedulers.Schedulers\r\nimport io.reactivex.subjects.BehaviorSubject\r\nimport org.junit.Test\r\nimport java.util.concurrent.TimeUnit\r\n\r\nclass SubjectTest {\r\n  @Test\r\n  fun test() {\r\n    (1..50).forEach { r ->\r\n      val requestCount = 100 * r\r\n      println(\"Testing round $r with request count: $requestCount\")\r\n      tryToReproduceValueLostIssue(requestCount)\r\n    }\r\n  }\r\n\r\n  private fun tryToReproduceValueLostIssue(requestCount: Int) {\r\n    // Arrange\r\n    val requestPublisher = BehaviorSubject.create<Int>().toSerialized()\r\n    // requestPublisher.subscribe { println(\"[DISPATCHED] $it\") }\r\n    val resultPublisher = BehaviorSubject.create<String>()\r\n    val resultObserver = resultPublisher.test()\r\n\r\n    val whenConnected = BehaviorSubject.createDefault(false)\r\n    fun <T> Observable<T>.waitTillConnected(): Observable<T> =\r\n      flatMap { x ->\r\n        whenConnected\r\n          .filter { it }\r\n          .firstOrError()\r\n          .map { x }\r\n          .toObservable()\r\n      }\r\n\r\n    val processRequest = requestPublisher\r\n      .observeOn(Schedulers.io())\r\n      .waitTillConnected()\r\n      // .doOnNext { println(\"[STARTED] $it\") }\r\n      .flatMap { x ->\r\n        Single\r\n          .fromCallable {\r\n            // Sleep to simulate a slight hiccup while dealing with a request.\r\n            TimeUnit.MILLISECONDS.sleep(600)\r\n            \"$x ✓\"\r\n          }\r\n          // .doOnNext { println(\"[FINISHED] $it\") }\r\n          .toObservable()\r\n      }\r\n\r\n    // Act\r\n    processRequest.subscribe(resultPublisher::onNext)\r\n\r\n    whenConnected.onNext(true)\r\n\r\n    (1..requestCount).forEach {\r\n      TimeUnit.MILLISECONDS.sleep(100)\r\n      requestPublisher.onNext(it)\r\n    }\r\n\r\n    // Assert\r\n    val timeout: Long = 2\r\n    resultObserver.awaitCount(requestCount, BaseTestConsumer.TestWaitStrategy.SLEEP_10MS, TimeUnit.MINUTES.toMillis(timeout))\r\n    resultObserver.assertValueCount(requestCount)\r\n  }\r\n}\r\n```\r\n\r\nIn my testing, the test above will fail:\r\n\r\n```\r\nTesting round 1 with request count: 100\r\nTesting round 2 with request count: 200\r\nTesting round 3 with request count: 300\r\n\r\njava.lang.AssertionError: Value counts differ; Expected: 300, Actual: 250 (latch = 1, values = 250, errors = 0, completions = 0, timeout!)\r\n\r\n\tat io.reactivex.observers.BaseTestConsumer.fail(BaseTestConsumer.java:190)\r\n\tat io.reactivex.observers.BaseTestConsumer.assertValueCount(BaseTestConsumer.java:516)\r\n\tat thuy.androidsamples.SubjectTest.tryToReproduceValueLostIssue(SubjectTest.kt:66)\r\n\tat thuy.androidsamples.SubjectTest.test(SubjectTest.kt:17)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\r\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\r\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\r\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\r\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\r\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\r\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\r\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\r\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\r\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\r\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\r\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\r\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\r\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\r\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)\r\n\tat com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)\r\n\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)\r\n\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat com.intellij.rt.execution.application.AppMainV2.main(AppMainV2.java:131)\r\n```\r\n\r\nI suspect there's something related to backpressure which I'm not quite familiar with or maybe there's a bug with `BehaviorSubject`.\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6161/comments",
    "author": "thuytrinh",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-08-17T17:33:09Z",
        "body": "You sleep 600 milliseconds between items. With 300 items, that's 180 seconds or 3 minutes. Generating 300 items takes 30 seconds and the wait for items starts after that, so effectively the test ends after 150 seconds. 150 allowed/180 needed * 300 expected = 250 actual items. Of course generating 400 items with the same sleeping will require even more time.\r\n\r\nSo this is not a bug in RxJava but in your test setup and the setup has no backpressure-related aspect either."
      }
    ]
  },
  {
    "number": 6142,
    "title": "Rename unsubscribeOn() to disposeOn()",
    "created_at": "2018-08-05T20:13:32Z",
    "closed_at": "2018-08-05T20:31:15Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6142",
    "body": "Many callbacks and methods are already using `dispose` in name, it does makes sense to rename `unsubscribeOn(Scheduler)` to `disposeOn(Schduler)` in my opinion as we already have `onDispose`, `dispose` and similar methods.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6142/comments",
    "author": "UMFsimke",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-08-05T20:31:15Z",
        "body": "Many more know it as `unsubscribeOn` from the 1.x era. This has been brought up and discussed before #4646."
      }
    ]
  },
  {
    "number": 6118,
    "title": "Some operators sometimes wait a long time",
    "created_at": "2018-07-31T09:34:43Z",
    "closed_at": "2018-08-06T07:58:59Z",
    "labels": [
      "Question",
      "Android",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6118",
    "body": "【version】\r\n```\r\n    api 'io.reactivex.rxjava2:rxjava:2.x.y'\r\n    api 'io.reactivex.rxjava2:rxandroid:2.0.1'\r\n    api 'com.trello.rxlifecycle2:rxlifecycle-components:2.2.1'\r\n    api 'com.jakewharton.rxbinding2:rxbinding:2.0.0'\r\n    api 'com.squareup.retrofit2:retrofit:2.3.0'\r\n    api 'com.squareup.retrofit2:adapter-rxjava2:2.3.0'\r\n    api 'com.squareup.retrofit2:converter-gson:2.3.0'\r\n    api 'com.squareup.okhttp3:logging-interceptor:3.8.1'\r\n```\r\n\r\n【question】\r\nI integrate rxjava2 operations in the parent class of activity, but sometimes the operator has to wait a long time to get into the method. Is it caused by rxjava2?\r\nUsing rxjava1 does not appear to be a problem...\r\n\r\n【question-ex】\r\n\r\n---------Sometimes the duration will more than 2 min!!!!!!!!!!!!!!!!!!!!!!!!!!!!-------\r\n\r\n```java\r\nimport android.os.SystemClock;\r\n\r\nimport com.centerm.selforderfork9fnp.R;\r\nimport com.centerm.selforderfork9fnp.base.activity.BaseActivity;\r\nimport com.centerm.selforderfork9fnp.tools.Logger;\r\n\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.ObservableEmitter;\r\nimport io.reactivex.ObservableOnSubscribe;\r\nimport io.reactivex.functions.Consumer;\r\nimport io.reactivex.schedulers.Schedulers;\r\n\r\n/**\r\n * author : koge_yvone\r\n * date : 2018/7/31\r\n * desc : 描述\r\n * version : 1.0\r\n */\r\n\r\npublic class DemoActivity extends BaseActivity {\r\n    private Long obStartTime;\r\n    private Long obCallbackTime;\r\n\r\n    private Long newObStartTime;\r\n    private Long newObCallbackTime;\r\n\r\n    @Override\r\n    protected boolean isNeedLoadDataThread() {\r\n        return true;//start rxjava2\r\n    }\r\n\r\n    @Override\r\n    protected boolean isHideStatusBar() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    protected void onBindMainLayoutId() {\r\n        setContentView(R.layout.activity_launcher);\r\n    }\r\n\r\n    @Override\r\n    protected void onInitView() {\r\n        //todo  findViewById\r\n        obStartTime = SystemClock.currentThreadTimeMillis();\r\n        Logger.d(\"create time on======>\" + obStartTime);\r\n    }\r\n\r\n    @Override\r\n    protected void onLoadData() {\r\n        //todo do something on thread(io(),newThread()... and so on)\r\n        obCallbackTime = SystemClock.currentThreadTimeMillis();\r\n        Logger.d(\"end time on======>\" + obCallbackTime);\r\n        Logger.d(\"duration======>\" + (obCallbackTime - obStartTime));\r\n    }\r\n\r\n    @Override\r\n    protected void onYourThings() {\r\n        testNewOb();\r\n    }\r\n\r\n    private void testNewOb() {\r\n        newObStartTime = SystemClock.currentThreadTimeMillis();\r\n        Logger.d(\"new Ob create time on======>\" + newObStartTime);\r\n        Observable observable = Observable.create(new ObservableOnSubscribe<Integer>() {\r\n            @Override\r\n            public void subscribe(ObservableEmitter<Integer> e) throws Exception {\r\n                newObCallbackTime = SystemClock.currentThreadTimeMillis();\r\n                Logger.d(\"new Ob end time on======>\" + newObCallbackTime);\r\n                Logger.d(\"new Ob duration======>\" + (newObCallbackTime - newObStartTime));\r\n                int i = 0;\r\n                while (i < 100) {\r\n                    i++;\r\n                    SystemClock.sleep(100);\r\n                }\r\n                e.onNext(i);\r\n                e.onComplete();\r\n            }\r\n        }).subscribeOn(Schedulers.io());\r\n        send(observable, new Consumer() {\r\n            @Override\r\n            public void accept(Object o) throws Exception {\r\n\r\n                //todo refreshView();\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n【code-BaseActivity】\r\n\r\n```java\r\n/**\r\n * author : koge_yvone\r\n * date : 2017/12/26\r\n * desc : 基础类activity\r\n * version : 1.0\r\n */\r\n\r\npublic abstract class BaseActivity extends RxAppCompatActivity implements BaseView {\r\n    private LoadingDialog dialog;\r\n    public static final int FLAG_HOMEKEY_DISPATCHED = 0x80000000; //需要自己定义标志\r\n    private CompositeDisposable mCompositeDisposable = new CompositeDisposable();\r\n\r\n    /**\r\n     * @return 是否开启状态栏隐藏功能\r\n     */\r\n    protected abstract boolean isHideStatusBar();\r\n\r\n    /**\r\n     * 绑定布局\r\n     */\r\n    protected abstract void onBindMainLayoutId();\r\n\r\n    /**\r\n     * 初始化你的页面-【主线程】\r\n     */\r\n    protected abstract void onInitView();\r\n\r\n\r\n    /**\r\n     * 初始化你需要耗时的事情，这里是不会影响界面阻塞的，不要在这里做UI刷新的事情-【io线程】\r\n     */\r\n    protected abstract void onLoadData();\r\n\r\n\r\n    /**\r\n     * 耗时结束，界面刷新后，开始你的搞事吧-【主线程】\r\n     */\r\n    protected abstract void onYourThings();\r\n\r\n    @Override\r\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        //先判断是否隐藏状态栏\r\n        if (isHideStatusBar()) hideStatusBar();\r\n        this.getWindow().setFlags(FLAG_HOMEKEY_DISPATCHED, FLAG_HOMEKEY_DISPATCHED);//屏蔽HOME关键代码\r\n        //设置布局\r\n        onBindMainLayoutId();\r\n        //初始化布局\r\n        onInitView();\r\n        //是否需要开启线程加载，默认开启\r\n        if (isNeedLoadDataThread()) initObservable();\r\n            //不需要开启，直接搞自己的事情\r\n        else onYourThings();\r\n        //将activity页面推入堆栈\r\n        ActMgr.getAppManager().addActivity(this);\r\n        dialog = new LoadingDialog(this);\r\n    }\r\n\r\n    /**\r\n     * 给懒人用的，帮你循环注册到同一个rxClickListener，建议写为Activity的成员……\r\n     *\r\n     * @param rxClickListener\r\n     * @param viewOrViewIds\r\n     */\r\n    public void addClickViews(RxClickListener rxClickListener, Object... viewOrViewIds) {\r\n        if (viewOrViewIds == null) throw new SecurityException(\"viewOrViewId is not support\");\r\n        for (Object viewOrViewId : viewOrViewIds) registerClickView(viewOrViewId, rxClickListener);\r\n    }\r\n\r\n    /**\r\n     * 注册防止抖动的点击事件\r\n     * 支持viewId或者view类型\r\n     *\r\n     * @param viewOrViewId\r\n     * @param listener\r\n     */\r\n    public void registerClickView(Object viewOrViewId, RxClickListener listener) {\r\n        View view;\r\n        if (viewOrViewId instanceof Integer) {\r\n            view = findViewById(Integer.parseInt(String.valueOf(viewOrViewId)));\r\n        } else if (viewOrViewId instanceof View) {\r\n            view = (View) viewOrViewId;\r\n        } else throw new SecurityException(\"viewOrViewId is not support\");\r\n        Observable observable = new MyViewClickObservable(view)\r\n                .throttleFirst(1, TimeUnit.SECONDS);\r\n        if (listener != null) send(observable, listener);\r\n    }\r\n\r\n    /**\r\n     * 初始化load加载观察者事件\r\n     */\r\n    protected void initObservable() {\r\n        Observable observable = Observable.create(new ObservableOnSubscribe<Boolean>() {\r\n            @Override\r\n            public void subscribe(ObservableEmitter<Boolean> e) throws Exception {\r\n                onLoadData();//这个是耗时操作，不要做UI刷新\r\n                e.onNext(true);\r\n                e.onComplete();\r\n            }\r\n        }).subscribeOn(Schedulers.io());\r\n        DisposableObserver observer = new DisposableObserver() {\r\n            @Override\r\n            protected void onStart() {\r\n                super.onStart();\r\n                onLoadStart();\r\n            }\r\n\r\n            @Override\r\n            public void onNext(Object o) {\r\n                onYourThings();\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable e) {\r\n                e.printStackTrace();\r\n                onLoadFail(e.getMessage());\r\n                onLoadEnd();\r\n            }\r\n\r\n            @Override\r\n            public void onComplete() {\r\n                onLoadEnd();\r\n            }\r\n        };\r\n        mCompositeDisposable.add(observer);\r\n        send(observable, observer);\r\n    }\r\n\r\n    /**\r\n     * @return 是否需要开启本地数据加载线程？默认开启...\r\n     */\r\n    protected boolean isNeedLoadDataThread() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return 是否需要让页面的文字不随着字体大小的变动而变动？默认不随着变动...\r\n     */\r\n    protected boolean isNeedFontSizeNotChange() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 隐藏状态栏，这个方法，还是私有吧，都要在setContentView之前，给你们用了也没用。。。\r\n     * Android 5.0以下版本是设置全屏哈，是全屏哈~~哈\r\n     */\r\n    private void hideStatusBar() {\r\n        Window window = getWindow();\r\n        window.requestFeature(Window.FEATURE_NO_TITLE);\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\r\n            window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS\r\n                    | WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);\r\n            window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\r\n                    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION\r\n                    | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);\r\n            window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\r\n            window.setStatusBarColor(Color.TRANSPARENT);\r\n            window.setNavigationBarColor(Color.TRANSPARENT);\r\n        } else {\r\n            window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,\r\n                    WindowManager.LayoutParams.FLAG_FULLSCREEN); // 设置全屏\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param v\r\n     * @param event\r\n     * @return 判断点击的位置是否可以隐藏输入法\r\n     */\r\n    private boolean isShouldHideInput(View v, MotionEvent event) {\r\n        if (v != null && (v instanceof EditText)) {\r\n            int[] leftTop = {0, 0};\r\n            //获取输入框当前的location位置\r\n            v.getLocationInWindow(leftTop);\r\n            int left = leftTop[0];\r\n            int top = leftTop[1];\r\n            int bottom = top + v.getHeight();\r\n            int right = left + v.getWidth();\r\n            if (event.getX() > left && event.getX() < right\r\n                    && event.getY() > top && event.getY() < bottom) {\r\n                // 点击的是输入框区域，保留点击EditText的事件\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * 发送rx的线程消息，以observer回调\r\n     * 绑定activity的onDestroy生命周期，当页面销毁的时候，线程就不收你的回调啦~\r\n     *\r\n     * @param observable\r\n     * @param observer\r\n     */\r\n    @SuppressLint(\"RestrictedApi\")\r\n    @Override\r\n    public void send(Observable observable, Observer observer) {\r\n        checkNotNull(observable, \"observable is null\");\r\n//        Logger.d(\"rxjava=========>send开始时间为：\" + DateUtils.getNowDate(DateUtils.FXGALL));\r\n        observable.compose(this.<Long>bindUntilEvent(ActivityEvent.DESTROY))//当activity执行destroy的时候结束订阅\r\n                .observeOn(AndroidSchedulers.mainThread()).subscribe(observer);\r\n\r\n//        observable\r\n//                .observeOn(AndroidSchedulers.mainThread()).subscribe(observer);\r\n    }\r\n\r\n    /**\r\n     * 发送rx的线程消息，以consumer回调\r\n     * 绑定activity的onDestroy生命周期，当页面销毁的时候，线程就不收你的回调啦~\r\n     *\r\n     * @param observable\r\n     * @param consumer\r\n     */\r\n    @SuppressLint(\"RestrictedApi\")\r\n    @Override\r\n    public void send(Observable observable, Consumer consumer) {\r\n        checkNotNull(observable, \"observable is null\");\r\n//        Logger.d(\"rxjava=========>send开始时间为：\" + DateUtils.getNowDate(DateUtils.FXGALL));\r\n        observable.compose(this.<Long>bindUntilEvent(ActivityEvent.DESTROY))//当activity执行destroy的时候结束订阅\r\n                .observeOn(AndroidSchedulers.mainThread()).subscribe(consumer);\r\n\r\n//        observable\r\n//                .observeOn(AndroidSchedulers.mainThread()).subscribe(consumer);\r\n    }\r\n\r\n    /**\r\n     * 开始加载的状态，可以用来转转转-【主线程】\r\n     */\r\n    @Override\r\n    public void onLoadStart() {\r\n\r\n    }\r\n\r\n    /**\r\n     * 加载失败的情况，可以用来填充失败情况-【主线程】\r\n     *\r\n     * @param errorMsg\r\n     */\r\n    @Override\r\n    public void onLoadFail(String errorMsg) {\r\n\r\n    }\r\n\r\n    /**\r\n     * 加载结束的状态，可以用来停止转转转-【主线程】\r\n     */\r\n    @Override\r\n    public void onLoadEnd() {\r\n\r\n    }\r\n\r\n    @Override\r\n    public boolean dispatchTouchEvent(MotionEvent ev) {\r\n        if (ev.getAction() == MotionEvent.ACTION_DOWN) {\r\n            View v = getCurrentFocus();\r\n            if (isShouldHideInput(v, ev)) {\r\n                KeyboardUtils.hideKeyboard(v);\r\n            }\r\n            return super.dispatchTouchEvent(ev);\r\n        }\r\n        // 必不可少，否则所有的组件都不会有TouchEvent了\r\n        if (getWindow().superDispatchTouchEvent(ev)) {\r\n            return true;\r\n        }\r\n        return onTouchEvent(ev);\r\n    }\r\n\r\n    @Override\r\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\r\n        if (keyCode == event.KEYCODE_HOME) {\r\n            return true;\r\n        }\r\n        return super.onKeyDown(keyCode, event);\r\n    }\r\n\r\n    @Override\r\n    public Resources getResources() {\r\n        Resources res = super.getResources();\r\n        if (!isNeedFontSizeNotChange()) {//默认的话系统字体变更了，我们这边不变更\r\n            return res;\r\n        }\r\n        Configuration config = new Configuration();\r\n        config.setToDefaults();\r\n        res.updateConfiguration(config, res.getDisplayMetrics());\r\n        return res;\r\n    }\r\n\r\n    @Override\r\n    protected void onDestroy() {\r\n        //移除堆栈信息中的activity\r\n        ActMgr.getAppManager().removeActivity(this);\r\n        mCompositeDisposable.clear();\r\n        super.onDestroy();\r\n    }\r\n\r\n    /**\r\n     * Activity jump method start\r\n     */\r\n\r\n    public void jumpToActivity(Intent intent) {\r\n        jumpToActivity(intent, false);\r\n    }\r\n\r\n    public void jumpToActivity(Intent intent, View view, String sharedName) {\r\n        jumpTo(intent, view, sharedName, false);\r\n    }\r\n\r\n    public void jumpToActivityForResult(Intent intent, int code) {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\r\n            jump_v21ForResult(intent, code);\r\n        else\r\n            jumpForResult(intent, code);\r\n    }\r\n\r\n    protected void jumpToActivity(Intent intent, boolean isFinishSelf) {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\r\n            jump_v21(intent);\r\n        else\r\n            jump(intent);\r\n        if (isFinishSelf)\r\n            supportedFinish();\r\n    }\r\n\r\n    protected void supportedFinish() {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\r\n            finishAfterTransition();\r\n        } else {\r\n            super.finish();\r\n        }\r\n    }\r\n\r\n    private void jumpTo(Intent intent, View view, String sharedName, boolean finishSelf) {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\r\n            jumpWithSharedElement(intent, view, sharedName);\r\n        } else {\r\n            jump(intent);\r\n        }\r\n        if (finishSelf) {\r\n            supportedFinish();\r\n        }\r\n    }\r\n\r\n    @TargetApi(value = Build.VERSION_CODES.LOLLIPOP)\r\n    private void jumpWithSharedElement(Intent intent, View view, String sharedName) {\r\n        startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, view, sharedName).toBundle());\r\n    }\r\n\r\n    private void jump(Intent intent) {\r\n        startActivity(intent);\r\n    }\r\n\r\n    @TargetApi(value = Build.VERSION_CODES.LOLLIPOP)\r\n    private void jump_v21(Intent intent) {\r\n        startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this).toBundle());\r\n    }\r\n\r\n    private void jumpForResult(Intent intent, int code) {\r\n        startActivityForResult(intent, code);\r\n    }\r\n\r\n    @SuppressLint(\"RestrictedApi\")\r\n    @TargetApi(value = Build.VERSION_CODES.LOLLIPOP)\r\n    private void jump_v21ForResult(Intent intent, int code) {\r\n        startActivityForResult(intent, code, ActivityOptions.makeSceneTransitionAnimation(this).toBundle());\r\n    }\r\n\r\n    /**\r\n     * end\r\n     */\r\n\r\n    @Override\r\n    public void onBackPressed() {\r\n        supportedFinish();\r\n    }\r\n\r\n    public void showLoading() {\r\n        if (dialog != null) {\r\n            dialog.show();\r\n        }\r\n    }\r\n\r\n    public void showLoading(Object msgOrResId) {\r\n        if (dialog != null) {\r\n            if (msgOrResId instanceof String)\r\n                dialog.getText().setText(String.valueOf(msgOrResId));\r\n            else if (msgOrResId instanceof Integer)\r\n                dialog.getText().setText(Integer.parseInt(String.valueOf(msgOrResId)));\r\n            dialog.getText().setVisibility(View.VISIBLE);\r\n            dialog.show();\r\n        }\r\n    }\r\n\r\n    public void hideLoading() {\r\n        if (dialog != null) {\r\n            dialog.dismiss();\r\n        }\r\n    }\r\n\r\n    public Context getThisActivity() {\r\n        return this;\r\n    }\r\n}\r\n```\r\n\r\n【code-BaseView】\r\n\r\n```java\r\n/**\r\n * author : koge_yvone\r\n * date : 2017/12/15\r\n * desc : BaseView接口\r\n * version : 1.0\r\n */\r\n\r\npublic interface BaseView {\r\n\r\n    /**\r\n     * 发送rx的线程消息，以observer回调\r\n     *\r\n     * @param observable\r\n     * @param observer\r\n     */\r\n    void send(Observable observable, Observer observer);\r\n\r\n    /**\r\n     * 发送rx的线程消息，以consumer回调\r\n     *\r\n     * @param observable\r\n     * @param consumer\r\n     */\r\n    void send(Observable observable, Consumer consumer);\r\n\r\n    /**\r\n     * 开始加载的状态，可以用来转转转\r\n     */\r\n    void onLoadStart();\r\n\r\n    /**\r\n     * 加载失败的情况，可以用来填充失败情况\r\n     *\r\n     * @param errorMsg\r\n     */\r\n    void onLoadFail(String errorMsg);\r\n\r\n    /**\r\n     * 加载结束的状态，可以用来停止转转转\r\n     */\r\n    void onLoadEnd();\r\n\r\n}\r\n```\r\n\r\n【code-MyViewClickObservable】\r\n```\r\npublic class MyViewClickObservable extends Observable<Object> {\r\n    private final View view;\r\n\r\n    public MyViewClickObservable(View view) {\r\n        this.view = view;\r\n    }\r\n\r\n    @SuppressLint(\"RestrictedApi\")\r\n    @Override\r\n    protected void subscribeActual(Observer<? super Object> observer) {\r\n        if (!checkMainThread(observer)) {\r\n            return;\r\n        }\r\n        MyViewClickObservable.Listener listener = new MyViewClickObservable.Listener(view, observer);\r\n        observer.onSubscribe(listener);\r\n        view.setOnClickListener(listener);\r\n    }\r\n\r\n    static final class Listener extends MainThreadDisposable implements View.OnClickListener {\r\n        private final View view;\r\n        private final Observer<? super Object> observer;\r\n\r\n        Listener(View view, Observer<? super Object> observer) {\r\n            this.view = view;\r\n            this.observer = observer;\r\n        }\r\n\r\n        @Override\r\n        public void onClick(View v) {\r\n            if (!isDisposed()) {\r\n                observer.onNext(v);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        protected void onDispose() {\r\n            view.setOnClickListener(null);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n【code-RxClickListener】\r\n\r\n```java\r\npublic abstract class RxClickListener implements Consumer<View> {\r\n    public abstract void onClick(View view);\r\n\r\n    @Override\r\n    public void accept(View view) throws Exception {\r\n        onClick(view);\r\n    }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6118/comments",
    "author": "yvone1991",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-07-31T10:20:05Z",
        "body": "I spent a lot of time trying to recreate your application but you omitted a lot of things. Please provide a standalone application, preferably a GitHub project, that **compiles and demonstrates** your problem. \r\n\r\nAlso provide a clear indication in between which points in your application do you experience that 2 minute delay. Please run your application in debug mode and pause it to see which thread does what that could hint about the source of the delay.\r\n\r\nI also recommend starting over with your application, step-by-step, and see what change introduces that huge delay, if any."
      },
      {
        "user": "yvone1991",
        "created_at": "2018-08-01T01:58:51Z",
        "body": " Logger.d(\"new Ob duration======>\" + (newObCallbackTime - newObStartTime));\r\n\r\nsometimes the duration more than 2 min~~~~sometimes..sometimes...sometimes...\r\n\r\n【code】\r\n\r\nprivate void testNewOb() {\r\n        newObStartTime = SystemClock.currentThreadTimeMillis();\r\n        Logger.d(\"new Ob create time on======>\" + newObStartTime);\r\n        Observable observable = Observable.create(new ObservableOnSubscribe<Integer>() {\r\n            @Override\r\n            public void subscribe(ObservableEmitter<Integer> e) throws Exception {\r\n                newObCallbackTime = SystemClock.currentThreadTimeMillis();\r\n                Logger.d(\"new Ob end time on======>\" + newObCallbackTime);\r\n                Logger.d(\"new Ob duration======>\" + (newObCallbackTime - newObStartTime));\r\n                int i = 0;\r\n                while (i < 100) {\r\n                    i++;\r\n                    SystemClock.sleep(100);\r\n                }\r\n                e.onNext(i);\r\n                e.onComplete();\r\n            }\r\n        }).subscribeOn(Schedulers.io());\r\n        send(observable, new Consumer() {\r\n            @Override\r\n            public void accept(Object o) throws Exception {\r\n\r\n                //todo refreshView();\r\n            }\r\n        });\r\n\r\n    }"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-01T06:11:53Z",
        "body": "Please use the triple backtick to denote code. Check out your question's sources which I fixed for you.\r\n\r\nI can't see any reason for that large delay. Maybe your device has a particular runtime where class initialization takes really long. Try with a very basic project and that code part only that measures the time to create body."
      },
      {
        "user": "yvone1991",
        "created_at": "2018-08-01T06:22:24Z",
        "body": "At first, when I wrote the UI interface, there was no such problem. (maybe I didn't test too many times.)\r\n\r\nWhen I write request logic on each interface, the create side will start waiting for a long time to start the launch(sometimes...sometimes...sometimes).\r\n\r\nI try to write a base project, but I can't guarantee that it will happen. And my whole project itself is just like my example code, and there's no extra thing to add, but I don't know why there's such a big delay when it's created."
      },
      {
        "user": "yvone1991",
        "created_at": "2018-08-01T06:28:44Z",
        "body": "whole project logic:\r\n\r\n【Every activity goes like this】\r\nActivity→bindLayout→findViewById→createObservable(delay more than 2 min, sometimes)→loadData( two minutes later, start this method )→onYourThings→createNewObservable（sometimes,delay more than 2 min）....\r\n\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-01T06:34:01Z",
        "body": "Without the entire project, I can't help you much further. Does it happen inside an emulator or on a device? Could you post your entire project on your GiHub repository?"
      },
      {
        "user": "yvone1991",
        "created_at": "2018-08-01T06:45:46Z",
        "body": "Can I send your e-mail？\r\n\r\n-----my project（^_^）"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-01T07:19:46Z",
        "body": "Yes. The address is my github handle + gmail.com"
      },
      {
        "user": "yvone1991",
        "created_at": "2018-08-01T07:42:11Z",
        "body": "Your email is classified as spam by the service provider (akarnokd@gmail.com), and the other party will not accept it."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-01T07:46:39Z",
        "body": "I can't give you any other email address. Are you on Twitter? Upload your code somewhere and PM me the URL."
      },
      {
        "user": "yvone1991",
        "created_at": "2018-08-01T07:48:50Z",
        "body": "I sent you with my company mailbox.\r\nDid you recieve it?"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-01T08:01:58Z",
        "body": "There is no attachment or link."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-01T08:19:43Z",
        "body": "In one of your emails, you mentioned this delay happens on POS devices. It could be device/Android specific anomaly. Are you using ProGuard? If not, try it; if yes, disable it and see if that helps."
      },
      {
        "user": "yvone1991",
        "created_at": "2018-08-01T08:31:27Z",
        "body": "I try it again，Did you recieve it？"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-01T08:32:16Z",
        "body": "I received a letter which asked me to ask for Google Drive permission of two files."
      },
      {
        "user": "yvone1991",
        "created_at": "2018-08-01T08:34:57Z",
        "body": "yes"
      },
      {
        "user": "yvone1991",
        "created_at": "2018-08-01T08:36:49Z",
        "body": "pen***555+gmail.com"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-01T08:37:47Z",
        "body": "I've already asked for permissions."
      },
      {
        "user": "yvone1991",
        "created_at": "2018-08-01T08:44:36Z",
        "body": "I have shared files"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-01T08:56:19Z",
        "body": "I've downloaded the project and built it. Where is the code that takes too long?"
      },
      {
        "user": "yvone1991",
        "created_at": "2018-08-01T09:05:15Z",
        "body": "OrderMenuActivity.class\r\nAddOrderActivity.class\r\nOrderStatusActivity.class\r\nOrderSureActivity.class\r\nTableAvtivity.class\r\n\r\n1、sometimes，onYourThings() delay 2 min reach。。。\r\n2、I have annotated a method：\r\nHttpManager.java\r\nline106 to line 110 log...\r\n====>\r\n```java\r\n   /**\r\n     * 请求前的准备\r\n     */\r\n    private Observable readyRequest(final String method, final Object body) {\r\n        Logger.d(\"这里开始开始发送数据源===========>readyRequest()\" + DateUtils.getNowDate(DateUtils.FXGALL));\r\n        Observable observable = Observable.just(body).map(new Function<Object, HttpRequest>() {\r\n            @Override\r\n            public HttpRequest apply(Object o) throws Exception {\r\n                Logger.d(\"这里开始组包===========>\" + DateUtils.getNowDate(DateUtils.FXGALL));\r\n                HttpRequest request = new HttpRequest();\r\n                request.setMethod(method);\r\n                request.setTimestamp(DateUtils.getNowDate(DateUtils.FXGALL));\r\n                request.setBiz_content(body);\r\n                request.setMac(\"222\");\r\n                request.setSession_id(\"222\");\r\n                Logger.d(\"这里组包完毕，发出去给retrofit2了===========>\");\r\n                return request;\r\n            }\r\n        }).subscribeOn(Schedulers.io());\r\n```"
      },
      {
        "user": "yvone1991",
        "created_at": "2018-08-01T09:08:44Z",
        "body": "All Observable that needs to be created may be delayed.\r\nThe previous use of rxjava1 did not have this problem"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-01T09:15:21Z",
        "body": "That `readyRequest` seems to be not in use. Are you sure you match the time difference properly in your log?"
      },
      {
        "user": "yvone1991",
        "created_at": "2018-08-01T09:20:12Z",
        "body": "It was originally used, and later removed。。。\r\n\r\nline159 to line 327，I have annotated them……\r\n\r\nFinally, I found that the problem of rxjava2 creation is not a create operator problem."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-01T09:25:33Z",
        "body": "> It was originally used, and later removed。。。\r\n\r\nHow would you expect me to diagnose your problem when the code isn't the one exhibiting the problem?\r\n\r\n> Finally, I found that the problem of rxjava2 creation is not a create operator problem.\r\n\r\nIt is likely you have a flaky network so it takes sometimes longer to get all response.\r\n"
      },
      {
        "user": "yvone1991",
        "created_at": "2018-08-01T09:36:18Z",
        "body": "Thank you very much for your patience.\r\n\r\nAt first I also suspected that it was a network problem, or something else, but until I used that way to verify it, I found that the time for creating OB was delay for a very long time.\r\n\r\nBut the problem I'm describing is that all the annotations I've done are to prove that something went wrong when I created the OB.\r\nPersonally, I think the key to the problem is to delay when creating OB objects. Because after 2min is delayed, all log will be brushed out in a flash, rather than a normal brush."
      }
    ]
  },
  {
    "number": 6115,
    "title": "rxjava2[2.1.8] delay Operation invalid when Turn off the screen  for a while",
    "created_at": "2018-07-30T03:20:18Z",
    "closed_at": "2018-07-30T06:02:22Z",
    "labels": [
      "Question",
      "Android",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6115",
    "body": "I used rxjava2[2.1.8] delay Operation in my  Foreground Service 。Normal use ok， but when Turn off the screen  for a while ，delay Operation cannot work，but the takeUntil Operation can use to cancel the invalid delay。my code：\r\n\r\n      Observable.just(1).delay(downtime, TimeUnit.SECONDS)\r\n                .doOnDispose({\r\n                    //valid all the time\r\n \r\n                })\r\n                .takeUntil(observable)\r\n                .subscribe({\r\n                    request()\r\n                })\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6115/comments",
    "author": "lckj686",
    "comments": [
      {
        "user": "TarasMazepa",
        "created_at": "2018-07-30T04:33:13Z",
        "body": "RxJava doesn't have any Android specific integration. If your code is not working in some tricky Android OS situations it usually means that you are doing something wrong with Android Sdk integration. In your case it could be one of the following:\r\n1. Your service is not ready for sporadic restarts from OS\r\n2. Your service doesn't aquire wake lock\r\n3. Consider using JobDcheduler to schedule some work instead of doing it with RxJava. JobScheduler will execute work even if your service/app is killed  "
      },
      {
        "user": "iNoles",
        "created_at": "2018-07-30T04:55:14Z",
        "body": "RxAndroid"
      },
      {
        "user": "TarasMazepa",
        "created_at": "2018-07-30T05:00:04Z",
        "body": "RxAndroid provides Android specific schedulers but have no effect on operators "
      },
      {
        "user": "akarnokd",
        "created_at": "2018-07-30T06:02:22Z",
        "body": "Please ask such platform specific questions on StackOverflow."
      },
      {
        "user": "lckj686",
        "created_at": "2018-07-31T00:53:04Z",
        "body": "thanks @TarasMazepa    ，\bI'll refer to your ideas "
      }
    ]
  },
  {
    "number": 6109,
    "title": "create()、just()...waiting long time",
    "created_at": "2018-07-27T10:40:49Z",
    "closed_at": "2018-07-31T08:14:52Z",
    "labels": [
      "Question",
      "Android",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6109",
    "body": "【version】\r\n```\r\napi 'io.reactivex.rxjava2:rxjava:2.x.y'\r\napi 'io.reactivex.rxjava2:rxandroid:2.0.1'\r\napi 'com.trello.rxlifecycle2:rxlifecycle-components:2.2.1'\r\napi 'com.jakewharton.rxbinding2:rxbinding:2.0.0'\r\napi 'com.squareup.retrofit2:retrofit:2.3.0'\r\napi 'com.squareup.retrofit2:adapter-rxjava2:2.3.0'\r\napi 'com.squareup.retrofit2:converter-gson:2.3.0'\r\napi 'com.squareup.okhttp3:logging-interceptor:3.8.1'\r\n```\r\n\r\n【code】\r\n====> parent\r\n```java\r\nabstract BaseActivity{\r\n    @Override\r\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        //hide statusbar\r\n        if (isHideStatusBar()) hideStatusBar();\r\n        //set Layout\r\n        onBindMainLayoutId();\r\n        //initLayoutView\r\n        onInitView();\r\n        if (isNeedLoadDataThread()) **initObservable();**\r\n        else _onYourThings()_;\r\n    }\r\n\r\n   protected void initObservable() {\r\n        Observable observable = Observable.create(new ObservableOnSubscribe<Boolean>() {\r\n            @Override\r\n            public void subscribe(ObservableEmitter<Boolean> e) throws Exception {\r\n                onLoadData();//Thread\r\n                e.onNext(true);\r\n                e.onComplete();\r\n            }\r\n        }).subscribeOn(Schedulers.io());\r\n        DisposableObserver observer = new DisposableObserver() {\r\n            @Override\r\n            protected void onStart() {\r\n                super.onStart();\r\n                onLoadStart();\r\n            }\r\n\r\n            @Override\r\n            public void onNext(Object o) {\r\n                _onYourThings();_\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable e) {\r\n                e.printStackTrace();\r\n                onLoadFail(e.getMessage());\r\n                onLoadEnd();\r\n            }\r\n\r\n            @Override\r\n            public void onComplete() {\r\n                onLoadEnd();\r\n            }\r\n        };\r\n        mCompositeDisposable.add(observer);\r\n        send(observable, observer);\r\n    }\r\n\r\n    @SuppressLint(\"RestrictedApi\")\r\n    @Override\r\n    public void send(Observable observable, Observer observer) {\r\n        checkNotNull(observable, \"observable is null\");\r\n        //bind onDestroy()\r\n        observable.compose(this.<Long>bindUntilEvent(ActivityEvent.DESTROY))\r\n                .observeOn(AndroidSchedulers.mainThread()).subscribe(observer);\r\n    }\r\n}\r\n```\r\n\r\nquestion:\r\n\r\nactivity→onLoadData()→onYourThings()→Observable.create()[here will wait 2 min……]\r\n\r\n```java\r\nactivity.oncreate()→Observable.create()/just()→Observer(){\r\n    String date1 = System.currentTimeMillis();\r\n    Log.i(TAG, date1);\r\n\r\n    Observable ob = Observable.create(){\r\n        String date2 = System.currentTimeMillis();\r\n        Log.i(TAG, date2);\r\n        //date2-date1>more than 2min!!!!!!!!!!!!!!!!!\r\n        **// waitting more than 2min before entering，why？？**\r\n        yourMethod();\r\n        e.onNext();\r\n        e.onComplete();\r\n    }；\r\n    send(ob,new Observer{\r\n       //...\r\n    });\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6109/comments",
    "author": "yvone1991",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-07-27T10:55:41Z",
        "body": "Please provide your **real** code as this won't compile and also very unlikely to exhibit such large delays. Also you haven't specified where you experience such large delays which makes us even harder to help you."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-07-31T08:14:52Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 6094,
    "title": "2.x: concatWith/mergeWith Completable for Single and Maybe",
    "created_at": "2018-07-18T17:06:04Z",
    "closed_at": "2018-07-19T12:32:50Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6094",
    "body": "Similar in vein to #5350, is there place in this library for methods that would void the need for extension functions like those four?\r\n\r\n```\r\nfun <T> Single<T>.concatWith(completable: Completable): Single<T> {\r\n    return toObservable().concatWith(completable).singleOrError()\r\n}\r\n\r\nfun <T> Single<T>.mergeWith(completable: Completable): Single<T> {\r\n    return toObservable().mergeWith(completable).singleOrError()\r\n}\r\n\r\nfun <T> Maybe<T>.concatWith(completable: Completable): Maybe<T> {\r\n    return toObservable().concatWith(completable).singleElement()\r\n}\r\n\r\nfun <T> Maybe<T>.mergeWith(completable: Completable): Maybe<T> {\r\n    return toObservable().mergeWith(completable).singleElement()\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6094/comments",
    "author": "arekolek",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-07-18T17:09:18Z",
        "body": "With Kotlin, you can have all sorts of extension methods yourself, there is no need to have them in RxJava itself. I don't think these paeticular convenience methods are worth it. You may try RxKotlin though."
      }
    ]
  },
  {
    "number": 6093,
    "title": "2.x: Concat operator, Maybes, and threading",
    "created_at": "2018-07-18T15:26:24Z",
    "closed_at": "2018-07-20T06:34:47Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6093",
    "body": "Following code sample (Kotlin 1.2.51, RxJava 2.1.16):\r\n```kotlin\r\nval m1 = Maybe.just(1).subscribeOn(Schedulers.io())\r\nval m2 = Maybe.just(1).subscribeOn(Schedulers.io())\r\n\r\nval m3 = m1\r\n    .concatWith(m2)\r\n    .firstElement()\r\n    .map { Thread.currentThread().name }\r\n\r\nvar counter = 0\r\nvar counterMain = 0\r\n\r\n(0 until 10000)\r\n    .forEach { if (m3.blockingGet() == \"main\") counterMain++ else counter++ }\r\n\r\nprintln(\"Result: main $counterMain, other $counter, sum ${counterMain + counter}\")\r\n````\r\nleads to the following in-deterministic (main number is different for each run) result:\r\n```Result: main 13, other 9987, sum 10000```\r\n\r\nIt seems that the result of the `concat` operator sometimes runs on the calling thread, even if the participating Maybes use specific schedulers. I could not reproduce this behavior for Observables or Singles. Is this intended behavior and the resulting thread cannot be guaranteed or could it be a bug?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6093/comments",
    "author": "schmist",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-07-18T15:53:31Z",
        "body": "This is a peculiarity of the backpressure inside the `concatArray` operator `concatWith` builds upon. If the first source is fast, the drain loop running on the main thread may get the success value and push it to downstream still on the main thread. You have to use `observeOn` before `map` to make sure the right thread is used or apply `subscribeOn` just after `concatWith` so that the drain loop is no longer invoked on the main thread if the above race condition happens."
      },
      {
        "user": "schmist",
        "created_at": "2018-07-18T17:18:37Z",
        "body": "Thanks for the quick answer!\r\n\r\nSince I cannot reproduce it for `Single` and `Observable`, and there are different `concatArray` implementations for `Flowable` and `Completable`, is the assumption correct that this peculiar behavior only exists for `Maybe` sources?\r\nIs this due to the nature of `Maybe` and cannot be changed or could it be fixed somehow so that all observable sources act the same?\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-07-18T18:26:10Z",
        "body": "This is a `Maybe` specific property as it has a dedicated implementation. `Single` is converted to `Flowable` and `Flowable.concat` is used where the code path is longer for the emission. Try with `Schedulers.single()` for those other implementations so that the scheduling window is minimal. "
      },
      {
        "user": "akarnokd",
        "created_at": "2018-07-18T18:38:21Z",
        "body": "To be clear, concatenating `Observable`s doesn't have this effect because there is no backpressure to coordinate the emissions with. Each source emits from its thread which passes through the `concat` operator. With `Flowable`, emissions may be held off or simply cached until the value can be retrieved, but this can happen on any participating threads. That's why to ensure proper reception of items, one should use `observeOn` before such `map`s to make sure no matter where the value originated, it continues on the desired thread (until the next async boundary)."
      },
      {
        "user": "schmist",
        "created_at": "2018-07-19T09:22:25Z",
        "body": "Ok, many thanks for your answers!"
      }
    ]
  },
  {
    "number": 6065,
    "title": "IndexOutOfBoundsException on io.reactivex.Observable.elementAtOrError (Observable.java:29134)",
    "created_at": "2018-06-27T06:14:08Z",
    "closed_at": "2018-07-08T07:38:23Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6065",
    "body": "Hi Guys,\r\n\r\nIn Crashlytics logs, for Android 4.4.2 and below we have a crash with \r\njava.lang.IndexOutOfBoundsException: index >= 0 required but it was 0\r\nio.reactivex.Observable.elementAtOrError (Observable.java:29134)\r\n\r\nThis condition should never be met. How could it be happened?\r\nI cannot reproduce it not locally nor on the device.\r\n\r\nrxJava 2.1.12\r\n\r\nThanks for your answer,\r\nMikhail",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6065/comments",
    "author": "chichaykin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-06-27T06:39:45Z",
        "body": "The code clearly checks for index < 0 so I don't know how it can happen. What is Fabric?"
      },
      {
        "user": "vanniktech",
        "created_at": "2018-06-27T07:11:46Z",
        "body": "Fabric is a container which has multiple functionalities. One of which is Crashlytics which gives you crash reporting. "
      },
      {
        "user": "akarnokd",
        "created_at": "2018-06-27T07:28:31Z",
        "body": "Could you give more context or some code snippets? Does your code get transformed in some way before execution?"
      },
      {
        "user": "TarasMazepa",
        "created_at": "2018-06-27T19:52:59Z",
        "body": "Hi @chichaykin, it looks like you are using proguard or something similar. Assuming that Observable.java have less than 10 000 lines of code, but in your crash report line # 29134 referenced. Can you decompile you apk and post here decompiled code of Observable.java? \r\n\r\nAlso, the full stack trace would be helpful.\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-07-08T07:38:23Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 6034,
    "title": "2.x: Why not using volatile on parameter `done` in BasicFuseableSubscriber ? Is that safe ?",
    "created_at": "2018-06-04T07:41:05Z",
    "closed_at": "2018-06-04T07:46:22Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6034",
    "body": "i am using RxJava v2.1.12 , and i have some confused.\r\n\r\nWhy not using volatile on parameter `done` in BasicFuseableSubscriber ? Is that safe ? would it cause any memory visibility problems ?\r\nThe following is my understanding : \r\nBasicFuseableSubscriber is using at middle operations like map , filter , doOnEach and etc.. its upstream subscriber will ensure thread safe between `onNext` `onComplete` `onError` , so it don't have the necessary to use volatile ?\r\n\r\nIs my understanding right ?\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6034/comments",
    "author": "happyomg",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-06-04T07:46:22Z",
        "body": "That's correct."
      },
      {
        "user": "pli2014",
        "created_at": "2018-06-04T09:04:22Z",
        "body": "@akarnokd  good job. BTW,  how do we switch threads between onNext onComplete onError in the same subscriber?   observeOn? but I always got same thread...\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-06-04T09:22:23Z",
        "body": "Please provide context for what you try to achieve and how do you check for the required thread."
      }
    ]
  },
  {
    "number": 6008,
    "title": "2.x: Single, toObservable and share: sometimes NoSuchElementException",
    "created_at": "2018-05-16T09:38:23Z",
    "closed_at": "2018-05-17T02:15:26Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6008",
    "body": "Hello. I periodically have a NoSuchElementException. Version 2.1.12.\r\n\r\nCode:\r\n```\r\nSingle<String> single = Single.just(\"12345\")\r\n              .toObservable()\r\n              .share()\r\n              .singleOrError();\r\n      \r\n      for (int i = 0; i < 10; i++) {\r\n         new Thread(() -> {\r\n            single.subscribe((t) -> {\r\n            }, thrw -> {\r\n               if (NoSuchElementException.class.equals(thrw.getClass())) {\r\n                  printStackTrace();\r\n                  return;\r\n               }\r\n            });\r\n         }).start();\r\n\r\n         if (i % 2 != 0) {\r\n            Thread.sleep(4);\r\n         }\r\n      }\r\n\r\n```\r\nStacktrace:\r\n```\r\nat io.reactivex.internal.observers.ConsumerSingleObserver.onError(ConsumerSingleObserver.java:47)\r\n\tat io.reactivex.internal.operators.observable.ObservableSingleSingle$SingleElementObserver.onComplete(ObservableSingleSingle.java:113)\r\n\tat io.reactivex.internal.operators.observable.ObservableRefCount$ConnectionObserver.onComplete(ObservableRefCount.java:145)\r\n\tat io.reactivex.internal.operators.observable.ObservablePublish$PublishObserver.onComplete(ObservablePublish.java:193)\r\n\tat io.reactivex.internal.observers.DeferredScalarDisposable.complete(DeferredScalarDisposable.java:85)\r\n\tat io.reactivex.internal.operators.single.SingleToObservable$SingleToObservableObserver.onSuccess(SingleToObservable.java:73)\r\n\tat io.reactivex.internal.operators.single.SingleJust.subscribeActual(SingleJust.java:30)\r\n\tat io.reactivex.Single.subscribe(Single.java:3220)\r\n\tat io.reactivex.internal.operators.single.SingleToObservable.subscribeActual(SingleToObservable.java:36)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:12005)\r\n\tat io.reactivex.internal.operators.observable.ObservablePublish.connect(ObservablePublish.java:116)\r\n\tat io.reactivex.internal.operators.observable.ObservableRefCount.subscribeActual(ObservableRefCount.java:68)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:12005)\r\n\tat io.reactivex.internal.operators.observable.ObservableSingleSingle.subscribeActual(ObservableSingleSingle.java:35)\r\n\tat io.reactivex.Single.subscribe(Single.java:3220)\r\n\tat io.reactivex.Single.subscribe(Single.java:3206)\r\n```\r\n\r\nIs this a bug or an incorrect code? For cycle is written to demonstrate the problem.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6008/comments",
    "author": "neyron91",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-05-16T10:19:27Z",
        "body": "This is a plausible outcome when using `share`. The underlying `publish` operator emits items to currently subscribed observers only. With that race in your code, some observers may come after the \"12345\" has been emitted but just before `onComplete` is signalled, thus they encounter an empty sequence. \r\n\r\nUse `replay(1).refCount()` to ensure you don't lose that single item."
      },
      {
        "user": "neyron91",
        "created_at": "2018-05-17T01:45:51Z",
        "body": "Thanks, it works!"
      }
    ]
  },
  {
    "number": 5963,
    "title": "Rxjava like event bus",
    "created_at": "2018-04-17T09:15:22Z",
    "closed_at": "2018-04-17T09:18:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5963",
    "body": "Hi, I am stuck in implementing RxJava as event bus in one scenario of my application. Here it goes,\r\nI have a singleton RxBus\r\nGrandParentFragment -> subscribe to RxBus.\r\nGrandParentFragment -. loads Parent Fragment-> which also subscribes to RxBus\r\nParentFragment->loads GrandChild-> which emits an item using the singleton RxBus.\r\nThis value is intended only for the parent and not the Grand parent. But because Grand Parent Fragment is live in memory it uses the stream to perform some ops. \r\n\r\nI was thinking of unsubscribing from RxBus in the Grand parent fragment in onPause method and subscribe back on the onResume. But this has same overhead like event bus to register and unregister.\r\n\r\nDo share some other solution for this use case.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5963/comments",
    "author": "preyesm",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-04-17T09:18:23Z",
        "body": "Don't do event bus in RxJava as it defeats the benefits of it. Also StackOverflow is full of event bus questions, please go there and search/ask this type of question there."
      }
    ]
  },
  {
    "number": 5962,
    "title": "2.x: Observable.mergeDelayError behavior",
    "created_at": "2018-04-16T12:55:37Z",
    "closed_at": "2018-04-20T13:26:58Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5962",
    "body": "When I use `Observable.mergeDelayError` , the error is not delayed and there is no diference with the simple `Observable.merge`. To force delay the error, I've to put the flag `delayError` of the `observeOn ` method to true. If I'm not wrong it is a bug since _delayError = true + merge_ should do the same as simply using _mergeDelayError_.\r\n\r\nHere you can see the code that does not work:\r\n\r\n        val networkSingle: Observable<List<User>> = Observable.error(Exception(\"Exception\"))\r\n        val defaultSingle: Observable<List<User>> = Observable.just<List<User>>(listOf())\r\n\r\n        Observable.mergeDelayError(defaultSingle, networkSingle)\r\n                .subscribeOn(Schedulers.io())\r\n                .observeOn(Schedulers.newThread())\r\n                .subscribeBy(onError = {\r\n                    errorsUI++\r\n\r\n                    println(\"errorsUI $errorsUI\")\r\n                }, onNext = {\r\n                    valuesUI++\r\n                    println(\"valuesUI $valuesUI\")\r\n\r\n                }).addTo(CompositeDisposable())\r\n    }\r\n\r\n\r\nAnd there the same code working:\r\n\r\n        val networkSingle: Observable<List<User>> = Observable.error(Exception(\"Exception\"))\r\n        val defaultSingle: Observable<List<User>> = Observable.just<List<User>>(listOf())\r\n\r\n        Observable.merge(defaultSingle, networkSingle)\r\n                .subscribeOn(Schedulers.io())\r\n                .observeOn(Schedulers.newThread(), true)\r\n                .subscribeBy(onError = {\r\n                    errorsUI++\r\n\r\n                    println(\"errorsUI $errorsUI\")\r\n                }, onNext = {\r\n                    valuesUI++\r\n                    println( \"valuesUI $valuesUI\")\r\n\r\n                }).addTo(CompositeDisposable())\r\n    }\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5962/comments",
    "author": "juzabel",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-04-16T13:55:15Z",
        "body": "Works as intended. \r\n\r\nEach operator has a scope where their behavior takes effect. Separate operator, separate behavior and configuration. If you want to keep delaying errors and prevent errors from cutting ahead, you have to specify `delayError = true` in every operator supporting such configuration."
      }
    ]
  },
  {
    "number": 5941,
    "title": "[RxJava 2.1] Executing blocking operations on IO scheduler switches execution to a single thread",
    "created_at": "2018-03-31T03:43:40Z",
    "closed_at": "2018-04-15T11:28:20Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5941",
    "body": "RxJava 2.1.3\r\n\r\nSample that demonstrates the problem:\r\n\r\n```java\r\nimport java.util.concurrent.ConcurrentHashMap;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\nimport java.util.concurrent.atomic.AtomicLong;\r\n\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.ObservableTransformer;\r\nimport io.reactivex.functions.Action;\r\nimport io.reactivex.schedulers.Schedulers;\r\n\r\npublic class Main {\r\n  private static final int NUM_THREADS = 8;\r\n  private static final int NUM_EVENTS = 200;\r\n\r\n  public static void main(String[] args) throws Exception {\r\n    System.out.println(\"Executing blocking operation...\");\r\n    observe(() -> Thread.sleep((long) (Math.random() * 100)));\r\n\r\n    System.out.println(\"Executing non-blocking operation...\");\r\n    observe(() -> {});\r\n  }\r\n\r\n  private static void observe(Action op) {\r\n    AtomicInteger messageReceived = new AtomicInteger(0);\r\n    AtomicInteger observableComplete = new AtomicInteger(0);\r\n    ConcurrentHashMap<String, AtomicInteger> counters = new ConcurrentHashMap<>();\r\n\r\n    createObservable()\r\n        .compose(createThreadPoolTransformer())\r\n        .compose(performOperation(op))\r\n        .subscribe(\r\n            e -> {\r\n              counters.compute(Thread.currentThread().getName(), (key, ai) -> {\r\n                ai = ai == null ? new AtomicInteger(0) : ai;\r\n                ai.incrementAndGet();\r\n                return ai;\r\n              });\r\n              messageReceived.incrementAndGet();\r\n\r\n              if (messageReceived.get() == NUM_EVENTS) {\r\n                System.out.println(String.format(\"Counts per thread: %s \\n\", counters));\r\n              }\r\n            }, e -> {}, observableComplete::incrementAndGet);\r\n\r\n    while(observableComplete.get() == 0) {\r\n      // wait until it's complete\r\n    }\r\n  }\r\n\r\n  private static Observable<Long> createObservable() {\r\n    return Observable.just(0).repeat(NUM_EVENTS).map(al -> {\r\n      Thread.sleep(10);\r\n      return System.currentTimeMillis();\r\n    });\r\n  }\r\n\r\n  private static ObservableTransformer<Long, Long> createThreadPoolTransformer() {\r\n    AtomicLong counter = new AtomicLong(0);\r\n    return upstream ->\r\n        upstream\r\n            .groupBy(e -> counter.getAndIncrement() % NUM_THREADS)\r\n            .flatMap(g -> g.observeOn(Schedulers.io()));\r\n  }\r\n\r\n  private static ObservableTransformer<Long, Long> performOperation(Action op) {\r\n    return upstream -> upstream\r\n        .map(\r\n            e -> {\r\n              if (Math.random() < 0.5) {\r\n                op.run();\r\n              }\r\n              return e;\r\n            });\r\n  }\r\n}\r\n```\r\nRunning the program should print something like:\r\n```\r\nExecuting blocking operation...\r\nCounts per thread: {RxCachedThreadScheduler-1=200} \r\n\r\nExecuting non-blocking operation...\r\nCounts per thread: {RxCachedThreadScheduler-1=25, RxCachedThreadScheduler-2=25, RxCachedThreadScheduler-3=25, RxCachedThreadScheduler-8=25, RxCachedThreadScheduler-4=25, RxCachedThreadScheduler-5=25, RxCachedThreadScheduler-6=25, RxCachedThreadScheduler-7=25} \r\n```\r\n\r\nIt shows that after scheduling execution of blocking operations on an IO pool, the observable runs all these operations on a single thread instead.\r\n\r\nI would really appreciate any suggestions to retain equal load on all threads even in the presence of blocking operations!",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5941/comments",
    "author": "sndre",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-03-31T08:51:28Z",
        "body": "The outcome is completely within allowed behavior for two things:\r\n\r\n- `flatMap` doesn't guarantee that a source thread will be able to push through. It is completely possible that one or few threads will perform the merge for the other threads, therefore, it may appear only one or two threads are only involved pushing data further to the downstream.\r\n- You are measuring the thread use at the end consumer, which is always serialized thus there is no guarantee you'll see that many thread hopping there. To make sure `op` is executed in various background threads, you should apply it after `g.observeOn(Schedulers.io())` inside `flatMap` as well as do the current thread check there."
      },
      {
        "user": "sndre",
        "created_at": "2018-04-17T18:32:57Z",
        "body": "@akarnokd, thank you so much for looking into it! That make sense and we followed your suggestion to to apply operations after `observeOn` 💯 "
      }
    ]
  },
  {
    "number": 5939,
    "title": "2.x: Observable.switchMapCompletable does not call action on completion",
    "created_at": "2018-03-30T07:59:47Z",
    "closed_at": "2018-04-01T08:23:10Z",
    "labels": [
      "Question",
      "2.x",
      "Kotlin"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5939",
    "body": "Maybe I’m using it wrong though. I’ve prepared some tests.\r\n\r\n```kotlin\r\nimport io.reactivex.Completable\r\nimport io.reactivex.functions.Action\r\nimport io.reactivex.schedulers.TestScheduler\r\nimport io.reactivex.subjects.PublishSubject\r\nimport org.junit.Test\r\nimport org.mockito.Mockito\r\nimport java.util.concurrent.TimeUnit\r\n\r\nclass CompletableTest {\r\n\r\n    private class Environment {\r\n\r\n        private val completableSeconds = 5\r\n\r\n        val timeScheduler = TestScheduler()\r\n        val action = Mockito.mock(Action::class.java)\r\n\r\n        val observable = PublishSubject.create<Unit>()\r\n        val completable = Completable.timer(completableSeconds.toLong(), TimeUnit.SECONDS, timeScheduler)\r\n\r\n        fun trigger() {\r\n            observable.onNext(Unit)\r\n            timeScheduler.advanceTimeBy(completableSeconds.toLong(), TimeUnit.SECONDS)\r\n        }\r\n    }\r\n\r\n    @Test fun pass_directSubscription() {\r\n        val env = Environment()\r\n\r\n        env.observable.subscribe { env.completable.subscribe(env.action) }\r\n\r\n        env.trigger()\r\n\r\n        Mockito.verify(env.action).run()\r\n    }\r\n\r\n    @Test fun fail_switchMapCompletable() {\r\n        val env = Environment()\r\n\r\n        env.observable.switchMapCompletable { env.completable }.subscribe(env.action)\r\n\r\n        env.trigger()\r\n\r\n        Mockito.verify(env.action).run()\r\n    }\r\n}\r\n```\r\n```\r\nWanted but not invoked:\r\naction.run();\r\n-> at CompletableTest.fail_switchMapCompletable\r\nActually, there were zero interactions with this mock.\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5939/comments",
    "author": "arturdryomov",
    "comments": [
      {
        "user": "artem-zinnatullin",
        "created_at": "2018-03-30T17:10:01Z",
        "body": "Because it returns `Completable` that waits for upstream completion, like regular `switchMap`\r\n\r\nSimpler test:\r\n\r\n```java\r\n@Test\r\npublic void t1() {\r\n    PublishSubject<Integer> subject = PublishSubject.create();\r\n\r\n    subject\r\n            .switchMapCompletable(new Function<Integer, CompletableSource>() {\r\n                @Override\r\n                public CompletableSource apply(Integer integer) throws Exception {\r\n                    return Completable.complete();\r\n                }\r\n            })\r\n            .test()\r\n            .assertComplete(); // Fails!\r\n}\r\n```\r\n\r\nBut if you complete upstream, it'll complete `switchMapCompletable`:\r\n\r\n```java\r\n@Test\r\npublic void t2() {\r\n    PublishSubject<Integer> subject = PublishSubject.create();\r\n\r\n    TestObserver<Void> test = subject\r\n            .switchMapCompletable(new Function<Integer, CompletableSource>() {\r\n                @Override\r\n                public CompletableSource apply(Integer integer) throws Exception {\r\n                    return Completable.complete();\r\n                }\r\n            })\r\n            .test();\r\n\r\n    test.assertNotComplete();\r\n\r\n    subject.onComplete();\r\n    \r\n    test.assertComplete();\r\n}\r\n```\r\n\r\n\r\nEdit: add \"Fails!\" comment."
      },
      {
        "user": "arturdryomov",
        "created_at": "2018-04-01T08:23:10Z",
        "body": "Thanks! In my mind each `onNext` of an `Observable` would start the declared `Completable`."
      }
    ]
  },
  {
    "number": 5912,
    "title": "Single.zip with Iterable<T> overload does not call given zipper function",
    "created_at": "2018-03-13T10:36:10Z",
    "closed_at": "2018-03-19T13:47:03Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5912",
    "body": "I have discovered that, invoking Single.zip with an empty Iterable will not call given zipper function. Is this behavior by design? I would expect that the zipper function would be called with an empty object-array. \r\n\r\n```\r\n  @Test\r\n  void singleDoesNothing() {\r\n    Single<Object[]> zip =\r\n        Single.zip(\r\n            Collections.emptyList(),\r\n            objects -> {\r\n              return objects;\r\n            });\r\n\r\n    zip.test().assertNotComplete().assertNoValues();\r\n  }\r\n```\r\n\r\nUsed version: 2.1.7 \r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5912/comments",
    "author": "SergejIsbrecht",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-03-13T10:40:22Z",
        "body": "Yes, this is by design."
      },
      {
        "user": "yuriykulikov",
        "created_at": "2018-03-13T10:48:06Z",
        "body": "Hello David,\r\ncould you please elaborate? What is the reason for this?"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-03-13T11:09:30Z",
        "body": "0 sources have no items to zip."
      },
      {
        "user": "yuriykulikov",
        "created_at": "2018-03-13T11:20:18Z",
        "body": "It must be at least explicitely mentioned in the documentation. Otherwise there is a lot of confusion, because developers interpret the current javadoc as: \"empty Iterable -> empty Array\". This is very unfortunate, because an empty Iterable becomes a corner case, which does not always happen, but when it does, nothing happens.\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-03-13T11:24:32Z",
        "body": "See #5876."
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2018-03-19T13:45:21Z",
        "body": "Guess we could close this as #5876 was merged :)"
      }
    ]
  },
  {
    "number": 5901,
    "title": "2.x: Pulib constructor for TestScheduler that already takes the time",
    "created_at": "2018-03-07T14:53:08Z",
    "closed_at": "2018-03-09T13:22:54Z",
    "labels": [
      "Question",
      "PR welcome",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5901",
    "body": "I'd like to have the ability to have an instantiated TestScheduler which already has a time. Internally it'd just delegate to `advanceTimeTo` and the constructor would also take the same parameters as that method.\r\n\r\nWhat are your thoughts?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5901/comments",
    "author": "vanniktech",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-03-07T15:06:13Z",
        "body": "You can do it simply after construction:\r\n\r\n```java\r\nTestScheduler scheduler = new TestScheduler();\r\nscheduler.advanceTimeBy(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\r\n```\r\n\r\nIf this is frequent, just create a static helper method:\r\n\r\n```java\r\npublic static TestScheduler newTestScheduler(long initialTimeMillis) {\r\n    TestScheduler scheduler = new TestScheduler();\r\n    scheduler.advanceTimeBy(initialTimeMillis, TimeUnit.MILLISECONDS);\r\n    return scheduler;\r\n}\r\n```"
      },
      {
        "user": "vanniktech",
        "created_at": "2018-03-07T15:08:00Z",
        "body": "Yeah with Kotlin it's even easier. I still feel like a constructor that takes the time would be beneficial. I'm not feeling too strong about it so I'll see what the opinions of other folks are."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-03-09T09:27:54Z",
        "body": "I guess this isn't that of a maintenance intensive change so PR welcome. You could set the current time directly without wasting time by calling `advanceTimeBy`."
      }
    ]
  },
  {
    "number": 5880,
    "title": "2.1.9 My Single does not run",
    "created_at": "2018-03-03T16:11:24Z",
    "closed_at": "2018-03-03T16:24:51Z",
    "labels": [
      "Question",
      "Android",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5880",
    "body": "I'm trying to convert this AsyncTask:\r\n\r\n```\r\n    private static class UpdateFeedTask extends AsyncTask<Void, Void, Void> {\r\n        private WeakReference<FeedFragment> weakFeedFragment;\r\n\r\n        private UpdateFeedTask(FeedFragment feedFragment) {\r\n            this.weakFeedFragment = new WeakReference<>(feedFragment);\r\n        }\r\n\r\n        @Override\r\n        protected void onPreExecute() {\r\n            if (!weakFeedFragment.get().swipeRefreshLayout.isRefreshing()) {\r\n                weakFeedFragment.get().feedProgressBar.setVisibility(View.VISIBLE);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        protected final Void doInBackground(Void... voids) {\r\n            weakFeedFragment.get().submissionList = weakFeedFragment.get().paginator.next();\r\n\r\n            return null;\r\n        }\r\n\r\n        @Override\r\n        protected void onPostExecute(Void value) {\r\n            weakFeedFragment.get().feedProgressBar.setVisibility(View.INVISIBLE);\r\n            weakFeedFragment.get().swipeRefreshLayout.setRefreshing(false);\r\n            weakFeedFragment.get().isLoadingNextSubmissions = false;\r\n\r\n            FeedAdapter feedAdapter = (FeedAdapter) weakFeedFragment.get().recyclerView.getAdapter();\r\n            feedAdapter.updateItems(weakFeedFragment.get().submissionList);\r\n        }\r\n    }\r\n```\r\n\r\ninto a Single Observable, but when I call it, it does not initiate at all:\r\n\r\n```\r\n   private void UpdateFeed() {\r\n        if (swipeRefreshLayout.isRefreshing()) {\r\n            feedProgressBar.setVisibility(View.VISIBLE);\r\n        }\r\n\r\n        updateFeedObservable()\r\n                .subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribeWith(new SingleObserver<Listing<Submission>>() {\r\n\r\n                    @Override public void onSubscribe(Disposable d) {\r\n                        d.dispose();\r\n                    }\r\n\r\n                    @Override public void onSuccess(Listing<Submission> submissions) {\r\n                        Log.d(TAG, \"onSuccess: WORKS\"); //Nope\r\n                        feedProgressBar.setVisibility(View.INVISIBLE);\r\n                        swipeRefreshLayout.setRefreshing(false);\r\n                        isLoadingNextSubmissions = false;\r\n\r\n                        FeedAdapter feedAdapter = (FeedAdapter) recyclerView.getAdapter();\r\n                        feedAdapter.updateItems(submissions);\r\n                    }\r\n\r\n                    @Override public void onError(Throwable e) {\r\n                        Log.e(TAG, e.getMessage());\r\n                    }\r\n                });\r\n\r\n    }\r\n\r\n    public Single<Listing<Submission>> updateFeedObservable() {\r\n        return Single.defer(() -> Single.fromCallable(() -> {\r\n            Log.d(TAG, \"updateFeedObservable: WORKS\"); //Nope\r\n            return paginator.next();\r\n        }));\r\n    }\r\n```\r\n\r\nWhat exactly is the problem?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5880/comments",
    "author": "mpivchev",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-03-03T16:24:51Z",
        "body": "This issue list is for plain RxJava related problems and questions. Please ask this type of Android related question on StackOverflow."
      }
    ]
  },
  {
    "number": 5869,
    "title": "No successful subscription when running `using` and `retry` together",
    "created_at": "2018-02-27T08:43:11Z",
    "closed_at": "2018-02-27T09:29:07Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5869",
    "body": "Version: 'io.reactivex.rxjava2:rxjava:2.1.10'\r\n\r\nNo successful subscription when running `using` and `retry` together, without `retry` or with other `Single` everything is fine.\r\n\r\n```        \r\nSingle.just(\"input\").flatMap(val ->\r\n                Single.using(\r\n                        () -> {\r\n                            System.out.println(\"create\");\r\n                            return \"\";\r\n                            },\r\n                        call -> singleSubscriber -> {\r\n                            System.out.println(\"sub\");\r\n                            singleSubscriber.onSuccess(val);\r\n                            System.out.println(\"sub done\");\r\n                            },\r\n                        call -> {\r\n                            System.out.println(\"close\");\r\n                        }\r\n                        )\r\n                .retry((count, error) -> {\r\n                    System.out.println(\"retry\");\r\n                    return true;\r\n                })\r\n        )\r\n                .subscribe(val -> System.out.println(\"output \" + val));\r\n```\r\nOutput:\r\n```\r\ncreate\r\nsub\r\nclose\r\nsub done\r\n```\r\n\r\nExpected:\r\n```\r\ncreate\r\nsub\r\nclose\r\noutput input\r\nsub done\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5869/comments",
    "author": "dmitart",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-02-27T09:16:51Z",
        "body": "You should not create a `SingleSource` via lambda as people often forget to follow the protocol: `onSubscribe (onSuccess | onError)?`. Use `Single.create()` instead:\r\n\r\n```java\r\nSingle.create(singleSubscriber -> {\r\n    System.out.println(\"sub\");\r\n    singleSubscriber.onSuccess(val);\r\n    System.out.println(\"sub done\");\r\n})\r\n```\r\n\r\nwith which now prints:\r\n\r\n```\r\ncreate\r\nsub\r\nclose\r\noutput input\r\nsub done\r\n```\r\n\r\nWhat happens is that `retry` converts to `Flowable` internally to reuse that operator, which requires downstream requests. However, since `onSubscribe` was never called, the request channel is never established below that operator and the single element is hold up indefinitely."
      },
      {
        "user": "dmitart",
        "created_at": "2018-02-27T09:29:07Z",
        "body": "This solves my issue, thank you. I was not using `using` a lot before and didn't knew about this convention."
      }
    ]
  },
  {
    "number": 5855,
    "title": "Why zip(range(0, 1mi)), range(0, 100)) never finishes, when inverting the order does?",
    "created_at": "2018-02-15T23:19:53Z",
    "closed_at": "2018-02-15T23:33:47Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5855",
    "body": "Version: \"2.1.9\"\r\n\r\nI recently ran into a problem where the order of my parameters to the Zip function matters, and now I'm trying to understand why.\r\n\r\nHere's a simplified test:\r\n\r\n```kotlin\r\nval bigRange = Observable.range(0, 1_000_000_000)\r\nval shortRange = Observable.range(0, 100)\r\n\r\nval ts = Observable.zip(shortRange, bigRange, BiFunction<Int, Int, Int> { _, b -> b }).test()\r\n// val ts = Observable.zip(bigRange, shortRange, BiFunction<Int, Int, Int> { a, _ -> a }).test()\r\n\r\nts.awaitTerminalEvent(10, TimeUnit.SECONDS)\r\n```\r\n\r\nIn the test above, the stream completes as expected; with 100 items. However, if I uncomment the other `ts`, then the app hangs.\r\n\r\nFrom the docs it makes me believe that if any of the streams completes, then the whole \"zip\" completes, but this is maybe not the case? Is it something to do with the Observable being a \"pusher\" and not a \"puller\"?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5855/comments",
    "author": "AllanHasegawa",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-02-15T23:24:17Z",
        "body": "`Observable` doesn't have backpressure and `range` is synchronous and will fill up the internal queue of `zip` before giving the chance to the other source. If the short one is first, that happens quickly. If the longer one is first, that may take a lot of time and memory. Try with `Flowable` and you should see both cases complete within reasonable time.\r\n\r\nRxJava is synchronous by default and you have to introduce asynchrony explicitly."
      },
      {
        "user": "AllanHasegawa",
        "created_at": "2018-02-15T23:33:47Z",
        "body": "Awesome explanation; very clear.\r\n\r\nMade a few experiments with Flowable and others \"async\" operators (intervalRange) and I think I understand it now :)\r\n\r\nThank you very much."
      }
    ]
  },
  {
    "number": 5829,
    "title": "Improve takeUntil method",
    "created_at": "2018-01-31T09:26:46Z",
    "closed_at": "2018-01-31T09:53:33Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5829",
    "body": "rxJava version : 2.x\r\n\r\nBoth 'takeUntil' and 'takeWhile' functions have no inclusive functions.\r\nSo It is impossible to make the following code.\r\n\r\n```java\r\nObservable.just(1,2,3,4,-1,1,2,3,4)\r\n.takeUntil(value -> value == -1)\r\n// I wish : 1, 2, 3, 4, -1\r\n// actually : 1, 2, 3, 4\r\n```\r\n\r\nor in real world...\r\n```java\r\nObservable.merge(\r\n    cacheRequest,\r\n    networkRequest\r\n)\r\n.takeUntilInclusive(data -> data.dataType == FROM_NETWORK);\r\n// Load mem/network data. But when it comes to network data, it stops.\r\n```\r\n\r\nhow about create blow functions?\r\n\r\n`takeWhileInclusive`\r\n`takeUntilInclusive`\r\n`skipWhileInclusive`\r\n`skipUntilInclusive`",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5829/comments",
    "author": "JSpiner",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-01-31T09:34:26Z",
        "body": "Have you actually tried your code?\r\n\r\n```java\r\nObservable.just(1,2,3,4,-1,1,2,3,4)\r\n        .takeUntil(value -> value == -1)\r\n        .subscribe(System.out::println);\r\n```\r\n\r\nprints:\r\n\r\n```\r\n1\r\n2\r\n3\r\n4\r\n-1\r\n```\r\n\r\nI'm not sure what you tried to accomplish originally, but `merge()` looks suspicious as it can interleave your data unexpectedly. Try `concat()`."
      },
      {
        "user": "JSpiner",
        "created_at": "2018-01-31T09:53:33Z",
        "body": "Opps.....\r\nIt looks not tested enough. I was so ashame...\r\nI'll close it.\r\n\r\nThanks!"
      }
    ]
  },
  {
    "number": 5814,
    "title": "2.x: doOnTerminate addition for Single",
    "created_at": "2018-01-18T09:41:26Z",
    "closed_at": "2018-01-18T09:51:15Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5814",
    "body": "I'm using RxJava 2.1.8. I often use the `doOnTerminate` operator for Single and Completable to handle certain events but I find there's no equivalent for Single. Is that intended and, if not, can it be added?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5814/comments",
    "author": "ValCanBuild",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-01-18T09:49:22Z",
        "body": "There is no particular reason and so far many got by without it. You can use `doOnEvent`."
      },
      {
        "user": "ValCanBuild",
        "created_at": "2018-01-18T09:51:15Z",
        "body": "I just read the docs for `doOnEvent` and it does seem like what i need. Thanks!"
      }
    ]
  },
  {
    "number": 5812,
    "title": "2.x: Surprising `startWith` scheduling behaviour",
    "created_at": "2018-01-17T09:13:58Z",
    "closed_at": "2018-01-17T09:40:19Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5812",
    "body": "Android and RxJava 2.1.8:\r\n\r\nI ran into a surprising behaviour of `startWith` that I'd like to verify. I've boiled it down to a simple example:\r\n```\r\nObservable.just(Unit)\r\n                .observeOn(Schedulers.io())\r\n                .startWith(Unit)\r\n                .switchMap {\r\n                    Observable.create<Unit> { emitter ->\r\n                        Thread.sleep(5000)\r\n                        emitter.onNext(Unit)\r\n                        emitter.onComplete()\r\n                    }\r\n                }\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe()\r\n```\r\n\r\nIn the above example, execution of the observable inside `switchMap` happens on the main scheduler and blocks my UI. \r\n\r\nI would expect that it will happen on the `io` scheduler and it does indeed, as soon as I remove `startWith`. \r\n\r\nI realise I can just add another `observeOn` after `startWith` but it's puzzling. We're already on the `io` scheduler when the `startWith` gets hit, so why would it switch threads?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5812/comments",
    "author": "Rosomack",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-01-17T09:21:54Z",
        "body": "`startWith` subscribes to its argument (constants are turned into Observable.just()) on the current thread and `observeOn` is above it, thus can't have any effect of it. Let me rewrite your code to make it more apparent:\r\n\r\n```java\r\nObservable.concat(\r\n    Observable.just(Unit),\r\n    Observable.just(Unit).observeOn(Schedulers.io())\r\n)\r\n.switchMap {\r\n       Observable.create<Unit> { emitter ->\r\n                Thread.sleep(5000)\r\n                emitter.onNext(Unit)\r\n                emitter.onComplete()\r\n       }\r\n }\r\n .observeOn(AndroidSchedulers.mainThread())\r\n .subscribe()\r\n```\r\n\r\nAs the subscription travels up, the thread hasn't changed so the first `just` will emit `Unit` on the caller thread which then goes into the blocking `switchMap`. \r\n\r\nYou can apply `subscribeOn` instead and the `switchMap` will trigger on the background thread:\r\n\r\n```java\r\nObservable.just(Unit)\r\n                .startWith(Unit)\r\n                .switchMap {\r\n                    Observable.create<Unit> { emitter ->\r\n                        Thread.sleep(5000)\r\n                        emitter.onNext(Unit)\r\n                        emitter.onComplete()\r\n                    }\r\n                }\r\n                .subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe()\r\n```\r\n\r\nor move the `observeOn` below the `startWith`:\r\n\r\n```java\r\nObservable.just(Unit)\r\n                .startWith(Unit)\r\n                .observeOn(Schedulers.io())\r\n                .switchMap {\r\n                    Observable.create<Unit> { emitter ->\r\n                        Thread.sleep(5000)\r\n                        emitter.onNext(Unit)\r\n                        emitter.onComplete()\r\n                    }\r\n                }\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe()\r\n```"
      },
      {
        "user": "Rosomack",
        "created_at": "2018-01-17T09:32:29Z",
        "body": "Ordinarily I would use `subscribeOn`, but sadly I'm using RxBinding which requires the subscription to happen on the main thread.\r\n\r\nThanks for your complete explanation! It makes sense."
      }
    ]
  },
  {
    "number": 5807,
    "title": " java.lang.ClassNotFoundException: io.reactivex.ObservableOnSubscribe",
    "created_at": "2018-01-15T11:46:49Z",
    "closed_at": "2018-01-15T12:10:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5807",
    "body": "  - [x] Please include the library version number, including the minor and patch version, in the issue text. In addition, if you'd include the major version in the title (such as `2.x`) that would be great.\r\n\r\nio.reactivex.rxjava2:rxjava:2.1.0\r\n\r\nAndroidStudio3.0.1  gradle 3.0.1 \r\n----------code-------\r\n```java\r\nimport com.android.ddmlib.Log;\r\n\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.ObservableEmitter;\r\nimport io.reactivex.ObservableOnSubscribe;\r\nimport io.reactivex.Observer;\r\nimport io.reactivex.disposables.Disposable;\r\n\r\n/**\r\n * Created by zry on 2018/1/14.\r\n */\r\n\r\npublic class HelloMyWorld {\r\n    private static final String TAG = \"HelloMyWorld\";\r\n\r\n    public static void main(String[] args) {\r\n        Observable.create(new ObservableOnSubscribe<Integer>() {\r\n            @Override\r\n            public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\r\n                emitter.onNext(1);\r\n                emitter.onNext(2);\r\n                emitter.onNext(3);\r\n                emitter.onComplete();\r\n            }\r\n        }).subscribe(new Observer<Integer>() {\r\n            @Override\r\n            public void onSubscribe(Disposable d) {\r\n                Log.d(TAG, \"subscribe\");\r\n            }\r\n\r\n            @Override\r\n            public void onNext(Integer value) {\r\n                Log.d(TAG, \"\" + value);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable e) {\r\n                Log.d(TAG, \"error\");\r\n            }\r\n\r\n            @Override\r\n            public void onComplete() {\r\n                Log.d(TAG, \"complete\");\r\n            }\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n-------------error----------------\r\n\r\n```\r\n\"/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/bin/java\" \"-javaagent:/Applications/Android Studio.app/Contents/lib/idea_rt.jar=50597:/Applications/Android Studio.app/Contents/bin\" -Dfile.encoding=UTF-8 -classpath \"/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/charsets.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/ext/localedata.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/ext/sunec.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/jce.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/jsse.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/management-agent.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/resources.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/rt.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/lib/dt.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/lib/jconsole.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/lib/sa-jdi.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/lib/tools.jar:/Users/zhuruyi/dffc/tvmobile/javademo/build/classes/java/main\" com.rxjava2demo.HelloMyWorld\r\nError: A JNI error has occurred, please check your installation and try again\r\nException in thread \"main\" java.lang.NoClassDefFoundError: io/reactivex/ObservableOnSubscribe\r\n\tat java.lang.Class.getDeclaredMethods0(Native Method)\r\n\tat java.lang.Class.privateGetDeclaredMethods(Class.java:2701)\r\n\tat java.lang.Class.privateGetMethodRecursive(Class.java:3048)\r\n\tat java.lang.Class.getMethod0(Class.java:3018)\r\n\tat java.lang.Class.getMethod(Class.java:1784)\r\n\tat sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)\r\n\tat sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)\r\nCaused by: java.lang.ClassNotFoundException: io.reactivex.ObservableOnSubscribe\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\r\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\r\n\t... 7 more\r\n\r\nProcess finished with exit code 1\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5807/comments",
    "author": "zhuruyi2013",
    "comments": [
      {
        "user": "zhuruyi2013",
        "created_at": "2018-01-15T12:01:34Z",
        "body": "-----------code---------------\r\n\r\n```java\r\nObservable.just(1).subscribe(new Consumer<Integer>() {\r\n            @Override\r\n            public void accept(Integer integer) throws Exception {\r\n                Log.d(TAG, \"i=\" + integer);\r\n            }\r\n        });\r\n```\r\n\r\n----------error------------------\r\n\r\n```\r\nException in thread \"main\" java.lang.NoClassDefFoundError: io/reactivex/functions/Consumer\r\n\tat java.lang.Class.getDeclaredMethods0(Native Method)\r\n\tat java.lang.Class.privateGetDeclaredMethods(Class.java:2701)\r\n\tat java.lang.Class.privateGetMethodRecursive(Class.java:3048)\r\n\tat java.lang.Class.getMethod0(Class.java:3018)\r\n\tat java.lang.Class.getMethod(Class.java:1784)\r\n\tat sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)\r\n\tat sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)\r\nCaused by: java.lang.ClassNotFoundException: io.reactivex.functions.Consumer\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\r\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\r\n\t... 7 more\r\n```\r\n\r\ni think the detail error does't mean the real error, maybe gradle3.0 can't support rxjava2.0.\r\ni create a java module under a androidproject,the build.gradle content as below:\r\n\r\n```\r\napply plugin: 'java'\r\n\r\ndependencies {\r\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\r\n    implementation 'com.android.tools.lint:lint-api:24.5.0'\r\n    implementation 'com.android.tools.lint:lint-checks:24.5.0'\r\n\r\n    implementation 'io.reactivex.rxjava2:rxjava:2.1.0'\r\n    implementation 'org.reactivestreams:reactive-streams:1.0.2'\r\n    implementation 'com.android.support.constraint:constraint-layout:1.0.2'\r\n//    implementation 'org.reactivestreams:reactive-streams-tck:1.0.2'\r\n\r\n//    implementation 'io.reactivex.rxjava2:rxandroid:2.0.1'\r\n}\r\n\r\njar {\r\n    manifest {\r\n        attributes(\"Lint-Registry\": \"com.dt.lint.MTIssueRegistry\")\r\n    }\r\n}\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-01-15T12:10:28Z",
        "body": "This is not an issue with RxJava but with the IDE/project setup you have. You may have to do a clean install of Android Studio and make sure you are using the latest Gradle the IDE supports. Also check the project settings to see if the imported libraries are properly marked as compile-time dependency by the IDE as sometimes they appear as runtime or test dependencies which then fail to run properly."
      }
    ]
  },
  {
    "number": 5800,
    "title": "2.x Flowable test with null values are ignored",
    "created_at": "2018-01-09T16:23:52Z",
    "closed_at": "2018-01-09T16:49:29Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5800",
    "body": "I'm using the version **2.1.8** from the master branch of this repo\r\n\r\nI forked the project and executed the tests. When finished, I see that multiple test are ignored like the `mergeWithNullValues()` from the `FlowableMergeTest` class. This test contains:\r\n\r\n```java\r\nTestSubscriber<String> ts = new TestSubscriber<String>();\r\nFlowable.merge(Flowable.just(null, \"one\"), Flowable.just(\"two\", null)).subscribe(ts);\r\nts.assertTerminated();\r\nts.assertNoErrors();\r\nts.assertValues(null, \"one\", \"two\", null);\r\n```\r\nObviously this test shouldn't never be pass, but, why is ignored? If we expect for this test a `NullPointerException`, why not make the test to expect this result? Like:\r\n\r\n```java\r\n@Test(expected = NullPointerException.class)\r\npublic void mergeWithNullValues() {\r\n    TestSubscriber<String> ts = new TestSubscriber<String>();\r\n    Flowable.merge(Flowable.just(null, \"one\"), Flowable.just(\"two\", null)).subscribe(ts);\r\n    ts.assertTerminated();\r\n    ts.assertNoErrors();\r\n    ts.assertValues(null, \"one\", \"two\", null);\r\n}\r\n```\r\nMultiple tests with similar behavior exists.\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5800/comments",
    "author": "fooock",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-01-09T16:49:29Z",
        "body": "These are remnant from the v1 tests and during the migration, I used custom tools to see which test methods have to be ported. Some of them are now invalid but serve a new purpose. They make sure the Travis CI output is changing every couple of seconds due to reporting ignored tests which prevents the CI from cancelling the build when it doesn't detect output from it for 10 minutes (the tests run over 11 minutes on CI). \r\n\r\nThe `null` checks themselves are verified elsewhere and don't really need the whole old test as it will throw as soon as `Flowable.just(null, \"one\")` executes."
      }
    ]
  },
  {
    "number": 5787,
    "title": "No option for ConcatMap with skip error",
    "created_at": "2018-01-05T09:53:18Z",
    "closed_at": "2018-01-05T10:10:54Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5787",
    "body": "Version : RxJava1\r\n\r\nConsider this example:\r\nI have a file downloading in sequence. If one download fails, it should move to next.\r\nPsudo code:\r\n```\r\nObservable.from(urls)\r\n .concatMap(url -> downloadObservable(url)) \r\n```\r\nThere is no option for moving to next url if the download fails. \r\nThere is no way to skip with `onErrorResumeNext()` as I just want to move to next url.\r\n  \r\n  ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5787/comments",
    "author": "kagile",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-01-05T10:10:54Z",
        "body": "Please make sure you have the latest 1.x version and check the available operators again."
      },
      {
        "user": "kagile",
        "created_at": "2018-01-05T10:18:27Z",
        "body": "@akarnokd I have latest version 1.x. No offense, but the docs are like explaining rocket science. Can you just hint the operator?"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-01-05T10:34:58Z",
        "body": "What's in the suggestion list when you start typing `.concatMap` in your IDE?"
      },
      {
        "user": "kagile",
        "created_at": "2018-01-05T10:53:43Z",
        "body": "`concatMapEager `and `concatMapDelayError `are there. I think `concatMapDelayError` would work. But that isn't mentioned clearly in docs that it will switch next. Also, I need the count of failed items, can I use `doOnError `for that after `concatMapDelayError `?"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-01-05T11:11:40Z",
        "body": "> But that isn't mentioned clearly in docs that it will switch next.\r\n\r\nThat would be logically contradictory, no? Why have a `delayError` operator when it just stops after the first error. Also the JavaDoc is pretty clear IMO:\r\n\r\n\"Maps each of the items into an Observable, **subscribes to them one after the other**, one at a time and emits their values in order while delaying any error from either this or any of the inner Observables **till all of them terminate**.\"\r\n\r\n> Also, I need the count of failed items, can I use doOnError for that after concatMapDelayError?\r\n\r\nNo. There is only at most one call to `onError` after `concatMapDelayError` which in this case could be a single arbitrary `Throwable` or a `CompositeException` for more than one failing source."
      },
      {
        "user": "kagile",
        "created_at": "2018-01-05T11:32:19Z",
        "body": "But I don't want to stop after first error. I want to move to next url in concatMap."
      },
      {
        "user": "mattid89",
        "created_at": "2019-01-09T17:20:42Z",
        "body": "I'm facing the same problem. I have handled the error correctly, but I need to continue with the next observable."
      },
      {
        "user": "Sisekelo",
        "created_at": "2021-05-10T11:09:24Z",
        "body": "@mattid89 how did you solve this?"
      }
    ]
  },
  {
    "number": 5768,
    "title": "java.lang.IllegalStateException:    at rx.internal.schedulers.ScheduledAction.run ",
    "created_at": "2017-12-18T13:27:46Z",
    "closed_at": "2018-01-02T15:22:31Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5768",
    "body": "```\r\njava.lang.IllegalStateException: \r\n  at rx.internal.schedulers.ScheduledAction.run (ScheduledAction.java:62)\r\n  at android.os.Handler.handleCallback (Handler.java:815)\r\n  at android.os.Handler.dispatchMessage (Handler.java:104)\r\n  at android.os.Looper.loop (Looper.java:207)\r\n  at android.app.ActivityThread.main (ActivityThread.java:5765)\r\n  at java.lang.reflect.Method.invoke (Native Method)\r\n  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:789)\r\n  at com.android.internal.os.ZygoteInit.main (ZygoteInit.java:679)\r\nCaused by: rx.exceptions.OnErrorFailedException: \r\n  at rx.observers.SafeSubscriber._onError (SafeSubscriber.java:192)\r\n  at rx.observers.SafeSubscriber.onError (SafeSubscriber.java:120)\r\n  at rx.exceptions.Exceptions.throwOrReport (Exceptions.java:200)\r\n  at rx.observers.SafeSubscriber.onNext (SafeSubscriber.java:144)\r\n  at rx.internal.operators.OperatorDoOnEach$1.onNext (OperatorDoOnEach.java:85)\r\n  at rx.observers.Subscribers$5.onNext (Subscribers.java:229)\r\n  at rx.internal.producers.SingleDelayedProducer.emit (SingleDelayedProducer.java:102)\r\n  at rx.internal.producers.SingleDelayedProducer.setValue (SingleDelayedProducer.java:85)\r\n  at rx.internal.operators.OperatorToObservableList$1.onCompleted (OperatorToObservableList.java:93)\r\n  at rx.internal.operators.OperatorMap$1.onCompleted (OperatorMap.java:43)\r\n  at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop (OperatorMerge.java:617)\r\n  at rx.internal.operators.OperatorMerge$MergeSubscriber.emit (OperatorMerge.java:529)\r\n  at rx.internal.operators.OperatorMerge$MergeSubscriber.onCompleted (OperatorMerge.java:258)\r\n  at rx.internal.operators.OperatorMap$1.onCompleted (OperatorMap.java:43)\r\n  at rx.internal.operators.OperatorMap$1.onCompleted (OperatorMap.java:43)\r\n  at rx.internal.operators.OperatorDoOnEach$1.onCompleted (OperatorDoOnEach.java:53)\r\n  at rx.internal.operators.OnSubscribeRedo$4$1.onCompleted (OnSubscribeRedo.java:326)\r\n  at rx.internal.operators.OperatorDematerialize$1.onCompleted (OperatorDematerialize.java:80)\r\n  at rx.internal.operators.OperatorMap$1.onCompleted (OperatorMap.java:43)\r\n  at rx.internal.operators.OnSubscribeRedo$3$1.onNext (OnSubscribeRedo.java:303)\r\n  at rx.internal.operators.OnSubscribeRedo$3$1.onNext (OnSubscribeRedo.java:289)\r\n  at rx.internal.operators.NotificationLite.accept (NotificationLite.java:150)\r\n  at rx.subjects.SubjectSubscriptionManager$SubjectObserver.emitNext (SubjectSubscriptionManager.java:253)\r\n  at rx.subjects.BehaviorSubject.onNext (BehaviorSubject.java:160)\r\n  at rx.internal.operators.OnSubscribeRedo$2$1.onCompleted (OnSubscribeRedo.java:233)\r\n  at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated (OperatorObserveOn.java:262)\r\n  at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call (OperatorObserveOn.java:199)\r\n  at rx.internal.schedulers.ScheduledAction.run (ScheduledAction.java:55)\r\n```\r\n\r\n\r\n\r\n\r\nHi please help me to solve this issue . I almost tried and included try catch exception in almost all the \r\nonError(Throwable throwable) , which handles any values inside them . \r\n\r\nStill the crash keeps on coming . I am updating my library versions below please check .\r\n\r\n\"io.reactivex:rxjava:1.1.1\" \r\n\"io.reactivex:rxandroid:1.1.0\"\r\n\"com.squareup.retrofit2:retrofit:2.0.2\" . \r\n\r\n\r\nPlease help . ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5768/comments",
    "author": "mancyzbooni",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-12-18T13:34:48Z",
        "body": "You are using quite outdated RxJava. Please upgrade to 1.3.4 first and retry. If it still fails, post the new stacktrace which should contain way more information than that old RxJava version."
      }
    ]
  },
  {
    "number": 5762,
    "title": "Use descriptive names in interfaces",
    "created_at": "2017-12-13T16:49:40Z",
    "closed_at": "2017-12-19T17:36:55Z",
    "labels": [
      "Question",
      "PR welcome",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5762",
    "body": "Every time I implement one of these interfaces I rename 'e' to 'emitter'. This is repetitive and can be avoided with renaming the param in the interface.\r\n\r\n```java\r\npublic interface SingleOnSubscribe<T> {\r\n\r\n    /**\r\n     * Called for each SingleObserver that subscribes.\r\n     * @param e the safe emitter instance, never null\r\n     * @throws Exception on error\r\n     */\r\n    void subscribe(@NonNull SingleEmitter<T> e) throws Exception;\r\n}\r\n```\r\n\r\nThis would be in line with naming in other interfaces, such as:\r\n\r\n```java\r\npublic interface CompletableConverter<R> {\r\n\r\n    /**\r\n     * Applies a function to the upstream Completable and returns a converted value of type {@code R}.\r\n     *\r\n     * @param upstream the upstream Completable instance\r\n     * @return the converted value\r\n     */\r\n    @NonNull\r\n    R apply(@NonNull Completable upstream);\r\n}\r\n```\r\n\r\nI am happy to do it myself, if you approve.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5762/comments",
    "author": "EGecius",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-12-13T16:55:56Z",
        "body": "Why don't you use lambdas where you can specify the name of the parameter?\r\n\r\n```java\r\nSingle.create(emitter -> { emitter.onSuccess(1); });\r\n```\r\n\r\nBesides, I'm not sure renaming the parameter wouldn't cause trouble with JVM languages where such change breaks existing code."
      },
      {
        "user": "vanniktech",
        "created_at": "2017-12-13T17:03:32Z",
        "body": "Not for kotlin. Named arguments are only supported from Kotlin compiled code where the Metadata annotation is present. "
      },
      {
        "user": "EGecius",
        "created_at": "2017-12-13T17:05:10Z",
        "body": "Android Studio autogenerates the following with lambdas:\r\nSingle.create(e -> )\r\n\r\n... which I repetitively rename to Single.create(emitter -> )"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-12-13T17:23:53Z",
        "body": "I think not many languages have upgraded their adapters to v2 yet (or will ever) so let's change it and see who's complaining."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-12-19T17:36:55Z",
        "body": "Closing via #5766"
      }
    ]
  },
  {
    "number": 5754,
    "title": "autoconnect() never reconnects to a completed source",
    "created_at": "2017-12-06T08:51:01Z",
    "closed_at": "2017-12-15T10:18:59Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5754",
    "body": "**RxJava 1.3.3**\r\n\r\nI'm not sure if what I've found is a bug, edge case or works as designed... Let's roll.\r\n\r\n## Assumptions\r\n- Observable, which had completed can be subscribed again and act like it was fresh (at least most of them can (just, custom observables, etc)\r\n- I use the same instance of the observable\r\n\r\n## Source observable\r\nEmitts `1` and never completes.\r\n\r\n```\r\nval source = Observable.just(1).mergeWith(Observable.never())\r\n```\r\n\r\n## Working example\r\n\r\n1. Subscribe to source as soon as we have at least one subscriber\r\n1. Source is completed as soon as releaseTrigger emits a value\r\n1. Next subscription (`thirdSubscriber`) to the same observable (regardless it already completed once) received `42`\r\n\r\n```\r\nval releaseTrigger = PublishSubject.create<Boolean>()\r\n        val source = Observable.just(42).mergeWith(Observable.never())\r\n        val observable = source\r\n                .takeUntil(releaseTrigger)\r\n                .publish()\r\n                .refCount()\r\n\r\n        val subscriber = observable.test()\r\n        subscriber.assertValue(42)\r\n\r\n        val secondSubscriber = observable.test()\r\n        secondSubscriber.assertNoValues()\r\n        secondSubscriber.assertNoTerminalEvent()\r\n\r\n        releaseTrigger.onNext(true)\r\n\r\n        val thirdSubscriber = observable.test()\r\n        thirdSubscriber.assertValue(42)\r\n```\r\n\r\n## Not working example\r\n\r\n1. Subscribe to source as soon as we have at least one subscriber (due to `autoConnect(1)`)\r\n1. Source is completed as soon as releaseTrigger emits a value\r\n1. Next subscription (`thirdSubscriber`) to the same observable (regardless it already completed once) never receives any value, `autoConnect` won't establish the connection.\r\n\r\n```\r\nval releaseTrigger = PublishSubject.create<Boolean>()\r\n        val source = Observable.just(42).mergeWith(Observable.never())\r\n        val observable = source\r\n                .takeUntil(releaseTrigger)\r\n                .publish()\r\n                .autoconnect()\r\n\r\n        val subscriber = observable.test()\r\n        subscriber.assertValue(42)\r\n\r\n        val secondSubscriber = observable.test()\r\n        secondSubscriber.assertNoValues()\r\n        secondSubscriber.assertNoTerminalEvent()\r\n\r\n        releaseTrigger.onNext(true)\r\n\r\n        val thirdSubscriber = observable.test()\r\n        thirdSubscriber.assertValue(42)\r\n```\r\n\r\n## Analysis\r\n\r\nThis is due to `autoConnect`'s implementation. `OnSubscribeAutoConnect` maintains `numberOfSubscribers` value, which is never decremented when subscribers are released therefore block\r\n\r\n```\r\nif (this.incrementAndGet() == numberOfSubscribers) {\r\n    source.connect(connection);\r\n}\r\n```\r\nis never executed.\r\n\r\n## Questions and ideas\r\n\r\n- Condiction could be changed to `this.incrementAndGet() >= numberOfSubscribers`. It seems to be pretty safe to call `connect()` on a `ConnectableObservable` which is already connected.\r\n- The counter could be decremented when child subscriber is disposed.\r\n- Some other?\r\n- No, go away, this is intended (please tell me why)",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5754/comments",
    "author": "uKL",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-12-06T11:07:21Z",
        "body": "The behavior is by design. `autoConnect` is for connecting once, `refCount` for connecting on a `0->1` transition."
      },
      {
        "user": "uKL",
        "created_at": "2017-12-06T11:37:57Z",
        "body": "It looks a little bit inconsistent with how it works. Do you think that it shouldn't be documented?\r\n\r\nSide question, is there any way to introduce required behavior (with built-in operators) or should I keep with my own operator?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-12-06T11:46:45Z",
        "body": "I don't understand you. If `refCount` does the expected behavior, use `refCount`.\r\n\r\n> Do you think that it shouldn't be documented?\r\n\r\nPR welcome."
      },
      {
        "user": "uKL",
        "created_at": "2017-12-08T13:29:29Z",
        "body": "`refCount` does not do the job because it unsubscribes when there are no subscribers left.\r\n\r\nMy expected result is to:\r\n1. Connect when the first subscriber subscribes\r\n1. Stay subscribed if all subscribers were unsubscribed\r\n1. If the source is completed and some other subscriber is interested reconnect to source."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-12-08T13:39:58Z",
        "body": "This behavior is not provided by RxJava. You have to write your own operator for it."
      }
    ]
  },
  {
    "number": 5744,
    "title": "Flowable GroupBy operator never completes",
    "created_at": "2017-11-27T10:16:43Z",
    "closed_at": "2017-12-15T10:21:16Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5744",
    "body": "On RxJava version 2.1.6\r\nJRE Oracle 1.8.111\r\nThis sample dummy code never completes.\r\n\r\n`Flowable.range(1, 132).groupBy(z -> z % 3).subscribe(z -> {}, err -> {}, () -> System.out.println(\"completed\"));`\r\n\r\nNumbers 132 and divisor 3 are essential, although issue is reproducible with other combinations like f.e. 139 and 10.\r\n\r\nConversely, with Observable everything works fine\r\n`Observable.range(1, 132)\r\n                .groupBy(z -> z % 3)\r\n                .subscribe(z -> {}, err -> {}, () -> System.out.println(\"completed\"));`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5744/comments",
    "author": "daniil-dubin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-11-27T10:22:55Z",
        "body": "You have to consume the `GroupedFlowable` groups in order to have more items delivered due to backpressure coordination by `groupBy`."
      },
      {
        "user": "daniil-dubin",
        "created_at": "2017-11-27T11:03:01Z",
        "body": "Thanks for your quick response.\r\nWith addition of consumption of GroupedFlowable this now completes fine:\r\n```java\r\n            Flowable.range(1, 394)\r\n                    .groupBy(z -> z % 3)\r\n                    .flatMap(groups -> groups)\r\n                    .blockingSubscribe();\r\n```\r\nBut simply adding useless but quite legitimate `.buffer(2).flatMap(batch -> Flowable.fromIterable(batch))`\r\nstill causes hang.\r\n```java\r\n            Flowable.range(1, 394)\r\n                    .groupBy(z -> z % 3)\r\n                    .buffer(2).flatMap(batch -> Flowable.fromIterable(batch))\r\n                    .flatMap(groups -> groups)\r\n                    .blockingSubscribe();\r\n```\r\nThat bizarre code while looking useless is a simplified version of one that processes events in batches in real application."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-11-27T11:31:39Z",
        "body": "Adding `buffer` after `groupBy` prevents the immediate consumption of the groups by `flatMap`."
      },
      {
        "user": "daniil-dubin",
        "created_at": "2017-11-27T12:45:36Z",
        "body": "So should it be considered like a bug?\r\nFor me it's obviously a problem when via quite legitimate usage of API (I believe that in the code above there was nothing prohibited done, correct me if I am wrong) it's possible to break the system under some circumstances. There should be at least some red flags in documentation discouraging misuse. In my particular case everything has been working fine for weeks until the number of emitted buffered events reached some magic value. That's upsetting.\r\nIf it's a bug should I dive into the rx-java internals to try to somehow fix it?\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-11-27T13:22:47Z",
        "body": "> So should it be considered like a bug?\r\n\r\nIt is a property of how the fan-out logic interacts with backpressure where the number of groups can't be anticipated by the operator. An emission from upstream could go into an existing group or create a new group with that single initial value. Since group creation has to honor backpressure any delay to bringing that group to a consumer may result in the sequence to hang.\r\n\r\n> I believe that in the code above there was nothing prohibited done, correct me if I am wrong\r\n\r\nWhy would you buffer groups in the first place?\r\n\r\n> There should be at least some red flags in documentation discouraging misuse.\r\n\r\nYou can formulate this warning and add them to the `Flowable.groupBy` overloads' JavaDoc via PR if you want.\r\n\r\n> If it's a bug should I dive into the rx-java internals to try to somehow fix it?\r\n\r\nThis property of `groupBy` has been there for a long time now and nobody so far could come up with a reasonable solution that also doesn't break the Reactive-Streams spec. You can have a stab at it if you want though.\r\n\r\nOne option would be to have `groupBy` use the on-backpressure-error policy which then will prompt the developer about the need to consume groups. However, this is a drastic behavior change and as such can only happen in a subsequent major release such as 3.x."
      }
    ]
  },
  {
    "number": 5730,
    "title": "How to execute a flowable dependent from another?",
    "created_at": "2017-11-18T15:29:43Z",
    "closed_at": "2017-11-22T14:32:59Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5730",
    "body": "I want to chain two flowables, when the first one finishes to collect data from the network its result (an array list) must be passed to the second flowable.\r\nThe flowables update the UI as described in the scenario shown below, when an error occurs the execution is stopped.\r\n\r\nI hope to be more clear as possible adding all details about the expected result and the code I wrote\r\n\r\nThe scenario\r\n\r\n1. flowable-1 makes X network calls (X value depends on some condition COND)\r\n2. every network call returns a list of items (size can vary)\r\n3. the UI shows the count of items (eg. \"Retrieved 1 items\", \"Retrieved 5 items\")\r\n4. all calls are done (the condition COND is satisfied)\r\n5. all items collected now must post-processed by flowable-2\r\n6. the UI shows the progress (eg. 'item 1 of 9', 'item 2 of 9', ..., 'item 9 of 9')\r\n\r\nA possible expected output should be\r\n\r\n    Retrieved 1 item(s) |  \r\n    Retrieved 3 item(s) |- printed inside the doOnNext() 'called' by flowable-1\r\n    Retrieved 5 item(s) |  the array contains 9 items (1 + 3 + 5)\r\n\r\n    Item 1 of 9         |\r\n    ...                 |- printed inside the doOnNext() 'called' by flowable-2\r\n    Item 9 of 9         |\r\n      \r\n    Finished            | printed inside the subscribe()\r\n\r\n\r\nI've used Flowable.generate() to collected items from network calls\r\n\r\n```java\r\npublic Flowable<List<String>> fetchFromNetFlowable() {\r\n    offset = 0;\r\n    return Flowable.generate(new Consumer<Emitter<List<String>>>() {\r\n        @Override\r\n        public void accept(Emitter<List<String>> emitter) throws Exception {\r\n            List<String> subset = networkCall(offset);\r\n            boolean loadNext = subset.size() > 0;\r\n            offset += subset.size();\r\n\r\n            final ArrayList<String> validItems = new ArrayList<>();\r\n            for (String dummy : subset) {\r\n                if (conditionMet(dummy)) {\r\n                    validItems.add(dummy);\r\n                } else {\r\n                    loadNext = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!validItems.isEmpty()) {\r\n                emitter.onNext(validItems);\r\n            }\r\n            if (!loadNext) {\r\n                emitter.onComplete();\r\n            }\r\n        }\r\n    });\r\n}\r\n```\r\n\r\nThe second flowable will be used to update UI from onNext() caller\r\n\r\n```java\r\npublic Flowable secondFlowable(final Iterator<String> iterator) {\r\n    return Flowable.generate((emitter) -> {\r\n        if (iterator.hasNext()) {\r\n            // do some stuff with value\r\n            emitter.onNext(iterator.next());\r\n        } else {\r\n            emitter.onComplete();\r\n        }\r\n    });\r\n}\r\n```\r\n\r\nThen I would use both flowables but I don't understard how to make the second dependent from the first one, the `processTheListCallingTheSecondFlowable()` must be called only when `fetchFromNetFlowable()` has finished\r\n\r\n```java\r\npublic readDataAndProcess() {\r\n    total = 0;\r\n    compositeDisposable.add(postRetrieverRx.readPhotoPosts(blogName)\r\n            .subscribeOn(Schedulers.io())\r\n            .observeOn(AndroidSchedulers.mainThread())\r\n            .toObservable()\r\n            .doOnNext((tumblrPost) -> {\r\n                    total += tumblrPost.size();\r\n                    System.out.println(\"Retrieved \" + total + \" items\");\r\n            })\r\n            .flatMap((posts) -> Observable.fromIterable(posts))\r\n            .toList() // <--- now I have the single list with all items\r\n            // I don't know how to do\r\n            // processTheListCallingTheSecondFlowable() isn't an rx operator\r\n            // consider it only pseudo code\r\n            .processTheListCallingTheSecondFlowable()\r\n            .subscribe((allPosts) -> System.out.println(\"Finished\")\r\n    );\r\n}\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5730/comments",
    "author": "dafi",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-11-18T15:59:12Z",
        "body": "The `flatMap` is a typical dependent continuation operator:\r\n\r\n```java\r\n    .toList()\r\n    .flatMapPublisher(list -> processTheListViaFlowable(list))\r\n    .subscribe(/* ... */);\r\n```"
      },
      {
        "user": "dafi",
        "created_at": "2017-11-18T16:34:41Z",
        "body": "Oh my God! Is it so simple?!?!\r\nI turned around flatMapXXX for two days without notice this method.\r\n\r\nThanks a lot!!"
      }
    ]
  },
  {
    "number": 5727,
    "title": "[RxJava 2.1.0] Single with Cache cancellable behaviour",
    "created_at": "2017-11-15T17:52:41Z",
    "closed_at": "2017-11-16T10:32:56Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5727",
    "body": "Hi,\r\nI'm using `Single` in the following way,\r\n\r\n           val bleConnection = Single.create({  \r\n             emitter -> // Do some one-time bluetooth connection operation and emit ble connection\r\n             emitter.setCancellable { \r\n                    // close the ble connection as this single is unsubscribed\r\n             }\r\n           }).cache()\r\n\r\n\r\nNow I expected `setCancellable` block to run when all the subscribers are disposed. But that block gets called on `onSuccess` or `onError`. So `Single` terminates itself when either success or error happens. But I want to run some cleanup operation when all my subscribers are disposed. How would I do that with `Single`? This can be easily achieved with `Flowable` or `Observable`. But this is essentially `Single` operation (Not a stream, just an one-time connection value). So I thought `Single` is the correct operator to use in this case.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5727/comments",
    "author": "BharathMG",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-11-15T18:04:36Z",
        "body": "This is not supported by `Single`. You have to use `Observable.create()`, `share()` and `singleOrError()` to have the final type `Single`. A longer path is similar, given the current `cache()`, convert it via `toObservable()`, `share()` and then `singleOrError()` back."
      },
      {
        "user": "BharathMG",
        "created_at": "2017-11-16T05:57:13Z",
        "body": "Sure, but another problem with `cache()` is,\r\n\r\n         val single = Single.create<Boolean>({ emitter ->\r\n         emitter.setCancellable {\r\n              println(\"CANCELLED\")\r\n          }\r\n        }).cache()\r\n\r\n        val test1 = single.subscribe()\r\n        val test2 = single.subscribe()\r\n        val test3 = single.subscribe()\r\n\r\n        test1.dispose()\r\n        test2.dispose()\r\n        test3.dispose()\r\n\r\n        println(\"ALL DISPOSED\")\r\n\r\nHere CANCELLED will not be printed as desired. It waits for `Single` to emit some value before cancelling and not for disposal. Is this intended?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-11-16T08:27:00Z",
        "body": "You have to do it through `Observable` as I described:\r\n\r\n```java\r\nvar single = Observable.create(emitter -> {\r\n    emitter.setCancellable(() -> System.out.println(\"Cancelled\"));\r\n})\r\n.replay()\r\n.refCount()\r\n.singleOrError();\r\n```"
      },
      {
        "user": "BharathMG",
        "created_at": "2017-11-16T10:32:56Z",
        "body": "Thank you!"
      }
    ]
  },
  {
    "number": 5714,
    "title": "2.x: retryWhen resubscribes too much",
    "created_at": "2017-11-09T14:46:11Z",
    "closed_at": "2017-11-09T15:46:17Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5714",
    "body": "This class is a ViewModel in an Android MVVM, the corresponding View (the Activity) subscribes to `data` using a LiveData.\r\nI use retryWhen as follow (GetEvents is a Single that emit error each time for now) : \r\n```kotlin\r\ninternal class AgendaListViewModel(getEvents: GetEvents) : ViewModel() {\r\n\r\n    private val stream = getEvents.execute()\r\n            .doOnSubscribe { loading.value = true }\r\n            .doFinally { loading.value = false }\r\n            .doOnError { error.value = it.localizedMessage; Timber.d(\"error event\") }\r\n            .retryWhen { error -> error.flatMap({ retryEvent.toFlowable(BackpressureStrategy.LATEST) }) }\r\n\r\n    private val retryEvent = PublishSubject.create<Boolean>()\r\n\r\n    //region state\r\n    val loading: MutableLiveData<Boolean> = MutableLiveData<Boolean>().apply { value = false }\r\n\r\n    val error = SingleLiveEvent<String>()\r\n\r\n    val data: LiveData<List<Event>>\r\n        get() = LiveDataReactiveStreams.fromPublisher(stream.toFlowable())\r\n\r\n    val selectedEvent: SingleLiveEvent<Event> = SingleLiveEvent()\r\n    //endregion\r\n\r\n    //region Events\r\n    fun selectedEvent(event: Event) {\r\n        selectedEvent.value = event\r\n    }\r\n\r\n    fun refresh() {\r\n        if (error.value != null) {\r\n            retryEvent.onNext(true)\r\n        }\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\n- First error occurs : Logcat displays `error event` correctly. \r\n- Calling `refresh` also works : the logcat display another `error event`, proving that it resubscribed\r\n- Calling `refresh` a second time is problematic : I see two new `error events`, where I expect only one\r\n- every subsequent call double the number of logs : 4, then 8, then 16...\r\n\r\nIs it the correct behavior or am I missing something ?\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5714/comments",
    "author": "Oyashirox",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-11-09T14:53:48Z",
        "body": "You `flatMap` onto the same `Subject` which keeps getting more and more observers, thus every `onNext` on it will trigger multiple signals that `flatMap` merges into one sequence of multiple retries. You should use `zipWith` instead.\r\n\r\n```kotlin\r\n.retryWhen { error -> \r\n    error.zipWith(\r\n        retryEvent.toFlowable(BackpressureStrategy.LATEST), \r\n        { (a, b) -> b} ) \r\n}\r\n```\r\n"
      }
    ]
  },
  {
    "number": 5666,
    "title": "Use take() concat() skip() together would cause item lost.",
    "created_at": "2017-10-13T09:35:33Z",
    "closed_at": "2017-10-16T02:16:31Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5666",
    "body": "Version: 2.1.5\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n        Observable<Integer> src = Observable.just(1, 2, 3, 4, 5);\r\n        src.publish(new Function<Observable<Integer>, ObservableSource<Integer>>() {\r\n            @Override\r\n            public ObservableSource<Integer> apply(@NonNull Observable<Integer> integerObservable) throws Exception {\r\n                return integerObservable.take(2).concatWith(integerObservable.skip(2));\r\n            }\r\n        }).subscribe(new Consumer<Integer>() {\r\n            @Override\r\n            public void accept(Integer integer) throws Exception {\r\n                System.out.println(integer);\r\n            }\r\n        });\r\n    }\r\n\r\n```\r\n\r\nexpected result: 1 2 3 4 5\r\nactual result: 1 2 5\r\n\r\n3 and 4 are lost. We suppose it was a bug.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5666/comments",
    "author": "jie-meng",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-10-13T09:50:33Z",
        "body": "That is the expected behavior. This is what happens:\r\n\r\n1. the range 1..5 is shared through a function\r\n2. the `integerObservable` you get will emit 1, 2\r\n3. the `take` unsubscribes after this two items\r\n4. `concatWith` switches to its second `ObservableSource` and subscribes to it\r\n5. the `skip` subscribes to the shared `integerObservable`\r\n6. the `integerObservable` resumes with 3, 4, 5\r\n7. `skip` ignores 3, 4; relays 5\r\n8. the sequence completes.\r\n\r\nSo due to `concatWith`, the second parameter sequence doesn't get to interact with the shared sequence until the first half completed."
      },
      {
        "user": "jie-meng",
        "created_at": "2017-10-16T02:16:31Z",
        "body": "Got it, Thanks!\r\n\r\npublish() makes src Observable to hot.\r\n\r\nChange code to\r\n\r\n```\r\npublic static void main(String[] args) {\r\n        Observable<Integer> src = Observable.just(1, 2, 3, 4, 5);\r\n        src.take(2).concatWith(src.skip(2))\r\n.subscribe(new Consumer<Integer>() {\r\n            @Override\r\n            public void accept(Integer integer) throws Exception {\r\n                System.out.println(integer);\r\n            }\r\n        });\r\n    }\r\n```\r\nIt works as expected."
      }
    ]
  },
  {
    "number": 5663,
    "title": "Is there a way to run in \"eager mode\" a RX chain?",
    "created_at": "2017-10-11T20:32:29Z",
    "closed_at": "2017-11-08T11:04:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5663",
    "body": "Currently there is no \"easy\" way to run a rx chain eagerly.\r\nFirst issue related to that is the broken SOLID principle implementation (almost any method is with final).\r\n\r\nI know that RX was designed for events and so on....\r\nBut would be nice to have such feature that could help to debug complex systems. Or at least will allow to provide your custom implementation for that or similar cases. Almost everything in Observable class is with static or final.\r\n\r\nAny plans on separation of API from implementation? Or an eager implementation that could be choose on execution point?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5663/comments",
    "author": "CyborTronik",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-10-11T20:42:05Z",
        "body": "What do you mean by \"run a rx chain eagerly\"?\r\n\r\nAlso remember that Java has no extension methods and the next closest thing is having a rich class with final methods.\r\n\r\n> Any plans on separation of API from implementation?\r\n\r\nNo. It adds no value to the Rx API, just duplication. You still wouldn't be able to \"extend\" the base interface with new operators unless you own that interface."
      },
      {
        "user": "CyborTronik",
        "created_at": "2017-10-11T20:50:34Z",
        "body": "I think was a misunderstanding.\r\nIs not about adding new operators but about changing default behavior.\r\n\r\nLets take by example, we would be able to implement a decorator pattern over Observable if methods wouldn't be marked with 'final' or if would be an interface with all current available operators/methods.\r\nUsage would be something like: \r\n```\r\n\r\n        Observable<Integer> integerObservable = Observable.fromArray(1, 2, 3, 4, 5);\r\n        integerObservable = new EagerObservable<Integer>(integerObservable);\r\n        integerObservable\r\n                .map(x -> x * x)\r\n                .blockingSubscribe(System.out::println);\r\n```\r\nWhere *EagerObservable* is my implementation/decoration of Observable class. "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-10-11T20:58:27Z",
        "body": "Decorate for what purpose?"
      },
      {
        "user": "CyborTronik",
        "created_at": "2017-10-11T21:19:30Z",
        "body": "I guess is clear for what I need it.\r\nBut if not, does it really matter? \r\nDoes it ever make sense to brake SOLID or other related principles that usually improve maintenance and usability of a library/code, just to save 2 bytes in era when laptops have terabytes and more? When compilers does all kind of optimization when these small things doesn't matter anymore? \r\nIs about just to make it a bit more usable, think it as improvement of user experience."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-10-11T22:04:56Z",
        "body": "> But if not, does it really matter?\r\n\r\nYes, because then we could point you to the right advanced feature(s) of the library.\r\n\r\n> that usually improve maintenance and usability of a library/code\r\n\r\nHow is RxJava not usable or not maintainable? Its declarative design still works after 4.5 public years. The public API narrows down the interaction possibilities of user-provided code with the complex (a)synchronous and backpressure logic. \r\n\r\nIt requires a paradigm shift, a shift in viewing data as flowing entity with time aspects. This allows users to concentrate on the business logic and assembling the required flows while the library takes care of the concurrency aspects that arise.\r\n"
      },
      {
        "user": "CyborTronik",
        "created_at": "2017-10-12T08:24:47Z",
        "body": "Hey man, don't get it aggressive. No one says that your framework is unusable, was about to be *more* usable by ability to cover few more cases."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-10-12T08:42:28Z",
        "body": "You didn't specify much, just a wrapper class name without showing what it does and you didn't specify what \"more\" cases you want to cover.\r\n\r\nPlease specify, in more detail, *what* you want to achieve and not how you'd like to achieve it. I.e., do you want to intercept flow creation?"
      },
      {
        "user": "CyborTronik",
        "created_at": "2017-10-12T19:35:36Z",
        "body": "I was asked just about ability to override methods to change default behavior considering my needs.\r\nThere is nothing to be done on RX side, is just about remove *final* from methods from Observable class(or separate API from implementation). "
      },
      {
        "user": "JakeWharton",
        "created_at": "2017-10-12T19:41:32Z",
        "body": "While a change like this is extremely unlikely to happen, I'll still voice my strong vote in opposition. This change would make operator invocation unknowingly expensive and any thread confinement requirements of the callbacks supplied to operators are almost guaranteed to be violated. It also completely destroys the semantics both of a cold observable and a hot observable. This would be a fundamental deviation in behavior and abandonment of existing semantics that would prohibitively harm consumers in nearly every case."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-10-12T19:47:07Z",
        "body": "To \"override behavior\", you'd have to implement an operator. Consequently, you can use that custom operator with `compose` and you have your custom operator applied in sequence.\r\n\r\n> to change default behavior considering my needs\r\n\r\nWhich operator do you want to override and how would you change its behavior?"
      },
      {
        "user": "digitalbuddha",
        "created_at": "2017-10-12T19:57:00Z",
        "body": "Just an observer but friendly reminder that this is an international project with different customs and native languages. Sometimes things come off as aggressive but it is in error. Over past few years I've seen Rxjava mature while taking community requests into account. As a fellow open source developer that uses rx as my base, I can give you a first hand account of the regret I have of exposing public apis as non final. The amount of work that goes into maintenance grows exponentially due to having the need to handle infinite use cases rather than ones that are predefined. While.your decoration seems reasonable  other transformations that I would come up with would drive David crazy. Personally I've found great power in the compose operator which gives you access to the entire observable coming in, from there you can compose anything you want. Smth like observable.compose(decorater()).subscribe. This style leads to better maintenance while still allowing the maintainers to keep their sanity. "
      },
      {
        "user": "CyborTronik",
        "created_at": "2017-10-12T19:58:32Z",
        "body": "Can you make a RX chain with 'compose' to run eagerly?\r\nThat would help a lot in debuging/investigating complex systems"
      },
      {
        "user": "digitalbuddha",
        "created_at": "2017-10-12T19:59:26Z",
        "body": "Could you kindly explain what you mean by eagerly "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-11-08T11:04:52Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5636,
    "title": "Disposing previous stream in flatMap",
    "created_at": "2017-10-03T11:38:53Z",
    "closed_at": "2017-10-03T12:17:36Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5636",
    "body": "Hi,\r\n\r\nI've found interesting behaviour and I am not sure is it intended behaviour and if so how I can actually aim my need.\r\n\r\nRxJava version I checked:\r\n- 2.1.2\r\n- 2.1.4\r\n\r\nIssue:\r\nKotlin example\r\n```\r\n val single = Single.just(\"single\")\r\n                .doOnDispose({ println(\"single disposed\") })\r\n                .doOnSuccess({ println(\"single success\") })\r\n                .doAfterTerminate({ println(\"single after terminate\") })\r\n\r\nval single2 = Single.just(\"single 2\")\r\n                .doOnDispose({ println(\"single2 disposed\") })\r\n                .doOnSuccess({ println(\"single2 success\") })\r\n                .doAfterTerminate({ println(\"single2 after terminate\") })\r\n\r\nsingle.flatMap { single2 }\r\n                .test()\r\n                .dispose()\r\n```\r\n\r\nThe output is following:\r\n```\r\nsingle success\r\nsingle2 success\r\nsingle2 after terminate\r\nsingle after terminate\r\nsingle2 disposed\r\n```\r\n\r\nSo the `single` was never disposed in this case. My expectation was to call `doOnDispose` as well in single, as I have some logic connected to lifecycle of this stream.\r\n\r\nI assume it is expected behaviour, but I really need such lifecycle in my case. Is it possible to force such behaviour in this case?\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5636/comments",
    "author": "jbialkowski13",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-10-03T11:50:47Z",
        "body": "`single` was not disposed because it was no longer part of the chain at that moment but `single2` was. If you want to perform guaranteed cleanup operation after a flow terminates or gets disposed, use `doFinally` instead of `doAfterTerminate`."
      },
      {
        "user": "jbialkowski13",
        "created_at": "2017-10-03T12:07:02Z",
        "body": "Actually it won't work in my case as `doFinally` is called as well after `onSuccess` was called, and in my case it is not expected result. I expect that I can be notified in original stream, that client has disposed it, without knowing how it was chained later by client."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-10-03T12:13:09Z",
        "body": "That is not possible in this setup. You could try `zip` or `Observable` that doesn't terminate and as such is kept as reference."
      },
      {
        "user": "jbialkowski13",
        "created_at": "2017-10-03T12:17:36Z",
        "body": "Thanks for tips."
      },
      {
        "user": "AllenVork",
        "created_at": "2018-12-07T03:50:42Z",
        "body": "I wonder whether the single leads to memory leaks?"
      }
    ]
  },
  {
    "number": 5629,
    "title": "Decouple API and implementation",
    "created_at": "2017-09-29T13:21:57Z",
    "closed_at": "2017-10-18T13:46:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5629",
    "body": "Do you guys think that it would be a good idea to restructure RxJava by spliting it into API and implementation (like Gradle for example)?\r\n\r\nFor instance, what if `Observable<T>` and `Subject<T>` were interfaces and we could do stuff like this (assuming that `publishSubject()` is equivalent to `PublishSubject.create()`):\r\n\r\n```Kotlin\r\n// Foo is a simple class that invokes onBar whenever bar is called\r\nopen class Foo(private val onBar: (Int) -> Unit) {\r\n\r\n    open fun bar() { onBar(value) }\r\n}\r\n\r\n// ObservableFoo is a Foo and also an Observable\r\nclass ObservableFoo private constructor(private val subject: Subject<Unit>) :\r\n        Observable<Unit> by subject,\r\n        Foo({ subject.onNext(Unit) }) {\r\n\r\n    constructor() : this(publishSubject())\r\n}\r\n\r\n// We can subscribe to ObservableFoo instances\r\nObservableFoo().subscribe { print(\"Bar changed to $it\") }\r\n```\r\n\r\nCurrently the only way to create a custom observable would be by inheriting from `Observable`. Making it an interface instead of a class would satisfy the 'composition over inheritance' principle.\r\n\r\nThis is my first time posting here so I apologise in advance if this is not the place to start this kind of discussion.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5629/comments",
    "author": "gabrielhuff",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2017-09-29T13:53:12Z",
        "body": "There is `ObservableSource` (and friends for other types) which provide the `subscribe` method that takes an `Observer`. You have to know what you're doing for this, though, and instead you should implement `ObservableOnSubscribe` (and friends for other types) which can be wrapped by the `Observable.create`."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-09-29T14:00:13Z",
        "body": "That principle leads to unnecessary allocation and indirection. We went extra lengths to reduce such things in v2. Besides, an overridable operator method is an invitation for megamorphic dispatch and people trying to override it with inadequate operator writing skills. Third, an exteding type would immediately get lost as the existing operators still return the base type. The most workable solution would be the language level extension methods which sadly is not available in Java."
      },
      {
        "user": "gabrielhuff",
        "created_at": "2017-09-29T16:17:39Z",
        "body": "@JakeWharton True. In fact, one could make things even more generic by implementing `Publisher` (thus removing a dependency from RxJava itself). Thing is, none of these interfaces have access to the `Observable` class utility (i.e. operators), which is pretty much what makes RxJava special.\r\n\r\nOf course, all of the above interfaces can be wrapped into `Observable` instances. But the overhead introduced by wrapping them every time would make things inviable from an API design perspective.\r\n\r\n@akarnokd  I agree with the part about the risk of breaking contracts, but this is intrinsic to everything that separates interface from implementation.\r\n\r\nAbout the part about the exteding types getting lost due to operators returning the base type, I don't see it as a problem. In fact, this is the current behavior (every operator returns an `Observable`).\r\n\r\nIt might look like I'm disagreeing with you guys, but I think everything you said make perfect sense. To be honest, I see this as an alternative rather than an improvement. It's a matter of design choices and you gave me good reasons why things are the way they are."
      },
      {
        "user": "abersnaze",
        "created_at": "2017-09-29T16:18:22Z",
        "body": "@stealthcode and I did some tinkering on an idea to build a gradle plugin for merging dependencies. The idea being that you could add methods to any class prior to the building of your code. I had envisioned the syntax being something like\r\n\r\n```\r\ndependencies {\r\n    colliderCompile 'org.reactivestreams:reactive-streams:1.0.1' {\r\n         merge 'reactivex.io.rxjava3:rxjava3:1.0'\r\n         merge 'reactivex.io.rxjava3:rxmath:1.0'\r\n    }\r\n}\r\n```\r\n\r\nThe `rxjava3` jar would contain a duplicate the interface of `org.reactivestreams.Publisher<T>` but with default methods for core things like `scan` and `flatMap`. The collider plugin would repackage the reactive-streams-1.0.1.jar on disk with the injected methods so IDEs and JVM would be none the wiser that they weren't there all along. Then the `rxmath` could add thing related to `count`, `average`, `mean` and `standardDeviation`.\r\n\r\nOf course that plugin would be an entirely independent project and NOT discussed here in rx java. If you have more questions ping me directly.\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-10-18T13:46:33Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5610,
    "title": "how to retry when subscriber error ?",
    "created_at": "2017-09-20T11:59:51Z",
    "closed_at": "2017-09-21T07:34:56Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5610",
    "body": "```java\r\n\r\n          final int[] a = {0};\r\n            Observable.interval(1, TimeUnit.SECONDS).retry(new Predicate<Throwable>() {\r\n                @Override\r\n                public boolean test(Throwable throwable) throws Exception {\r\n                    a[0]=0;\r\n                    System.out.println(\" reset Observable\");\r\n                    return true;\r\n                }\r\n            }).subscribe(new io.reactivex.functions.Consumer<Long>() {\r\n                @Override\r\n                public void accept(Long aLong) throws Exception {\r\n                    a[0]++;\r\n                    System.out.println(a[0]+\"=====\"+System.currentTimeMillis());\r\n                    if (a[0] >5){\r\n                        /*\r\n                        *  it will throw error  i want to retry\r\n                        * */\r\n                        System.out.println(\"a[2] = \" + a[2]);\r\n                    }\r\n                }\r\n            }, new io.reactivex.functions.Consumer<Throwable>() {\r\n                @Override\r\n                public void accept(Throwable throwable) throws Exception {\r\n                    System.out.println(\"e.getLocalizedMessage() = \" + throwable.getLocalizedMessage());\r\n                    a[0]=0;\r\n                }\r\n            });\r\n```\r\n\r\nthis is my log \r\n\r\n```\r\n1=====1505908635697\r\n2=====1505908636687\r\n3=====1505908637684\r\n4=====1505908638684\r\n5=====1505908639684\r\n6=====1505908640684\r\ne.getLocalizedMessage() = 2\r\n```\r\nIf the consumer throws an error, this wording can not be retried? If  i  want to try again, what should I do?\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5610/comments",
    "author": "AllenCoder",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-09-20T12:09:46Z",
        "body": "`retry` can only deal with errors upstream to it. You have to reorganize your flow in a way that the operation that may throw happens before `retry`:\r\n\r\n```java\r\nObservable.interval(1, TimeUnit.SECONDS)\r\n.doOnNext(v -> {\r\n   /* your potentially crashing code here */\r\n})\r\n.retry(e -> true)\r\n.subscribe(v -> { /* non-crashing code here */ }, e -> { /* ... */ }}\r\n```"
      },
      {
        "user": "AllenCoder",
        "created_at": "2017-09-21T01:39:01Z",
        "body": "thank you very much!"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-09-21T07:34:56Z",
        "body": "Great!"
      },
      {
        "user": "TomasThibaut",
        "created_at": "2019-08-13T07:34:09Z",
        "body": "But is there anyway to retry error on downstreams like ``` subscribe() ```,cuz if error happens here, it'll be catch by error callback in ```subscribe()``` and interrupt the whole steam?"
      }
    ]
  },
  {
    "number": 5605,
    "title": "2.x: flowable blockingSubscribe bug",
    "created_at": "2017-09-15T09:11:00Z",
    "closed_at": "2017-09-26T09:09:44Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5605",
    "body": "Ran into the following unexpected behavior (bug?) when experimenting with Flowables:\r\nRxJava v2.1.3\r\n\r\n```java\r\nFlowable.just(1, 2).mergeWith(Flowable.error(new Exception(\"whoops\")))\r\n   .blockingSubscribe(v -> LOGGER.info(\"received: \" + v), LOGGER::error, () -> LOGGER.info(\"completed\"));\r\n```\r\n\r\nI expected to get the following output: \r\n```\r\nreceived: 1\r\nreceived: 2\r\njava.lang.Exception: whoops\r\n```\r\nbut the code only logs the exception, without any values. \r\n\r\nChanging blockingSubscribe to subscribe produces the expected output. \r\nAlso, using Observable instead of Flowable produces the expected output with both subscribe and blockingSubscribe, which makes me think this might be a bug. \r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5605/comments",
    "author": "mvoda",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-09-15T10:28:00Z",
        "body": "This is a valid outcome. `mergeWith` allows errors to cut ahead. In this case, since `blockingSubscribe` requests later than a regular `subscribe`, the underlying `merge` operator won't relay the 1, 2 when they are emitted due to lack of requests but the `Exception` can and will be emitted without downstream requests.\r\n\r\nTry `concatWith` instead."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-09-26T09:09:44Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5597,
    "title": "java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.",
    "created_at": "2017-09-12T06:57:34Z",
    "closed_at": "2017-09-26T09:41:14Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5597",
    "body": "09-12 14:45:10.220 22214-22214/com.emuzi.wallet E/UncaughtException: java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\r\n                                                                         at rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:114)\r\n                                                                         at android.os.Handler.handleCallback(Handler.java:733)\r\n                                                                         at android.os.Handler.dispatchMessage(Handler.java:95)\r\n                                                                         at android.os.Looper.loop(Looper.java:146)\r\n                                                                         at android.app.ActivityThread.main(ActivityThread.java:5748)\r\n                                                                         at java.lang.reflect.Method.invokeNative(Native Method)\r\n                                                                         at java.lang.reflect.Method.invoke(Method.java:515)\r\n                                                                         at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1291)\r\n                                                                         at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1107)\r\n                                                                         at dalvik.system.NativeStart.main(Native Method)\r\n                                                                      Caused by: rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\r\n                                                                         at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:187)\r\n                                                                         at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\r\n                                                                         at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java:273)\r\n                                                                         at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:216)\r\n                                                                         at rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:107)\r\n                                                                         at android.os.Handler.handleCallback(Handler.java:733) \r\n                                                                         at android.os.Handler.dispatchMessage(Handler.java:95) \r\n                                                                         at android.os.Looper.loop(Looper.java:146) \r\n                                                                         at android.app.ActivityThread.main(ActivityThread.java:5748) \r\n                                                                         at java.lang.reflect.Method.invokeNative(Native Method) \r\n                                                                         at java.lang.reflect.Method.invoke(Method.java:515) \r\n                                                                         at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1291) \r\n                                                                         at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1107) \r\n                                                                         at dalvik.system.NativeStart.main(Native Method) \r\n                                                                      Caused by: rx.exceptions.CompositeException: 2 exceptions occurred. \r\n                                                                         at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:187) \r\n                                                                         at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115) \r\n                                                                         at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java:273) \r\n                                                                         at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:216) \r\n                                                                         at rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:107) \r\n                                                                         at android.os.Handler.handleCallback(Handler.java:733) \r\n                                                                         at android.os.Handler.dispatchMessage(Handler.java:95) \r\n                                                                         at android.os.Looper.loop(Looper.java:146) \r\n                                                                         at android.app.ActivityThread.main(ActivityThread.java:5748) \r\n                                                                         at java.lang.reflect.Method.invokeNative(Native Method) \r\n                                                                         at java.lang.reflect.Method.invoke(Method.java:515) \r\n                                                                         at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1291) \r\n                                                                         at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1107) \r\n                                                                         at dalvik.system.NativeStart.main(Native Method) \r\n                                                                      Caused by: rx.exceptions.CompositeException$CompositeExceptionCausalChain: Chain of Causes for CompositeException In Order Received =>\r\n                                                                         at android.util.Log.getStackTraceString(Log.java:454)\r\n                                                                         at android.util.Log.e(Log.java:356)\r\n                                                                         at com.google.firebase.crash.internal.zzh.uncaughtException(Unknown Source)\r\n                                                                         at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)\r\n                                                                         at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)\r\n                                                                         at rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:118)\r\n                                                                         at android.os.Handler.handleCallback(Handler.java:733) \r\n                                                                         at android.os.Handler.dispatchMessage(Handler.java:95) \r\n                                                                         at android.os.Looper.loop(Looper.java:146) \r\n                                                                         at android.app.ActivityThread.main(ActivityThread.java:5748) \r\n                                                                         at java.lang.reflect.Method.invokeNative(Native Method) \r\n                                                                         at java.lang.reflect.Method.invoke(Method.java:515) \r\n                                                                         at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1291) \r\n                                                                         at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1107) \r\n                                                                         at dalvik.system.NativeStart.main(Native Method) \r\n                                                                      Caused by: com.emuzi.wallet.module.LogoutException\r\n                                                                         at com.emuzi.wallet.service.CheckLogoutOperator$1.onNext(CheckLogoutOperator.java:46)\r\n                                                                         at retrofit2.adapter.rxjava.OperatorMapResponseToBodyOrError$1.onNext(OperatorMapResponseToBodyOrError.java:41)\r\n                                                                         at retrofit2.adapter.rxjava.OperatorMapResponseToBodyOrError$1.onNext(OperatorMapResponseToBodyOrError.java:38)\r\n                                                                         at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$RequestArbiter.request(RxJavaCallAdapterFactory.java:173)\r\n                                                                         at rx.Subscriber.setProducer(Subscriber.java:209)\r\n                                                                         at rx.Subscriber.setProducer(Subscriber.java:205)\r\n                                                                         at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$CallOnSubscribe.call(RxJavaCallAdapterFactory.java:152)\r\n                                                                         at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$CallOnSubscribe.call(RxJavaCallAdapterFactory.java:138)\r\n                                                                         at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n                                                                         at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n                                                                         at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n                                                                         at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n                                                                         at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n                                                                         at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n                                                                         at rx.Observable.unsafeSubscribe(Observable.java:10200)\r\n                                                                         at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\r\n                                                                         at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:228)\r\n                                                                         at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\r\n                                                                         at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\r\n                                                                         at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n                                                                         at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\r\n                                                                         at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\r\n                                                                         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\r\n                                                                         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\r\n                                                                         at java.lang.Thread.run(Thread.java:841)\r\n                                                                      Caused by: android.view.WindowManager$BadTokenException:",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5597/comments",
    "author": "a8453770",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-09-12T07:04:50Z",
        "body": "You didn't implement `onError` in your `subscribe()` call:\r\n\r\n    source.subscribe(v -> { }, e -> e.printStackTrace()) \r\n\r\nfor example.\r\n\r\nRelevant exceptions:\r\n\r\nCaused by: com.emuzi.wallet.module.LogoutException\r\nCaused by: android.view.WindowManager$BadTokenException:"
      },
      {
        "user": "a8453770",
        "created_at": "2017-09-12T07:24:57Z",
        "body": "thank you , this is my implement onError in subscribe() call\r\n```java\r\n @Override\r\n    public Subscriber<? super T> call(Subscriber<? super T> subscriber) {\r\n        return new Subscriber<T>() {\r\n            @Override\r\n            public void onCompleted() {\r\n                subscriber.onCompleted();\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable e) {\r\n                if (subscriber != null) {\r\n                       subscriber.onError(e);\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onNext(T t) {\r\n                if (subscriber != null ) {\r\n                    if (t instanceof Response && ((Response) t).result == -2) {\r\n                        subscriber.onError(new LogoutException());\r\n                        subscriber.unsubscribe();\r\n                    } else if (t instanceof NetworkErrorException) {\r\n                        subscriber.onError(new NetworkErrorException());\r\n                        subscriber.unsubscribe();\r\n                    } else if (t instanceof SocketTimeoutException) {\r\n                        subscriber.onError(new SocketTimeoutException());\r\n                        subscriber.unsubscribe();\r\n                    }else {\r\n                        subscriber.onNext(t);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n```"
      },
      {
        "user": "a8453770",
        "created_at": "2017-09-12T07:25:48Z",
        "body": "@akarnokd"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-09-12T11:01:32Z",
        "body": "That is an operator and not an end susbscriber."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-09-26T09:41:14Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      },
      {
        "user": "a8453770",
        "created_at": "2017-10-15T10:07:24Z",
        "body": "hi  I added the method, but it was wrong\r\n\r\n     public static <T> void subscribe(BaseActivity activity,\r\n                                     Observable<T> observable,\r\n                                     Action1<T> onNext,\r\n                                     Action1<Throwable> onError,\r\n                                     Action0 onComplete) {\r\n        observable.compose(activity.bindToLifecycle())\r\n                 .compose(applySchedulers())\r\n                .subscribe(onNext, onError, onComplete);\r\n\r\n    }\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-10-15T10:14:24Z",
        "body": "What does your `Action1<Throwable>` do?"
      },
      {
        "user": "a8453770",
        "created_at": "2017-10-15T10:17:34Z",
        "body": "in my BaseActivity  \r\n```java\r\nprotected void handleError(Throwable t) {\r\n        if (t instanceof LogoutException) {\r\n            reLogin();\r\n        } else if (t instanceof SocketException) {\r\n            showCenterToast(R.string.networkServiceError);\r\n        } else if (t instanceof NetworkErrorException) {\r\n            showCenterToast(R.string.networkServiceError);\r\n        } else if (t instanceof TimeoutException) {\r\n            showCenterToast(R.string.time_out);\r\n        } else if (t instanceof UnknownHostException) {\r\n            showCenterToast(R.string.networkUnknownError);\r\n        } else if (t instanceof SocketTimeoutException) {\r\n            showCenterToast(R.string.time_out);\r\n        } else {\r\n            showCenterToast(R.string.service_not_use);\r\n        }\r\n         hideProgressDialog();\r\n    }\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-10-15T10:27:15Z",
        "body": "So what is the **new** exception you are getting? Also please use three backticks (ASCII code 96) to get ```formatted code``` that is easier to read."
      },
      {
        "user": "a8453770",
        "created_at": "2017-10-19T02:12:43Z",
        "body": "Sorry  It my code problem,I've solved it. Thank you"
      }
    ]
  },
  {
    "number": 5591,
    "title": "Caused by: java.lang.NullPointerException                                                                             at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver.onNext(ObservableConcatMap.java:128)",
    "created_at": "2017-09-07T02:59:13Z",
    "closed_at": "2017-09-07T07:40:29Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5591",
    "body": "```java\r\npublic class BluetoothActivity extends AppCompatActivity {\r\n   @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_bluetooth);\r\n        Observable.just(\"a\")\r\n                .concatMap(b->getResponse(b))\r\n                .concatMap(b->getResponse(b))\r\n                .subscribe(new Consumer<Object>() {\r\n                    @Override\r\n                    public void accept(Object o) throws Exception {\r\n                    }\r\n\r\n                }, new Consumer<Throwable>() {\r\n                    @Override\r\n                    public void accept(Throwable throwable) throws Exception {\r\n                    }\r\n                });\r\n}\r\npublic Observable<Object> getResponse(Object o){\r\n        Log.d(\"program\",\"getResponse():\"+o.toString());\r\n        return new Observable<Object>() {\r\n            @Override\r\n            protected void subscribeActual(Observer<? super Object> observer) {\r\n                observer.onNext(\"b\");\r\n                observer.onComplete();\r\n            }\r\n\r\n        };\r\n    }\r\n}\r\n```\r\n\r\nLog:\r\n```\r\n09-06 18:55:58.312 20589-20589/? E/dalvikvm: /system/framework/pm.jar odex has stale dependencies\r\n09-06 18:55:58.472 20589-20589/? E/memtrack: Couldn't load memtrack module (No such file or directory)\r\n09-06 18:55:58.472 20589-20589/? E/android.os.Debug: failed to load memtrack module: -2\r\n09-06 18:55:58.632 1478-20601/? E/ActivityThread: Failed to find provider info for com.leadcore.sdb\r\n09-06 18:56:06.622 20618-20618/? E/dalvikvm: /system/framework/am.jar odex has stale dependencies\r\n09-06 18:56:06.832 20618-20618/? E/memtrack: Couldn't load memtrack module (No such file or directory)\r\n09-06 18:56:06.832 20618-20618/? E/android.os.Debug: failed to load memtrack module: -2\r\n09-06 18:56:09.082 20638-20638/com.example.z.myplayer E/dalvikvm: Could not find class 'android.graphics.drawable.RippleDrawable', referenced from method android.support.v7.widget.AppCompatImageHelper.hasOverlappingRendering\r\n09-06 18:56:09.252 20638-20638/com.example.z.myplayer E/AndroidRuntime: FATAL EXCEPTION: main\r\n                                                                        Process: com.example.z.myplayer, PID: 20638\r\n                                                                        java.lang.RuntimeException: Unable to start activity ComponentInfo{com.example.z.myplayer/com.example.z.myplayer.BluetoothActivity}: java.lang.NullPointerException\r\n                                                                            at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2209)\r\n                                                                            at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2258)\r\n                                                                            at android.app.ActivityThread.access$800(ActivityThread.java:147)\r\n                                                                            at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1211)\r\n                                                                            at android.os.Handler.dispatchMessage(Handler.java:102)\r\n                                                                            at android.os.Looper.loop(Looper.java:136)\r\n                                                                            at android.app.ActivityThread.main(ActivityThread.java:5135)\r\n                                                                            at java.lang.reflect.Method.invokeNative(Native Method)\r\n                                                                            at java.lang.reflect.Method.invoke(Method.java:515)\r\n                                                                            at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:798)\r\n                                                                            at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:614)\r\n                                                                            at dalvik.system.NativeStart.main(Native Method)\r\n                                                                         Caused by: java.lang.NullPointerException\r\n                                                                            at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver.onNext(ObservableConcatMap.java:128)\r\n                                                                            at com.example.z.myplayer.BluetoothActivity$5.subscribeActual(BluetoothActivity.java:170)\r\n                                                                            at io.reactivex.Observable.subscribe(Observable.java:10903)\r\n                                                                            at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarXMapObservable.subscribeActual(ObservableScalarXMap.java:166)\r\n                                                                            at io.reactivex.Observable.subscribe(Observable.java:10903)\r\n                                                                            at io.reactivex.internal.operators.observable.ObservableConcatMap.subscribeActual(ObservableConcatMap.java:52)\r\n                                                                            at io.reactivex.Observable.subscribe(Observable.java:10903)\r\n                                                                            at io.reactivex.Observable.subscribe(Observable.java:10889)\r\n                                                                            at io.reactivex.Observable.subscribe(Observable.java:10818)\r\n                                                                            at com.example.z.myplayer.BluetoothActivity.onCreate(BluetoothActivity.java:79)\r\n                                                                            at android.app.Activity.performCreate(Activity.java:5356)\r\n                                                                            at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1087)\r\n                                                                            at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2163)\r\n                                                                            at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2258) \r\n                                                                            at android.app.ActivityThread.access$800(ActivityThread.java:147) \r\n                                                                            at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1211) \r\n                                                                            at android.os.Handler.dispatchMessage(Handler.java:102) \r\n                                                                            at android.os.Looper.loop(Looper.java:136) \r\n                                                                            at android.app.ActivityThread.main(ActivityThread.java:5135) \r\n                                                                            at java.lang.reflect.Method.invokeNative(Native Method) \r\n                                                                            at java.lang.reflect.Method.invoke(Method.java:515) \r\n                                                                            at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:798) \r\n                                                                            at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:614) \r\n                                                                            at dalvik.system.NativeStart.main(Native Method) \r\n09-06 18:56:09.402 1478-20662/? E/ActivityThread: Failed to find provider info for com.leadcore.sdb\r\n09-06 18:56:09.662 20660-20660/? E/dalvikvm: /system/framework/am.jar odex has stale dependencies\r\n09-06 18:56:09.822 20660-20660/? E/memtrack: Couldn't load memtrack module (No such file or directory)\r\n09-06 18:56:09.822 20660-20660/? E/android.os.Debug: failed to load memtrack module: -2\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5591/comments",
    "author": "youngonlyforyou",
    "comments": [
      {
        "user": "youngonlyforyou",
        "created_at": "2017-09-07T03:00:43Z",
        "body": "activity crash ..............app crash .........."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-09-07T07:39:35Z",
        "body": "The problem is that you use `new Observable()` where you should follow the observable protocol and call `onSubscribe`:\r\n\r\n```java\r\npublic Observable<Object> getResponse(Object o){\r\n        Log.d(\"program\",\"getResponse():\"+o.toString());\r\n        return new Observable<Object>() {\r\n```\r\n\r\nYou should use `Observable.create()`  instead:\r\n\r\n```java\r\npublic Observable<Object> getResponse(Object o){\r\n    Log.d(\"program\",\"getResponse():\"+o.toString());\r\n    return Observable.<Object>create(new ObservableOnSubscribe<Object>() {\r\n        @Override \r\n        public void subscribe(ObservableEmitter<Object> observer) {\r\n             observer.onNext(\"b\");\r\n             observer.onComplete();\r\n        }\r\n    });\r\n```"
      },
      {
        "user": "youngonlyforyou",
        "created_at": "2017-09-07T16:31:24Z",
        "body": "thx very much ,my friend. I have solved the problem      ：）   ：）"
      }
    ]
  },
  {
    "number": 5588,
    "title": "ConnectableObservable.connect() causes NetworkOnMainThreadException",
    "created_at": "2017-09-06T15:02:52Z",
    "closed_at": "2017-09-14T14:25:23Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5588",
    "body": "## Versions \r\nRxJava: 2.1.0\r\nRxAndroid: 2.0.1\r\n\r\n## Issue\r\nI'm using the following pattern to allow me to share the result of an expensive network call across two observables, which both transform the result in different ways:\r\n\r\n```java\r\nConnectableObservable<Model> connectableObservable = doExpensiveNetworkCall().publish();\r\n\r\n// Transform in one way.\r\nconnectableObservable\r\n    .filter(...)\r\n    .subscribeOn(mDataManager.getScheduler())\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .subscribe(...);\r\n\r\n// Transform in another.\r\nconnectableObservable\r\n    .filter(....)\r\n    .subscribeOn(mDataManager.getScheduler())\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .subscribe(...);\r\n\r\n// And connect... Uh oh,  NetworkOnMainThreadException!\r\nconnectableObservable.connect();\r\n```\r\n\r\nThis is a very useful pattern, however, calling `.connect()` causes `NetworkOnMainThreadException` as the expensive network call is then run on the *main thread*, despite all subscribers of the downstream observables being on a separate thread.\r\n\r\nIs there an equivalent of `.connectOn()` or another alternative which can be used to also let the ConnectableObservable know that it should be run on a different thread? Alternatively, if there's a better way of achieving the above, any guidance would be much appreciated!",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5588/comments",
    "author": "DCRichards",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-09-06T15:42:56Z",
        "body": "`publish` turns the cold source into a hot one, similar to a `PublishSubject`, and `subscribeOn` has no practical effect on hot publish-like sources. In other terms, applying `subscribeOn` after the `ConnectableObservable` has no effect. You have to apply `subscribeOn` before the publishing:\r\n\r\n```java\r\nConnectableObservable<Model> connectableObservable = doExpensiveNetworkCall()\r\n    .subscribeOn(mDataManager.getScheduler())                  // <------------------------------\r\n    .publish();\r\n\r\n// Transform in one way.\r\nconnectableObservable\r\n    .filter(...)\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .subscribe(...);\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-09-14T14:25:23Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      },
      {
        "user": "DCRichards",
        "created_at": "2017-09-14T14:52:01Z",
        "body": "Thank you @akarnokd, that was exactly what I needed, had a bit of a wood from the trees moment. Sorted 👌"
      }
    ]
  },
  {
    "number": 5583,
    "title": "how to subscribe BiConsumer with 2.x",
    "created_at": "2017-09-04T10:05:34Z",
    "closed_at": "2017-09-05T01:33:31Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5583",
    "body": "Hi,\r\n\r\nHow can I subscribe BiConsumer just like subscribe Consumer?\r\n code like this:\r\n\r\n```java\r\nBiConsumer<Integer, String> biConsumer = new BiConsumer<Integer, String>() {\r\n\r\n            @Override\r\n            public void accept(Integer integer, String s) throws Exception {\r\n\r\n            }\r\n        };\r\nObservable.create().subscribe(biConsumer);\r\n```       \r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5583/comments",
    "author": "TxShon",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-09-04T10:14:55Z",
        "body": "That is not possible with RxJava. You have to combine data elements into classes or tuples."
      },
      {
        "user": "TxShon",
        "created_at": "2017-09-05T01:33:31Z",
        "body": "Get it,thanks for your prompt reply"
      }
    ]
  },
  {
    "number": 5580,
    "title": "Exception not propagated on parallel execution with blocking zip function",
    "created_at": "2017-08-31T13:36:40Z",
    "closed_at": "2017-09-01T09:28:22Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5580",
    "body": "When using the zip operator on an `Observable` or `Single` along with a blocking call, there apparently isn't a way to propagate a single error consistently since `mergeArrayDelayError()` or similar all accept a single data type.\r\n\r\nIn this example, I have two `Single`, executed in parallel on a different thread, which are then passed into a `zip` function and then synchronously executed through a `blockingGet()`.\r\nWhat I'd expect is that the exception is thrown by this latter method. What happens though is that the exception is passed to the default uncaught exception handler from `RxJavaPlugins.onError()`.\r\n\r\nAm I using the wrong approach or is there an issue with error propagation here?\r\n**RxJava 2.1.3** on Android.\r\n\r\nHere's the (failing) JUnit test:\r\n\r\n```\r\n    @Test(expected = InterruptedException.class)\r\n    public void testParallelZip_exceptionNotPropagated() throws Exception {\r\n        Single<Object> allPeopleSource = Single.fromCallable(() -> {\r\n            throw new InterruptedException();\r\n        }).subscribeOn(Schedulers.io());\r\n        Single<String> idsSource = Single.fromCallable(() -> \"second_single\").subscribeOn(Schedulers.io());\r\n\r\n        Single.zip(allPeopleSource, idsSource, (o, s) -> \"result\").blockingGet();\r\n    }\r\n```\r\n\r\nAnd here's the failure crash log:\r\n```\r\njava.lang.Exception: Unexpected exception, expected<java.lang.InterruptedException> but was<java.lang.RuntimeException>\r\n\r\n\tat org.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:28)\r\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\r\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\r\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\r\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\r\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\r\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\r\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\r\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\r\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\r\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\r\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\r\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)\r\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)\r\n\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:262)\r\n\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:84)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)\r\nCaused by: java.lang.RuntimeException: java.lang.InterruptedException\r\n\tat io.reactivex.internal.util.ExceptionHelper.wrapOrThrow(ExceptionHelper.java:45)\r\n\tat io.reactivex.internal.observers.BlockingMultiObserver.blockingGet(BlockingMultiObserver.java:91)\r\n\tat io.reactivex.Single.blockingGet(Single.java:2154)\r\n\tat [...].RxUtilsTest.testParallelZip_exceptionNotPropagated(RxUtilsTest.java:70)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\r\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\r\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\r\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\r\n\tat org.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:19)\r\n\t... 20 more\r\nCaused by: java.lang.InterruptedException\r\n\tat com.teamwork.data.util.RxUtilsTest.lambda$testParallelZip_exceptionNotPropagated$1(RxUtilsTest.java:66)\r\n\tat io.reactivex.internal.operators.single.SingleFromCallable.subscribeActual(SingleFromCallable.java:35)\r\n\tat io.reactivex.Single.subscribe(Single.java:2700)\r\n\tat io.reactivex.internal.operators.single.SingleSubscribeOn$SubscribeOnObserver.run(SingleSubscribeOn.java:89)\r\n\tat io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:452)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:61)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:52)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5580/comments",
    "author": "marcosalis",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-31T13:44:28Z",
        "body": "`InterruptedException` is a checked exception and we opted for `blockingGet` to not declare `throws Exception` in its signature. Therefore, it has to wrap any checked exception into a `RuntimeException`, which you received. You have to unwrap the inner `InterruptedException` which JUnit doesn't let you define via its `expected =` annotation afaik. Instead, you have to try-catch manually:\r\n\r\n```java\r\n@Test\r\npublic void testParallelZip_exceptionNotPropagated() throws Exception {\r\n    Single<Object> allPeopleSource = Single.fromCallable(() -> {\r\n        throw new InterruptedException();\r\n    }).subscribeOn(Schedulers.io());\r\n    Single<String> idsSource = Single.fromCallable(() -> \"second_single\")\r\n        .subscribeOn(Schedulers.io());\r\n\r\n    try {\r\n        Single.zip(allPeopleSource, idsSource, (o, s) -> \"result\").blockingGet();\r\n        fail(\"Should have thrown!\");\r\n    } catch (AssertionError ex) {\r\n        throw ex;\r\n    } catch (RuntimeException ex) {\r\n        assertTrue(ex + \"\", ex.getCause() instanceof InterruptedException);\r\n    }\r\n}\r\n```"
      },
      {
        "user": "marcosalis",
        "created_at": "2017-08-31T14:37:44Z",
        "body": "@akarnokd apologies, I've changed my implementation from `Observable` and `Single` and that changed the result entirely.\r\n\r\nTake this as an example of my scenario, but I haven't been able to reproduce the issue in a unit test:\r\n\r\n```\r\nObservable<Object> source1 = Observable.fromCallable(() -> {\r\n            throw new InterruptedException();\r\n        }).subscribeOn(Schedulers.io());\r\nObservable<String> source2 = Observable.fromCallable(() -> \"second_observable\")\r\n                .subscribeOn(Schedulers.io());\r\nObservable.zip(source1, source2, (o, s) -> \"result\").blockingSingle();\r\n```\r\n\r\nThe exception I get is originated from \r\n`io.reactivex.internal.operators.observable.ObservableFromCallable.subscribeActual(ObservableFromCallable.java:48)`\r\nwhich means that the `Observer` seems to have been already disposed (from `ObservableFromCallable`, in my case `RxJavaPlugins.onError(e)` is executed):\r\n```\r\n            if (!d.isDisposed()) {\r\n                s.onError(e);\r\n            } else {\r\n                RxJavaPlugins.onError(e);\r\n            }\r\n```\r\nThe two source observables are obviously not shared among threads and they're just local variables. Can you think of any cases where this would happen?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-31T15:27:34Z",
        "body": "No. If it went through the `RxJavaPlugins.onError`, you'd see the `UndeliverableException` in the stacktrace. Given that only one of the sources throw, that path can't be taken as there is nothing to dispose the chain. So either you misunderstood something or you have a different flow setup than in the top post."
      },
      {
        "user": "marcosalis",
        "created_at": "2017-08-31T15:38:28Z",
        "body": "@akarnokd I do see the `UndeliverableException` in the crash logs. The log I put earlier on referred to the other case, apologies again for confusing you.\r\n\r\n```\r\nE/UncaughtException: io.reactivex.exceptions.UndeliverableException: java.lang.InterruptedException\r\n              at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:349)\r\n              at io.reactivex.internal.operators.observable.ObservableFromCallable.subscribeActual(ObservableFromCallable.java:48)\r\n              at io.reactivex.Observable.subscribe(Observable.java:10838)\r\n              at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96)\r\n              at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:452)\r\n              at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:61)\r\n              at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:52)\r\n              at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n              at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\r\n              at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\r\n              at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\r\n              at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\r\n              at java.lang.Thread.run(Thread.java:841)\r\n Caused by: java.lang.InterruptedException (...)\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-31T15:47:28Z",
        "body": "So what remains, @marcosalis, that you post the code that causes that exception so I can reproduce the issue."
      },
      {
        "user": "marcosalis",
        "created_at": "2017-09-01T09:28:22Z",
        "body": "@akarnokd, unfortunately I can't reproduce the issue outside of the production code of the app I'm working on. What seems to be happening is that there is some kind of weird interaction with the RxJava scheduler threads, their interrupted state and the fact that the Observable seems to be disposed right after it's created. I will need to investigate this further, in the meantime I'm closing the issue as this doesn't seem to happen when using `Single` instead of `Observable` (I guess because of the different implementation of `SingleFromCallable.subscribeActual`, which never calls to `RxJavaPlugins.onError`)."
      }
    ]
  },
  {
    "number": 5562,
    "title": "in this case subscribe onNext not working",
    "created_at": "2017-08-23T03:47:21Z",
    "closed_at": "2017-08-26T10:38:24Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5562",
    "body": "Thanks for using RxJava but before you post an issue, please consider the following points:\r\n\r\nhere is my retrofit and rxjava version：\r\n\r\n    //rx\r\n    compile 'io.reactivex.rxjava2:rxjava:2.0.3'\r\n    compile 'io.reactivex.rxjava2:rxandroid:2.0.1'\r\n    //retrofit\r\n    compile 'com.squareup.retrofit2:retrofit:2.2.0'\r\n    compile 'com.squareup.retrofit2:converter-gson:2.0.2'\r\n    compile 'com.squareup.retrofit2:adapter-rxjava2:2.2.0'\r\n    //okhttp3\r\n    compile 'com.squareup.okhttp3:okhttp:3.4.1'\r\n    compile 'com.squareup.okhttp3:logging-interceptor:3.4.1'\r\n    compile 'com.squareup.okio:okio:1.6.0'\r\n\r\n retrofit like this\r\n`    @GET(\"getAppList\")\r\n    Flowable<EBApiResult<List<UserAppInfo>>> testGetUserApp();`\r\n\r\nrxjava like this\r\n\r\n`          Flowable<EBApiResult<List<UserAppInfo>>>  flowable = testGetAppInfos();`\r\n\r\n        flowable.map(new Function<EBApiResult<List<UserAppInfo>>, List<UserAppInfo>>() {\r\n\r\n            @Override\r\n            public List<UserAppInfo> apply(EBApiResult<List<UserAppInfo>> result) throws Exception {\r\n                return result.getResultData();\r\n            }\r\n        }).subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(new Subscriber<List<UserAppInfo>>() {\r\n                    @Override\r\n                    public void onSubscribe(Subscription s) {\r\n                        Log.i(\"123\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(List<UserAppInfo> userAppInfos) {\r\n                        uiPresenter.bindAppInfoList(result);\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(Throwable t) {\r\n                        uiPresenter.errPage(t.getMessage());\r\n                    }\r\n\r\n                    @Override\r\n                    public void onComplete() {\r\n                        uiPresenter.errPage(null);\r\n                    }\r\n                });`\r\n\r\nI can see that onSubscribe is called back\r\nbut onNext onError is not。\r\n\r\nIf I call rxjava like this\r\n\r\n`          Flowable<EBApiResult<List<UserAppInfo>>>  flowable = testGetAppInfos();`\r\n\r\n      flowable.map(new Function<EBApiResult<List<UserAppInfo>>, List<UserAppInfo>>() {\r\n\r\n            @Override\r\n            public List<UserAppInfo> apply(EBApiResult<List<UserAppInfo>> result) throws Exception {\r\n                return result.getResultData();\r\n            }\r\n        }).subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(new Consumer<List<UserAppInfo>>() {\r\n                    @Override\r\n                    public void accept(List<UserAppInfo> appInfos) throws Exception {\r\n                        storeAppInfos(appInfos);\r\n                        List<UserAppInfo> result = filterListByCurrentCondition(appInfos, CURRENT_NEED_SHOW_APPS);\r\n                        uiPresenter.bindAppInfoList(result);\r\n                    }\r\n                }, new Consumer<Throwable>() {\r\n                    @Override\r\n                    public void accept(Throwable t) throws Exception {\r\n                        uiPresenter.errPage(t.getMessage());\r\n                    }\r\n                }, new Action() {\r\n                    @Override\r\n                    public void run() throws Exception {\r\n                    }\r\n                });`\r\n\r\nevery accept can be reached\r\ni dont know why。\r\nbut i debug with source，I doubt it because...my Flowable‘s implementation is not QueueSubscription。\r\n\r\nI don't know how to fix my problem. I hope you can understand",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5562/comments",
    "author": "neodreamtale",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-23T10:05:48Z",
        "body": "You have to call `s.request(Long.MAX_VALUE)` in the first case where you have `Log.i(\"123\")`."
      },
      {
        "user": "neodreamtale",
        "created_at": "2017-08-25T06:53:43Z",
        "body": "@akarnokd thank you \r\nBecause of the language barrier, I didn't know how to use it before。After your prompt, I went to the relevant documents。it's working，thankyou！"
      }
    ]
  },
  {
    "number": 5561,
    "title": "Task order for Observable.combineLatest and Schedulers.computation()",
    "created_at": "2017-08-22T18:25:28Z",
    "closed_at": "2017-08-22T23:30:10Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5561",
    "body": "Version: 1.3.0\r\n\r\nHello!\r\n\r\nI have observed strange behavior while I was using combineLatest with Schedulers.computation(). Please take a look at example:\r\n```java\r\n   private static void runSubscription(String prefix, boolean shouldWait, ConcurrentMap<String, Integer> stat) {\r\n        Observable<Long> interval = Observable.interval(1000, TimeUnit.MILLISECONDS);\r\n        Observable.combineLatest(Observable.just(prefix), interval, (s1, s2) -> s1)\r\n            .subscribeOn(Schedulers.computation())\r\n            .observeOn(Schedulers.computation())\r\n            .onBackpressureLatest()\r\n            .subscribe(s -> {\r\n                try {\r\n                    if (shouldWait) {\r\n                        Thread.sleep(4000);\r\n                    }\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                stat.merge(s, 1, (v1, v2) -> v1 + v2);\r\n            });\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        ConcurrentMap<String, Integer> stat = new ConcurrentHashMap<>();\r\n\r\n        stat.put(\"1\", 0);\r\n        runSubscription(\"1\", true, stat);\r\n        for (int i = 1; i < Runtime.getRuntime().availableProcessors(); i++) {\r\n            String key = String.valueOf(i + 1);\r\n            stat.put(key, 0);\r\n            runSubscription(key, false, stat);\r\n        }\r\n\r\n        while (!Thread.currentThread().isInterrupted()) {\r\n            // Print invocation statistics\r\n            System.out.println(stat);\r\n            Thread.sleep(4000);\r\n        }\r\n    }\r\n```\r\nThe output shows how many times particular subscriber was invoked. First column - subscriber number, second - invocation count. For version above output is:\r\n```\r\n{1=0, 2=0, 3=0, 4=0}\r\n{1=0, 2=1, 3=1, 4=3}\r\n{1=1, 2=1, 3=1, 4=7}\r\n{1=2, 2=1, 3=1, 4=11}\r\n{1=3, 2=1, 3=1, 4=15}\r\n{1=4, 2=1, 3=1, 4=19}\r\n{1=5, 2=1, 3=1, 4=23}\r\n{1=6, 2=1, 3=1, 4=27}\r\n{1=7, 2=1, 3=1, 4=31}\r\n...\r\n```\r\nThe output is not stable, but every time some of threads invoked less times. \r\nBut when I changed both `Schedulers.computation()` to `Schedulers.io()`, output changed to expected:\r\n```\r\n{1=0, 2=0, 3=0, 4=0}\r\n{1=0, 2=3, 3=3, 4=3}\r\n{1=1, 2=7, 3=7, 4=7}\r\n{1=2, 2=11, 3=11, 4=11}\r\n{1=3, 2=15, 3=15, 4=15}\r\n{1=4, 2=19, 3=19, 4=19}\r\n```\r\nIs it incorrect usage of scheduler, or it is a bug?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5561/comments",
    "author": "dya-victor",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-22T20:16:49Z",
        "body": "The `computation` scheduler has a number of worker threads that is, by default, is equal to the number of available processors and hands out worker threads in a round robin fashion. Since there is a limited number of them and you block one of them in your first run, the subsequent runs will likely get that scheduler and block tasks behind it.\r\n\r\nYou are practically wasting schedulers as `subscribeOn` in this case has no effect, `interval` already runs on the computation scheduler and `observeOn` moves the events from one computation worker to another without much benefit."
      },
      {
        "user": "dya-victor",
        "created_at": "2017-08-22T22:36:55Z",
        "body": "Thank you for quick answer! But I still have a doubts. I tried to changed `Schedulers.computation` to `Schedulers.from(Executors.newFixedThreadPool(3))`, nine subscriptions, and it did work as expected:\r\n```\r\n{1=0, 2=0, 3=0, 4=0, 5=0, 6=0, 7=0, 8=0, 9=0}\r\n{1=0, 2=3, 3=3, 4=3, 5=3, 6=3, 7=3, 8=3, 9=3}\r\n{1=1, 2=7, 3=7, 4=7, 5=7, 6=7, 7=7, 8=7, 9=7}\r\n{1=2, 2=11, 3=11, 4=11, 5=11, 6=11, 7=11, 8=11, 9=11}\r\n```\r\nIn the same time, even with removing `observeOn` and `subscribeOn` number of invocations are not even. \r\n\r\n<details>\r\n<summary>Modified code, Executor used</Summary>\r\n\r\n```java\r\npublic class Main {\r\n    private static final Executor executor = Executors.newFixedThreadPool(3);\r\n\r\n    private static void runSubscription(String prefix, boolean shouldWait, ConcurrentMap<String, Integer> stat) {\r\n        Observable<Long> interval = Observable.interval(1000, TimeUnit.MILLISECONDS);\r\n        Observable.combineLatest(Observable.just(prefix), interval, (s1, s2) -> s1)\r\n                .onBackpressureLatest()\r\n                .observeOn(Schedulers.from(executor))\r\n                .subscribeOn(Schedulers.from(executor))\r\n                //.observeOn(Schedulers.computation())\r\n                .subscribe(s -> {\r\n                    try {\r\n                        if (shouldWait) {\r\n                            Thread.sleep(4000);\r\n                        }\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    stat.merge(s, 1, (v1, v2) -> v1 + v2);\r\n                });\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        ConcurrentMap<String, Integer> stat = new ConcurrentHashMap<>();\r\n\r\n        stat.put(\"1\", 0);\r\n        runSubscription(\"1\", true, stat);\r\n        for (int i = 1; i < Runtime.getRuntime().availableProcessors() + 5; i++) {\r\n            String key = String.valueOf(i + 1);\r\n            stat.put(key, 0);\r\n            runSubscription(key, false, stat);\r\n        }\r\n\r\n        while (!Thread.currentThread().isInterrupted()) {\r\n            // Print invocation statistics\r\n            System.out.println(stat);\r\n            Thread.sleep(4000);\r\n        }\r\n    }\r\n}\r\n```\r\n</details>"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-22T22:46:37Z",
        "body": "`Executors.newFixedThreadPool(3)` works differently than our schedulers. We have N x `Executors.newSingleThreadedScheduledExecutor()`, each of them handed out to operators on demand. If one gets stuck, everybody who gets that executor is blocked. \r\n\r\nIn contrast, `newFixedThreadPool(3)` has 3 workers which pick the next task from a shared queue. If one is blocked, the other 2 will be still able to pick tasks from the queue."
      },
      {
        "user": "dya-victor",
        "created_at": "2017-08-22T22:55:30Z",
        "body": "Thank you!"
      },
      {
        "user": "timofeevda",
        "created_at": "2017-08-23T09:35:05Z",
        "body": "> Executors.newSingleThreadedScheduledExecutor(), each of them handed out to operators on demand. If one gets stuck, everybody who gets that executor is blocked.\r\n\r\nThat's a strange design decision. If we replace Thread.sleep() with tough computational work (e.g. several nested loops with large amount of iterations) one of \"observeOn\" operators will be starving because the other one keeps getting tasks from \"observeOn\" queue effectively blocking other operator who got that executor.\r\n\r\nIn case of bad timings, backpressure and conditional logic within \"CPU bound\" work (leading to arbitrary execution time spent in observer) usage of Scheduler.computation() will lead to completely unpredictable results.\r\n\r\nLooks like round-robin policy of handing out pooled worker is very sensitive to the rate of events and time computational work takes. Shared queue doesn't have this issue but may be slightly less efficient.\r\n\r\nIn any case behavior described above seems conterintuitive. I would except scheduler to try to invoke tasks regardless of \"slow\" tasks performed in one of the workers. "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-23T10:01:22Z",
        "body": "> That's a strange design decision.\r\n\r\nIt is designed as such by default to avoid thread hopping that hurts performance in the long run. Plus, if you actually don't block but compute something, you are making progress.\r\n\r\n> I would except scheduler to try to invoke tasks regardless of \"slow\" tasks performed in one of the workers.\r\n\r\nThe default doesn't do that because most operators expect a FIFO execution and reliable delayed scheduling which can be achieved by a single threaded scheduled executor. \r\n\r\nFor all other cases, there is the option of `Schedulers.from` which adds the penalty for forcing a FIFO execution internally in case the underlying executor is multi-threaded and has to use helper schedulers to ensure timing stays ordered."
      },
      {
        "user": "timofeevda",
        "created_at": "2017-08-23T10:26:30Z",
        "body": "OK, thanks for explanation."
      }
    ]
  },
  {
    "number": 5559,
    "title": "Sample operator with BehaviorSubject issue",
    "created_at": "2017-08-22T15:20:15Z",
    "closed_at": "2017-08-22T16:34:56Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5559",
    "body": "When trying to use the sample operator with a BehaviorSubject as sampler it didn't work as expected (or understood).\r\nFor instance, this simple unit test fails:\r\n\r\n```java\r\n @Test\r\n    public void testSampler() {\r\n        PublishSubject<Long> generator = PublishSubject.create();\r\n\r\n        BehaviorSubject<Boolean> sampler = BehaviorSubject.createDefault(true);\r\n\r\n        TestObserver<Long> sampledGeneratorObserver = generator.sample(sampler).test();\r\n        generator.onNext(2L);\r\n\r\n        sampledGeneratorObserver.assertValueCount(1);\r\n    }\r\n```\r\n\r\nRX version: 2.1.x\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5559/comments",
    "author": "jaumard",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-22T15:28:21Z",
        "body": "Sampler is subscribed before the generator source thus the default `true` sampled nothing as the generator hasn't emitted anything yet. If you call `sampler.onNext(true)` after `generator.onNext(2L)`, the test should pass."
      },
      {
        "user": "jaumard",
        "created_at": "2017-08-22T16:34:56Z",
        "body": "Yeah I know it will work if I do it after but it doesn't fit my needs like that. I was thinking it will emit the default one again. \r\nThanks for the explanation ! "
      }
    ]
  },
  {
    "number": 5549,
    "title": "retryWhen() method signature for Observable differs from other Rx types",
    "created_at": "2017-08-10T23:59:31Z",
    "closed_at": "2017-08-19T22:31:55Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5549",
    "body": "`Flowable`, `Single`, `Maybe` and `Completable` implementations of `retryWhen()` accept a `hander` parameter is typed that is typed `Function<? super Flowable<Throwable>, ? extends Publisher<?>>`.  `Observable.retryWhen()` uses a different type for `handler` which is not compatible with a handler written for the other types.\r\n\r\n```\r\npublic final Single<T> retryWhen(\r\n    Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler)\r\n\r\npublic final Completable retryWhen(\r\n    Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) \r\n\r\npublic final Maybe<T> retryWhen(\r\n    final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler)\r\n\r\npublic final Flowable<T> retryWhen(\r\n    final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler)\r\n```\r\n versus\r\n\r\n```\r\npublic final Observable<T> retryWhen(\r\n    final Function<? super Observable<Throwable>, ? extends ObservableSource<?>> handler)\r\n```\r\n\r\nIt seems instead that this should be:\r\n\r\n```\r\npublic final Observable<T> retryWhen(\r\n    final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler)\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5549/comments",
    "author": "jeremy303",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-11T06:50:41Z",
        "body": "Observable driven by Observable, Flowable by Flowable, and the rest had options for both. In v3 the 0-1 types run with Observable as they are in different subproject from Flowable."
      }
    ]
  },
  {
    "number": 5548,
    "title": "[2.x] Return first emitted result from list of observables or return error if empty",
    "created_at": "2017-08-10T12:32:36Z",
    "closed_at": "2017-08-10T13:02:09Z",
    "labels": [
      "Question",
      "2.x",
      "StackOverflow"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5548",
    "body": "Hey\r\n\r\nI have a `List<Observable<?>>` and I want to get the first item emitted by any of these (running sequentially) or return error from last observable if all returned error or custom error if all were empty (which I can do with `.switchIfEmpty(Observable.error(RuntimeException()))`).\r\n\r\nCurrently, I have something like this:\r\n\r\n    Observable.fromIterable(listOfObservables)\r\n            .take(1)\r\n            .switchIfEmpty(Observable.error(RuntimeException()))\r\n\r\nThis code handles getting only first emitted value and returning an error if all observables were empty but don't handle error case. Any ideas how I can solve that part?\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5548/comments",
    "author": "sourabhv",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-10T13:02:09Z",
        "body": "If you don't read the welcome text of our issue list, why sould I think you'd read any answer?\r\n\r\n> Questions like \"how do I X with RxJava\" are generally better suited for StackOverflow (where it may already have an answer)"
      }
    ]
  },
  {
    "number": 5534,
    "title": " [1.2.0]Caused by: rx.exceptions.OnErrorNotImplementedException: HTTP 500 Internal Server Error",
    "created_at": "2017-08-03T09:41:38Z",
    "closed_at": "2017-08-03T10:32:12Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5534",
    "body": "when i use retrofit+rxjava+rxCalladapter,  foud error  here :\r\n\r\n```\r\n08-03 17:12:50.864 18778-18809/com.xuebansoft.xinghuo.manager E/AndroidRuntime: FATAL EXCEPTION: RxIoScheduler-2\r\nProcess: com.xuebansoft.xinghuo.manager, PID: 18778\r\njava.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\r\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:57)\r\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\r\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\r\n    at java.lang.Thread.run(Thread.java:841)\r\n Caused by: rx.exceptions.OnErrorNotImplementedException: HTTP 500 Internal Server Error\r\n    at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:386)\r\n    at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:383)\r\n    at rx.internal.util.ActionSubscriber.onError(ActionSubscriber.java:44)\r\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:152)\r\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\r\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java:276)\r\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:219)\r\n    at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:228)\r\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\r\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422) \r\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237) \r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152) \r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265) \r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112) \r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587) \r\n    at java.lang.Thread.run(Thread.java:841) \r\n Caused by: retrofit2.adapter.rxjava.HttpException: HTTP 500 Internal Server Error\r\n    at retrofit2.adapter.rxjava.BodyOnSubscribe$BodySubscriber.onNext(BodyOnSubscribe.java:51)\r\n    at retrofit2.adapter.rxjava.BodyOnSubscribe$BodySubscriber.onNext(BodyOnSubscribe.java:36)\r\n    at retrofit2.adapter.rxjava.CallArbiter.deliverResponse(CallArbiter.java:115)\r\n    at retrofit2.adapter.rxjava.CallArbiter.emitResponse(CallArbiter.java:97)\r\n    at retrofit2.adapter.rxjava.CallExecuteOnSubscribe.call(CallExecuteOnSubscribe.java:46)\r\n    at retrofit2.adapter.rxjava.CallExecuteOnSubscribe.call(CallExecuteOnSubscribe.java:24)\r\n    at retrofit2.adapter.rxjava.BodyOnSubscribe.call(BodyOnSubscribe.java:33)\r\n    at retrofit2.adapter.rxjava.BodyOnSubscribe.call(BodyOnSubscribe.java:25)\r\n    at rx.Observable.unsafeSubscribe(Observable.java:10151)\r\n    at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\r\n    at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:228) \r\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55) \r\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422) \r\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237) \r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152) \r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265) \r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112) \r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587) \r\n    at java.lang.Thread.run(Thread.java:841) \r\n```\r\n\r\nand  the running code is here:\r\n\r\n```java\r\n    ManagerApi.getIns().updateChannelInfoForMobileUser(AppHelper.getIUser().getMobileUserId(), ((XhEvent.BindEvent) event).getmChannelId(), ((XhEvent.BindEvent) event).getmUserId())\r\n                                .subscribeOn(Schedulers.io()).observeOn(Schedulers.io()).subscribe(new Action1<EduCommResponse>() {\r\n                            @Override\r\n                            public void call(EduCommResponse eduCommResponse) {\r\n                                if (eduCommResponse.isSuccess()) {\r\n                                    RememberMe.get().devBindedUser();\r\n                                }\r\n                            }\r\n                        });\r\n```\r\nwhen the http response code is 500 ,will throw this error",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5534/comments",
    "author": "pMotato",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-03T09:57:18Z",
        "body": "The key message is:\r\n\r\n> Add onError handling.\r\n\r\ni.e., use `subscribe(Action1<T>, Action1<Throwable>)` at least."
      },
      {
        "user": "pMotato",
        "created_at": "2017-08-03T10:14:17Z",
        "body": "awesome!!!thks"
      }
    ]
  },
  {
    "number": 5532,
    "title": "RxJava 2 and async subscriber",
    "created_at": "2017-08-02T17:16:46Z",
    "closed_at": "2017-08-03T05:55:57Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5532",
    "body": "Hi, I am using RxJava 2.1.2 and found recently sample code that worked in RxJava 1.x but seems to work differently in RxJava 2.\r\nWhen I execute the code below I assume that each \"subscribe\" code will be run in new thread. However it is run in new but the same thread \"RxNewThreadScheduler-1\". I assume that Schedulers.io() should create a new thread per each long-running task. Please advice.\r\n\r\n```java\r\npublic class SampleRx {\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tObservable.fromArray(\"1\", \"2\", \"3\")\r\n\t\t\t.observeOn(Schedulers.io())\r\n\t\t\t.subscribe(item -> { \r\n\t\t\t\tSystem.out.println(\r\n\t\t\t\t\t\tThread.currentThread().getName());\r\n\t\t\tThread.sleep(2000); });\r\n\t\tThread.sleep(7000);\r\n\t}\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5532/comments",
    "author": "sergey-morenets",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-02T18:02:32Z",
        "body": "`Schedulers.io()` reuses threads so if there is a small delay after a flow terminates, the same thread will appear to serve the next flow. This behavior should be the same for both v1 and v2. Your sample code has one flow so it can't show any effects of multiple flows. Could you clarify it?"
      },
      {
        "user": "sergey-morenets",
        "created_at": "2017-08-02T18:19:32Z",
        "body": "Hi @akarnokd \r\n\r\nYes, it's strange but it seems to work the same way in 1.x.\r\nCan you advise then how to to modify the original code so that each subscribe method will be invoked in the separate thread ?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-02T18:22:58Z",
        "body": "There is the `Schedulers.newThread` for that."
      },
      {
        "user": "sergey-morenets",
        "created_at": "2017-08-02T18:31:29Z",
        "body": "Thank you, @akarnokd \r\n\r\nDo you mean this code? Unfortunately it still uses one thread \"RxNewThreadScheduler-1\"\r\n\r\n```java\r\n\t\tObservable.fromArray(\"1\", \"2\", \"3\")\r\n\t\t\t.observeOn(Schedulers.newThread())\r\n\t\t\t.subscribe(item -> { \r\n\t\t\t\tSystem.out.println(\r\n\t\t\t\t\t\tThread.currentThread().getName());\r\n\t\t\tThread.sleep(2000); });\r\n\t\tThread.sleep(7000);\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-02T19:27:46Z",
        "body": "It's unclear to me how do you expect multiple threads when subscribing once?\r\n\r\nTry this:\r\n\r\n```java\r\nObservable<String> source = \r\n    Observable.fromArray(\"1\", \"2\", \"3\")\r\n    .observeOn(Schedulers.newThread());\r\n\r\nsource.subscribe(v -> System.out.println(Thread.currentThread().getName()));\r\n\r\nsource.subscribe(v -> System.out.println(Thread.currentThread().getName()));\r\n\r\nThread.sleep(10000);\r\n```\r\n\r\nor this:\r\n\r\n```java\r\nObservable.fromArray(\"1\", \"2\", \"3\")\r\n  .flatMap(v -> \r\n    Observable.just(v)\r\n       .subscribeOn(Schedulers.newThread())\r\n       .map(v -> Thread.currentThread().getName())\r\n  )\r\n  .subscribe(System.out::println);\r\n\r\nThread.sleep(10000);\r\n```"
      },
      {
        "user": "sergey-morenets",
        "created_at": "2017-08-03T05:55:57Z",
        "body": "Thank you, @akarnokd \r\n\r\nIt works perfectly."
      }
    ]
  },
  {
    "number": 5526,
    "title": "ParallelFlowable  concatMapDelayError emits items out of order",
    "created_at": "2017-07-30T19:49:09Z",
    "closed_at": "2017-08-08T14:35:33Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5526",
    "body": "here is my code  with  parallel operator \r\n\r\n\r\n```\r\ndisposable.add(RxFirebase.observeChildEvent(mDatabase.child(AppConstant.MESSAGES).child(myID_otherID))\r\n                .filter(event -> event.getEventType() == RxFirebaseChildEvent.EventType.ADDED )\r\n                .parallel().runOn(Schedulers.io())\r\n                .concatMapDelayError(messageEvent-> {\r\n\r\n                  \r\n                  Message msg = messageEvent.getValue().getValue(Message.class);\r\n\r\n                    if(msg.getType().equals(AppConstant.MSG_TYPE_VIDEO))\r\n                    {\r\n\r\n                       return Flowable.zip(Flowable.just(msg),AppDatabase.getInstance(getContext()).downloadDoa().getDownloadtem(msg.getVideo_url())\r\n                            .defaultIfEmpty(new DownloadItem(null,null,null,null))\r\n                            .toFlowable().observeOn(AndroidSchedulers.mainThread()),(message, downloadItem) -> {\r\n\r\n                                message.setLocal_video_Path(downloadItem.local_path);\r\n                                message.setStatus(downloadItem.status);\r\n                                return message;\r\n\r\n                        });\r\n\r\n                    }else {\r\n                        return Flowable.just(msg);\r\n                    }\r\n\r\n                },2,true)\r\n                .sequential()\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(event -> {\r\n                    if(event.getLocal_video_Path() != null)\r\n                    Log.d(TAG, \"setMessagesListener: \"+event.getLocal_video_Path());\r\n\r\n                    messagesAdapter.addItem(event);\r\n                }, Throwable::printStackTrace));\r\n```\r\n\r\nit emit item out of order   but when i remove   .parallel().runOn(Schedulers.io())   and  .sequential()  and add subscribeOn(Schedular.io())  at zip operator  it emit item in order ???\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5526/comments",
    "author": "shakil807g",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-30T20:00:03Z",
        "body": "If you go parallel, the source is dispatched to parallel, independent rails that can go on their own speed. If joined together with `sequential` the output order is indeterminate."
      },
      {
        "user": "shakil807g",
        "created_at": "2017-07-30T20:03:12Z",
        "body": "but then what is difference between using flatmap with ParallelFlowable and using contactMap ( which emit items in order)"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-30T20:05:15Z",
        "body": "`concatMap` keeps a relative order within a rail and `flatMap` doesn't as it by itself can run sources concurrently that can finish at any time."
      },
      {
        "user": "shakil807g",
        "created_at": "2017-07-30T20:13:26Z",
        "body": "ok but how can i go parallel and maintain order as well  ?? and does using contactMap without ParallelFlowable  will work in case of  1000 of message coming in from upper stream and i want to maintain order as well ??"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-30T20:30:24Z",
        "body": "Keeping a relative order between the sequential front and sequential back is not supported by RxJava's implementation. You have to manually pack the data and a monotonic index into a tuple, parallelize the flow and then use `sorted(Comparator)` to collect them back in order. However, when using `concatMap`, you have to unpack the data and then repack it with the original index. \r\n\r\nWithout parallel, `concatMap`'s output will remain ordered, i.e., if given an input output mapping of  `a -> (1, 2)` and `b -> (3, 4)`, the operator's final output will be `1, 2, 3, 4` because `a` is processed fully before `b`. "
      },
      {
        "user": "shakil807g",
        "created_at": "2017-07-30T20:44:33Z",
        "body": "ok thanks without parallel and having 1000 of events coming from upper stream will concatMap flood the system with threads "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-31T05:25:51Z",
        "body": "`concatMap` runs one source at a time and if you use `Schedulers.io()`, the number of threads created will be small."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-08T14:35:33Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5512,
    "title": "combineLatest-Function not called when first parameter emits multiple items (1.3)",
    "created_at": "2017-07-21T14:07:08Z",
    "closed_at": "2017-08-06T22:23:45Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5512",
    "body": "Hi folks,\r\n\r\nI think I discovered a bug with the combineLatest function or I just didn't understand how it's supposed to work :). \r\nIf you want to combine two observable, one that emits a single item and one that emits two items, then the function to combine the two observables only gets called twice if you pass in the observable that emits multiple items as second parameter. Here is minimal code example that probably better shows what I mean\r\n\r\n```\r\nObservable<String> case1Observable1 = Observable.just(\"Case 1 - Observable 1 - String 1\").startWith(\"Case 1 - Observable 1 - String 2\");\r\nObservable<String> case1Observable2 = Observable.just(\"Case 1 - Observable 2 - String 1\");\r\n\r\nObservable.combineLatest(case1Observable1, case1Observable2, (s, s2) -> {\r\n    System.out.println(\"Combining...\");\r\n    System.out.println(s);\r\n    System.out.println(s2);\r\n    return \"Combined \" + s + \"|||\" + s2;\r\n}).subscribe(s -> System.out.println(\"Item emitted: \" + s));\r\n\r\nObservable<String> case2Observable1 = Observable.just(\"Case 2 - Observable 1 - String 1\");\r\nObservable<String> case2Observable2 = Observable.just(\"Case 2 - Observable 2 - String 1\").startWith(\"Case 2 - Observable 2 - String 2\");\r\n\r\nObservable.combineLatest(case2Observable1, case2Observable2, (s, s2) -> {\r\n    System.out.println(\"Combining...\");\r\n    System.out.println(s);\r\n    System.out.println(s2);\r\n    return \"Combined \" + s + \"|||\" + s2;\r\n}).subscribe(s -> System.out.println(\"Item emitted: \" + s));\r\n```\r\n\r\nThis produces the following output:\r\n\r\n```\r\nCombining...\r\nCase 1 - Observable 1 - String 1\r\nCase 1 - Observable 2 - String 1\r\nItem emitted: Combined Case 1 - Observable 1 - String 1|||Case 1 - Observable 2 - String 1\r\nCombining...\r\nCase 2 - Observable 1 - String 1\r\nCase 2 - Observable 2 - String 2\r\nItem emitted: Combined Case 2 - Observable 1 - String 1|||Case 2 - Observable 2 - String 2\r\nCombining...\r\nCase 2 - Observable 1 - String 1\r\nCase 2 - Observable 2 - String 1\r\nItem emitted: Combined Case 2 - Observable 1 - String 1|||Case 2 - Observable 2 - String 1\r\n```\r\n\r\nI'd expect both cases to produce the same output, but as you can see, in the first case the combine function only is called once.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5512/comments",
    "author": "osiris86",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-21T15:25:58Z",
        "body": "This is not a bug but a property of the combine function when driven by synchronous sources. The source that gets subscribed earlier will rush through its items synchronously and the operator will only remember its latest item before subscribing to the next source, and so on:\r\n\r\n```\r\nA: ----o----o--|\r\nB:             --z--|\r\n=====================\r\nR: --------------M--|\r\n```\r\n\r\n```\r\nA:  --z--|\r\nB:       ----o----o--|\r\n======================\r\nR: ----------M----M--|\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-06T22:23:45Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      },
      {
        "user": "angelsanzn",
        "created_at": "2021-06-22T21:57:58Z",
        "body": "It would be nice if this got documented in the Javadoc for the method. It is a really subtle behavior that can lead to nasty bugs."
      }
    ]
  },
  {
    "number": 5510,
    "title": "Why doOnComplete / doOnSubscribe / subscribe not called?",
    "created_at": "2017-07-20T21:45:45Z",
    "closed_at": "2017-07-20T21:59:44Z",
    "labels": [
      "Question",
      "Kotlin"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5510",
    "body": "Why are `doOnComplete`, `doOnSubscribe` (and also `doFinally`) not called?\r\n\r\n```kotlin\r\n//    val obs = createObservable()\r\nval obs = createCompletable()\r\n\r\n@JvmStatic fun main(args: Array<String>) {\r\n\r\n    obs.doOnSubscribe {\r\n        println(\"on subscribe!\")\r\n    }\r\n\r\n    obs.doOnComplete {\r\n        println(\"complete!\")\r\n    }\r\n\r\n    obs.doFinally{\r\n        println(\"dofinally!\")\r\n    }\r\n\r\n    obs.subscribe{\r\n        println(\"subscribe\")\r\n    }\r\n}\r\n\r\nfun createCompletable(): Completable =\r\n    Completable.create{ emitter ->\r\n        println(\"calling oncomplete\")\r\n        emitter.onComplete()\r\n    }\r\n\r\nfun createObservable(): Observable<Void> =\r\n    Observable.create<Void> { emitter ->\r\n        println(\"calling oncomplete\")\r\n        emitter.onComplete()\r\n    }\r\n```\r\n\r\nAlso, the subscribe block is called only when using `Completable`, with `Observable<Void>` this is also not called, why?\r\n\r\nIt seems that I'm missing something basic but not being able to figure out exactly what it is. \r\n\r\nI assume that the reason `subscribe` is not called when using the observable, is that this reacts only to `onNext` (?), but why isn't `doOnComplete` called either?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5510/comments",
    "author": "ivnsch",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-20T21:53:44Z",
        "body": "The methods on the base reactive types return a new instance which you have to subscribe to or continue chaining:\r\n\r\n```kotlin\r\ncreateCompletable()\r\n.doOnSubscribe {\r\n        println(\"on subscribe!\")\r\n}\r\n.doOnComplete {\r\n        println(\"complete!\")\r\n}\r\n.doFinally {\r\n        println(\"dofinally!\")\r\n}\r\n.subscribe{\r\n        println(\"success\")\r\n}\r\n```\r\n"
      },
      {
        "user": "ivnsch",
        "created_at": "2017-07-20T21:59:36Z",
        "body": "Ah, my bad! I thought these could be attached anywhere and it would somehow just work. Thanks!"
      }
    ]
  },
  {
    "number": 5508,
    "title": "Caused by : rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError",
    "created_at": "2017-07-20T01:48:28Z",
    "closed_at": "2017-08-06T22:25:09Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5508",
    "body": "This is when I am in the use of Retrofit + Rxjava TalkingData statistics to the problem above.Appear in high frequency.But not return, don't know how to solve,\r\n\r\nThis is the version I used：\r\n  compile 'com.squareup.retrofit2:converter-gson:2.0.2'\r\n  compile 'com.squareup.retrofit2:adapter-rxjava:2.0.2'\r\n  compile 'com.squareup.retrofit2:retrofit:2.0.2'\r\n  compile 'io.reactivex:rxandroid:1.1.0'\r\n  compile 'io.reactivex:rxjava:1.1.0'\r\n\r\nThis is the error log:\r\n```\r\njava.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\r\n\trx.internal.schedulers.ScheduledAction.run(ScheduledAction.java)\r\n\tandroid.os.Handler.handleCallback(Handler.java:743)\r\n\tandroid.os.Handler.dispatchMessage(Handler.java:95)\r\n\tandroid.os.Looper.loop(Looper.java:150)\r\n\tandroid.app.ActivityThread.main(ActivityThread.java:5621)\r\n\tjava.lang.reflect.Method.invoke(Native Method)\r\n\tcom.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:794)\r\n\tcom.android.internal.os.ZygoteInit.main(ZygoteInit.java:684)\r\nCaused by : rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\r\n\trx.observers.SafeSubscriber._onError(SafeSubscriber.java)\r\n\trx.observers.SafeSubscriber.onError(SafeSubscriber.java)\r\n\trx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java)\r\n\trx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java)\r\nCaused by : rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\r\nCaused by : rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\r\nCaused by : rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\r\nCaused by : rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5508/comments",
    "author": "longzc1314",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-20T06:22:49Z",
        "body": "The log is trimmed and it seems your error handler in subscribe() is failing. Please provide the full stacktrace and the code exhibiting the failure."
      },
      {
        "user": "longzc1314",
        "created_at": "2017-07-20T06:28:43Z",
        "body": " The complete error log shown above is above and I can't reproduce myself, most of which is huawei's phone,Excuse me, can I avoid the above problem,\r\n\r\n @Override\r\n    public void onError(Throwable e) {\r\n        try {\r\n            if (e instanceof OnErrorFailedException) {\r\n             //   e.printStackTrace();\r\n            } else {\r\n                onFailure(e.getMessage(), \"\");\r\n            }\r\n        } catch (Exception e1) {\r\n            e1.printStackTrace();\r\n        }\r\n    }"
      },
      {
        "user": "longzc1314",
        "created_at": "2017-07-20T06:51:57Z",
        "body": "@akarnokd \r\nThe complete error log shown above is above and I can't reproduce myself, most of which is huawei's phone,Excuse me, can I avoid the above problem,\r\n\r\n@override\r\npublic void onError(Throwable e) {\r\ntry {\r\nif (e instanceof OnErrorFailedException) {\r\n// e.printStackTrace();\r\n} else {\r\nonFailure(e.getMessage(), \"\");\r\n}\r\n} catch (Exception e1) {\r\ne1.printStackTrace();\r\n}\r\n}"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-20T07:53:09Z",
        "body": "There is not enough information in the log and the code snipplet, to me, has only the `onFailure(e.getMessage(), \"\");` call that may fail for some reason. Without further information, I'm afraid we can't help you much."
      },
      {
        "user": "longzc1314",
        "created_at": "2017-07-20T07:56:46Z",
        "body": "@akarnokd \r\nDoes this problem cause the app to drop out, I can't reproduce it myself, and there's so much information on TalkingData, so what's going to make this error"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-20T13:46:07Z",
        "body": "If I have to guess, there is probably a network connection error somewhere which is not handled properly and the default subscriber just crashes for errors. If you could show what's in `onFailure(e.getMessage(), \"\");` or generally in your `onError` handlers, that might move us forward."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-06T22:25:09Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      },
      {
        "user": "weigg520",
        "created_at": "2018-09-17T12:06:14Z",
        "body": "09-17 19:56:41.304 24357-24357/com.cnbot.kgrobot E/AndroidRuntime: FATAL EXCEPTION: main\r\n                                                                   Process: com.cnbot.kgrobot, PID: 24357\r\n                                                                   java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\r\n                                                                       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:62)\r\n                                                                       at android.os.Handler.handleCallback(Handler.java:739)\r\n                                                                       at android.os.Handler.dispatchMessage(Handler.java:95)\r\n                                                                       at android.os.Looper.loop(Looper.java:135)\r\n                                                                       at android.app.ActivityThread.main(ActivityThread.java:5280)\r\n                                                                       at java.lang.reflect.Method.invoke(Native Method)\r\n                                                                       at java.lang.reflect.Method.invoke(Method.java:372)\r\n                                                                       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:963)\r\n                                                                       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:758)\r\n                                                                    Caused by: rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\r\n                                                                       at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:192)\r\n                                                                       at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120)\r\n                                                                       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java:264)\r\n                                                                       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:207)\r\n                                                                       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\r\n                                                                       at android.os.Handler.handleCallback(Handler.java:739) \r\n                                                                       at android.os.Handler.dispatchMessage(Handler.java:95) \r\n                                                                       at android.os.Looper.loop(Looper.java:135) \r\n                                                                       at android.app.ActivityThread.main(ActivityThread.java:5280) \r\n                                                                       at java.lang.reflect.Method.invoke(Native Method) \r\n                                                                       at java.lang.reflect.Method.invoke(Method.java:372) \r\n                                                                       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:963) \r\n                                                                       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:758) \r\n                                                                    Caused by: rx.exceptions.CompositeException: 2 exceptions occurred. \r\n                                                                       at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:192) \r\n                                                                       at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120) \r\n                                                                       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java:264) \r\n                                                                       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:207) \r\n                                                                       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55) \r\n                                                                       at android.os.Handler.handleCallback(Handler.java:739) \r\n                                                                       at android.os.Handler.dispatchMessage(Handler.java:95) \r\n                                                                       at android.os.Looper.loop(Looper.java:135) \r\n                                                                       at android.app.ActivityThread.main(ActivityThread.java:5280) \r\n                                                                       at java.lang.reflect.Method.invoke(Native Method) \r\n                                                                       at java.lang.reflect.Method.invoke(Method.java:372) \r\n                                                                       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:963) \r\n                                                                       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:758) \r\n                                                                    Caused by: rx.exceptions.CompositeException$CompositeExceptionCausalChain: Chain of Causes for CompositeException In Order Received =>\r\n                                                                       at com.aimall.easylib.utils.CrashHandler.getStackTraceString(CrashHandler.java:61)\r\n                                                                       at com.aimall.easylib.utils.CrashHandler.saveCrashInfo2File(CrashHandler.java:202)\r\n                                                                       at com.aimall.easylib.utils.CrashHandler.handleException(CrashHandler.java:118)\r\n                                                                       at com.aimall.easylib.utils.CrashHandler.uncaughtException(CrashHandler.java:86)\r\n                                                                       at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)\r\n                                                                       at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)\r\n                                                                       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:66)\r\n                                                                       at android.os.Handler.handleCallback(Handler.java:739) \r\n                                                                       at android.os.Handler.dispatchMessage(Handler.java:95) \r\n                                                                       at android.os.Looper.loop(Looper.java:135) \r\n                                                                       at android.app.ActivityThread.main(ActivityThread.java:5280) \r\n                                                                       at java.lang.reflect.Method.invoke(Native Method) \r\n                                                                       at java.lang.reflect.Method.invoke(Method.java:372) \r\n                                                                       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:963) \r\n                                                                       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:758) \r\n                                                                    Caused by: java.net.ConnectException: Failed to connect to /192.168.40.254:80\r\n                                                                       at okhttp3.internal.io.RealConnection.connectSocket(RealConnection.java:187)\r\n                                                                       at okhttp3.internal.io.RealConnection.buildConnection(RealConnection.java:170)\r\n                                                                       at okhttp3.internal.io.RealConnection.connect(RealConnection.java:111)\r\n                                                                       at okhttp3.internal.http.StreamAllocation.findConnection(StreamAllocation.java:187)\r\n                                                                       at okhttp3.internal.http.StreamAllocation.findHealthyConnection(StreamAllocation.java:123)\r\n                                                                       at okhttp3.internal.http.StreamAllocation.newStream(StreamAllocation.java:93)\r\n                                                                       at okhttp3.internal.http.HttpEngine.connect(HttpEngine.java:296)\r\n                                                                       at okhttp3.internal.http.HttpEngine.sendRequest(HttpEngine.java:248)\r\n                                                                       at okhttp3.RealCall.getResponse(RealCall.java:243)\r\n                                                                       at okhttp3.RealCall$ApplicationInterceptorChain.proceed(RealCall.java:201)\r\n                                                                       at okhttp3.logging.HttpLoggingInterceptor.intercept(HttpLoggingInterceptor.java:212)\r\n                                                                       at okhttp3.RealCall$ApplicationInterceptorChain.proceed(RealCall.java:190)\r\n                                                                       at okhttp3.RealCall.getResponseWithInterceptorChain(RealCall.java:163)\r\n                                                                       at okhttp3.RealCall.execute(RealCall.java:57)\r\n                                                                       at retrofit2.OkHttpCall.execute(OkHttpCall.java:174)\r\n                                                                       at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$RequestArbiter.request(RxJavaCallAdapterFactory.java:171)\r\n                                                                       at rx.internal.operators.OperatorSubscribeOn$1$1$1.request(OperatorSubscribeOn.java:80)\r\n                                                                       at rx.Subscriber.setProducer(Subscriber.java:209)\r\n                                                                       at rx.internal.operators.OperatorSubscribeOn$1$1.setProducer(OperatorSubscribeOn.java:76)\r\n                                                                       at rx.Subscriber.setProducer(Subscriber.java:205)\r\n                                                                       at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$CallOnSubscribe.call(RxJavaCallAdapterFactory.java:152)\r\n                                                                       at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$CallOnSubscribe.call(RxJavaCallAdapterFactory.java:138)\r\n                                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:50)\r\n                                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n                                                                       at rx.Observable.unsafeSubscribe(Observable.java:8460)\r\n                                                                       at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\r\n                                                                   \tat rx.intern\r\n"
      },
      {
        "user": "weigg520",
        "created_at": "2018-09-17T12:08:39Z",
        "body": "@akarnokd "
      },
      {
        "user": "akarnokd",
        "created_at": "2018-09-17T12:23:02Z",
        "body": "@weigg520 Why would you \"at\" me about a stack dump lacking context, reproduction code or any details on an RxJava version no longer supported?"
      },
      {
        "user": "yan962868635",
        "created_at": "2022-07-18T02:40:28Z",
        "body": "请教问题是如何解决的 \r\nAsk how the problem is solved\r\n\r\n"
      }
    ]
  },
  {
    "number": 5503,
    "title": "Ignore(don't save reference to) disposable returning after subscription. RxJava2",
    "created_at": "2017-07-19T12:03:35Z",
    "closed_at": "2017-08-06T22:25:29Z",
    "labels": [
      "Question",
      "Android",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5503",
    "body": "Hello, and thx for your great work. I'm Android developer and I faced with some situation. I use Observable.create(...) **to wrap listeners**  and move into reactive-world:\r\n```\r\n  Observable.create(emitter -> {\r\n            SharedPreferences sharedPreferences = getSharedPreferences();\r\n            SharedPreferences.OnSharedPreferenceChangeListener listener = (sharedPreferences, key) -> emitter.onNext(sharedPreferences.getBoolean(\"Some key\", false));\r\n            sharedPreferences.registerOnSharedPreferenceChangeListener(listener);\r\n            emitter.setCancellable(() -> sharedPreferences.unregisterOnSharedPreferenceChangeListener(listener));\r\n        });\r\n```\r\n\r\n**The problem** is, **this listener is stroring as WeakReference** at SharedPreferences. \r\nIn that case, only Disposable, returning after Observable.subscribe(...) method will save strong-reference to this listener.\r\n\r\nSometimes it does not neccessary for me to persist that Disposable, because i won't dispose() my subscription. But in this case( don't store reference to Disposable), my listener will be cleared by GC and my Observable stops emit items.\r\n\r\n**My question:** Whether it is valid to not store Disposable, returning after subscribe(...) or not in common case.\r\nOr my code is wrong and I need to create some proxy-class, that will store strong-references in this case\r\n\r\nThx!\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5503/comments",
    "author": "aleksei-tvorogov",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-19T12:16:16Z",
        "body": "You have to retain a strong reference to the listener in your case of which the easiest way is to store the `Disposable` of the subscription in a strong reference (as it practically does the same thing as a proxy wrapper would at this point)."
      },
      {
        "user": "aleksei-tvorogov",
        "created_at": "2017-07-20T09:58:14Z",
        "body": "- I know, undestand and wrote about saving listener inside strong reference at _Disposable_\r\n- Storing strong-referenceto listener at _Disposable_ is a native behaviour in such cases, because(as i mention earlier), it storing by using _Emitter#setCancellable(...)_\r\n\r\nAnd so, my question was: **Whether it is valid to not store Disposable( returning after Observable#subscribe(...))in common case**\r\n\r\nI work at team, and we want to maintain some rules during developing. Necessity(Or lack of such necessity) of mandatory preservation strong-reference to disposable is one of such rules.\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-20T10:14:02Z",
        "body": "On Android, you have to store that `Disposable` to support cancelling the sequence in case the activity is stopped or paused. The usual issue is opposite to your situation, namely the strong reference may leak the activity beyond its lifecycle. From this perspective, the fact that `registerOnSharedPreferenceChangeListener` uses weak references and unless you store a reference to the Observer/Disposable, the setup will end up being GCd, the objective here is to have a working solution counteracting this property and not the philosophical question of whether storing Disposables is good practice or not."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-20T10:16:15Z",
        "body": "The counter-question is, how would you handle the situation without RxJava and just by interacting with the listener the traditional Android way?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-06T22:25:29Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      },
      {
        "user": "einmalfel",
        "created_at": "2017-08-10T11:22:29Z",
        "body": "@akarnokd Hello! I'd like to rephrase original question: doesn't observable contract guarantee that its subscriptions must work with no regard to whether client code stores references to them or not?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-10T11:36:17Z",
        "body": "How do you define \"must work\"? If you don't store references, you can't call `dispose` thus can't stop an ongoing `Observable` flow."
      },
      {
        "user": "einmalfel",
        "created_at": "2017-08-10T12:28:33Z",
        "body": "@akarnokd I'd define it as follows: subscription works while its observer receives items it has subscribed to"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-10T12:58:51Z",
        "body": "Yes. There are two cases to consider: \r\n- Running a synchronous source will work because the current thread will keep references to it through the end `Observable.subscribe()` call. \r\n- Running asynchronous source with standard schedulers will keep a reference to the whole chain from the backing ScheduledExecutorService's thread as the task it executes has strong references to the inner components of the `Observable` operators.\r\n\r\nThis guarantee actually comes from Java, because otherwise everything would break that somehow doesn't store reference in somewhere reachable from static roots."
      },
      {
        "user": "aleksei-tvorogov",
        "created_at": "2017-08-10T14:02:43Z",
        "body": "Ok, let's see code, that subscribes for settings and show/hide error:\r\n\r\n```\r\n  private void someMethod() {\r\n        observePreferences().subscribe(someValue -> someValue ? showNotification(),\r\n                hideNotifiaction());\r\n    }\r\n```\r\nAt that part of code I ignored disposable, returned after Observable#subscribe(...) call, because I'm not interested in disposing subscription. Also, I have not any thread switching, thus not using schedulers. \r\nobservePreferences() can be realized at this manner:\r\n```\r\n\r\n private Observable<Boolean> observePreferences() {\r\n        return Observable.create(emitter -> {\r\n            SharedPreferences sharedPreferences = getSharedPreferences();\r\n            SharedPreferences.OnSharedPreferenceChangeListener listener = (sharedPreferences, key) -> emitter.onNext(sharedPreferences.getBoolean(\"some_pref_key\", false));\r\n            sharedPreferences.registerOnSharedPreferenceChangeListener(listener);\r\n            emitter.setCancellable(() -> sharedPreferences.unregisterOnSharedPreferenceChangeListener(listener));\r\n        })\r\n    }\r\n```\r\n\r\nNow, let's see io.reactivex.internal.operators.observable.ObservableCreate.java:\r\n\r\n```\r\n @Override\r\n    protected void subscribeActual(Observer<? super T> observer) {\r\n        CreateEmitter<T> parent = new CreateEmitter<T>(observer);\r\n        observer.onSubscribe(parent);\r\n\r\n        try {\r\n            source.subscribe(parent);\r\n        } catch (Throwable ex) {\r\n            Exceptions.throwIfFatal(ex);\r\n            parent.onError(ex);\r\n        }\r\n    }\r\n```\r\nAs you can see, only place, where disposable is storing is\r\n _observer.onSubscribe(parent);_\r\n\r\nAlso, as we can see at Observable's\r\n\r\n```\r\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,\r\n            Action onComplete, Consumer<? super Disposable> onSubscribe) {\r\n        ObjectHelper.requireNonNull(onNext, \"onNext is null\");\r\n        ObjectHelper.requireNonNull(onError, \"onError is null\");\r\n        ObjectHelper.requireNonNull(onComplete, \"onComplete is null\");\r\n        ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\");\r\n\r\n        LambdaObserver<T> ls = new LambdaObserver<T>(onNext, onError, onComplete, onSubscribe);\r\n\r\n        subscribe(ls);\r\n\r\n        return ls;\r\n```\r\n\r\nresults disposable is not storing at any places.\r\n\r\nThus, at that implementation, no one storing disposable after subscription. Thus, weak listener will be removed by GC soon and my subscriber/observer/consumer will not receive events after that."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-10T14:55:53Z",
        "body": "Is `registerOnSharedPreferenceChangeListener` RxJava ? Let's see a simplified example:\r\n\r\n```java\r\nWeakReference<Integer> wr = new WeakReference<>(123456789);\r\n\r\nObservable<Integer> obs = Observable.fromCallable(() -> wr.get());\r\n\r\nSystem.gc();\r\nThread.sleep(200);\r\n\r\nobs.test()\r\n  .assertFailure(NullPointerException.class);\r\n```\r\n\r\nUnsurprisingly, RxJava failed to keep `123456789` alive. \r\n\r\nRxJava can't change such weak sources into strong ones and also can't make you hold strong references to its own components.\r\n\r\nYour case has nothing to do with RxJava. I assume the weak reference property of `registerOnSharedPreferenceChangeListener` was there all along and when you manually registered a listener, you kept a strong reference to the listener somewhere until it could be released. Now RxJava is taking the place of the listener thus you have to keep a strong reference of the observer or disposable you use/get back to prevent losing the listener. (This is no contradiction to my answer to @einmalfel question as he didn't specify what sources he meant and my answer assumed standard RxJava sources that don't have any weak references anywhere near them.)\r\n \r\n\r\n"
      },
      {
        "user": "einmalfel",
        "created_at": "2017-08-10T15:51:54Z",
        "body": "@akarnokd so, does the observable implementation in question violate Observable contract?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-10T16:36:35Z",
        "body": "Let's see:\r\n\r\n- `onSubscribe` called? **Yes**, by `create` itself\r\n- `onXXX` methods called sequentially? **Yes**, the sharedPreferences signals from the main thread, right?\r\n- `onXXX` stops if the consumer disposes? **Yes**, the setCancellation call after the register call ensures this.\r\n\r\nVerdict: contract honored."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-10T17:16:12Z",
        "body": "If the question had been, how to work around such weak listeners, that's a more interesting question. For example, have a companion task that keeps a reference to the listener as part of the `Observable` setup:\r\n\r\n```java\r\nprivate Observable<Boolean> observePreferences() {\r\n    return Observable.create(emitter -> {\r\n            SharedPreferences sharedPreferences = getSharedPreferences();\r\n            SharedPreferences.OnSharedPreferenceChangeListener listener = \r\n                (sharedPreferences, key) ->\r\n                     emitter.onNext(sharedPreferences.getBoolean(\"some_pref_key\", false));\r\n            sharedPreferences.registerOnSharedPreferenceChangeListener(listener);\r\n\r\n            Disposable d = Schedulers.io().schedulePeriodicallyDirect(\r\n               () -> log(listener.toString()), 100000, TimeUnit.DAYS);\r\n\r\n            emitter.setCancellable(() -> \r\n                  sharedPreferences.unregisterOnSharedPreferenceChangeListener(listener);\r\n                  d.dispose();\r\n            });\r\n      });\r\n}"
      },
      {
        "user": "einmalfel",
        "created_at": "2017-08-13T08:05:42Z",
        "body": "@akarnokd Nice solution! in our project we decided to go for SharedPrefs decorator that stores strong refs"
      },
      {
        "user": "Zhuinden",
        "created_at": "2020-05-07T06:02:18Z",
        "body": "In a similar scenario, I used a `IdentityHashMap` to store the references, and removed the references on cancellation."
      }
    ]
  },
  {
    "number": 5498,
    "title": "Single shared operator",
    "created_at": "2017-07-18T15:04:05Z",
    "closed_at": "2017-08-06T22:25:41Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5498",
    "body": "With rx2.x and Single, I'm search for the equivalent of the shared operator from Observable.\r\n \r\nFrom what I understand this operator doesn't exist for Single, is there a reason for that ? \r\n\r\nMy need is to shared a Single that execute network call, I don't want to do x time that network call, just want to share the response when the network call is done. `cache` operator is not what I need as it will never do the network call again. If there multiple subscribe during a call just share the response of the first one, if not just execute the network call normally \r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5498/comments",
    "author": "jaumard",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-18T16:00:06Z",
        "body": "The semantics for `ConnectableSingle` has not been defined and the alternatives, such as converting to `Observable` and back for the missing operations or using `cache`, were enough as the workaround. In addition, since the `Single` succeeds or fails, the `refCount` would be a gamble because if you don't subscribe fast enough in a batch, one of the subscribers would restart the upstream unexpectedly. Therefore, there are currently no plans to have such extensions for the \"shorter\" reactive base types."
      }
    ]
  },
  {
    "number": 5497,
    "title": "Possible bug in worker eviction mechanism of IoScheduler",
    "created_at": "2017-07-18T14:24:48Z",
    "closed_at": "2017-07-18T15:10:10Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5497",
    "body": "While profiling an application I'm working on, I ran into the following issue.\r\nThe worker pool backing the global IO scheduler never seems to shrink unless you don't use it _at all_ for at least 60s.\r\n\r\nVersion: 2.1.0\r\nReproducer:\r\n```java\r\nimport java.util.concurrent.TimeUnit;\r\n\r\nimport io.reactivex.Completable;\r\nimport io.reactivex.Flowable;\r\nimport io.reactivex.disposables.Disposable;\r\nimport io.reactivex.internal.schedulers.IoScheduler;\r\nimport io.reactivex.schedulers.Schedulers;\r\n\r\npublic class IoSchedulerTest {\r\n    public static void main(String[] args) throws Exception {\r\n        // burst of 20 tasks\r\n        Flowable\r\n                .range(0, 20)\r\n                .parallel(20)\r\n                .runOn(Schedulers.io())\r\n                .doOnNext(__ -> Thread.sleep(500))\r\n                .sequential()\r\n                .ignoreElements()\r\n                .blockingAwait();\r\n\r\n        IoScheduler scheduler = (IoScheduler) Schedulers.io();\r\n        System.out.format(\"IO scheduler size after initial burst: %d%n\", scheduler.size());\r\n\r\n        long start = System.nanoTime();\r\n\r\n        // sleep for a while, but not long enough for worker eviction\r\n        System.out.println(\"Sleeping for 45s...\");\r\n        TimeUnit.SECONDS.sleep(45);\r\n\r\n        Disposable d = Schedulers.computation().schedulePeriodicallyDirect(\r\n                () -> System.out.format(\"IO scheduler size after %ss: %d%n\", secondsSince(start), scheduler.size()),\r\n                0, 5, TimeUnit.SECONDS);\r\n\r\n        // 1 task every 5 sec for the next 30s or so\r\n        while (secondsSince(start) <= 75) {\r\n            System.out.println(\"Creating another task for Schedulers.io()\");\r\n            Completable\r\n                    .fromAction(() -> Thread.sleep(5000))\r\n                    .subscribeOn(Schedulers.io())\r\n                    .blockingAwait();\r\n        }\r\n\r\n        // sleep for 65 sec to allow for worker eviction\r\n        System.out.println(\"Sleeping for 65s...\");\r\n        TimeUnit.SECONDS.sleep(65);\r\n\r\n        System.out.format(\"IO scheduler size after sleeping for 65s: %d%n\", scheduler.size());\r\n        d.dispose();\r\n    }\r\n\r\n    static long secondsSince(long nanoTimeStart) {\r\n        return TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - nanoTimeStart);\r\n    }\r\n}\r\n```\r\nThis prints:\r\n```\r\nIO scheduler size after initial burst: 20\r\nSleeping for 45s...\r\nCreating another task for Schedulers.io()\r\nIO scheduler size after 45s: 20\r\nIO scheduler size after 50s: 20\r\nCreating another task for Schedulers.io()\r\nIO scheduler size after 55s: 20\r\nCreating another task for Schedulers.io()\r\nIO scheduler size after 60s: 20\r\nCreating another task for Schedulers.io()\r\nIO scheduler size after 65s: 20\r\nCreating another task for Schedulers.io()\r\nIO scheduler size after 70s: 20\r\nCreating another task for Schedulers.io()\r\nIO scheduler size after 75s: 20\r\nCreating another task for Schedulers.io()\r\nIO scheduler size after 80s: 20\r\nSleeping for 65s...\r\nIO scheduler size after 85s: 20\r\nIO scheduler size after 90s: 20\r\nIO scheduler size after 95s: 20\r\nIO scheduler size after 100s: 20\r\nIO scheduler size after 105s: 20\r\nIO scheduler size after 110s: 20\r\nIO scheduler size after 115s: 20\r\nIO scheduler size after 120s: 5\r\nIO scheduler size after 125s: 5\r\nIO scheduler size after 130s: 5\r\nIO scheduler size after 135s: 5\r\nIO scheduler size after 140s: 5\r\nIO scheduler size after 145s: 5\r\nIO scheduler size after sleeping for 65s: 5\r\n```\r\nWhat I'd expect and think is desirable is eviction kicking in after about 60s or so.\r\nBut it seems that is as soon as something is executed by the IO scheduler the eviction timer resets and so the pool will never shrink until it is left completely unused for 60 seconds.\r\n\r\nOur application pretty much never leaves the IO scheduler unused for such a long time...",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5497/comments",
    "author": "cardamon",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-18T14:48:29Z",
        "body": "> unless you don't use it at all for at least 60s.\r\n\r\nThis is by design and the default timeout. The workers individually will timeout after this amount unless you keep reusing them in some way.\r\n\r\n> Our application pretty much never leaves the IO scheduler unused for such a long time...\r\n\r\nAnd likely will reuse existing threads in the IO pool. I'd only worry if the pool kept growing.\r\n\r\nIt looks like the TTL is not configurable currently but could be made configurable relatively easily."
      },
      {
        "user": "cardamon",
        "created_at": "2017-07-18T15:10:10Z",
        "body": "Ah OK.\r\nI more or less was expecting `Schedulers.io()` to be similar to something like\r\n```Schedulers.from(Executors.newCachedThreadPool())```, which in the above example would shrink the pool after the first 60s elapsed regardless of whether new tasks are being continuously added or not."
      }
    ]
  },
  {
    "number": 5496,
    "title": "Merge works not as expected",
    "created_at": "2017-07-18T12:31:19Z",
    "closed_at": "2017-07-18T12:57:14Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5496",
    "body": "The operator merge not work as expected.\r\nVersion: 2.1.0\r\n```java\r\n    public static void main(String[] args){\r\n\r\n        Observable<Integer> i = Observable.create((ObservableEmitter<Integer> e) -> {\r\n            throw new RuntimeException(\"h1\");\r\n        }).subscribeOn(Schedulers.io());\r\n\r\n        Observable<Integer> i2 = Observable.create((ObservableEmitter<Integer> e) -> {\r\n            throw new RuntimeException(\"h2\");\r\n        }).subscribeOn(Schedulers.io());\r\n\r\n        Observable.merge(i, i2)\r\n                .subscribeOn(Schedulers.io())\r\n                .subscribe(\r\n                        integer -> {\r\n                            System.out.println(\"integer = \" + integer);\r\n                        },\r\n                        throwable -> {\r\n                            System.out.println(\"throwable = \" + throwable);\r\n                        });\r\n\r\n        try {\r\n            Thread.sleep(20 * 1000);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n```\r\n\r\nIf I remove `i`, `i2` subscribeOn operator. It works fine.\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5496/comments",
    "author": "gengjiawen",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-18T12:39:51Z",
        "body": "I don't see how you have any expectation about this setup or how you'd define \"doesn't work\" in this context."
      },
      {
        "user": "gengjiawen",
        "created_at": "2017-07-18T12:46:25Z",
        "body": "It crash.I expect it will deal with the first stream error occured, kill other stream."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-18T12:52:56Z",
        "body": "This setup behaves correctly because you race the emission of two errors due to `subscribeOn` on two independent threads. There are a couple of outcomes possible and legal:\r\n\r\n- h1 wins and cancels i2, no h2 emission\r\n- h2 wins and cancels i, no h1 emission\r\n- h1 wins but h2 reaches the merge and a composite exception is formed\r\n- h2 wins but h1 reaches the merge and a composite exception is formed\r\n- h1 wins but h2 reaches the merge and gets routed to the global error handler\r\n- h2 wins but h1 reaches the merge and gets routed to the global error handler\r\n- h1 wins and i2 is cancelled just before trying to signal h2, which then gets routed to the global error handler\r\n- h2 wins and i is cancelled just before trying to signal h1, which then gets routed to the global error handler"
      },
      {
        "user": "gengjiawen",
        "created_at": "2017-07-18T12:57:08Z",
        "body": "thanks, it's very clear."
      }
    ]
  },
  {
    "number": 5488,
    "title": "SocketTimeoutException cause CompositeException$CompositeExceptionCausalChain",
    "created_at": "2017-07-14T06:15:05Z",
    "closed_at": "2017-08-06T22:25:57Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5488",
    "body": "```\r\njava.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\r\n      at rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:114)\r\n      at android.os.Handler.handleCallback(Handler.java:742)\r\n      at android.os.Handler.dispatchMessage(Handler.java:95)\r\n      at android.os.Looper.loop(Looper.java:154)\r\n      at android.app.ActivityThread.main(ActivityThread.java:5529)\r\n      at java.lang.reflect.Method.invoke(Native Method)\r\n      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:739)\r\n      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:629)\r\n   Caused by: rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\r\n      at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:192)\r\n      at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120)\r\n      at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java:276)\r\n      at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:219)\r\n      at rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:107)\r\n      at android.os.Handler.handleCallback(Handler.java:742) \r\n      at android.os.Handler.dispatchMessage(Handler.java:95) \r\n      at android.os.Looper.loop(Looper.java:154) \r\n      at android.app.ActivityThread.main(ActivityThread.java:5529) \r\n      at java.lang.reflect.Method.invoke(Native Method) \r\n      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:739) \r\n      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:629) \r\n   Caused by: rx.exceptions.CompositeException: 2 exceptions occurred. \r\n      at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:192) \r\n      at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120) \r\n      at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java:276) \r\n      at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:219) \r\n      at rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:107) \r\n      at android.os.Handler.handleCallback(Handler.java:742) \r\n      at android.os.Handler.dispatchMessage(Handler.java:95) \r\n      at android.os.Looper.loop(Looper.java:154) \r\n      at android.app.ActivityThread.main(ActivityThread.java:5529) \r\n      at java.lang.reflect.Method.invoke(Native Method) \r\n      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:739) \r\n      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:629) \r\n   Caused by: rx.exceptions.CompositeException$CompositeExceptionCausalChain: Chain of Causes for CompositeException In Order Received =>\r\n      at com.tencent.bugly.crashreport.crash.e.a(BUGLY:187)\r\n      at com.tencent.bugly.crashreport.crash.e.b(BUGLY:334)\r\n      at com.tencent.bugly.crashreport.crash.e.uncaughtException(BUGLY:372)\r\n      at com.umeng.analytics.pro.as.uncaughtException(CrashHandler.java:37)\r\n      at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)\r\n      at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)\r\n      at rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:118)\r\n      at android.os.Handler.handleCallback(Handler.java:742) \r\n      at android.os.Handler.dispatchMessage(Handler.java:95) \r\n      at android.os.Looper.loop(Looper.java:154) \r\n      at android.app.ActivityThread.main(ActivityThread.java:5529) \r\n      at java.lang.reflect.Method.invoke(Native Method) \r\n      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:739) \r\n      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:629) \r\n   Caused by: java.net.SocketTimeoutException: failed to connect to /192.168.100.16 (port 80) after 15000ms\r\n      at libcore.io.IoBridge.connectErrno(IoBridge.java:169)\r\n      at libcore.io.IoBridge.connect(IoBridge.java:122)\r\n      at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:183)\r\n      at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:452)\r\n      at java.net.Socket.connect(Socket.java:884)\r\n      at okhttp3.internal.platform.AndroidPlatform.connectSocket(AndroidPlatform.java:63)\r\n      at okhttp3.internal.connection.RealConnection.connectSocket(RealConnection.java:221)\r\n      at okhttp3.internal.connection.RealConnection.connect(RealConnection.java:147)\r\n      at okhttp3.internal.connection.StreamAllocation.findConnection(StreamAllocation.java:192)\r\n      at okhttp3.internal.connection.StreamAllocation.findHealthyConnection(StreamAllocation.java:121)\r\n      at okhttp3.internal.connection.StreamAllocation.newStream(StreamAllocation.java:100)\r\n      at okhttp3.internal.connection.ConnectInterceptor.intercept(ConnectInterceptor.java:42)\r\n      at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\r\n      at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:67)\r\n      at okhttp3.internal.cache.CacheInterceptor.intercept(CacheInterceptor.java:93)\r\n      at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\r\n      at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:67)\r\n      at okhttp3.internal.http.BridgeInterceptor.intercept(BridgeInterceptor.java:93)\r\n      at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\r\n      at okhttp3.internal.http.RetryAndFollowUpInterceptor.intercept(RetryAndFollowUpInterceptor.java:120)\r\n      at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\r\n      at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:67)\r\n      at com.lingdanet.safeguard.customer.net.HeaderInterceptor.intercept(HeaderInterceptor.java:57)\r\n      at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\r\n      at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:67)\r\n  \tat okhttp3.logging\r\n```\r\n\r\n\r\n\r\nthis is my HeaderIntercept\r\n\r\n```\r\n@Override\r\n    public Response intercept(Chain chain) throws IOException{\r\n        Request request = chain.request();\r\n        Request.Builder builder = request\r\n                .newBuilder();\r\n        String token = SPUtils.getInstance().getString(Constant.TOKEN, \"\");\r\n//        String token = SafeguardCustomerApplication.getInstance().getToken();\r\n        LogUtils.d(TAG, \"token = \" + token);\r\n        if(headers != null && !TextUtils.isEmpty(token)) {\r\n            LogUtils.d(TAG, \"headers != null\" + token);\r\n            headers.put(AUTHORIZATION, token);\r\n        }\r\n        if (headers != null && headers.size() > 0) {\r\n            Set<String> keys = headers.keySet();\r\n            for (String headerKey : keys) {\r\n                builder.addHeader(headerKey, headers.get(headerKey)).build();\r\n            }\r\n        }\r\n        Response repsonse = chain.proceed(builder.build());\r\n        if (null != repsonse) {\r\n            String curToken = repsonse.header(AUTHORIZATION);\r\n            LogUtils.d(TAG, \"cuToken = \" + curToken);\r\n            if ((!TextUtils.isEmpty(curToken)) && (!TextUtils.equals(token, curToken))) {\r\n                token = curToken;\r\n                SPUtils.getInstance().put(Constant.TOKEN, token);\r\n            }\r\n        }\r\n\r\n        return repsonse;\r\n    }\r\n```\r\n\r\n```\r\n Response repsonse = chain.proceed(builder.build());\r\n```\r\nthe error point to this line",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5488/comments",
    "author": "cxmmxc",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-14T07:33:22Z",
        "body": "The primary error is the inability to connect to an endpoint:\r\n\r\n`Caused by: java.net.SocketTimeoutException: failed to connect to /192.168.100.16 (port 80) after 15000ms`\r\n\r\nThe secondary error is that you don't have proper error handling in your `subscribe()` method but the stacktrace is truncated and you don't seem to use the latest version of RxJava."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-06T22:25:57Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5487,
    "title": "1.x: Single.flatMapCompletable and Observable.flatMapCompletable have inconsistent signatures",
    "created_at": "2017-07-13T16:25:43Z",
    "closed_at": "2017-07-13T17:46:37Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5487",
    "body": "Using 1.3.0, my understanding is that flatMapCompletable will never call onNext() since none of the flatMapped Completables will. \r\nI think the signature is correct in Single but not in Observable:\r\n```\r\npublic class Single<T> {\r\n[...]\r\n    public final Completable flatMapCompletable(final Func1<? super T, ? extends Completable> func) {\r\n```\r\n```\r\npublic class Observable<T> {\r\n[...]\r\n    public final Observable<T> flatMapCompletable(Func1<? super T, ? extends Completable> mapper) {\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5487/comments",
    "author": "nlebas",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-13T16:36:11Z",
        "body": "The practice of returning a different reactive type from non-conversion `Observable` operators started out in 2.x and would be inconsistent in relation to the other operators in `Observable`. For `Single`, there was simply not much choice as there is no empty `Single`, hence `Completable`."
      },
      {
        "user": "nlebas",
        "created_at": "2017-07-13T17:46:37Z",
        "body": "I guess it's OK.\r\nI'll have to wait until all my dependencies are ready for rxjava2, though."
      }
    ]
  },
  {
    "number": 5469,
    "title": "Is it possible to create custom Observer?",
    "created_at": "2017-07-06T08:06:58Z",
    "closed_at": "2017-07-19T09:59:38Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5469",
    "body": "Hi, I am using RxJava 2.1.1. \r\n\r\nWhen I add data in list adapter, data can be added in front, middle or tail. \r\n\r\nIt would be nice if the data had an index, but not always.\r\n\r\nIt would be very comfortable if I could customize Observer to get a callback.\r\n\r\nLike this,\r\n\r\n```\r\nPublishSubject<DataItem> dataSubject = PublishSubject.create();\r\n\r\nvoid observeData(){\r\n    dataSubject.subscribe(\r\n        new Consumer<DataItem>() {\r\n            @Override \r\n            void addHead(DataItem dataItem){}\r\n\r\n            @Override \r\n            void addMiddle(DataItem dataItem, int position){}\r\n\r\n            @Override \r\n            void addTail(DataItem dataItem){}\r\n\r\n    );\r\n}\r\n\r\nvoid addItemToHead(DataItem dataItem){\r\n    dataSubject.customObserver().addHead(dataItem);\r\n}\r\n\r\n```\r\n\r\nIs there any pattern I can use like this?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5469/comments",
    "author": "JSpiner",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-06T08:19:18Z",
        "body": "I don't understand the question. Java is a statically typed language where an interface definition explicitly states what methods have to be implemented and also ensures what methods are there to be called."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-19T09:59:38Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5464,
    "title": "ReplaySubject and PublisherSubject Bug",
    "created_at": "2017-07-05T02:27:07Z",
    "closed_at": "2017-07-19T10:00:16Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5464",
    "body": "I'm use rxjava version 2.1.1.\r\nI think I found a litle bug\r\n\r\nEvery time I send object to a observers, the my `subscribe` never is called when I'm use `flatMapInterable` and `toList` to processe itens in my list before him.\r\nthe subscribes only called when subject.onComplete() isso called.\r\nPlease see the code.\r\n```java\r\nReplaySubject<List<Object>> subject = ReplaySubject.create();\r\nsubject.flatMapIterable(object -> {\r\n            Log.d(TAG, \"flatMapIterable: it is called \" + object.toString());\r\n            return object;\r\n        }).doOnEach(objNotification -> Log.d(TAG, \"doOnEach: it is called \" + objNotification.getValue().toString()))\r\n          .toList()\r\n          .subscribe(obj -> Log.d(TAG, \"subscribe: it is only called after subscribe.onComplete()\" + obj.toString()));\r\nsubject.onNext(getListOfObjects());\r\nLog.d(TAG, \"onComplete:\");\r\nsubject.onComplete();\r\n```\r\nSee the logcat\r\n\r\n```log\r\n07-04 23:20:38.258 10770-10770/app.package D/TAG: flatMapIterable: it is called\r\n07-04 23:20:38.259 10770-10770/app.package D/TAG: doOnEach: it is called\r\n07-04 23:20:38.259 10770-10770/app.package D/TAG: onComplete:\r\n07-04 23:20:38.260 10770-10770/app.package D/TAG: doOnEach: it is called\r\n07-04 23:20:38.260 10770-10770/app.package D/TAG: it is only called after subscribe.onComplete()\r\n```\r\n\r\nP.S. Sorry my bad english",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5464/comments",
    "author": "marcusedu",
    "comments": [
      {
        "user": "cardamon",
        "created_at": "2017-07-05T07:20:25Z",
        "body": "That seems (to me at least) to be working as intended, looking at the marble diagram of `toList`. How would `toList` \"know\" it's supposed to emit something without a terminal event?\r\nMaybe you could use the `buffer` operator, it might do what you want..."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-05T13:49:38Z",
        "body": "The Javadoc of `toList` has been updated to emphasize on the finite requirement via #5465."
      },
      {
        "user": "marcusedu",
        "created_at": "2017-07-05T16:15:15Z",
        "body": "Hye guys thanks for helping."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-19T10:00:15Z",
        "body": "You are welcome."
      }
    ]
  },
  {
    "number": 5463,
    "title": "Copyrights of marble diagrams",
    "created_at": "2017-07-05T01:40:48Z",
    "closed_at": "2017-07-05T10:18:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5463",
    "body": "@akarnokd I want to write a book about Rxjava in Chinese, I want to know if I could use the diagrams of Rxjava in my book? Thanks a lot.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5463/comments",
    "author": "Chaoba",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-05T07:43:46Z",
        "body": "The diagrams are Apache 2.0 too so you can reuse them in a book.\r\n\r\nRelated: #4158"
      },
      {
        "user": "Chaoba",
        "created_at": "2017-07-05T10:18:46Z",
        "body": "Got it. Thank you very much."
      },
      {
        "user": "Chaoba",
        "created_at": "2017-12-01T05:10:06Z",
        "body": "@akarnokd Sorry to bother you again. I have almost completed my book and wonder if you could write a forward for my book? It will be my great honor if you could help me. Let me introduce my book in brief.\r\n\r\nChapter 1 Introduce RxJava\r\nChapter 2 Combined with marble diagrams to introduce kinds of operators\r\nChapter 3 Introduce Schedulers\r\nChapter 4 Combiled with source codes to introduce the realization principle of some operators and Schedulers.\r\nChapter 5 Give some demos on how to solve practical problems and usage of RxLifecycle and RxBinding\r\nChapter 6 What's new on RxJava2\r\n\r\nMy email is qqliys@126.com. Look forward to hear from you.\r\nThanks a lot."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-12-01T07:49:12Z",
        "body": "Hi. I'm afraid I don't have the literacy do that, sorry."
      }
    ]
  },
  {
    "number": 5455,
    "title": "Problems caused by  rxjava version and rxAndroid version",
    "created_at": "2017-06-30T10:16:42Z",
    "closed_at": "2017-06-30T11:22:24Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5455",
    "body": "RxJava2.1.0 does not execute onComplete when used in conjunction with RxAndroid2.0.1\r\nWhen RxJava2.1.1 is used in conjunction with RxAndroid2.0.1, onComplete is executed\r\nWhy?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5455/comments",
    "author": "ltigers",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-30T10:29:36Z",
        "body": "Unknown, also please provide context and unit test that demonstrates the flow that behaves unexpectedly."
      }
    ]
  },
  {
    "number": 5452,
    "title": "The number of method references in a .dex file cannot exceed 64K after adding rx dependencies",
    "created_at": "2017-06-28T20:38:14Z",
    "closed_at": "2017-07-05T22:29:17Z",
    "labels": [
      "Question",
      "Android",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5452",
    "body": "I had the error \"The number of method references in a .dex file cannot exceed 64K\" when I try to generate an apk. When I remove ReactiveX's dependencies, I have no error anymore.\r\n\r\nI'm using the following dependencies:\r\n`compile 'io.reactivex.rxjava2:rxjava:2.1.1'`\r\n`compile 'io.reactivex.rxjava2:rxandroid:2.0.1'`\r\n\r\nI know I need to use `multiDexEnabled=true` to solve this issue, but I don't want my app being multDex for now.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5452/comments",
    "author": "lennonpetrick",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2017-06-28T20:41:37Z",
        "body": "You can enable ProGuard to remove unused methods and also to optimize method count by inlining small methods. This library ProGuard's fantastically."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-05T22:29:17Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5451,
    "title": "About single.",
    "created_at": "2017-06-28T06:49:03Z",
    "closed_at": "2017-06-28T10:14:20Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5451",
    "body": "To be honest,I don't know why there is a concept is “Single”.It's just a single data of observabe,but they are not the same kind of interface.\r\n\r\nAt rx1,I never use the single,observable is quite enough for me.\r\nNow I want change the rx1 to rx2,I found the functions like \"toList\" return a \"Single\" instance,but I just want use observable to do something,I must change the single to observable,it's redundantly to do this,or single is redundantly for my code.\r\n\r\nIn the end,please tell me why produce the \"Single\" concept？",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5451/comments",
    "author": "yangwuan55",
    "comments": [
      {
        "user": "yangwuan55",
        "created_at": "2017-06-28T07:12:23Z",
        "body": "I think the ObservableSource and SingleSource should has a same father.\r\n\r\nand now I can do this : \r\n\r\n```\r\n\r\nObservable.zip(observableOrSingle,xxx);\r\n\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-28T07:42:35Z",
        "body": "`Single` captures the fact of 1 element or error only in the type. Indeed it has a subset of capabilities of `Observable` but uses simpler internal state to represent a flow. You can always convert back to `Observable`/`Flowable` via `toObservable()`/`toFlowable()`. This distinction allows better reasoning about the flows by the developer and also allows certain flow optimizations.\r\n\r\nThe protocols are not the same: `Single` has `onSuccess` and `onError` while `Observable` has `onNext`, `onError` and `onComplete`. In addition, there are two problems: RxJava 2 is stable thus can't just change parameter- or return types or hierarchies; having the same base type can cause ambiguities in compilation."
      },
      {
        "user": "yangwuan55",
        "created_at": "2017-06-28T10:14:20Z",
        "body": "OK, thanks for answer!I will try to understand more."
      }
    ]
  },
  {
    "number": 5446,
    "title": "2.x: #delay() operator emits items non-deterministically",
    "created_at": "2017-06-26T22:44:48Z",
    "closed_at": "2017-06-27T18:09:22Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5446",
    "body": "I am using RxJava 2.1.0.\r\n\r\n**tl;dr: I think this is a real issue because sometimes the test case is single-threaded (as expected), but sometimes it is multi-threaded. This non-determinism seems problematic.**\r\n\r\nI had a flaky test in my test suite. I have boiled it down to the following reproducible (failing) test case:\r\n\r\n```java\r\n    @Test\r\n    public void test() throws Exception {\r\n        // Looping to demonstrate flakiness\r\n        for (int i = 0; i < 10; i++) {\r\n            Single<String> source = Single.create(new ErrorsProvider());\r\n\r\n            source.observeOn(Schedulers.trampoline()) // Schedulers.io() in production\r\n                    .retryWhen(delayedRetry())\r\n                    .test()\r\n                    .assertResult(\"Success\");\r\n        }\r\n    }\r\n\r\n    private static class ErrorsProvider implements SingleOnSubscribe<String> {\r\n\r\n        private AtomicInteger count = new AtomicInteger(0);\r\n\r\n        @Override public void subscribe(@NonNull SingleEmitter<String> e) throws Exception {\r\n            if (count.getAndIncrement() == 0) {\r\n                e.onError(new Throwable(\"fail\"));\r\n            } else {\r\n                e.onSuccess(\"Success\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private static Function<Flowable<Throwable>, Publisher<?>> delayedRetry() {\r\n        return errors -> errors.flatMap(error -> {\r\n            if (error.getMessage().equals(\"fail\")) {\r\n                // This delay would be non-zero in production but set to 0 during test runs\r\n                return Flowable.just(0).delay(0, TimeUnit.SECONDS);\r\n            }\r\n            return Flowable.error(error);\r\n        });\r\n    }\r\n```\r\n\r\nI would expect this test to pass 100% of the time, but instead it fails every time I run it inside this loop. More to the point, even with 1 iteration, it'll fail on CI regularly.\r\n\r\nI have modified my test like so to workaround the issue:\r\n\r\n```java\r\n            Single<String> source = Single.create(new ErrorsProvider());\r\n\r\n            source.observeOn(Schedulers.trampoline())\r\n                    .retryWhen(delayedRetry())\r\n                    .test()\r\n                    .awaitCount(1) // new line\r\n                    .assertResult(\"Success\");\r\n```\r\n\r\nBut I feel like this should not be necessary.\r\n\r\nIn my production code, I have extensive logging enabled, and by reading them carefully I noticed that _sometimes_, after the `retryWhen()` operator was called, subsequent emissions occurred on a new thread. Most of the time, all emissions are called on a single thread (which is what I'd expect when using `Schedulers.trampoline()`). It was at this point I noticed that the `delay()` operator operates by default on `Schedulers.computation()`. I thought perhaps I was simply mis-using the library, and so I changed my delay call to `delay(...).observeOn(Schedulers.trampoline())`, but that had no effect.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5446/comments",
    "author": "autonomousapps",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-27T07:23:55Z",
        "body": "`delay` runs on the computation scheduler and observing it on the trampoline scheduler has no effect. The trampoline scheduler isn't there to pin execution to a particular thread, its purpose is to make sure tasks submitted from multiple threads execute one after the other. You could use the `delay(long, TimeUnit, Scheduler)` overload to override the scheduler and not introduce asynchrony in your tests.\r\n\r\nAlternatively, you could use `awaitDone(long, TimeUnit)` to wait for the async flow and then assert on the contents. `awaitCount` waits only for the `onNext` event and your workaround may still fail to receive `onComplete` in time."
      },
      {
        "user": "autonomousapps",
        "created_at": "2017-06-27T17:24:20Z",
        "body": "Thank you for correcting my misunderstanding of some of these issues. (I actually wish the javadoc were as clear as your sentence \"The trampoline scheduler isn't there to pin execution to a particular thread, its purpose is to make sure tasks submitted from multiple threads execute one after the other\".)\r\n\r\nNevertheless, the non-deterministic behavior seems wrong. Why would the test sometimes pass (when not in a loop), but other times fail? Why would I sometimes observe all code paths on a single thread, and sometimes on two threads?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-27T17:34:46Z",
        "body": "The moment you have an async scheduler in there somewhere (via opeator overload default), you open yourself to concurrent behavior thus events may not arrive \"immediately\" like in a fully synchronous case.\r\n\r\n> non-deterministic behavior seems wrong\r\n\r\nConcurrent behavior is often non-intuitive and non-deterministic.\r\n\r\n> Why would the test sometimes pass (when not in a loop), but other times fail?\r\n\r\nBecause the test thread and the consuming thread run concurrently and the test thread might get delayed just enough so the other thread has time to signal all of its events. Other times, the other thread may get things done a bit later and the test thread has already at or behind its checks.\r\n\r\n> Why would I sometimes observe all code paths on a single thread, and sometimes on two threads?\r\n\r\nConcurrent events are serialized into a single thread and if more events are involved, the same thread may deliver all events if the timing is right."
      },
      {
        "user": "autonomousapps",
        "created_at": "2017-06-27T18:09:22Z",
        "body": "Got it! Thank you."
      }
    ]
  },
  {
    "number": 5445,
    "title": "NPE when Flowable goes parallel `2.x`",
    "created_at": "2017-06-26T21:50:54Z",
    "closed_at": "2017-06-29T15:16:48Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5445",
    "body": "Flowable throws NPE if goes parallel \r\n```\r\n//throws NPE\r\nFlowable.fromPublisher({\r\n  it.onNext(1)\r\n  it.onNext(2)\r\n  it.onComplete()\r\n}).parallel().sequential().subscribe({println(it)})\r\n```\r\nBut if i use `range` instead of `fromPublisher` it will be fine \r\n```\r\nFlowable.range(1,2).parallel().sequential().subscribe({println(it)})\r\n```\r\nAm i missing something ?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5445/comments",
    "author": "lakemove",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-26T21:53:32Z",
        "body": "`fromPublisher` requires you to implement a Reactive-Streams `Publisher` correctly. Use `Flowable.create()` instead."
      }
    ]
  },
  {
    "number": 5424,
    "title": "RxJava1.3.0 stackoverflow at android4.4",
    "created_at": "2017-06-19T07:23:07Z",
    "closed_at": "2017-06-19T08:35:55Z",
    "labels": [
      "Question",
      "Android",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5424",
    "body": "version:1.3.0\r\nos:android4.4\r\nMy app is running is very good at other version of android except for android4.4.\r\nThere is the crash log:\r\n```\r\n\r\njava.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\r\n                                                       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:59)\r\n                                                       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\r\n                                                       at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n                                                       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\r\n                                                       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\r\n                                                       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\r\n                                                       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\r\n                                                       at java.lang.Thread.run(Thread.java:841)\r\n                                                    Caused by: java.lang.StackOverflowError\r\n                                                       at java.util.concurrent.ConcurrentLinkedQueue.isEmpty(ConcurrentLinkedQueue.java:397)\r\n                                                       at rx.internal.schedulers.CachedThreadScheduler$CachedWorkerPool.get(CachedThreadScheduler.java:90)\r\n                                                       at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker.<init>(CachedThreadScheduler.java:188)\r\n                                                       at rx.internal.schedulers.CachedThreadScheduler.createWorker(CachedThreadScheduler.java:176)\r\n                                                       at rx.internal.operators.OperatorSubscribeOn.call(OperatorSubscribeOn.java:44)\r\n                                                       at rx.internal.operators.OperatorSubscribeOn.call(OperatorSubscribeOn.java:30)\r\n                                                       at rx.Observable.unsafeSubscribe(Observable.java:10256)\r\n                                                       at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41)\r\n                                                       at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30)\r\n                                                       at rx.Observable.unsafeSubscribe(Observable.java:10256)\r\n                                                       at rx.internal.operators.CachedObservable$CacheState.connect(CachedObservable.java:183)\r\n                                                       at rx.internal.operators.CachedObservable$CachedSubscribe.call(CachedObservable.java:248)\r\n                                                       at rx.internal.operators.CachedObservable$CachedSubscribe.call(CachedObservable.java:230)\r\n                                                       at rx.Observable.unsafeSubscribe(Observable.java:10256)\r\n                                                       at rx.internal.operators.OperatorZip$Zip.start(OperatorZip.java:202)\r\n                                                       at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:143)\r\n                                                       at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:109)\r\n                                                       at rx.internal.util.ScalarSynchronousObservable$WeakSingleProducer.request(ScalarSynchronousObservable.java:276)\r\n                                                       at rx.Subscriber.setProducer(Subscriber.java:209)\r\n                                                       at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:138)\r\n                                                       at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:129)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n                                                       at rx.Observable.unsafeSubscribe(Observable.java:10256)\r\n                                                       at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)\r\n                                                       at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n                                                       at rx.Observable.unsafeSubscribe(Observable.java:10256)\r\n                                                       at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:248)\r\n                                                       at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:148)\r\n                                                       at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\r\n                                                       at rx.internal.producers.SingleDelayedProducer.emit(SingleDelayedProducer.java:102)\r\n                                                       at rx.internal.producers.SingleDelayedProducer.setValue(SingleDelayedProducer.java:85)\r\n                                                       at rx.internal.operators.OperatorAny$1.onNext(OperatorAny.java:62)\r\n                                                       at rx.internal.operators.NotificationLite.accept(NotificationLite.java:135)\r\n                                                       at rx.internal.operators.CachedObservable$ReplayProducer.replay(CachedObservable.java:403)\r\n                                                   \tat rx.internal.operators.CachedObservable$CacheState.dispatch(CachedObservable.j\r\n\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5424/comments",
    "author": "yangwuan55",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-19T07:28:23Z",
        "body": "Maybe the default stack size on that platform is low. You can break the stack depth at places by introducing `observeOn` or (somehow) specify the minimum thread stack depth for the application."
      },
      {
        "user": "yangwuan55",
        "created_at": "2017-06-19T08:35:55Z",
        "body": "@akarnokd Thank you! I do the observeOn is useful."
      }
    ]
  },
  {
    "number": 5420,
    "title": "Subscribe is not returning disposable when using repeat operator",
    "created_at": "2017-06-16T11:20:24Z",
    "closed_at": "2017-07-05T22:29:42Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5420",
    "body": "Hi, I'm using rxjava 2.1.0. I want to make a pooling to a server, so I'm using a repeat operator. But when I subscribe to the observable, it does not return a disposable. \r\n\r\nFor example, if I do: \r\n\r\n Disposable s = Observable.just(true).repeat().subscribe();\r\n int i = 0;\r\n\r\nThe second line i = 0 is never reached. I cant get a disposable reference after calling to subscribe(), in order to call to dispose() when I want to finish my pooling.\r\n\r\nI'm not sure if this is a bug, or I dont understand the behaviour of the repeat operator. It is working fine, but I'm not able to finish the subscription when using the repeat operator. ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5420/comments",
    "author": "vicpinm",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-16T11:31:03Z",
        "body": "You built a sequence that repeats a constant, immediate source indefinitely upon subscription on the current thread and thus you won't get the control back. You have to specify where the asynchronous execution should happen via `subscribeOn` in this case. Also such immediate repeats are not really recommended for pooling and instead you should consider using `interval()`."
      },
      {
        "user": "vicpinm",
        "created_at": "2017-06-16T12:18:29Z",
        "body": "You are right, is a thread-related issue. I have fixed it with a the subscribeOn operator, thanks a lot!"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-05T22:29:42Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5417,
    "title": "2.x defaultIfEmpty for Maybe",
    "created_at": "2017-06-16T07:46:51Z",
    "closed_at": "2017-06-16T08:36:02Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5417",
    "body": "Hi. I'm glad that I started using 2.x and be able to use Maybe.\r\nI started using it, and wanted to ask a question.\r\n\r\nNow `Maybe#defaultIfEmpty` returns `Maybe`, but because this operator guarantees to emit data, I think should be `Maybe#defaultIfEmpty` returns `Single`.\r\n\r\nI would like to know if there is a reason to return `Maybe`.\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5417/comments",
    "author": "uzzu",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-16T08:00:04Z",
        "body": "It was probably overlooked but we can't change the type now."
      },
      {
        "user": "vanniktech",
        "created_at": "2017-06-16T08:02:50Z",
        "body": "`defaultIfEmptySingle` that returns Single?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-16T08:10:48Z",
        "body": "There is the `toSingle(T defaultValue)`."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-16T08:14:48Z",
        "body": "Also `defaultIfEmpty` is based on `switchIfEmpty` thus it returns `Maybe`."
      },
      {
        "user": "uzzu",
        "created_at": "2017-06-16T08:36:02Z",
        "body": "OK. :+1:\r\nI write unit tests and it seems that there is no problem with substituting `toSingle(T defaultValue)`, so I will use that.\r\n\r\n[IMO] I think that `defaultIfEmpty` is more readable than `toSingle` , so I'd like to return `Single` in 3.x or future versions.\r\n\r\nThank you for answering my question 😄 "
      }
    ]
  },
  {
    "number": 5412,
    "title": "combineLatest(Iterable<Publisher<>>, Function<>) not emitting on empty iterable ",
    "created_at": "2017-06-14T10:33:48Z",
    "closed_at": "2017-06-28T08:58:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5412",
    "body": "I am using RxJava 2.10 and operator\r\n\r\nio.reactivex.Flowable#combineLatest(java.lang.Iterable<? extends org.reactivestreams.Publisher<? extends T>>, io.reactivex.functions.Function<? super java.lang.Object[],? extends R>)\r\n\r\n but I've seen this behavior in 1.x as well. \r\n\r\nOverload of combineLatests (and combineLatestsDelayError) that takes Iterable of Publishers is not emitting any items and 'combiner' function passed to it is not called when iterable is empty. For this operator I would expect it to scale linearly, that is:\r\n\r\n- If I pass Iterable of size 2 as a first argument I expect an Array of size 2 to be passed to combiner function\r\n- If I pass Iterable of size 1 as a first argument I expect an Array of size 1 to be passed to combiner function\r\n- If I pass Iterable of size 0 as a first argument I expect an Array of size 0 to be passed to combiner function\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5412/comments",
    "author": "Sroka",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-14T10:46:46Z",
        "body": "Wrong expectation. If you know you have zero sources, you are using the wrong operator to trigger actions. You can pick `just`, `map` it and actually ignore the input value. If you don't know you have zero sources, you still have the option to switch to a non-empty source via `switchIfEmpty`."
      },
      {
        "user": "Sroka",
        "created_at": "2017-06-14T11:11:57Z",
        "body": "@akarnokd Well, OK, makes sense. It took me quite a while to track this one down. Do you think it should be included in the docs? I can document it and make pull request "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-14T11:16:14Z",
        "body": "Yes, something along the line of this:\r\n\r\n> Providing an empty array/Iterable will result in an immediate completion without any calls to the provided combiner function.\r\n\r\nNote that there are several overloads to be considered in both `Flowable` and `Observable`."
      }
    ]
  },
  {
    "number": 5411,
    "title": "Must be called from main thread of process",
    "created_at": "2017-06-14T02:40:47Z",
    "closed_at": "2017-07-05T22:22:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5411",
    "body": "```java\r\npublic static <T> ObservableTransformer<T, T> applySchedulers(final IView view) {\r\n        return new ObservableTransformer<T, T>() {\r\n            @Override\r\n            public Observable<T> apply(Observable<T> observable) {\r\n                return observable.subscribeOn(Schedulers.io())\r\n                        .doOnSubscribe(disposable -> {\r\n                            view.showLoading();//显示进度条\r\n                        })\r\n                        .subscribeOn(AndroidSchedulers.mainThread())\r\n                        .observeOn(AndroidSchedulers.mainThread())\r\n                        .doAfterTerminate(() -> {\r\n                            view.hideLoading();//隐藏进度条\r\n                        }).compose(RxUtils.bindToLifecycle(view));\r\n            }\r\n        };\r\n    }\r\n```\r\n\r\n外面调用   \r\n```java\r\nmModel.getEndCityModelList(new Gson().toJson(map)).compose(RxUtils.applySchedulers(mRootView)).map(new BaseEntity<>()).subscribe(new CommonDisposableObserver<>(new HttpOnNextListener<List<CityModel>>() {\r\n            @Override\r\n            public void onNext(List<CityModel> cityModels) {\r\n                setLetter(cityModels);\r\n                if (adapter == null) {\r\n                    adapter = new SelectCityAdapter(cityModels);\r\n                    mRootView.setAdapter(adapter);\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onFail(int code, String msg) {\r\n                checkCode(code, msg, mAppManager);\r\n            }\r\n        }));\r\n```\r\n总是报错Must be called from main thread of process，不知道哪里的问题",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5411/comments",
    "author": "hekaidaqaz",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-14T07:34:32Z",
        "body": "I can't understand what you are saying. Please translate your problem into English."
      },
      {
        "user": "aaronweihe",
        "created_at": "2017-06-14T15:28:46Z",
        "body": "The OP was asking why the code would run into this `IllegalStateException: Must be called from main thread of process`.\r\n\r\nI guess the problem was the `view.showLoading();` was executed on io thread, so moving the `doOnSubscribe` call after the `observeOn(AndroidSchedulers.mainThread())` would be the easiest fix."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-14T16:35:34Z",
        "body": "Thanks @aaronhe42!"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-05T22:22:12Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5410,
    "title": "Fatal Exception: java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.",
    "created_at": "2017-06-13T09:20:02Z",
    "closed_at": "2017-07-19T10:00:44Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5410",
    "body": "```\r\nFatal Exception: java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\r\nat rx.internal.schedulers.ScheduledAction.run(MyApplication:62)\r\nat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:423)\r\nat java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\nat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:269)\r\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\r\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\r\nat java.lang.Thread.run(Thread.java:818)\r\nCaused by java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask@c5c7b27 rejected from java.util.concurrent.ScheduledThreadPoolExecutor@33009e6[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 1]\r\nat java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2014)\r\nat java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:794)\r\nat java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute(ScheduledThreadPoolExecutor.java:302)\r\nat java.util.concurrent.ScheduledThreadPoolExecutor.schedule(ScheduledThreadPoolExecutor.java:527)\r\nat java.util.concurrent.ScheduledThreadPoolExecutor.submit(ScheduledThreadPoolExecutor.java:626)\r\nat rx.internal.schedulers.NewThreadWorker.scheduleActual(MyApplication:239)\r\nat rx.internal.schedulers.NewThreadWorker.schedule(MyApplication:224)\r\nat rx.internal.schedulers.NewThreadWorker.schedule(MyApplication:216)\r\nat rx.internal.operators.OperatorSubscribeOn$1$1$1.request(MyApplication:82)\r\nat rx.Subscriber.request(MyApplication:157)\r\nat rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(MyApplication:225)\r\nat rx.internal.schedulers.ScheduledAction.run(MyApplication:55)\r\nat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:423)\r\nat java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\nat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:269)\r\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\r\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\r\nat java.lang.Thread.run(Thread.java:818)\r\n```\r\n\r\nI have updated retrofit library to ` 'com.squareup.retrofit2:retrofit:2.0.2'`, app is working fine at the time of development and debug. After publishing the app on prod this appeared on 'Crashlytics' very frequent. \r\nI have no  idea about it. Ask me for any help.\r\nThese are the dependencies \r\n`compile 'com.squareup.retrofit2:retrofit:2.0.2'\r\n compile 'com.squareup.retrofit2:adapter-rxjava:2.0.2'\r\n compile 'io.reactivex:rxandroid:1.0.1@aar'`\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5410/comments",
    "author": "vijay-pal",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-13T09:51:36Z",
        "body": "What exact RxJava version are you using and what is the code look like? This somewhat looks like an unsubscription/emission race due to screen rotation."
      },
      {
        "user": "vijay-pal",
        "created_at": "2017-06-13T10:07:16Z",
        "body": "I am using `rxandroid:1.0.1` with retrofit `retrofit2:adapter-rxjava:2.0.2`, \r\nAnd calling http request look like \r\n\r\n```java\r\nsubscription = service.getApi()\r\n      .getToolExamList(jsonString)\r\n      .subscribeOn(Schedulers.newThread())\r\n      .observeOn(Schedulers.computation())\r\n      .retryWhen(new RetryWithDelay(Constants.MAX_RETRIES, Constants.MAX_DELAY)).unsubscribeOn(Schedulers.newThread())\r\n      .subscribe(new Observer<String>() {\r\n        @Override\r\n        public void onCompleted() {\r\n          if (listener != null)\r\n            new Handler(Looper.getMainLooper()).post(new Runnable() {\r\n              @Override\r\n              public void run() {\r\n                listener.stopProgressBar();\r\n              }\r\n            });\r\n        }\r\n\r\n        @Override\r\n        public void onError(final Throwable error) {\r\n          if (listener != null) {\r\n            new Handler(Looper.getMainLooper()).post(new Runnable() {\r\n              @Override\r\n              public void run() {\r\n                listener.stopProgressBar();\r\n                listener.onError(error, jsonString);\r\n              }\r\n            });\r\n          }\r\n        }\r\n\r\n        @Override\r\n        public void onNext(String response) {\r\n          if (listener != null) {\r\n            listener.onResponse(response);\r\n          }\r\n\r\n        }\r\n      });\r\n```\r\n\r\nAnd unsubscribes call when Activity destroy by \r\n\r\n```java\r\n  @Override\r\n  public void onDestroy() {\r\n    super.onDestroy();\r\n    if (mPresenter != null) {\r\n      mPresenter.unSubscribe();\r\n    }\r\n  }` \r\n`@Override\r\n  public boolean isUnSubscribe() {\r\n    return subscription == null || subscription.isUnsubscribed();\r\n  }\r\n\r\n  @Override\r\n  public void unSubscribe() {\r\n    if (!isUnSubscribe()) {\r\n      subscription.unsubscribe();\r\n    }\r\n  }\r\n``` "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-13T10:27:48Z",
        "body": "Please use the latest versions of those libraries."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-19T10:00:44Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5404,
    "title": "Propose emit NoSuchElementException in SingleFromCallable on empty callable result",
    "created_at": "2017-06-09T13:23:20Z",
    "closed_at": "2017-06-09T14:45:04Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5404",
    "body": "RxJava version: 2.1.0\r\n\r\nI propose emit NoSuchElementException instead NPE in SingleFromCallable on empty callable result because it is more logically. For example class MaybeToSingle throws NoSuchElementException (not NPE).",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5404/comments",
    "author": "ultraon",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-09T13:57:38Z",
        "body": "It signals NPE because you are not supposed to return `null`. Null doesn't hold any semantic indication about whether it means emptiness or a bug. You can, however, design a wrapper that turns a null into NSE:\r\n\r\n```java\r\npublic static <T> Callable<T> nullToNSE(Callable<T> call) {\r\n    return () -> {\r\n       T t = call.call();\r\n       if (t == null) {\r\n           throw new NoSuchElementException();\r\n       }\r\n       return t;\r\n    };\r\n}\r\n```"
      },
      {
        "user": "ultraon",
        "created_at": "2017-06-09T14:45:04Z",
        "body": "I agree with you after reading java.util.concurrent.Callable JavaDoc for call() method: Computes a result, or throws an exception if unable to do so."
      }
    ]
  },
  {
    "number": 5402,
    "title": "combineLatest with Iterable  not work ",
    "created_at": "2017-06-08T19:46:08Z",
    "closed_at": "2017-06-11T07:07:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5402",
    "body": "What I am currently using:\r\n```\r\nObservable.combineLatest(countsObslist,objects -> {\r\n            Log.d(\"Rx\",\"check\");\r\n            for (Object obj:objects) {\r\n                if(((CharSequence)obj).length()>0){\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }).subscribe(aBoolean -> RxView.enabled(btnOder).accept(aBoolean));\r\n```\r\ncountsObslist is List<Observable<CharSequence>> type\r\n\r\nthis funtion can not run correctly.....",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5402/comments",
    "author": "benlinx1018",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-08T20:06:21Z",
        "body": "What exactly are you trying to achieve and what is it that doesn't work?"
      },
      {
        "user": "benlinx1018",
        "created_at": "2017-06-09T00:25:30Z",
        "body": "I want to subscribe all edittext in  list view\r\nif anyone has value,enable button\r\n\r\nusing follow code subscribe the edittext and add to list:\r\n\r\n`  countsObslist.add(RxTextView.textChanges(viewHolder.edtTxtCount));`"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-09T07:23:55Z",
        "body": "`combineLatest` acts only if all sources have emitted an item. You have to start the sources with some default value to get it going:\r\n\r\n```java\r\ncountsObslist.add(RxTextView.textChanges(viewHolder.edtTxtCount).startWith(\"\"));\r\n```"
      },
      {
        "user": "benlinx1018",
        "created_at": "2017-06-11T07:07:47Z",
        "body": "Thanks, I see"
      }
    ]
  },
  {
    "number": 5400,
    "title": "2.x - xxxOrError documentation is not clear.",
    "created_at": "2017-06-07T20:07:09Z",
    "closed_at": "2017-07-05T22:27:49Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5400",
    "body": "The documentation for any lastOrError/firstOrError/... is confusing about the error case.\r\nI got confused by the case where an error occurs during the processing.\r\n\r\nFor example in lastOrError, it does not state what happens when the observable emits an error itself. Do we get the last emitted item before the error ? Do we get the error ?\r\n\r\n(I wrote some simple test cases to ensure of the result and I now know how it works though 😀)",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5400/comments",
    "author": "saiimons",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-07T20:16:55Z",
        "body": "Since they return `Single`, they can't emit a value and an error together as those events are mutually exclusive."
      },
      {
        "user": "saiimons",
        "created_at": "2017-06-07T20:22:12Z",
        "body": "@akarnokd not really my point, sorry if my english makes it not so clear. I had trouble understanding whether lastOrError would be \"last item emitted before observable completes or fails\" or just \"last item emitted before observable completes\""
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-07T20:33:58Z",
        "body": "We avoid swallowing errors and `Single` never signals `onSuccess` and `onError` together thus: last item emitted before the `Observable` completes. The general theme with RxJava is that you get errors eagerly often skipping ahead of items (unless the operator supports error-delaying option)."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-05T22:27:49Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5398,
    "title": "Execute specific (automatic) actions when the client un/subscribe to Flowable.",
    "created_at": "2017-06-06T19:07:33Z",
    "closed_at": "2017-07-05T22:22:39Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5398",
    "body": "I was trying to create a `Flowable` that is connected to a source when the client subscribes, and disconnect from the source when the client unsubscribes.\r\n\r\nI tried first using a custom `Flowable`, in this way:\r\n\r\n```\r\npublic final class SensorEventFlowable extends Flowable<RxSensorEvent> {\r\n\r\n    private final SensorManager sensorManager;\r\n    private final Sensor sensor;\r\n    private final int samplingPeriodUs;\r\n\r\n    SensorEventFlowable(SensorManager sensorManager, Sensor sensor, int samplingPeriodUs) {\r\n        this.sensorManager = sensorManager;\r\n        this.sensor = sensor;\r\n        this.samplingPeriodUs = samplingPeriodUs;\r\n    }\r\n\r\n    @Override\r\n    protected void subscribeActual(Subscriber<? super RxSensorEvent> subscriber) {\r\n        Listener listener = new Listener(sensorManager, subscriber);\r\n        subscriber.onSubscribe(listener);\r\n        sensorManager.registerListener(listener, sensor, samplingPeriodUs);\r\n    }\r\n\r\n    static final class Listener implements Subscription, SensorEventListener {\r\n        private final SensorManager sensorManager;\r\n        private final Subscriber<? super RxSensorEvent> subscriber;\r\n\r\n        Listener(SensorManager sensorManager, Subscriber<? super RxSensorEvent> subscriber) {\r\n            this.sensorManager = sensorManager;\r\n            this.subscriber = subscriber;\r\n        }\r\n\r\n        @Override\r\n        public void onSensorChanged(SensorEvent event) {\r\n            subscriber.onNext(new RxSensorEvent(event));\r\n        }\r\n\r\n        @Override\r\n        public void request(long n) { }\r\n\r\n        @Override\r\n        public void cancel() {\r\n            sensorManager.unregisterListener(this);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\nbut I was suggested to use `Flowable.create()` instead. So I tried to use it:\r\n\r\n```\r\npublic final class SensorEventFlowableFactory {\r\n\r\n    public static Flowable<RxSensorEvent> create(SensorManager sensorManager, Sensor sensor, int samplingPeriodUs) {\r\n        return Flowable.create(e -> {\r\n            Listener listener = new Listener(e);\r\n            sensorManager.registerListener(listener, sensor, samplingPeriodUs);\r\n        }, BackpressureStrategy.MISSING);\r\n    }\r\n\r\n    static final class Listener implements SensorEventListener {\r\n        private final FlowableEmitter<RxSensorEvent> emitter;\r\n\r\n        Listener(FlowableEmitter<RxSensorEvent> emitter) {\r\n            this.emitter = emitter;\r\n        }\r\n\r\n        @Override\r\n        public void onSensorChanged(SensorEvent event) {\r\n            emitter.onNext(new RxSensorEvent(event));\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\nI have some doubts about this code:\r\n\r\n1. In the first implementation I have `cancel` method that will execute `sensorManager.unregisterListener(this);`. How can I make this happens in the second implementation? (when the client unsubscribe from the flowable). I don't want the client to be aware about this.\r\n\r\n2. Actually, if I am not wrong, the method `sensorManager.registerListener(listener, sensor, samplingPeriodUs);` is called when the Flowable is created, and not when the client subscribe. Is that correct? If so, where do I need to place that call (registerListner) in order to be executed only if and when the client subscribes?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5398/comments",
    "author": "Joseph82",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2017-06-06T19:14:09Z",
        "body": "You can set a cancelation action (callback) on the `e` param. And no, the lambda is invoked once per subscriber when they subscribe."
      },
      {
        "user": "Joseph82",
        "created_at": "2017-06-06T19:18:33Z",
        "body": "Oh, cool! It works fine :) Thank you @JakeWharton "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-05T22:22:39Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5392,
    "title": "RxJava 2.1.0 SerialDisposable#isDisposed() return false for Disposables#disposed() initial value",
    "created_at": "2017-06-05T12:35:17Z",
    "closed_at": "2017-06-05T13:37:29Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5392",
    "body": "Consider following code:\r\n```java\r\nSerialDisposable disposable = new SerialDisposable(Disposables.disposed());\r\nif (disposable.isDisposed()) {\r\n   // do somesing\r\n}\r\n```\r\nI wanted to set my initial value to be disposed and thought ```isDispossed()``` will return ```true``` for ```Disposable``` returned from ```Disposables.disposed()```, but it actually returns ```false```. Find out thats because ```SerialDisposable#isDisposed()``` just check if current ```Disposable``` equals to ```DisposableHelper#DISPOSED```, which is weird. So to fix this I have to go with this:\r\n```java\r\nSerialDisposable disposable = new SerialDisposable(DisposableHelper.DISPOSED);\r\nif (disposable.isDisposed()) {\r\n   // do somesing\r\n}\r\n```\r\nIs this intended behavior? If so, can you please explicitly indicate this in the documentation?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5392/comments",
    "author": "bejibx",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-05T13:14:30Z",
        "body": "> Is this intended behavior?\r\n\r\nYes. The containers don't care of the actual state of what they contain and if they did, that would disrupt the state of the system. For example, if a Disposable in the CompositeDisposable container is disposed, should the the CompositeDisposable report itself as disposed despite all other content not being disposed? Also containers act as a deferred cancellation mechanism so having a disposes content doesn't mean the end of life since that disposed item can be replaced by a non-disposed item any time and continue.\r\n\r\n> If so, can you please explicitly indicate this in the documentation?\r\n\r\nTrying to prevent all those possible misunderstandings or mis-assumptions via documentation is infeasible, especially in a free and open-source project where you can find out and experiment with the code on your own to clear up your understanding. I firmly think this question and the original assumptions behind it are not suitable for explicit mention in the documentation."
      },
      {
        "user": "bejibx",
        "created_at": "2017-06-05T13:37:29Z",
        "body": "It seems I just misunderstood ```SerialDisposable``` concept. Sorry about that.\r\n\r\n> Trying to prevent all those possible misunderstandings or mis-assumptions via documentation is infeasible, especially in a free and open-source project where you can find out and experiment with the code on your own to clear up your understanding.\r\n\r\nNot quite agree with that. Having this little clarification in documentation would have saved me about 2 hours trying to understand why my app behave so strange. There could be another developers who may at first misunderstood how ```SerialDisposable``` behaves.\r\n\r\nAnyway, closing this issue. Again, sorry for bother you.\r\n"
      }
    ]
  },
  {
    "number": 5388,
    "title": "RxJava 2: LambdaObserver.onNext() attempts propagate error to disposed observer",
    "created_at": "2017-06-01T19:12:00Z",
    "closed_at": "2017-07-05T22:21:45Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5388",
    "body": "Hi!\r\nVersion rxjava is 2.1.0.\r\nMay be error or dead code in method onNext of LambdaObserver:\r\n\r\n    @Override\r\n    public void onNext(T t) {\r\n        if (!isDisposed()) {\r\n            try {\r\n                onNext.accept(t);\r\n            } catch (Throwable e) {\r\n                Exceptions.throwIfFatal(e);\r\n                get().dispose();    <-- Observer is disposed\r\n                onError(e);  <-- Here does attempt to propagate error, however onError() check state of observer and do nothing.\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5388/comments",
    "author": "master-den",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-01T19:34:27Z",
        "body": "I'm pretty sure there is a unit test that proves the contrary. `get().dispose()` disposes the this' content but the `isDisposed` uses `DisposableHelper.isDisposed` that essentially checks for the this' content for reference equality with `DisposableHelper.DISPOSED`."
      },
      {
        "user": "master-den",
        "created_at": "2017-06-06T21:42:43Z",
        "body": "Thanks for answer.\r\nIt inspired me to deep research our code. And I found in our code where a subscribtion was disposed rather by time that onError() will be invoked from LambdaObserver.onNext(). Thus, the problem of swallowed exception is in our architecture of app."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-05T22:21:45Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5387,
    "title": "How to add obfuscation in RxJava2",
    "created_at": "2017-06-01T09:14:43Z",
    "closed_at": "2017-06-07T07:53:46Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5387",
    "body": "",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5387/comments",
    "author": "sushanqiang",
    "comments": [
      {
        "user": "vanniktech",
        "created_at": "2017-06-01T09:18:13Z",
        "body": "You don't need any proguard rules."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-07T07:53:46Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5380,
    "title": "How to abort map() with long running operation after unsubscribe?",
    "created_at": "2017-05-30T21:33:50Z",
    "closed_at": "2017-07-05T22:23:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5380",
    "body": "Hi,\r\nI am writing to a file (with a while loop) in map().\r\n\r\n I want to cancel this request, so I unsubscribe from the observable, onNext does not come as expected, _however the while cycle in map() keeps going_. \r\n\r\nIs there a way I can have the while loop break upon unsubscribe with map() or do I have to flatmap and create custom observable and check for isUnsubscribe somehow?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5380/comments",
    "author": "ursusursus",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-30T21:42:40Z",
        "body": "How does your loop look like? Maybe it can be turned into `range`, `fromIterable` or a generator that gets cancelled if run from within `flatMap` or `concatMap`."
      },
      {
        "user": "ursusursus",
        "created_at": "2017-05-30T21:46:29Z",
        "body": "Its a download of file, so the usual: getting the inputstream and writing it to fileoutputstream\r\n\r\n```\r\n...\r\nwhile ((bytesRead = is.read(buffer)) > 0) {\r\n   fos.write(buffer, 0, bytesRead);\r\n}\r\n... \r\nreturn filePath\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-30T21:59:09Z",
        "body": "Maybe the simplest way to gain access to a cancellation indicator is to have this code inside a `Observable.create()`:\r\n\r\n```java\r\nObservable.just(file)\r\n.flatMap(f ->\r\n    Observable.create(emitter -> {\r\n         // ...\r\n         while ((bytesRead = is.read(buffer)) > 0 && !emitter.isDisposed()) {\r\n            fos.write(buffer, 0, bytesRead);\r\n         }\r\n         if (!emitter.isDisposed()) {\r\n             emitter.onNext(filePath);\r\n             emitter.onComplete();\r\n         }\r\n    })\r\n)\r\n.subscribeOn(Schedulers.io())\r\n.subscribe(...);"
      },
      {
        "user": "ursusursus",
        "created_at": "2017-05-30T22:20:08Z",
        "body": "Thanks, that was my plan B.\r\n\r\n// Offtopic, how can I have a \"task queue\" which completes when all work is done in rxjava? (it should enqueue new tasks if they came while task was processing; and should complete when all work is done). For now I have PublishSubject with concatMap for the backpressure, works as I need however it obviously never completes. I know I can have just() and mergeWith(subject) but I would like it to start from the same method, now \"enqueue\" methods needs to see if the stream is running and choose just() or subject.onNext() which I would like to abstract away in rxjava. Is this somehow possible?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-30T22:26:27Z",
        "body": "> obviously never completes\r\n\r\nCall `onComplete` on the `PublishSubject` and it will complete once all previous items have been processed."
      },
      {
        "user": "ursusursus",
        "created_at": "2017-05-30T22:29:30Z",
        "body": "Yes, but thats what I was hoping rx would do somehow by it self. \r\nSo the only way is to keep a hashmap of queued tasks manually?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-30T22:32:01Z",
        "body": "> when all work is done\r\n\r\nHow do you know that there is no more work being submitted to the task queue?"
      },
      {
        "user": "ursusursus",
        "created_at": "2017-05-30T22:34:46Z",
        "body": "What I would imagine is that concatMap could somehow query its backpressure buffer (im no rx expert, i just assume there is a buffer since it concats backpressured things) and emit onComplete if there is none"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-30T22:38:37Z",
        "body": "It's unclear to me what you try to achieve. Perhaps you should ask this question on Stackoverflow, especially if you target platform is Android."
      },
      {
        "user": "ursusursus",
        "created_at": "2017-05-30T22:45:45Z",
        "body": "I dont think the platform matters. Im trying to create a stream which processes stuff and then completes. However you can add a new tasks onto it while it is running via subject (therefore stream should process this emission next (via concatmap) and only then terminate\r\n\r\nIn other words, I want to also complete the stream in subscriber.onNext if concatMap has nothing in buffer"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-05T22:23:30Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5375,
    "title": "2.0.9 possible bug with Maybe.switchIfEmpty ",
    "created_at": "2017-05-29T11:55:42Z",
    "closed_at": "2017-05-29T12:29:09Z",
    "labels": [
      "Question",
      "2.x",
      "Kotlin"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5375",
    "body": "So, not sure if it's a bug or am I not using the operator right.\r\n\r\n    Maybe.empty<Int>()\r\n            .switchIfEmpty { Maybe.just(2) }\r\n            .subscribe {\r\n                println(\"got $it\")\r\n            }\r\n\r\nBlock above completes without any results as if `Maybe` is empty. While block below completes successfully with `got 2` output.\r\n\r\n    Maybe.empty<Int>()\r\n            .switchIfEmpty(Maybe.just(2))\r\n            .subscribe {\r\n                println(\"got $it\")\r\n            }\r\n\r\nFrom documentation I expect, that both cases should work the same.\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5375/comments",
    "author": "mjurkus",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-29T12:03:10Z",
        "body": "The first case creates a lambda that does nothing, courtesy of Kotlin I guess. If written out in Java syntax:\r\n\r\n```java\r\n.switchIfEmpty(mo -> { Maybe.just(2); })\r\n```\r\n\r\nwhere you are supposed to signal on `mo` according to the `Maybe` protocol but you just create and throw away a `Maybe` instance."
      },
      {
        "user": "mjurkus",
        "created_at": "2017-05-29T12:27:41Z",
        "body": "You're right, but, lambda does something.\r\n`.switchIfEmpty { ... }` creates `MaybeSource` where `subscribe` is executed and `Maybe.just(2)` is created, but nothing happens after that.\r\nso in this case:\r\n`.switchIfEmpty { it.onSuccess(2) }` and `.switchIfEmpty(Maybe.just(2))` are the same.\r\n\r\nThanks for pointing out my mistake."
      }
    ]
  },
  {
    "number": 5374,
    "title": "[Newbie] Observable.interval Tick till set time or till flag is set",
    "created_at": "2017-05-29T04:26:08Z",
    "closed_at": "2017-05-29T11:27:00Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5374",
    "body": "I need to wait for a condition or timeout. I came up with the following approach, but there are too many things happening. How can i compress it\r\n\r\n```Java\r\nimport io.reactivex.Observable;\r\nimport java.util.concurrent.TimeUnit;\r\nimport io.reactivex.schedulers.Schedulers;\r\nimport java.util.concurrent.atomic.AtomicBoolean;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\n\r\npublic class Test{\r\n  public static void main(String[] args)throws InterruptedException{\r\n    AtomicBoolean toggle = new java.util.concurrent.atomic.AtomicBoolean(true);\r\n\r\n     Observable.interval(0,50, TimeUnit.MILLISECONDS)\r\n                .takeWhile(l->l<(20000/50))\r\n                .takeWhile(l-> toggle.get())\r\n                .observeOn(Schedulers.io())\r\n                .map(l->{ return (l>ThreadLocalRandom.current().nextInt(5, 20 + 1))?true:false;})\r\n                 // The above map will call a remote function to check for some condition\r\n                .observeOn(Schedulers.computation())\r\n                .filter(exist->exist)\r\n                //.takeWhile(exist->!exist)\r\n                .map(l->{toggle.set(false);return l;})\r\n                .map(l->{System.out.println(\"Called at \"+l);return l;})\r\n                .blockingSubscribe();\r\n  }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5374/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-29T07:41:57Z",
        "body": "Here are a couple of hints:\r\n\r\n- Combine the logical expressions of the two `takeWhile`.\r\n- The comparison against the random number already yields a boolean value, you don't need the `?:`.\r\n- Use `doOnNext` to have side-effects instead of `map` and combine the two into a single lambda expression.\r\n- You may want to replace `filter` with `takeUntil` and you no longer need the `toggle` field as the sequence can stop after the first `true` received."
      }
    ]
  },
  {
    "number": 5368,
    "title": "1.x Can't figure out from crash report where the bad code is",
    "created_at": "2017-05-25T15:25:31Z",
    "closed_at": "2017-05-25T17:55:44Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5368",
    "body": "I have 35K crashes in my crashlytics dashboard all pointing to one single stacktrace but I can't find the offending code. I have rxjava all over the code so it's not easy to track. Can someone help me reconstruct the rx chain from the stacktrace?\r\n\r\nWhat I deduce from the stack trace is that onErrorResumeNext() with Observable.empty() is being called and somewhere down the chain there is a first() operator without a default and that is the reason it crashes. But I can't find such a chain in my code. I know that behind the scenes the operators may be different so maybe the stacktrace is pointing to a different operator chain?\r\n\r\nI would appreciate any hint as the crash numbers are sky rocketing but I can't reproduce the crash on my devices.\r\n\r\nPS: Is there some tool I can use to have a more relevant rxjava stacktrace in my crashlytics?\r\n\r\n```\r\nCaused by java.util.NoSuchElementException: Sequence contains no elements\r\n       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:115)\r\n       at rx.internal.operators.OperatorTake$1.onCompleted(OperatorTake.java:56)\r\n       at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onCompleted(OnSubscribeFilter.java:99)\r\n       at rx.observers.SerializedObserver.onCompleted(SerializedObserver.java:176)\r\n       at rx.observers.SerializedSubscriber.onCompleted(SerializedSubscriber.java:64)\r\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:246)\r\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:209)\r\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)\r\n       at rx.internal.operators.OnSubscribeDoOnEach$DoOnEachSubscriber.onCompleted(OnSubscribeDoOnEach.java:70)\r\n       at rx.internal.operators.OnSubscribeMap$MapSubscriber.onCompleted(OnSubscribeMap.java:97)\r\n       at rx.internal.operators.OperatorOnErrorResumeNextViaFunction$4.onCompleted(OperatorOnErrorResumeNextViaFunction.java:101)\r\n       at rx.internal.operators.OnSubscribeDoOnEach$DoOnEachSubscriber.onCompleted(OnSubscribeDoOnEach.java:70)\r\n       at rx.internal.operators.OnSubscribeMap$MapSubscriber.onCompleted(OnSubscribeMap.java:97)\r\n       at rx.internal.operators.OnSubscribeRedo$4$1.onCompleted(OnSubscribeRedo.java:321)\r\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:656)\r\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\r\n       at rx.internal.operators.OperatorMerge$InnerSubscriber.onCompleted(OperatorMerge.java:857)\r\n       at rx.internal.operators.OperatorDelay$1$1.call(OperatorDelay.java:59)\r\n       at rx.internal.schedulers.EventLoopsScheduler$EventLoopWorker$2.call(EventLoopsScheduler.java:189)\r\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\r\n       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390)\r\n       at java.util.concurrent.FutureTask.run(FutureTask.java:234)\r\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153)\r\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267)\r\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)\r\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)\r\n       at java.lang.Thread.run(Thread.java:841)\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5368/comments",
    "author": "kaciula",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-25T15:52:55Z",
        "body": "Not likely without the code base or enabling `RxJavaHooks.enableAssemblyTracking()` in your app at the end user. You can somewhat deduce a chain of operations from the trace:\r\n\r\nconcat(map -> doOnEach) -> filter -> take -> single"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-25T17:34:19Z",
        "body": "Another way that doesn't destroy performance that much is to replace all uses of `single()` with a transformer that allows setting a tag and adds that to the message when an onError is passing by:\r\n\r\n```java\r\nObservable.Transformer<T, T> withTag(String tag) {\r\n    return o -> o.single().onErrorResumeNext(e -> {\r\n        if (e instanceof NoSuchElementException) {\r\n           e = new NoSuchElementException(tag + \": \" + e.getMessage(), e);\r\n        }\r\n        return Observable.error(e);\r\n    });\r\n}\r\n\r\n//\r\nsource.op()\r\n.op()\r\n.compose(withTag(\"Doing business #1\"))\r\n.op()\r\n...\r\n```"
      },
      {
        "user": "kaciula",
        "created_at": "2017-05-25T17:41:12Z",
        "body": "I don't use single() at all in my code but I do use last() (in just one place) which behind the scenes does takeLast(1).single() so I'm guessing this could be it. And the crashes start from the version I introduced this chain. Here is the pseudocode:\r\n\r\n```\r\nList<Observable<?>> observables = new ArrayList<>();\r\nObservable<?> stream1 = ...;\r\nobservables.add(stream1);\r\nObservable<?> stream2 = ...;\r\nobservables.add(stream2);\r\n....\r\nObservable<?> stream10 = ...;\r\nobservables.add(stream10);\r\n\r\nObservable.concat(observables).last().subscribe(...);\r\n```\r\n\r\nSo I am trying to run 10 API calls in sequence and wait until all of them are completed. Is there a more standard way to achieve this? Initially I was running each API call through a concatMap so I would have a chain of 10 concatMap() but for some reason (can't remember why) I changed it to this. It seems more elegant..."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-25T17:47:15Z",
        "body": "If you don't care about the value, use `ignoreElements`, otherwise use `lastOrDefault` to avoid the crash."
      },
      {
        "user": "kaciula",
        "created_at": "2017-05-25T17:55:44Z",
        "body": "OK. Using lastOrDefault hides the error but does not fix the underlying issue. I will use the withTag() trick to pinpoint the exact source of the problem and get to the bottom of this.\r\n\r\nThank you for engaging with me."
      }
    ]
  },
  {
    "number": 5364,
    "title": "2.x Flowable.fromIterable(items) How to interrupt the iterator emission data?",
    "created_at": "2017-05-24T11:22:40Z",
    "closed_at": "2017-08-06T22:27:55Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5364",
    "body": "Flowable.fromIterable(items) how to interrupt the iterator emission data in flatmap ?\r\n\r\n```java\r\nFlowable.fromIterable(items)\r\n    .flatMap(new Function<IconInfo, Publisher<IconInfoBody>>() {\r\n        @Override\r\n        public Publisher<IconInfoBody> apply(IconInfo appInfo) throws Exception {\r\n               //I want to interrupt the iterator emission data\r\n        }\r\n    })\r\n```\r\n\r\nthank you!",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5364/comments",
    "author": "jdsjlzx",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-01T11:46:15Z",
        "body": "What do you mean by interrupt? Have you looked at the `takeWhile`/`takeUntil` operators?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-06T22:27:55Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5360,
    "title": "RxJava 1.x Event Bus with sticky events",
    "created_at": "2017-05-23T06:12:33Z",
    "closed_at": "2017-06-16T09:07:23Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5360",
    "body": "I am using an event bus, which was linked on Square's Otto library page\r\n\r\n    public class RxBus<T> {\r\n    \r\n        private final Subject<T, T> bus = new SerializedSubject<>(PublishSubject.create());\r\n    \r\n        public void send(T object) {\r\n            bus.onNext(object);\r\n        }\r\n    \r\n        public Observable<T> toObservable() {\r\n            return bus;\r\n        }\r\n    \r\n    }\r\n\r\n\r\nIt was working well until I tried sending an event from Activity to Fragment (Android). It didn't work because the fragment wasn't created when I sent the event. Is there a way to add sticky events in RxBus, something like in GreenRobot's EventBus. Any ideas and hints about how I can do it would be great :)",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5360/comments",
    "author": "sourabhv",
    "comments": [
      {
        "user": "I60R",
        "created_at": "2017-05-23T06:23:39Z",
        "body": "You don't need event bus with RxJava. Try with BehaviorSubject or ReplaySubject instead"
      },
      {
        "user": "sourabhv",
        "created_at": "2017-05-23T06:31:02Z",
        "body": "No, I didn't say I am using any event bus. In the code above, I am using `PublishSubject`. But I doubt ReplaySubject will serve the purpose, I don't want every event to be streamed to new subscribers. `BehaviorSubject` won't work either I think. ReplaySubject can work if there's a way to flush the whole subject after use. Is there a way to do it?"
      },
      {
        "user": "I60R",
        "created_at": "2017-05-23T06:37:14Z",
        "body": "Yes, you can use `take(1)` operator. \r\n\r\n*P.S:* It's not good idea to use ReplaySubject, because all events will be stored in memory. BehaviorSubject stores only last"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-07T07:58:38Z",
        "body": "`UnicastSubject` let's you cache items until a single `Subscriber` subscribes to it and doesn't retain elements. Note, however, that it doesn't support multiple `Subscriber`s."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-16T09:07:23Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5359,
    "title": "How can i swallow the error and do nothing when an error occurs ?",
    "created_at": "2017-05-23T01:57:40Z",
    "closed_at": "2017-07-05T22:21:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5359",
    "body": "How can i dispose the disposable when an error occurs ? Because i want to swallow the error and do nothing ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5359/comments",
    "author": "tata8k",
    "comments": [
      {
        "user": "I60R",
        "created_at": "2017-05-23T06:25:54Z",
        "body": "onErrorResumeNext(Observable.emtpy()) should work"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-05T22:21:20Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5352,
    "title": "2.x: buffer() with limit and timeout not restarting timer",
    "created_at": "2017-05-18T03:13:19Z",
    "closed_at": "2017-07-05T22:11:15Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5352",
    "body": "I have an Observable delivering events every 500ms. I buffer this with the following code:\r\n\r\n`    return dataObservable.buffer(EmaxData.DATA_TIMEOUT, EmaxData.DATA_TIMEOUT_UNIT,\r\n            Schedulers.computation(), 1, ArrayListSupplier.asCallable(), true);`\r\n\r\nwhere DATA_TIMEOUT is 2000ms.\r\nThe intention is that with normal data flow a List of one data element will be delivered as soon as each upstream data item is received. If the data flow is interrupted for more than 2s a zero-length list will be delivered to announce data loss to the observer.\r\n\r\nEven though I have set the `restartTimerOnMaxSize` I get one zero-length list every 2s, interspersed with the normal data.\r\n\r\nI'm running this on Android, and observation is on the main thread. If I build the application (from exactly the same source code) for iOS using RoboVM the spurious empty list items do not occur.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5352/comments",
    "author": "clydebarrow",
    "comments": [
      {
        "user": "clydebarrow",
        "created_at": "2017-05-18T03:20:43Z",
        "body": "Log trace showing timestamps:\r\n\r\n 2017-05-18 13:18:23 Gauges: Data length 1 at time 3300\r\n\r\n 2017-05-18 13:18:23 Gauges: Data length 1 at time 3827\r\n\r\n2017-05-18 13:18:24 Gauges: Data length 1 at time 4330\r\n\r\n2017-05-18 13:18:24 Gauges: Data length 1 at time 4825\r\n\r\n2017-05-18 13:18:24 Gauges: Data length 0 at time 4896\r\n\r\nNote the last (empty) entry only 71ms after the previous valid one. This pattern repeats every 2s.\r\nThis behaviour is what I would expect if the `restartTimerOnMaxSize` flag was false, but I have confirmed in the debugger that it is true.\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-18T08:16:30Z",
        "body": "Hi. A couple of questions:\r\n\r\n- Which version of RxJava 2 are you using?\r\n- This is the canonical test for the 1 buffer restart case. Does it work for you?\r\n\r\n```java\r\nTestScheduler scheduler = new TestScheduler();\r\n\r\nPublishSubject<Integer> ps = PublishSubject.create();\r\n\r\nTestObserver<List<Integer>> to = ps\r\n.buffer(100, TimeUnit.MILLISECONDS, scheduler, 1, Functions.<Integer>createArrayList(16), true)\r\n.test();\r\n\r\nscheduler.advanceTimeBy(50, TimeUnit.MILLISECONDS);\r\n\r\nps.onNext(1);\r\n\r\nto.assertValue(Arrays.asList(1));\r\n\r\nscheduler.advanceTimeBy(51, TimeUnit.MILLISECONDS);\r\n\r\nto.assertValue(Arrays.asList(1));\r\n\r\nscheduler.advanceTimeBy(50, TimeUnit.MILLISECONDS);\r\n\r\nto.assertValues(Arrays.asList(1), Collections.<Integer>emptyList());\r\n\r\nscheduler.advanceTimeBy(50, TimeUnit.MILLISECONDS);\r\n\r\nps.onNext(1);\r\n\r\nto.assertValues(Arrays.asList(1), Collections.<Integer>emptyList(), Arrays.asList(1));\r\n\r\nscheduler.advanceTimeBy(51, TimeUnit.MILLISECONDS);\r\n\r\nto.assertValues(Arrays.asList(1), Collections.<Integer>emptyList(), Arrays.asList(1));\r\n\r\nscheduler.advanceTimeBy(50, TimeUnit.MILLISECONDS);\r\n\r\nto.assertValues(Arrays.asList(1), Collections.<Integer>emptyList(), Arrays.asList(1), \r\n    Collections.<Integer>emptyList());\r\n```\r\n\r\n- If not, can you provide an unit test that demonstrates your problem?\r\n"
      },
      {
        "user": "clydebarrow",
        "created_at": "2017-05-19T21:44:00Z",
        "body": "The version I'm using is 2.0.8. however I'll have to study the unit test posted above to convince myself it covers my case. I will try fiddling with the test and report back."
      },
      {
        "user": "clydebarrow",
        "created_at": "2017-05-23T11:42:53Z",
        "body": "I have not been able to construct a unit test that fails in the same way - similar code run on the build host seems to work fine. I have worked around the problem by measuring the time between events:\r\n\r\n        disposable = observable.subscribe(\r\n            emaxData -> {\r\n                if(emaxData.size() == 0) {\r\n                    CJLog.logMsg(\"Got empty buffer %f seconds after last valid buffer\", (System.currentTimeMillis()-lastTime)/1000f);\r\n                    CJLog.logMsg(\"Observing on Thread %s\", Thread.currentThread().toString());\r\n                    if(System.currentTimeMillis() > lastTime + 1500)    // TODO - fix the problem with buffer\r\n                        Gauges.this.setInvalid();\r\n                } else {\r\n                    lastTime = System.currentTimeMillis();\r\n                    Gauges.this.updateValues(emaxData.get(0));\r\n                }\r\n            },\r\n            throwable -> {\r\n                CJLog.logException(throwable);\r\n                Gauges.this.setInvalid();\r\n            },\r\n            () -> {\r\n                CJLog.logMsg(\"onComplete called\");\r\n                Gauges.this.setInvalid();\r\n            }\r\n        );\r\n \r\nAnd this is sample log output (the buffer timeout is set to 2 seconds and you'll note the empty buffers are 2 seconds apart.)\r\n\r\n      2017-05-23 20:42:18 Gauges: Got empty buffer 0.122000 seconds after last valid buffer\r\n     2017-05-23 20:42:18 Gauges: Observing on Thread Thread[RxComputationThreadPool-3,5,main]\r\n     2017-05-23 20:42:20 Gauges: Got empty buffer 0.124000 seconds after last valid buffer\r\n     2017-05-23 20:42:20 Gauges: Observing on Thread Thread[RxComputationThreadPool-3,5,main]\r\n\r\n\r\n\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-05T22:11:15Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      },
      {
        "user": "clydebarrow",
        "created_at": "2018-03-28T09:37:54Z",
        "body": "Following up on this - the problem appears to be that the Observable had been subscribed to twice. It's not clear to me why this produced the symptoms it did but fixing this seems to have made the problem go away."
      }
    ]
  },
  {
    "number": 5349,
    "title": "2.0.8 flowableOnSubscribe onNext not working",
    "created_at": "2017-05-17T10:33:20Z",
    "closed_at": "2017-05-19T06:48:28Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5349",
    "body": "```java\r\nFlowable<List<String>> flowable = Flowable.just(Arrays.asList(\"one\",\"two\",\"three\"));\r\n\t\tflowable.subscribe(new FlowableSubscriber() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onComplete() {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\tSystem.out.println(\"completed\");\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onError(Throwable arg0) {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onNext(Object arg0) {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\tSystem.out.println((String)arg0);\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onSubscribe(Subscription arg0) {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\tSystem.out.println(\"on subscribe\");\r\n\t\t\t}\r\n\t\t});\r\n```\r\n\r\nflowableOnSubscribe onNext and onComplete not working,only onSubscribe is working",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5349/comments",
    "author": "mithunkumarc",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-17T11:03:11Z",
        "body": "You should call `Subscription.request(n)` to have the data start flowing."
      },
      {
        "user": "mithunkumarc",
        "created_at": "2017-05-19T06:48:25Z",
        "body": "@akarnokd Correct asnwer. Thanks."
      }
    ]
  },
  {
    "number": 5342,
    "title": "2.x: withLatestFrom() doesn't return the latest value",
    "created_at": "2017-05-15T11:55:22Z",
    "closed_at": "2017-05-15T19:39:02Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5342",
    "body": "Version of RxJava - `2.1.0`. Here is an example which involves use of `PublishSubject`:\r\n\r\n```\r\n// Subject is used to communicate changes in the model\r\nPublishSubject modelSubject = PublishSubject.create();\r\nmodelSubject.subscribe(model -> {\r\n    editText.setText(model.value());   // this will cause a new event in the stream below\r\n});\r\n\r\n// Observing changes in the form\r\nRxTextView.afterTextChangeEvents(editText)\r\n     .takeUntil(RxView.detaches(parent))\r\n     .filter(event -> event.editable() != null)\r\n     .withLatestFrom(modelSubject, (event, model) -> {\r\n          return Pair.create(event, model);\r\n     })\r\n     .filter(pair -> {\r\n         return !pair.val0().editable().toString()\r\n             .equals(String.valueOf(pair.val1().value()));\r\n         })\r\n     .debounce(512, TimeUnit.MILLISECONDS)\r\n     .map(pair -> RowAction.create(pair.val1().uid(),\r\n            pair.val0().editable().toString()))\r\n     .subscribe(processor::onNext, throwable -> {\r\n            throw new OnErrorNotImplementedException(throwable);\r\n      });\r\n```\r\n\r\nAs you can see, `modelSubject` here can trigger events in the `RxTextView.afterTextChangeEvents(editText)` stream, meaning that consequent call to the `.withLatestFrom()` should return the value which caused the event in the stream. \r\n\r\nIt is quite interesting that for the first event emitted by `RxTextView.afterTextChangeEvents(editText)`, `withLatestFrom()` captures correct model value. Let's say that we push second model through subject which triggers another event in `editText` observable. Instead of pulling newest model instance from `modelSubject`, `.withLatestFrom()` returns an old value which is not relevant anymore. ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5342/comments",
    "author": "arazabishov",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-15T12:11:34Z",
        "body": "There are two subscribers to the `modelSubject` of which the first one triggers a text event change synchronously before the second subscriber is notified, thus when the `withLatestFrom` is reached you'll have the old model. Swap the two `subscribe()` calls which should make sure `withLatestFrom` is notified first.\r\n\r\nAlternatively, consider using `BehaviorSubject` and `map` by mapping in the `BehaviorSubject.getValue()` instead of `withLatestFrom`.\r\n\r\n```java\r\nBehaviorSubject modelSubject = BehaviorSubject.create();\r\n\r\n .map(event -> {\r\n      return Pair.create(event, modelSubject.getValue());\r\n })\r\n```"
      },
      {
        "user": "arazabishov",
        "created_at": "2017-05-15T19:39:02Z",
        "body": "Thank you very much for pointing out the problem with synchronicity. "
      }
    ]
  },
  {
    "number": 5338,
    "title": "2.x TestObserver form Maybe.just(...).test() asserts complete",
    "created_at": "2017-05-11T20:46:28Z",
    "closed_at": "2017-07-05T22:11:59Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5338",
    "body": "RxJava 2.0.7\r\nAccording to\r\n> RxJava 2.0.0-RC2 introduced a new base reactive type called Maybe . . . if there is only a single value to be signalled, only onSuccess is called and onComplete is not.\r\n\r\nI assume that  `Maybe.just(\"SomeValue\").test().assertNotComplete()` will pass the test. But it doesn't.\r\nWith this example(above) output: `AssertionError: Completed! (latch = 0, values = 1, errors = 0, completions = 1)`",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5338/comments",
    "author": "prokhorovri",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-11T21:54:08Z",
        "body": "For simplicity, there are no separate test consumers for `Single` and `Maybe` but the `TestObserver` delegates to `onNext` & `onComplete`. The typical tests are then performed via `assertResult()` for empty, `assertResult(T)` for single element responses and `assertFailure()` for errors."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-05T22:11:59Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5336,
    "title": "java.lang.NoClassDefFoundError: io.reactivex.Flowable",
    "created_at": "2017-05-11T03:00:09Z",
    "closed_at": "2017-05-15T12:58:04Z",
    "labels": [
      "Question",
      "Android",
      "2.x",
      "StackOverflow"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5336",
    "body": "I use compile 'io.reactivex.rxjava2:rxjava:2.1.0' compile 'io.reactivex.rxjava2:rxandroid:2.0.1' in my app.gradle  , my app run is ok.\r\n\r\nbut for the project-request, i should use these jar from my project lib, so i download it from maven, and put it into my-project /lib , and rewrite app.gradle      compile files('lib/rxjava-2.1.0.jar')  compile(name: 'rxandroid-2.0.1', ext: 'aar') ,\r\nmy code \r\n\r\n```java\r\nObservable.create(new ObservableOnSubscribe<String>() {\r\n\r\n           @Override\r\n           public void subscribe(@NonNull ObservableEmitter<String> observableEmitter) throws Exception {\r\n               Log.i(TAG,\"subcribe method\");\r\n               ..........\r\n               observableEmitter.onNext(result);\r\n\r\n           }\r\n       }).subscribeOn(Schedulers.io())\r\n               .observeOn(AndroidSchedulers.mainThread())\r\n               .subscribe(new Observer<String>() {\r\n\r\n            @Override\r\n            public void onSubscribe(@NonNull Disposable disposable) {\r\n                Log.i(TAG,\"onSubscribe\");\r\n            }\r\n\r\n            @Override\r\n            public void onNext(@NonNull String s) {\r\n                        Log.i(TAG,\"onNext login result s:\"+s);\r\n                        check_login_result(s);\r\n            }\r\n\r\n            @Override\r\n            public void onError(@NonNull Throwable throwable) {\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onComplete() {\r\n\r\n            }\r\n        });\r\n```\r\n\r\nwhen it run, it will crash ,and log is\r\n```\r\nE/AndroidRuntime(28386): java.lang.NoClassDefFoundError: io.reactivex.Flowable\r\nE/AndroidRuntime(28386): \tat io.reactivex.Observable.bufferSize(Observable.java:126)\r\nE/AndroidRuntime(28386): \tat io.reactivex.Observable.observeOn(Observable.java:8545)\r\n...................\r\nE/AndroidRuntime(28386): \tat android.view.View.performClick(View.java:4438)\r\nE/AndroidRuntime(28386): \tat android.view.View$PerformClick.run(View.java:18438)\r\nE/AndroidRuntime(28386): \tat android.os.Handler.handleCallback(Handler.java:733)\r\nE/AndroidRuntime(28386): \tat android.os.Handler.dispatchMessage(Handler.java:95)\r\nE/AndroidRuntime(28386): \tat android.os.Looper.loop(Looper.java:136)\r\nE/AndroidRuntime(28386): \tat android.app.ActivityThread.main(ActivityThread.java:5008)\r\nE/AndroidRuntime(28386): \tat java.lang.reflect.Method.invokeNative(Native Method)\r\nE/AndroidRuntime(28386): \tat java.lang.reflect.Method.invoke(Method.java:515)\r\nE/AndroidRuntime(28386): \tat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:807)\r\nE/AndroidRuntime(28386): \tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:623)\r\nE/AndroidRuntime(28386): \tat dalvik.system.NativeStart.main(Native Method)\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5336/comments",
    "author": "yangmao1986",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-11T07:24:35Z",
        "body": "Your project setup is likely wrong and I don't understand why you can't go with the default gradle dependency setup. Also you should ask this question on StackOverflow where more experienced Android developers frequent."
      },
      {
        "user": "originx",
        "created_at": "2017-05-11T09:25:05Z",
        "body": "This seems like a proguard issue and not related to RxJava itself.\r\nYou have to check if your proguard is cleaning up more stuff than it should and how does it behave with your custom jar, and adapt the rules, especially if that jar has something changed compared to the standard rx lib.\r\nNormally you dont need specific proguard rules for 2.x but like akarnokd said this is an Android problem and not an Rx one and is related to proguard and/or multidex."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-15T12:58:04Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      },
      {
        "user": "TrillGates",
        "created_at": "2017-05-26T02:34:01Z",
        "body": "Change  observeOn(AndroidSchedulers.mainThread()) to  .observeOn(AndroidSchedulers.mainThread(),false,100),It would be work out,God bless  you!"
      }
    ]
  },
  {
    "number": 5335,
    "title": "Single produces Flowables and Observables",
    "created_at": "2017-05-09T08:18:24Z",
    "closed_at": "2017-05-09T08:37:52Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5335",
    "body": "When I used Single.concat I was confused that I suddenly had a Flowable. Why is that no Observable? \r\nIt also seems inconsistent with `Observable.concat` where both just produce an Observable.\r\n\r\n```java\r\n    /**\r\n     * Concatenate the single values, in a non-overlapping fashion, of the Single sources provided by\r\n     * an Iterable sequence.\r\n     * <dl>\r\n     *  <dt><b>Backpressure:</b><dt>\r\n     *  <dd>The returned {@code Flowable} honors the backpressure of the downstream consumer.</dd>\r\n     * <dt><b>Scheduler:</b></dt>\r\n     * <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.</dd>\r\n     * </dl>\r\n     * @param <T> the value type\r\n     * @param sources the Iterable sequence of SingleSource instances\r\n     * @return the new Flowable instance\r\n     * @since 2.0\r\n     */\r\n    @CheckReturnValue\r\n    @SchedulerSupport(SchedulerSupport.NONE)\r\n    @BackpressureSupport(BackpressureKind.FULL)\r\n    public static <T> Flowable<T> concat(Iterable<? extends SingleSource<? extends T>> sources) {\r\n        return concat(Flowable.fromIterable(sources));\r\n    }\r\n\r\n    /**\r\n     * Concatenate the single values, in a non-overlapping fashion, of the Single sources provided by\r\n     * an Observable sequence.\r\n     * <dl>\r\n     * <dt><b>Scheduler:</b></dt>\r\n     * <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.</dd>\r\n     * </dl>\r\n     * @param <T> the value type\r\n     * @param sources the ObservableSource of SingleSource instances\r\n     * @return the new Observable instance\r\n     * @since 2.0\r\n     */\r\n    @CheckReturnValue\r\n    @SchedulerSupport(SchedulerSupport.NONE)\r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    public static <T> Observable<T> concat(ObservableSource<? extends SingleSource<? extends T>> sources) {\r\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\r\n        return RxJavaPlugins.onAssembly(new ObservableConcatMap(sources, SingleInternalHelper.toObservable(), 2, ErrorMode.IMMEDIATE));\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5335/comments",
    "author": "PaulWoitaschek",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-09T08:35:38Z",
        "body": "Because you can unbound them via `toObservable` without dataloss or buffer bloat but the other direction is not true."
      }
    ]
  },
  {
    "number": 5329,
    "title": "2.x Completable stops the chain",
    "created_at": "2017-05-02T12:57:35Z",
    "closed_at": "2017-05-02T17:28:18Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5329",
    "body": "I discovered that once Completable is done (method of `CompletableEmitter.onComplete()` is called), the chain stops and all operators are not called. \r\n\r\nSo I have the following source code\r\n```\r\nCompletable setup() {\r\n...\r\n}\r\n....\r\n            payment.setup()\r\n                          .toObservable()\r\n                          .flatMap(new Function<Object, ObservableSource<List<String>>() {\r\n                                       @Override\r\n                                       public ObservableSource<String>> apply(@io.reactivex.annotations.NonNull Object o) throws Exception {\r\n                                           return \"Some mapping is here\";\r\n                                       }\r\n                                   });\r\n```\r\n\r\nOnce `setup()` method finished successfully, `flatMap()` is not called. Is it supposed to be so? Is it possible to have a chain to Completable?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5329/comments",
    "author": "dkhmelenko",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-02T13:02:22Z",
        "body": "`Completable` does not have values and `flatMap` doesn't work without values. Use `Completable.andThen`."
      },
      {
        "user": "dkhmelenko",
        "created_at": "2017-05-02T17:28:18Z",
        "body": "Perfect. Thanks! "
      }
    ]
  },
  {
    "number": 5327,
    "title": "doOnTerminal and doFinally not called in delay operator",
    "created_at": "2017-05-02T05:04:05Z",
    "closed_at": "2017-06-16T09:19:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5327",
    "body": "rxjava 2.1.0\r\n```\r\nObservable.just(\"Alex\").delay(1000, TimeUnit.MILLISECONDS)\r\n                .doOnSubscribe(new LiteConsumer<Disposable>() {\r\n                    @Override\r\n                    public void onNext(Disposable result) {\r\n                        LogTrack.e(\"only called in delay operator\");\r\n                    }\r\n                })\r\n                .doOnTerminate(new Action() {\r\n                    @Override\r\n                    public void run() throws Exception {\r\n                        LogTrack.e(\" not called\");\r\n                    }\r\n                })\r\n                .doFinally(new Action() {\r\n                    @Override\r\n                    public void run() throws Exception {\r\n                        LogTrack.e(\"not called\");\r\n                    }\r\n                })\r\n                .subscribe(new LiteObserver<String>() {\r\n                    @Override\r\n                    public void onNext(String result) {\r\n                        LogTrack.e(result);\r\n                    }\r\n                });\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5327/comments",
    "author": "tata8k",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-02T06:33:09Z",
        "body": "You are not waiting long enough to see the value. Sleep in the main thread."
      },
      {
        "user": "tata8k",
        "created_at": "2017-05-02T07:03:29Z",
        "body": "@akarnokd how long I should wait ?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-02T07:32:54Z",
        "body": "There is a correlation between the delay amount and how long should you wait..."
      },
      {
        "user": "gaemi",
        "created_at": "2017-05-09T01:44:19Z",
        "body": "@UsherBaby For example, use the code below.\r\n```java\r\n// your code\r\nObservable.just(\"Alex\").delay(1000, TimeUnit.MILLISECONDS)\r\n                .doOnSubscribe(new LiteConsumer<Disposable>() {\r\n                    @Override\r\n                    public void onNext(Disposable result) {\r\n                        LogTrack.e(\"only called in delay operator\");\r\n                    }\r\n                })\r\n                .doOnTerminate(new Action() {\r\n                    @Override\r\n                    public void run() throws Exception {\r\n                        LogTrack.e(\" not called\");\r\n                    }\r\n                })\r\n                .doFinally(new Action() {\r\n                    @Override\r\n                    public void run() throws Exception {\r\n                        LogTrack.e(\"not called\");\r\n                    }\r\n                })\r\n                .subscribe(new LiteObserver<String>() {\r\n                    @Override\r\n                    public void onNext(String result) {\r\n                        LogTrack.e(result);\r\n                    }\r\n                });\r\n\r\n// insert this code\r\nTimeUnit.SECONDS.sleep(2000);\r\n```\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-16T09:19:49Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5321,
    "title": "2.x. Subject does not emit items",
    "created_at": "2017-04-28T13:58:27Z",
    "closed_at": "2017-05-02T06:40:43Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5321",
    "body": "`compile 'io.reactivex.rxjava2:rxjava:2.0.9'`\r\n\r\nIt seems like subscribing inside `doOnSubcribe` leads to `subject` swallowing and not emitting items\r\n\r\n```\r\nfinal Observable<String> testActionObservable = Observable.just(\"test1\");\r\n        final Observable<String> testAction2Observable = Observable.just(\"test2\");\r\n        final Observable<String> actions = Observable.merge(testActionObservable, testAction2Observable);\r\n\r\n        final PublishSubject<String> subject = PublishSubject.create();\r\n\r\n        final Consumer<String> actionConsumer = new Consumer<String>() {\r\n            @Override\r\n            public void accept(String action) throws Exception {\r\n                System.out.println(\"accept \" + Thread.currentThread().getName());\r\n                subject.onNext(action);\r\n            }\r\n        };\r\n\r\n        final DisposableObserver<String> disposableObserver = new DisposableObserver<String>() {\r\n            @Override\r\n            public void onNext(String s) {\r\n                System.out.println(s);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable throwable) {\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onComplete() {\r\n\r\n            }\r\n        };\r\n\r\n        final Consumer<Disposable> onSubscribe = new Consumer<Disposable>() {\r\n            @Override\r\n            public void accept(Disposable disposable) throws Exception {\r\n                System.out.println(\"onSubscribe \" + Thread.currentThread().getName());\r\n                actions.subscribe(actionConsumer);\r\n            }\r\n        };\r\n\r\n        subject\r\n            .doOnSubscribe(onSubscribe)\r\n            .subscribe(disposableObserver);\r\n```\r\n\r\nEmits\r\n\r\n```\r\nonSubscribe main\r\naccept main\r\naccept main\r\n```\r\n\r\nbut things starts to work then subscription to `actions` is moved after subscription to `subject` \r\n\r\n```\r\nfinal Observable<String> testActionObservable = Observable.just(\"test1\");\r\n        final Observable<String> testAction2Observable = Observable.just(\"test2\");\r\n        final Observable<String> actions = Observable.merge(testActionObservable, testAction2Observable);\r\n\r\n        final PublishSubject<String> subject = PublishSubject.create();\r\n\r\n        final Consumer<String> actionConsumer = new Consumer<String>() {\r\n            @Override\r\n            public void accept(String action) throws Exception {\r\n                System.out.println(\"accept \" + Thread.currentThread().getName());\r\n                subject.onNext(action);\r\n            }\r\n        };\r\n\r\n        final DisposableObserver<String> disposableObserver = new DisposableObserver<String>() {\r\n            @Override\r\n            public void onNext(String s) {\r\n                System.out.println(s);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable throwable) {\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onComplete() {\r\n\r\n            }\r\n        };\r\n\r\n        final Consumer<Disposable> onSubscribe = new Consumer<Disposable>() {\r\n            @Override\r\n            public void accept(Disposable disposable) throws Exception {\r\n                System.out.println(\"onSubscribe \" + Thread.currentThread().getName());\r\n\r\n            }\r\n        };\r\n\r\n        subject\r\n            .doOnSubscribe(onSubscribe)\r\n            .subscribe(disposableObserver);\r\n\r\n        actions.subscribe(actionConsumer);\r\n```\r\n\r\nemits\r\n\r\n```\r\nonSubscribe main\r\naccept main\r\ntest1\r\naccept main\r\ntest2\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5321/comments",
    "author": "palaima",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-28T14:15:47Z",
        "body": "When `onSubscribe` is executing from a `Subject`, the `Observer` is not yet visible to the `Subject` and any calls to `onNext` will never reach the `Observer`. This ensures that there can't be any concurrent calls to `onSubscribe` and `onNext` when the subscription happens."
      }
    ]
  },
  {
    "number": 5320,
    "title": "Disposable from doOnSubscribe cannot be used by CompositeDisposable to dispose",
    "created_at": "2017-04-27T19:10:42Z",
    "closed_at": "2017-05-02T02:28:10Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5320",
    "body": "compile 'io.reactivex.rxjava2:rxjava:2.0.1'\r\n\r\nThe following code will never finish because doOnDispose is never called.\r\n\r\n```java\r\n      final CountDownLatch latch = new CountDownLatch(2);\r\n      final CompositeDisposable allSubscriptions = new CompositeDisposable();\r\n      Observable\r\n         .just(1,2,3)\r\n         .observeOn(Schedulers.from(Executors.newSingleThreadExecutor()))\r\n         .doOnSubscribe(disposable -> {\r\n            allSubscriptions.add(disposable);\r\n            latch.countDown();\r\n         })\r\n         .doOnDispose(() -> latch.countDown())\r\n         .subscribe();\r\n\r\n      allSubscriptions.clear();\r\n      try {\r\n         latch.await();\r\n      } catch (InterruptedException e) {\r\n         e.printStackTrace();\r\n      }\r\n```\r\n\r\nBut this works fine\r\n\r\n```java\r\n      final CountDownLatch latch = new CountDownLatch(2);\r\n      final CompositeDisposable allSubscriptions = new CompositeDisposable();\r\n      allSubscriptions.add(\r\n         Observable\r\n            .just(1,2,3)\r\n            .observeOn(Schedulers.from(Executors.newSingleThreadExecutor()))\r\n            .doOnSubscribe(disposable -> latch.countDown())\r\n            .doOnDispose(() -> latch.countDown())\r\n            .subscribe()\r\n      );\r\n\r\n      allSubscriptions.clear();\r\n\r\n      try {\r\n         latch.await();\r\n      } catch (InterruptedException e) {\r\n         e.printStackTrace();\r\n      }\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5320/comments",
    "author": "amphora001",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-27T19:43:41Z",
        "body": "You are disposing in the middle of the sequence in the first example; cancellation/dispose always travels upstream."
      },
      {
        "user": "amphora001",
        "created_at": "2017-04-27T21:22:43Z",
        "body": "so what's the proper way to chain Observables so that they get added to a CompositeDisposable? The 2nd example is ugly."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-27T22:08:22Z",
        "body": "That's the correct way; take the `Disposable` returned by the `subscribe` method or the `DisposableObserver` and dispose that. The chain will automatically propagate the dispose call up the chain. You never had to save the individual `Disposable`s within the chain in the first place."
      }
    ]
  },
  {
    "number": 5314,
    "title": "The following error confuse packaging is complete, run times",
    "created_at": "2017-04-25T02:19:52Z",
    "closed_at": "2017-04-27T08:30:57Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5314",
    "body": "```\r\nProcess: www.pingyuan.yangplay, PID: 8040\r\nreactivex.exceptions.OnErrorNotImplementedException\r\n at io.reactivex.internal.functions.Functions$14.accept(Unknown Source)\r\n at io.reactivex.internal.functions.Functions$14.accept(Unknown Source)\r\n at io.reactivex.internal.observers.LambdaObserver.onError(Unknown Source)\r\n at io.reactivex.internal.observers.LambdaObserver.onNext(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmitScalar(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableBuffer$BufferExactObserver.onNext(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmit(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onNext(Unknown Source)\r\n at io.reactivex.observers.SerializedObserver.onNext(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver$InnerObserver.onNext(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver.drain(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver.onSubscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFromIterable.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableConcatMap.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmitScalar(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFromArray$FromArrayDisposable.run(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFromArray.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableBuffer.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at www.pingyuan.yangplay.ui.activity.MainActivity.j(Unknown Source)\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5314/comments",
    "author": "AndroidAndYang",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-25T08:24:27Z",
        "body": "You are using `subscribe(Consumer<T>)` instead of `subscribe(Consumer<T>, Consumer<Throwable>)` and your `Consumer<T>` crashes."
      },
      {
        "user": "AndroidAndYang",
        "created_at": "2017-04-26T09:43:09Z",
        "body": "Thanks"
      }
    ]
  },
  {
    "number": 5312,
    "title": "Disposable state in onComplete",
    "created_at": "2017-04-23T06:03:45Z",
    "closed_at": "2017-06-16T09:18:52Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5312",
    "body": "Hello! Version of RxJava is 2.0.9.\r\nIn my app I use ```Disposable```'s state to determine if some work is done or still running.\r\nI noticed, that in ```onComplete``` callback ```Single```'s ```Disposable``` returns ```true``` from isDisposed while ```Completable```'s ```Disposable``` returns ```false```.\r\n\r\nDoes it correct? Or I should not rely on ```Disposable``` state in ```onComplete``` callback?\r\n\r\nCode sample:\r\n```\r\nimport io.reactivex.Completable\r\nimport io.reactivex.Single\r\nimport io.reactivex.disposables.Disposable\r\nimport io.reactivex.schedulers.Schedulers\r\n\r\nfun main(args: Array<String>) {\r\n\r\n    var sin_disposable: Disposable? = null\r\n    sin_disposable = Single.just(34)\r\n            .subscribeOn(Schedulers.computation())\r\n            .observeOn(Schedulers.io())\r\n            .subscribe { _, _ ->\r\n                println(\"sin 1 ${sin_disposable?.isDisposed}\")\r\n            }\r\n    println(\"sin 2 ${sin_disposable?.isDisposed}\")\r\n\r\n    var сom_disposable: Disposable? = null\r\n    сom_disposable = Completable.complete()\r\n            .subscribeOn(Schedulers.computation())\r\n            .observeOn(Schedulers.io())\r\n            .subscribe({\r\n                println(\"сom 1 ${сom_disposable?.isDisposed} completed\")\r\n            }, { e ->\r\n                println(\"сom 1 ${сom_disposable?.isDisposed} error $e\")\r\n            })\r\n    println(\"сom 2 ${сom_disposable?.isDisposed}\")\r\n\r\n    Thread.sleep(1000)\r\n    println(\"sin 3 ${sin_disposable?.isDisposed}\")\r\n    println(\"сom 3 ${сom_disposable?.isDisposed}\")\r\n\r\n}\r\n```\r\n\r\nOutput is:\r\n```\r\nsin 2 false\r\nsin 1 true\r\nсom 2 false\r\nсom 1 false completed\r\nsin 3 true\r\nсom 3 true\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5312/comments",
    "author": "qwert2603",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-23T08:20:16Z",
        "body": "Relying on such external `isDisposed` is not recommended and is considered a non-reactive thinking. The Completable.subscribe() sets the disposed state after the callback, probably because some test wants to call dispose that propagates upstream."
      },
      {
        "user": "qwert2603",
        "created_at": "2017-04-23T14:01:51Z",
        "body": "Thanks for reply. I'll rethink some things in my app to avoid relying on ```isDisposed```."
      }
    ]
  },
  {
    "number": 5311,
    "title": "Confusing about request() method in a custom Flowable",
    "created_at": "2017-04-22T12:16:44Z",
    "closed_at": "2017-05-04T09:17:41Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5311",
    "body": "Let's say I create a custom `Flowable`:\r\n\r\n```\r\npublic final class CustomFlowable extends Flowable<Integer> {\r\n\r\n    @Override\r\n    protected void subscribeActual(Subscriber subscriber) {\r\n        Listener listener = new Listener(subscriber);\r\n        subscriber.onSubscribe(listener);\r\n    }\r\n\r\n    static final class Listener implements Subscription {\r\n        private final Subscriber<Integer> subscriber;\r\n\r\n\r\n        Listener(Subscriber<Integer> subscriber) {\r\n            this.subscriber = subscriber;\r\n        }\r\n\r\n       public void onSensorChanged(SensorEvent event) {\r\n            subscriber.onNext(event));\r\n        }\r\n\r\n        @Override\r\n        public void request(long n) {\r\n            // how to deal with this method?\r\n        }\r\n\r\n        @Override\r\n        public void cancel() {\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nI have no clue about how to implement the `request(long n)` method in order to handle gracefully the backpressure. \r\nMy guess it is that when the `request()` method is called, I should send a number of items equals to `n` . But, should I stop in the meantime the normal stream of data coming from external source ( sensors)?\r\nDo I have a way for accessing the items in the queue and call a sequence of `onNext()` for those items? ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5311/comments",
    "author": "Joseph82",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-22T12:20:36Z",
        "body": "There is rarely any reason to implement custom Flowables. Why do you want it? Based on the naming, you should be using `Flowable.create()` instead."
      },
      {
        "user": "Joseph82",
        "created_at": "2017-04-22T13:04:25Z",
        "body": "With `Flowable.create()` I have to define a `BackpressureStrategy` (as second parameter). \r\n\r\nWhat if I want to let the user to define a different backpressure strategy? "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-22T13:21:50Z",
        "body": "There is the `BackpressureStrategy.MISSING` and the requirement that the consumer applies one of the `onBackpressureX` operators."
      },
      {
        "user": "Joseph82",
        "created_at": "2017-04-22T13:25:26Z",
        "body": "Ok. I wasn't sure about the meaning of `MISSING`. \r\n\r\nI'll try to switch to a Flowable created with `Flowable.create()`.\r\n\r\nThank you."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-04T09:17:40Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5298,
    "title": "exception = java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.",
    "created_at": "2017-04-20T02:47:32Z",
    "closed_at": "2017-04-20T08:22:34Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5298",
    "body": "2017-04-19 20:31:07,660\tERROR/CrashHandler:\t__   __        __            /  /  /\r\n2017-04-19 20:31:07,661\tERROR/CrashHandler:\t/  ` |__)  /\\  /__` |__|     /  /  / \r\n2017-04-19 20:31:07,662\tERROR/CrashHandler:\t\\__, |  \\ /~~\\ .__/ |  |    .  .  . \r\n2017-04-19 20:31:07,704\tERROR/CrashHandler:\tversionName: 3.1.0\r\n2017-04-19 20:31:07,705\tERROR/CrashHandler:\tversionCode: 2017041901\r\n2017-04-19 20:31:07,706\tERROR/CrashHandler:\tDeviceInfo[BOARD] : msm8939\r\n2017-04-19 20:31:07,706\tERROR/CrashHandler:\tDeviceInfo[BOOTLOADER] : 3.19.0.0000\r\n2017-04-19 20:31:07,707\tERROR/CrashHandler:\tDeviceInfo[BRAND] : htc\r\n2017-04-19 20:31:07,707\tERROR/CrashHandler:\tDeviceInfo[CPU_ABI] : armeabi-v7a\r\n2017-04-19 20:31:07,708\tERROR/CrashHandler:\tDeviceInfo[CPU_ABI2] : armeabi\r\n2017-04-19 20:31:07,708\tERROR/CrashHandler:\tDeviceInfo[DEVICE] : htc_a52dtul\r\n2017-04-19 20:31:07,708\tERROR/CrashHandler:\tDeviceInfo[DISPLAY] : LRX22G release-keys\r\n2017-04-19 20:31:07,709\tERROR/CrashHandler:\tDeviceInfo[FINGERPRINT] : htc/a52dtul_htccn_chs_2/htc_a52dtul:5.0.2/LRX22G/583966.7:user/release-keys\r\n2017-04-19 20:31:07,709\tERROR/CrashHandler:\tDeviceInfo[HARDWARE] : qcom\r\n2017-04-19 20:31:07,710\tERROR/CrashHandler:\tDeviceInfo[HOST] : ABM031\r\n2017-04-19 20:31:07,710\tERROR/CrashHandler:\tDeviceInfo[ID] : LRX22G\r\n2017-04-19 20:31:07,710\tERROR/CrashHandler:\tDeviceInfo[MANUFACTURER] : HTC\r\n2017-04-19 20:31:07,710\tERROR/CrashHandler:\tDeviceInfo[MODEL] : HTC D826w\r\n2017-04-19 20:31:07,711\tERROR/CrashHandler:\tDeviceInfo[PRODUCT] : a52dtul_htccn_chs_2\r\n2017-04-19 20:31:07,711\tERROR/CrashHandler:\tDeviceInfo[RADIO] : unknown\r\n2017-04-19 20:31:07,711\tERROR/CrashHandler:\tDeviceInfo[SERIAL] : CC53GYG13444\r\n2017-04-19 20:31:07,712\tERROR/CrashHandler:\tDeviceInfo[SUPPORTED_32_BIT_ABIS] : [Ljava.lang.String;@1f283846\r\n2017-04-19 20:31:07,712\tERROR/CrashHandler:\tDeviceInfo[SUPPORTED_64_BIT_ABIS] : [Ljava.lang.String;@11697a07\r\n2017-04-19 20:31:07,713\tERROR/CrashHandler:\tDeviceInfo[SUPPORTED_ABIS] : [Ljava.lang.String;@35814734\r\n2017-04-19 20:31:07,713\tERROR/CrashHandler:\tDeviceInfo[TAG] : Build\r\n2017-04-19 20:31:07,714\tERROR/CrashHandler:\tDeviceInfo[TAGS] : release-keys\r\n2017-04-19 20:31:07,714\tERROR/CrashHandler:\tDeviceInfo[TYPE] : user\r\n2017-04-19 20:31:07,714\tERROR/CrashHandler:\tDeviceInfo[UNKNOWN] : unknown\r\n2017-04-19 20:31:07,715\tERROR/CrashHandler:\tDeviceInfo[USER] : buildteam\r\n2017-04-19 20:31:07,715\tERROR/CrashHandler:\tDeviceInfo[IS_DEBUGGABLE] : false\r\n2017-04-19 20:31:07,716\tERROR/CrashHandler:\tDeviceInfo[TIME] : 1439482856000\r\n2017-04-19 20:31:07,716\tERROR/CrashHandler:\tDeviceInfo[STAGE] : 2\r\n2017-04-19 20:31:07,717\tERROR/CrashHandler:\tUncaughtException, THREAD: Thread[main,5,main] NAME: main ID: 1\r\n2017-04-19 20:31:07,717\tERROR/CrashHandler:\t**** STACKTRACE BEGIN ****\r\n2017-04-19 20:31:07,717\tERROR/CrashHandler:\texception = java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\r\n2017-04-19 20:31:07,718\tERROR/CrashHandler:\tat rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:112)\r\n2017-04-19 20:31:07,718\tERROR/CrashHandler:\tat android.os.Handler.handleCallback(Handler.java:739)\r\n2017-04-19 20:31:07,718\tERROR/CrashHandler:\tat android.os.Handler.dispatchMessage(Handler.java:95)\r\n2017-04-19 20:31:07,718\tERROR/CrashHandler:\tat android.os.Looper.loop(Looper.java:155)\r\n2017-04-19 20:31:07,719\tERROR/CrashHandler:\tat android.app.ActivityThread.main(ActivityThread.java:5702)\r\n2017-04-19 20:31:07,719\tERROR/CrashHandler:\tat java.lang.reflect.Method.invoke(Method.java:-2)\r\n2017-04-19 20:31:07,720\tERROR/CrashHandler:\tat java.lang.reflect.Method.invoke(Method.java:372)\r\n2017-04-19 20:31:07,720\tERROR/CrashHandler:\tat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1029)\r\n2017-04-19 20:31:07,720\tERROR/CrashHandler:\tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:824)\r\n2017-04-19 20:31:07,721\tERROR/CrashHandler:\t**** STACKTRACE END **** \r\n2017-04-19 20:31:07,721\tERROR/CrashHandler:\t**** CAUSE BEGIN ****\r\n2017-04-19 20:31:07,722\tERROR/CrashHandler:\tgetCause() = rx.exceptions.OnErrorNotImplementedException\r\n2017-04-19 20:31:07,722\tERROR/CrashHandler:\tat rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:386)\r\n2017-04-19 20:31:07,722\tERROR/CrashHandler:\tat rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:383)\r\n2017-04-19 20:31:07,723\tERROR/CrashHandler:\tat rx.internal.util.ActionSubscriber.onError(ActionSubscriber.java:44)\r\n2017-04-19 20:31:07,723\tERROR/CrashHandler:\tat rx.observers.SafeSubscriber._onError(SafeSubscriber.java:152)\r\n2017-04-19 20:31:07,724\tERROR/CrashHandler:\tat rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\r\n2017-04-19 20:31:07,724\tERROR/CrashHandler:\tat rx.exceptions.Exceptions.throwOrReport(Exceptions.java:205)\r\n2017-04-19 20:31:07,724\tERROR/CrashHandler:\tat rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:139)\r\n2017-04-19 20:31:07,725\tERROR/CrashHandler:\tat rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:227)\r\n2017-04-19 20:31:07,725\tERROR/CrashHandler:\tat rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:107)\r\n2017-04-19 20:31:07,725\tERROR/CrashHandler:\tat android.os.Handler.handleCallback(Handler.java:739)\r\n2017-04-19 20:31:07,726\tERROR/CrashHandler:\tat android.os.Handler.dispatchMessage(Handler.java:95)\r\n2017-04-19 20:31:07,726\tERROR/CrashHandler:\tat android.os.Looper.loop(Looper.java:155)\r\n2017-04-19 20:31:07,726\tERROR/CrashHandler:\tat android.app.ActivityThread.main(ActivityThread.java:5702)\r\n2017-04-19 20:31:07,727\tERROR/CrashHandler:\tat java.lang.reflect.Method.invoke(Native Method)\r\n2017-04-19 20:31:07,727\tERROR/CrashHandler:\tat java.lang.reflect.Method.invoke(Method.java:372)\r\n2017-04-19 20:31:07,728\tERROR/CrashHandler:\tat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1029)\r\n2017-04-19 20:31:07,728\tERROR/CrashHandler:\tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:824)\r\n2017-04-19 20:31:07,728\tERROR/CrashHandler:\t**** CAUSE END ***",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5298/comments",
    "author": "coderloveryan",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2017-04-20T03:54:55Z",
        "body": "This is a problem with your code, not the library. Add `onError` implementations to your subscribers!"
      }
    ]
  },
  {
    "number": 5293,
    "title": "rx.exceptions.OnErrorThrowable$OnNextValue",
    "created_at": "2017-04-19T06:57:13Z",
    "closed_at": "2017-05-04T09:18:35Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5293",
    "body": "I use rxjava and retrofit to send audio file after recording,but sometimes server reports that audio file broken,the log is:\r\nrx.exceptions.OnErrorThrowable$OnNextValue\r\nOnError while emitting onNext value: com.lizhiweike.network.HttpResult.class\r\n\r\n`\r\n\r\n    compile 'com.squareup.retrofit2:retrofit:2.2.0'\r\n    compile 'com.squareup.retrofit2:adapter-rxjava:2.2.0'\r\n    compile 'com.squareup.retrofit2:converter-gson:2.2.0'\r\n    compile 'io.reactivex:rxjava:1.0.14'\r\n    compile 'io.reactivex:rxandroid:1.0.1'\r\n\r\n        File file = new File(path);\r\n        RequestBody requestFile = RequestBody.create(MediaType.parse(\"audio/*\"), file);\r\n        body = MultipartBody.Part.createFormData(\"audio_file\", file.getName(), requestFile);\r\n\r\n        HashMap<String,RequestBody> params = new HashMap<>();\r\n        params.put(\"lecture_id\",RequestBody.create(MediaType.parse(\"multipart/form-data\"), mId + \"\"));\r\n        params.put(\"need_encode\",RequestBody.create(MediaType.parse(\"multipart/form-data\"), String.valueOf(false)));\r\n        params.put(\"duration\",RequestBody.create(MediaType.parse(\"multipart/form-data\"),attachment.getDuration() + \"\"));\r\n\r\n        Subscription subscription = ApiService.getInstance().sendAudioMessage(body,params).subscribe(new HttpObserver<IMMessage>() {\r\n            @Override\r\n            protected void onError(ApiException ex) {\r\n                CrashReport.postCatchedException(ex);\r\n                ToastUtil.showToast(getActivity(),ex.getMsg());\r\n                onSendMessageFail(msg);\r\n            }\r\n\r\n            @Override\r\n            public void onNext(IMMessage imMessage) {\r\n                onSendMessageSuccess(msg);\r\n            }\r\n        });\r\n        mCompositeSubscription.add(subscription);\r\n`",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5293/comments",
    "author": "gewuxy",
    "comments": [
      {
        "user": "gewuxy",
        "created_at": "2017-04-19T07:09:58Z",
        "body": "`\r\n\r\n    @Multipart\r\n    @POST(\"api/upload_audio\")\r\n    Observable<HttpResult<IMMessage>> sendAudioMessage(@Part MultipartBody.Part audio, @PartMap Map<String,RequestBody> map);\r\n\r\n    public Observable<IMMessage> sendAudioMessage(MultipartBody.Part file, Map<String,RequestBody> params){\r\n        return weikeApi.sendAudioMessage(file,params)\r\n                .map(new ServerResultFunc<IMMessage>())\r\n                .onErrorResumeNext(new HttpResultFunc<IMMessage>())\r\n                .subscribeOn(Schedulers.io())\r\n                .unsubscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread());\r\n    }\r\n`"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-19T08:50:42Z",
        "body": "Could you share the full stacktrace?"
      },
      {
        "user": "gewuxy",
        "created_at": "2017-04-19T10:36:16Z",
        "body": "com.xx.network.exception.ApiException:com.xx.network.exception.ServerException\r\n2 com.xx.network.ExceptionEngine.handleException(ExceptionEngine.java:55)\r\n3 ......\r\n4 Caused by:\r\n5 rx.exceptions.OnErrorThrowable$OnNextValue:OnError while emitting onNext value: com.xx.network.HttpResult.class\r\n6 rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:73)\r\n7 retrofit2.adapter.rxjava.BodyOnSubscribe$BodySubscriber.onNext(BodyOnSubscribe.java:48)\r\n8 retrofit2.adapter.rxjava.BodyOnSubscribe$BodySubscriber.onNext(BodyOnSubscribe.java:36)\r\n9 retrofit2.adapter.rxjava.CallArbiter.deliverResponse(CallArbiter.java:115)\r\n10 retrofit2.adapter.rxjava.CallArbiter.emitResponse(CallArbiter.java:97)\r\n11 retrofit2.adapter.rxjava.CallExecuteOnSubscribe.call(CallExecuteOnSubscribe.java:46)\r\n12 retrofit2.adapter.rxjava.CallExecuteOnSubscribe.call(CallExecuteOnSubscribe.java:24)\r\n13 retrofit2.adapter.rxjava.BodyOnSubscribe.call(BodyOnSubscribe.java:33)\r\n14 retrofit2.adapter.rxjava.BodyOnSubscribe.call(BodyOnSubscribe.java:25)\r\n15 rx.Observable.unsafeSubscribe(Observable.java:10151)\r\n16 rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)\r\n17 rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)\r\n18 rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n19 rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n20 rx.Observable.unsafeSubscribe(Observable.java:10151)\r\n21 rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\r\n22 rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:228)\r\n23 rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\r\n24 java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\r\n25 java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n26 java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\r\n27 java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\r\n28 java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\r\n29 java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\r\n30 java.lang.Thread.run(Thread.java:818)"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-19T10:40:19Z",
        "body": "Looks like your `ServerResultFunc` crashes.  But it is still unclear why; maybe there is another cause below what you posted?"
      },
      {
        "user": "gewuxy",
        "created_at": "2017-04-19T10:41:55Z",
        "body": "the server side reports that file broken"
      },
      {
        "user": "gewuxy",
        "created_at": "2017-04-19T10:42:19Z",
        "body": "`    \r\n\r\n    private class ServerResultFunc<T> implements Func1<HttpResult<T>, T> {\r\n        @Override\r\n        public T call(HttpResult<T> httpResult) {\r\n            if (httpResult.getCode() != 0) {\r\n                throw new ServerException(httpResult.getCode(),httpResult.getMsg());\r\n            }\r\n            return httpResult.getData();\r\n        }\r\n    }`"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-19T10:45:45Z",
        "body": "Since RxJava doesn't do networking, you should see what's wrong with Retrofit (for example, stripping RxJava and doing plain Retrofit calls). It is possible you run into a bug that's been fixed in a newer version. Also you may try StackOverflow and ask how and why Retrofit would upload incomplete data."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-04T09:18:35Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5292,
    "title": "NPE in defer().flatMap() chain [2.0.6]",
    "created_at": "2017-04-18T20:26:12Z",
    "closed_at": "2017-04-18T21:08:09Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5292",
    "body": "I get \"java.lang.NullPointerException: Attempt to invoke interface method 'void io.reactivex.disposables.Disposable.dispose()' on a null object reference\" running following sample code\r\n\r\n`    CompositeDisposable subs = new CompositeDisposable();\r\n\r\n    private Integer getInt() {\r\n        if(true)\r\n            throw new IllegalStateException();\r\n        return 0;\r\n    }\r\n\r\n    private void test() {\r\n        subs.add(Observable.defer(() -> observer -> {\r\n            observer.onNext(1);\r\n            observer.onComplete();\r\n        }).flatMap(o -> Observable.fromCallable(this::getInt))\r\n                .subscribe(integer -> {}, Throwable::printStackTrace)\r\n        );\r\n    }`\r\n\r\nAm I using defer in a wrong way? ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5292/comments",
    "author": "kamehamehajim",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-18T20:29:42Z",
        "body": "Could you post the entire stacktrace?"
      },
      {
        "user": "kamehamehajim",
        "created_at": "2017-04-18T20:32:24Z",
        "body": "```\r\n04-18 23:27:23.310 12259-12259/? E/AndroidRuntime: FATAL EXCEPTION: main\r\n                                                   Process: com.example.testapp, PID: 12259\r\n                                                   java.lang.RuntimeException: Unable to resume activity {com.example.testapp/com.example.testapp.ui.MainActivity}: java.lang.NullPointerException: Attempt to invoke interface method 'void io.reactivex.disposables.Disposable.dispose()' on a null object reference\r\n                                                       at android.app.ActivityThread.performResumeActivity(ActivityThread.java:3145)\r\n                                                       at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:3176)\r\n                                                       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2517)\r\n                                                       at android.app.ActivityThread.access$900(ActivityThread.java:158)\r\n                                                       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1364)\r\n                                                       at android.os.Handler.dispatchMessage(Handler.java:102)\r\n                                                       at android.os.Looper.loop(Looper.java:148)\r\n                                                       at android.app.ActivityThread.main(ActivityThread.java:5515)\r\n                                                       at java.lang.reflect.Method.invoke(Native Method)\r\n                                                       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:764)\r\n                                                       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:654)\r\n                                                    Caused by: java.lang.NullPointerException: Attempt to invoke interface method 'void io.reactivex.disposables.Disposable.dispose()' on a null object reference\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:498)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:490)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:331)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:323)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmitScalar(ObservableFlatMap.java:224)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:146)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:139)\r\n                                                       at com.example.testapp.presenters.ListSpecsPresenter.lambda$null$0(ListSpecsPresenter.java:51)\r\n                                                       at com.example.testapp.presenters.ListSpecsPresenter$$Lambda$8.subscribe(Unknown Source)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableDefer.subscribeActual(ObservableDefer.java:39)\r\n                                                       at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(ObservableFlatMap.java:55)\r\n                                                       at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                       at io.reactivex.Observable.subscribe(Observable.java:10686)\r\n                                                       at io.reactivex.Observable.subscribe(Observable.java:10615)\r\n                                                       at com.example.testapp.presenters.ListSpecsPresenter.test(ListSpecsPresenter.java:54)\r\n                                                       at com.example.testapp.presenters.ListSpecsPresenter.onAttachView(ListSpecsPresenter.java:34)\r\n                                                       at com.example.testapp.presenters.ListSpecsPresenter.onAttachView(ListSpecsPresenter.java:15)\r\n                                                       at com.example.testapp.ui.SpecListFragment.onResume(SpecListFragment.java:158)\r\n                                                       at android.support.v4.app.Fragment.performResume(Fragment.java:2235)\r\n                                                       at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1346)\r\n                                                       at android.support.v4.app.FragmentManagerImpl.moveFragmentToExpectedState(FragmentManager.java:1528)\r\n                                                       at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1595)\r\n                                                       at android.support.v4.app.FragmentManagerImpl.dispatchResume(FragmentManager.java:2898)\r\n                                                       at android.support.v4.app.FragmentController.dispatchResume(FragmentController.java:223)\r\n                                                       at android.support.v4.app.FragmentActivity.onResumeFragments(FragmentActivity.java:509)\r\n                                                       at android.support.v4.app.FragmentActivity.onPostResume(FragmentActivity.java:498)\r\n                                                       at android.support.v7.app.AppCompatActivity.onPostResume(AppCompatActivity.java:172)\r\n                                                       at android.app.Activity.performResume(Activity.java:6548)\r\n                                                       at android.app.ActivityThread.performResumeActivity(ActivityThread.java:3134)\r\n                                                       at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:3176) \r\n                                                       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2517) \r\n                                                       at android.app.ActivityThread.access$900(ActivityThread.java:158) \r\n                                                       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1364) \r\n                                                       at android.os.Handler.dispatchMessage(Handler.java:102) \r\n                                                       at android.os.Looper.loop(Looper.java:148) \r\n                                                       at android.app.ActivityThread.main(ActivityThread.java:5515) \r\n                                                       at java.lang.reflect.Method.invoke(Native Method) \r\n                                                       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:764) \r\n                                                       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:654)\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-18T20:32:43Z",
        "body": "Okay, the problem is that you are not supposed to create observables via the lambda (even though they appear to be functional interfaces) because you have to call `onSubscribe` with a `Disposable`. Use `Observable.just()` or `Observable.create()` instead."
      },
      {
        "user": "kamehamehajim",
        "created_at": "2017-04-18T20:39:38Z",
        "body": "```java\r\n    private void test() {\r\n        subs.add(Observable.defer(() -> new ObservableSource<Integer>() {\r\n            @Override\r\n            public void subscribe(Observer<? super Integer> observer) {\r\n                observer.onNext(1);\r\n                observer.onComplete();\r\n            }\r\n        }).flatMap(o -> Observable.fromCallable(this::getInt))\r\n                .subscribe(integer -> {}, Throwable::printStackTrace)\r\n        );\r\n    }\r\n```\r\n\r\nFails too. Am I still doing it wrong? (sorry for badly inserted code, I don't know what's going on)"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-18T20:51:30Z",
        "body": "```java\r\npublic void test() {\r\n    subs.add(Observable.defer(() -> Observable.create(observer -> {\r\n        observer.onNext(1);\r\n        observer.onComplete();\r\n    })).flatMap(o -> Observable.fromCallable(this::getInt))\r\n        .subscribe(integer -> {}, Throwable::printStackTrace)\r\n    );\r\n}\r\n```"
      },
      {
        "user": "kamehamehajim",
        "created_at": "2017-04-18T21:08:09Z",
        "body": "Ok, I got it, I should've just called observer.onSubscribe() to provide some kind of disposable. Thanks for quick reply."
      }
    ]
  },
  {
    "number": 5291,
    "title": "2.x `Flowable.create` parameter ordering is awkward (especially in Kotlin)",
    "created_at": "2017-04-18T14:05:53Z",
    "closed_at": "2017-04-27T13:09:59Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5291",
    "body": "The ordering of the `Flowable.create` parameters makes it impossible to use trailing closures in Kotlin, causing calls that look like this:\r\n\r\n```kotlin\r\nFlowable.create({ emitter ->\r\n  // etc...\r\n}, LATEST)\r\n```\r\n\r\nIf the declaration were `Flowable.create(BackpressureStrategy, FlowableOnSubscribe<T>)` it would be possible to do this instead:\r\n\r\n```kotlin\r\nFlowable.create(LATEST) { emitter ->\r\n  // etc...\r\n}\r\n```\r\n\r\nOrdinarily, I'd solve this by making an extension function on the class, but Kotlin can't add static methods to java classes as they lack a `companion object`.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5291/comments",
    "author": "joshfriend",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2017-04-18T14:08:09Z",
        "body": "You can use a top-level function instead:\r\n```kotlin\r\nfun flowable(strategy: BPS, onSubscribe: (Emitter) -> Unit) = Flowable.create(onSubscribe, strategy)\r\n```"
      },
      {
        "user": "joshfriend",
        "created_at": "2017-04-18T18:41:58Z",
        "body": "That's what I ended up with too, but it doesn't \"feel right\". Is this a change that could be considered for a future release?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-18T18:55:00Z",
        "body": "RxJava is a Java library where the current parameter order \"feels right\". Source like static operators, such as `create` can live in any other class, not necessarily in `Flowable` thus you can create your own class with parameter ordering as you see fit. In addition, Kotlin has extension methods so you you can \"add\" instance operators without going through the hassle of waiting for / requesting one in RxJava proper."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-27T13:09:59Z",
        "body": "Closing as the signature can't be changed but Kotlin users can define their own functions with the parameter ordering as they see fit."
      }
    ]
  },
  {
    "number": 5284,
    "title": "Fatal Exception thrown on Scheduler.Worker thread.     network socket time out create",
    "created_at": "2017-04-14T09:18:47Z",
    "closed_at": "2017-04-27T13:10:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5284",
    "body": "java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\r\nat rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:114)\r\nat android.os.Handler.handleCallback(Handler.java:739)\r\nat android.os.Handler.dispatchMessage(Handler.java:95)\r\nat android.os.Looper.loop(Looper.java:148)\r\nat android.app.ActivityThread.main(ActivityThread.java:5417)\r\nat java.lang.reflect.Method.invoke(Native Method)\r\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\r\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\r\nCaused by: rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\r\nat rx.observers.SafeSubscriber._onError(SafeSubscriber.java:187)\r\nat rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\r\nat rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\r\nat rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\r\nat rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\r\nat rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:852)\r\nat rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java:273)\r\nat rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:216)\r\nat rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:107)\r\nat android.os.Handler.handleCallback(Handler.java:739) \r\nat android.os.Handler.dispatchMessage(Handler.java:95) \r\nat android.os.Looper.loop(Looper.java:148) \r\nat android.app.ActivityThread.main(ActivityThread.java:5417) \r\nat java.lang.reflect.Method.invoke(Native Method) \r\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726) \r\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616) \r\nCaused by: rx.exceptions.CompositeException: 2 exceptions occurred.\r\nat rx.observers.SafeSubscriber._onError(SafeSubscriber.java:187) \r\nat rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115) \r\nat rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88) \r\nat rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88) \r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266) \r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818) \r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579) \r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568) \r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276) \r\nat rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88) \r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266) \r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818) \r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579) \r\nat rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568) \r\nat rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:852) \r\nat rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java:273) \r\nat rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:216) \r\nat rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:107) \r\nat android.os.Handler.handleCallback(Handler.java:739) \r\nat android.os.Handler.dispatchMessage(Handler.java:95) \r\nat android.os.Looper.loop(Looper.java:148) \r\nat android.app.ActivityThread.main(ActivityThread.java:5417) \r\nat java.lang.reflect.Method.invoke(Native Method) \r\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726) \r\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616) \r\nCaused by: rx.exceptions.CompositeException$CompositeExceptionCausalChain: Chain of Causes for CompositeException In Order Received =>\r\nat android.util.Log.getStackTraceString(Log.java:338)\r\nat com.android.internal.os.RuntimeInit.Clog_e(RuntimeInit.java:61)\r\nat com.android.internal.os.RuntimeInit.-wrap0(RuntimeInit.java)\r\nat com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:86)\r\nat java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)\r\nat java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)\r\nat rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:118)\r\nat android.os.Handler.handleCallback(Handler.java:739) \r\nat android.os.Handler.dispatchMessage(Handler.java:95) \r\nat android.os.Looper.loop(Looper.java:148) \r\nat android.app.ActivityThread.main(ActivityThread.java:5417) \r\nat java.lang.reflect.Method.invoke(Native Method) \r\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726) \r\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616) \r\nCaused by: java.net.SocketTimeoutException: failed to connect to /192.168.0.109 (port 10000) after 10000ms\r\nat libcore.io.IoBridge.connectErrno(IoBridge.java:169)\r\nat libcore.io.IoBridge.connect(IoBridge.java:122)\r\nat java.net.PlainSocketImpl.connect(PlainSocketImpl.java:183)\r\nat java.net.PlainSocketImpl.connect(PlainSocketImpl.java:452)\r\nat java.net.Socket.connect(Socket.java:884)\r\nat okhttp3.internal.platform.AndroidPlatform.connectSocket(AndroidPlatform.java:63)\r\nat okhttp3.internal.connection.RealConnection.connectSocket(RealConnection.java:220)\r\nat okhttp3.internal.connection.RealConnection.connect(RealConnection.java:146)\r\nat okhttp3.internal.connection.StreamAllocation.findConnection(StreamAllocation.java:186)\r\nat okhttp3.internal.connection.StreamAllocation.findHealthyConnection(StreamAllocation.java:121)\r\nat okhttp3.internal.connection.StreamAllocation.newStream(StreamAllocation.java:100)\r\nat okhttp3.internal.connection.ConnectInterceptor.intercep",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5284/comments",
    "author": "myhcqgithub",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-14T09:26:53Z",
        "body": "Please provide some code that demonstrates the problem as stacktrace dumps on itself is not useful.\r\n\r\n> failed to connect to /192.168.0.109 (port 10000) after 10000ms\r\n\r\nAlso make sure you consume exceptions gracefully."
      },
      {
        "user": "myhcqgithub",
        "created_at": "2017-04-14T09:29:16Z",
        "body": "     at okhttp3.internal.connection.ConnectInterceptor.intercept(ConnectInterceptor.java:42)\r\n                                                                    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\r\n                                                                    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:67)\r\n                                                                    at okhttp3.internal.cache.CacheInterceptor.intercept(CacheInterceptor.java:93)\r\n                                                                    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\r\n                                                                    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:67)\r\n                                                                    at okhttp3.internal.http.BridgeInterceptor.intercept(BridgeInterceptor.java:93)\r\n                                                                    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\r\n                                                                    at okhttp3.internal.http.RetryAndFollowUpInterceptor.intercept(RetryAndFollowUpInterceptor.java:120)\r\n                                                                    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\r\n                                                                    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:67)\r\n                                                                    at com.ems358.cms.common.data.http.interceptor.LoggerInterceptor.intercept(LoggerInterceptor.java:45)\r\n                                                                    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\r\n                                                                \tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:6"
      },
      {
        "user": "myhcqgithub",
        "created_at": "2017-04-14T09:31:55Z",
        "body": "I request the network at onresume and then quickly switch the interface to crash"
      },
      {
        "user": "myhcqgithub",
        "created_at": "2017-04-14T09:33:19Z",
        "body": "   \r\nException prompt code\r\n\r\n```java @Override\r\n    public Response intercept(Chain chain) throws IOException {\r\n        Request request = chain.request();\r\n        LoggerForRequest(request);\r\n        Response response = chain.proceed(request);\r\n        if (response == null) {\r\n            Logger.e(\"response==null\");\r\n        }\r\n        return LoggerForResponse(response);\r\n    }\r\n```\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-14T10:53:09Z",
        "body": "First, you have a connection problem to 192.168.0.192. Second, you likely rethrow an exception from `subscribe()` that ends up somewhere off the main thread:\r\n\r\n```java\r\nObservable.error(new SocketTimeoutException())\r\n.subscribe(new Subscriber() {\r\n    public void onError(Throwable ex) {\r\n        throw new RuntimeException(ex); // <-------------- this should be avoided\r\n    }\r\n});"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-27T13:10:33Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      },
      {
        "user": "YaDongHouse",
        "created_at": "2017-12-13T07:38:51Z",
        "body": "I met the same problem.How did you solve it？"
      },
      {
        "user": "YaDongHouse",
        "created_at": "2017-12-14T03:02:26Z",
        "body": "I find where i make  a mistake.  when i handle SocketTimeoutException  in OnError()  I use SocketTimeoutException.getcause().getmessage()  as parameters of the construction method. but SocketTimeoutException.getcause().getmessage() is null. so happen this error."
      }
    ]
  },
  {
    "number": 5279,
    "title": "2.x source code:OpenHashSet's rehash",
    "created_at": "2017-04-11T16:37:56Z",
    "closed_at": "2017-04-19T21:04:25Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5279",
    "body": "I'm reading the source code of Rxjava 2.0.1, and find the rehash function in OpenHashSet is a little strange.\r\n```\r\n    void rehash() {\r\n        T[] a = keys;\r\n        int i = a.length;\r\n        int newCap = i << 1;\r\n        int m = newCap - 1;\r\n\r\n        T[] b = (T[])new Object[newCap];\r\n\r\n\r\n        for (int j = size; j-- != 0; ) {\r\n            while (a[--i] == null) { } // NOPMD\r\n            int pos = mix(a[i].hashCode()) & m;\r\n            if (b[pos] != null) {\r\n                for (;;) {\r\n                    pos = (pos + 1) & m;\r\n                    if (b[pos] == null) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            b[pos] = a[i];\r\n        }\r\n\r\n        this.mask = m;\r\n        this.maxSize = (int)(newCap * loadFactor);\r\n        this.keys = b;\r\n    }\r\n```\r\nI just quite understand the for loop with j and i. Shouldn't it like below?\r\n```\r\n    void rehash() {\r\n        T[] a = keys;\r\n        int i = a.length;\r\n        int newCap = i << 1;\r\n        int m = newCap - 1;\r\n\r\n        T[] b = (T[])new Object[newCap];\r\n\r\n\r\n        for (int j = size; j-- != 0; ) {\r\n            if(a[j] == null){\r\n                continue;\r\n            }\r\n            int pos = mix(a[j].hashCode()) & m;\r\n            if (b[pos] != null) {\r\n                for (;;) {\r\n                    pos = (pos + 1) & m;\r\n                    if (b[pos] == null) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            b[pos] = a[j];\r\n        }\r\n\r\n        this.mask = m;\r\n        this.maxSize = (int)(newCap * loadFactor);\r\n        this.keys = b;\r\n    }\r\n```\r\n\r\nChange the i to j in the for loop?\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5279/comments",
    "author": "hanzhida",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-11T16:43:36Z",
        "body": "No. The `j` loop goes through the number of elements while `a[i] == null` skips over the empty slots in the backing array."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-19T21:04:25Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5278,
    "title": "1.2.7 Completable swallowing errors",
    "created_at": "2017-04-10T12:56:58Z",
    "closed_at": "2017-04-27T13:03:35Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5278",
    "body": "Can someone explain why the Completable test below fails because no exception was thrown?\r\n\r\n    \t@Test\r\n\tpublic void testCompletableError() {\r\n\t\ttry {\r\n\t\t\tnew MyExplodingCompletable().someMethod().subscribe();\r\n\t\t\tfail(\"error not thrown up\");\r\n\t\t} catch (Exception e) {\r\n\t\t\tassertEquals(OnErrorNotImplementedException.class, e.getClass());\r\n\t\t}\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testSingleError() {\r\n\t\ttry {\r\n\t\t\tnew MyExplodingSingle().someMethod().subscribe();\r\n\t\t\tfail(\"error not thrown up\");\r\n\t\t} catch (Exception e) {\r\n\t\t\tassertEquals(OnErrorNotImplementedException.class, e.getClass());\r\n\t\t}\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testObservableError() {\r\n\t\ttry {\r\n\t\t\tnew MyExplodingObserver().someMethod().subscribe();\r\n\t\t\tfail(\"error not thrown up\");\r\n\t\t} catch (Exception e) {\r\n\t\t\tassertEquals(OnErrorNotImplementedException.class, e.getClass());\r\n\t\t}\r\n\t}\r\n\r\n\tclass MyExplodingCompletable {\r\n\r\n\t\tCompletable someMethod() {\r\n\t\t\treturn Completable.error(new Exception(\"boom\"));\r\n\t\t}\r\n\t}\r\n\r\n\tclass MyExplodingSingle {\r\n\t\tSingle someMethod() {\r\n\t\t\treturn Single.error(new Exception(\"boom\"));\r\n\t\t}\r\n\t}\r\n\r\n\tclass MyExplodingObserver {\r\n\t\tObservable someMethod() {\r\n\t\t\treturn Observable.error(new Exception(\"boom\"));\r\n\t\t}\r\n\t}",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5278/comments",
    "author": "qazt482",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-10T14:14:58Z",
        "body": "`Completable` was designed a bit differently, and comes as a backport from 2.x where `CompletableObserver` is not allowed to throw."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-27T13:03:35Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      },
      {
        "user": "dklotz",
        "created_at": "2017-09-22T21:09:27Z",
        "body": "@akarnokd This inconsistency between Single, Observable and Completable is driving me crazy while trying to have one unified way of handling uncaught exceptions that works for all singles, observables and completables in an application. If I e.g. have a single and subscribe without giving an onError callback, I can see OnErrorNotImplementedException bubble up to some central place where I can handle it, if I call toCompletable on the same Single and subscribe again without an onError callback, the exception is completely swallowed. From an API user standpoint, its really difficult to understand why Completable should work any different from Single or Observable."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-09-22T23:25:17Z",
        "body": "@dklotz always specify an `onError` handler."
      }
    ]
  },
  {
    "number": 5272,
    "title": "1.x repeatWhen does not call onCompleted on child subscription",
    "created_at": "2017-04-07T21:37:26Z",
    "closed_at": "2017-04-07T22:08:32Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5272",
    "body": "Tested using RxJava 1.2.9.\r\n\r\nThe description of `repeatWhen` implies if the `notificationHandler` call an `onComplete` it should pass it onto the child subscription: \"If that Observable calls onComplete or onError then repeatWhen will call onCompleted or onError on the child subscription.\"\r\n\r\nHowever, this doesn't seem to happen. The `onError` seems to work, but `onCompleted` does not. This code illustrates this:\r\n\r\n```java\r\nSubscriber<Integer> subscriber = new Subscriber<Integer>() {\r\n    @Override public void onCompleted() {\r\n        System.out.println(\"completed\");\r\n    }\r\n\r\n    @Override public void onError(Throwable e) {\r\n        System.out.println(\"error\");\r\n    }\r\n\r\n    @Override public void onNext(Integer i) {\r\n\r\n    }\r\n};\r\n\r\n// Does not output anything\r\nObservable.just(1)\r\n        .repeatWhen(observable -> observable.flatMap(ignored -> Observable.empty()))\r\n        .subscribe(subscriber);\r\n\r\n// Prints \"error\" (as expected)\r\nObservable.just(1)\r\n        .repeatWhen(observable -> observable.flatMap(ignored -> Observable.error(new Exception())))\r\n        .subscribe(subscriber);\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5272/comments",
    "author": "Chubacca",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-07T21:42:40Z",
        "body": "You can't complete an entire `flatMap` with an inner `empty()` source, that just counts as 'skipping' and the merged flow is kept intact. For `repeatWhen` and `retryWhen`, you need a different mechanism and make `observable` complete, for example, with `takeWhile` or `takeUntil` or some lifted operator that can turn an `onNext` into an `onCompleted`."
      },
      {
        "user": "Chubacca",
        "created_at": "2017-04-07T22:08:32Z",
        "body": "Ah, makes sense, the flatMap won't pass the onComplete through (because it's mapped). Thanks!"
      }
    ]
  },
  {
    "number": 5266,
    "title": "CombineLatest computation explosion",
    "created_at": "2017-04-05T16:18:03Z",
    "closed_at": "2017-04-05T17:52:59Z",
    "labels": [
      "Question",
      "StackOverflow"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5266",
    "body": "Hi,\r\nI'm massively using RXjava for compute actions in my program.\r\nAccording to the user wanted actions and program settings, I'm computing the task duration and other stuff.\r\nI'm falling on tricky situation that which maybe can't be solve with Rx.\r\nThe users actions with parameters are kind of tree of \"small actions\". I'm building an observable tree according to the user choice. In some \"small actions\", I'm using software parameters. So my observable tree is built using switchMap(transform user choice) and combineLatest (for combining two successive actions).\r\nThe issue appeas with lot of actions. I'm creating the observable tree according to the user choice, take few times (<2s)(The user parameters are not observable yet, so i'm rebuilding all the tree from the root for each user changes). But if i'm changing one parameter which is used repetitively inside the tree(as \"leaf\" observable), it takes ages. It seems logical due to combineLatest which change two times (previous action, and the action) and that for all the tree nodes.\r\nI'm already thinking to an alternative which will consist to associate the \"leaf\" observables to the tree construction and only combileLatest with all the \"leaf\" observables.\r\nI don't want complexify more the tree builder, I'm wondering if there is inside RxJava already a solution for that issue.\r\nA kind of debounce of all the \"leaf\" observables which will recompute the tree from the root to the leaf (like my observable tree building)\r\n\r\nHere an overview (obs1 and obs2 are the \"leaf\" observables).\r\n\r\n<pre>\r\nObs1\\                                                              \r\n     |-> combineLatest \\                               \r\nObs2/                  |        \r\n                       | -> combineLatest  \\                       \r\nObs1\\                  |                   |\r\n     |-> combineLatest /                   |\r\nObs2/                                      |\r\n                                           |\r\n                                           |\r\n                                           |\r\n                                           |-->combineLatest ---- .... many more\r\n                                           |\r\nObs1\\                                      |\r\n     |-> combineLatest \\                   |\r\nObs2/                  |                   |\r\n                       | -> combineLatest  /\r\nObs1\\                  |                             \r\n     |-> combineLatest /\r\nObs2/\r\n\r\nmany more ...\r\n</pre>\r\n\r\n\r\nThanks,",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5266/comments",
    "author": "diorcety",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-05T17:02:07Z",
        "body": "This question is better suited for StackOverflow."
      }
    ]
  },
  {
    "number": 5264,
    "title": "doOnDispose / doOnLifecycle onDisposed action not being called",
    "created_at": "2017-04-04T20:31:22Z",
    "closed_at": "2017-04-11T11:51:36Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5264",
    "body": "Maybe I am doing something wrong, but this just stopped working when I updated version from 2.01 to 2.07 and 2.08.\r\n\r\nThe doOnDispose and the doOnLifecycle onDisposed action are not being called.\r\n\r\nSample code:\r\n\r\n        Observable.fromCallable(() -> \"1\")\r\n                .doOnLifecycle(\r\n                        disposable -> Log.i(TAG, \"1:doOnSubscribe\"),\r\n                        () -> Log.i(TAG, \"1:doOnDispose\")\r\n                )\r\n                .subscribe()\r\n                .dispose();\r\n\r\n        Observable.fromCallable(() -> \"2\")\r\n                .doOnSubscribe(disposable -> Log.i(TAG, \"2:doOnSubscribe\"))\r\n                .doOnDispose(() -> Log.i(TAG, \"2:doOnDispose\"))\r\n                .subscribe()\r\n                .dispose();",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5264/comments",
    "author": "fqborges",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-04T20:39:30Z",
        "body": "`subscribe` disconnects the upstream `Disposable` when it receives a terminal event thus you can't dispose an already completed sequence. This change was introduced in 2.0.5 via #4957."
      },
      {
        "user": "fqborges",
        "created_at": "2017-04-04T20:52:36Z",
        "body": "Is there a way to receive onDispose events after 2.0.5?\r\nI was using subscribe and dispose events for showing and hiding activity indicators/progress bar on when doing network.\r\n\r\nFor example, I used to do something like this:\r\n\r\n                doSomethingUsingNetwork()\r\n                .doOnSubscribe(d -> showProgress() )\r\n                .doOnDispose(() -> hideProgress() )\r\n                .subscribe(\r\n                        this::handleNext,\r\n                        this::handleError\r\n                )\r\n\r\nEdit: Why using onDispose? Because I missed the onFinally events when the subscription was disposed before onComplete/onError"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-04T20:54:09Z",
        "body": "Use doFinally."
      },
      {
        "user": "fqborges",
        "created_at": "2017-04-04T20:57:55Z",
        "body": "Thanks, it works like a charm in this version."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-11T11:51:36Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5263,
    "title": "The ParallelFlowable's behavior of the cancel method had been changed between 2.0.6 and 2.0.7",
    "created_at": "2017-04-03T07:11:17Z",
    "closed_at": "2017-04-04T04:30:38Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5263",
    "body": "In the case that a ParallelFlowable was subscribed by an array of Subscribers, \r\nwhen one Subscriber calls the cancel method, the ParallelFlowable stops emitting and all the Subscribers don't get any items on 2.0.6.\r\nHowever, I upgraded to 2.0.7, the ParallelFlowable stops emitting to only the Subscriber which called the cancel method and the others keep getting items.\r\n\r\nI wonder which one would be the expected behavior.\r\nTo me, 2.0.7's behavior makes more sense. ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5263/comments",
    "author": "otal1105",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-03T07:27:00Z",
        "body": "See #5117."
      },
      {
        "user": "otal1105",
        "created_at": "2017-04-04T04:30:38Z",
        "body": "Thank you. I didn't check this issue since I thought that this issue is about an exception handling."
      }
    ]
  },
  {
    "number": 5260,
    "title": "Is it possible to do real non-blocking IO with RxJava?",
    "created_at": "2017-04-02T20:35:53Z",
    "closed_at": "2017-04-19T21:05:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5260",
    "body": "Hello all,\r\n\r\nI have been trying to do non-blocking IO requests with RxJava without success, all I have been able to achieve is making my calls run asynchronously on a thread from the Schedulers.io thread pool. It seems that the threads from Schedulers.io still block waiting for the response, therefore not doing real NIO.\r\n\r\nIs it possible to do real NIO using just RxJava or does one have to use another library that does NIO (such as Unirest)?\r\n\r\nThanks in advance",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5260/comments",
    "author": "jfconavarrete",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-02T20:45:58Z",
        "body": "RxJava doesn't do IO on its own and you need some other library for that, such as Netty for example."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-19T21:05:13Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5259,
    "title": "how to implement the code style of rxjava",
    "created_at": "2017-04-02T11:37:48Z",
    "closed_at": "2017-04-11T11:54:21Z",
    "labels": [
      "Question",
      "StackOverflow"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5259",
    "body": "\r\ni am using greendao with rxjava, i am confused about how to implement the code style of rxjava.\r\n\r\nyou can see the Code nesting below.\r\n\r\n```java\r\n        private HistoryVideoDao historyVideoDao;\r\n        QueryBuilder<HistoryVideo> query;\r\n\r\n        historyVideoDao = daoSession.getHistoryVideoDao();\r\n        query = historyVideoDao.queryBuilder().orderAsc(HistoryVideoDao.Properties.ViewTime).limit(10);\r\n\r\n        Observable.concat(historyVideoDaoRx.insert(historyVideo), historyVideoDaoRx.count())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(new Action1<Object>() {\r\n                    @Override\r\n                    public void call(Object o) {\r\n                        if (o instanceof Long) {\r\n                            if (((Long) o) > 60) {\r\n                                query.rx().list().observeOn(AndroidSchedulers.mainThread())\r\n                                        .subscribe(new Action1<List<HistoryVideo>>() {\r\n                                            @Override\r\n                                            public void call(List<HistoryVideo> historyVideos) {\r\n                                                historyVideoDaoRx.deleteInTx(historyVideos).subscribe(new Action1<Void>() {\r\n                                                    @Override\r\n                                                    public void call(Void aVoid) {\r\n                                                        \r\n                                                    }\r\n                                                });\r\n                                            }\r\n                                        });\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n```\r\n\r\nthe code above mean that\r\nwhen i insert an history by dao object ,\r\nthe i check the total count in table haven more than 60\r\nif does , i will delete 10 in table\r\nfor that , i  must also to query the last 10 in table\r\nand then delete the 10 in table.\r\nthe insert,  count ,  query,  delete operation all are rx!\r\n\r\ni can not make it beautiful more!\r\nhow can i acheieve the goal to implement the code style of rxjava?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5259/comments",
    "author": "weituotian",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-02T12:08:10Z",
        "body": "This type of question is better asked on StackOverflow."
      },
      {
        "user": "weituotian",
        "created_at": "2017-04-02T13:54:09Z",
        "body": "@akarnokd \r\n\r\ni improve the code style below, is that rxjava Recommend?\r\n\r\nbut i have not test yet\r\n```java\r\nhistoryVideoDaoRx.insert(historyVideo)\r\n                .flatMap(new Func1<HistoryVideo, Observable<Long>>() {\r\n                    @Override\r\n                    public Observable<Long> call(HistoryVideo historyVideo) {\r\n                        return historyVideoDaoRx.count();\r\n                    }\r\n                })\r\n                .flatMap(new Func1<Long, Observable<List<HistoryVideo>>>() {\r\n                    @Override\r\n                    public Observable<List<HistoryVideo>> call(Long aLong) {\r\n                        if (aLong > 60) {\r\n                            return query.rx().list();\r\n                        }\r\n                        return Observable.never();\r\n                    }\r\n                })\r\n                .flatMap(new Func1<List<HistoryVideo>, Observable<Void>>() {\r\n                    @Override\r\n                    public Observable<Void> call(List<HistoryVideo> historyVideos) {\r\n                        return historyVideoDaoRx.deleteInTx(historyVideos);\r\n                    }\r\n                })\r\n                .subscribe(new Action1<Void>() {\r\n                    @Override\r\n                    public void call(Void aVoid) {\r\n\r\n                    }\r\n                });\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-11T11:51:00Z",
        "body": "Unless you contribute to RxJava itself, you are bound to the style of your development group/company. Usually it's not a beauty contest and what matters is that the code works or not and you don't commit any of the coding sins (such as subscribing to an Observable from within onNext and such)."
      },
      {
        "user": "weituotian",
        "created_at": "2017-04-11T11:54:21Z",
        "body": "@akarnokd \r\nok ! my code work well.  but i really not understand how to make it beauty"
      }
    ]
  },
  {
    "number": 5254,
    "title": "RxJava 1.2.9 : calling onError without finishing / unsubscribing / onCompleted",
    "created_at": "2017-04-01T10:58:49Z",
    "closed_at": "2017-04-27T13:04:17Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5254",
    "body": "my code：\r\n\r\n```\r\nSubscription subscription = Observable.create(new Observable.OnSubscribe<ProgressModel>() {\r\n            @Override\r\n            public void call(Subscriber<? super ProgressModel> subscriber) {\r\n                try {\r\n                    OkHttpClient httpClient = new OkHttpClient();\r\n                    Call call = httpClient.newCall(new Request.Builder().url(URL).build());\r\n                    Response response = call.execute();\r\n                    if (response.code() == 200) {\r\n\r\n                        makeFileFullPath(savePath);\r\n\r\n                        File file = new File(savePath);\r\n\r\n                        FileOutputStream outputStream = null;\r\n\r\n                        InputStream inputStream = null;\r\n                        try {\r\n\r\n                            inputStream = response.body().byteStream();\r\n                            outputStream = new FileOutputStream(file);\r\n                            byte[] buff = new byte[1024 * 4];\r\n                            long downloaded = 0;\r\n                            long target = response.body().contentLength();\r\n\r\n                            ProgressModel progressModel = new ProgressModel();\r\n                            progressModel.updateData(0, target, false);\r\n                            subscriber.onNext(progressModel);\r\n                            int length = 0;\r\n                            long oldPro = 0;\r\n                            while ((length = inputStream.read(buff)) != -1) {\r\n                                outputStream.write(buff, 0, length);\r\n                                downloaded += length;\r\n\r\n                                long tmp = (downloaded *100 /target);\r\n\r\n                               if(tmp != oldPro) {\r\n                                   progressModel.updateData(downloaded, target, false);\r\n                                   subscriber.onNext(progressModel);\r\n                                   oldPro = tmp;\r\n                               }\r\n\r\n                                if(isStop.get()) {\r\n                                    break;\r\n                                }\r\n                                System.out.println(\"complemnt\"+tmp+\",\"+oldPro);\r\n                            }\r\n                            if (downloaded == target) {\r\n                                subscriber.onCompleted();\r\n                            } else {\r\n                                subscriber.onNext(new ProgressModel(-1,-1,false));\r\n                            }\r\n\r\n                        } catch (IOException ignore) {\r\n                            subscriber.onNext(new ProgressModel(-1,-1,false));\r\n\r\n                        } finally {\r\n                            if (inputStream != null) {\r\n                                inputStream.close();\r\n                            }\r\n                            if(outputStream != null) {\r\n                                outputStream.close();\r\n                            }\r\n                        }\r\n                    } else {\r\n                        subscriber.onNext(new ProgressModel(-1,-1,false));\r\n                    }\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n\r\n            }\r\n        }).subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber<ProgressModel>() {\r\n            @Override\r\n            public void onNext(ProgressModel s) {\r\n                if(s == null) return;\r\n\r\n               if(!progressListener.update(s.already,s.total,s.done)) {\r\n                   System.out.println(\"calback1111111112 kaishi zhixingle\");\r\n                   isStop.set(true);\r\n               }\r\n            }\r\n\r\n            @Override\r\n            public void onCompleted() {\r\n                progressListener.update(-1,-1,true);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable e) {\r\n                System.out.println(\"calback1111111112 kaishi zhixingle\");\r\n            }\r\n        });\r\n        mCompositeSubscription.add(subscription);\r\n```\r\nI did not call the method   ```public void onError(Throwable e)``` ,\r\n, but it was called by itself.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5254/comments",
    "author": "trycatchx",
    "comments": [
      {
        "user": "trycatchx",
        "created_at": "2017-04-01T11:07:04Z",
        "body": "> When I Calling onNext very many times，Subscriber calls the onError method through itself。why ?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-01T11:42:20Z",
        "body": "It would be great if you actually shared the exception you are getting."
      },
      {
        "user": "trycatchx",
        "created_at": "2017-04-12T09:56:20Z",
        "body": "@akarnokd I can not get any exception. But i add .onBackpressureBuffer()  in Observable ,  and the problem is solved.  if I add onBackpressureDrop the problem is still there . "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-12T10:28:49Z",
        "body": "> I can not get any exception\r\n\r\nI can't tell what's wrong without knowing at least the name of the exception you are getting. Any stacktrace would be equally helpful. \r\n\r\nYou should avoid using `Observable.create(Observable.OnSubscribe)` because it has no safeguards and you are responsible for implementing the Observable protocol correctly. Use `Observable.create(Action<Emitter<T>>, Emitter.BackpressureMode)` instead."
      },
      {
        "user": "trycatchx",
        "created_at": "2017-04-17T10:24:17Z",
        "body": "@akarnokd  Thank you for your help ! I use `Observable.create(Action<Emitter>, Emitter.BackpressureMode) ` instead ， and the code works fine ！"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-27T13:04:17Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5248,
    "title": "1.x 2.x: Lost values when using debounce and map",
    "created_at": "2017-03-31T12:15:20Z",
    "closed_at": "2017-05-15T12:51:52Z",
    "labels": [
      "Question",
      "1.x",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5248",
    "body": "The following test when added to the `OperatorDebounceTest` on the 1.x branch does fail:\r\n\r\n```\r\n    @Test\r\n    public void debounceWithNextEventWhileInMap() throws Exception {\r\n        // given:\r\n        final CountDownLatch firstLatch = new CountDownLatch(1);\r\n        final CountDownLatch secondLatch = new CountDownLatch(1);\r\n        final CountDownLatch thirdLatch = new CountDownLatch(1);\r\n        PublishSubject<Integer> subject = PublishSubject.create();\r\n        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\r\n                subject.startWith(Integer.valueOf(1))\r\n                .debounce(100, TimeUnit.MILLISECONDS)\r\n                //.observeOn(Schedulers.computation())\r\n                .map(new Func1<Integer, Integer>(){\r\n                    @Override\r\n                    public Integer call(Integer integer) {\r\n                        if (integer.intValue() == 1) {\r\n                            firstLatch.countDown();\r\n                            try {\r\n                                if (!secondLatch.await(5, TimeUnit.SECONDS))\r\n                                    throw new RuntimeException(\"secondLatch.await()\");\r\n                            } catch (InterruptedException e) {\r\n                                throw new RuntimeException(e);\r\n                            }\r\n                        }\r\n                        if (integer.intValue() == 2) {\r\n                            thirdLatch.countDown();\r\n                        }\r\n                        return integer;\r\n                    }\r\n                })\r\n                .subscribe(ts);\r\n\r\n        // when:\r\n        Assert.assertTrue(firstLatch.await(5, TimeUnit.SECONDS));\r\n        subject.onNext(Integer.valueOf(2));\r\n        secondLatch.countDown();\r\n        Assert.assertTrue(thirdLatch.await(5, TimeUnit.SECONDS));\r\n        subject.onCompleted();\r\n\r\n        // then:\r\n        ts.awaitTerminalEventAndUnsubscribeOnTimeout(5, TimeUnit.SECONDS);\r\n        ts.assertValues(Integer.valueOf(1), Integer.valueOf(2));\r\n    }\r\n```\r\n\r\nThe equivalent test on the 2.x branch does fail as well.\r\n\r\nWhen uncommenting `.observeOn(Schedulers.computation())`, the test works on both branches.\r\n\r\nThe above is a reduced sample of a bug we had in our codebase, where we try debounce values entered by the user to fetch information from a server. If a second event occurs while in `map()` and map does take longer than the debounce time, the second event is lost.\r\n\r\nFYI: \r\nIn our code we use `flatMap` with `subscribeOn(Schedulers.io())` inside and I also tried to introduce `onBackpressureLatest()`, but for the testcase I wanted to make it as concise as possible: \r\n\r\n```\r\n        textField.textObservable()\r\n            .debounce(300, TimeUnit.MILLISECONDS)//\r\n            .distinctUntilChanged()//\r\n            // if loadData takes longer, and new events arrive in the meantime, only execute\r\n            // the latest event\r\n            .onBackpressureLatest()//\r\n            .flatMap(params -> loadData(params)\r\n                .subscribeOn(Schedulers.io())\r\n                .observeOn(uiScheduler)\r\n                .doOnNext(data -> updateUi(data))), 1)//\r\n            .subscribe();\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5248/comments",
    "author": "tschulte",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-03-31T12:39:51Z",
        "body": "This is an expected behavior when you hold up the pipeline by directly blocking the emission of `debounce`. It doesn't queue up signals that have cleared their timeout window."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-15T12:51:52Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5218,
    "title": "FlatMap with Completable ",
    "created_at": "2017-03-24T06:38:08Z",
    "closed_at": "2017-03-24T10:13:32Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5218",
    "body": "Basically I want to have the option of converting an Observable from flatMap to use as Completable. I am using RxJava 1.2.1 and trying to migrate to RxJava 2. Following the lead by Jake, I am removing all the Observable<Void> declarations  and replacing them with Completable. Here is the problem where I am stuck\r\n```\r\n public Observable<Void> saveReminder(final Reminder reminder)\r\n    {\r\n        return Observable.fromEmitter((Emitter<DataSnapshot> dataSnapshotAsyncEmitter) ->\r\n        {\r\n            FirebaseApi.getReminderReference().addListenerForSingleValueEvent(new ValueEventListener()\r\n            {\r\n                @Override\r\n                public void onDataChange(DataSnapshot dataSnapshot)\r\n                {\r\n                    dataSnapshotAsyncEmitter.onNext(dataSnapshot);\r\n                    dataSnapshotAsyncEmitter.onCompleted();\r\n                }\r\n\r\n                @Override\r\n                public void onCancelled(DatabaseError databaseError)\r\n                {\r\n                    if (databaseError != null)\r\n                    {\r\n                        dataSnapshotAsyncEmitter.onError(databaseError.toException());\r\n                    }\r\n                }\r\n            });\r\n        }, Emitter.BackpressureMode.LATEST).observeOn(Schedulers.io()).flatMap(reminderCardsSnapshot ->\r\n        {\r\n            try\r\n            {\r\n                return Observable.just(saveData(reminder, reminderCardsSnapshot));\r\n            } catch (Exception e)\r\n            {\r\n                return Observable.error(e);\r\n            }\r\n        });\r\n    }\r\n```\r\nI need to replace **Observable<Void>** with **Completable**. Plz help",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5218/comments",
    "author": "reactivedroid",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-03-24T08:42:05Z",
        "body": "Which one?"
      },
      {
        "user": "reactivedroid",
        "created_at": "2017-03-24T08:52:13Z",
        "body": "@akarnokd I want to replace Observable<Void> to return Completable. \r\n`try\r\n            {\r\n                return Observable.just(saveData(reminder, reminderCardsSnapshot));\r\n            } catch (Exception e)\r\n            {\r\n                return Observable.error(e);\r\n            }`\r\nHow can the above method return Completable when it is wrapped inside flatMap which returns an Observable. Can you plz change the method above to return Completable?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-24T09:02:18Z",
        "body": "```java\r\n.flatMapCompletable(reminderCardsSnapshot ->\r\n    Completable.fromAction(() -> saveData(reminder, reminderCardsSnapshot)))\r\n```\r\n\r\nAs a general tip, I suggest you walk through each method in the classes so you can build a mental map on what's available.\r\n"
      },
      {
        "user": "reactivedroid",
        "created_at": "2017-03-24T10:08:05Z",
        "body": "Agreed. But `flatMapCompletable` is available in RxJava2...do you know any way where we can achieve the same in RxJava 1.2.1?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-24T10:09:18Z",
        "body": "Upgrade to 1.2.9."
      },
      {
        "user": "reactivedroid",
        "created_at": "2017-03-24T10:13:32Z",
        "body": "@akarnokd Thanks 👍 "
      }
    ]
  },
  {
    "number": 5200,
    "title": "2.x distinctUntilChanged should not update its value reference unless it changes",
    "created_at": "2017-03-20T09:11:41Z",
    "closed_at": "2017-03-20T12:34:54Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5200",
    "body": "RxJava version: 2.0.7\r\n\r\nThe `ObservableDistinctUntilChanged` caches the last emitted value regardless if it changes or not, this can waste memory needlessly if the emits emitted are large. \r\n\r\nFor example, consider this snippet:\r\n```java\r\nObservable.concatArray(loadHeavyResourceFromCache(), observeHeavyResourceFromNetwork())\r\n    .distinctUntilChanged()\r\n    .subscribe(this::showHeavyResource);\r\n```\r\n\r\nAssuming they resources are equal and that `showHeavyResource` stores a reference to the item both the cached value and the network value are kept in memory.\r\nI feel like `ObservableDistinctUntilChanged` probably shouldn't change its internal value if it doesn't change between emissions.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5200/comments",
    "author": "ansman",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-03-20T09:36:38Z",
        "body": "The contract is that subsequent elements are compared and thus the last seen element is always stored to be ready for comparing with the upcoming element."
      },
      {
        "user": "ansman",
        "created_at": "2017-03-20T10:28:26Z",
        "body": "But why does it need to update the value if they are equal?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-20T10:31:07Z",
        "body": "Equality is a funny thing when mutable objects are involved. See #4743 for example. You can use `onTerminateDetach` to get rid of any internal references after termination."
      },
      {
        "user": "ansman",
        "created_at": "2017-03-20T10:37:41Z",
        "body": "My stream is endless so there is no termination.\r\nI assume mutable objects break all sorts of things, but with the PR you linked it should make no difference if you store the first or the last of the duplicate values?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-20T11:19:04Z",
        "body": "Then you need a custom operator."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-20T11:36:25Z",
        "body": "```java\r\npublic static <T> ObservableTransformer<T, T> distinctUntilChangedNoUpdate() {\r\n    return o -> Observable.defer(() -> {\r\n        AtomicReference<T> last = new AtomicReference<T>()\r\n        return o.filter(v -> {\r\n            if (last.get() == null || !last.get().equals(v)) {\r\n               last.lazySet(v);\r\n               return true;\r\n            }\r\n            return false;\r\n        }); \r\n    });\r\n}\r\n```"
      },
      {
        "user": "ansman",
        "created_at": "2017-03-20T12:11:48Z",
        "body": "I see, and there is no way that the built in operator will change?\r\n\r\nAlso, how come an `AtomicReference` is needed? Access should be serialised by upstream, right?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-20T12:21:28Z",
        "body": "> I see, and there is no way that the built in operator will change?\r\n\r\nEstablished operators' behavior won't change.\r\n\r\n> Also, how come an AtomicReference is needed? Access should be serialised by upstream, right?\r\n\r\nYou can't create a `T[]` and `AtomicReference` already stores items on the heap and casts it properly. This is why `lazySet` is in there."
      },
      {
        "user": "ansman",
        "created_at": "2017-03-20T12:34:53Z",
        "body": "Ah, I see. Thanks.\r\n\r\nWhy would I need to create a `T[]`? I would only ever store a single object, right?"
      },
      {
        "user": "radityagumay",
        "created_at": "2018-09-18T12:14:50Z",
        "body": "\r\n> > I see, and there is no way that the built in operator will change?\r\n> \r\n> Established operators' behavior won't change.\r\n> \r\n> > Also, how come an AtomicReference is needed? Access should be serialised by upstream, right?\r\n> \r\n> You can't create a `T[]` and `AtomicReference` already stores items on the heap and casts it properly. This is why `lazySet` is in there.\r\n\r\nthanks for this @akarnokd "
      }
    ]
  },
  {
    "number": 5180,
    "title": "When using retryWhen why is there not a resubscription if the return is Observable.error(...)",
    "created_at": "2017-03-13T21:49:42Z",
    "closed_at": "2017-03-29T08:58:04Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5180",
    "body": "Thanks for using RxJava but before you post an issue, please consider the following points:\r\n\r\n  - RxJava Version: 1.2.7\r\n\r\nOverview:\r\nI wanted to test the scenario where I use RxJava to poll a service. The expectation is that the service will return a list with transactions, an empty list, or an exception will be thrown. Whenever, a list with transactions is returned they will be published to any subscribe to the relevant Rx subject. From Rx perspective polling and retry will be indefinite by will be throttled and the intent is to use a circuit breaker higher up the call stack to reduce necessary calls when the server is not available. \r\n\r\nIn my research all works as expected if you return list data, empty list or throw an exception. However, if one was to return say:\r\n\r\n  Observable.error(new RuntimeException());\r\n\r\nThen resubscription does not appear to take place.\r\n\r\nHere's the pretty much self contain code.  I've made it so that I can simulate having a mix of list items, empty list or exception returning. I can also have a specific set of the above options return. Additionally, I can simulate throwing an exception or returning Observable.error(...).\r\n\r\n```java\r\npackage com.shapestone.transaction.publisher;\r\n\r\nimport rx.Observable;\r\nimport rx.Observer;\r\nimport rx.Subscription;\r\nimport rx.subjects.PublishSubject;\r\nimport rx.subjects.Subject;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Random;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\nimport static java.lang.String.format;\r\nimport static rx.Observable.just;\r\nimport static rx.Observable.timer;\r\n\r\n/**\r\n * Date: 3/13/17.\r\n */\r\npublic class TransactionSubjectPlaypen {\r\n  enum ExceptionType { OBSERVABLE_EXCEPTION, THROW_EXCEPTION}\r\n  private static ExceptionType exceptionType;\r\n  private static final int COUNTER_START = 1;\r\n  private static final int ATTEMPTS = 5;\r\n  private static final int ORIGINAL_DELAY_IN_SECONDS = 10;\r\n  private Subject<TestTransaction, TestTransaction> transactionSubject;\r\n\r\n  public TransactionSubjectPlaypen() {\r\n    this.transactionSubject = PublishSubject.create();\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    try {\r\n      exceptionType = ExceptionType.THROW_EXCEPTION;\r\n      final TransactionSubjectPlaypen transactionSubjectPlaypen = new TransactionSubjectPlaypen();\r\n      transactionSubjectPlaypen.subscribe(new TestTransactionObserver());\r\n      transactionSubjectPlaypen.start();\r\n      Thread.sleep(120000);\r\n    } catch (InterruptedException e) {\r\n      e.printStackTrace();\r\n    }\r\n  }\r\n\r\n  public Subscription subscribe(Observer<TestTransaction> transactionObserver) {\r\n    return transactionSubject.subscribe(transactionObserver);\r\n  }\r\n\r\n  public void start() {\r\n    startPeriodicTransactionRetrieval();\r\n  }\r\n\r\n  // Emits Transaction\r\n\r\n  private void startPeriodicTransactionRetrieval() {\r\n    System.out.println(\"TransactionSubjectPlaypen.startPeriodicTransactionRetrieval\");\r\n    TransactionSubjectPlaypen.exceptionType = ExceptionType.OBSERVABLE_EXCEPTION;\r\n    Observable.fromCallable(() -> pollRemoteForTransactions(1))\r\n      .retryWhen(errors -> {\r\n        System.out.println(\"retryWhen\");\r\n        return errors.flatMap(error -> {\r\n          return Observable.just(null);\r\n        });\r\n      })\r\n      .repeatWhen(observable -> {\r\n        System.out.println(\"repeatWhen\");\r\n        return observable.concatMap(v -> timer(4, TimeUnit.SECONDS));\r\n      })\r\n      .flatMap(listObservable -> {\r\n       return listObservable;\r\n      }).flatMapIterable(testTransactions -> {\r\n        return testTransactions;\r\n      }).subscribe(transactionSubject);\r\n  }\r\n\r\n  // This is a bit superfluous however it is included to gave a more complete understanding of the problem.\r\n  private Observable<List<TestTransaction>> pollRemoteForTransactions(Integer i) {\r\n    System.out.println(\"TransactionSubjectPlaypen.pollRemoteForTransactions\");\r\n    return remoteServiceClientSimulation(i);\r\n  }\r\n\r\n  private Observable<List<TestTransaction>> remoteServiceClientSimulation(Integer i) {\r\n    System.out.println(\"TransactionSubjectPlaypen.remoteServiceClientSimulation\");\r\n    try {\r\n      randomNetworkDelaySimulation();\r\n      return getTransactions(i);\r\n    } catch (InterruptedException e) {\r\n      throw new RuntimeException(e.getMessage());\r\n    }\r\n  }\r\n\r\n  private void randomNetworkDelaySimulation() throws InterruptedException {\r\n    System.out.println(\"TransactionSubjectPlaypen.randomNetworkDelaySimulation\");\r\n    final int MAX_DELAY = 8000;\r\n    Thread.sleep(new Random().nextInt(MAX_DELAY));\r\n  }\r\n\r\n  @SuppressWarnings(\"Duplicates\")\r\n  private Observable<List<TestTransaction>> getTransactions(Integer requestedOption) {\r\n    System.out.println(\"TransactionSubjectPlaypen.getTransactions\");\r\n    final List<TestTransaction> transactions = new ArrayList<>();\r\n    int ZERO_RETURN_TRANSACTIONS = 0, ONE_RETURN_EXCEPTION = 1;\r\n\r\n    int MAX_OPTIONS = 3;\r\n    final int i = (requestedOption != null ? requestedOption : new Random().nextInt(MAX_OPTIONS));\r\n    if (i == ZERO_RETURN_TRANSACTIONS) {\r\n\r\n      transactions.add(new TestTransaction(\"addVendor\"));\r\n      transactions.add(new TestTransaction(\"addPersonAccount\"));\r\n      transactions.add(new TestTransaction(\"addSystemAccount\"));\r\n      transactions.add(new TestTransaction(\"addDeploymentContext\"));\r\n      transactions.add(new TestTransaction(\"addProperty\"));\r\n\r\n      System.out.println(format(\"Return %d transaction\", transactions.size()));\r\n\r\n      return just(transactions);\r\n\r\n    } else if (i == ONE_RETURN_EXCEPTION) {\r\n\r\n      if (exceptionType == ExceptionType.THROW_EXCEPTION) {\r\n        System.out.println(\"Return exception\");\r\n        throw new RuntimeException();\r\n        //return error(new RuntimeException());\r\n      } else {\r\n        System.out.println(format(\"Returning %d transaction\", transactions.size()));\r\n        return Observable.error(new RuntimeException());\r\n      }\r\n    } else {\r\n\r\n      System.out.println(format(\"Returning %d transaction\", transactions.size()));\r\n      return just(transactions);\r\n\r\n    }\r\n\r\n  }\r\n\r\n  public static class TestTransactionObserver implements Observer<TestTransaction> {\r\n\r\n    @Override\r\n    public void onCompleted() {\r\n      System.out.println(\"TestTransactionObserver.onCompleted\");\r\n    }\r\n\r\n    @Override\r\n    public void onError(Throwable e) {\r\n      System.out.println(\"TestTransactionObserver.onError\");\r\n      System.out.println(e);\r\n    }\r\n\r\n    @Override\r\n    public void onNext(TestTransaction testTransaction) {\r\n      System.out.println(\"TestTransactionObserver.onNext\");\r\n      System.out.println(\"Value = \" + testTransaction);\r\n    }\r\n  }\r\n\r\n  public static class TestTransaction {\r\n    private String name;\r\n\r\n    public TestTransaction() {\r\n    }\r\n\r\n    public TestTransaction(String name) {\r\n      this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n      return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n      this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n      return \"TestTransaction{\" +\r\n        \"name='\" + name + '\\'' +\r\n        '}';\r\n    }\r\n  }\r\n\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5180/comments",
    "author": "michaaelw",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-03-13T22:10:59Z",
        "body": "The `pollRemoteForTransactions` returns an `Observable` from the `fromCallable` which is considedered a success value and thus `retryWhen` doesn't see its inner exception. Only the first `flatMap` will unbox it and will find the error, but ther is no `retryWhen` further down. \r\n\r\nNote that error handling such as `retryWhen` can operate on errors that are above them, not below in the chain. \r\n\r\nPlace the `retryWhen` and `repeatWhen` just before the `subscribe()` call and you should see the retry/repeat happening."
      },
      {
        "user": "michaaelw",
        "created_at": "2017-03-13T22:23:39Z",
        "body": "Thanks for the prompt response @akarnokd. That make sense."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-29T08:58:04Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5178,
    "title": "2.x: TestObserver's \"isDisposed\"",
    "created_at": "2017-03-12T10:26:49Z",
    "closed_at": "2017-03-23T18:44:29Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5178",
    "body": "I have a DisposableObserver that has its own disposability implementation. It will correctly return the state when you hit `isDisposed`, but it is backed by a different enum (basically a fork of `DisposableHelper`, since it's internal-only). This is the delegate that `TestObserver` ends up wrapping in my test. Thing is, when you hit `TestObserver#isDisposed()`, it explicitly only does a reference comparison check between the disposable and the enum instance in `DisposableHelper`.\r\n\r\nIs this intentional? If so, should `isDisposed` not be used with `TestObserver` in testing?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5178/comments",
    "author": "ZacSweers",
    "comments": [
      {
        "user": "ZacSweers",
        "created_at": "2017-03-12T10:30:08Z",
        "body": "Another note on this - this also seems to break `isSubscribed` checks. The delegate observer is disposed now, but the wrapping `TestObserver` is still subscribed"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-12T11:08:13Z",
        "body": "`TestObserver` is a special kind which has to allow `dispose()` to be called after it has received the terminal event. See #4872. "
      },
      {
        "user": "ZacSweers",
        "created_at": "2017-03-23T18:44:29Z",
        "body": "Gotcha, thanks!"
      }
    ]
  },
  {
    "number": 5171,
    "title": "In Single.just().subscribe(onSuccess,onError), Throwable is not passed to the onError.",
    "created_at": "2017-03-10T08:55:31Z",
    "closed_at": "2017-03-10T09:03:39Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5171",
    "body": "",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5171/comments",
    "author": "linuxbelletian",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-03-10T09:05:54Z",
        "body": "`Single` has only terminal states: `onSuccess` and `onError`. If one or the other fails, there is no further down to signal that error. `Subscriber`/`Observer` onNext is not a terminal event and thus it can signal to `onError`."
      }
    ]
  },
  {
    "number": 5168,
    "title": "2.x: FlowableSubscriber and custom operator test failures",
    "created_at": "2017-03-09T02:18:04Z",
    "closed_at": "2017-03-29T09:11:08Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5168",
    "body": "Prior to rxjava 2.0.7 the operators in *rxjava2-extras* internally had custom subscribers built by implementing `Subscriber<T>`. Tests were passing and stable. With rxjava 2.0.7 and the strictness changes a large number of tests started failing across many *rxjava2-extras* operators. By implementing `FlowableSubscriber<T>` inside all of the operators instead of `Subscriber<T>` all tests started passing again. \r\n\r\nWas it your expectation @akarnokd that I would get failures because of the 2.0.7 changes? Was it thus a required change to my code or should we make the RxJava code a bit more robust? I can come up with some simple tests I imagine if you'd like the issues to be chased.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5168/comments",
    "author": "davidmoten",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2017-03-09T03:49:33Z",
        "body": "I suspect it is to do with me not handling deferred requests in a strict fashion. I'll confirm later."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-09T08:35:36Z",
        "body": "Changes of 2.0.7 should be transparent; all the RS TCK unit tests we have pass so it must be something in your code that triggers failure. What are your failures?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-16T10:20:06Z",
        "body": "If you ported operators from 1.x, you should watch out for `request(0)` which is forbidden in 2.x."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-29T09:11:08Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5166,
    "title": "1.x Execute action after flattened observable completes",
    "created_at": "2017-03-08T20:57:05Z",
    "closed_at": "2017-03-12T14:51:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5166",
    "body": "Hello,\r\n\r\ni'm with a doubt that i don't know how to write a flow that use a connection from database, but closes it a soon as the query ends, and before the downstream consume it's events.\r\n\r\nI'm using vert.x rxfied jdbc client, example code:\r\n\r\n```\r\njdbcClient.getConnectionObservable()\r\n                  .flatMap(conn -> conn.queryWithParamsObservable(\"SQL QUERY ...\", new JsonArray())\r\n                                       .doOnTerminate(conn::close))\r\n                  .map(ResultSet::getRows)\r\n                  .groupBy( // ... )\r\n```\r\n\r\nHow can i make the `conn::close` be classed **BEFORE** `map`, `groupby` and the rest of chian operators execute?\r\n\r\nCurrently, it will run the `doOnTerminate` only when the `subscriber` `unsubscribes`, since i'm returning it to other code, someone could do expensive things with the results, and i don't want the connection to be held due to that.\r\n\r\nOther thing, ideally i will be using `Observable.using` to create generic repository methods, because `getConnectionObservable` isn't lazy, it fetches a connection on calling, but it's not a `hot` observable since it don't pushes the values until subscribed, so, a sampel code would look like this:\r\n\r\n```\r\nObservable.defer(jdbcClient::getConnectionObservable)\r\n                  .flatMap(conn -> Observable.using(() -> {\r\n                                                      log.debug(\"Fetching database connection\");\r\n                                                      return conn;\r\n                                                  },\r\n                                                  // handle the connection here,\r\n                                                  connToClose -> {\r\n                                                      log.debug(\"Returning connection to pool\");\r\n                                                      connToClose.close();\r\n                                                  }));\r\n```\r\n\r\nI need to close the connection after it's used, before the chain ends.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5166/comments",
    "author": "kennedyoliveira",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-03-08T21:13:33Z",
        "body": "Hi. You were almost there: you have to apply Observable.using() on the outside:\r\n\r\n```java\r\nObservable.using(\r\n    jdbcClient::getConnectionObservable,\r\n    conn -> conn.queryWithParamsObservable(...)\r\n               .map(ResultSet::getRows)\r\n               .groupBy( ... )\r\n    conn -> conn.close(),\r\n    false\r\n)\r\n\r\n// or\r\nObservable.using(\r\n    jdbcClient::getConnectionObservable,\r\n    conn -> conn.queryWithParamsObservable(...)\r\n    conn -> conn.close(),\r\n    false\r\n)\r\n.map(ResultSet::getRows)\r\n.groupBy( ... )\r\n\r\n```"
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2017-03-08T21:41:25Z",
        "body": "Hey @akarnokd, thank you for the fast answer!\r\n\r\nI forgot to mention i'm using 1.x version, and `jdbcClient.getConnectionObservable` returns a `Observable<SQLConnection>` and not a connection, so  i would not be able to close it on last function, or i'm missing something?\r\n\r\nBy the way, i don't understand how the last parameter `disposeEagerly`, would you mind explaining it or pointing a resource to read more, besides the documentation?\r\n\r\nThank you"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-08T22:19:03Z",
        "body": "In that case your `defer` approach should work.\r\n\r\n> would you mind explaining it\r\n\r\nIf true, the dispose action is called before the onComplete is sent downstream. If false, the dispose action is called after. Sometimes you have to delay the dispose action with it because computation may still depend on the resource."
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2017-03-08T23:38:18Z",
        "body": "@akarnokd thanks for explaining about the `disposeEagerly`, know i understand.\r\n\r\nBack to the main question, the `defer` approach doesn't work, i created a simple example:\r\n\r\n```\r\n// defer because jdbcClient.getConnectionObservable() fetches a connection\r\nfinal Observable<SQLConnection> lazyConnection = Observable.defer(() -> {\r\n  log(\"Fetching connection\");\r\n  return jdbcClient.getConnectionObservable();\r\n});\r\n\r\nreturn lazyConnection\r\n  .flatMap(resource ->\r\n             Observable.using(\r\n               () -> {\r\n                 log(\"Creating resource\");\r\n                 return resource;\r\n               },\r\n               conn -> {\r\n                 log(\"Doing select on the connection\");\r\n                 return conn.queryObservable(\"SELECT * FROM INFORMATION_SCHEMA.HELP \");\r\n               },\r\n               conn -> {\r\n                 conn.close();\r\n                 log(\"Closing the connection\");\r\n               }, false))\r\n  .map(resultSet -> {\r\n    log(\"Mapping, connection should be close\");\r\n    // this doesn't need database connection, because it's eagerly fetched by the jdbc client\r\n    return resultSet.getRows();\r\n  })\r\n  .map(rows -> {\r\n    log(\"Mapping again, the connection should be closed\");\r\n\r\n    // sleep to simulate some delay\r\n    try { Thread.sleep(1_000); } catch (InterruptedException e) { }\r\n\r\n    // random\r\n    return rows.get(1);\r\n  });\r\n```\r\n\r\nThe output is the following:\r\n\r\n```\r\n2017-03-08T20:35:33.515 [vert.x-eventloop-thread-0] Fetching connection\r\n2017-03-08T20:35:33.515 [vert.x-eventloop-thread-0] Creating resource\r\n2017-03-08T20:35:33.516 [vert.x-eventloop-thread-0] Doing select on the connection\r\n2017-03-08T20:35:33.518 [vert.x-eventloop-thread-0] Mapping, connection should be close\r\n2017-03-08T20:35:33.519 [vert.x-eventloop-thread-0] Mapping again, the connection should be closed\r\n2017-03-08T20:35:34.525 [vert.x-eventloop-thread-0] Closing the connection\r\n```\r\n\r\nI can upload the project on Github if you want to review.\r\n\r\nThank you."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-09T08:45:14Z",
        "body": "So you need the connection closed before the downstream starts processing the single result set, right? In that case apply `.singleOrError()` before your first map and have the `using` eagerly dispose."
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2017-03-09T12:34:04Z",
        "body": "Yes, that's exactly it, using single worked, now the connection is release before downstream starts to process.\r\n\r\nI was trying to understand the `OperatorSingle`, but i got a little confused with the parent child relationship on subscribing, could you explain it a little?\r\n\r\n```\r\n    @Override\r\n    public Subscriber<? super T> call(final Subscriber<? super T> child) {\r\n\r\n        final ParentSubscriber<T> parent = new ParentSubscriber<T>(child, hasDefaultValue,\r\n                defaultValue);\r\n        child.add(parent);\r\n        return parent;\r\n    }\r\n```\r\n\r\nThank you!"
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2017-03-09T12:41:00Z",
        "body": "Another thing, i noticed there are 2 single operators, `toSingle` and `single`, one use `Single.create` and other use `lift`, what are the differences between them?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-10T18:17:01Z",
        "body": "I'm sorry, I currently don't have time to educate you personally."
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2017-03-10T19:16:04Z",
        "body": "I see, sorry for taking you time, i appreciate your help."
      }
    ]
  },
  {
    "number": 5149,
    "title": "Is the \"Rxjava\" always can be written  general java application, for exapmle: java web,java console application",
    "created_at": "2017-03-03T09:18:44Z",
    "closed_at": "2017-03-21T23:01:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5149",
    "body": "##   And  thank you for writing  this great project",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5149/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-03-03T09:26:29Z",
        "body": "Thanks for the praising! The title indicates you have a question, right?"
      },
      {
        "user": "ghost",
        "created_at": "2017-03-03T09:41:00Z",
        "body": "yes, and, I want kown, Rxjava  support the  java  forever, not the only one android .(maybe my poor english don't expressing my intention enough。。。 )"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-03T09:45:18Z",
        "body": "RxJava supports Java 6+, that includes Android and most desktop/server setups today."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-21T23:01:47Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5144,
    "title": "Promote DisposableLambdaObserver for public use?",
    "created_at": "2017-02-27T21:30:04Z",
    "closed_at": "2017-03-01T02:28:56Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5144",
    "body": "I noticed that `io.reactivex.internal.observers` includes `DisposableLambdaObserver`.  Might this class be promoted from the `internal` package for public use, thus allowing our `DisposableObserver`s to be defined with lambdas without resorting to writing our own lambda-friendly implementation?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5144/comments",
    "author": "jeremy303",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-02-27T21:39:22Z",
        "body": "`DisposableLambdaObserver` supports the lambda version of `Observable.subscribe()`. Why do you need that publicly?"
      },
      {
        "user": "jeremy303",
        "created_at": "2017-03-01T02:28:56Z",
        "body": "@akarnokd You are totally right, it's not needed-- I was confused.  I was interpreting the documentation and tutorials I read as indicating that a `DisposableObserver` needed to be provided to  `subscribeWith` when I needed dispose capability, but I now see that is only when providing an `Observer` for the subscribe, not when using the `subscribe` methods that accept lambdas, which return a `Disposable`."
      }
    ]
  },
  {
    "number": 5134,
    "title": "Overloaded startWith is misleading",
    "created_at": "2017-02-24T16:18:55Z",
    "closed_at": "2017-03-20T08:59:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5134",
    "body": "The overloaded `startWith` function is misleading when you actually want to start with an empty list but accidentially end up calling `startWith(java.lang.Iterable<? extends T> items)` instead of `startWith(T item)` and thus don't start / emit anything, blocking all depending subscriptions.\r\n\r\nThere should better be a  `startWithIterable(java.lang.Iterable<? extends T> items)`  (as there is also for flatMap(), zip(), ...)",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5134/comments",
    "author": "tobiasschuerg",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-02-24T16:32:40Z",
        "body": "What was your `T` and what Java version were you compiling on?\r\n\r\nWe can deprecate `startWith(T)` add `startWithItem(T)` that's shorter an expressive at the same time."
      },
      {
        "user": "tobiasschuerg",
        "created_at": "2017-02-24T16:49:33Z",
        "body": "My `T` was a `List<Object>`  respectively  `startWith(Collections.<List<Object>>emptyList())` on Java 7\r\n\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-02-24T16:57:54Z",
        "body": "To clarify, under Eclipse and compiled with target 6 and 7, the following\r\n\r\n```java\r\nFlowable<List<Object>> flow = Flowable.never();\r\nflow.startWith(Collections.emptyList());\r\n```\r\n\r\nselects `startWith(T)`. and\r\n\r\n```java\r\nFlowable<List<Object>> flow = Flowable.never();\r\nflow.startWith(Collections.<List<Object>>emptyList());\r\n```\r\n\r\nselects `startWith(Iterable<T>)`.\r\n\r\n`Collections.<List<Object>>emptyList()` is of type `List<List<Object>>`.\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-20T08:59:21Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 5118,
    "title": "Why is there no share or publish/refcount for single?",
    "created_at": "2017-02-19T09:04:44Z",
    "closed_at": "2017-02-19T10:03:00Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5118",
    "body": "RX Java version 2.0.4 - Single doesn't have share/publish/refcount and therefore we can't have hot observables. Is there any reason for the same.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5118/comments",
    "author": "bangarharshit",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-02-19T09:53:14Z",
        "body": "It has a `cache` operator and a `SingleSubject` to help with many cases when the single item should be cached. You can always convert back to `Observable` and have access to the `publish` and `refCount` operators."
      },
      {
        "user": "bangarharshit",
        "created_at": "2017-02-19T10:03:00Z",
        "body": "Got it. Resolving."
      },
      {
        "user": "afaucogney",
        "created_at": "2020-11-04T09:54:21Z",
        "body": "I come back to the issue. Could we have more context about the \"why\" there is no \"share\" operator for single ? Even if we can maybe solve some requirement in another way. Is it by design decision ?"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-11-04T10:02:19Z",
        "body": "We limit the API surface of the library and the need for share in other types is rare."
      }
    ]
  },
  {
    "number": 5095,
    "title": "replay() for Maybe?",
    "created_at": "2017-02-14T01:21:04Z",
    "closed_at": "2017-02-14T21:11:34Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5095",
    "body": "How come there's no `replay()` method for `Maybe`? I'd like to replay the emission of `Maybe` without having to re-execute the expensive operations.\r\n\r\nVersion: 2.0.1\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5095/comments",
    "author": "thelastbirth",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-02-14T08:29:20Z",
        "body": "Have you looked at `cache()`?"
      },
      {
        "user": "thelastbirth",
        "created_at": "2017-02-14T19:17:05Z",
        "body": "`cache()` works. Thanks. I wonder why's the decision not putting `replay()` in `Maybe`?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-02-14T21:11:34Z",
        "body": "There is no notion for connectable-maybe and `cache()` fulfills most of the user demand along with `MaybeSubject`."
      }
    ]
  },
  {
    "number": 5073,
    "title": "2.x - groupBy() Parallelization Not Working like in 1.0",
    "created_at": "2017-02-05T02:24:15Z",
    "closed_at": "2017-02-05T14:16:18Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5073",
    "body": "Hi David, \r\n\r\nWhile I was writing the Packt book, I think I might have found a problem with RxJava 2.0, unless this was an intended change and I'm missing something. When I do the parallelization pattern with `groupBy()` and a modulus Integer, it works fine in RxJava 1.0. Everything parallelizes across multiple threads as expected. \r\n\r\n```java \r\n\r\nimport rx.Observable;\r\nimport rx.schedulers.Schedulers;\r\nimport java.time.LocalTime;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\npublic class Launcher {\r\n    public static void main(String[] args) {\r\n\r\n       int coreCount = Runtime.getRuntime().availableProcessors();\r\n       AtomicInteger assigner = new AtomicInteger(0);\r\n\r\n       Observable.range(1,10)\r\n               .groupBy(i -> assigner.incrementAndGet() % coreCount)\r\n               .flatMap(grp -> grp.observeOn(Schedulers.io())\r\n                       .map(i2 -> intenseCalculation(i2))\r\n               )\r\n               .subscribe(i -> System.out.println(\"Received \" + i + \" \"\r\n                       + LocalTime.now() + \" on thread \"\r\n                       + Thread.currentThread().getName()));\r\n\r\n       sleep(20000);\r\n    }\r\n\r\n    public static <T> T intenseCalculation(T value) {\r\n        sleep(ThreadLocalRandom.current().nextInt(3000));\r\n        return value;\r\n    }\r\n    public static void sleep(long millis) {\r\n        try {\r\n            Thread.sleep(millis);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**OUTPUT:**\r\n\r\n```\r\nReceived 1 20:17:23.422 on thread RxIoScheduler-2\r\nReceived 3 20:17:23.840 on thread RxIoScheduler-4\r\nReceived 4 20:17:24.053 on thread RxIoScheduler-5\r\nReceived 9 20:17:24.273 on thread RxIoScheduler-2\r\nReceived 5 20:17:24.695 on thread RxIoScheduler-6\r\nReceived 8 20:17:24.950 on thread RxIoScheduler-9\r\nReceived 6 20:17:25.242 on thread RxIoScheduler-7\r\nReceived 7 20:17:25.251 on thread RxIoScheduler-8\r\nReceived 2 20:17:25.324 on thread RxIoScheduler-3\r\nReceived 10 20:17:27.532 on thread RxIoScheduler-3\r\n\r\n```\r\n\r\nBut if I switch to RxJava 2.0, this no longer parallelizes. Everything stays strictly serial and only one thread is used. \r\n\r\n```java\r\n\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.schedulers.Schedulers;\r\n\r\nimport java.time.LocalTime;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\npublic class Launcher {\r\n    public static void main(String[] args) {\r\n\r\n       int coreCount = Runtime.getRuntime().availableProcessors();\r\n       AtomicInteger assigner = new AtomicInteger(0);\r\n\r\n       Observable.range(1,10)\r\n               .groupBy(i -> assigner.incrementAndGet() % coreCount)\r\n               .flatMap(grp -> grp.observeOn(Schedulers.io())\r\n                       .map(i2 -> intenseCalculation(i2))\r\n               )\r\n               .subscribe(i -> System.out.println(\"Received \" + i + \" \"\r\n                       + LocalTime.now() + \" on thread \"\r\n                       + Thread.currentThread().getName()));\r\n\r\n       sleep(20000);\r\n    }\r\n\r\n    public static <T> T intenseCalculation(T value) {\r\n        sleep(ThreadLocalRandom.current().nextInt(3000));\r\n        return value;\r\n    }\r\n    public static void sleep(long millis) {\r\n        try {\r\n            Thread.sleep(millis);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**OUTPUT:**\r\n\r\n```\r\nReceived 1 20:21:03.321 on thread RxCachedThreadScheduler-1\r\nReceived 9 20:21:05.273 on thread RxCachedThreadScheduler-1\r\nReceived 2 20:21:05.559 on thread RxCachedThreadScheduler-1\r\nReceived 10 20:21:07.390 on thread RxCachedThreadScheduler-1\r\nReceived 3 20:21:10.055 on thread RxCachedThreadScheduler-1\r\nReceived 4 20:21:11.962 on thread RxCachedThreadScheduler-1\r\nReceived 5 20:21:12.850 on thread RxCachedThreadScheduler-1\r\nReceived 6 20:21:15.779 on thread RxCachedThreadScheduler-1\r\nReceived 7 20:21:17.927 on thread RxCachedThreadScheduler-1\r\nReceived 8 20:21:20.540 on thread RxCachedThreadScheduler-1\r\n```\r\n\r\nIs there something new that I'm supposed to do? Or is this a possible behavior regression? ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5073/comments",
    "author": "thomasnield",
    "comments": [
      {
        "user": "thomasnield",
        "created_at": "2017-02-05T02:28:51Z",
        "body": "Hmmm... this makes things more interesting. Using a `subscribeOn()` instead of an `observeOn()` seems to make parallelization work. I don't know if this was intended or not. \r\n\r\n```java\r\n\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.schedulers.Schedulers;\r\n\r\nimport java.time.LocalTime;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\npublic class Launcher {\r\n    public static void main(String[] args) {\r\n\r\n       int coreCount = Runtime.getRuntime().availableProcessors();\r\n       AtomicInteger assigner = new AtomicInteger(0);\r\n\r\n       Observable.range(1,10)\r\n               .groupBy(i -> assigner.incrementAndGet() % coreCount)\r\n               .flatMap(grp -> grp.subscribeOn(Schedulers.io())\r\n                       .map(i2 -> intenseCalculation(i2))\r\n               )\r\n               .subscribe(i -> System.out.println(\"Received \" + i + \" \"\r\n                       + LocalTime.now() + \" on thread \"\r\n                       + Thread.currentThread().getName()));\r\n\r\n       sleep(20000);\r\n    }\r\n\r\n    public static <T> T intenseCalculation(T value) {\r\n        sleep(ThreadLocalRandom.current().nextInt(3000));\r\n        return value;\r\n    }\r\n    public static void sleep(long millis) {\r\n        try {\r\n            Thread.sleep(millis);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n**OUTPUT:**\r\n\r\n```\r\nReceived 8 20:27:03.291 on thread RxCachedThreadScheduler-8\r\nReceived 6 20:27:03.446 on thread RxCachedThreadScheduler-6\r\nReceived 5 20:27:03.495 on thread RxCachedThreadScheduler-5\r\nReceived 4 20:27:03.681 on thread RxCachedThreadScheduler-4\r\nReceived 7 20:27:03.989 on thread RxCachedThreadScheduler-7\r\nReceived 2 20:27:04.797 on thread RxCachedThreadScheduler-2\r\nReceived 1 20:27:05.172 on thread RxCachedThreadScheduler-1\r\nReceived 9 20:27:05.327 on thread RxCachedThreadScheduler-1\r\nReceived 10 20:27:05.913 on thread RxCachedThreadScheduler-2\r\nReceived 3 20:27:05.957 on thread RxCachedThreadScheduler-3\r\n```\r\n\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-02-05T09:07:25Z",
        "body": "Works for me on RxJava 2.0.5."
      },
      {
        "user": "thomasnield",
        "created_at": "2017-02-05T14:16:18Z",
        "body": "Ah, okay. I was using 2.0.3 where apparently there was an issue. It looks like it was resolved by 2.0.5. Sorry I didn't check that first. "
      }
    ]
  },
  {
    "number": 5040,
    "title": "Is it necessary to dispose DisposableSingleObserver explicitly ?",
    "created_at": "2017-02-01T10:03:51Z",
    "closed_at": "2017-02-01T10:42:47Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5040",
    "body": "Is it necessary to dispose DisposableSingleObserver explicitly ?\r\n\r\n```\r\nfinal DisposableSingleObserver<? super SoapObject> myDisposableSingleObserver\r\n            = new DisposableSingleObserver<SoapObject>(){\r\n        @Override\r\n        public void onSuccess (SoapObject response){\r\n            //My logic here\r\n        }\r\n\r\n        @Override\r\n        public void onError (Throwable error){\r\n            Log.e(TAG, \"Error:\" + error.getMessage());\r\n        }\r\n    };\r\n```\r\nFor Example If I exit from Android activity; Will RxJava dispose myDisposableSingleObserver implicitly or I have to call\r\n```\r\nif (myDisposableSingleObserver.isDisposed()) {\r\n     myDisposableSingleObserver.dispose();\r\n}\r\n```\r\n\r\nI am using v2.0.5\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5040/comments",
    "author": "zahid-mt",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-02-01T10:27:48Z",
        "body": "If the execution gets to `onSuccess` or `onError`, the upstream is to be considered disposed and all resources freed (before or just after your code returns from the onXXX method). \r\n\r\nThere is no need to call `dispose` on `DisposableSingleObserver` and has likely no effect because some operators disconnect the internal link of `Disposable`s thus a `dispose` may never reach a `doOnDispose()` operator.\r\n\r\nTo make sure your resource is released no matter what, use `using` and/or `doFinally`.\r\n\r\n"
      }
    ]
  },
  {
    "number": 5022,
    "title": "Doubt about the terms Upstream vs Downstream",
    "created_at": "2017-01-26T20:07:36Z",
    "closed_at": "2017-01-27T16:00:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5022",
    "body": "Hello everyone,\r\n\r\ni'm confused with the terms upstream and downstream, and hope someone could describe better who is who, and maybe illustrate with some examples?\r\n\r\nFor example, the documentation about zipWith in a Flowable:\r\n\r\n`The operator expects backpressure from the sources and honors backpressure from the downstream. (I.e., zipping with interval(long, TimeUnit) may result in MissingBackpressureException, use one of the onBackpressureX to handle similar, backpressure-ignoring sources.`\r\n\r\nHow do i interpret it? The downstream is the source i'm zipping (The parameter of `zipWith`) and the upstream is the `Flowable` i'm calling `zipWith`? ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5022/comments",
    "author": "kennedyoliveira",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-01-26T20:14:40Z",
        "body": "Let me illustrate it:\r\n\r\n```\r\n           upstream                           downstream\r\nsource <------------- operator (parameters) -------------> consumer/further operators\r\n```\r\n\r\nSome operators have multiple upstreams such as `zipWith` which is an instance convenience for `zip(upstream1, upstream2, func2)`."
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2017-01-27T16:00:42Z",
        "body": "Thank you @akarnokd, you made it very clear."
      },
      {
        "user": "keshavvgarg",
        "created_at": "2022-03-10T12:57:22Z",
        "body": "@akarnokd, What does the arrow symbol apply here?"
      }
    ]
  },
  {
    "number": 5018,
    "title": "java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare()",
    "created_at": "2017-01-25T06:03:20Z",
    "closed_at": "2017-02-03T01:53:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5018",
    "body": "I use Rxjava2 with retrofit .It is right when the lenght of the paramete is short,When I make the length of the parameter longer.It report this error.I have this piece of code;\r\n\r\n```java\r\npublic void sendRequest(String url, MySubscriber ss, HashMap<String, String> data) {\r\nFlowable mObservable;\r\nfinal String[] paths = url.split(\"/\");\r\nmObservable = myApi.getData(paths[0], paths[1], data);\r\nmObservable.observeOn(new HandlerScheduler(new Handler(Looper.getMainLooper()))).\r\nsubscribeOn(Schedulers.io())\r\n.subscribe(ss);\r\n}\r\n```\r\nThis is my Interface\r\n```java\r\nprivate interface MyApi {\r\n@FormUrlEncoded\r\n@Headers(HttpData.Header)\r\n@POST(\"{path1}/{path2}\")\r\nFlowable getData(@Path(\"path1\") String path1, @Path(\"path2\") String path2, @FieldMap HashMap<String, String> data);\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5018/comments",
    "author": "CodeDogDream",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-01-25T08:04:17Z",
        "body": "Hi.\r\n\r\n1) There is the `AndroidSchedulers.mainThread()` instead of manually creating a looper.\r\n2) Swap `subscribeOn` with `observeOn`.\r\n3) On what thread does this `sendRequest` get called?\r\n4) What is the stacktrace of the error?\r\n"
      }
    ]
  },
  {
    "number": 5012,
    "title": "2.x: Reusing observers with managing subscriptions/disposables. ",
    "created_at": "2017-01-23T08:44:40Z",
    "closed_at": "2017-01-23T09:19:41Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5012",
    "body": "I have the following problem: I have observer for network request, which can be reused in future (user swipe to refresh and etc). The problem is that I want to have ability to unsubscribe from results in any time and don't want to recreate observer each time. Code looks like that.\r\n```java\r\nprotected Observer<Collection<T>> mResponseObserver = new Observer<Collection<T>>() {\r\n        @Override\r\n        public void onSubscribe(Disposable d) {\r\n          // don't know how to store reference in another way     \r\n          mDisposable = d;\r\n        }\r\n     .....................\r\n    };\r\n..........................\r\n// can execute periodically\r\nvoid onRefresh() {\r\n    observableA.subscribe(mResponseObserver);\r\n}\r\n\r\n.........................\r\nvoid dispose() {\r\n    mDisposable.dispose();\r\n}\r\n```\r\nI try variant replacing ``` Observer``` with ```DisposableObserver``` and save disposable using ```subscribeWith()``` method, but it throw ```java.lang.IllegalStateException: Disposable already set!``` which is logical.\r\n\r\nMaybe I'm wrong and I need to create new observer each time ? What is the best practice?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5012/comments",
    "author": "youngam",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-01-23T08:53:44Z",
        "body": "The best practice is to create an `Observer` every time you want to subscribe."
      },
      {
        "user": "youngam",
        "created_at": "2017-01-23T08:58:34Z",
        "body": "Thank you very much for fast response. Can you please explain in two sentences or reference me to some source where I can read why it is not good to reuse observers?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-01-23T09:11:49Z",
        "body": "Most developers don't know enough about concurrency, the java memory model, the flow and lifecycle model of RxJava to ensure such optimizations actually work. I don't think you have thousands or millions of subscriptions that you can't afford allocating a few dozen new `Observer`s when needed. "
      }
    ]
  },
  {
    "number": 5010,
    "title": "How can `.buffer(2,1)` ever emit a list with only one item?",
    "created_at": "2017-01-20T21:07:28Z",
    "closed_at": "2017-01-20T21:19:47Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5010",
    "body": "Using RxJava version 1.2.5. (kotlin code below) \r\n\r\n```\r\nObservable.just(\"1\")\r\n                .startWith(emptyList<String>())\r\n                .buffer(2, 1)\r\n                .map { Pair(it[0], it[1]) } //throws java.lang.IndexOutOfBoundsException: Index: 1, Size: 1\r\n                .subscribe()\r\n\r\n```\r\n\r\nHow can `.buffer(2,1)` ever emit a list with only one item?\r\n\r\n\r\nOr, if you prefer java\r\n\r\n```\r\npublic class BufferTest {\r\n\r\n    @Test\r\n    public void name() throws Exception {\r\n        Observable.just(\"1\")\r\n                .startWith(new ArrayList<String>(0))\r\n                .buffer(2, 1)\r\n                .map(\r\n                        new Func1<List<String>, Pair>() {\r\n                            @Override\r\n                            public Pair call(List<String> list) {\r\n                                return new Pair(list.get(0), list.get(1)); //throws java.lang.IndexOutOfBoundsException: Index: 1, Size: 1\r\n                            }\r\n                        })\r\n                .subscribe();\r\n    }\r\n\r\n    private static class Pair {\r\n        final String first;\r\n        final String second;\r\n\r\n        Pair(String first, String second) {\r\n            this.first = first;\r\n            this.second = second;\r\n        }\r\n    }\r\n}\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5010/comments",
    "author": "ZakTaccardi",
    "comments": [
      {
        "user": "ZakTaccardi",
        "created_at": "2017-01-20T21:19:47Z",
        "body": "My bad - when the observable completes, the remaining buffer is emitted, hence the exception"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-01-20T21:21:12Z",
        "body": "It's quite easy: if there is a non-empty buffer when `onComplete` arrives, emit it. Operators try to avoid data loss so you can get partial buffers. If you don't want those, filter them out with `filter`."
      },
      {
        "user": "ZakTaccardi",
        "created_at": "2017-01-20T21:39:39Z",
        "body": "yep - that's what I'm doing now. Thanks!"
      }
    ]
  },
  {
    "number": 4995,
    "title": "Share does not work with just() and from()",
    "created_at": "2017-01-14T22:46:02Z",
    "closed_at": "2017-01-19T14:00:58Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4995",
    "body": "Tested with RxJava <= 1.2.5:\r\n\r\nCreating observable with _interval()_:\r\n```java\r\nObservable<Long> interval = Observable.interval(100, TimeUnit.MILLISECONDS);\r\nObservable<Long> source = interval\r\n        .take(2)\r\n        .doOnNext(aLong -> System.out.println(\"Side effect\"));\r\nObservable<Long> published = source.share();\r\nObservable<Zip> zip = Observable.zip(\r\n        published.buffer(2),\r\n        OperatorMinMax.max(published),\r\n        Zip::new\r\n);\r\nzip.toBlocking().single();\r\n```\r\n\r\nresults in (which is **correct** because of the _share()_ operator):\r\n```\r\nSide effect\r\nSide effect\r\n```\r\n\r\nHowever, when creating Observable with _just()_:\r\n```java\r\nObservable<Long> interval = Observable.just(0L, 1L);\r\nObservable<Long> source = interval\r\n        .take(2)\r\n        .doOnNext(aLong -> System.out.println(\"Side effect\"));\r\nObservable<Long> published = source.share();\r\nObservable<Zip> zip = Observable.zip(\r\n        published.buffer(2),\r\n        OperatorMinMax.max(published),\r\n        Zip::new\r\n);\r\nzip.toBlocking().single();\r\n```\r\nthe result is:\r\n```\r\nSide effect\r\nSide effect\r\nSide effect\r\nSide effect\r\n```\r\nwhich is in my opinion **incorrect** as I used the _share()_ operator. The same applies for operators _from()_, _range()_...\r\nIs this a bug, or am I missing something important here?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4995/comments",
    "author": "xdom",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-01-14T22:56:35Z",
        "body": "With `share()`, if the upstream terminates, the internal subscriber count is set to zero. If a new subscriber comes in, that makes `share()` resubscribe to the upstream. \r\n\r\nIn your second case, `just` completes within the buffer size of `zip` and now you have two subscriptions."
      },
      {
        "user": "xdom",
        "created_at": "2017-01-14T23:10:37Z",
        "body": "Thank you @akarnokd for clarification. Can you think of any solution for my issue?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-01-14T23:12:52Z",
        "body": "Use `publish()` and when everything is set up, including the end consumer(s), call `connect()` on the `ConnectableObservable`."
      },
      {
        "user": "xdom",
        "created_at": "2017-01-14T23:18:09Z",
        "body": "Alright, and what if (in my real scenario) I return the zipped observable from a method and thus when subscribing to it, I don't have any access to the `ConnectableObservable`? Am I lost then?"
      },
      {
        "user": "JakeWharton",
        "created_at": "2017-01-14T23:28:30Z",
        "body": "You can use the overload of `publish()` that takes a function.\r\n```java\r\nObservable<Zip> zip = source.publish(published -> {\r\n    return Observable.zip(\r\n          published.buffer(2),\r\n          OperatorMinMax.max(published),\r\n          Zip::new);\r\n});\r\n```"
      },
      {
        "user": "xdom",
        "created_at": "2017-01-14T23:54:24Z",
        "body": "@JakeWharton Looks like this works perfectly! Thank you."
      }
    ]
  },
  {
    "number": 4985,
    "title": "onBackpressureBuffer into custom queue",
    "created_at": "2017-01-12T10:58:04Z",
    "closed_at": "2017-01-18T07:15:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4985",
    "body": "I want to buffer elements produced by hot source into custom queue (PriorityQueue). Also I want to retreive unprocessed elements after unsubscription.  \r\nFound, that source code of OperatorOnBackpressureBuffer.BufferSubscriber already has TODO for this task, so, extending this operator seems to be right way to go.  \r\nAny progress on this?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4985/comments",
    "author": "I60R",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-01-12T12:31:15Z",
        "body": "That comment refers to a more lightweight queue but still fifo queue.\r\n\r\nThe problem with `PriorityQueue` is the probabilistic reordering in case of backpressure. Consider buffering with a fixed time/size and then sorting the resulting List based on some priority."
      },
      {
        "user": "I60R",
        "created_at": "2017-01-13T07:16:09Z",
        "body": "Why reordering not allowed? In my case it's expected behaviour"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-01-13T08:33:55Z",
        "body": "The emphasis is on **probabilistic** because you can't predict if and when the dowstream won't be able to process the data and the buffering starts to happen."
      },
      {
        "user": "I60R",
        "created_at": "2017-01-13T09:44:09Z",
        "body": "The idea is simple: `Subscriber` calls `request(1)` (this peeks element with highest priority from buffer), processes it asynchronously then do next `request(1)` until _terminal element_ (expected with lowest priority) received. Reordering and probablistic buffering are expectected here. \r\nOr I'm missing something important that will break contracts\\my expectations?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-01-13T09:53:33Z",
        "body": "Doesn't work.\r\n\r\n1) case 1: you consume the `onBackpressureBuffer` immediately with a Subscriber and call `request(1)` from `onNext`, effect: due to call-stack blocking, the buffer won't have more than 1 element in it, thus no reordering\r\n2) case 2: you apply some async operation (such as `onBackpressureBuffer().observeOn()`). such operators request some predetermined amount which will request in chunks. effect: sometimes the sequence will go 1-by-1, sometimes a chunk will have ordered items (just like with my buffer example) but no guarantee when."
      },
      {
        "user": "I60R",
        "created_at": "2017-01-13T11:04:06Z",
        "body": "Is there more information about call-stack blocking, or other information about **case 1**? \r\nCan't figure out, why `Subscriber` below won't work:\r\n\r\n        elements.subscribe(new Subscriber<Element>() {\r\n\r\n            @Override\r\n            public void onNext(final Element element) {\r\n                processAsync(element, new Callback() {\r\n\r\n                    @Override\r\n                    void doOnProcessingFinish() {\r\n                        if (element.isTerminal()) {\r\n                            unsubscribe();\r\n                        } else {\r\n                            request(1);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            …\r\n\r\n        });\r\nSo, in **case 2** async operation \"buffers\" requests before sending them to source?\r\nWhat means \"predetermined amount\"?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-01-13T11:10:19Z",
        "body": "I suggest you take the source code of `onBackpressureBuffer`, apply your changes and experiment with it to see what happens."
      },
      {
        "user": "I60R",
        "created_at": "2017-01-18T07:15:10Z",
        "body": "Okay, now I understand problem. Thank for your answers"
      }
    ]
  },
  {
    "number": 4960,
    "title": "1.x Documentation issue for .doOnUnsubscribe()",
    "created_at": "2017-01-05T20:32:20Z",
    "closed_at": "2017-01-05T20:39:32Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4960",
    "body": "Looking at the javadoc for .doOnUnsubscribe, there's a caveat:\r\n\r\n```\r\nNote that terminal events trigger the action unless the Observable is subscribed to via unsafeSubscribe().\r\n```\r\n\r\nRunning a quick test, this seems wrong:\r\n\r\n```\r\nSubscription subscription = Observable.never()\r\n                .doOnSubscribe(() -> Timber.e(\"Sub\"))\r\n                .doOnUnsubscribe(() -> Timber.e(\"Unsub\"))\r\n                .unsafeSubscribe(new Subscriber<Object>() {\r\n                    @Override\r\n                    public void onCompleted() {}\r\n\r\n                    @Override\r\n                    public void onError(Throwable e) {}\r\n\r\n                    @Override\r\n                    public void onNext(Object o) {}\r\n                });\r\n        subscription.unsubscribe();\r\n```\r\n\r\nprints out:\r\n\r\n```\r\nSub\r\nUnsub\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4960/comments",
    "author": "danh32",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-01-05T20:35:09Z",
        "body": "`terminal events == onError | onCompleted`"
      },
      {
        "user": "danh32",
        "created_at": "2017-01-05T20:39:32Z",
        "body": "Yep, sorry! Misreading on my part. It sounded to me like the doOnUnsubscribe action wouldn't trigger in these cases."
      }
    ]
  },
  {
    "number": 4913,
    "title": "2.x: Misbehavior of BehavoirProcessor when converted to Single",
    "created_at": "2016-12-09T11:25:11Z",
    "closed_at": "2016-12-09T14:04:45Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4913",
    "body": "io.reactivex.rxjava2:rxandroid:2.0.1\r\n\r\nI believe `BehaviorProcessor` does not work correctly with `Single` observable. I am using `BehaviorProcessor` similarly to how I used `BehaviorSubject` with RxJava1, but this time with a `Single` observable.\r\n\r\nEvent producer\r\n```java\r\nBehaviorProcessor<Event> bp = BehaviorProcessor.create();\r\n\r\npublic Single<Event> getEvent() {\r\n    return bp.singleOrError();\r\n}\r\n\r\nvoid onEventReceived(Event event) {\r\n    bp.onEvent(event);\r\n    bp.onComplete();\r\n}\r\n```\r\n\r\nEvent observer\r\n```java\r\n\r\nproducer.getEvent().subscribeWith(\r\n    new DisposableSingleObserver<Event>() {\r\n        @Override public void onSuccess(Event value) {\r\n            Log.e(TAG, \"success\");\r\n        }\r\n\r\n        @Override public void onError(Throwable e) {\r\n            Log.e(TAG, \"error\");\r\n        }\r\n    }\r\n);\r\n```\r\n\r\nObserved behavior:\r\n1. If observers get subscribed **before** `onEventReceived()` is called, then all observers receive their `onSuccess()` callback, which is OK.\r\n2. If observers get subscribe **after** `onEventReceived()` (meaning after `onEvent()` and `onComplete()` are emitted), then `Single` receives `java.util.NoSuchElementException`. I believe this is NOT OK. Expected behavoir would be receiveing `onSuccess()` with the last value. This is what `BehaviorProcessor` should do for downstream observers, isn't it? Otherwise it appears to be useless for `Single` observers.\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4913/comments",
    "author": "sergejsha",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-12-09T13:05:20Z",
        "body": "This is the correct behavior for `BehaviorProcessor`. It doesn't retain the last value if it gets terminated. This has been so since day 1 with `BehaviorSubject` as well. Use `ReplayProcessor.createWithSize(1)` instead."
      },
      {
        "user": "sergejsha",
        "created_at": "2016-12-09T13:33:45Z",
        "body": "This is true what you say. But if I try to keep it not terminated by not calling `onComplete()`, the `Single` doesn't receive `onSuccess()`, which is also ok. Just out of curiosity, what would be the main use case for `BehavoirProcesser` with `Single` then, if later subscriptions always receive `onError()` instead of the most recent item it has observed?"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-12-09T14:00:08Z",
        "body": "I don't understand what you try to achieve here. If you want a `Single` of the latest of the `BehaviorProcessor`, use `take(1).singleOrError()` so a `SingleObserver` will receive at most one success value and disconnect from the `BehaviorProcessor`."
      },
      {
        "user": "sergejsha",
        "created_at": "2016-12-09T14:04:45Z",
        "body": "That's fine. Thanks for supporting David!"
      }
    ]
  },
  {
    "number": 4906,
    "title": "The order of `doOnSubscribe` changed in RxJava 2 without documentation",
    "created_at": "2016-12-06T07:10:35Z",
    "closed_at": "2016-12-06T10:04:30Z",
    "labels": [
      "Question",
      "1.x",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4906",
    "body": "We noticed one of our tests failing because or an ordering issue with `doOnSubscribe`. In RxJava 1 downstream `doOnSubcribe` would be called before upstream but it's the reverse in RxJava 2.\r\n\r\nHere's a code snippet that showcases the problem:\r\n```java\r\nObservable.empty()\r\n\t.doOnSubscribe(() -> System.out.println(\"RX1 upstream\"))\r\n\t.doOnSubscribe(() -> System.out.println(\"RX1 downstream\"))\r\n\t.subscribe();\r\n```\r\nThis will produce the following log statements:\r\n```\r\nRX1 downstream\r\nRX1 upstream\r\n```\r\nwhile the following snippet:\r\n```java\r\nio.reactivex.Observable.empty()\r\n\t.doOnSubscribe(d -> System.out.println(\"RX2 upstream\"))\r\n\t.doOnSubscribe(d -> System.out.println(\"RX2 downstream\"))\r\n\t.subscribe();\r\n```\r\nproduces the following statement:\r\n```\r\nRX2 upstream\r\nRX2 downstream\r\n```\r\n\r\nIs this an intended change?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4906/comments",
    "author": "ansman",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-12-06T09:06:46Z",
        "body": "Yes. The 1.x operator is lift based which executes the downstream operations first. In 2.x, the onSubscribe happens starting from upstream travelling downstream like the onNext events. Why do you have order-dependent doOnSubscribe?"
      },
      {
        "user": "ansman",
        "created_at": "2016-12-06T09:46:22Z",
        "body": "We had a test that tested a retry transformer and we needed to simulate getting different errors on different tries. Here's the code that caused the issue:\r\n```java\r\nAtomicInteger subscribeCount = new AtomicInteger(0);\r\nIOException e = new IOException();\r\nRuntimeException re = new RuntimeException();\r\n\r\nObservable\r\n        .defer(() -> subscribeCount.get() >= 2 ?\r\n                Observable.error(re) :\r\n                Observable.concat(Observable.just(\"1\"), Observable.just(\"2\"), Observable.error(e)))\r\n        .doOnSubscribe(subscribeCount::incrementAndGet)\r\n        .compose(retry())\r\n        .subscribe(subscriber);\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-12-06T09:59:32Z",
        "body": "Relplace `get()` with `incrementAndGet()` and drop the `doOnSubscribe()` call."
      },
      {
        "user": "ansman",
        "created_at": "2016-12-06T10:04:30Z",
        "body": "Ok, great!\r\nJust wanted to make sure this wasn't unexpected."
      }
    ]
  },
  {
    "number": 4898,
    "title": "RxJava 2 Single: onSuccess(null) vs onError(new NullPointerException())",
    "created_at": "2016-12-02T09:54:21Z",
    "closed_at": "2017-01-18T19:36:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4898",
    "body": "Since in RxJava 2.0 null values throw an exception by specification. Is it then safe to simplify this code:\r\n```\r\npublic Single<Something> getSomething() {\r\n            return Single.create(new SingleOnSubscribe<Something>() {\r\n                @Override\r\n                public void subscribe(final SingleEmitter<Something> e) throws Exception {\r\n                    SomethingFactory.getSomethingAsync(new SomethingCallback() {\r\n                        @Override\r\n                        public void onSomethingReady(Something something) {\r\n                            if (something != null) {\r\n                                e.onSuccess(something);\r\n                            } else {\r\n                                e.onError(new NullPointerException(\"Got null Something\"));\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n```\r\nas:\r\n```\r\npublic Single<Something> getSomething() {\r\n            return Single.create(new SingleOnSubscribe<Something>() {\r\n                @Override\r\n                public void subscribe(final SingleEmitter<Something> e) throws Exception {\r\n                    SomethingFactory.getSomethingAsync(new SomethingCallback() {\r\n                        @Override\r\n                        public void onSomethingReady(Something something) {\r\n                            e.onSuccess(something);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n```\r\n?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4898/comments",
    "author": "julioromano",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-12-02T10:38:53Z",
        "body": "If you are fine with NPE signals then yes."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-01-18T19:36:54Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 4888,
    "title": "Should a disposed ConnectableObservable replay() still emit?",
    "created_at": "2016-11-28T10:00:15Z",
    "closed_at": "2016-11-28T12:05:55Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4888",
    "body": "I have this test which passes, but I initially expected it (in particular the 2nd `test`) to fail:\r\n\r\n```java\r\n@Test\r\npublic void connectableReplay() throws Exception {\r\n    ConnectableObservable<Integer> just = Observable.just(1).replay();\r\n\r\n    just.test().assertNoValues();\r\n\r\n    Disposable connect = just.connect();\r\n    connect.dispose();\r\n\r\n    just.test()\r\n            .assertValue(1)\r\n            .assertComplete();\r\n}\r\n```\r\n\r\nSo even after a `replay()` ConnectableObservable was disposed it can still emit it's replayed values? Is that the desired behaviour?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4888/comments",
    "author": "Mauin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-28T10:05:48Z",
        "body": "Yes. `connect.dispose` disconnects from the upstream in case it hasn't yet terminated but consumers still get the events received till then."
      },
      {
        "user": "Mauin",
        "created_at": "2016-11-28T12:05:55Z",
        "body": "Okay, thanks for the clarification! 👍"
      }
    ]
  },
  {
    "number": 4886,
    "title": "OperatorObserveOn use  Queue-drain is Unnecessary?",
    "created_at": "2016-11-27T17:03:42Z",
    "closed_at": "2016-11-28T08:11:34Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4886",
    "body": "OperatorObserveOn is used to change thread for Subscriber to execute `onNext()` `onCompleted()` `onError()` ,In order to emits values  in a sequential way,OperatorObserveOn use Queue-drain in`ObserveOnSubscriber.schedule()` \r\n\r\n       protected void schedule() {\r\n            if (counter.getAndIncrement() == 0) {   //restrict only one thread access\r\n                recursiveScheduler.schedule(action);\r\n            }\r\n        }\r\n\r\n**BUT recursiveScheduler is a Worker**,from Worker's DOC:\r\n\r\n> Sequential Scheduler for executing actions on a single thread or event loop.\r\n\r\nSo,In OperatorObserveOn,without consider backpressure,we can just schedule action by `Worker ` directly,just like:\r\n\r\n        @Override\r\n        public void onNext(final T t) {\r\n\t      recursiveScheduler.schedule(new Action0() {\r\n\r\n            @Override\r\n            public void call() {\r\n                child.onNext(t);\r\n            }\r\n\r\n        });\r\n       }\r\n\r\nIs there any problem？\r\n\r\n ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4886/comments",
    "author": "chuyun923",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-27T17:34:53Z",
        "body": "The queue-drain gives much better performance because scheduling individual elements costs 1 allocation and a somewhat costly scheduling of the task itself. By queue drain, there is only an atomic increment followed by a scheduling of a `this` occasionally and the two sides of the queue communicate very efficiently if the supply of items is fast enough."
      },
      {
        "user": "chuyun923",
        "created_at": "2016-11-28T06:23:03Z",
        "body": " Thank you."
      }
    ]
  },
  {
    "number": 4869,
    "title": "RxJava 1.2.1  retryWhen not working on eclipse，but working on Android Studio",
    "created_at": "2016-11-20T13:17:37Z",
    "closed_at": "2016-11-26T11:57:31Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4869",
    "body": "The code is as follows:\r\n\r\n```java\r\nstatic int retryCount = 0;\r\n\tprivate static void test5(){\r\n\t\t\r\n\t\tfinal int maxRetries = 3;\r\n\r\n        Observable.create(new Observable.OnSubscribe<Integer>() {\r\n            @Override\r\n            public void call(Subscriber<? super Integer> subscriber) {\r\n                subscriber.onError(new RuntimeException(\"always fails\"));\r\n            }\r\n        })\r\n        .subscribeOn(Schedulers.immediate())\r\n         .retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\r\n\r\n                    @Override\r\n                    public Observable<?> call(Observable<? extends Throwable> observable) {\r\n                        return observable.flatMap(new Func1<Throwable, Observable<?>>() {\r\n                            @Override\r\n                            public Observable<?> call(Throwable throwable) {\r\n                                if (++retryCount <= maxRetries) {\r\n                                    // When this Observable calls onNext, the original Observable will be retried (i.e. re-subscribed).\r\n                                    System.out.println(\"get error, it will try after \" + 1000 + \" millisecond, retry count \" + retryCount);\r\n                                    return Observable.timer(1000, TimeUnit.MILLISECONDS);\r\n                                }\r\n                                return Observable.error(throwable);\r\n                            }\r\n                        });\r\n                    }\r\n\r\n\r\n                })\r\n                .subscribe(new Subscriber<Integer>() {\r\n\r\n                    @Override\r\n                    public void onCompleted() {\r\n                        System.out.println(\"onCompleted\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(Integer value) {\r\n                        System.out.println(\"onSuccess value = \" + value);\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(Throwable error) {\r\n                        System.out.println(\"onError error = \" + error);\r\n                    }\r\n                });\r\n\t\t\r\n\t}\r\n```\r\n\r\n\r\nThank you！",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4869/comments",
    "author": "jdsjlzx",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-20T15:01:33Z",
        "body": "You mean it doesn't compile? It works for me in Eclipse 4.6.1 and when I add `Thread.sleep(10000)`.\n"
      },
      {
        "user": "jdsjlzx",
        "created_at": "2016-11-21T01:53:34Z",
        "body": "it can compile,but the code execution results are different"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-21T07:11:51Z",
        "body": "What results do you get in each case?"
      },
      {
        "user": "jdsjlzx",
        "created_at": "2016-11-23T16:52:47Z",
        "body": "the code execution on eclipse（Only one time）：\r\nget error, it will try after 1000 millisecond, retry count 1\r\n\r\nthe code execution Android Studio：\r\nget error, it will try after 1000 millisecond, retry count 1\r\nget error, it will try after 1000 millisecond, retry count 2\r\nget error, it will try after 1000 millisecond, retry count 3\r\nonError error = java.lang.RuntimeException: always fails\r\n\r\nI don't know what reason is this，waiting for your reply，thank you！"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-23T16:58:12Z",
        "body": "Try this:\r\n\r\n```java\r\n```java\r\nstatic int retryCount = 0;\r\nprivate static void test5() throws Exception {\r\n\r\n    final int maxRetries = 3;\r\n    Observable.create(new Observable.OnSubscribe<Integer>() {\r\n            @Override\r\n            public void call(Subscriber<? super Integer> subscriber) {\r\n                subscriber.onError(new RuntimeException(\"always fails\"));\r\n            }\r\n        })\r\n        .subscribeOn(Schedulers.immediate())\r\n         .retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\r\n\r\n                    @Override\r\n                    public Observable<?> call(Observable<? extends Throwable> observable) {\r\n                        return observable.flatMap(new Func1<Throwable, Observable<?>>() {\r\n                            @Override\r\n                            public Observable<?> call(Throwable throwable) {\r\n                                if (++retryCount <= maxRetries) {\r\n                                    // When this Observable calls onNext, the original Observable will be retried (i.e. re-subscribed).\r\n                                    System.out.println(\"get error, it will try after \" + 1000 + \" millisecond, retry count \" + retryCount);\r\n                                    return Observable.timer(1000, TimeUnit.MILLISECONDS);\r\n                                }\r\n                                return Observable.error(throwable);\r\n                            }\r\n                        });\r\n                    }\r\n\r\n\r\n                })\r\n        .subscribe(new Subscriber<Integer>() {\r\n\r\n            @Override\r\n            public void onCompleted() {\r\n                System.out.println(\"onCompleted\");\r\n            }\r\n\r\n            @Override\r\n            public void onNext(Integer value) {\r\n                System.out.println(\"onSuccess value = \" + value);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable error) {\r\n                System.out.println(\"onError error = \" + error);\r\n            }\r\n        });\r\n\r\n\t\tThread.sleep(10000);  // <--------------------------------------------- let it wait\r\n\t}\r\n```"
      },
      {
        "user": "jdsjlzx",
        "created_at": "2016-11-24T14:22:30Z",
        "body": "Thank you for your plan, it worked！"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-26T11:57:31Z",
        "body": "Great!"
      },
      {
        "user": "flyfire",
        "created_at": "2018-03-13T10:02:29Z",
        "body": "Why does it work?Can somebody explain?"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-03-13T10:05:33Z",
        "body": "@flyfire You have to have the Java main thread sleep a bit, otherwise it quits before the retry can take effect. Standard RxJava schedulers run on daemon threads that are stopped when all other threads, such as the main thread, end."
      }
    ]
  },
  {
    "number": 4865,
    "title": "Observing dynamic data set",
    "created_at": "2016-11-18T07:56:25Z",
    "closed_at": "2016-11-18T09:21:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4865",
    "body": "Hey,\r\n\r\nWhat is the best approach to observe dynamic data set? \r\nFor example, I have a list of items which is being updated every few seconds and I want to somehow trigger `onNext()` and notify subscribers only after update event.\r\n\r\nI have already tried `PublishSubject` - I was calling `publishSubject.onNext(list)` after every update event, but I'm not sure this is the best approach.\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4865/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-18T08:27:03Z",
        "body": "It depends on your context. If you are processing the list in the same thread then `PublishSubject.onNext(list)` is okay. If you process it on a different thread while it may change on its \"home\" thread, you'd have to use `PublishSubject.toSerialized()` and emit a copy of the `list`.\n"
      }
    ]
  },
  {
    "number": 4862,
    "title": "2.x: RxJavaPlugins.reset() doesn't reset after Schedulers initializaion",
    "created_at": "2016-11-16T17:16:36Z",
    "closed_at": "2016-12-15T12:09:10Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4862",
    "body": "I have a query about whether or not the current behavior of`RxJavaPlugins`'s \r\n`setInit<XYZ>SchedulerHandler` hooks are behaving as intended. It seems that it is not possible to revert to the \"out of the box\" `Schedulers` state.\r\n\r\nTake the example of `Scheduler.computation()`. If I set a new default `Scheduler` using `setInitComputationSchedulerHandler` (which, to be applied successfully, must be done prior to accessing the `Schedulers` class), then once set this default cannot be changed; even using `RxJavaPlugins.reset()`.\r\n\r\nTo elaborate, when I override the default `Scheduler` instance, using the aforementioned hook, then the overriding `Function<Callable<Scheduler>>` is assigned to the non-final static field: `RxJavaPlugins.onInitComputationHandler`.\r\n\r\nAs per:\r\n\r\n```java\r\n    public static void setInitComputationSchedulerHandler(Function<Callable<Scheduler>, Scheduler> handler) {\r\n        if (lockdown) {\r\n            throw new IllegalStateException(\"Plugins can't be changed anymore\");\r\n        }\r\n        onInitComputationHandler = handler;\r\n    }\r\n```   \r\n\r\nNow in `Schedulers.java`, the static final field `COMPUTATION` is statically initialized via the result of `RxJavaPlugins.initComputationScheduler()` using the eventual default value of `new ComputationScheduler()` when no override is set. \r\n\r\nIf an override was set via `setInitComputationSchedulerHandler`,then that override is applied, but that result is final, as can be seen below -\r\n\r\n```java\r\nstatic final Scheduler COMPUTATION;\r\n\r\nstatic final class ComputationHolder {\r\n    static final Scheduler DEFAULT = new ComputationScheduler();\r\n}\r\n\r\nstatic {\r\n    COMPUTATION = RxJavaPlugins.initComputationScheduler(new Callable<Scheduler>() {\r\n                @Override\r\n                public Scheduler call() throws Exception {\r\n                    return ComputationHolder.DEFAULT;\r\n                }\r\n            });\r\n    }\r\n``` \r\n\r\nThis means that `COMPUTATION` is permanently assigned to be the override value. When a class accessess `Schedulers.computation()`, they will get the `COMPUTATION` instance by default.\r\n\r\nSee:\r\n\r\n```java\r\n    public static Scheduler computation() {\r\n        return RxJavaPlugins.onComputationScheduler(COMPUTATION);\r\n    }\r\n```\r\n\r\nIf they again call `setInitComputationSchedulerHandler` or `reset()` to clear the `RxJavaPlugins.onInitComputationHandler` field, then regardless, the original `COMPUTATION` value remains.\r\n\r\nNow they *can* call `RxJavaPlugins.setComputationSchedulerHandler()` to change the `Scheduler` that is eventually returned, but my opinion at least, is that it should be possible to revert back to the \"out of the box\" `Schedulers` state. Also being subject to the vagueries of static initialization order timing has the potential to cause debugging headaches for those overriding `Schedulers`.\r\n\r\nWithout suggesting an implementation, I would at least suggest that `RxJavaPlugins.reset()` should at least allow the caller the potential to reassign the default `Scheduler` instance.\r\n\r\nWhat thoughts do you have on the current behavior and my suggested change? ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4862/comments",
    "author": "peter-tackage",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-16T17:26:25Z",
        "body": "The current setup is introduced to prevent instantiating the default schedulers in environments where the default ExecutorService-based schedulers are not allowed. Instead of overriding the initial value, override the individual `setComputationSchedulerHandler` to return the scheduler of your chosing dynamically.\n"
      },
      {
        "user": "peter-tackage",
        "created_at": "2016-11-16T18:31:03Z",
        "body": "There are similar use cases in the Android world (which has the same API); we don't want the equivalent default Scheduler to be initialized in `AndroidSchedulers.mainThread()` when executing on the desktop JVM. So I'm comfortable with the motivation for having an alternative default Scheduler. \n\nHowever; is the intent behind the current implementation that once set (even implicitly, by accessing the `Schedulers` class), one should expect that it cannot be changed? `RxJavaPlugins.reset()` gives the impression that can reset to the out-of-the-box state (by calling `setInitComputationSchedulerHandler(null);`, but currently that would only be effective when done _before_ the `Schedulers` class is accessed.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-16T18:36:29Z",
        "body": "You set the baseline Schedulers once then dynamically override them. Because the dynamic override takes precedence, there is no loss of functionality.\n"
      },
      {
        "user": "peter-tackage",
        "created_at": "2016-11-19T17:10:01Z",
        "body": "OK. Thanks for the clarification.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-12-15T12:09:10Z",
        "body": "If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 4861,
    "title": "SerializedSubscriber should propagate onStart()",
    "created_at": "2016-11-16T16:00:28Z",
    "closed_at": "2016-12-15T12:07:26Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4861",
    "body": "`rx.observers.SerializedSubscriber` should also propagate `onStart()` event to the original subscriber, similar to other `on*()` methods",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4861/comments",
    "author": "adamdyga",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-16T16:40:32Z",
        "body": "Do you have an use case for this? Currently it doesn't do that because that usually leads to double calls to `onStart` in some operators.\n"
      },
      {
        "user": "adamdyga",
        "created_at": "2016-11-28T14:24:28Z",
        "body": "In my case `onStart()` is used to initiate backpressure (reactive pull):\r\n\r\n```\r\npublic class MySubscriber extends Subscriber<...>\r\n{\r\n\t@Override\r\n\tpublic void onStart()\r\n\t{\r\n\t\trequest(1);\r\n\t}\r\n        ....\r\n}\r\n```\r\n\r\nWhen the subscriber is wrapped with `SerializedSubscriber` it doesn't work. Yes, it can be easily fixed  by subclassing `SerializedSubscriber` and propagating `onStart()`, but this just doesn't feel right. If all `on*()` events are propagated, why not `onStart()` too? I understand that it was omitted due to some operators calling it multiple times, but can it also happen to my (or any other) subscriber if I don't wrap it with `SerializedSubscriber`? If so, shouldn't the operators be fixed, instead of mitigating the problem in subscriber(s)?"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-28T14:29:23Z",
        "body": "It has been fixed; it is called RxJava 2. Call `request(1)` in the constructor of your subscriber."
      },
      {
        "user": "adamdyga",
        "created_at": "2016-11-28T14:37:27Z",
        "body": "OK. Thanks for the hint. I thought that calling it in constructor is a little bit too early..."
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-28T14:38:49Z",
        "body": "Such request calls get accumulated and forwarded to the upstream when the time is right."
      },
      {
        "user": "akarnokd",
        "created_at": "2016-12-15T12:07:26Z",
        "body": "If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 4855,
    "title": "1.x: Something happens with Message.what onNext value",
    "created_at": "2016-11-16T01:58:43Z",
    "closed_at": "2016-11-17T15:14:33Z",
    "labels": [
      "Question",
      "Android"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4855",
    "body": "Rxjava 1.1.8\r\n\r\nMaybe its an issue with `Parcelable` management since `Message` is parcelable.\r\nThe idea is to listen to handler messages with subscriptions but `message.what` attribute comes with 0 always.\r\n\r\n```\r\nclass RxHandler(looper: Looper) : Handler(looper) {\r\n  val messagesObservable = PublishSubject<Message>()\r\n\r\n  override fun handleMessage(msg: Message?) {\r\n    super.handleMessage(msg)\r\n    msg?.let { messagesObservable.onNext(it) }\r\n  }\r\n}\r\n```\r\n\r\nand then subscribe to it:\r\n\r\n```\r\nplaybackHandler.messagesObservable\r\n          .subscribe({\r\n              // it.what is always 0 \r\n          }, { Timber.e(it, \"Error on playback handler message handling\") })\r\n\r\n```\r\n\r\nand then:\r\n\r\n```\r\nplaybackHandler.sendEmptyMessage(1)\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4855/comments",
    "author": "danielgomezrico",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-16T08:36:07Z",
        "body": "RxJava doesn't know about the internals of your values so this must be something to do with how Android message passing works in a handler. You have better chance asking this on StackOverflow.\n"
      }
    ]
  },
  {
    "number": 4854,
    "title": "1.x: ReplaySubject cache item limit",
    "created_at": "2016-11-15T16:05:53Z",
    "closed_at": "2016-12-15T12:08:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4854",
    "body": "Hey,\r\nDespite the fact that I am creating a ReplaySubject with create(X), this limit is not being respected and when I am fetching replaySubject.getValues() I am always getting an increasing list, which accumulates every emitted item. \r\n\r\nIs this a known issue?\r\nBest regards\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4854/comments",
    "author": "sergiomarqmoura",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-15T16:11:12Z",
        "body": "How do you use `ReplaySubject`? Does it receive events while you call `getValues()`? `ReplaySubject` ensures continuous event delivery which means if you subscribe at some point but don't request in time, you may get more values than the limit. The same is true for `getValues()`.\n"
      },
      {
        "user": "sergiomarqmoura",
        "created_at": "2016-11-15T18:20:38Z",
        "body": "@akarnokd thanks for the answer. What I am doing is the following:\nI have a replay subject which I initialize with create(1)\n\nAfter that, the subject is being used to emit items (subject.onNext(x)), and I thought that everytime this is called, the \"cache\" would be overwritten (since it only carries one element). However, when I subscribe to it later in time, I am receiving the first emitted value. While debugging it (with getValues()) I found that the cache is holding a lot of values and increasing over time.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-15T21:28:50Z",
        "body": "Do you mean `ReplaySubject.createWithSize(1)`?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-12-15T12:08:16Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 4850,
    "title": "Primitive Specilisation of API",
    "created_at": "2016-11-15T05:47:42Z",
    "closed_at": "2016-11-15T08:00:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4850",
    "body": "For latency, GC and memory efficiency is it possible to add primitive specialised equivalents?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4850/comments",
    "author": "sirinath",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-15T08:00:13Z",
        "body": "It's too much work for too little benefit; most users don't send millions of integers through a sequence plus we'd multiply the library size by 2x-4x. Bottom line, it is possible but we won't do it.\n"
      },
      {
        "user": "sp-1234",
        "created_at": "2017-01-12T10:09:03Z",
        "body": "Why not do it in a separate optional add-on library? Then those who don't need it won't have any additional problems at all.\r\nAlso not all types are needed, I think (int, long, float, double) are enough for all practical cases. Then there are 4*4 = 16 permutations for primitive->primitive mapping functions, that's not too bad.\r\n\r\n> most users don't send millions of integers through a sequence\r\n\r\nWell, they don't do this because currently it's impossible to do efficiently.\r\n\r\nAlso how hard do you think it is? Maybe I'll even take the challenge."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-01-12T10:17:13Z",
        "body": "Don't forget the Object->Primitive and Primitive->Object conversions, like `map((int i) -> Integer.toString(i))`.\r\n\r\nNobody is working on this and this won't be part of RxJava for the forseeable future. Also it depends on how Project Panama gets into the JDK eventually.\r\n\r\n> Also how hard do you think it is? \r\n\r\nYou lose `null` as a not-available indicator inside operators. This has cascading concurrency effects such as the need for a new Queue API, solving the problem of atomically changing a primitive + an empty indicator token, etc. At the end, you'll likely end up wrapping the primitives anyway and you gained almost nothing."
      },
      {
        "user": "sp-1234",
        "created_at": "2017-01-12T10:28:04Z",
        "body": "> Don't forget the Object->Primitive and Primitive->Object conversions, like map((int i) -> Integer.toString(i)).\r\n\r\nThere are little permutations (4), because all reference types are the same in this regard, that's nothing compared to 4*4 primitive permutations\r\n\r\n>Also it depends on how Project Panama gets into the JDK eventually.\r\n\r\nYeah that's true, but it won't make its way into existing Android versions (if at all).\r\n\r\n> You lose null as a not-available indicator inside operators.\r\n\r\nThis is a painful one, but maybe API could be extended for primitive versions so that user will explicitly choose an \"impossible\" value which is treated like null, when defining source of the data.\r\nLots of cases which work with only non-negative values or use ints for booleans/bytes are easy then. Also floating point types have NaN. Etc.\r\n\r\n> solving the problem of atomically changing a primitive\r\n\r\nAFAIK it's possible to do with sun.misc.Unsafe, which is exactly the backend behind AtomicLong class.\r\n\r\n> At the end, you'll likely end up wrapping the primitives anyway and you gained almost nothing.\r\n\r\nGiven the above points, maybe it's not so likely?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-01-12T11:47:16Z",
        "body": "If you are so convinced then go ahead and try it in your own repo."
      }
    ]
  },
  {
    "number": 4847,
    "title": "RxJava 1.x onCompleted is never called?",
    "created_at": "2016-11-14T15:33:28Z",
    "closed_at": "2016-11-15T14:20:43Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4847",
    "body": "Hi, \r\n\r\nI have the following code to demonstrate the problem.\r\n\r\n```Java\r\nCountDownLatch latch = new CountDownLatch(1);\r\n        \r\nObservable<Integer> stream1 = Observable.range(1, 3);\r\nObservable<Integer> stream2 = stream1\r\n        .flatMap(a -> {\r\n            return Observable.fromEmitter(emitter -> {\r\n                Thread t = new Thread(() -> {\r\n                    if (a == 3) {\r\n                        emitter.onCompleted();\r\n                    } else {\r\n                        emitter.onNext(a + 1000);\r\n                    }\r\n                });\r\n                System.out.println(Thread.currentThread().getName() + \" Created a-thread for \" + a);\r\n                t.setName(\"a-thread\");\r\n                t.start();\r\n            }, Emitter.BackpressureMode.NONE);\r\n        });\r\n        stream2\r\n                .doOnUnsubscribe(()-> System.out.println(Thread.currentThread().getName() + \" Unsubscribed.\"))\r\n                .subscribe(a -> {\r\n                    System.out.println(Thread.currentThread().getName() + \" processing: \" + a);\r\n                },\r\n                System.err::println,\r\n                () -> {\r\n                    System.out.println(Thread.currentThread().getName() + \" processed complete.\");\r\n                    latch.countDown();\r\n                });\r\nlatch.await();\r\n```\r\n\r\nI am expecting \" processed complete.\" will be called but it never did. I am using rxJava 1.2.2.\r\nAlso, would the Observer#onCompleted being called if the \"emitter.onCompleted()\" had been commented out from the above?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4847/comments",
    "author": "lawkai",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-14T18:03:03Z",
        "body": "You have to call `emitter.onCompleted()` for all `Observable`s because `flatMap` completes only if both the upstream and all the inner `Observable`s complete. You complete only the `Observable` for `a == 3` and keep the others alive.\n"
      },
      {
        "user": "lawkai",
        "created_at": "2016-11-15T14:20:43Z",
        "body": "Thanks, it did work as expected after I add emitter.onCompleted() for every instance of the Observables from the flatMap.\n"
      }
    ]
  },
  {
    "number": 4840,
    "title": "Why  resubscribe the source observable emit same output when I use retryWhen operator?",
    "created_at": "2016-11-12T09:58:00Z",
    "closed_at": "2016-11-12T21:01:06Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4840",
    "body": "code:\r\n```java\r\nstr = \"aaa\";\r\n        Observable.just(str).map(new Func1<String, String>() {\r\n                    @Override\r\n                    public String call(String s) {\r\n                        Log.i(\"====\", \"s == \" + s);\r\n                        if (\"aaa\".equals(s)) throw new RuntimeException(s);\r\n                        return s + \"123\";\r\n                    }\r\n                }).retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\r\n                    @Override\r\n                    public Observable<?> call(Observable<? extends Throwable> observable) {\r\n                        return observable.zipWith(Observable.range(1, 4), new Func2<Throwable, Integer, Integer>() {\r\n                            @Override\r\n                            public Integer call(Throwable throwable, Integer i) {\r\n                                str = \"ggg\";\r\n                                return i;\r\n                            }\r\n                        }).flatMap(new Func1<Integer, Observable<? extends Long>>() {\r\n                            @Override\r\n                            public Observable<? extends Long> call(Integer retryCount) {\r\n                                return Observable.timer(1, TimeUnit.SECONDS);\r\n                            }\r\n                        });\r\n                    }\r\n                }).subscribe(new Action1<String>() {\r\n                    @Override\r\n                    public void call(String s) {\r\n                        Log.i(\"====k\", \"s = \" + s);\r\n                    }\r\n                }, new Action1<Throwable>() {\r\n                    @Override\r\n                    public void call(Throwable throwable) {\r\n                        Log.i(\"====\", \"throwable = \" + throwable.getMessage());\r\n                    }\r\n                });\r\n```\r\nIn my opinion，it should log\r\n```\r\naaa\r\nggg\r\nggg\r\n...\r\n```\r\nbut in fact it always log\r\n```\r\naaa\r\naaa\r\naaa\r\n...\r\n```\r\nwhy?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4840/comments",
    "author": "fanturbo",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T11:10:48Z",
        "body": "`Observable.just(str)` captures `str`'s value and is a constant `Observable` in this regard, no matter how `str` changes afterwards. Use `Observable.fromCallable(() -> str)` to get a fresh value each time there is a retry.\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-12T12:50:26Z",
        "body": "@akarnokd When I use retrofit & rxjava in project,api return type is Observable,is it a constant Observable?I use cookie in request,and when cookie is invalid,i request new cookie(cookie is a String type member variable) in retrywhen and i got same error from server afterwards because the cookie is old cookie.Why is Observable.just(str) a constant Observabl?Is it because of str's String type?or other reasons?Thanks for your reply.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T12:59:01Z",
        "body": "Let me illustrate the situation with a classical example program:\n\n``` java\npublic class Example {\n    static String str;\n\n    public static void main(String[] args) {\n        str = \"aaa\";\n\n        String local = str;\n\n        str = \"ggg\";\n\n        System.out.println(local);\n        System.out.println(local);\n        System.out.println(local);\n    }\n}\n```\n\nCan you tell what this program prints to the console?\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-12T13:09:14Z",
        "body": "@akarnokd I got it.Thanks for your example.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T21:01:06Z",
        "body": "Great. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-22T01:49:03Z",
        "body": "@akarnokd \r\nI am sorry about  so late to ask this.\r\nI use rxjava&retrofit in my project.\r\n`@GET(\"group/{id}/users\")\r\nObservable<List<User>> groupList(@Path(\"id\") int groupId);`\r\nIs this return Observable also a constant Observable ?"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-22T07:55:47Z",
        "body": "No."
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-22T09:21:23Z",
        "body": "@akarnokd okay,it's the same question.groupId is member variable,when i first request from server i set groupid 0 and server return 404.and in retrywhen i changed groupId value,but i find in charles that in Request groupId is 0,too.(Now i use OkHttp interceptor to resolve this problem.But i want to know why groupId didn't change in second retry?)"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-22T09:27:49Z",
        "body": "How do you call `groupList()`? If you call it once and resubscribe to the returned Observable, that request path `id` is baked in:\r\n\r\n```java\r\nint groupId = 0;\r\n\r\nObservable<List<User>> obs1 = groupList(groupId);\r\n\r\ngroupId = 1;\r\n\r\nobs1.subscribe(v -> { }, Throwable::printStackTrace);\r\n```\r\n\r\nDo you think the last line will request with `groupId == 1` ?"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-22T09:57:42Z",
        "body": "```java\r\nApiClient.groupList(groupId)\r\n                .map(new Func1<List<User>, List<User>>() {\r\n                    @Override\r\n                    public List<User> call(List<User> list) {\r\n                        if (list.size() == 0) {\r\n                            throw new RuntimeException(\"gg\");\r\n                        }\r\n                        return list;\r\n                    }\r\n                })\r\n                .retryWhen(new RetryWithDelay(3, 2000))\r\n                .subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(new Action1<List<User>>() {\r\n                    @Override\r\n                    public void call(List<User> response) {\r\n                        fillData(response);\r\n                    }\r\n                }, new Action1<Throwable>() {\r\n                    @Override\r\n                    public void call(Throwable throwable) {\r\n                        Log.i(\"===========k3\", throwable.toString());\r\n                    }\r\n                });\r\n```\r\nthis is my code.I change groupId in RetryWithDelay's call method.what's wrong with the code?\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-22T10:13:55Z",
        "body": "You don't seem to understand how a value read from a variable won't change if you change the variable. Use `defer`:\r\n\r\n```java\r\nObservable.defer(() -> ApiClient.groupList(groupId))\r\n   // ... the rest\r\n```"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-22T14:22:29Z",
        "body": "@akarnokd yes,I didn't understand where differences are between Observable.just and Observable.fromCallable.Since you say 'No',I think retrofit's return Observable is like Observable.fromCallable,it is not a constant Observable and it will use fresh value when retry again.\r\nBut i was wrong.retrywhen operator's meaning is resubscribe source Observable,in my code,it is constant because ApiClient.groupList(groupId)) has produced,it is like Observable.just.(I think you should say 'Yes' because I think retrofit's return Observable is like a constant Observable) But when use \r\nObservable.defer,the result is different because defer operator decides the Observable is new(use fresh variable) when subscribe.\r\nThanks for your help!love you!"
      }
    ]
  },
  {
    "number": 4837,
    "title": "RxJava switchifempty() on generics",
    "created_at": "2016-11-11T15:05:08Z",
    "closed_at": "2016-12-15T12:06:12Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4837",
    "body": "Hi there,\r\n\r\nI'm trying to combine two sources which emit classes extending one abstract class. First I want to check the first source, then with `switchIfEmpty()` I want to check the second source. However, I get the compile error \r\n\r\n` incompatible types: Flowable<CAP#1> cannot be converted to Publisher<? extends CAP#2>` or see the following example\r\n\r\n```Java\r\npublic class UserEmitter {\r\n  public Flowable<? extends User> getUser() {\r\n    return emitUser1().switchIfEmpty(emitUser2());\r\n  }\r\n\r\n  private Flowable<? extends User> emitUser1() {\r\n    return Flowable.just(new User1(), new User2());\r\n  }\r\n\r\n  private Flowable<? extends User> emitUser2() {\r\n    return Flowable.just(new User2(), new User2());\r\n  }\r\n}\r\n\r\nabstract class User {\r\n\r\n}\r\n\r\nclass User1 extends User {\r\n\r\n}\r\n\r\nclass User2 extends User {\r\n\r\n}\r\n```\r\n\r\nAny help is appreciated.\r\n\r\nBest regards",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4837/comments",
    "author": "Agraphie",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-11T15:09:17Z",
        "body": "Type inference in Java 8 is incomplete and sometimes can't properly type expressions, especially the `? extends X` types. You should force `<User>` in `just` and in the return types.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-12-15T12:06:12Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 4834,
    "title": "The stack trace gets deep very quickly and causes StackOverflowException below Android Lollipop",
    "created_at": "2016-11-10T22:51:46Z",
    "closed_at": "2016-12-15T12:08:34Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4834",
    "body": "RxJava 1.1.8 can create deep stack trace fairly quickly.\r\nEspecially below Lollipop, Android has smaller limit for stack trace depth which makes us run into StackOverflowException.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4834/comments",
    "author": "haiminh87",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-10T22:55:30Z",
        "body": "This is a known property of synchronous stages and we can't do much about it. You may have better chance with 2.x but without further details from you, we can't really help your case that triggers the SO.\n"
      },
      {
        "user": "haiminh87",
        "created_at": "2016-11-11T00:44:30Z",
        "body": "This is an example stacktrace. Just a lot of layers.\n\n```\njava.lang.StackOverflowError\n     at java.lang.Throwable.<init>(Throwable.java:67)\n     at java.lang.Error.<init>(Error.java:48)\n     at java.lang.LinkageError.<init>(LinkageError.java:46)\n     at java.lang.NoClassDefFoundError.<init>(NoClassDefFoundError.java:43)\n     at rx.exceptions.Exceptions.throwIfFatal(SourceFile:85)\n     at rx.exceptions.Exceptions.throwOrReport(SourceFile:204)\n     at rx.observers.SafeSubscriber.onNext(SourceFile:139)\n     at rx.internal.operators.OperatorDistinctUntilChanged$1.onNext(SourceFile:102)\n     at rx.internal.operators.OperatorSwitch$SwitchSubscriber.drain(SourceFile:316)\n     at rx.internal.operators.OperatorSwitch$SwitchSubscriber.emit(SourceFile:207)\n     at rx.internal.operators.OperatorSwitch$InnerSubscriber.onNext(SourceFile:401)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.drain(SourceFile:285)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.combine(SourceFile:228)\n     at rx.internal.operators.OnSubscribeCombineLatest$CombinerSubscriber.onNext(SourceFile:379)\n     at rx.observers.SafeSubscriber.onNext(SourceFile:134)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.drain(SourceFile:285)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.combine(SourceFile:228)\n     at rx.internal.operators.OnSubscribeCombineLatest$CombinerSubscriber.onNext(SourceFile:379)\n     at rx.observers.SafeSubscriber.onNext(SourceFile:134)\n     at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(SourceFile:77)\n     at rx.internal.operators.NotificationLite.accept(SourceFile:152)\n     at com.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.accept$a2d69e2(SourceFile:311)\n     at com.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.emitLoop$1332631(SourceFile:282)\n     at com.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.emitFirst$a2d69e2(SourceFile:259)\n     at com.jakewharton.rxrelay.BehaviorRelay$1.call(SourceFile:81)\n     at com.jakewharton.rxrelay.BehaviorRelay$1.call(SourceFile:79)\n     at com.jakewharton.rxrelay.RelaySubscriptionManager.add(SourceFile:100)\n     at com.jakewharton.rxrelay.RelaySubscriptionManager.call(SourceFile:59)\n     at com.jakewharton.rxrelay.RelaySubscriptionManager.call(SourceFile:36)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OnSubscribeMap.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeMap.call(SourceFile:33)\n     at rx.Observable.subscribe(SourceFile:9957)\n     at rx.Observable.subscribe(SourceFile:9924)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.subscribe(SourceFile:144)\n     at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile:84)\n     at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile:28)\n     at rx.Observable.subscribe(SourceFile:9957)\n     at rx.Observable.subscribe(SourceFile:9924)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.subscribe(SourceFile:144)\n     at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile:84)\n     at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile:28)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OperatorSwitch$SwitchSubscriber.onNext(SourceFile:157)\n     at rx.internal.operators.OperatorSwitch$SwitchSubscriber.onNext(SourceFile:77)\n     at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(SourceFile:77)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.drain(SourceFile:285)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.combine(SourceFile:228)\n     at rx.internal.operators.OnSubscribeCombineLatest$CombinerSubscriber.onNext(SourceFile:379)\n     at rx.observers.SafeSubscriber.onNext(SourceFile:134)\n     at rx.observers.Subscribers$5.onNext(SourceFile:235)\n     at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(SourceFile:227)\n     at rx.android.schedulers.FastPathScheduler$FastPathWorker.schedule(SourceFile:102)\n     at rx.android.schedulers.FastPathScheduler$FastPathWorker.schedule(SourceFile:90)\n     at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.schedule(SourceFile:190)\n     at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext(SourceFile:165)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.drain(SourceFile:285)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.combine(SourceFile:228)\n     at rx.internal.operators.OnSubscribeCombineLatest$CombinerSubscriber.onNext(SourceFile:379)\n     at rx.observers.SafeSubscriber.onNext(SourceFile:134)\n     at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(SourceFile:77)\n     at rx.internal.operators.OperatorDistinctUntilChanged$1.onNext(SourceFile:102)\n     at rx.internal.util.ScalarSynchronousObservable$WeakSingleProducer.request(SourceFile:276)\n     at rx.Subscriber.setProducer(SourceFile:211)\n     at rx.Subscriber.setProducer(SourceFile:205)\n     at rx.internal.operators.OnSubscribeMap$MapSubscriber.setProducer(SourceFile:102)\n     at rx.Subscriber.setProducer(SourceFile:205)\n     at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(SourceFile:138)\n     at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(SourceFile:129)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OnSubscribeMap.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeMap.call(SourceFile:33)\n     at rx.Observable.subscribe(SourceFile:9957)\n     at rx.Observable.subscribe(SourceFile:9924)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.subscribe(SourceFile:144)\n     at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile:84)\n     at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile:28)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OnSubscribeDelaySubscriptionOther$1.onCompleted(SourceFile:74)\n     at rx.Completable$28.onCompleted(SourceFile:2079)\n     at rx.Completable$22$1$1.call(SourceFile:1619)\n     at rx.android.schedulers.FastPathScheduler$FastPathWorker.schedule(SourceFile:102)\n     at rx.android.schedulers.FastPathScheduler$FastPathWorker.schedule(SourceFile:90)\n     at rx.Completable$22$1.onCompleted(SourceFile:1615)\n     at rx.Completable$3$1.onCompleted(SourceFile:135)\n     at rx.Completable$10$1.onCompleted(SourceFile:559)\n     at rx.internal.operators.NotificationLite.accept(SourceFile:142)\n     at rx.subjects.SubjectSubscriptionManager$SubjectObserver.accept$a2d69e2(SourceFile:320)\n     at rx.subjects.SubjectSubscriptionManager$SubjectObserver.emitLoop$1332631(SourceFile:293)\n     at rx.subjects.SubjectSubscriptionManager$SubjectObserver.emitFirst$a2d69e2(SourceFile:272)\n     at rx.subjects.BehaviorSubject$1.call(SourceFile:111)\n     at rx.subjects.BehaviorSubject$1.call(SourceFile:107)\n     at rx.subjects.SubjectSubscriptionManager.add(SourceFile:97)\n     at rx.subjects.SubjectSubscriptionManager.call(SourceFile:62)\n     at rx.subjects.SubjectSubscriptionManager.call(SourceFile:35)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.Completable$10.call(SourceFile:573)\n     at rx.Completable$10.call(SourceFile:552)\n     at rx.Completable.unsafeSubscribe(SourceFile:2028)\n     at rx.Completable$3.call(SourceFile:175)\n     at rx.Completable$3.call(SourceFile:122)\n     at rx.Completable.unsafeSubscribe(SourceFile:2028)\n     at rx.Completable$22.call(SourceFile:1611)\n     at rx.Completable$22.call(SourceFile:1600)\n     at rx.Completable.unsafeSubscribe(SourceFile:2028)\n     at rx.Completable.unsafeSubscribe$3c21ec27(SourceFile:2076)\n     at rx.Completable.unsafeSubscribe(SourceFile:2060)\n     at rx.Completable$30.call(SourceFile:2245)\n     at rx.Completable$30.call(SourceFile:2242)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OnSubscribeDelaySubscriptionOther.call(SourceFile:80)\n     at rx.internal.operators.OnSubscribeDelaySubscriptionOther.call(SourceFile:31)\n     at rx.Observable.subscribe(SourceFile:9957)\n     at rx.Observable.subscribe(SourceFile:9924)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.subscribe(SourceFile:144)\n     at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile:84)\n     at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile:28)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OnSubscribeMap.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeMap.call(SourceFile:33)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.Observable.subscribe(SourceFile:9957)\n     at rx.Observable.subscribe(SourceFile:9924)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.subscribe(SourceFile:144)\n     at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile:84)\n     at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile:28)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OnSubscribeFilter.call(SourceFile:45)\n     at rx.internal.operators.OnSubscribeFilter.call(SourceFile:30)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OnSubscribeMap.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeMap.call(SourceFile:33)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OnSubscribeMap.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeMap.call(SourceFile:33)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.Observable.subscribe(SourceFile:9957)\n     at rx.Observable.subscribe(SourceFile:9924)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.subscribe(SourceFile:144)\n     at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile:84)\n     at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile:28)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.Observable.subscribe(SourceFile:9957)\n     at rx.Observable.subscribe(SourceFile:9924)\n     at rx.Observable.subscribe(SourceFile:9832)\n     at com.ubercab.presidio.app.optional.root.main.ride.request.home.map_layer.HomeMapLayerInteractor.__updateCamera$Impl(SourceFile:113)\n     at com.ubercab.presidio.app.optional.root.main.ride.request.home.map_layer.HomeMapLayerInteractor.updateCamera(SourceFile)\n     at com.ubercab.presidio.app.optional.root.main.ride.request.home.map_layer.HomeMapLayerInteractor.access$200(SourceFile:49)\n     at com.ubercab.presidio.app.optional.root.main.ride.request.home.map_layer.HomeMapLayerInteractor$3.onNext$171db248(SourceFile:159)\n     at com.ubercab.presidio.app.optional.root.main.ride.request.home.map_layer.HomeMapLayerInteractor$3.onNext(SourceFile:156)\n     at rx.internal.util.ObserverSubscriber.onNext(SourceFile:34)\n     at rx.observers.SafeSubscriber.onNext(SourceFile:134)\n     at rx.observers.SerializedObserver.onNext(SourceFile:92)\n     at rx.observers.SerializedSubscriber.onNext(SourceFile:94)\n     at rx.internal.operators.OperatorTakeUntil$1.onNext(SourceFile:45)\n     at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(SourceFile:227)\n     at rx.android.schedulers.FastPathScheduler$FastPathWorker.schedule(SourceFile:102)\n     at rx.android.schedulers.FastPathScheduler$FastPathWorker.schedule(SourceFile:90)\n     at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.schedule(SourceFile:190)\n     at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext(SourceFile:165)\n     at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(SourceFile:76)\n     at rx.internal.operators.OperatorThrottleFirst$1.onNext(SourceFile:53)\n     at rx.observers.SerializedObserver.onNext(SourceFile:92)\n     at rx.observers.SerializedSubscriber.onNext(SourceFile:94)\n     at rx.internal.operators.OperatorWithLatestFrom$1.onNext(SourceFile:60)\n     at rx.internal.operators.OperatorDistinctUntilChanged$1.onNext(SourceFile:102)\n     at rx.internal.operators.OperatorThrottleFirst$1.onNext(SourceFile:53)\n     at rx.internal.operators.OperatorScan$2.onNext(SourceFile:116)\n     at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(SourceFile:77)\n     at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(SourceFile:76)\n     at rx.internal.operators.OnSubscribeRefCount$2.onNext(SourceFile:120)\n     at rx.internal.operators.NotificationLite.accept(SourceFile:152)\n     at rx.internal.operators.OperatorReplay$BoundedReplayBuffer.replay(SourceFile:1093)\n     at rx.internal.operators.OperatorReplay$InnerProducer.request(SourceFile:711)\n     at rx.Subscriber.setProducer(SourceFile:211)\n     at rx.Subscriber.setProducer(SourceFile:205)\n     at rx.internal.operators.OnSubscribeMap$MapSubscriber.setProducer(SourceFile:102)\n     at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.setProducer(SourceFile:104)\n     at rx.Subscriber.setProducer(SourceFile:205)\n     at rx.internal.operators.OperatorReplay$7.call(SourceFile:241)\n     at rx.internal.operators.OperatorReplay$7.call(SourceFile:202)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OnSubscribeRefCount.doSubscribe(SourceFile:112)\n     at rx.internal.operators.OnSubscribeRefCount.call(SourceFile:80)\n     at rx.internal.operators.OnSubscribeRefCount.call(SourceFile:34)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OnSubscribeFilter.call(SourceFile:45)\n     at rx.internal.operators.OnSubscribeFilter.call(SourceFile:30)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OnSubscribeMap.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeMap.call(SourceFile:33)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OnSubscribeFilter.call(SourceFile:45)\n     at rx.internal.operators.OnSubscribeFilter.call(SourceFile:30)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.Observable.subscribe(SourceFile:9957)\n     at rx.Observable.subscribe(SourceFile:9924)\n     at rx.Observable.subscribe(SourceFile:9832)\n     at com.ubercab.presidio.app.optional.root.main.ride.request.home.map_layer.HomeMapLayerInteractor.__trackDeviceLocation$Impl(SourceFile:156)\n     at com.ubercab.presidio.app.optional.root.main.ride.request.home.map_layer.HomeMapLayerInteractor.trackDeviceLocation(SourceFile)\n     at com.ubercab.presidio.app.optional.root.main.ride.request.home.map_layer.HomeMapLayerInteractor.__didBecomeActive$Impl(SourceFile:70)\n     at com.ubercab.presidio.app.optional.root.main.ride.request.home.map_layer.HomeMapLayerInteractor.access$200(SourceFile)\n     at com.uber.rib.core.Interactor.dispatchAttach(SourceFile:90)\n     at com.uber.rib.core.Router.dispatchAttach(SourceFile:109)\n     at com.uber.rib.core.Router.attachChild(SourceFile:80)\n     at com.ubercab.presidio.app.core.root.main.ride.request.home.HomeRouter.__routeToHomeMapLayer$Impl(SourceFile:314)\n     at com.ubercab.presidio.app.core.root.main.ride.request.home.HomeRouter.__removeViewAndDetach$Impl(SourceFile)\n     at com.ubercab.presidio.app.core.root.main.ride.request.home.HomeInteractor$2.onNext(SourceFile:118)\n     at com.ubercab.presidio.app.core.root.main.ride.request.home.HomeInteractor$2.onNext(SourceFile:114)\n     at rx.internal.util.ObserverSubscriber.onNext(SourceFile:34)\n     at rx.observers.SafeSubscriber.onNext(SourceFile:134)\n     at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(SourceFile:227)\n     at rx.android.schedulers.FastPathScheduler$FastPathWorker.schedule(SourceFile:102)\n     at rx.android.schedulers.FastPathScheduler$FastPathWorker.schedule(SourceFile:90)\n     at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.schedule(SourceFile:190)\n     at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext(SourceFile:165)\n     at rx.observers.SerializedObserver.onNext(SourceFile:92)\n     at rx.observers.SerializedSubscriber.onNext(SourceFile:94)\n     at rx.internal.operators.OperatorTakeUntil$1.onNext(SourceFile:45)\n     at rx.internal.operators.NotificationLite.accept(SourceFile:152)\n     at com.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.accept$a2d69e2(SourceFile:311)\n     at com.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.emitLoop$1332631(SourceFile:282)\n     at com.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.emitFirst$a2d69e2(SourceFile:259)\n     at com.jakewharton.rxrelay.BehaviorRelay$1.call(SourceFile:81)\n     at com.jakewharton.rxrelay.BehaviorRelay$1.call(SourceFile:79)\n     at com.jakewharton.rxrelay.RelaySubscriptionManager.add(SourceFile:100)\n     at com.jakewharton.rxrelay.RelaySubscriptionManager.call(SourceFile:59)\n     at com.jakewharton.rxrelay.RelaySubscriptionManager.call(SourceFile:36)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:48)\n     at rx.internal.operators.OnSubscribeLift.call(SourceFile:30)\n     at rx.Observable.subscribe(SourceFile:9957)\n     at rx.Observable.subscribe(SourceFile:9924)\n     at rx.Observable.subscribe(SourceFile:9832)\n     at com.ubercab.presidio.app.core.root.main.ride.request.home.HomeInteractor.__startHomeFlow$Impl(SourceFile:114)\n     at com.ubercab.presidio.app.core.root.main.ride.request.home.HomeInteractor.startHomeFlow(SourceFile)\n     at com.ubercab.presidio.app.core.root.main.ride.request.home.HomeInteractor.access$000(SourceFile:46)\n     at com.ubercab.presidio.app.core.root.main.ride.request.home.HomeInteractor$1.onSuccess(SourceFile:71)\n     at com.ubercab.presidio.app.core.root.main.ride.request.home.HomeInteractor$1.onSuccess(SourceFile:68)\n     at rx.Single$18.onNext(SourceFile:1888)\n     at rx.observers.SafeSubscriber.onNext(SourceFile:134)\n     at rx.observers.Subscribers$5.onNext(SourceFile:235)\n     at rx.internal.operators.OperatorDoOnEach$1.onNext(SourceFile:86)\n     at rx.observers.SerializedObserver.onNext(SourceFile:92)\n     at rx.observers.SerializedSubscriber.onNext(SourceFile:94)\n     at rx.Single$21$1.onNext(SourceFile:2057)\n     at rx.internal.producers.SingleDelayedProducer.emit(SourceFile:102)\n     at rx.internal.producers.SingleDelayedProducer.setValue(SourceFile:85)\n     at rx.Single$1$1.onSuccess(SourceFile:80)\n     at rx.internal.operators.OnSubscribeSingle$1.onCompleted(SourceFile:55)\n     at rx.observers.Subscribers$5.onCompleted(SourceFile:225)\n     at rx.internal.util.ScalarSynchronousObservable$WeakSingleProducer.request(SourceFile:285)\n     at rx.Subscriber.setProducer(SourceFile:211)\n     at rx.Subscriber.setProducer(SourceFile:205)\n     at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(SourceFile:138)\n     at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(SourceFile:129)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OnSubscribeDelaySubscriptionOther$1.onCompleted(SourceFile:74)\n     at rx.Completable$28.onCompleted(SourceFile:2079)\n     at rx.Completable$22$1$1.call(SourceFile:1619)\n     at rx.android.schedulers.FastPathScheduler$FastPathWorker.schedule(SourceFile:102)\n     at rx.android.schedulers.FastPathScheduler$FastPathWorker.schedule(SourceFile:90)\n     at rx.Completable$22$1.onCompleted(SourceFile:1615)\n     at rx.Completable$3$1.onCompleted(SourceFile:135)\n     at rx.Completable$10$1.onCompleted(SourceFile:559)\n     at rx.internal.operators.NotificationLite.accept(SourceFile:142)\n     at rx.subjects.SubjectSubscriptionManager$SubjectObserver.accept$a2d69e2(SourceFile:320)\n     at rx.subjects.SubjectSubscriptionManager$SubjectObserver.emitLoop$1332631(SourceFile:293)\n     at rx.subjects.SubjectSubscriptionManager$SubjectObserver.emitFirst$a2d69e2(SourceFile:272)\n     at rx.subjects.BehaviorSubject$1.call(SourceFile:111)\n     at rx.subjects.BehaviorSubject$1.call(SourceFile:107)\n     at rx.subjects.SubjectSubscriptionManager.add(SourceFile:97)\n     at rx.subjects.SubjectSubscriptionManager.call(SourceFile:62)\n     at rx.subjects.SubjectSubscriptionManager.call(SourceFile:35)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.Completable$10.call(SourceFile:573)\n     at rx.Completable$10.call(SourceFile:552)\n     at rx.Completable.unsafeSubscribe(SourceFile:2028)\n     at rx.Completable$3.call(SourceFile:175)\n     at rx.Completable$3.call(SourceFile:122)\n     at rx.Completable.unsafeSubscribe(SourceFile:2028)\n     at rx.Completable$22.call(SourceFile:1611)\n     at rx.Completable$22.call(SourceFile:1600)\n     at rx.Completable.unsafeSubscribe(SourceFile:2028)\n     at rx.Completable.unsafeSubscribe$3c21ec27(SourceFile:2076)\n     at rx.Completable.unsafeSubscribe(SourceFile:2060)\n     at rx.Completable$30.call(SourceFile:2245)\n     at rx.Completable$30.call(SourceFile:2242)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OnSubscribeDelaySubscriptionOther.call(SourceFile:80)\n     at rx.internal.operators.OnSubscribeDelaySubscriptionOther.call(SourceFile:31)\n     at rx.Observable.unsafeSubscribe(SourceFile:9861)\n     at rx.internal.operators.OnSubscribeSingle.call(SourceFile:81)\n     at rx.internal.operators.OnSubscribeSingle.call(SourceFile:27)\n     at rx.Single$1.call(SourceFile:90)\n     at rx.Single$1.call(SourceFile:70)\n     at rx.Single$2.call(SourceFile:171)\n     at rx.Single$2.call(SourceFile:163)\n     at rx.Single$2.call(SourceFile:171)\n     at rx.Single$2.call(SourceFile:163)\n     at rx.Single$2.call(SourceFile:171)\n     at rx.Single$2.call(SourceFile:163)\n     at rx.Single.subscribe(SourceFile:1816)\n     at rx.Single.subscribe(SourceFile:1893)\n     at com.ubercab.presidio.app.core.root.main.ride.request.home.HomeInteractor.__didBecomeActive$Impl(SourceFile:68)\n     at com.ubercab.presidio.app.core.root.main.ride.request.home.HomeInteractor.access$000(SourceFile)\n     at com.uber.rib.core.Interactor.dispatchAttach(SourceFile:90)\n     at com.uber.rib.core.Router.dispatchAttach(SourceFile:109)\n     at com.uber.rib.core.Router.attachChild(SourceFile:80)\n     at com.uber.rib.core.RouterNavigator$2.call(SourceFile:125)\n     at com.uber.rib.core.RouterNavigator.internalPush(SourceFile:237)\n     at com.uber.rib.core.RouterNavigator.pushTransientState(SourceFile:119)\n     at com.ubercab.presidio.app.core.root.main.ride.request.RequestRouter.__routeToHome$Impl(SourceFile:117)\n     at com.ubercab.presidio.app.core.root.main.ride.request.RequestRouter.routeToHome(SourceFile)\n     at com.ubercab.presidio.app.core.root.main.ride.request.RequestInteractor$RequestFlowSubscriber.onNext(SourceFile:642)\n     at com.ubercab.presidio.app.core.root.main.ride.request.RequestInteractor$RequestFlowSubscriber.onNext(SourceFile:610)\n     at rx.internal.util.ObserverSubscriber.onNext(SourceFile:34)\n     at rx.observers.SafeSubscriber.onNext(SourceFile:134)\n     at rx.observers.SerializedObserver.onNext(SourceFile:92)\n     at rx.observers.SerializedSubscriber.onNext(SourceFile:94)\n     at rx.internal.operators.OperatorTakeUntil$1.onNext(SourceFile:45)\n     at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(SourceFile:227)\n     at rx.android.schedulers.FastPathScheduler$FastPathWorker.schedule(SourceFile:102)\n     at rx.android.schedulers.FastPathScheduler$FastPathWorker.schedule(SourceFile:90)\n     at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.schedule(SourceFile:190)\n     at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext(SourceFile:165)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.drain(SourceFile:285)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.combine(SourceFile:228)\n     at rx.internal.operators.OnSubscribeCombineLatest$CombinerSubscriber.onNext(SourceFile:379)\n     at rx.observers.SafeSubscriber.onNext(SourceFile:134)\n     at rx.internal.operators.OperatorDistinctUntilChanged$1.onNext(SourceFile:96)\n     at rx.internal.operators.OperatorDistinctUntilChanged$1.onNext(SourceFile:96)\n     at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(SourceFile:77)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.drain(SourceFile:285)\n     at rx.internal.operators.OnSubscribeCombineLatest$LatestCoordinator.combine(SourceFile:228)\n     at rx.internal.operators.OnSubscribeCombineLatest$CombinerSubscriber.onNext(SourceFile:379)\n     at rx.observers.SafeSubscriber.onNext(SourceFile:134)\n     at rx.internal.operators.NotificationLite.accept(SourceFile:152)\n     at com.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.emitNext$a2d69e2(SourceFile:240)\n     at com.jakewharton.rxrelay.BehaviorRelay.call(SourceFile:100)\n     at com.ubercab.presidio.app.core.root.main.ride.request.RequestWaypointWorker.clearDestinationWaypoints(SourceFile:173)\n     at com.ubercab.presidio.app.core.root.main.ride.request.RequestInteractor$RequestFlowSubscriber$2.run(SourceFile:650)\n     at com.ubercab.presidio.app.core.root.main.ride.request.RequestInteractor.__handleBackPress$Impl(SourceFile:214)\n     at com.ubercab.presidio.app.core.root.main.ride.request.RequestInteractor.handleBackPress(SourceFile)\n     at com.uber.rib.core.Router.handleBackPress(SourceFile:53)\n     at com.ubercab.presidio.app.core.root.main.ride.RideRouter.__passBackPressToChildren$Impl(SourceFile:313)\n     at com.ubercab.presidio.app.core.root.main.ride.RideRouter.passBackPressToChildren(SourceFile)\n     at com.ubercab.presidio.app.core.root.main.ride.RideInteractor.__handleBackPress$Impl(SourceFile:335)\n     at com.ubercab.presidio.app.core.root.main.ride.RideInteractor.handleBackPress(SourceFile)\n     at com.uber.rib.core.Router.handleBackPress(SourceFile:53)\n     at com.ubercab.presidio.app.core.root.main.MainRouter.__passBackPressToChildren$Impl(SourceFile:217)\n     at com.ubercab.presidio.app.core.root.main.MainRouter.passBackPressToChildren(SourceFile)\n     at com.ubercab.presidio.app.core.root.main.MainInteractor.__handleBackPress$Impl(SourceFile:232)\n     at com.ubercab.presidio.app.core.root.main.MainInteractor.handleBackPress(SourceFile)\n     at com.uber.rib.core.Router.handleBackPress(SourceFile:53)\n     at com.ubercab.presidio.app.core.root.RootRouter.__passBackPressToChildren$Impl(SourceFile:201)\n     at com.ubercab.presidio.app.core.root.RootRouter.passBackPressToChildren(SourceFile)\n     at com.ubercab.presidio.app.core.root.RootInteractor.__handleBackPress$Impl(SourceFile:330)\n     at com.ubercab.presidio.app.core.root.RootInteractor.handleBackPress(SourceFile)\n     at com.uber.rib.core.Router.handleBackPress(SourceFile:53)\n     at com.uber.rib.core.RibActivity.onBackPressed(SourceFile:183)\n     at android.app.Activity.onKeyUp(Activity.java:2266)\n     at android.view.KeyEvent.dispatch(KeyEvent.java:2724)\n     at android.app.Activity.dispatchKeyEvent(Activity.java:2496)\n     at android.support.v7.app.AppCompatActivity.dispatchKeyEvent(SourceFile:543)\n     at android.support.v7.view.WindowCallbackWrapper.dispatchKeyEvent(SourceFile:53)\n     at android.support.v7.app.AppCompatDelegateImplBase$AppCompatWindowCallbackBase.dispatchKeyEvent(SourceFile:315)\n     at com.android.internal.policy.impl.PhoneWindow$DecorView.dispatchKeyEvent(PhoneWindow.java:1965)\n     at android.view.ViewRootImpl$ViewPostImeInputStage.processKeyEvent(ViewRootImpl.java:4022)\n     at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:3994)\n     at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3555)\n     at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3605)\n     at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3574)\n     at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3681)\n     at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3582)\n     at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:3738)\n     at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3555)\n     at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3605)\n     at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3574)\n     at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3582)\n     at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3555)\n     at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3605)\n     at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3574)\n     at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3714)\n     at android.view.ViewRootImpl$ImeInputStage.onFinishedInputEvent(ViewRootImpl.java:3877)\n     at android.view.inputmethod.InputMethodManager$PendingEvent.run(InputMethodManager.java:2026)\n     at android.view.inputmethod.InputMethodManager.invokeFinishedInputEventCallback(InputMethodManager.java:1720)\n     at android.view.inputmethod.InputMethodManager.finishedInputEvent(InputMethodManager.java:1711)\n     at android.view.inputmethod.InputMethodManager$ImeInputEventSender.onInputEventFinished(InputMethodManager.java:2003)\n     at android.view.InputEventSender.dispatchInputEventFinished(InputEventSender.java:141)\n     at android.os.MessageQueue.nativePollOnce(Native Method)\n     at android.os.MessageQueue.next(MessageQueue.java:138)\n     at android.os.Looper.loop(Looper.java:131)\n     at android.app.ActivityThread.main(ActivityThread.java:5268)\n     at java.lang.reflect.Method.invokeNative(Native Method)\n     at java.lang.reflect.Method.invoke(Method.java:515)\n     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:793)\n     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:609)\n     at dalvik.system.NativeStart.main(Native Method)\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-11T08:06:58Z",
        "body": "You can break this long stack by introducing `observeOn(AndroidSchedulers.mainThread())` at few places.\n"
      },
      {
        "user": "haiminh87",
        "created_at": "2016-11-16T00:50:09Z",
        "body": "Yes, but it's mostly a hack to add observeOn just to break the long stack. Logically, the code hasn't change thread yet.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-16T12:49:57Z",
        "body": "There is the option to increase the app's stack size to accomodate the long chains you are unwilling to break up with `observeOn`.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-12-15T12:08:34Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      },
      {
        "user": "CodyEngel",
        "created_at": "2017-03-30T18:03:43Z",
        "body": "I just wanted to chime in on this and say that adding `observeOn` seemed to resolve the issue for me.\r\n\r\nWe're still on 1.2.1 and I have a fairly intense chain for syncing offline data, it's making multiple network calls and multiple database calls for each set of users that have offline data. Before it was crashing on API 19 (everything I tested on with post-lollipop worked fine) and it's no longer crashing after adding several `observeOn` calls after some of my operators."
      }
    ]
  },
  {
    "number": 4829,
    "title": "subscribeOn (rx.Scheduler) in Observable cannot be applied to (io.reactivex.Scheduler) ",
    "created_at": "2016-11-10T07:49:33Z",
    "closed_at": "2016-11-10T15:34:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4829",
    "body": "   Gradle:\r\n    // 编译RxJava\r\n    compile 'io.reactivex:rxjava:1.2.2'\r\n    // 编译RxAndroid\r\n    compile 'io.reactivex:rxandroid:1.2.1'\r\n    // 编译Retrofit网络加载框架\r\n    compile 'com.squareup.retrofit2:retrofit:2.1.0'\r\n    // 编译Retrofit网络加载框架直接解析JSON数据变成JAVA对象\r\n    compile 'com.squareup.retrofit2:converter-gson:2.1.0'\r\n    // 编译Retrofit对RxJava的支持\r\n    compile 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0'",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4829/comments",
    "author": "ljf1172361058",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-10T08:26:37Z",
        "body": "You have the wrong imports:\n\n```\ncompile 'io.reactivex.rxjava2:rxjava:2.0.0'\ncompile 'io.reactivex.rxjava2:rxandroid:2.0.0'\n```\n"
      },
      {
        "user": "ljf1172361058",
        "created_at": "2016-11-10T09:24:37Z",
        "body": "@akarnokd thank you\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-10T15:34:52Z",
        "body": "You are welcome.\n"
      }
    ]
  },
  {
    "number": 4821,
    "title": "Question: Observable no longer throwing MissingBackpressureException",
    "created_at": "2016-11-08T09:57:47Z",
    "closed_at": "2016-11-08T10:28:24Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4821",
    "body": "Hello, \r\nI understand as with RxJava2.x that Observable is not backpressure aware by default.\r\nI had a piece of code that I was expecting to throw MissingBackpressureException. It did with RxJava1.x\r\n\r\n```\r\nObservable.create(subscriber -> {\r\n            log.info(\"Started emitting\");\r\n\r\n            for (int i = 0; i < 200; i++) {\r\n                log.info(\"Emitting {}\", i);\r\n                subscriber.onNext(i);\r\n            }\r\n\r\n            subscriber.onComplete();\r\n        });\r\nobservable = observable\r\n                .observeOn(Schedulers.io());\r\n        CountDownLatch latch = new CountDownLatch(1);\r\n        observable.subscribe(slowObserver(latch));\r\n        Helpers.wait(latch);\r\n\r\n\r\n    private <T> Observer<T> slowObserver(CountDownLatch latch) {\r\n        return new Observer<T>() {\r\n            @Override\r\n            public void onSubscribe(Disposable d) {\r\n            }\r\n\r\n            @Override\r\n            public void onNext(Object value) {\r\n                log.info(\"Got {}\", value);\r\n                Helpers.sleepMillis(100);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable err) {\r\n                log.error(\"Subscriber got error\", err);\r\n                latch.countDown();\r\n            }\r\n\r\n            @Override\r\n            public void onComplete() {\r\n                log.info(\"Completed\");\r\n                latch.countDown();\r\n            }\r\n        };\r\n    }\r\n```\r\nI see that the buffer size should be Integer.getInteger(\"rx2.buffer-size\", 128) - and it's 128 in my case, however no exception is thrown.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4821/comments",
    "author": "balamaci",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-08T10:15:15Z",
        "body": "`Observable` operators use unbounded buffers which use linked arrays, of lenght 128 each section by default, to reduce allocation pressure. They are not there to limit the element count travelling through.\n"
      },
      {
        "user": "balamaci",
        "created_at": "2016-11-08T10:28:24Z",
        "body": "Ok, I understand. Thanks for explaining it.\n"
      }
    ]
  },
  {
    "number": 4817,
    "title": "How to stop sending data from Flowable.fromIterable.",
    "created_at": "2016-11-07T07:48:15Z",
    "closed_at": "2016-12-05T11:22:28Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4817",
    "body": "```java\r\njava.net.UnknownHostException: Unable to resolve host \"nshop.goujiawang.com\": No address associated with hostname\r\n\tat java.net.InetAddress.lookupHostByName(InetAddress.java:440)\r\n\tat java.net.InetAddress.getAllByNameImpl(InetAddress.java:252)\r\n\tat java.net.InetAddress.getAllByName(InetAddress.java:215)\r\n\tat okhttp3.Dns$1.lookup(Dns.java:39)\r\n\tat okhttp3.internal.connection.RouteSelector.resetNextInetSocketAddress(RouteSelector.java:172)\r\n\tat okhttp3.internal.connection.RouteSelector.nextProxy(RouteSelector.java:138)\r\n\tat okhttp3.internal.connection.RouteSelector.next(RouteSelector.java:80)\r\n\tat okhttp3.internal.connection.StreamAllocation.findConnection(StreamAllocation.java:178)\r\n\tat okhttp3.internal.connection.StreamAllocation.findHealthyConnection(StreamAllocation.java:129)\r\n\tat okhttp3.internal.connection.StreamAllocation.newStream(StreamAllocation.java:98)\r\n\tat okhttp3.internal.connection.ConnectInterceptor.intercept(ConnectInterceptor.java:42)\r\n\tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\r\n\tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:67)\r\n\tat okhttp3.internal.cache.CacheInterceptor.intercept(CacheInterceptor.java:109)\r\n\tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\r\n\tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:67)\r\n\tat okhttp3.internal.http.BridgeInterceptor.intercept(BridgeInterceptor.java:93)\r\n\tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\r\n\tat okhttp3.internal.http.RetryAndFollowUpInterceptor.intercept(RetryAndFollowUpInterceptor.java:124)\r\n\tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\r\n\tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:67)\r\n\tat okhttp3.logging.HttpLoggingInterceptor.intercept(HttpLoggingInterceptor.java:212)\r\n\tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\r\n\tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:67)\r\n\tat okhttp3.RealCall.getResponseWithInterceptorChain(RealCall.java:170)\r\n\tat okhttp3.RealCall.execute(RealCall.java:60)\r\n\tat retrofit2.OkHttpCall.execute(OkHttpCall.java:174)\r\n\tat com.jakewharton.retrofit2.adapter.rxjava2.CallObservable.subscribeActual(CallObservable.java:41)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:10151)\r\n\tat com.jakewharton.retrofit2.adapter.rxjava2.BodyObservable.subscribeActual(BodyObservable.java:34)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:10151)\r\n\tat io.reactivex.internal.operators.flowable.FlowableFromObservable.subscribeActual(FlowableFromObservable.java:31)\r\n\tat io.reactivex.Flowable.subscribe(Flowable.java:12172)\r\n\tat io.reactivex.internal.operators.flowable.FlowableOnBackpressureLatest.subscribeActual(FlowableOnBackpressureLatest.java:31)\r\n\tat io.reactivex.Flowable.subscribe(Flowable.java:12172)\r\n\tat io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.onNext(FlowableFlatMap.java:156)\r\n\tat io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync(FlowableObserveOn.java:399)\r\n\tat io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run(FlowableObserveOn.java:175)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:154)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:269)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\r\n\tat java.lang.Thread.run(Thread.java:818)\r\n```\r\n```java\r\nupload = Flowable.fromIterable(view.getUploadFiles())\r\n                .filter(new Predicate<String>() {\r\n                    @Override\r\n                    public boolean test(String s) {\r\n                        L.i(\"-------------1111\");\r\n                        return !TextUtils.isEmpty(s);\r\n                    }\r\n                })\r\n                .map(new Function<String, RequestBody>() {\r\n                    @Override\r\n                    public RequestBody apply(String s) throws Exception {\r\n                        L.i(\"-------------2222\");\r\n                        return UpLoadUtils.getRequestBody(s);\r\n                    }\r\n                })\r\n                .observeOn(Schedulers.io())\r\n                .flatMap(new Function<RequestBody, Publisher<BaseRes<UploadImagData>>>() {\r\n                    @Override\r\n                    public Publisher<BaseRes<UploadImagData>> apply(RequestBody requestBody) throws Exception {\r\n                        L.i(\"-------------3333\");\r\n                        return RServices.get().uploadImg(view.getJSessionId(), requestBody);\r\n                    }\r\n                })\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .doOnError(new Consumer<Throwable>() {\r\n                    @Override\r\n                    public void accept(Throwable throwable) throws Exception {\r\n                        L.i(\"-------------4444\");\r\n                        upload.dispose();\r\n                        view.dismissDialog();\r\n                        T.show(context, context.getString(R.string.network_not_well));\r\n                    }\r\n                })\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribeWith(new ResourceSubscriber<BaseRes<UploadImagData>>() {\r\n                    @Override\r\n                    public void onNext(BaseRes<UploadImagData> baseRes) {\r\n                        view.showDialogProgress(\"正在上传图片\", \"第\" + ++current + \"张\");\r\n                        picPaths.add(baseRes.getResult().getId());\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(Throwable t) {\r\n                        L.i(\"-------------5555\");\r\n//                        upload.dispose();\r\n                        view.dismissDialog();\r\n                        T.show(context, context.getString(R.string.network_not_well));\r\n                    }\r\n\r\n                    @Override\r\n                    public void onComplete() {\r\n                        submitMaterialQuality(picPaths);\r\n                    }\r\n                });\r\n```\r\nAndroid 6.0.1 & RxJava2\r\n\r\nI close network,and execute 'upload' 10 times. this error happened.\r\nI used doOnError to catch the error, if  I execute less times, it would not happened.but much times,it happened.I think if catching error and stop sending data,it would not happened.\r\nhow to stop Flowable sending data?\r\n\r\nThis problem bothering me for a long time, can helping me?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4817/comments",
    "author": "yubaokang",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-07T08:06:34Z",
        "body": "The error is with some name lookup inside Okio: `java.net.UnknownHostException: Unable to resolve host \"nshop.goujiawang.com\": No address associated with hostname` and doesn't appear to be related to RxJava.\n\n> how to stop Flowable sending data?\n\nPlease read about `takeUntil` and `takeWhile`.\n"
      },
      {
        "user": "Mauin",
        "created_at": "2016-11-07T08:15:45Z",
        "body": "If you \"close\", as in turn off the network then you're going to run into network errors like the one you posted above.\n\nSince your `doOnError` and `onError` callback are very similar as well, I don't see much difference. When the network call runs into an error due to network issues, the Flowable will emit `onError` and thus no data will be transferred anymore (in the case above no data is transferred at all, because the Host cannot be found).\n"
      },
      {
        "user": "yubaokang",
        "created_at": "2016-11-07T08:33:28Z",
        "body": "@Mauin  @akarnokd \nContinuous calls ......\nlog: \n\n``` java\n11-07 16:30:04.876 $5.test(L:78): -------------1111\n11-07 16:30:04.877 $4.apply(L:85): -------------2222\n11-07 16:30:04.887 $5.test(L:78): -------------1111\n11-07 16:30:04.888 $4.apply(L:85): -------------2222\n11-07 16:30:04.889 $5.test(L:78): -------------1111\n11-07 16:30:04.889 $4.apply(L:85): -------------2222\n11-07 16:30:04.890 $5.test(L:78): -------------1111\n11-07 16:30:04.891 $4.apply(L:85): -------------2222\n11-07 16:30:04.892 $5.test(L:78): -------------1111\n11-07 16:30:04.893 $4.apply(L:85): -------------2222\n11-07 16:30:04.894 $5.test(L:78): -------------1111\n11-07 16:30:04.894 $4.apply(L:85): -------------2222\n11-07 16:30:04.895 $5.test(L:78): -------------1111\n11-07 16:30:04.899 22345-22598/ $3.apply(L:93): -------------3333\n11-07 16:30:05.220 22345-22598/ $3.apply(L:93): -------------3333\n11-07 16:30:05.223 $2.accept(L:101): -------------4444\n11-07 16:30:05.476 $5.test(L:78): -------------1111\n11-07 16:30:05.477 $4.apply(L:85): -------------2222\n11-07 16:30:05.478 22345-22812/ $3.apply(L:93): -------------3333\n11-07 16:30:05.478 $5.test(L:78): -------------1111\n11-07 16:30:05.478 $4.apply(L:85): -------------2222\n11-07 16:30:05.479 $5.test(L:78): -------------1111\n11-07 16:30:05.479 $4.apply(L:85): -------------2222\n11-07 16:30:05.480 $5.test(L:78): -------------1111\n11-07 16:30:05.481 $4.apply(L:85): -------------2222\n11-07 16:30:05.482 $5.test(L:78): -------------1111\n11-07 16:30:05.483 $4.apply(L:85): -------------2222\n11-07 16:30:05.484 $5.test(L:78): -------------1111\n11-07 16:30:05.484 $4.apply(L:85): -------------2222\n11-07 16:30:05.485 $5.test(L:78): -------------1111\n11-07 16:30:05.706 22345-22812/ $3.apply(L:93): -------------3333\n11-07 16:30:05.713 $2.accept(L:101): -------------4444\n11-07 16:30:05.814 $4.apply(L:85): -------------2222\n11-07 16:30:05.819 $4.apply(L:85): -------------2222\n11-07 16:30:06.003 22345-22803/ $3.apply(L:93): -------------3333\n11-07 16:30:06.016 $2.accept(L:101): -------------4444\n11-07 16:30:06.140 $5.test(L:78): -------------1111\n11-07 16:30:06.140 $4.apply(L:85): -------------2222\n11-07 16:30:06.141 22345-22598/ $3.apply(L:93): -------------3333\n11-07 16:30:06.141 $5.test(L:78): -------------1111\n11-07 16:30:06.142 $4.apply(L:85): -------------2222\n11-07 16:30:06.144 $5.test(L:78): -------------1111\n11-07 16:30:06.145 $4.apply(L:85): -------------2222\n11-07 16:30:06.147 $5.test(L:78): -------------1111\n11-07 16:30:06.148 $4.apply(L:85): -------------2222\n11-07 16:30:06.149 $5.test(L:78): -------------1111\n11-07 16:30:06.150 $4.apply(L:85): -------------2222\n11-07 16:30:06.151 $5.test(L:78): -------------1111\n11-07 16:30:06.152 $4.apply(L:85): -------------2222\n11-07 16:30:06.152 $5.test(L:78): -------------1111\n11-07 16:30:06.329 22345-22598/ $3.apply(L:93): -------------3333\n11-07 16:30:06.350 $2.accept(L:101): -------------4444\n11-07 16:30:06.494 $5.test(L:78): -------------1111\n11-07 16:30:06.495 $4.apply(L:85): -------------2222\n11-07 16:30:06.495 22345-22812/ $3.apply(L:93): -------------3333\n11-07 16:30:06.496 $5.test(L:78): -------------1111\n11-07 16:30:06.496 $4.apply(L:85): -------------2222\n11-07 16:30:06.497 $5.test(L:78): -------------1111\n11-07 16:30:06.497 $4.apply(L:85): -------------2222\n11-07 16:30:06.498 $5.test(L:78): -------------1111\n11-07 16:30:06.499 $4.apply(L:85): -------------2222\n11-07 16:30:06.499 $5.test(L:78): -------------1111\n11-07 16:30:06.500 $4.apply(L:85): -------------2222\n11-07 16:30:06.501 $5.test(L:78): -------------1111\n11-07 16:30:06.501 $4.apply(L:85): -------------2222\n11-07 16:30:06.502 $5.test(L:78): -------------1111\n11-07 16:30:06.655 22345-22812/ $3.apply(L:93): -------------3333\n11-07 16:30:06.655 $2.accept(L:101): -------------4444\n11-07 16:30:06.828 $5.test(L:78): -------------1111\n11-07 16:30:06.829 $4.apply(L:85): -------------2222\n11-07 16:30:06.830 22345-22803/ $3.apply(L:93): -------------3333\n11-07 16:30:06.830 $5.test(L:78): -------------1111\n11-07 16:30:06.831 $4.apply(L:85): -------------2222\n11-07 16:30:06.832 $5.test(L:78): -------------1111\n11-07 16:30:06.833 $4.apply(L:85): -------------2222\n11-07 16:30:06.834 $5.test(L:78): -------------1111\n11-07 16:30:06.835 $4.apply(L:85): -------------2222\n11-07 16:30:06.836 $5.test(L:78): -------------1111\n11-07 16:30:06.837 $4.apply(L:85): -------------2222\n11-07 16:30:06.838 $5.test(L:78): -------------1111\n11-07 16:30:06.838 $4.apply(L:85): -------------2222\n11-07 16:30:06.839 $5.test(L:78): -------------1111\n11-07 16:30:07.030 22345-22803/ $3.apply(L:93): -------------3333\n11-07 16:30:07.063 $2.accept(L:101): -------------4444\n11-07 16:30:07.358 $5.test(L:78): -------------1111\n11-07 16:30:07.359 $4.apply(L:85): -------------2222\n11-07 16:30:07.360 22345-22598/ $3.apply(L:93): -------------3333\n11-07 16:30:07.360 $5.test(L:78): -------------1111\n11-07 16:30:07.361 $4.apply(L:85): -------------2222\n11-07 16:30:07.362 $5.test(L:78): -------------1111\n11-07 16:30:07.364 $4.apply(L:85): -------------2222\n11-07 16:30:07.365 $5.test(L:78): -------------1111\n11-07 16:30:07.366 $4.apply(L:85): -------------2222\n11-07 16:30:07.368 $5.test(L:78): -------------1111\n11-07 16:30:07.369 $4.apply(L:85): -------------2222\n11-07 16:30:07.371 $5.test(L:78): -------------1111\n11-07 16:30:07.372 $4.apply(L:85): -------------2222\n11-07 16:30:07.373 $5.test(L:78): -------------1111\n11-07 16:30:07.516 $5.test(L:78): -------------1111\n```\n\nand crash\n\n``` java\n FATAL EXCEPTION: RxCachedThreadScheduler-1\nProcess: , PID: 22345\njava.net.ConnectException: Failed to connect to /192.168.19.116:8099\n    at okhttp3.internal.connection.RealConnection.connectSocket(RealConnection.java:189)\n    at okhttp3.internal.connection.RealConnection.buildConnection(RealConnection.java:173)\n    at okhttp3.internal.connection.RealConnection.connect(RealConnection.java:114)\n    at okhttp3.internal.connection.StreamAllocation.findConnection(StreamAllocation.java:193)\n    at okhttp3.internal.connection.StreamAllocation.findHealthyConnection(StreamAllocation.java:129)\n    at okhttp3.internal.connection.StreamAllocation.newStream(StreamAllocation.java:98)\n    at okhttp3.internal.connection.ConnectInterceptor.intercept(ConnectInterceptor.java:42)\n    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\n    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:67)\n    at okhttp3.internal.cache.CacheInterceptor.intercept(CacheInterceptor.java:109)\n    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\n    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:67)\n    at okhttp3.internal.http.BridgeInterceptor.intercept(BridgeInterceptor.java:93)\n    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\n    at okhttp3.internal.http.RetryAndFollowUpInterceptor.intercept(RetryAndFollowUpInterceptor.java:124)\n    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\n    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:67)\n    at okhttp3.logging.HttpLoggingInterceptor.intercept(HttpLoggingInterceptor.java:212)\n    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:92)\n    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:67)\n    at okhttp3.RealCall.getResponseWithInterceptorChain(RealCall.java:170)\n    at okhttp3.RealCall.execute(RealCall.java:60)\n    at retrofit2.OkHttpCall.execute(OkHttpCall.java:174)\n    at com.jakewharton.retrofit2.adapter.rxjava2.CallObservable.subscribeActual(CallObservable.java:41)\n    at io.reactivex.Observable.subscribe(Observable.java:10151)\n    at com.jakewharton.retrofit2.adapter.rxjava2.BodyObservable.subscribeActual(BodyObservable.java:34)\n    at io.reactivex.Observable.subscribe(Observable.java:10151)\n    at io.reactivex.internal.operators.flowable.FlowableFromObservable.subscribeActual(FlowableFromObservable.java:31)\n    at io.reactivex.Flowable.subscribe(Flowable.java:12172)\n    at io.reactivex.internal.operators.flowable.FlowableOnBackpressureLatest.subscribeActual(FlowableOnBackpressureLatest.java:31)\n    at io.reactivex.Flowable.subscribe(Flowable.java:12172)\n    at io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.onNext(FlowableFlatMap.java:156)\n    at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync(FlowableObserveOn.java:399)\n    at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run(FlowableObserveOn.java:175)\n    at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)\n    at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:154)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:269)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\n    at java.lang.Thread.run(Thread.java:818)\n```\n"
      },
      {
        "user": "yubaokang",
        "created_at": "2016-11-07T08:40:03Z",
        "body": "add one premise, I had closed network.\n"
      },
      {
        "user": "Mauin",
        "created_at": "2016-11-07T08:40:50Z",
        "body": "@yubaokang So the app really crashes? It's expected that the exception occurs when network is not available. But it should be handled in `doOnError` or in the `onError` callback, not crash the app.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-07T08:43:22Z",
        "body": "This exception is again unrelated to RxJava. You seem to have a network problem in your local environment or there is a bug in `RServices.get().uploadImg` you are not showing that doesn't play well with network resources.\n\nIn addition, `doOnError` doesn't handle the exception it just peeks into that and you can perform side-effects at that point. To handle an error, use `onErrorResumeNext`, `onErrorReturn`, `retry` or `retryWhen`.\n"
      },
      {
        "user": "yubaokang",
        "created_at": "2016-11-07T08:50:28Z",
        "body": "@Mauin It crashes......\n"
      },
      {
        "user": "Mauin",
        "created_at": "2016-11-07T08:53:35Z",
        "body": "As @akarnokd mentioned, this is not related to RxJava but it seems like you're not handling errors coming from the HTTP Client correctly.\n"
      },
      {
        "user": "yubaokang",
        "created_at": "2016-11-07T08:54:05Z",
        "body": "@akarnokd but if executes one time ,It is well.and if not use rxjava, it also well. just use rxjava crash.\n"
      },
      {
        "user": "yubaokang",
        "created_at": "2016-11-07T09:02:28Z",
        "body": "When I call continuously, can appear sometimes crash, now I try will not appear again, really strange.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-12-05T11:22:27Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 4814,
    "title": "java.io.InterruptedIOException: thread interrupted ",
    "created_at": "2016-11-06T14:15:01Z",
    "closed_at": "2016-11-12T18:09:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4814",
    "body": "when i use retrofit and rxjava download file with progress.\r\n``` java\r\n11-03 22:52:35.048 18649-18699/better.hello W/System.err: java.io.InterruptedIOException: thread interrupted\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.Timeout.throwIfReached(Timeout.java:145)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.Okio$2.read(Okio.java:137)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.AsyncTimeout$2.read(AsyncTimeout.java:238)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.RealBufferedSource.read(RealBufferedSource.java:45)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okhttp3.internal.http.Http1xStream$FixedLengthSource.read(Http1xStream.java:381)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.RealBufferedSource.read(RealBufferedSource.java:45)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.ForwardingSource.read(ForwardingSource.java:35)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.OkHttpCall$ExceptionCatchingRequestBody$1.read(OkHttpCall.java:279)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.RealBufferedSource$1.read(RealBufferedSource.java:386)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at java.io.InputStream.read(InputStream.java:162)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at better.hello.util.FileUtils.writeFile(FileUtils.java:120)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at better.hello.common.UiHelper$1$1.call(UiHelper.java:29)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at better.hello.common.UiHelper$1$1.call(UiHelper.java:26)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.Observable.unsafeSubscribe(Observable.java:10200)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:248)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:148)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1$1.onNext(OperatorSubscribeOn.java:53)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.OperatorMapResponseToBodyOrError$1.onNext(OperatorMapResponseToBodyOrError.java:41)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.OperatorMapResponseToBodyOrError$1.onNext(OperatorMapResponseToBodyOrError.java:38)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$RequestArbiter.request(RxJavaCallAdapterFactory.java:173)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1$1$1.request(OperatorSubscribeOn.java:80)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.Subscriber.setProducer(Subscriber.java:211)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeMap$MapSubscriber.setProducer(OnSubscribeMap.java:102)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1$1.setProducer(OperatorSubscribeOn.java:76)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.Subscriber.setProducer(Subscriber.java:205)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$CallOnSubscribe.call(RxJavaCallAdapterFactory.java:152)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$CallOnSubscribe.call(RxJavaCallAdapterFactory.java:138)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.Observable.unsafeSubscribe(Observable.java:10200)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:228)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.lang.Thread.run(Thread.java:818)\r\n```\r\nthere is my snippet:\r\n``` java\r\nHttpUtil.downFile(mp4_url).subscribeOn(Schedulers.io()).flatMap(new Func1<ResponseBody, Observable<DownloadInfo>>() {\r\n            @Override\r\n            public Observable<DownloadInfo> call(final ResponseBody body) {\r\n                return Observable.create(new Observable.OnSubscribe<DownloadInfo>() {\r\n                    @Override\r\n                    public void call(Subscriber<? super DownloadInfo> subscriber) {\r\n                        FileUtils.writeFile(subscriber, body, fileName);\r\n                    }\r\n                });\r\n            }\r\n        }).unsubscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber<DownloadInfo>() {\r\n            @Override\r\n            public void onCompleted() {\r\n                \r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable e) {\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onNext(DownloadInfo info) {\r\n\r\n            }\r\n        });\r\n```\r\n``` java\r\npublic static void writeFile(Subscriber<? super DownloadInfo> subscriber, ResponseBody body, String fileName) {\r\n        try {\r\n            File file = getFile(fileName);\r\n            long readSize = 0, length = body.contentLength();\r\n            byte buffer[] = new byte[4096];\r\n            FileOutputStream outputStream = new FileOutputStream(file, true);\r\n            InputStream ins = body.byteStream();\r\n            DownloadInfo info = new DownloadInfo(length);\r\n            while (true) {\r\n                int read = ins.read(buffer);\r\n                if (read <= 0) {\r\n                    subscriber.onCompleted();\r\n                    break;\r\n                }\r\n                outputStream.write(buffer, 0, read);\r\n                readSize += read;\r\n                info.setReadFileSize(readSize);\r\n                info.setProgress(readSize / length);\r\n                subscriber.onNext(info);\r\n                Utils.d(\"Better\", \"下载了==\" + readSize + \",total=\" + length);\r\n            }\r\n            if (null != outputStream) {\r\n                outputStream.flush();\r\n                outputStream.close();\r\n            }\r\n            if (null != ins) {\r\n                ins.close();\r\n            }\r\n            if (null!=body){\r\n                body.close();\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            subscriber.onError(e);\r\n        }\r\n    }\r\n```\r\nif i do not call subscriber.onNext(info) in the while circle  ,everything will be ok ,and the file will be download correctly.The place where the error can occur is subscribe.onNext().I just do not known why.\r\nsomeone can help me ?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4814/comments",
    "author": "471448446",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-07T08:12:58Z",
        "body": "First, this looks like to be an unreliable network issue that times out. \n\nSecond, you are sending a mutable object downstream from that `onNext` which can lead to all sorts of undefined behavior. You should send a fresh object on every turn:\n\n``` java\n                DownloadInfo info = new DownloadInfo(length);\n                info.setReadFileSize(readSize);\n                info.setProgress(readSize / length);\n                subscriber.onNext(info);\n```\n\nThird, don't use `Observable.create` but use `Observable.fromEmitter`.\n"
      },
      {
        "user": "471448446",
        "created_at": "2016-11-08T14:45:15Z",
        "body": "@akarnokd Thanks for your reply,according to your advice it did work.This problem troubled me a few days.3Q.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T18:09:14Z",
        "body": "Great!\n"
      },
      {
        "user": "rafaelcheckapp",
        "created_at": "2018-12-20T00:26:16Z",
        "body": "Thanks @akarnokd this has been driving me crazy for days, someone left a .create hidden XD"
      }
    ]
  },
  {
    "number": 4806,
    "title": "Can I force zip opertaer work on AndroidSchedulers.mainThread()",
    "created_at": "2016-11-04T08:47:24Z",
    "closed_at": "2016-11-04T09:01:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4806",
    "body": "zip combine varlues on the Scheduler which last Observable worked on.\r\nI want zip operate work on AndroidSchedulers.mainThread() or anyone of the Observable Schedulers.\r\n\r\nHow could I do?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4806/comments",
    "author": "lengyue524",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-04T08:50:23Z",
        "body": "2 options\n-  apply `observeOn(AndroidSchedulers.mainThread())` on all of its inputs\n- identity map (or pair up) the zipper function's input, apply `observeOn` after the zip then use `map` to work with the pair/array of values.\n"
      },
      {
        "user": "lengyue524",
        "created_at": "2016-11-04T09:00:52Z",
        "body": "Thanks, It works.\n"
      }
    ]
  },
  {
    "number": 4802,
    "title": "Observable depends on other Observable | Needing both values",
    "created_at": "2016-11-03T20:39:01Z",
    "closed_at": "2016-11-04T12:41:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4802",
    "body": "I have an Observable whose emitted item I need for the next Observable but I can't use flatMap() because the method I need to call in the Subscriber needs the result of both Observables.\r\n\r\n```java\r\nservice.getToken(code)\r\n          .subscribe(new Action1<Token>() {\r\n                        @Override\r\n                        public void call(Token token) {\r\n                            service.getProfile(token.getAccessToken())\r\n                                    .subscribe(\r\n                                    new Action1<Profile>() {\r\n                                        @Override\r\n                                        public void call(Profile profile) {\r\n                                            createAccount(token, profile);\r\n                                        }\r\n                                    });\r\n                        }\r\n                    });\r\n```\r\n\r\nAny better approach then this?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4802/comments",
    "author": "metp",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-03T20:56:32Z",
        "body": "Use the `flatMap` that takes a second `Func2`:\n\n``` java\nservice.getToken()\n.flatMap(token -> service.getProfile(token.getAccessToken()),\n    (token, profile) -> { createAccount(token, profile); return true; })\n.subscribe(v -> { }, Throwable::printStackTrace)\n```\n"
      },
      {
        "user": "metp",
        "created_at": "2016-11-04T12:41:48Z",
        "body": "Thank you for the quick response, that's a far better approach!\n"
      }
    ]
  },
  {
    "number": 4788,
    "title": "RxJava 2.x Single is not extending Publisher",
    "created_at": "2016-10-31T12:26:51Z",
    "closed_at": "2016-10-31T14:59:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4788",
    "body": "Hi, I think Single should implement also org.reactivestreams.Publisher like Flowable.\r\nRight now in io.reactivex.rxjava2 2.0.0 Single doesn't implement Publisher and this leads to being unable to do the following:\r\n\r\n```\r\nFlowable<String> colors = Flowable.fromArray(\"red\", \"green\", \"blue\",\r\n                \"red\", \"yellow\", \"green\", \"green\");\r\n\r\n        Flowable<GroupedFlowable<String, String>> groupedColorsStream = colors\r\n                                                                           .groupBy(val -> val);\r\n\r\n        Flowable<Pair<String, Long>>\r\n                countedColors = groupedColorsStream\r\n                                        .flatMap(groupedFlow -> groupedFlow\r\n                                                                    .count()\r\n                                                                    .map(countVal -> new Pair<>(groupedFlow.getKey(), countVal))\r\n                                        );\r\n        countedColors.subscribe(System.out::println);\r\n\r\n```\r\n\r\nsince count() returns Single<Long>, and flatMap has the signature:\r\n```\r\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {\r\n        return this.flatMap(mapper, false, bufferSize(), bufferSize());\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4788/comments",
    "author": "balamaci",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-31T13:22:26Z",
        "body": "It's not possible because of the receiver types are incompatible. Use `toFlowable` or `flatMapSingle` instead.\n"
      },
      {
        "user": "balamaci",
        "created_at": "2016-10-31T14:59:49Z",
        "body": "Thanks for answering\n"
      }
    ]
  },
  {
    "number": 4781,
    "title": "2.x - the code below Subscription.request(long) in onSubscribe() would't be executed until a flowable were completed",
    "created_at": "2016-10-30T03:51:19Z",
    "closed_at": "2016-10-30T13:38:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4781",
    "body": "When a flowable works on the main thread, `request(long)` in `onSubscribe(Subscription)` always calls `onNext(T)` and then `onComplete()`.\nTherefore, the code below `request(long)` in `onSubscribe(Subscription)` would be executed after `onNext(T)` and `onComplete()`.\n\n```\nFlowable.just(1, 2, 3).subscribe(new Subscriber<Integer>() {\n\n  @Override\n  public void onSubscribe(Subscription s) {\n    s.request(Long.MAX_VALUE);\n    System.out.println(\"onSubscribe done\");\n  }\n\n  @Override\n  public void onNext(Integer t) {\n    System.out.println(t);\n  }\n  ...\n}\n```\n\nThe result is always like this.\n\n```\n1\n2\n3\nonComplete called\nonSubscribe done\n```\n\nI can avoid this by calling `request(long)` at the end of `onSubscribe()`.\nHowever, this behavior is different from RxJava 1.x.\n\nAlso, there is a problem to override ResourceSubscriber's onStrat().\nSince `request(long)` acts this way, if I want to do something in `onStart()`, I have to put `super.onStart()` on the bottom of `onStart()`.\n\n```\n@Override\nprotected void onStart() {\n  initialize();\n  super.onStart();\n}\n```\n\nIf I write below, `intitalize()` would be called after `onComplete()`.\n\n```\n@Override\nprotected void onStart() {\n  super.onStart();\n  initialize();\n}\n```\n\nI think that this is a problem since developers always have to care about where they writie a request method.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4781/comments",
    "author": "otal1105",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-30T07:34:46Z",
        "body": "Yes, this is a property of how Reactive-Streams request-onNext pair work. You have to do initialization before you call `request(n)` or make sure whatever you do after is thread-safe when looked at from `onNext`.\n\nI'll update the wiki and mention this case.\n"
      },
      {
        "user": "otal1105",
        "created_at": "2016-10-30T13:38:29Z",
        "body": "Thank you! I checked the updated wiki! I really appreciate your hard working!\n"
      }
    ]
  },
  {
    "number": 4778,
    "title": "Error handling when operate observable",
    "created_at": "2016-10-28T08:44:29Z",
    "closed_at": "2016-11-12T18:19:12Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4778",
    "body": " when i do operator like Map to observable  ,then  function throws exception ,is there a way to let  the subscriber 's onError know error emit?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4778/comments",
    "author": "julist213",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2016-10-28T08:59:13Z",
        "body": "If the exception is  a checked exception then rethrow it wrapped in a RuntimeException (or your own class that extends RuntimeException). A non-checked exception will turn up as an onError emission.\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2016-10-28T09:02:12Z",
        "body": "Example:\n\n``` java\nObservable.just(1)\n  .map(x -> {\n      try { \n          return canThrow(x);\n      } catch (IOException e) { \n          throw new RuntimeException(e);}\n    });\n```\n"
      },
      {
        "user": "julist213",
        "created_at": "2016-10-28T09:20:42Z",
        "body": "@davidmoten thanks ,it's helpful!\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T18:19:12Z",
        "body": "Sidenote: you could go with 2.x and avoid these try catches almost always. \n\nIf you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4776,
    "title": "Rename operator doOnSubscribe to doBeforeSubscribe",
    "created_at": "2016-10-27T22:05:07Z",
    "closed_at": "2016-12-05T11:21:46Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4776",
    "body": "We've faced an issue using `doOnSubscribe` (yeah, yeah, side-effects, managed to refactor this though).\n\nTest that shows the problem (RxJava 1.x):\n\n``` java\n@Test\npublic void define_whenSubscribed_please() {\n    final PublishSubject<String> publishSubject = PublishSubject.create();\n    final TestSubscriber<String> subscriber = new TestSubscriber<String>();\n\n    publishSubject\n            .doOnSubscribe(new Action0() {\n                @Override\n                public void call() {\n                    publishSubject.onNext(\"value1\");\n                    // If you'll do it on separate thread with delay, subscriber will see value.\n                }\n            })\n            .subscribe(subscriber);\n\n    subscriber.assertValue(\"value1\");\n}\n```\n\nThis test fails with `AssertionError: Number of items does not match. Provided: 1  Actual: 0.`.\n\nIf action have some threading (especially with io) involved this may result in \"sometimes/mostOfTheTime works, rarely doesn't\" because there'll be a race between side-effect execution and actual subscription of the subscriber.\n\nJavadoc is not very clear about the time _when_ action will be invoked: \n\n``` java\nthe action that gets called when an observer subscribes to the source {@code Observable}\n```\n\nI suggest to deprecate this operator in 1.x and add `doBeforeSubscribe` as a replacement and do the same for 2.x without deprecation.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4776/comments",
    "author": "artem-zinnatullin",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2016-10-28T01:55:37Z",
        "body": "This is a really, really weird case.\n\nI sympathize with the fact that the side-effect happens before the upstreams func runs, but subscribe/unsubscribe/request goes up and next/complete/error goes down. Operators can be named however you want but without a proper mental model of Rx you can _always_ screw this up in a way similar to your code.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-28T07:21:49Z",
        "body": "This comes up sometimes, the workaround is to use `startWith` or `scan(initial, (a, b) -> b)` but there's an inherent race with the subject's other callers (which otherwise call onNext as well).\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2016-10-28T09:19:07Z",
        "body": "@JakeWharton well, I'm not trying to protect such code nor blame anyone for writing it, it's bad, in our case it was much more complicated example than in the test, it was legacy code that did it's job, now it's rewritten and covered with tests.\n\nI just want to improve documentation and naming of the operator to save somebody's time in future!\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-12-05T11:21:46Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ]
  },
  {
    "number": 4774,
    "title": "2.x: queue drain pattern and Long.MAX_VALUE optimisation",
    "created_at": "2016-10-27T10:35:25Z",
    "closed_at": "2016-10-28T02:02:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4774",
    "body": "@akarnokd Nice work on the RxJava 2 writing operators wiki page by the way. Looking forward to reading more as it gets fleshed out.\n\nI was curious about the queue-drain pattern that we don't look to reduce volatile reads when `Long.MAX_VALUE` is requested. Setting a mutable non-volatile boolean field `unbounded` (or whatever) to true the first time that `requested.get()` returns `Long.MAX_VALUE` and then checking that to avoid volatile reads later might yield performance gains in some scenarios.\n\nI haven't browsed the `Flowable` operators yet but `FlowableZip` for starters could be enhanced in this way and I suspect ten or so more from doing a quick grep.\n\nHappy to do PRs if you think this is of benefit.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4774/comments",
    "author": "davidmoten",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-27T10:51:40Z",
        "body": "Volatile reads are non-issue, eliminating writes are. Plus those reads are amortized by the available number of values. Your suggestion adds another possible false-sharing scenario along with an extra branch on the common path. In addition, it is the question how many times you have an unbounded consumer with very fast inputs that just pound on the loop.\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2016-10-27T11:03:55Z",
        "body": "ok, thought you had it covered.\n"
      }
    ]
  },
  {
    "number": 4772,
    "title": "doOnUnsubscribe() not called for Single ",
    "created_at": "2016-10-26T21:01:03Z",
    "closed_at": "2016-11-12T18:34:35Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4772",
    "body": "I've just noticed that `doOnUnsubscribe` not called when I use `Single` along with `observeOn(AndroidSchedulers.mainThread())`. \n\nFor example this code\n\n``` java\n Single.fromCallable(() -> 42)\n    .subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .doOnSubscribe(() -> Log.d(MainActivity.class.getName(), \"subscribed\"))\n    .doOnUnsubscribe(() -> Log.d(MainActivity.class.getName(), \"unsubscribed\"))\n    .subscribe(integer -> Log.d(MainActivity.class.getName(), \"got result\"));\n```\n\nwill provide next output: \"subscribed\", \"got result\"\n\nI also tested this code with `observeOn(Schedulers.immediate())` and I got correct output. \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4772/comments",
    "author": "AntonHolovin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-26T21:21:35Z",
        "body": "Thanks for reporting. This has been fixed already in the snapshot version and will be part of 1.2.2.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T18:34:35Z",
        "body": "Closing via 1.2.2\n"
      }
    ]
  },
  {
    "number": 4758,
    "title": "how to use the buffer(func0) ?",
    "created_at": "2016-10-24T05:57:42Z",
    "closed_at": "2016-11-12T18:35:54Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4758",
    "body": "could you help me to understand how to use the buffer(func0)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4758/comments",
    "author": "kevinmonster911",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-24T10:49:54Z",
        "body": "Its purpose is (supposed to be) to get a new `Observable` once the previous observable signalled the end of the current buffer. It is a very old port from the Rx.NET API and I haven't found any use for it yet. The other `buffer` overloads (+ `defer`) were enough.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T18:35:54Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4748,
    "title": "[2.x] sequenceEqual should return a Single, not an Observable?",
    "created_at": "2016-10-21T20:05:12Z",
    "closed_at": "2016-10-21T20:38:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4748",
    "body": "sequenceEqual should always emit a single boolean, so should its return value be a Single?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4748/comments",
    "author": "DavidMGross",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-21T20:10:41Z",
        "body": "All `sequenceEqual` calls should return `Single` in RC5. Did you find one which doesn't?\n"
      },
      {
        "user": "DavidMGross",
        "created_at": "2016-10-21T20:38:21Z",
        "body": "My bad... I was looking at 1.x by mistake.\n"
      }
    ]
  },
  {
    "number": 4741,
    "title": "Changes from 2.0.0-RC5 to 2.0.0 final",
    "created_at": "2016-10-21T08:03:04Z",
    "closed_at": "2016-10-21T08:20:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4741",
    "body": "I didn't find any details in the README/Wiki.\n\nWhat will be the changes that still go into 2.x until the final release? Is the API considered stable for now and the final release will pretty much just bump the version number, aside from internal bugfixes or should we expect more changes until the final release?\n\nSo as library developers, could one prepare a RxJava2 variant which uses RC5 and just bump the version to final 2.0.0 to release a 2.x variant of the library?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4741/comments",
    "author": "Mauin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-21T08:14:11Z",
        "body": "I'll continue with the coverage work and in case we stumble upon an API problem, we will add RC6. You could help by walking through the API looking for mistakes or inconsistencies.\n"
      },
      {
        "user": "Mauin",
        "created_at": "2016-10-21T08:20:17Z",
        "body": "👍 Thanks for the explanation, then I'll start updating some of my older 2.0.0-RC1/2 branches to see.\n"
      }
    ]
  },
  {
    "number": 4728,
    "title": "Problem in creating a new operator",
    "created_at": "2016-10-19T09:31:12Z",
    "closed_at": "2016-10-19T11:16:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4728",
    "body": "Hi, I am trying to create new operator which wraps the streaming functionality of Gson in an observable. But my in my OnNext I am receiving the same value again and again, and the subscriber.onNext of the below code is bound in a infinite loop. What am I doing wrong?\n\n```\npublic class JsonIteratorOperator implements Observable.Operator<JsonReader, JsonReader>{\n    final Func1<JsonReader, JsonReader> func1;\n\n    JsonIteratorOperator(Func1<JsonReader, JsonReader> func1) {\n        this.func1 = func1;\n    }\n\n    public Subscriber<? super JsonReader> call(final Subscriber<? super JsonReader> subscriber) {\n\n        return new Subscriber<JsonReader>() {\n            public void onCompleted() {\n                subscriber.onCompleted();\n            }\n\n            public void onError(Throwable e) {\n                subscriber.onError(e);\n            }\n\n            public void onNext(JsonReader jsonReader) {\n                try {\n                    jsonReader.beginObject();\n                    while (jsonReader.hasNext()) {\n                        subscriber.onNext(jsonReader);\n                    }\n                    jsonReader.endObject();\n                    subscriber.onCompleted();\n                } catch (Throwable e) {\n                    Exceptions.throwIfFatal(e);\n                    onError(OnErrorThrowable.addValueAsLastCause(e, jsonReader.toString()));\n                }\n            }\n        };\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4728/comments",
    "author": "masterlittle",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-19T09:47:19Z",
        "body": "What is your unit test for it? Why do you emit the jsonReader itself over and over? Maybe your consumer doesn't extract the object from jsonReader and thus there is always a value available. In addition, you should instantiate the `Subscriber` like this:\n\n``` java\nreturn new Subscriber<JsonReader>(subscriber) {  // <-- links the upstream with the downstream\n```\n"
      },
      {
        "user": "masterlittle",
        "created_at": "2016-10-19T10:36:31Z",
        "body": "This is how I am trying to implement it. A basic example. The reader is not moving forward even when I'm extracting the values or skipping them. \nI attached a debugger in the try block below. It is not being called and I think that's the reason why the jsonReader doesn't move forward. The iterate function directly calls the subscribe.OnNext().\n\n```\nrGson.readJsonObservable(inputStream)\n                .iterate(new Func1<JsonReader, JsonReader>() {\n                    public JsonReader call(JsonReader jsonReader) {\n                        try {\n                            if (jsonReader.nextName().equals(\"_id\"))\n                                System.out.println(jsonReader.nextString());\n                            else if (jsonReader.nextName().equals(\"index\"))\n                                System.out.println(jsonReader.nextInt());\n                            else\n                                jsonReader.skipValue();\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                        return jsonReader;\n                    }\n                }).subscribe();\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-19T10:46:38Z",
        "body": "This problem is not related to RxJava. Please first try to make it work without RxJava and once you gained enough experience with GSon then attempt at converting it to RxJava.\n"
      },
      {
        "user": "masterlittle",
        "created_at": "2016-10-19T11:14:29Z",
        "body": "I caught the problem. It was a missing  line of code in the iterate operator. I neglected to call func.call(jsonreader) before calling subscriber.onNext().\nThanks for your help. :)\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-19T11:16:43Z",
        "body": "I'm glad you sorted it out.\n"
      }
    ]
  },
  {
    "number": 4726,
    "title": "2.x Observable.observeOn() has an unbounded buffer",
    "created_at": "2016-10-19T09:00:12Z",
    "closed_at": "2016-10-19T15:48:31Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4726",
    "body": "`Observable.observeOn()` has an unbounded buffer and ignores the **bufferSize** parameter.\n\nWhy does `Observable.observeOn()` exist in the first place ? I think schedulers only make sense for `Flowable`.\n\nThis code crashes as expected:\n\n``` kotlin\n Flowable.create<Int>({\n        for (i in 0..100) {\n            it.onNext(i)\n        }\n    }, FlowableEmitter.BackpressureMode.NONE)\n    .observeOn(Schedulers.computation(), false, 1)\n    .subscribe {\n        Thread.sleep(100)\n    }\n```\n\nThis does not crash, I think this should crash :\n\n``` kotlin\nObservable.create<Int> {\n        for (i in 0..1000) {\n            it.onNext(i)\n        }\n    }\n    .observeOn(Schedulers.computation(), false, 1)\n    .subscribe {\n        Thread.sleep(100)\n    }\n```\n\nThe code from above is written in Kotlin.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4726/comments",
    "author": "adipascu",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-19T09:16:43Z",
        "body": "`Observable.observeOn` takes the `bufferSize` parameter to size its internal buffer's island size (`SpscLinkedArrayQueue`) to reduce allocation in case of a bursty source. Setting it to anything below 16 adds a relatively large overhead.\n\n>  I think schedulers only make sense for Flowable\n\nCrossing thread boundaries makes sense to all reactive base types so we have operators for it in every base reactive class.\n"
      },
      {
        "user": "adipascu",
        "created_at": "2016-10-19T09:32:36Z",
        "body": "This is working as intended ? The documentation from Observable.observeOn() states:\n\n> Modifies an ObservableSource to perform its emissions and notifications on a specified Scheduler  asynchronously with a **bounded buffer** of configurable size\n\nFrom testing I never managed to hit this bounded buffer limit (the observable thread did not block) and I had a slow consumer.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-19T09:36:48Z",
        "body": "That's a copy-paste error in the documentation. I'll fix it in my upcoming coverage PR.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-19T15:48:31Z",
        "body": "Closing via #4730 \n"
      }
    ]
  },
  {
    "number": 4721,
    "title": "2.x - bufferSize of Observable#flatMapIterable(mapper, bufferSize)",
    "created_at": "2016-10-18T07:32:37Z",
    "closed_at": "2016-10-19T15:49:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4721",
    "body": "[RxJava 2.0.0-RC4]\nIt seems that bufferSize became maxConcurrency.\n\nI checked the Observable.java source.\n\n```\n public final <U> Observable<U> flatMapIterable(\n    Function<? super T, ? extends Iterable<? extends U>> mapper, int bufferSize) {\n  return flatMap(ObservableInternalHelper.flatMapIntoIterable(mapper), false,\n      bufferSize);\n}\npublic final <R> Observable<R> flatMap(\n    Function<? super T, ? extends ObservableSource<? extends R>> mapper, \n    boolean delayErrors, \n    int maxConcurrency) {\n  return flatMap(mapper, delayErrors, maxConcurrency, bufferSize());\n}\n```\n\nI'm not sure whether the param's name is wrong or the source is wrong.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4721/comments",
    "author": "otal1105",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-18T07:50:25Z",
        "body": "Actually, that overload is unnecessary.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-19T15:49:49Z",
        "body": "Closing via #4723 \n"
      }
    ]
  },
  {
    "number": 4704,
    "title": "2.x: Observable.interval() - why doesn't it have backpressure (Flowable) now (after 1.x)?",
    "created_at": "2016-10-14T06:38:02Z",
    "closed_at": "2016-10-14T08:23:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4704",
    "body": "I used to use `Observable.interval()` with `Observable.zip()` and deal with `backpressure`. Now then `backpressure` is implemented via `Flowable`, `Observable.interval()` still returns `Observable`, not `Flowable`. \nHow can it be `Observable` when it is a hot source?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4704/comments",
    "author": "Nexen23",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-14T07:04:30Z",
        "body": "You mixed up a few concepts here. In 2.x the backpressure-enabled type is `Flowable`. `Observable` doesn't have any backpressure. Why would `Observable.interval()` return `Flowable`? In addition, `interval` is cold because it only starts to tick when a `Subscriber`/`Observer` subscribes to it.\n"
      },
      {
        "user": "Nexen23",
        "created_at": "2016-10-14T07:57:21Z",
        "body": "@akarnokd, oww well, haven't expected `Flowable.interval()` to exist.\nYeah, you are right, its cold. What I meant is `interval()` will not wait `Subscriber` to be done with its things and emit next value if `intervalMs` is smaller than time needed for `Subscriber.onNext()`.\nSo, in case of long doing `onNext()`, what will `Observable.interval()` do with `Observable.zip()` after that if it has no `backpressure`? Will it drop all except last value or...?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-14T07:59:14Z",
        "body": "There is no drop there but it will fill in the internal buffer of zip(). If zip is delayed too much, you'll get an `OutOfMemoryError`.\n"
      },
      {
        "user": "Nexen23",
        "created_at": "2016-10-14T08:14:31Z",
        "body": "@akarnokd, have I understood it right that  `2.x Observable.zip(source)` now works like `1.x Observable.zip(source.onBackpressureBuffer())`, maintaining all unobserved data in itself?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-14T08:18:54Z",
        "body": "2.x `Observable.zip` uses an unbounded buffer instead of a bounded one. There is no additional buffer like with 1.x zip+onBackpressureBuffer.\n"
      },
      {
        "user": "Nexen23",
        "created_at": "2016-10-14T08:23:12Z",
        "body": "I got it. Thanks for so fast reply :+1: \n"
      }
    ]
  },
  {
    "number": 4703,
    "title": "Subject should throw exception when calling onNext after onComplete",
    "created_at": "2016-10-13T22:11:05Z",
    "closed_at": "2016-10-14T17:11:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4703",
    "body": "```\nPublishSubject publishSubject = PublishSubject.create();\npublishSubject.onCompleted();\npublishSubject.onNext(new Object());\n```\n\nIn 1.x you can call onNext after onCompleted and no exception will be thrown. \nI think it should throw an exception, but maybe it isn't possible to reliably assert that the observable hasn't completed before calling onNext when dealing with different threads. \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4703/comments",
    "author": "runningcode",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-14T07:01:52Z",
        "body": "This change would break the expectation that these methods don't throw. Why do you call onNext after onComplete?\n"
      },
      {
        "user": "runningcode",
        "created_at": "2016-10-14T07:26:56Z",
        "body": "Maybe `onCompleted` and `onNext` are called from different threads. I guess that's the problem with subjects anyways. :\\\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-14T07:29:55Z",
        "body": "Then you should use `toSerialized` and work with that `Subject` as regular `Subject`s are not thread safe. If you work with `SerializedSubject` then there is no reason to penalize that thread that didn't and can't know some other thread brought the `Subject` to a terminal state.\n"
      },
      {
        "user": "runningcode",
        "created_at": "2016-10-14T17:11:44Z",
        "body": "Ah ok. Perhaps I misunderstood that RxJava enforces the contract. It only guarantees that Observers receive events that follow the contract by wrapping Observers inside a SafeSubscriber.\n"
      }
    ]
  },
  {
    "number": 4700,
    "title": "Observable.using async resource factory?",
    "created_at": "2016-10-13T08:17:29Z",
    "closed_at": "2016-10-13T15:43:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4700",
    "body": "Hello,\n\ni have a use case where i will use a resource that need to be released after usage, so i thought the `Observable.using` fit in these case, but i obtain the resource from a `Observable` that could do a network call if it's not available local.\n\nThe resource is a session identifier with expiration time, so when it's not expired i have it local and it's fast, otherwise i do a network call, but the problem is, the `Observable.using` resourceFactory (first param), is a `Func0`, and i don't want to block inside it with `toBlocking.single`, how could i use it? Is there any alternative?\n\nHere is an example code, i wan't to remove the blocking part\n\n``` java\nreturn Observable.using(\n      // create resource\n      () -> getSession().toBlocking().single(), // i don't want to do that!\n      // use it\n      session -> doWork(session), // returns a observable\n      // release\n      session -> // release session,\n      true)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4700/comments",
    "author": "kennedyoliveira",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-13T08:25:04Z",
        "body": "FlatMap over it and have it as a constant in using.\n\n``` java\ngetSession()\n.flatMap(session -> Observable.using(() -> session, s-> doWork(s), s -> { }));\n```\n"
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2016-10-13T15:43:05Z",
        "body": "@akarnokd I just thought about this solution when I woke up, maybe I just needed some sleep haha, anyway thank you! \n"
      }
    ]
  },
  {
    "number": 4691,
    "title": "Merging two observables that subcribeOn different threads does not call doOnCompleted() for merged observable",
    "created_at": "2016-10-11T16:53:44Z",
    "closed_at": "2016-11-12T09:02:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4691",
    "body": "Merging two observables that subcribeOn different threads does not call doOnCompleted() for merged observable.\n\nI have copied a simple example below which demonstrates the issue:\n# Example\n\n``` java\nObservable<Integer> o1 = Observable.just(1, 2, 3);\n        Observable<Integer> o2 = Observable.merge(\n            o1,\n            Observable.empty()\n        )\n            .subscribeOn(Schedulers.newThread())\n            .doOnCompleted(() -> mLogger.error(\"a\"));\n        Observable<Integer> o3 = Observable.just(4, 5, 6);\n        Observable<Integer> o4 = Observable.merge(\n            o3,\n            Observable.empty()\n        )\n            .subscribeOn(Schedulers.newThread())\n            .doOnCompleted(() -> mLogger.error(\"b\"));\n        Observable.merge(\n            o2,\n            o4\n        )\n            .doOnCompleted(() -> mLogger.error(\"c\"))\n            .subscribe();\n```\n## Actual\n\n```\nERROR [2016-10-11 01:47:59,642] com.harbinger.application.App: a\nERROR [2016-10-11 01:47:59,644] com.harbinger.application.App: b\n```\n## Expected\n\nI expected that \"c\" would log as well.\n# Workaround\n\nBelow I fix the problem by putting moving `subscribeOn()` to final merged observable.\n\n``` java\nObservable<Integer> o1 = Observable.just(1, 2, 3);\nObservable<Integer> o2 = Observable.merge(\n    o1,\n    Observable.empty()\n)\n    .doOnCompleted(() -> mLogger.error(\"a\"));\nObservable<Integer> o3 = Observable.just(4, 5, 6);\nObservable<Integer> o4 = Observable.merge(\n    o3,\n    Observable.empty()\n)\n    .doOnCompleted(() -> mLogger.error(\"b\"));\nObservable.merge(\n    o2,\n    o4\n)\n    .subscribeOn(Schedulers.newThread())\n    .doOnCompleted(() -> mLogger.error(\"c\"))\n    .subscribe();\n```\n\n```\nERROR [2016-10-11 01:51:33,838] com.harbinger.application.App: a\nERROR [2016-10-11 01:51:33,839] com.harbinger.application.App: b\nERROR [2016-10-11 01:51:33,839] com.harbinger.application.App: c\n```\n# System Info\n## RxJava\n\n```\n<dependency>\n    <groupId>io.reactivex</groupId>\n    <artifactId>rxjava</artifactId>\n    <version>1.0.13</version>\n</dependency>\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4691/comments",
    "author": "phoganuci",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-11T18:04:47Z",
        "body": "Works for me if I add `toBlocking` before the last `subscribe()`. Otherwise a standalone program quits before it can print the last log entry.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T09:02:21Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4673,
    "title": "Subscriber receives value after the unsubscription",
    "created_at": "2016-10-06T07:56:21Z",
    "closed_at": "2016-11-09T11:51:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4673",
    "body": "I have the following issue\n\n```\n@Test public void testUnsubscribe() throws InterruptedException {\n    PublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n    Subscription subscription = mBooleanPublishSubject\n            .doOnNext(value -> System.out.println(\"Sending value \" + value))\n            .onBackpressureBuffer()\n            .observeOn(Schedulers.computation())\n            .map(v -> {\n                long sum = 0;\n                for (int i = 0; i < 10000000; i++) {\n                    sum += i;\n                }\n                return sum > 0;\n            })\n            .doOnNext(__ -> System.out.println(\"Before subscribe\"))\n            .subscribe(value -> System.out.println(\"Value received \" + value));\n\n    mBooleanPublishSubject.onNext(true);\n    mBooleanPublishSubject.onNext(true);\n    Thread.sleep(10);\n    System.out.println(\"Unsubscribing\");\n    subscription.unsubscribe();\n    System.out.println(\"Unsubscribed\");\n    Thread.sleep(1000);\n}\n```\n\nOutput\n\n```\nSending value true\nSending value true\nUnsubscribing\nUnsubscribed\nBefore subscribe\nValue received true\n```\n\nIs that expected behaviour?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4673/comments",
    "author": "httpdispatch",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-06T08:09:25Z",
        "body": "Unsubscription is best effort and unless called in sequence, values may slip through.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-10-06T08:10:46Z",
        "body": "Are there any recomendations to reduce such slip probability?\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-10-06T08:11:43Z",
        "body": "If i have flatMap after the map or use concatMap instead of map everything works as expected\n\n```\n@Test public void testUnsubscribe() throws InterruptedException {\n        PublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n        Subscription subscription = mBooleanPublishSubject\n                .doOnNext(value -> System.out.println(\"Sending value \" + value))\n                .onBackpressureBuffer()\n                .observeOn(Schedulers.computation())\n                .concatMap(v -> Observable.fromCallable(() -> {\n                    System.out.println(\"concatMap\");\n                    long sum = 0;\n                    for (int i = 0; i < 100000000; i++) {\n                        sum += i;\n                    }\n                    return sum > 0;\n                }))\n                .doOnNext(__ -> System.out.println(\"Before subscribe\"))\n                .subscribe(value -> System.out.println(\"Value received \" + value));\n\n        mBooleanPublishSubject.onNext(true);\n        mBooleanPublishSubject.onNext(true);\n        Thread.sleep(30);\n        System.out.println(\"Unsubscribing\");\n        subscription.unsubscribe();\n        System.out.println(\"Unsubscribed\");\n        Thread.sleep(1000);\n    }\n```\n\nOutput\n\n```\nSending value true\nSending value true\nconcatMap\nUnsubscribing\nUnsubscribed\n```\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-10-06T08:18:11Z",
        "body": "How i understood from the described behaviour map, doOnNext should not perform long running operations because of such value slip probability\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-06T08:42:02Z",
        "body": "Have your end Subscriber check isUnsubscribed eagerly.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-10-06T08:44:00Z",
        "body": "@akarnokd should it be something like this?\n\n```\n@Test public void testUnsubscribe() throws InterruptedException {\n        PublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n        MutableObject<Subscription> subscription = new MutableObject<>();\n        subscription.set(mBooleanPublishSubject\n                .doOnNext(value -> System.out.println(\"Sending value \" + value))\n                .onBackpressureBuffer()\n                .observeOn(Schedulers.computation())\n                .map(v -> {\n                    System.out.println(\"map: started\");\n                    long sum = 0;\n                    for (int i = 0; i < 10000000; i++) {\n                        sum += i;\n                    }\n                    System.out.println(\"map: ended\");\n                    return sum > 0;\n                })\n                .filter(__ -> !subscription.get().isUnsubscribed())\n                .doOnNext(__ -> System.out.println(\"Before subscribe\"))\n                .filter(__ -> !subscription.get().isUnsubscribed())\n                .subscribe(value -> System.out.println(\"Value received \" + value)));\n\n        mBooleanPublishSubject.onNext(true);\n        mBooleanPublishSubject.onNext(true);\n        Thread.sleep(10);\n        System.out.println(\"Unsubscribing\");\n        subscription.get().unsubscribe();\n        System.out.println(\"Unsubscribed\");\n        Thread.sleep(1000);\n    }\n```\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-10-06T08:45:24Z",
        "body": "Or there is a more beautiful way?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-06T08:45:46Z",
        "body": "I mean subclass Subscriber instead of using lambdas.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-10-06T08:47:50Z",
        "body": "That is OK for subscriber but not enough for other places of the chain: map, doOnNext. Is there a way to check whether the chain is unsubscribed without using external variable? For sure i may write dummy calls\nflatMap(v -> Observable.just(v)) instead of checking !subscription.get().isUnsubscribed(), but that doesn't look beautiful either\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-06T09:17:27Z",
        "body": "Other than writing a custom operator there is no  more elegant way subjectively.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-10-06T09:29:05Z",
        "body": "@akarnokd Thank you very much for your explanation and time. \n\nNot sure whether the issue should be closed such as other users may discover same problem.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-10-06T09:42:19Z",
        "body": "Using your suggestion i've implemented Operator\n\nPerhaps that may help somebody else\n\n```\n@Test public void testUnsubscribe() throws InterruptedException {\n    PublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n    MutableObject<Subscription> subscription = new MutableObject<>();\n    subscription.set(mBooleanPublishSubject\n            .doOnNext(value -> System.out.println(\"Sending value \" + value))\n            .onBackpressureBuffer()\n            .observeOn(Schedulers.computation())\n            .map(v -> {\n                System.out.println(\"map: started\");\n                long sum = 0;\n                for (int i = 0; i < 10000000; i++) {\n                    sum += i;\n                }\n                System.out.println(\"map: ended\");\n                return sum > 0;\n            })\n            .lift(new BreakIfUnsubscribed())\n            .doOnNext(__ -> System.out.println(\"Before subscribe\"))\n            .lift(new BreakIfUnsubscribed())\n            .subscribe(value -> System.out.println(\"Value received \" + value)));\n\n    mBooleanPublishSubject.onNext(true);\n    mBooleanPublishSubject.onNext(true);\n    Thread.sleep(30);\n    System.out.println(\"Unsubscribing\");\n    subscription.get().unsubscribe();\n    System.out.println(\"Unsubscribed\");\n    Thread.sleep(1000);\n}\n\npublic class BreakIfUnsubscribed<T> implements Observable.Operator<T, T> {\n    public BreakIfUnsubscribed() {\n    }\n\n    @Override public Subscriber<? super T> call(Subscriber<? super T> subscriber) {\n        return new Subscriber<T>(subscriber) {\n            @Override\n            public void onCompleted() {\n                if (!subscriber.isUnsubscribed()) {\n                    subscriber.onCompleted();\n                }\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                if (!subscriber.isUnsubscribed()) {\n                    subscriber.onError(t);\n                }\n            }\n\n            @Override\n            public void onNext(T item) {\n                if (!subscriber.isUnsubscribed()) {\n                    subscriber.onNext(item);\n                }\n            }\n        };\n    }\n}\n```\n\nOutput\n\n```\nSending value true\nSending value true\nmap: started\nmap: ended\nBefore subscribe\nValue received true\nmap: started\nUnsubscribing\nUnsubscribed\nmap: ended\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-09T11:51:25Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4670,
    "title": "Regarding delayed emissions",
    "created_at": "2016-10-05T11:53:45Z",
    "closed_at": "2016-10-25T13:41:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4670",
    "body": "In my code bbaPi.getProductsNextPage makes an http call and returns an observable. I generate a range of page numbers and pass this to the api call. I want to make this call after every n seconds but currently, when I use the zip operator, the call is sent for all the page numbers and then the emission of the call is delayed by 2 minutes. How can I delay this call by n seconds?\n\n```\n@Override\n    public Observable<List<Product>> getBbProducts(String category, String city) {\n        return bbApi.getProductsList(category, readCookie(objectMapper))\n                .map(response -> BbMapper.mapResponse(ProductPage.class, objectMapper, response))\n                .onBackpressureBuffer()\n                .filter(productPage -> productPage != null)\n                .flatMap(productPage -> {\n                    int totalPages = productPage.getResponse().getTab_info().get(0).getProduct_info().getTot_pages();\n                    int totalProducts = productPage.getResponse().getTab_info().get(0).getProduct_info().getP_count();\n\n                    return Observable.range(1, totalPages)\n                            .onBackpressureBuffer()\n                            .flatMap(new Func1<Integer, Observable<List<Product>>>() {\n                                         @Override\n                                         public Observable<List<Product>> call(Integer integer) {\n                                             long startTime = System.currentTimeMillis();\n                                             return Observable.zip(\n                                                     Observable.interval(1, TimeUnit.SECONDS)\n                                                             .onBackpressureDrop(),\n// This. I want to delay it by n seconds.\n                                                     bbApi.getProductsNextPage(category, readCookie(objectMapper), integer)\n                                                             .onBackpressureBuffer()\n                                                             .flatMap(new Func1<Response, Observable<List<Product>>>() {\n                                                                 @Override\n                                                                 public Observable<List<Product>> call(Response response) {\n                                                                     long endTime = System.currentTimeMillis();\n                                                                     System.out.println(\"Time taken: \" + (endTime - startTime) + \"Page: \" + integer);\n                                                                     return Observable\n                                                                             .from(BbMapper.mapToProductList(objectMapper, response))\n                                                                             .map(all -> BbMapper.mapToProduct(all, city))\n                                                                             .toList()\n                                                                             .subscribeOn(Schedulers.computation());\n                                                                 }\n                                                             })\n                                                             .onBackpressureBuffer()\n                                                     ,\n                                                     (aLong, products) -> products);\n                                         }\n                                     }\n                            )\n                            .onBackpressureDrop()\n                            .flatMap(new Func1<List<Product>, Observable<List<Product>>>() {\n                                @Override\n                                public Observable<List<Product>> call(List<Product> products) {\n                                    return Observable.just(products);\n                                }\n                            });\n                });\n    }\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4670/comments",
    "author": "masterlittle",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-05T12:07:55Z",
        "body": "I don't fully understand what you try to achieve. If you want to retrieve the next page after 2 seconds, you can just flatMap an `interval`:\n\n``` java\nObservable.interval(2, TimeUnit.SECONDS)\n.take(maxPages)\n.onBackpressureDrop()\n.concatMap(v -> service.getPage((int)v + 1))\n...\n\n// or \n\nObservable.range(1, maxPages)\n.concatMap(v -> service.getPage(v).delaySubscription(2, TimeUnit.SECONDS))\n...\n```\n"
      },
      {
        "user": "masterlittle",
        "created_at": "2016-10-05T20:11:00Z",
        "body": "I implemented the first suggestion and it works! thanks\nI have one more query. I am iterating over a list using from() and in each emission I am making http calls using the data from the emission. Currently the http calls of different emissions are interleaved. I want to do do something so that until the result of all http calls for the first emission is not returned it should be blocked and after that, second emission should be emitted. Can it be done?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-05T20:26:22Z",
        "body": "See `concatMapEager` which runs async sources at once but relays values from the first one only until it completes, then relays values from the second one, etc.\n"
      },
      {
        "user": "masterlittle",
        "created_at": "2016-10-05T20:37:27Z",
        "body": "Thanks. I had made a hacky solution in which I ran a loop manually and called a new Subscriber every time in onComplete() and then using a subject. Very ugly code. This may just work. Thanks again.\n"
      },
      {
        "user": "masterlittle",
        "created_at": "2016-10-06T05:39:45Z",
        "body": "Thanks @akarnokd . Worked like a dream after I tweaked the maxConcurrent. Another query(sorry), I want to limit the rate of emission. Currently every 2 seconds I receive an emission of 20 items. I want to throttle this to 10 items. I thought of using debounce() with buffer() but I am not sure I will not be losing emissions in the process. I mean if I use a debounce of 2 and a buffer of 10, I will receive a list of 10 items but what will happen to the remaining 10 items? Is there ny other way to do it?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-06T08:50:09Z",
        "body": "Buffer it with 10 size and zip it with a interval.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-25T13:41:10Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4665,
    "title": "which operator can do that?",
    "created_at": "2016-10-04T00:39:32Z",
    "closed_at": "2016-10-25T13:23:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4665",
    "body": "i have two Observable,one is use check have sign,another is use do sign. if check not sign,i will do another Observable.if check already sign,i will show a toast,and another Observable not use.\nplease help me \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4665/comments",
    "author": "lyq027",
    "comments": [
      {
        "user": "abersnaze",
        "created_at": "2016-10-04T01:12:48Z",
        "body": "Does this like it would work for you.\n\n```\nObservable<CheckSign> check = ...\nObservable<Sign> sign = ...;\n\ncheck.flatMap((c) -> {\n    if(c.isSigned()) {\n        return Observable.just(c.signedData);\n    } else {\n        return sign;\n    }\n});\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-25T13:23:01Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4664,
    "title": "2x RxJavaPlugins - 1.x RxJavaHooks using TestScheduler::advanceTimeBy",
    "created_at": "2016-10-03T23:53:21Z",
    "closed_at": "2016-10-04T07:05:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4664",
    "body": "I have a question regarding the usage of `TestScheduler` and hooks.\n\nThe next text passes using 1.x version:\n\n``` java\n  @Test public void Verify_Test_Scheduler_Rx1() {\n    rx.schedulers.TestScheduler scheduler = new rx.schedulers.TestScheduler();\n    RxJavaHooks.setOnComputationScheduler(current -> scheduler);\n\n    AtomicInteger flag = new AtomicInteger();\n\n    rx.Observable.just(1)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .delay(3, TimeUnit.SECONDS)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .subscribe();\n\n    scheduler.advanceTimeBy(4, TimeUnit.SECONDS);\n\n    assertThat(flag.get(), is(2));\n\n    RxJavaHooks.reset();\n  } \n```\n\n But this one fails, being the flag value 1, instead of 2:\n\n``` java\n@Test public void Verify_Test_Scheduler_Rx2() {\n    TestScheduler scheduler = new TestScheduler();\n    RxJavaPlugins.onComputationScheduler(scheduler);\n\n    AtomicInteger flag = new AtomicInteger();\n\n    Observable.just(1)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .delay(3, TimeUnit.SECONDS)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .subscribe();\n\n    scheduler.advanceTimeBy(4, TimeUnit.SECONDS);\n\n    assertThat(flag.get(), is(2));\n\n    RxJavaPlugins.reset();\n  }\n```\n\n  What is the correct usage of `TestScheduler` with `RxJavaPlugins` in 2.x to achieve the same effect that the one recreated in 1.x? \n\n  Thanks. \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4664/comments",
    "author": "VictorAlbertos",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-04T07:00:59Z",
        "body": "``` java\nRxJavaPlugins.setComputationSchedulerHandler(current -> scheduler);\n```\n"
      },
      {
        "user": "VictorAlbertos",
        "created_at": "2016-10-04T07:05:38Z",
        "body": "Right. Thanks @akarnokd \n"
      }
    ]
  },
  {
    "number": 4657,
    "title": "Subscriber unsubscribe doubt",
    "created_at": "2016-10-02T03:19:13Z",
    "closed_at": "2016-10-03T07:34:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4657",
    "body": "Hello!\n\nI'm with a doubt about the unsubscribe process and memory related stuff, today i faced a simple case that made me wonder, the case is, i have a web Event Stream that i'll send some information when receive a request, but this information is sent with an interval, suppose each 500 milliseconds, and when the request ends, i want to clear all the resources allocated so i don't get a memory leak, the simplified code looks like this:\n\n``` java\nfinal Subscription metricsSubscription = Observable.interval(delay, TimeUnit.MILLISECONDS, scheduler)\n                                                   .map(i -> new DashboardData(HystrixCommandMetrics.getInstances(),\n                                                                               HystrixThreadPoolMetrics.getInstances(),\n                                                                               HystrixCollapserMetrics.getInstances()))\n                                                   .concatMap(dashboardData -> Observable.from(SerialHystrixDashboardData.toMultipleJsonStrings(dashboardData)))\n                                                   .subscribe(metric -> writeMetric(metric, response),\n                                                              ex -> log.error(\"Error sending metrics\", ex));\n```\n\nPretty simple, when the request ends, the client disconnect, i call:\n\n``` java\nmetricsSubscription.unsubscribe();\n```\n\nWhat happens to the interval observable? It'll stop emitting events, but it'll be garbage collected? \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4657/comments",
    "author": "kennedyoliveira",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-02T07:44:20Z",
        "body": "The internal sequences should become collectable but it is possible that holding the `Subscription` reference itself may keep alive components. Use `onTerminateDetach` to make sure that doesn't happen.\n"
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2016-10-02T08:34:26Z",
        "body": "@akarnokd thank you for your response, so basically the code is correct, the problem would be the `Subscription` reference as you state, so basically, if there are no problems with references, unsubscribing would clean everything that needs to be clean so the observable can stop and be collected?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-02T08:35:21Z",
        "body": "Yes.\n"
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2016-10-02T22:25:02Z",
        "body": "@akarnokd thanks for clarifying things out, i didn't know about this onTerminateDetach, it was implemented recently or i missed it?\n\nAnother thing, there is any performance impact using it? \n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-03T07:14:40Z",
        "body": "A couple of patch versions before.\n\n> Another thing, there is any performance impact using it?\n\nIt has minimal overhead, just like an extra `map` or `filter`.\n"
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2016-10-03T07:34:07Z",
        "body": "@akarnokd thank you very much for the information, very helpful!\n"
      }
    ]
  },
  {
    "number": 4638,
    "title": "RxJava combine.zip issue ",
    "created_at": "2016-09-29T15:13:40Z",
    "closed_at": "2016-10-25T13:30:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4638",
    "body": "Hi,\n\nI'm having an issue with RxJava and Android - tested with ZIP, COMBINE or COMBINE LATEST function. \nI'm using these methods to combine multiple API calls and the result should be several arrays with some data (server always returns the same set of data).\nThe problem I have is that sometimes some arrays are empty (in onNext/onCompleted methods) even if the server returns data, or the data between arrays are mixed up.\nIt happens approximately every 10th-20th call. \nThe code snippet is:\n\n``` java\nprivate void getFullClientDetails() {\n\n        repo = ServiceGenerator.createServiceRx(ApplicationController.getInstance(), mApplicationSettings, this);\n        ProgressDialogUtil.showProgressDialog(ClientBaseActivity.this);\n        ScreenOrientationLock.lockScreenOrientation(this);\n        Observable<ArrayList<Assessment>> assessmentObservable = getAssessmentObservable(repo);\n        Observable<ArrayList<Report>> reportObservable = getReportObservable(repo);\n        Observable<ArrayList<CarePlan>> carePlanObservable = getCarePlanObservable(repo);\n        Observable<ArrayList<Evaluation>> evaluationObservable = getEvaluationObservable(repo);\n        Observable<ArrayList<GuidanceAppointment>> appointmentObservable = getAppointmentObservable(repo);\n\n        final Observable<MedicalInfoObservable> combined = Observable.zip(assessmentObservable, reportObservable, carePlanObservable, evaluationObservable, appointmentObservable,\n                new Func5<ArrayList<Assessment>,\n                        ArrayList<Report>, ArrayList<CarePlan>, ArrayList<Evaluation>, ArrayList<GuidanceAppointment>, MedicalInfoObservable>() {\n                    @Override\n                    public MedicalInfoObservable call(ArrayList<Assessment> assessments,\n                                                      ArrayList<Report> reports, ArrayList<CarePlan> carePlan, ArrayList<Evaluation> evaluations, ArrayList<GuidanceAppointment> appointments) {\n                        return new MedicalInfoObservable(assessments, reports, carePlan, evaluations, appointments);\n                    }\n                });\n\n\n        subscription = combined.subscribe(new Subscriber<MedicalInfoObservable>() {\n            @Override\n            public void onCompleted() {\n                openDetailsTabActivity();\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                showErrorMessage(e);\n            }\n\n            @Override\n            public void onNext(MedicalInfoObservable medicalInfoObservable) {\n\n                    mAssessmentResponse = (ArrayList<Assessment>) medicalInfoObservable.assessmentList;\n                    mReportsResponse = (ArrayList<Report>) medicalInfoObservable.reportList;\n                    mCarePlanList = (ArrayList<CarePlan>) medicalInfoObservable.carePlanList;\n                    mEvaluationsList = (ArrayList<Evaluation>) medicalInfoObservable.evaluationList;\n                    mAppointmentList = (ArrayList<GuidanceAppointment>) medicalInfoObservable.appointmentList;\n                    Log.e(\"ClientObservable\", \"Appointment List: \" + medicalInfoObservable.appointmentList.size() +\n                            \", Assessment List: \" + medicalInfoObservable.assessmentList.size() + \",Care Plan: \" + medicalInfoObservable.carePlanList.size() +\n                            \", Evaluation List: \" + medicalInfoObservable.evaluationList.size() + \",Report\" + medicalInfoObservable.reportList.size()); \n                            }\n\n\n        });\n    }\n\n\n\n    private Observable<ArrayList<Assessment>> getAssessmentObservable(Retrofit repo) {\n        return repo\n                .create(AssessmentApi.class)\n                .getAssessmentListRx(mCurrentlySelectedClient.getId(), true)\n                .subscribeOn(Schedulers.newThread())\n                .observeOn(AndroidSchedulers.mainThread());\n    }\n\n    private Observable<ArrayList<Report>> getReportObservable(Retrofit repo) {\n        return repo\n                .create(ReportApi.class)\n                .getReportRxWithClient(mCurrentlySelectedClient.getId(), true)\n                .subscribeOn(Schedulers.newThread())\n                .observeOn(AndroidSchedulers.mainThread());\n    }\n\n    private Observable<ArrayList<CarePlan>> getCarePlanObservable(Retrofit repo) {\n        return repo\n                .create(CarePlanApi.class)\n                .getCarePlanListRx(mCurrentlySelectedClient.getId(), true)\n                .subscribeOn(Schedulers.newThread())\n                .observeOn(AndroidSchedulers.mainThread());\n    }\n\n    private Observable<ArrayList<Evaluation>> getEvaluationObservable(Retrofit repo) {\n        return repo\n                .create(EvaluationApi.class)\n                .getEvaluationListRx(mCurrentlySelectedClient.getId(), true)\n                .subscribeOn(Schedulers.newThread())\n                .observeOn(AndroidSchedulers.mainThread());\n    }\n\n    private Observable<ArrayList<GuidanceAppointment>> getAppointmentObservable(Retrofit repo) {\n        return repo\n                .create(GuidanceAppointmentApi.class)\n                .getGuidanceAppointmentListRx(mCurrentlySelectedClient.getId(), true)\n                .subscribeOn(Schedulers.newThread())\n                .observeOn(AndroidSchedulers.mainThread());\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        if(subscription != null)\n            subscription.unsubscribe();\n    }\n\n```\n\nResponse from the server is always the same (**7,4,30** items in list), but in onNext/onCompleted method I have different results. The example is:\n\nAppointment List: 7, Assessment List: 4,Care Plan: 30, Evaluation List: 0,Report 0\nAppointment List: 7, Assessment List: 4,Care Plan: 30, Evaluation List: 0,Report 0\nAppointment List: 7, Assessment List: 4,Care Plan: 30, Evaluation List: 0,Report 0\nAppointment List: 0, Assessment List: 4,Care Plan: 30, Evaluation List: 0,Report 0\nAppointment List: 7, Assessment List: 4,Care Plan: 0, Evaluation List: 0,Report 0\n\nOne more example:\nAppointment List: 7, Assessment List: 4,Care Plan: 30, Evaluation List: 0,Report 0\nAppointment List: 7, Assessment List: 4,Care Plan: 30, Evaluation List: 0,Report 0\nAppointment List: 7, Assessment List: 4,Care Plan: 30, Evaluation List: 0,Report 0\nAppointment List: 30, Assessment List: 4,Care Plan: 30, Evaluation List: 0,Report 0\nAppointment List: 7, Assessment List: 4,Care Plan: 30, Evaluation List: 0,Report 0\nAppointment List: 7, Assessment List: 4,Care Plan: 30, Evaluation List: 0,Report 0\nAppointment List: 7, Assessment List: 4,Care Plan: 30, Evaluation List: 7,Report 4\n\nOne more:\nAssessment ONE: 4 ,Care Plan ONE: 30 , Report: 0 Evaluation: 0\nAssessment ONE: 4 ,Care Plan ONE: 0 , Report: 0 Evaluation: 0\nAssessment ONE: 4 ,Care Plan ONE: 30 , Report: 0 Evaluation: 0\nAssessment ONE: 4 ,Care Plan ONE: 30 , Report: 0 Evaluation: 30\n\nIt seems that everything works fine with two API calls and two lists of objects, but with more than two issue appear.\n\nBuild gradle dependencies: \n    compile 'com.squareup.retrofit2:retrofit:2.1.0'\n    compile 'com.squareup.retrofit2:converter-gson:2.1.0'\n    compile 'io.reactivex:rxandroid:1.2.1'\n    compile 'io.reactivex:rxjava:1.2.0'\n    compile 'com.squareup.retrofit2:adapter-rxjava:2.1.0'\n    compile 'com.squareup.okhttp3:logging-interceptor:3.4.1'\n\nIf you need more information just let me now.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4638/comments",
    "author": "dastko",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-29T15:25:09Z",
        "body": "If you call the services individually, do they return the correct amount? Is it possible the server mixes up results due to some concurrency bug that manifests with 3+ concurrent calls? You could test this by creating a single-threaded `ExecutorService`, wrap it into scheduler via `Schedulers.from()` and using that single Scheduler everywhere that uses `Schedulers.newThread()` currently?\n"
      },
      {
        "user": "dastko",
        "created_at": "2016-09-29T15:43:12Z",
        "body": "Hi,\n\nThank you for the quick response.\n\nNo, the server always returns the same values, this is already tested (deeply).\n\nAs you can see in the example above:\n\nAssessment ONE: 4 ,Care Plan ONE: 30 , Report: 0 Evaluation: 0\nAssessment ONE: 4 ,Care Plan ONE: 0 , Report: 0 Evaluation: 0\nAssessment ONE: 4 ,Care Plan ONE: 30 , Report: 0 Evaluation: 0\nAssessment ONE: 4 ,Care Plan ONE: 30 , Report: 0 Evaluation: 30\n\nSometimes, I got the list of Evaluation (or Report, there is no a clear pattern) objects with properties that belong to Care Plan object (the common property for this two objects is id) and customers can see the list of objects that doesn't exist in the database.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-29T16:22:26Z",
        "body": "I'd append doOnNext() to each API call and print out what they see. There could be also the possibility that Retrofit mixes up the data between requests because of reusing the same connection and not properly demuxing. I don't think this is an issue with RxJava.\n"
      },
      {
        "user": "dastko",
        "created_at": "2016-09-29T17:56:11Z",
        "body": "Thank you.\n\nI'm really not sure why is this happening, but I will investigate it further more. \n"
      },
      {
        "user": "dastko",
        "created_at": "2016-09-30T14:43:24Z",
        "body": "Hi @akarnokd ,\n\nI've tried with your suggestion:\n\nExecutorService sc = Executors.newFixedThreadPool(1);\nscheduler = Schedulers.from(sc);\n\nEverything works just fine, but with one thread in the pool. When I tried with 4 or more threads in the pool - issue appears.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-30T15:32:14Z",
        "body": "Now you could try instantiating 4 APIs with Retrofit so they are distinct objects and see if they still don't work at the same time.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-25T13:30:52Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      },
      {
        "user": "WDevaloper",
        "created_at": "2020-11-05T08:17:41Z",
        "body": "me too.How to deal with it ?"
      }
    ]
  },
  {
    "number": 4624,
    "title": "doOnDispose not called",
    "created_at": "2016-09-28T11:19:09Z",
    "closed_at": "2016-10-25T13:31:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4624",
    "body": "Hi all,\n\nthe new doOnDispose method in 2.0.0-RC3 is not called. For example this test:\n\n```\n    @Test\n    public void doOnDisposeShouldBeCalled() {\n        Observable.fromCallable(() -> {\n            System.out.println(\"start\");\n            return \"start\";\n        })\n        .doOnError(e -> {\n            System.out.println(\"doOnError\");\n        })\n        .doOnComplete(() -> {\n            System.out.println(\"doOnComplete\");\n        })\n        .doOnDispose(() -> {\n            System.out.println(\"doOnDispose\");\n        })\n        .subscribe(new TestObserver<>());\n    }\n```\n\nprints:\n\n```\nstart\ndoOnComplete\n```\n\nThe same test executed in 1.2.0 (using doOnUnsubscribe() instead of doOnDispose()) correctly executes the doOnUnsubscribe() method and prints:\n\n```\nstart\ndoOnComplete\ndoOnUnsubscribe\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4624/comments",
    "author": "ufoscout",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-28T11:21:43Z",
        "body": "`doOnDispose` gets only called when there is actually something disposing. If things just complete then it is not called. Consider using `using` that will dispose the resource in both terminal and downstream dispose cases.\n"
      },
      {
        "user": "ufoscout",
        "created_at": "2016-09-28T11:57:20Z",
        "body": "@akarnokd I understand it, but the documentation should be fixed because it says that doOnUnsubscribe() has been renamed doOnDispose() but in fact these two methods behave differently, so it not a simple rename and can cause issues when upgrading from 1.x to 2.x.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-28T12:00:48Z",
        "body": "I've updated the wiki with a section about `doOnDispose`.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-25T13:31:46Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      },
      {
        "user": "dmitry-weirdo",
        "created_at": "2018-10-10T14:04:39Z",
        "body": "Not sure whether I'm writing to the correct place, but `doOnDispose` is not executed when subscriber called `dispose` on `ConnectableObservable`.  When, `doOnDispose` is called on `Observable`, from which `ConnectableObservable` is created (by `publish`), `doOnDispose` is executed after calling `dispose` from each subscriber.\r\n\r\n`doFinally` works the same way.\r\n\r\nIs this the correct/expected behaviour?\r\n\r\n**UPDATE:** Calling `dispose` on `Disposable` gotten from `ConnectableObservable#connect` method actually executes both `doOnDispose` and `doFinally`. So the behaviour seems to be correct, although not super-obvious."
      }
    ]
  },
  {
    "number": 4613,
    "title": "2.x Wrong Signature of zipWith methods",
    "created_at": "2016-09-27T09:43:06Z",
    "closed_at": "2016-10-25T13:10:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4613",
    "body": "Looks like there is an error in `zipWith` methods signature in RC3\n\n```\npublic final <U, R> Maybe<R> zipWith(MaybeSource<? extends U> other, \n            BiFunction<? super T, ? super U, ? extends R> zipper) \n```\n\n```\npublic final <U, R> Observable<R> zipWith(ObservableSource<? extends U> other,\n            BiFunction<? super T, ? super U, ? extends R> zipper)\n```\n\nand probably some other methods\nshould generics be defined as `<T, U, R>` ?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4613/comments",
    "author": "stepango",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-27T09:46:13Z",
        "body": "Those are instance methods and inherit `<T>` from the parent class which are `Maybe<T>` and `Observable<T>`.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-25T13:10:36Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4608,
    "title": "1.x @Beta and @Experimental annotations are annotated with itself. ",
    "created_at": "2016-09-26T14:08:31Z",
    "closed_at": "2016-09-26T22:11:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4608",
    "body": "In branch 1.x both @Beta and @Experimental annotations are annotated with itself. That's not the case for the branch 2.x.\n\nI don't understand the purpose of annotating those annotation with itself. Should they not be annotated? \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4608/comments",
    "author": "VictorAlbertos",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-26T18:46:56Z",
        "body": "No idea.\n"
      },
      {
        "user": "zsxwing",
        "created_at": "2016-09-26T19:42:45Z",
        "body": "I guess it's added when they were experimental but we totally forgot to delete them. I think we can remove them now since they are definitely stable APIs.\n\n@VictorAlbertos  could you submit a PR to remove them?\n"
      },
      {
        "user": "VictorAlbertos",
        "created_at": "2016-09-26T20:55:09Z",
        "body": "Sure 👍 \n"
      }
    ]
  },
  {
    "number": 4596,
    "title": "concatWith not called when exception thrown in a following flatMap",
    "created_at": "2016-09-24T08:51:58Z",
    "closed_at": "2016-11-12T19:21:41Z",
    "labels": [
      "Question",
      "1.x",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4596",
    "body": "Hi all,\n\nI am struggling to understand why the concatWith() or onErrorResumeNext() Observables are never executed when an exception happens in a flatMap() call performed **after** the concatWith like in this unit test:\n\n```\n    @Test\n    public void concatWithTest() {\n        Observable.fromCallable(() -> {\n            System.out.println(\"start\");\n            return \"start\";\n        })\n        .doOnError(e -> {\n            System.out.println(\"doOnError\");\n        })\n        .doOnCompleted(() -> {\n            System.out.println(\"doOnCompleted\");\n        })\n        .concatWith(Observable.fromCallable(() -> {\n            System.out.println(\"concatWith\");\n            return \"concatWith\";\n        }))\n        .onErrorResumeNext(e -> {\n            return Observable.fromCallable(() -> {\n                System.out.println(\"onErrorResumeNext\");\n                return \"onErrorResumeNext\";\n            });\n        })\n        .flatMap(firstname -> {\n            System.out.println(\"flatMap\");\n            //throw new RuntimeException();\n            return Observable.just(firstname);\n        })\n        .subscribe(new TestSubscriber<>());\n    }\n```\n\nThis test prints:\n\n```\nstart\nflatMap\ndoOnCompleted\nconcatWith\nflatMap\n```\n\nNevertheless, if in the last flatMap() an exception is thrown (uncomment the \"throw new RuntimeException();\" line in the unit test) then it prints:\n\n```\nstart\nflatMap\n```\n\nSurprisingly, the concatWith() is not called but not even the doOnCompleted(), doOnError() or onErrorResumeNext(). In our situation this involves that resources closed in those methods are never released (in our case an async database connection) when an exception is thrown somewhere in the chain.\nThe same behaviour is present in RxJava 1.1.10 and 1.2.0.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4596/comments",
    "author": "ufoscout",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2016-09-24T09:07:03Z",
        "body": "When you call `.doOnError` or `onErrorResumeNext` they handle errors reported _upstream_ of each call (your final `flatMap` is _downstream_). The first emission will eventually hit the final `flatMap` and provoke an error which will terminate the stream and unsubscribe the subscriber. The unsubscribe action in the subscriber would then initiate a chain of unsubscription actions up the observable chain. Naturally the `concatWith` never gets initiated.\n\nYou mention a need to release resources. To properly handle releasing resources a resource needs to be released on unsubscription (which happens after an error or completion or an explicit unsubscribe call). Have a look at the `Observable.using` method which handles this cleanly for you.\n"
      },
      {
        "user": "ufoscout",
        "created_at": "2016-09-25T06:19:50Z",
        "body": "@davidmoten thanks for your reply, now things are a little bit more clear even if not very intuitive to me.\nI have already investigated the `Observable.using`; however, I need to execute another Observable when the main one ends but it allows me to only execute a synchronous action. Could you please help me understand how to achieve my objective?\nWhat I really need is to execute an observable in case of success (`concatWith` should be fine for this task) and another Observable in case of failure.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-19T15:55:46Z",
        "body": "> What I really need is to execute an observable in case of success (concatWith should be fine for this task) and another `Observable` in case of failure.\n\nThe closest thing is the `flatMap` overload whose functions return `Observable` but is relatively expensive. There, you could map onNexts to `Observable.just()` and the other two event types to the `Observable` of your chosing.\n"
      },
      {
        "user": "ufoscout",
        "created_at": "2016-10-19T20:15:19Z",
        "body": "@akarnokd Thanks for your support; however, I moved my code to rxjava 2.0 and, with my big surprise, in this new version the concatWith() method is called even when there are exceptions thrown downstream in a flatMap call. So in 2.0 my issue does not exist any more.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-25T13:51:50Z",
        "body": "I've tried with both 2.x Flowable and Observable and if the `flatMap` throws, I get\n\n```\nstart\nflatMap\n```\n\nwith them as well. Maybe you forgot to uncomment the throwing code? Nevertheless, it is the expected behavior.\n"
      },
      {
        "user": "ufoscout",
        "created_at": "2016-10-25T15:45:38Z",
        "body": "@akarnokd \nI tested it again, this is my code:\n\n```\n    @Test\n    public void concatWithTest() {\n        Observable.fromCallable(() -> {\n            System.out.println(\"start\");\n            return \"start\";\n        })\n        .concatWith(Observable.fromCallable(() -> {\n            System.out.println(\"concatWith\");\n            return \"concatWith\";\n        }))\n        .onErrorResumeNext(e -> {\n            return Observable.fromCallable(() -> {\n                System.out.println(\"onErrorResumeNext\");\n                return \"onErrorResumeNext\";\n            });\n        })\n        .flatMap(firstname -> {\n            System.out.println(\"flatMap\");\n            throw new RuntimeException();\n        })\n        .subscribe(new TestObserver<>());\n    }\n\n```\n\nIf executed with 2.0.0-RC4 it prints:\n\n```\nstart\nflatMap\nconcatWith\n```\n\nbut with 2.0.0-RC5 it prints \n\n```\nstart\nflatMap\n```\n\nSo my code was working fine with RC4 and now it is again broken :(\n\nAt this point I guess I should try what suggested by you some comments ago:\n\n> The closest thing is the flatMap overload whose functions return Observable but is relatively expensive. There, you could map onNexts to Observable.just() and the other two event types to the Observable of your chosing.\n\nbut I don't understand exactly what it means. Would it be possible to provide a small example?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-25T15:50:06Z",
        "body": "``` java\nsource.flatMap(\n   v -> Observable.just(v.toString()),\n   e -> Observable.just(\"error\"),\n   () -> Observable.just(\"complete\")\n);\n```\n"
      },
      {
        "user": "ufoscout",
        "created_at": "2016-10-31T11:49:20Z",
        "body": "@akarnokd I tried your solution but it still does not work the way I need. In fact, this test:\n\n```\n    @Test\n    public void flatMapErrorHandling() {\n        doSomething()\n        .flatMap(firstname -> {\n            System.out.println(\"flatMap\");\n            throw new RuntimeException();\n        })\n        .subscribe(new TestObserver<>());\n    }\n\n    Observable<String> doSomething() {\n        return Observable.fromCallable(() -> {\n            System.out.println(\"start\");\n            return \"start\";\n        })\n        .flatMap(\n                v -> Observable.just(v),\n                e -> Observable.fromCallable(() -> {\n                    System.out.println(\"Error\");\n                    return \"Error\";\n                }),\n                () -> Observable.fromCallable(() -> {\n                    System.out.println(\"Complete\");\n                    return \"Complete\";\n                })\n             );\n    }\n```\n\nstill prints:\n\n```\nstart\nflatMap\n```\n\nI cannot handle the error in the flatMap which is in the test method because it is only a consumer of a library that exposes the doSomething() method. \nIt seems to me that RxJava here breaks the encapsulation principle, in fact, the behaviour of the doSomething() method is somewhat altered by outside interference.\n\nThe original java code before we moved to RxJava was as simple as:\n\n```\n    void doSomething(Consumer<Connection> consumer) {\n        Connection connection = // get some type of connection somewhere\n        try {\n            consumer.accept(connection);\n            connection.commit();\n        } catch (Throwable e) {\n            connection.rollback();\n        } finally  {\n            connection.close();\n        }\n    }\n```\n\nNow we are unable to handle the rollback-then-close case.\nI am close to give in with this. I couldn't believe this was so incredibly complex to achieve with RxJava.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-31T13:30:03Z",
        "body": "You should apply the 3-arg flatMap after the one that crashes.\n\nWhat do you want to achieve with that connection example? Send a connection along a complex set of operators? Have you looked at `using`?\n"
      },
      {
        "user": "ufoscout",
        "created_at": "2016-10-31T14:02:27Z",
        "body": "> What do you want to achieve with that connection example? Send a connection along a complex set of operators?\n\nyes, and we want the connection to be closed at the end no matter the outcome.\n\n> Have you looked at using?\n\nyes, we tried. But with \"using\" the connection is closed too early, even with eager=false, so when we access the result set a \"Connection is already closed\" Exception is thrown.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-31T14:14:51Z",
        "body": "Maybe you have to redesign the processing chain as well.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T19:21:41Z",
        "body": "If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4588,
    "title": "2.x: Convert Observable to Single without a default value",
    "created_at": "2016-09-23T08:23:13Z",
    "closed_at": "2016-10-09T18:24:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4588",
    "body": "With the RC3 changes I don't see an easy way of converting an Observable into a Single without giving a default value.\n\nHow do you feel about adding methods for that?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4588/comments",
    "author": "vanniktech",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-23T08:29:11Z",
        "body": "@abersnaze didn't like throwing because being empty. Try your API through `Maybe` and `switchIfEmpty(Maybe.error())`.\n\n**Edit** wrong method name, fixed.\n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-09-23T08:34:27Z",
        "body": "`defaultIfEmpty(MaybeSource<T>)` does not exist\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-23T08:45:57Z",
        "body": "Yeah sorry, `switchIfEmpty()` (I sometimes mix the two as `defaultIfEmpty` delegates to `switchIfEmpty`).\n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-09-23T09:07:04Z",
        "body": "I don't quite see how `switchIfEmpty` solves my original problem. `Maybe.switchIfEmpty()` still returns a `Maybe`.\n\nAlso I'd rather have a `NoSuchElementException` and fail early than passing in a default value when converting an Observable to Single.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-23T09:09:56Z",
        "body": "You could restore `toSingle` (under `singleOrError`), only the surface API has been removed.\n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-09-23T09:13:47Z",
        "body": "So basically add to Observable + Flowable:\n\n`singleOrError`\n`firstOrError`\n`lastOrError`\n`elementAtOrError`\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-23T09:15:05Z",
        "body": "Yes.\n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-09-23T09:20:05Z",
        "body": "Alright cool will do\n"
      },
      {
        "user": "abersnaze",
        "created_at": "2016-09-23T18:21:47Z",
        "body": "Does singleElement() error on more than one but not on empty?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-23T18:27:46Z",
        "body": "Yes, that was kept and also why firstElement is there to ignore more without signalling.\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-10-09T18:11:01Z",
        "body": "This can be closed right?\n"
      }
    ]
  },
  {
    "number": 4578,
    "title": "use realm, toList can't go to onNext or onError? ",
    "created_at": "2016-09-22T02:34:25Z",
    "closed_at": "2016-10-17T18:46:38Z",
    "labels": [
      "Question",
      "Android"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4578",
    "body": "Who can tell me which my code wrong? i get data from realm ,and use rxjava operate. now when i get data ,the stram only execute to log message as \"3333333\",after toList,can't go to onNext or onError.\nif i remove toList,it can go to onNext，why?\nplease help me.\n\n``` java\nmModel.getAllSearchHistoryCache().filter(new Func1<RealmResults<SearchHistoryBean>, Boolean>() {\n            @Override\n            public Boolean call(RealmResults<SearchHistoryBean> searchHistoryBeen) {\n                Logger.e(\"111111111\");\n                return searchHistoryBeen.isLoaded();\n            }\n        }).flatMap(new Func1<RealmResults<SearchHistoryBean>, Observable<SearchHistoryBean>>() {\n            @Override\n            public Observable<SearchHistoryBean> call(RealmResults<SearchHistoryBean> searchHistoryBeen) {\n                Logger.e(\"2222222222\");\n                return Observable.from(searchHistoryBeen);\n            }\n        }).map(new Func1<SearchHistoryBean, String>() {\n            @Override\n            public String call(SearchHistoryBean searchHistoryBean) {\n                Logger.e(\"3333333333\");\n                return searchHistoryBean.getKeyWord();\n            }\n        }).toList().observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber<List<String>>() {\n            @Override\n            public void onCompleted() {\n                Logger.e(\"onCompleted\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                Logger.e(\"onError\");\n            }\n\n            @Override\n            public void onNext(List<String> strings) {\n                Logger.e(\"strings:\"+strings);\n                mView.showSearchHistoryList(strings);\n            }\n        });\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4578/comments",
    "author": "lyq027",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-22T06:57:58Z",
        "body": "`toList` requires a finite stream and I guess Realm doesn't give you that.\n"
      },
      {
        "user": "lyq027",
        "created_at": "2016-09-23T01:12:04Z",
        "body": "@akarnokd \ni remove toList , now i use map to create list for my custom, it can call onNext，so i don't know why?\nhow to use toList for work,\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-23T06:59:21Z",
        "body": "No idea, maybe you should ask those who created the Realm-RxJava bridge.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-17T18:46:38Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4571,
    "title": "Replay + Scan with initial value emits too many values",
    "created_at": "2016-09-20T20:30:27Z",
    "closed_at": "2016-10-17T18:47:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4571",
    "body": "The following test behaves as expected, emitting a single value to the subscriber:\n\n```\n    @Test\n    public void testExpectedReplayBehavior() {\n        final TestScheduler scheduler = new TestScheduler();\n        final TestSubject<Integer> subject = TestSubject.create(scheduler);\n        final TestSubscriber<Integer> subscriber = new TestSubscriber<>();\n\n        final ConnectableObservable<Integer> sums = subject.scan((a, b) -> a + b).replay(1);\n        sums.connect();\n\n        subject.onNext(1);\n        subject.onNext(2);\n        subject.onNext(3);\n        scheduler.triggerActions();\n\n        sums.subscribe(subscriber);\n\n        subscriber.assertValueCount(1);\n        subscriber.assertValues(6);\n    }\n```\n\nHowever, the second test fails, emitting all of the events from the source subject, rather than replaying the 1 event I requested with `replay(1)`:\n\n```\n    @Test\n    public void testFlakyReplayBehavior() {\n        final TestScheduler scheduler = new TestScheduler();\n        final TestSubject<Integer> subject = TestSubject.create(scheduler);\n        final TestSubscriber<Integer> subscriber = new TestSubscriber<>();\n\n        final ConnectableObservable<Integer> sums = subject.scan(1, (a, b) -> a + b).replay(1);\n        sums.connect();\n\n        subject.onNext(2);\n        subject.onNext(3);\n        scheduler.triggerActions();\n\n        sums.subscribe(subscriber);\n\n        subscriber.assertValueCount(1);\n        subscriber.assertValues(6);\n    }\n```\n\nAm I missing something nonintuitive about either `scan` or `replay`'s behavior that would reconcile these differences? I don't understand why supplying an initial argument for the accumulator would cause a drastic difference in behavior here.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4571/comments",
    "author": "Thorn1089",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-20T20:59:16Z",
        "body": "Interesting.\n\n`scan(T, Func2)` has an internal buffer that holds onto the intermediate values until the downstream requests. Since `replay` coordinates requests, without a real subscriber, replay doesn't request on its own so `scan` keeps buffering. Once there is a subscriber to `replay`, it requests and now `scan` delivers all buffered values and given the active connection, the `TestSubscriber` receives all 3 values (1, 3, 6). The `scan(Func2)` doesn't buffer and delivers values immediately, filling in the `replay`'s buffer.\n\nSumming up:\n1. `TestSubject` doesn't honor backpressure\n2. `scan(T, Func2)` buffers too much\n3. `replay` doesn't request without `Subscriber`(s)\n\n2 can be considered a bug, 1 should be worked around with proper test emission and 3 is a matter of design and consequences (unlikely to change in 1.x).\n"
      },
      {
        "user": "Thorn1089",
        "created_at": "2016-09-20T21:09:58Z",
        "body": "Thanks for the clarification. I do have a follow-up question around number 1; namely, what should I be doing instead in a test scenario to manually mimic observable emissions if `TestSubject` is not the correct method? Can you clarify what proper test emission would look like here?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-20T21:16:54Z",
        "body": "We use `PublishSubject` mostly when there is no real need for a time component but an imperative sequence of emit-then-test code:\n\n``` java\nPublishSubject<Integer> ps = PublishSubject.create();\n\nTestSubscriber<Integer> ts = new TestSubscriber<>();\n\nps.subscribe(ts);\n\nps.onNext(1);\nts.assertValues(1);\n\nps.onNext(2);\nts.assertValues(1, 2);\n\n// etc.\n```\n"
      },
      {
        "user": "Thorn1089",
        "created_at": "2016-09-20T21:18:23Z",
        "body": "Good to know, thanks!\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-17T18:47:01Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      },
      {
        "user": "tgolden-andplus",
        "created_at": "2016-10-17T18:53:47Z",
        "body": "Sorry, can you link the corresponding ticket for the buggy behavior described re: `scan(T, Func2)`?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-17T18:59:45Z",
        "body": "There is none. It was unclear if the given scan behavior should be considered a bug or not.\n"
      }
    ]
  },
  {
    "number": 4559,
    "title": "2.x: Single.timeout with Callable<SingleSource<? extends T> other>>",
    "created_at": "2016-09-15T08:36:57Z",
    "closed_at": "2016-09-15T09:03:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4559",
    "body": "Basically I'd like to have a lazy timeout so that I only need to construct the other Single source once the original Single source 'timeouts'\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4559/comments",
    "author": "vanniktech",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-15T08:39:15Z",
        "body": "`Single.defer()`\n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-09-15T09:03:57Z",
        "body": "That's very smart\n"
      }
    ]
  },
  {
    "number": 4551,
    "title": "Subjects and Processors does not implement Disposable in 2.x",
    "created_at": "2016-09-14T14:44:26Z",
    "closed_at": "2016-10-17T18:49:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4551",
    "body": "Subjects and Processors does not implement Disposable in 2.x\nIs there something I am missing ?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4551/comments",
    "author": "djodjoni",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2016-09-14T14:47:34Z",
        "body": "What do you expect disposing these types to do?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-14T14:56:51Z",
        "body": "Use `takeUntil` with _another_ Subject to disconnect it from a source:\n\n``` java\nSubject<Object> cancel = PublishSubject.create();\nSubject<Integer> receiver = PublishSubject.create();\n\nsource.takeUntil(cancel).subscribe(receiver);\n\n// after a while\n\ncancel.onComplete();\n```\n"
      },
      {
        "user": "djodjoni",
        "created_at": "2016-09-14T16:29:20Z",
        "body": "Thx @akarnokd, indeed this works but it would be nice to use CompositeDisposable as it can be shared with other Subscribers/Observers similarly as CompositeSubscription in 1.x. Do you have any idea if this will be possible ?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-14T16:37:00Z",
        "body": "No, besides it's an indication you'd better use `Observable.publish` or `Observable.replay()` which can be disposed.\n"
      },
      {
        "user": "djodjoni",
        "created_at": "2016-09-14T17:50:01Z",
        "body": "ok thx!\n"
      },
      {
        "user": "djodjoni",
        "created_at": "2016-09-18T01:46:29Z",
        "body": "I'd like to reopen the discussion. \nThe solution with takeUntil() is not really the best as in case of canceling the Processor receives a terminal event which is not expected. I end up using ConnectableFlowable in between the upstream and the processor, which allows canceling subscription without terminal event.\n\nThis however could be an overhead and makes RxJava Processors a little underdeveloped Subscribers as the Subscription is never saved and there is no way to cancel. \n\nIn Project Reactor for example Porcessors keep reference to the Subscription and provide methods to either get that Ref or call cancel() or both.  \n\nCould you share may be the reasoning why is this not possible to do in RxJava ?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-18T08:27:56Z",
        "body": "It was not designed to support that case.\n"
      },
      {
        "user": "djodjoni",
        "created_at": "2016-09-18T08:42:49Z",
        "body": "By supporting 'that case' you mean to be able to unsubscribe a Subject/Processor?\nIn 1.x this is possible of course as we have the Subscription returned, while due to Reactive Streams compatibility this is not possible in 2.x. In other words has its purpose changed from 1.x to 2.x ?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-18T08:51:03Z",
        "body": "If you don't like it, post a PR.\n"
      },
      {
        "user": "djodjoni",
        "created_at": "2016-09-18T09:02:27Z",
        "body": "I would love to if it doesn't contradict with the current idea and . This is why I try to figure out what you have in mind for those Subjects/Processors.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-18T09:32:50Z",
        "body": "It works for me both ways so I leave it up to you to make all 10 classes support external cancellation.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-17T18:49:05Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4550,
    "title": "is possible to extend Subscriber for receive more user define events ?for example :",
    "created_at": "2016-09-14T10:32:56Z",
    "closed_at": "2016-10-17T18:49:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4550",
    "body": "``` java\npublic abstract class ProgressSubscriber<T> extends Subscriber<T> {\n    public abstract void onProcess(float v) ;\n}\n```\n\nand i do this \n\n``` java\n Observable.create(new Observable.OnSubscribe<String>() {\n            @Override\n            public void call(Subscriber<? super String> subscriber) {\n                ProgressSubscriber s = (ProgressSubscriber) subscriber;\n                s.onProcessLoad(1);\n\n            }\n        }).subscribe(new ProgressSubscriber<String>() {\n            @Override\n                    public void onProcessLoad(float v) {\n                        Log.e(TAG, \"===================>\" + v);\n                    }\n}\n```\n\nit's wrong .so ,please tell it is possible to implement such func in a another way ?thanks\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4550/comments",
    "author": "julist213",
    "comments": [
      {
        "user": "julist213",
        "created_at": "2016-09-14T10:38:21Z",
        "body": "extends SafeSubscriber ??\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-14T10:42:58Z",
        "body": "No, it's impossible. Why do you want to call custom methods on the incoming subscriber instead of calling `onNext` multiple times?\n\n``` java\nObservable.fromEmitter(e -> {\n    o.onNext(1);\n    o.onNext(2);\n    o.onNext(3);\n}, BackpressureMode.BUFFER)\n.subscribe(v -> Log.e(TAG, \"=============>\" + v));\n```\n"
      },
      {
        "user": "julist213",
        "created_at": "2016-09-17T02:08:21Z",
        "body": "@akarnokd something like download file onNext method i'd like to do like onNext(File file) ,and i want to call custom methods to process progress .and i  sucess when i extends safesubscriber ,so i think it can be done in that way .\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-17T18:49:20Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4548,
    "title": "subscription=null?",
    "created_at": "2016-09-14T04:20:21Z",
    "closed_at": "2016-10-19T15:57:48Z",
    "labels": [
      "Question",
      "Android"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4548",
    "body": "How do you do when I am with `Rxjava` get why `subscription` is empty, but can you tell me how to get the `subscription`,Below is my code.\n\n```\nsubscription = downloadService.download(appInfoModel.getInstallUrl())\n                .unsubscribeOn(AndroidSchedulers.mainThread())\n                .map(new Func1<ResponseBody, InputStream>() {\n                    @Override\n                    public InputStream call(ResponseBody responseBody) {\n                        return responseBody.byteStream();\n                    }\n                })\n                .unsubscribeOn(AndroidSchedulers.mainThread())\n                .doOnNext(new Action1<InputStream>() {\n                    @Override\n                    public void call(InputStream inputStream) {\n                        try {\n                            FileUtils.writeFile(inputStream, FileUtils.getFile(appInfoModel));\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                            throw new CustomizeException(e.getMessage(), e);\n                        }\n                    }\n                })\n                .unsubscribeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Subscriber<InputStream>() {\n                    @Override\n                    public void onCompleted() {\n                        downloadCompleted();\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        downloadCompleted();\n                        Log.d(TAG,e.toString());\n                    }\n\n                    @Override\n                    public void onNext(InputStream inputStream) {\n\n                    }\n                });\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4548/comments",
    "author": "guoyoujin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-14T07:17:12Z",
        "body": "I don't understand your question. Are you saying you get `subscription` back as `null`?\n"
      },
      {
        "user": "guoyoujin",
        "created_at": "2016-09-14T08:03:35Z",
        "body": "@akarnokd ,yes `subscription = null`\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-14T08:15:31Z",
        "body": "That's only possible if `downloadService.download` runs on a background thread and you check `subscription == null` there before the main thread has finished storing `subscription`. \n\nAlso why are you using `unsubscribeOn(AndroidSchedulers.mainThread())`? Did you mean `observeOn` to get back to the main thread?\n"
      },
      {
        "user": "guoyoujin",
        "created_at": "2016-09-14T08:52:02Z",
        "body": "@akarnokd \nBecause I am using `intentService`, so use synchronous download files, lead to this problem\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-14T10:49:14Z",
        "body": "How do you check if `subscription` is null? Could you post something more detailed?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-19T15:57:48Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4547,
    "title": "replay does not cache if subscribed to using toBlocking().toFuture().get()",
    "created_at": "2016-09-13T23:20:07Z",
    "closed_at": "2016-09-29T14:20:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4547",
    "body": "Given the following snippet:\n\n```\n    BehaviorSubject<Observable<Integer>> s = BehaviorSubject.create(Observable.just(1));\n\n    Observable<Integer> o = s.flatMap(sp -> sp).replay(1).autoConnect();\n\n    //o.subscribe();\n\n    System.out.println(\"1st = \" + o.first().toBlocking().toFuture().get(0, TimeUnit.SECONDS));\n\n    s.onNext(Observable.just(2));\n\n    System.out.println(\"2st = \" + o.first().toBlocking().toFuture().get(0, TimeUnit.SECONDS));\n```\n\nI expect output: \n\n```\n1st = 1\n2nd = 2 \n```\n\ninstead I get \n\n```\n1st = 1 \n2nd = 1\n```\n\nIf I uncomment o.subscribe(), then the replay value gets updated correctly on 2nd.  Also it works correctly if not using the flatMap().  \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4547/comments",
    "author": "ppiech",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-14T07:13:38Z",
        "body": "`replay` only moves as far as there were requests. Since both `o.first()` request 1 (due to `take(1)` inside), `replay` doesn't request more from the `flatMap`. Without `flatMap`, there is no backpressure and the `s.onNext(Observable.just(2))` is forced through into the `replay`. When you have a consumer like `o.subscribe`, that requests `Long.MAX_VALUE` which then allows `replay` to move forward and take in the 2nd Observable.\n"
      },
      {
        "user": "ppiech",
        "created_at": "2016-09-14T16:08:43Z",
        "body": "The explanation make sense, but it doesn't leave me with any good workaround.  Is there an alternative to replay() which ignores backpressure?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-14T16:10:05Z",
        "body": "``` java\no.subscribe();\n```\n\nthat will unbound it.\n"
      },
      {
        "user": "ppiech",
        "created_at": "2016-09-14T18:05:53Z",
        "body": "I think this means that if I'm dealing with an open observable, it's not safe to use `o.first().toBlocking().toFuture()`\ninstead I should use \n`o.toBlocking().next().toIterator().next()`\nThe downside is that the latter may deadlock if I haven't implemented my observable correctly, where as the former would throw an exception.\n\nOr I should add \n`o.subscribe().unsubscribe()` prior to calling `toBlocking()`.\nbut it really looks like a voodoo hack.\n\nThank you for the explanation!\n"
      }
    ]
  },
  {
    "number": 4539,
    "title": "Chain of Causes for CompositeException In Order Received =>",
    "created_at": "2016-09-13T02:53:09Z",
    "closed_at": "2016-10-12T15:53:16Z",
    "labels": [
      "Question",
      "Android"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4539",
    "body": "```\njava.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\nat rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:59)\nat android.os.Handler.handleCallback(Handler.java:733)\nat android.os.Handler.dispatchMessage(Handler.java:95)\nat android.os.Looper.loop(Looper.java:136)\nat android.app.ActivityThread.main(ActivityThread.java:5120)\nat java.lang.reflect.Method.invokeNative(Native Method)\nat java.lang.reflect.Method.invoke(Method.java:515)\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:818)\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:634)\nat dalvik.system.NativeStart.main(Native Method)\nCaused by: rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\nat rx.observers.SafeSubscriber._onError(SafeSubscriber.java:186)\nat rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\nat rx.exceptions.Exceptions.throwOrReport(Exceptions.java:205)\nat rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:139)\nat rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\nat rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:227)\nat rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n... 9 more\nCaused by: rx.exceptions.CompositeException: 2 exceptions occurred.\n... 16 more\nCaused by: rx.exceptions.CompositeException$CompositeExceptionCausalChain: Chain of Causes for CompositeException In Order Received =>\nat com.tencent.wxop.stat.a.c.a(Unknown Source)\nat com.tencent.wxop.stat.a.c.<init>(Unknown Source)\nat com.tencent.wxop.stat.n.uncaughtException(Unknown Source)\nat java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)\nat java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)\nat rx.internal.schedulers.ScheduledAction.signalError(ScheduledAction.java:68)\nat rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:59)\n... 9 more\nCaused by: java.lang.NullPointerException\nat com.uto.passenger.view.fragment.MainContentView$4$1.onNext(MainContentView.java:271)\nat com.uto.passenger.view.fragment.MainContentView$4$1.onNext(MainContentView.java:261)\nat com.uto.passenger.subscribers.ProgressSubscriber.onNext(ProgressSubscriber.java:182)\nat rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)\nat rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\nat rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:227)\nat rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n... 9 more\nCaused by: java.lang.NullPointerException\nat com.uto.passenger.view.base.BaseFragment.showToast(BaseFragment.java:138)\nat com.uto.passenger.view.base.BaseFragment.checkCode(BaseFragment.java:104)\nat com.uto.passenger.view.fragment.MainContentView.access$300(MainContentView.java:73)\nat com.uto.passenger.view.fragment.MainContentView$4$1.onFail(MainContentView.java:276)\nat com.uto.passenger.subscribers.ProgressSubscriber.onError(ProgressSubscriber.java:166)\nat rx.observers.SafeSubscriber._onError(SafeSubscriber.java:152)\nat rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\nat rx.exceptions.Exceptions.throwOrReport(Exceptions.java:205)\nat rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:139)\n... 12 more\n```\n\nAbove when I encounter problems of exception, don't know what is problem\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4539/comments",
    "author": "hekaidaqaz",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-13T07:27:12Z",
        "body": "```\nCaused by: java.lang.NullPointerException\nat com.uto.passenger.view.fragment.MainContentView$4$1.onNext(MainContentView.java:271)\nat com.uto.passenger.view.fragment.MainContentView$4$1.onNext(MainContentView.java:261)\nat com.uto.passenger.subscribers.ProgressSubscriber.onNext(ProgressSubscriber.java:182)\n```\n\n```\nCaused by: java.lang.NullPointerException\nat com.uto.passenger.view.base.BaseFragment.showToast(BaseFragment.java:138)\nat com.uto.passenger.view.base.BaseFragment.checkCode(BaseFragment.java:104)\nat com.uto.passenger.view.fragment.MainContentView.access$300(MainContentView.java:73)\nat com.uto.passenger.view.fragment.MainContentView$4$1.onFail(MainContentView.java:276)\nat com.uto.passenger.subscribers.ProgressSubscriber.onError(ProgressSubscriber.java:166)\n```\n"
      },
      {
        "user": "hekaidaqaz",
        "created_at": "2016-09-14T01:58:51Z",
        "body": "This must be in the main thread\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-14T10:51:02Z",
        "body": "Some reference in your code is null, maybe because the activity/fragment gets destroyed before the sequence emits a value or error. You should probably check for null first in your code before calling other methods.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-12T15:53:16Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      },
      {
        "user": "desgraci",
        "created_at": "2016-11-14T23:54:19Z",
        "body": "@akarnokd Had the same issue, was on the IO thread before calling the subscriber, on my onError I touched the UI and I wasn't getting the notification for that, but this composite error, I think that was what @hekaidaqaz was trying to mention on his comment. Was able to reproduce it on io.reactivex:rxandroid:1.2.0.\n"
      }
    ]
  },
  {
    "number": 4532,
    "title": "How can I test subscribeOn(scheduler) was called on the correct scheduler",
    "created_at": "2016-09-12T14:13:27Z",
    "closed_at": "2016-09-13T06:46:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4532",
    "body": "How can I verify this in a unit test?\nFor example:\n\n```\nSubscription subscribe(Scheduler ioScheduler, Scheduler uiScheduler, Subscriber subscriber) {\n    return observable.subscribeOn(ioScheduler).observeOn(uiScheduler).subscribe(subscriber);\n}\n```\n\nTried using TestScheduler and TestSubscriber, but could not find a good way to do this.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4532/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-12T14:27:24Z",
        "body": "Use `doOnNext` and write into a container/field/list the `Thread.currentThread` and verify if it's name starts `RxIOScheduler` or similar.\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-09-12T14:29:52Z",
        "body": "Thanks @akarnokd, but the Schedulers I pass are TestScheduler. Any other suggestions?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-12T14:40:03Z",
        "body": "`TestScheduler`s usually run on the main thread (unless you mix them with regular Schedulers or custom threads) and require moving the virtual time manually forward via `advanceTimeBy`. If you do that and you get the expected emissions in the `TestSubscriber` then everything worked.\n\n``` java\nTestScheduler sched = new TestScheduler();\nTestSubscriber<Integer> ts = TestSubscriber.create();\n\nObservable.just(1).delay(500, TimeUnit.MILLISECONDS, sched)\n.subscribe(ts);\n\nts.assertNoValues();\nts.assertNoErrors();\nts.assertNotCompleted();\n\nsched.advanceTimeBy(499, TimeUnit.MILLISECONDS);\n\nts.assertNoValues();\nts.assertNoErrors();\nts.assertNotCompleted();\n\nsched.advanceTimeBy(1, TimeUnit.MILLISECONDS);\n\nts.assertValue(1);\nts.assertNoErrors();\nts.assertCompleted();\n```\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-09-12T14:47:26Z",
        "body": "But in this case you have only one scheduler. I have two. What I want to assert is that subscribeOn was used with the ioScheduler (the first param of the method) and the observeOn was triggered with the uiScheduler.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-12T14:53:41Z",
        "body": "You can't do that, there is no identity of `TestScheduler`s. The only thing you can check if that if you don't call `advanceTimeBy` nothing scheduled should happen (like moving the ioScheduler forward but not the uiScheduler).\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-09-12T14:55:26Z",
        "body": "Running the scheduled actions on `ioScheduler` and then `uiScheduler` in that order basically guarantees it. The reverse would fail to notify the subscriber.\n\nA better solution would be to expose two properties on `TestScheduler`: a total count of scheduled actions and a count of scheduled actions that will run with a call to `triggerActions`. Then you test could read:\n\n``` java\nsubscribe(io, ui, s);\nassertThat(io.scheduledCount()).isEqualTo(1);\nassertThat(ui.scheduledCount()).isEqualTo(0);\nio.triggerActions();\nassertThat(io.scheduledCount()).isEqualTo(0);\nassertThat(ui.scheduledCount()).isEqualTo(1);\nui.triggerActions();\ns.assertValue(whatever);\n```\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-09-12T15:02:11Z",
        "body": "Thanks @JakeWharton, the order does make a difference, but still doesn't cover the case where I use the ioScheduler twice in my code.\nI guess your second suggestion will solve that better.\nSo I guess ATM this is not really possible right?\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-09-12T15:24:50Z",
        "body": "The only way to verify this that I found was to do the following:\n\n```\n        subscriber.assertNoValues();\n\n        ioScheduler.triggerActions();\n        subscriber.assertNoValues();\n        mainScheduler.triggerActions();\n\n        subscriber.assertCompleted();\n```\n\nThis both verifies the order and the dependency on the both schedulers.\nI needed to add another test for use of the mainScheduler twice as well:\n\n```\n        subscriber.assertNoValues();\n\n        mainScheduler.triggerActions();\n\n        subscriber.assertNoValues();\n```\n"
      },
      {
        "user": "yoelglus",
        "created_at": "2016-09-13T06:43:13Z",
        "body": "Me again, this time from my personal account. Will close this issue and submit a PR with some suggestions to make this easier to test.\n@JakeWharton - I want to find a more explicit solution since scheduledCount is very generic and does not describe the thing I am trying to test. Any suggestions are very welcomed.\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-09-13T13:13:57Z",
        "body": "I fail to see how a count of scheduled actions would not cover this case. If you used the scheduler twice the count would be 2 instead of 1. Anything beyond that strays too far into white box testing and at that point you can just use Mockito and mock a Scheduler to verify interactions.\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-09-13T13:50:29Z",
        "body": "I am not saying it doesn't cover this case, it is just a matter of readability of the tests and their intention. But I guess you're right that it will make it a white box testing too much. I will have a deeper look at the TestScheduler and TestSubject to see if I can have something like:\n\n```\nTestScheduler ioScheduler = new TestScheduler(\"io\");\nTestScheduler mainScheduler = new TestScheduler(\"main\");\n\nsubscibe(testSubject, ioScheduler, mainScheduler, subscriber);\n\ntestSubject.assertSubscribeOn(\"io\");\ntestSubject.assertObserveOn(\"main\");\n```\n\nI am afraid I still have a lot to learn about RxJava so I might be way off with this expectation. \n"
      }
    ]
  },
  {
    "number": 4520,
    "title": "2.x: Maybe.complete()",
    "created_at": "2016-09-09T11:52:08Z",
    "closed_at": "2016-09-09T11:55:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4520",
    "body": "Was a bit astonished that there was no `Maybe.complete()` then I saw `Maybe.empty()` which seems to be doing the thing. Any interest in a shortcut or maybe a rename of the method?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4520/comments",
    "author": "vanniktech",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-09T11:54:03Z",
        "body": "Completable is either complete or error, Maybe is has something or is empty (or error).\n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-09-09T11:55:41Z",
        "body": "Alright still feels odd to me but acceptable.\n"
      }
    ]
  },
  {
    "number": 4517,
    "title": "2.x: ResourceSubscriber & ResourceObserver",
    "created_at": "2016-09-09T09:20:29Z",
    "closed_at": "2016-09-09T15:54:23Z",
    "labels": [
      "Question",
      "Feature-Request",
      "PR welcome"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4517",
    "body": "Why is `ResourceSubscriber` using `CompositeDisposable` and `ResourceObserver` using `ListCompositeDisposable`?\n\nAlso the java documentation does not seem to fit of the disposables.\n`/** The resource composite, can be null. */`\n\nIt's initialized and made final and adding a `null` Disposable will throw a `NullPointerException`.\n\nIn addition is there a need for ResourceMaybeObserver and the alike implementation for Single & Completable?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4517/comments",
    "author": "vanniktech",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-09T09:32:08Z",
        "body": "> Why is ResourceSubscriber using CompositeDisposable and ResourceObserver using ListCompositeDisposable?\n\nBy mistake, both should be `ListCompositeDisposable`\n\n> Also the java documentation does not seem to fit of the disposables.\n\nUsed to be optional to have resource support there, the javadoc was not updated when the class was changed to always support resources.\n\n> It's initialized and made final and adding a null Disposable will throw a NullPointerException.\n\nYes, that's intentional.\n\n> In addition is there a need for ResourceMaybeObserver and the alike implementation for Single & Completable?\n\nPR welcome.\n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-09-09T09:36:49Z",
        "body": "Alright I'll get working 👍 \n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-09-09T15:54:23Z",
        "body": "Closing via #4518 \n"
      }
    ]
  },
  {
    "number": 4515,
    "title": "2.x Observer vs Subscriber. Just to clarify.",
    "created_at": "2016-09-08T17:31:11Z",
    "closed_at": "2016-09-08T18:18:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4515",
    "body": "In 1.x the difference between Observer and Subscriber is that a Subscriber allows to subscribe and unsubscribe, however an Observer only allows to subscribe.\n\nBut in 2.x Observer is used to subscribe to an Observable, and Subscriber is used to subscribe to a Flowable. And if you want to be able to unsubscribe, you need to use ResourceObserver and ResourceSubscriber respectively.\n\nIs that right?\n\nThanks.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4515/comments",
    "author": "VictorAlbertos",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-08T18:14:41Z",
        "body": "Yes.\n"
      },
      {
        "user": "ScottCooper92",
        "created_at": "2017-03-01T17:47:12Z",
        "body": "Hi, I realise this is an old issue but I'd like some further clarification. \r\n\r\nThe distinction between a Subscriber and an Observer is that Subscribers are part of the Reactive Stream specification, where the first rule of Subscribers is that they must \"MUST signal demand via Subscription.request(long n) to receive onNext signals.\"\r\n\r\nSince Observables don't have backpressure support, and therefore don't signal demand via request(long n), they use Observer, which doesn't have the request method.\r\n\r\nAm I on the right track?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-01T22:52:28Z",
        "body": "Since `Observable`s don't have backpressure support, there is no need for a `Subscription` with a `request()` method. To avoid some confusion, separate \"connection\" types is employed: `Disposable` with a `dispose()` method that is analogous to `Subscription.cancel()`."
      }
    ]
  },
  {
    "number": 4511,
    "title": "skipUntil with \"empty\" observable causes source obs to never complete.",
    "created_at": "2016-09-08T14:31:02Z",
    "closed_at": "2016-09-08T15:31:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4511",
    "body": "Hello,\n\n``` java\nObservable.interval(1, TimeUnit.SECONDS)\n      .doOnNext(n -> Timber.d(\"firstObs %s\", n))\n      .doOnUnsubscribe(() -> Timber.d(\"onUnsubscribe\"))\n      .doOnCompleted(() -> Timber.d(\"onCompleted\"))\n      .skipUntil(Observable.timer(3, TimeUnit.SECONDS)\n        .flatMap(b -> Observable.empty())\n        .doOnCompleted(() -> Timber.d(\"onCompleted2\")))\n      .subscribe(\n        n -> Timber.d(\"Next? %s\",n),\n        e -> Timber.d(e, \"Err\"),\n        () -> Timber.d(\"Completed\")\n      );\n    Timber.d(\"Ciao\");\n```\n\nLooking at this snippet I would expect \"Completed\" to be triggered upon skipUntil observable completion ('after 3 seconds'). \n\nAfter some time of debugging I found out it's not the case and the Source observable does not get \"onCompleted\" or \"onUnsubscribe\" called when the latter `skipUntil` obs completes its execution.\n\nThis means that the first obs is never gonna end and the emitted items are not going to reach the end of the chain\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4511/comments",
    "author": "vekexasia",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2016-09-08T14:34:29Z",
        "body": "flatMap does not propagate completion events\n"
      },
      {
        "user": "vekexasia",
        "created_at": "2016-09-08T14:52:48Z",
        "body": "why do I get the following output \n\n```\n09-08 16:50:05.670 D/MainActivity: onSubscribe2\n09-08 16:50:05.672 D/MainActivity: onSubscribe\n09-08 16:50:05.674 D/MainActivity: Ciao\n09-08 16:50:06.674 D/MainActivity: firstObs 0\n09-08 16:50:07.674 D/MainActivity: firstObs 1\n09-08 16:50:08.672 D/MainActivity: onCompleted2\n09-08 16:50:08.672 D/MainActivity: onUnsubscribe2\n09-08 16:50:08.674 D/MainActivity: firstObs 2\n09-08 16:50:09.674 D/MainActivity: firstObs 3\n09-08 16:50:10.674 D/MainActivity: firstObs 4\n...\n```\n\nwhen using the following code then?\n\n``` java\nObservable.interval(1, TimeUnit.SECONDS)\n      .doOnNext(n -> Timber.d(\"firstObs %s\", n))\n      .doOnSubscribe(() -> Timber.d(\"onSubscribe\"))\n      .doOnUnsubscribe(() -> Timber.d(\"onUnsubscribe\"))\n      .doOnCompleted(() -> Timber.d(\"onCompleted\"))\n      .skipUntil(Observable.timer(3, TimeUnit.SECONDS)\n        .flatMap(b -> Observable.empty())\n        .doOnCompleted(() -> Timber.d(\"onCompleted2\"))\n        .doOnSubscribe(() -> Timber.d(\"onSubscribe2\"))\n        .doOnUnsubscribe(() -> Timber.d(\"onUnsubscribe2\"))\n      )\n      .subscribe(\n        n -> Timber.d(\"Next? %s\", n),\n        e -> Timber.d(e, \"Err\"),\n        () -> Timber.d(\"Completed\")\n      );\n    Timber.d(\"Ciao\");\n```\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-09-08T14:56:57Z",
        "body": "Because timer completes. I guess you're just using that as an `ignoreElements()`?\n"
      },
      {
        "user": "vekexasia",
        "created_at": "2016-09-08T14:59:19Z",
        "body": "Actually I was hoping that when the skipUntil observable completes, then \"parent\".\"unsubscribe\"  is triggered so that no more elements are sent through the pipeline.\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-09-08T15:00:28Z",
        "body": "`skipUntil` is documented to require an emission to unlatch upstream events so all you need to do is remove your `flatMap`.\n\n> Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n"
      },
      {
        "user": "vekexasia",
        "created_at": "2016-09-08T15:04:35Z",
        "body": "the code above is just as \"sample\". Consider an observable that completes after three seconds without emitting any item (used as skipUntil parameter).\n\nIn such case the first obs will just continue emit its elements without ever completing (and without any chance for the items to reach the end of the chain) \n"
      },
      {
        "user": "vekexasia",
        "created_at": "2016-09-08T15:11:48Z",
        "body": "Just to mention that I rewrote the OperatorSkipUntil so that it unsubscribes from `child` when `other` completes without emitting any element.\n\nI figured it would be something to raise here since someone might expect the same behavior ( if `other` completes without emitting any elements then unsubscribe from `child`)\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-09-08T15:17:01Z",
        "body": "Ahhh, I see. That makes sense I think. I thought you were proposing that it become unlatched when the inner observable completes.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-08T15:22:45Z",
        "body": "Yes, `skipUntil` requires the other `Observable` to signal an item in 1.x and just ignores an empty other `Observable`. In 2.x `skipUntil` enables the gate when the source either signals or just completes.\n\nThis signals-or-completes is a common practice in such operators that take auxiliary sources to trigger one-time events. I guess the 1.x `skipUntil` not opening the gate on a plain `onComplete` is a bug.\n"
      },
      {
        "user": "vekexasia",
        "created_at": "2016-09-08T15:31:59Z",
        "body": "Thank you all :)\n"
      }
    ]
  },
  {
    "number": 4510,
    "title": "TestSubscriber not finishing for flatMap observable",
    "created_at": "2016-09-08T13:23:04Z",
    "closed_at": "2016-10-06T22:03:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4510",
    "body": "So here is the code that I have\n\n```\nreturn Observable.zip(repository.getProductWithId(productId),\n                repository.getDefaultCard(),\n                repository.getPatient(),\n                repository.getTimeslotWithId(timeslotId),\n                repository.getLocationWithId(locationId),\n                Observable.just(bitmapWriter.writeBitmapToFile(signatureBitmap, \".jpg\")),\n                (product, paymentCard, patient, timeslot, location, signaturePath) -> {\n                    List<Object> objects = new ArrayList<>();\n                    objects.add(product);\n                    objects.add(paymentCard);\n                    objects.add(patient);\n                    objects.add(timeslot);\n                    objects.add(location);\n                    objects.add(signaturePath);\n                    return objects;\n                })\n                .observeOn(mBackgroundScheduler)\n                .flatMap(baseModels -> {\n                    String reasonToVisit = sharedPreferences.getString(\n                            Constants.PREFS_PRODUCT_REASON, null);\n                    Product product = (Product) baseModels.get(0);\n                    PaymentCard paymentCard = (PaymentCard) baseModels.get(1);\n                    Patient patient = (Patient) baseModels.get(2);\n                    Timeslot timeslot = (Timeslot) baseModels.get(3);\n                    Location location = (Location) baseModels.get(4);\n                    String signaturePath = (String) baseModels.get(5);\n\n                    if (product.isSignatureRequired()) {\n                        return repository.createAppointmentWithSignature(signaturePath,\n                                androidId,\n                                paymentCard != null ? paymentCard.getId() : null,\n                                reasonToVisit,\n                                product.getId(), timeslot.getId(), patient.getId(),\n                                location.getId());\n                    }\n\n                    return repository.createAppointment(paymentCard != null ? paymentCard.getId() : null,\n                            reasonToVisit,\n                            product.getId(), timeslot.getId(), patient.getId(),\n                            location.getId());\n                })\n                .doOnNext(appointment -> clearPreviousReasonAndProductId())\n                .subscribeOn(mBackgroundScheduler)\n                .observeOn(mUiScheduler)\n                .subscribe(useCaseSubscriber);\n```\n\nWhen I run the code in Android it works perfectly, but when I run test it never finishes.\n\nHere is the test:\n\n```\nmBackgroundScheduler = new TestScheduler();\n        mUiScheduler = new TestScheduler();\ndoReturn(\"reason\").when(mSharedPreferences).getString(Constants.PREFS_PRODUCT_REASON, null);\n        Product product = mock(Product.class);\n        doReturn(false).when(product).isSignatureRequired();\n        doReturn(\"productId\").when(product).getId();\n        doReturn(Observable.just(product)).when(mRepository).getProductWithId(anyString());\n\n        doReturn(Observable.just(null)).when(mRepository).getDefaultCard();\n\n        Patient patient = mock(Patient.class);\n        doReturn(\"patientId\").when(patient).getId();\n        doReturn(Observable.just(patient)).when(mRepository).getPatient();\n\n        Timeslot timeslot = mock(Timeslot.class);\n        doReturn(\"timeslotId\").when(timeslot).getId();\n        doReturn(Observable.just(timeslot)).when(mRepository).getTimeslotWithId(anyString());\n\n        Location location = mock(Location.class);\n        doReturn(\"locationId\").when(location).getId();\n        doReturn(Observable.just(location)).when(mRepository).getLocationWithId(anyString());\n\n        Appointment appointment = mock(Appointment.class);\n        doReturn(Observable.just(appointment)).when(mRepository).createAppointment(anyString(),\n                anyString(), anyString(), anyString(), anyString(), anyString());\n\n        doNothing().when(mTestCase).clearPreviousReasonAndProductId();\n\n        TestSubscriber subscriber = new TestSubscriber();\n        mTestCase.setData(PRODUCT_ID, TIMESLOT_ID, LOCATION_ID, null);\n        mTestCase.buildUseCaseObservable().toBlocking().subscribe(subscriber);\n\n        subscriber.assertNoErrors();\n        subscriber.assertValue(appointment);\n        subscriber.assertCompleted();\n\n        verify(mTestCase).clearPreviousReasonAndProductId();\n        verify(mRepository).getProductWithId(PRODUCT_ID);\n        verify(mRepository).getDefaultCard();\n        verify(mRepository).getPatient();\n        verify(mRepository).getTimeslotWithId(TIMESLOT_ID);\n        verify(mRepository).getLocationWithId(LOCATION_ID);\n        verify(mBitmapWriter).writeBitmapToFile(null, \".jpg\");\n        verify(mSharedPreferences).getString(Constants.PREFS_PRODUCT_REASON, null);\n        verify(product).isSignatureRequired();\n        verify(mRepository).createAppointment(null, \"reason\", \"productId\", \"timeslotId\",\n                \"patientId\", \"locationId\");\n        verify(product).getId();\n        verify(timeslot).getId();\n        verify(patient).getId();\n        verify(location).getId();\n        verifyNoMoreInteractions(mRepository);\n        verifyNoMoreInteractions(mBitmapWriter);\n        verifyNoMoreInteractions(mSharedPreferences);\n        verifyNoMoreInteractions(product);\n        verifyNoMoreInteractions(timeslot);\n        verifyNoMoreInteractions(patient);\n        verifyNoMoreInteractions(location);\n        verifyZeroInteractions(appointment);\n```\n\nI'm ommiting in code creation of TestCase, I'm just simply passing TestSchedulers to the constructor, so not to say that I'm missing something from that standpoint. Thing is that execution of test just hangs after `.toBlocking().subscribe(subsriber)`\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4510/comments",
    "author": "UMFsimke",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-08T13:57:32Z",
        "body": "You deadlock yourself because of blocking subscribe and nothing is moving the `TestScheduler`'s time forward. You need a real scheduler or a non-blocking subscribe and call `advanceTimeBy` on all `TestScheduler`s, possibly multiple times after one another.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-06T22:03:40Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4489,
    "title": "2.x: SerializedEmitter not implementing Disposable",
    "created_at": "2016-09-06T17:47:50Z",
    "closed_at": "2016-09-06T20:30:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4489",
    "body": "While looking at the different `Observable`/`Single`/`Completable` Emitters I noticed that the ObservableCreate `SerializedEmitter` is the only one not implementing `Disposable` and thus `#dispose`.\n\nIs this intended?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4489/comments",
    "author": "Mauin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-06T19:52:33Z",
        "body": "Yes, you are not supposed to dispose it from inside the emitter callback anyway.\n"
      },
      {
        "user": "Mauin",
        "created_at": "2016-09-06T20:30:44Z",
        "body": "Okay, thanks for the clarification @akarnokd 👍 \n"
      }
    ]
  },
  {
    "number": 4485,
    "title": "Renaming RxCachedThreadScheduler",
    "created_at": "2016-09-06T12:43:52Z",
    "closed_at": "2016-09-06T13:03:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4485",
    "body": "Is it possible to simply change the name `RxCachedThreadScheduler` to something else?\n\nThanks in advance!\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4485/comments",
    "author": "richardradics",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-06T12:48:50Z",
        "body": "Not without recompiling the library. Why do you want to change it?\n"
      },
      {
        "user": "richardradics",
        "created_at": "2016-09-06T13:03:47Z",
        "body": "I am working on an android project which has really long package name, so i just wondering how to reduce the lines in the logcat.\n\nThank you for the answer.\n"
      }
    ]
  },
  {
    "number": 4477,
    "title": "2.x TestObserver and TestSubscriber for unit testing",
    "created_at": "2016-09-05T15:24:36Z",
    "closed_at": "2016-09-06T08:50:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4477",
    "body": "In 1.x I was using `TestSubscriber` to perform assertions in unit tests. But it seems that in 2.x is `TestObserver` the class that we need to use for this matter. Is that correct? And if that's correct, when I should use `TestSubscriber`?\n\nThanks. \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4477/comments",
    "author": "VictorAlbertos",
    "comments": [
      {
        "user": "vanniktech",
        "created_at": "2016-09-05T15:27:33Z",
        "body": "All reactive types also have a built in `test` method that can be used.\n"
      },
      {
        "user": "VictorAlbertos",
        "created_at": "2016-09-05T15:41:47Z",
        "body": "Very handy. Thanks @vanniktech  \n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-06T06:57:26Z",
        "body": "You use `TestSubscriber` with `Flowable` and `TestObserver` with `Observable`. You can test `Single`, `Completable` and `Maybe` by converting them to either `Flowable` or `Observable`, but the built-in `test()`s for these three return `TestObserver`.\r\n"
      },
      {
        "user": "VictorAlbertos",
        "created_at": "2016-09-06T08:50:41Z",
        "body": "Thanks @akarnokd \n"
      },
      {
        "user": "andreathacker",
        "created_at": "2018-03-08T23:19:41Z",
        "body": "In 2.x @akarnokd mentioned that the built-in return for `Single`, `Completable` and `Maybe` is `TestSubscriber` but it looks like it actual default for `Completable` is now `TestObserver`\r\n\r\n```\r\n    @CheckReturnValue\r\n    @SchedulerSupport(SchedulerSupport.NONE)\r\n    public final TestObserver<Void> test() {\r\n        TestObserver<Void> ts = new TestObserver<Void>();\r\n        subscribe(ts);\r\n        return ts;\r\n    }\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-03-08T23:41:11Z",
        "body": "@davidargylethacker Thanks, edited my comment to define the correct type."
      },
      {
        "user": "osvalr",
        "created_at": "2018-07-17T15:31:01Z",
        "body": "Thanks @akarnokd "
      }
    ]
  },
  {
    "number": 4473,
    "title": "1.x: SingleDoAfterTerminateSubscriber swallowing exception",
    "created_at": "2016-09-05T12:35:46Z",
    "closed_at": "2016-09-05T12:49:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4473",
    "body": "Isn't `SingleDoAfterTerminateSubscriber` swallowing an exception?\n\ne.g. when action that get's invoked throws an excpetion for instance NullPointerException It'll be just rethrown but not delivered through onError\n\nAlso could not `SingleDoOnEvent` be reused for this behavior of invoking an action when Single has completed or errored? \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4473/comments",
    "author": "vanniktech",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-05T12:41:03Z",
        "body": "It is **AfterTerminate**, that is, called after onXXX of the downstream has been called. At that point, the exception can't go anywhere other than the global onError handler.\n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-09-05T12:49:28Z",
        "body": "Okay makes sense. Thanks for the explanation! \n"
      }
    ]
  },
  {
    "number": 4465,
    "title": "2.x: operator method naming in Observable",
    "created_at": "2016-09-02T09:16:48Z",
    "closed_at": "2016-09-14T10:57:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4465",
    "body": "hi guys,\n\nI think there is much redundancy in many operator methods comparing to 1.x. For example, the `from` series:\n\n`fromCallable(Callable<? extends T> supplier)`\n\nThe parameter (list) has already indicated the object and can help to set the methods apart syntactically. I think we can leave out the unnecessary `Callable` part in the name.  I mean it's trouble to have something like this:  `justTwoItems(T item1, T item2)` right? :) \n\nNever mind,  `just` is fine.\n\nThere are many similar cases mainly in `from` and `concat` series. But sorry I can't list them all.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4465/comments",
    "author": "XizhiXu",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-02T09:25:12Z",
        "body": "These methods have prefixes because Java 8 compilers can't disambiguate properly between the methods, forcing you to cast them to the proper functional interface type; a postfix is simply shorter and more explicit to the reader.\n"
      }
    ]
  },
  {
    "number": 4456,
    "title": "2.x: Naming of .doOnCancel()",
    "created_at": "2016-09-01T17:10:54Z",
    "closed_at": "2016-09-01T18:48:00Z",
    "labels": [
      "Question",
      "PR welcome"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4456",
    "body": "As I understand it the `.doOnCancel()` operator is basically the replacement of `.doOnUnsubscribe()` in the 1.x world.\n\nIn that case: Just from a naming perspective wouldn't it be clearer to name it `.doOnDispose()` ?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4456/comments",
    "author": "Mauin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-01T17:13:19Z",
        "body": "`Flowable` -> `doOnCancel()` because of `Subscription.cancel()`, the other can be called `doOnDispose()`. Want to submit a PR?\n"
      },
      {
        "user": "Mauin",
        "created_at": "2016-09-01T17:14:14Z",
        "body": "Ah, I was not looking much at Flowable yet, that's why I missed that part. Thanks for explaining!\n\nI'll get started on the PR.\n"
      }
    ]
  },
  {
    "number": 4444,
    "title": "PublishSubject - Why isn't there onStart() method?",
    "created_at": "2016-08-30T15:17:00Z",
    "closed_at": "2016-09-14T10:59:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4444",
    "body": "Why isn't there onStart() method in PublishSubject, BehaviorSubject etc?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4444/comments",
    "author": "rusmichal",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-30T15:43:38Z",
        "body": "They are `Observer`s in 1.x and not `Subscriber`s since both `Observable` and `Subscriber` are classes, a `Subject` can't extend both. Besides, these subjects have nothing to do for an `onStart` anyway.\n"
      },
      {
        "user": "rusmichal",
        "created_at": "2016-08-30T16:05:09Z",
        "body": "Ok. What I should use in that case?:\n\n```\nPublishSubject<String> tokenObservable\n....\naccessTokenObservable(...)\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Subscriber<String>() {\n            @Override\n            public void onCompleted() {\n                tokenObservable.onCompleted();\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                tokenObservable.onError(e);\n            }\n\n            @Override\n            public void onNext(String s) {\n                tokenObservable.onNext(s);\n            }\n\n            @Override\n            public void onStart() {\n\n            }\n        });\n```\n\nIn other place of project is use getter for `tokenObservable.asObservable()`\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-30T16:31:47Z",
        "body": "What is your use case?\n"
      },
      {
        "user": "rusmichal",
        "created_at": "2016-08-30T17:11:54Z",
        "body": "General I have LinkedInHelper class where I am using to getting token. In this class I call request to LinkedIn API with retrofit and RxJava. I created PublishSubject object because I want to know what accessTokenObservable is emitting in LinkedInHelper on move it to activity. This is kind of callback.\n\nI created getObservableToken method which return `tokenObservable.asObservable()`. I use getObservableToken and call subscribe on it. \n\nDo you know what I mean?\n"
      },
      {
        "user": "rusmichal",
        "created_at": "2016-08-30T19:38:58Z",
        "body": "Maybe better will be if I share my observable with `publish()` method and subscribe in activity? I should get multiple emissions? Right?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-31T07:26:37Z",
        "body": "With `publish(Func1)`, the upstream will be consumed exactly one but the events will be dispatched to as many consumers as necessary.\n"
      },
      {
        "user": "rusmichal",
        "created_at": "2016-08-31T09:59:22Z",
        "body": "I resolved using interface as callback\n\n```\naccessTokenObservable(...)\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Subscriber<String>() {\n            @Override\n            public void onCompleted() {\n                if(tokenListener != null) {\n                    tokenListener.onCompleted();\n                }\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                if(tokenListener != null) {\n                    tokenListener.onError(e);\n                }\n            }\n\n            @Override\n            public void onNext(String token) {\n                if(tokenListener != null) {\n                    tokenListener.onTokenObtained(token);\n                }\n            }\n\n            @Override\n            public void onStart() {\n                if(tokenListener != null) {\n                    tokenListener.onStart();\n                }\n            }\n        });\n```\n\nIn activity, but I prefer use RxJava\n\n```\nsetTokenListener(new LinkedInHelper.TokenListener() {\n            @Override\n            public void onCompleted() {\n                //hide spinner\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                //show error, hide spinner\n            }\n\n            @Override\n            public void onTokenObtained(String token) {\n                //to do\n            }\n\n            @Override\n            public void onStart() {\n                //show spinner\n            }\n        });\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-14T10:59:50Z",
        "body": "Great!\nI'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4440,
    "title": "Observable invoked twice on single subscription",
    "created_at": "2016-08-30T05:17:19Z",
    "closed_at": "2016-09-01T16:34:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4440",
    "body": "Hi,\nI have a simple use case where f1,  f2 and f3 are observable network calls with the dependency order: f2 -> f1 (f2 depends on f1 )and f3 -> f1 (f3 depends on f1). \nWhen I zip f2 and f3 to produce a combined result, f1 is getting called twice but I want it invoked only once otherwise it defeats the purpose. Could you please advise? I am sure I have the wiring wrong but couldn't figure out where and I tried all options on f1 : cache, share, replay \n\nCode:\n\n``` java\npublic static void main(String[] args) {\n    String id = \"abc\";\n    Observable.zip(T2dependency(id ), T3dependency(id ), \n        new Func2<JsonObject, JsonObject, JsonObject>() {\n\n    @Override\n    public JsonObject call(JsonObject t2Response, JsonObject t3Response) {\n\n     // operations on t2 & t3\n\n        return t2Response;\n    }\n\n    })\n    .subscribe(next -> System.out.println(\"final subscribe o/p: \" + new Gson().toJson(next)),\n        error -> error.printStackTrace());\n}\n\n\nprotected Observable<JsonObject> T2dependency(String id) {\n\n    return getT1info(id)\n    .<JsonObject>flatMap(new Func1<JsonObject, Observable<JsonObject>>() {\n\n        @Override\n        public Observable<JsonObject> call(JsonObject t1Response) {\n            System.out.println(\"T2.t1Response\");\n            return Observable.just(t1Response);\n        }\n    });\n}\n\nprotected Observable<JsonObject> T3dependency(String id) {\n\n    return getT1info(id)\n    .<JsonObject>flatMap(new Func1<JsonObject, Observable<JsonObject>>() {\n\n        @Override\n        public Observable<JsonObject> call(JsonObject t1Response) {\n            System.out.println(\"T3.t1Response\");\n            return Observable.just(t1Response);\n        }\n    });\n}\n\nprotected Observable<JsonObject> getT1info(String id) {\n        return ObservableHttp.createGet(url+id, client).toObservable()\n    .<JsonObject>flatMap(\n            response -> {\n\n                System.out.println(\"calling getT1info: \" + count++ );\n                return response.getContent()\n                        .map(s3 ->{\n                            System.out\n                                    .println(new String(s3));\n                            return new JsonParser().parse(new String(s3)).getAsJsonObject();\n                            }\n                        ); \n                    }\n            )\n            .timeout(3000, TimeUnit.MILLISECONDS)\n        .doOnError(throwable ->\n                System.out.println(\"printing throwable (getT1info): \" + throwable.toString())\n        );\n}\n```\n\nAny advise is greatly appreciated,\nThank you.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4440/comments",
    "author": "udayravuri",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-30T07:11:07Z",
        "body": "You can use `publish(Func1)` that will share the underlying source for all consumers within the function call:\n\n``` java\nObservable.range(1, 10)\n.doOnSubscribe(() -> System.out.println(\"Subscribed\"))\n.publish(o -> Observable.zip(o.map(v -> v * 10), o.map(v -> v * 20), (a, b) -> a + \"-\" + b))\n.subscribe(System.out::println, Throwable::printStackTrace);\n```\n"
      },
      {
        "user": "udayravuri",
        "created_at": "2016-09-01T16:34:32Z",
        "body": "It worked perfectly. It took me some time to try out all of my wiring scenarios, especially for the observables that made network calls.\nThank you so much.\n"
      },
      {
        "user": "udayravuri",
        "created_at": "2016-09-01T16:34:40Z",
        "body": "Thank you\n"
      }
    ]
  },
  {
    "number": 4438,
    "title": "2.x: Best way to unsubscribe/dispose a Subject subscription?",
    "created_at": "2016-08-29T19:41:55Z",
    "closed_at": "2016-08-29T19:53:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4438",
    "body": "Since there is no longer a `Subscription` returned when subscribing a `Subject` to an `Observable`, looking for the best way unsubscribe/dispose.\n\n``` java\nObservable<Long> observableA = Observable.interval(200, TimeUnit.MILLISECONDS).map(value -> value);\nObservable<Long> observableB = Observable.interval(200, TimeUnit.MILLISECONDS).map(value -> value * 100L);\n\nBehaviorSubject<Long> subject = BehaviorSubject.create();\nsubject.subscribe(System.out::println);\n\nSystem.out.println(\"Subscribing to observableA\");\nobservableA.subscribe(subject);\n\nTimeUnit.SECONDS.sleep(3);\n\n// TODO: How to unsubscribe the subject from upstream observableA before subscribing it to upstream observableB?\n\nSystem.out.println(\"Subscribing to observableB\");\nobservableB.subscribe(subject);\n\nTimeUnit.SECONDS.sleep(3);\n```\n\nWhat I've come up with so far is to `subscribeWith` an object that extends `DisposableObserver` that forwards `onNext`, `onError`, `onComplete` to the subject and use that to `dispose()` at the appropriate time.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4438/comments",
    "author": "paulblessing",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-29T19:50:07Z",
        "body": "Yes, that works, also `subscribe(subject::onNext)` etc. where you get back a `Disposable` too.\n"
      },
      {
        "user": "paulblessing",
        "created_at": "2016-08-29T19:53:25Z",
        "body": "Works for me, thanks. Was just trying to make sure I wasn't overlooking something obvious.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-29T19:58:25Z",
        "body": "In 2.x, exposing the `dispose()` method is the choice of the consumer `Observer`; this saves us a lot of allocation when such feature is not required.\n"
      }
    ]
  },
  {
    "number": 4429,
    "title": "BackPressure buffer size",
    "created_at": "2016-08-26T08:05:25Z",
    "closed_at": "2016-09-15T08:42:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4429",
    "body": "I'm trying to implement some zip, which combining some wrapper from EditView like:\n\n``` java\ncommentBarView.setOnTextChangedListener(\n    view -> commentBarViewTextWrapper.onNext(view != null ? view.getText().toString() : null));\n```\n\nwith an interval, so my zip looks like: \n\n``` java\nObservable.zip(commentBarViewTextWrapper.onBackpressureBuffer(1, null, () -> true),\n          Observable.interval(0,USER_TYPING_INTERVAL, TimeUnit.SECONDS, scheduler),\n          (i, c) -> conversationTyping).subscribe(conversationTyping1 -> {\n              sendMessage(conversationTyping1);\n          }, throwable -> {\n              throwable.printStackTrace();\n          })\n```\n\nThe problem is that commentBarViewTextWrapper emmits a lot of events, and if I stop typing, there are a lot of events emmit afterwards. I'm trying to reduce it with buffer limit, but it doesn't work.\nWhich solution could be in this case? \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4429/comments",
    "author": "adauvalter",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-01T14:31:54Z",
        "body": "Have you looked at `debounce` and possibly `switchMap`?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-15T08:42:26Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4408,
    "title": "CombineLatest and toList combination.",
    "created_at": "2016-08-23T07:28:11Z",
    "closed_at": "2016-08-24T10:40:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4408",
    "body": "Hello, \nThe RexactiveX documentation says : \n\n>  CombineLatest emits an item whenever any of the source Observables emits an item (so long as each of the source Observables has emitted at least one item)\n\nbut when I use combineLatest on a stream converted with toList, the output only produces one element even if the other stream (the one not converted with toList) has many values.\n\nGiving this test :\n\n``` java\nimport org.testng.annotations.Test;\nimport rx.Observable;\n\npublic class CombineLastTest {\n\n    @Test\n    public void testZip() {\n        Observable.combineLatest(//\n                Observable.just(1, 2, 3, 4, 5)//\n                     .doOnNext((integerValue) -> System.out.println(\"First stream value  : \" + integerValue))//\n                     .doOnCompleted(() -> System.out.println(\"First stream complete\")),//\n                Observable.just(\"a\", \"b\", \"c\", \"d\", \"e\")//\n                     .doOnNext((stringValue) -> System.out.println(\"Second stream value : \" + stringValue))//\n                     .toList()//\n                     .doOnNext((stringListValues) -> System.out.println(\"Second stream to list : \" + stringListValues))//\n                     .doOnCompleted(() -> System.out.println(\"Second stream complete\")),//\n                (firstStreamLatestStringValue, secondStreamLatestStringListValue) -> firstStreamLatestStringValue + \" \" + secondStreamLatestStringListValue)//\n            .doOnCompleted(() -> System.out.println(\"Stream is completed\")).subscribe(System.out::println);\n    }\n}\n```\n\nI get :\n\n```\nFirst stream value  : 1\nFirst stream value  : 2\nFirst stream value  : 3\nFirst stream value  : 4\nFirst stream value  : 5\nFirst stream complete\nSecond stream value : a\nSecond stream value : b\nSecond stream value : c\nSecond stream value : d\nSecond stream value : e\nSecond stream to list : [a, b, c, d, e]\n5 [a, b, c, d, e]\nSecond stream complete\nStream is completed\n```\n\nI presume I should get : \n\n```\nFirst stream value  : 1\nFirst stream value  : 2\nFirst stream value  : 3\nFirst stream value  : 4\nFirst stream value  : 5\nFirst stream complete\nSecond stream value : a\nSecond stream value : b\nSecond stream value : c\nSecond stream value : d\nSecond stream value : e\nSecond stream to list : [a, b, c, d, e]\n1 [a, b, c, d, e]\n2 [a, b, c, d, e]\n3 [a, b, c, d, e]\n4 [a, b, c, d, e]\n5 [a, b, c, d, e]\nSecond stream complete\nStream is completed\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4408/comments",
    "author": "sdaclin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-23T07:43:11Z",
        "body": "`combineLatest` will run through a synchronous source and only keep its last value. You should swap the two parameters that will yield something like you wanted.\n\nIt is an odd operator because it only works as one expects if the sources emit from the same thread and are naturally interleaved or all have exactly one value to combine. All else is subject to either thread scheduling non-determinism or run-to-end like behavior just like this.\n"
      },
      {
        "user": "sdaclin",
        "created_at": "2016-08-23T08:21:08Z",
        "body": "Ok thank you a lot David for being so fast with your answer. :+1: \nI've swapped the two inputs : \n\n``` java\n@Test\n    public void testZipFixed() {\n        Observable.combineLatest(//\n                                 Observable.just(\"a\", \"b\", \"c\", \"d\", \"e\")//\n                                         .doOnNext((stringValue) -> System.out.println(\"Second stream value : \" + stringValue))//\n                                         .toList()//\n                                         .doOnNext((stringListValues) -> System.out.println(\"Second stream to list : \" + stringListValues))//\n                                         .doOnCompleted(() -> System.out.println(\"Second stream complete\")),//\n                                 Observable.just(1, 2, 3, 4, 5)//\n                                         .doOnNext((integerValue) -> System.out.println(\"First stream value  : \" + integerValue))//\n                                         .doOnCompleted(() -> System.out.println(\"First stream complete\")),//\n                                 (secondStreamLatestStringListValue, firstStreamLatestStringValue) -> firstStreamLatestStringValue + \" \" + secondStreamLatestStringListValue)//\n                .doOnCompleted(() -> System.out.println(\"Stream is completed\")).subscribe(System.out::println);\n    }\n```\n\nAnd now it works as expected :\n\n```\nSecond stream value : a\nSecond stream value : b\nSecond stream value : c\nSecond stream value : d\nSecond stream value : e\nSecond stream to list : [a, b, c, d, e]\nSecond stream complete\nFirst stream value  : 1\n1 [a, b, c, d, e]\nFirst stream value  : 2\n2 [a, b, c, d, e]\nFirst stream value  : 3\n3 [a, b, c, d, e]\nFirst stream value  : 4\n4 [a, b, c, d, e]\nFirst stream value  : 5\n5 [a, b, c, d, e]\nFirst stream complete\nStream is completed\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-24T10:40:51Z",
        "body": "Great. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4407,
    "title": "Unsubscribe not called when using retryWhen",
    "created_at": "2016-08-23T05:22:14Z",
    "closed_at": "2016-08-23T16:56:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4407",
    "body": "I am not sure if this is expected, but when I run the below test, I get an assertion error:\n\n`java.lang.AssertionError: Not unsubscribed. (1 completion)`\n\nIt does not happen all the time which is why I put it in a loop. I suspect it has something to do with the timer in `retryWhen`. If the timer is set to 0, the test runs successfully. Anything else, it fails. I noticed the timer runs on the computation scheduler and tried adding `observeOn(Schedulers.immediate())` everywhere with no luck. \n\nIs the expected? If so, how can I get this to run reliably?\n\nTested on RxJava v1.1.9 and v1.1.0\n\n``` java\n\n    @Test\n    public void testUnsubscribe_shouldUnsubscribeAfterRetry() {\n        String testValue = \"test\";\n        for (int i = 0; i < 1000; ++i) {\n            TestSubscriber<String> subscriber = new TestSubscriber<>();\n            AtomicBoolean shouldFail = new AtomicBoolean(true);\n\n            Observable.defer(() -> {\n                if (shouldFail.getAndSet(false)) {\n                    return Observable.error(new IOException(\"Network Error\"));\n                } else {\n                    return Observable.just(testValue);\n                }\n            }).retryWhen(this::onErrorTryAgainWithTimer).subscribe(subscriber);\n\n            subscriber.awaitTerminalEvent();\n            subscriber.assertValue(testValue);\n            subscriber.assertNoErrors();\n            subscriber.assertUnsubscribed();  // Fails here\n        }\n    }\n\n    private Observable<?> onErrorTryAgainWithTimer(Observable<? extends Throwable> errors) {\n        return errors.zipWith(Observable.just(10, 1000, 2000), (n, i) -> i)\n                .flatMap(time -> Observable.timer(time, MILLISECONDS));\n    }\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4407/comments",
    "author": "mandrizzle",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-23T07:04:04Z",
        "body": "What happens is that the `SafeSubscriber` calls `onComplete()` and then `unsubscribe` from the timer thread. The `onComplete` unblocks the `awaitTerminalEvent()` and then the assertions may run concurrently with `unsubscribe` which may or may not happen in time for the `assertUnsubscribed` to happen.\n"
      },
      {
        "user": "mandrizzle",
        "created_at": "2016-08-23T16:56:02Z",
        "body": "I think you are right, if I change my test to use a count down latch:\n\n``` java\n    @Test\n    public void testUnsubscribe_shouldUnsubscribeAfterRetry() throws InterruptedException {\n        String testValue = \"test\";\n        CountDownLatch latch = new CountDownLatch(1);\n\n        for (int i = 0; i < 1000; ++i) {\n            TestSubscriber<String> subscriber = new TestSubscriber<>();\n            AtomicBoolean shouldFail = new AtomicBoolean(true);\n\n            Observable.defer(() -> {\n                if (shouldFail.getAndSet(false)) {\n                    return Observable.error(NETWORK_EXCEPTION);\n                } else {\n                    return Observable.just(testValue);\n                }\n            }).retryWhen(this::onErrorTryAgainWithTimer).doOnUnsubscribe(latch::countDown).subscribe(subscriber);\n\n            subscriber.awaitTerminalEvent();\n            subscriber.assertValue(testValue);\n            subscriber.assertNoErrors();\n            latch.await();\n//            subscriber.assertUnsubscribed();\n        }\n    }\n```\n\nthe test completes every time. Thanks!\n"
      }
    ]
  },
  {
    "number": 4405,
    "title": "Sync State Observable does not work well with subscribeOn",
    "created_at": "2016-08-22T18:03:12Z",
    "closed_at": "2016-08-23T07:12:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4405",
    "body": "An observable created with `Observable.create(SyncOnSubscribe)` does not work well when that observable is assigned a scheduler with `Observable.subscribeOn(Scheduler)`. \n\nSpecifically, the `SyncOnSubscribe.call(Subscriber)` method is not being called in the lifecycle of the `OperatorSubscribeOn.call(Subscriber)`.\n\nThis does not set the proper producer required for SyncOnSubscribe to work. \n\nThis can be seen on RxJava 1.1.9 (on Android).\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4405/comments",
    "author": "hf",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-22T18:23:50Z",
        "body": "Could you post a code that's not working for you? You have to create an `Observable` from an instance of `SyncOnSubscribe` because `Observable` has to call `Subscriber.onStart` that may trigger the necessary `request(n)` calls down the chain.\n"
      },
      {
        "user": "hf",
        "created_at": "2016-08-23T07:12:16Z",
        "body": "The issue was with a CompositeSubscription that got unsubscribed before the addition of the SyncOnSubscribe subscription. Sorry, everything is great. :)\n"
      }
    ]
  },
  {
    "number": 4404,
    "title": "RxJavaObservableExecutionHook for only one Observable?",
    "created_at": "2016-08-22T16:37:57Z",
    "closed_at": "2016-08-24T05:57:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4404",
    "body": "If I understand correctly, using `RxJavaObservableExecutionHook` will respond for all observable calls within my app. Is there a way to hook `RxJavaObservableExecutionHook` into only a single observable? I'd like different hooks for different observables throughout my app.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4404/comments",
    "author": "tir38",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-22T16:45:22Z",
        "body": "Use the callbacks of `RxJavaHooks` like `setOnObservableCreate` or `setOnObservableStart` but you'll need to identify your `Observable` or `OnSubscribe` implementation in some way.\n"
      },
      {
        "user": "tir38",
        "created_at": "2016-08-24T05:57:17Z",
        "body": "Excellent thanks.\n"
      }
    ]
  },
  {
    "number": 4377,
    "title": "bug with combineLatest() ?",
    "created_at": "2016-08-19T13:04:29Z",
    "closed_at": "2016-08-23T13:56:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4377",
    "body": "These last days, I was burned by a somewhat unexpected behavior of combineLatest (RxJava 1.1.9) :\nWhen I used with 2 observables on different threads (because of subscribeOn), it emits nothing \n\nAm I doing something wrong ? or is this a bug ? as designed ?\n\n``` java\nimport javafx.util.Pair;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport rx.Observable;\nimport rx.schedulers.Schedulers;\n\n@RunWith(JUnit4.class)\npublic class Bug {\n    @Test\n    void test() throws Exception {\n        StringBuilder builder = new StringBuilder();\n        // this one works as expected\n        builder.append(\"first test\\n\");\n\n        Observable.combineLatest(\n            Observable.just(1, 2, 3, 4, 5, 6, 7), \n            Observable.just(2, 5, 7, 9, 2, 4, 5), \n            (a, b) -> new Pair(a, b)).subscribe(it -> builder.append(it.toString()));\n\n        // this one doesn't  emit anything\n        builder.append(\"second test\\n\");\n         Observable.combineLatest(\n            Observable.just(1, 2, 3, 4, 5, 6, 7).subscribeOn(Schedulers.io()), \n            Observable.just(2, 5, 7, 9, 2, 4, 5), \n            (a, b) -> new Pair(a, b)).subscribe(it -> builder.append(it.toString()));\n\n        // this one doesn't  emit anything\n        builder.append(\"third test\\n\");\n        Observable.combineLatest(\n            Observable.just(1, 2, 3, 4, 5, 6, 7).observeOn(Schedulers.io()).map(it -> it), \n            Observable.just(2, 5, 7, 9, 2, 4, 5), \n            (a, b) -> new Pair(a, b)).subscribe(it -> builder.append(it.toString()));\n\n        throw new Exception(builder.toString());\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4377/comments",
    "author": "Lakedaemon",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-19T15:12:29Z",
        "body": "Your test quits before those other asynchronous `combineLatest`s can even run.  Even if they'd run, the `StringBuilder` would get corrupted due to concurrent access.\n"
      },
      {
        "user": "Lakedaemon",
        "created_at": "2016-08-19T15:53:13Z",
        "body": "Yes, you are right. I wrote crappy tests that can't fulfill their purpose.\n\nI have an issue in one android app with combineLatest that never emits anything though the 2 observables that feeds it (one observable created through Observable.create() <-- this might be the issue (bad implementation, backpressure not implemented but needed ?), and one observable created through a publishSubject with startWith(1 value)) each emit something. \n\nI'll go back to investigating what goes wrong in my app... \n"
      },
      {
        "user": "Lakedaemon",
        "created_at": "2016-08-19T17:40:10Z",
        "body": "It's weird. \nI fixed (or I think that I did) the Observable.onCreate() : \na) I wasn't using onCompleted() at the end, \nb) I also added an onBackpressureBuffer() after it\nc) Also, it goes through a scan operator that emits  a data collector that feeds combineLatest()\nI also made sure that I'm returning a different collector (in case combineLatest tests if the result is the same).... \nyet, though the scan observable emits lots of items on a 20 seconds span... the combineLatest() only emits 1 item at the very end, when the scan operator is finished... really weird.\nI'll try to investigate further...\n"
      },
      {
        "user": "Lakedaemon",
        "created_at": "2016-08-19T21:08:04Z",
        "body": "I got it working. Actually, it was point c that was causing my issue.\nIn the scan operator I was always returning the same accumulator and I guess that there is a test in the combineLatest operator to avoid emitting a value that hasn't changed.\n\nReturning a copy of the accumulator with a slightly different id fixed the equal result and combineLatest suddenly started emitting mor items.  \n\nMaybee this could/should be added in the documentation of combineLatest if it isn't already there.\n"
      },
      {
        "user": "Lakedaemon",
        "created_at": "2016-08-20T16:10:56Z",
        "body": "I'm reopening this issue because my problem might still come from a combineLatest bug\n\nFinding it in my app is quite tricky and I wrongly thought that it might come from an equal test.\n\nApparently, if I use Observable.combineLatests(observable1, observable2) it fails\nbut if I switch the observables Observable.combineLatests(observable2, observable1), it succeeds.\n\nSo, I'm thinking that It might be a timing issue or a bug in combineLatest.\nI haven't much time to code but I'll invstiguate further and try to write a minimal test showing the bug\n"
      },
      {
        "user": "Lakedaemon",
        "created_at": "2016-08-22T17:37:57Z",
        "body": "I'm still observing nasty issues with combineLatest. \n\nI'm wondering if the problem lies with the way it requests items from my 2 observables\n\nWhen my issue appears : one observable emits like crazy (like 290 items on a io thread) and the other observable (an Observable.just(int) on the current thread) waits and emit when the other observable is finished. Then, the combineLatest emits it's first item  when it should have emitted like 290 items instead\n\nsadly, the combineLatest code is really complicated and I would be at a loss to check if this really happens But I'm pretty sure that the issue lies with combineLatest\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-22T17:47:22Z",
        "body": "CombineLatest prefetches 128 elements from each source. If your source is synchronous, that means it will run through it and you'll get its very last item only. You rarely want to combine with synchronous sources due to this property. Don't you need `zip` instead?\n"
      },
      {
        "user": "Lakedaemon",
        "created_at": "2016-08-22T20:12:01Z",
        "body": "I have my issue with an Observable.just(cursor) (that I'll replace with a PublishSubject<Int>.startWith(cursor) once things work out and an asynchronous Observable<Collector> that emits 290 times (on the novel where the issue appears) after each page it collects.\n\nwith logs in 3 places (2 inside map after the 2 observables and 1 in the combining function), I observed that the asynchronous observable was emitting 290 items and the other observable was somehow waiting till it was finished to emit it's single item and then the combination function was called once.\n\nzip wouldn't work because I'm spliting a novel into 291 pages, but as it is quite long (20s), I also emit the position where the reader is reading and if pagination has already done that page, it can return it immediately.\n\nthe publishSubject is used in case the reader swipes to the next/previous page or if he jumps to a completely different page. That way, I can split pages in the background but serve him page immediately (if he jumps at the end, I just paginate 1 page from his chosen position while paginating continues from start...)\n"
      },
      {
        "user": "Lakedaemon",
        "created_at": "2016-08-23T13:56:01Z",
        "body": "I finally found what was wrong. There is no issue with combineLatest (as expected).\n\nI was using subscribeOn() in a foolish attempt to make some observable run either on the UI thread or on a Schedulers.io() thread... and this had those surprising result (related to locks ? races ? contention ?). \nI guess that it prevented the subscription of Observable.just() till the other observable was finished which surprised me\n\nMy observable created through Observable.create() was fine (but now that I understand things better, I should probably use SyncOnSubscribe inside). \n\nNow, to make a custom observable source work on Schedulers.io(), I'm using \n\nObservable.just(Unit).observeOn(Schedulers.io()).flatMap(myObservable)\n\nIt is certainly overkill (and a waste) to use a flatMap to make my observable work on another thread, but it's the first and only solution I found at the moment.\n\nMy conclusions : subscribeOn(), when misused, can introduce some very nasty issues, very hard to debug. Now, I know.\n\nMany thanks for your kind answers and your awesome contributions to RxJava, you rock ! \n"
      }
    ]
  },
  {
    "number": 4374,
    "title": "how to resolve this problem for \"Caused by java.util.ConcurrentModificationException\"",
    "created_at": "2016-08-19T08:32:53Z",
    "closed_at": "2016-08-19T09:49:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4374",
    "body": "Fatal Exception: java.lang.ExceptionInInitializerError\n       at com.trello.rxlifecycle.components.support.RxAppCompatActivity.(RxAppCompatActivity.java)\n       at java.lang.Class.newInstanceImpl(Class.java)\n       at java.lang.Class.newInstance(Class.java:1208)\n       at android.app.Instrumentation.newActivity(Instrumentation.java:1061)\n       at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2114)\n       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2248)\n       at android.app.ActivityThread.access$800(ActivityThread.java:136)\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1197)\n       at android.os.Handler.dispatchMessage(Handler.java:102)\n       at android.os.Looper.loop(Looper.java:136)\n       at android.app.ActivityThread.main(ActivityThread.java:5020)\n       at java.lang.reflect.Method.invokeNative(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java:515)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)\n       at dalvik.system.NativeStart.main(NativeStart.java)\nCaused by java.util.ConcurrentModificationException\n       at java.util.Hashtable$HashIterator.nextEntry(Hashtable.java:727)\n       at java.util.Hashtable$EntryIterator.next(Hashtable.java:778)\n       at java.util.Hashtable$EntryIterator.next(Hashtable.java:776)\n       at rx.plugins.RxJavaPlugins.getPluginImplementationViaProperty(RxJavaPlugins.java:177)\n       at rx.plugins.RxJavaPlugins.getObservableExecutionHook(RxJavaPlugins.java:130)\n       at rx.Observable.(Observable.java)\n       at com.trello.rxlifecycle.components.support.RxAppCompatActivity.(RxAppCompatActivity.java)\n       at java.lang.Class.newInstanceImpl(Class.java)\n       at java.lang.Class.newInstance(Class.java:1208)\n       at android.app.Instrumentation.newActivity(Instrumentation.java:1061)\n       at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2114)\n       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2248)\n       at android.app.ActivityThread.access$800(ActivityThread.java:136)\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1197)\n       at android.os.Handler.dispatchMessage(Handler.java:102)\n       at android.os.Looper.loop(Looper.java:136)\n       at android.app.ActivityThread.main(ActivityThread.java:5020)\n       at java.lang.reflect.Method.invokeNative(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java:515)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)\n       at dalvik.system.NativeStart.main(NativeStart.java)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4374/comments",
    "author": "maoai-xianyu",
    "comments": [
      {
        "user": "artem-zinnatullin",
        "created_at": "2016-08-19T08:41:49Z",
        "body": "This is problem in RxLifecycle and not in RxJava, please file a bug there and close it here :)\n\n> at com.trello.rxlifecycle.components.support.RxAppCompatActivity.(RxAppCompatActivity.java)\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-19T08:43:17Z",
        "body": "There are other libraries that modify the System properties concurrently. We tried to remedy this in an RxJava version so please make sure you use an up to date version (1.1.9 as of now).\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2016-08-19T08:50:30Z",
        "body": "Ah right, it's system property modification while iterating, then it should be fixed in RxJava 1.1.3\n"
      },
      {
        "user": "maoai-xianyu",
        "created_at": "2016-08-19T09:38:30Z",
        "body": "what? Fix this problem use for 1.1.9 version or  1.1.3 version? Please confirm.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-19T09:41:10Z",
        "body": "Always use the latest version, 1.1.9 currently.\n"
      },
      {
        "user": "maoai-xianyu",
        "created_at": "2016-08-19T09:47:47Z",
        "body": "OK. Thanks. I try it. Hope it is OK.\n"
      }
    ]
  },
  {
    "number": 4362,
    "title": "ReplaySubject and Filter, bug or feature?",
    "created_at": "2016-08-17T18:04:59Z",
    "closed_at": "2016-09-08T10:48:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4362",
    "body": "Hi, \nI have two subsribers for one ReplaySubject. \nSubscriber1 filters emited objects for type 1   -- replaySubject.filter(1).subscribe()\nSubscriber2 filters emited objects for type 2  -- replaySubject.filter(2).subscribe()\n\nI emit from my ReplaySubject objects of types 1,1,1,1,2 (one on click)\nSubscriber1 gets 1,1,1,1\nthen on the next click\nSubscriber2 gets 2 and (!INTERSTING!) Subscriber1 gets 1,1,1,1 again.\n\nLooks like there are some logic of ReplaySubject based on if onNext was called (on not called in case of filtering) and force ReplaySubject to reemit the objects \nI can provide simplified code if needed\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4362/comments",
    "author": "Cher80",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-17T19:28:00Z",
        "body": "A small code example would be great.\n"
      },
      {
        "user": "micdm",
        "created_at": "2016-08-22T07:29:51Z",
        "body": "I think I caught a similar bug prior to #4051. @Cher80 what version of RxJava do you use?\n"
      },
      {
        "user": "ncanibano",
        "created_at": "2016-08-25T23:39:05Z",
        "body": "We found out a similar strange behavior in our app with ReplaySubject and filter duplicating items.\nYou can reproduce it with this code snippet:\n\n```\nobject RxTest {\n\n  def main(args: Array[String]): Unit = {\n    val subject = ReplaySubject[Int]()\n\n    val result = subject\n      .filter(_ > 0)\n\n    result.subscribe(chunk ⇒ println(chunk))\n\n    subject.onNext(1)\n    subject.onNext(2)\n    subject.onNext(0)\n    subject.onNext(3)\n    subject.onNext(0)\n    subject.onNext(6)\n  }\n\n}\n```\n\nWe are using RxJava v1.1.6 and RxScala v0.26.2.\nThis is the expected behavior or do you think is there an issue here?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-26T06:48:46Z",
        "body": "This test passes with 1.1.10 snapshot:\n\n``` java\n    @Test\n    public void filtered() {\n        ReplaySubject<Integer> subject = ReplaySubject.create();\n\n        TestSubscriber<Integer> ts1 = TestSubscriber.create();\n        TestSubscriber<Integer> ts2 = TestSubscriber.create();\n\n        Observable<Integer> o = subject.filter(new Func1<Integer, Boolean>() {\n            @Override\n            public Boolean call(Integer v) {\n                return v > 0;\n            }\n        });\n\n        o.subscribe(ts1);\n        o.subscribe(ts2);\n\n        subject.onNext(1);\n        subject.onNext(2);\n        subject.onNext(0);\n        subject.onNext(3);\n        subject.onNext(0);\n        subject.onNext(6);\n\n        ts1.assertValues(1, 2, 3, 6);\n        ts2.assertValues(1, 2, 3, 6);\n\n        subject.onNext(0);\n        subject.onNext(7);\n\n        ts1.assertValues(1, 2, 3, 6, 7);\n        ts2.assertValues(1, 2, 3, 6, 7);\n    }\n```\n"
      },
      {
        "user": "ncanibano",
        "created_at": "2016-08-26T12:49:06Z",
        "body": "The same test fails in 1.1.6 with this error:\n\njava.lang.AssertionError: Number of items does not match. Provided: 4  Actual: 6.\nProvided values: [1, 2, 3, 6]\nActual values: [1, 2, 2, 3, 3, 6](0 completions)\n\n```\nat rx.observers.TestObserver.assertionError(TestObserver.java:197)\nat rx.observers.TestObserver.assertReceivedOnNext(TestObserver.java:116)\nat rx.observers.TestSubscriber.assertReceivedOnNext(TestSubscriber.java:274)\nat rx.observers.TestSubscriber.assertValues(TestSubscriber.java:529)\n```\n\nCould you please confirm that this was an unknown issue in previous versions? Since which stable version is this error fixed? Thanks!\n"
      },
      {
        "user": "ncanibano",
        "created_at": "2016-08-26T13:06:38Z",
        "body": "It seems this issue was fixed in 1.1.7 thanks to #4051 \nBut we don't know where it was first introduced.\nThanks\n"
      },
      {
        "user": "ncanibano",
        "created_at": "2016-08-26T19:30:46Z",
        "body": "It seems that it was recently introduced in version 1.1.6 due to an optimization.\nVersions previous to 1.1.6 are working just fine as far as we know.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-08T10:48:11Z",
        "body": "Yes, there was a bad optimization added in 1.1.6 which has been resolved in the next release. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4306,
    "title": "2.x: Unused exceptions in public API",
    "created_at": "2016-08-07T21:56:59Z",
    "closed_at": "2016-08-09T04:54:58Z",
    "labels": [
      "Question",
      "Cleanup"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4306",
    "body": "Currently there's a few exceptions which are unused that are in the public API:\n- `OnCompleteFailedException`\n- `OnErrorFailedException`\n- `OnErrorNotImplementedException`\n- `UnsubscribeFailedException`\n\nThere are tests which use these for various reasons, but the primary cause of lack of use is that subscribers cannot throw according to the Reactive Streams specification.\n\nThis is just a tracking issue for doing something about that or removing them before 2.0.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4306/comments",
    "author": "JakeWharton",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-07T22:05:37Z",
        "body": "Yes, they are there mostly to satisfy some tests that are mostly ignored by the way. Certainly we can't throw them  so they can be removed. If you remove them from tests, please keep the test method with `@Ignored` so they don't show up as missing for the test-sync I'm doing.\n"
      }
    ]
  },
  {
    "number": 4280,
    "title": "2.x: Exceptions is in internal package",
    "created_at": "2016-08-04T02:59:06Z",
    "closed_at": "2016-08-07T22:03:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4280",
    "body": "...despite its tests being in the public API package.\n\nIt's hard to write libraries without `Exceptions.throwIfFatal`. Should this be in the public API?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4280/comments",
    "author": "JakeWharton",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-04T06:45:36Z",
        "body": "Possibly, what should happen with the rest of the methods?\n\nIf you'd review #4278 that would allow the refactoring to happen without interference.\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-08-05T23:25:28Z",
        "body": "I would think they'd split, although having two classes of the same name would obviously be less than ideal. Maybe it could be hoisted onto RxJavaPlugins since its often used with calling `RxJavaPlugins.onError`? There could even be a combination method that does both, since there's a few hundred uses of the pair throughout RxJava's codebase as-is.\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-08-07T22:03:26Z",
        "body": "This can be closed! 🎉 \n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-08-07T22:03:36Z",
        "body": "Oh wait it's my issue, I can do that!\n"
      }
    ]
  },
  {
    "number": 4277,
    "title": "1.x: Feature Request Observable.firstOrDefaultSingle",
    "created_at": "2016-08-03T12:27:36Z",
    "closed_at": "2016-08-06T21:05:24Z",
    "labels": [
      "Question",
      "Feature-Request"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4277",
    "body": "How do you guys feel about an overload that is named something along the lines of `Observable.firstOrDefaultSingle` and basically does the same as `Observable.firstOrDefault` with the difference of returning a `Single<T>` instead of `Observable<T>`?\n\nEdit: Could also maybe be called `firstOrDefaultAsSingle`\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4277/comments",
    "author": "vanniktech",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-03T13:21:22Z",
        "body": "What's wrong with `firstOrDefault().toSingle()` ?\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-08-03T13:36:27Z",
        "body": "Or `switchIfEmpty().toSingle()` for async defaults.\n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-08-03T14:01:33Z",
        "body": "Nothing is wrong with that, I'm right now using `firstOrDefault().toSingle()`.\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-08-03T14:35:50Z",
        "body": "I don't like that it conflates two concepts: taking the empty stream and ensuring it's non-empty but also transforming the type from Observable to Single.\n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-08-06T21:05:24Z",
        "body": "Closing since if this type of suggestion would be approved (basically transforming Observable in any way into one that only emits one item and then converts itself into Single a lot of other operators would need to get the `asSingle` matching method e.g. first(), `last()`, `lastOrDefault()` for consistency\n"
      }
    ]
  },
  {
    "number": 4274,
    "title": "RetryWhen not working",
    "created_at": "2016-08-02T20:04:56Z",
    "closed_at": "2016-08-03T16:12:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4274",
    "body": "I want to retry my request if user clicks on the retry Button. I create a PublishSubject, and I am doing as follow:\n\n```\nthis.subscription = paginationObservable.flatMap(i -> {\n            this.lastPage = i;\n            return this.provider.getMovies(this.sortOrder, i);\n        }).doOnError(throwable -> setHasError(true))\n                .retryWhen(o -> o.flatMap(t -> retryButtonSubject))\n                .subscribe(movies1 -> {\n                    this.movies.addAll(movies1);\n                });\n```\n\nWhen use click's the retry button the subject emit an item, but the request is not executed again:\n\n```\npublic void clickRetryButton() {\n    this.retryButtonSubject.onNext(null);\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4274/comments",
    "author": "guitcastro",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-03T07:11:26Z",
        "body": "This works for me:\n\n``` java\nObservable<Integer> paginationObservable = Observable.range(1, 3);\n\nPublishSubject<Integer> retryButtonSubject = PublishSubject.create();\n\nboolean[] once = { false };\n\npaginationObservable.flatMap(i -> {\n    if (once[0]) {\n        return Observable.range(1, 2);\n    }\n    once[0] = true;\n    return Observable.error(new IOException());\n})\n.doOnError(Throwable::printStackTrace)\n        .retryWhen(o -> o.flatMap(t -> retryButtonSubject))\n        .subscribe(movies1 -> {\n            System.out.println(movies1);\n});\n\nretryButtonSubject.onNext(null);\n```\n"
      }
    ]
  },
  {
    "number": 4271,
    "title": "1.x: Should TestSubscriber.assertValues() check that subscription has happened?",
    "created_at": "2016-08-02T11:10:52Z",
    "closed_at": "2016-09-08T10:56:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4271",
    "body": "Found false positive test in our codebase where we were checking `TestSubscriber.assertNoValues()` but it was not subscribed at that point and test passed though it shouldn't…\n\nShould we fail-fast in that case and throw `AssertionError` if subscriber was not subscribed before call to `assertNoValues()`?\n\nBasically:\n\n``` java\nclass TestSubscriber extends Subscriber {\n\n  private int startCounter = 0;\n\n  @Override public void onStart() {\n    startCounter++;\n  }\n\n  public void assertNoValues() {\n    if (startCounter == 0) {\n      throw new AssertionError(\"TestSubscriber was not subscribed before!\");\n    }\n  }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4271/comments",
    "author": "artem-zinnatullin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-02T11:17:29Z",
        "body": "Adding a `startCounter` is okay but I'm not convinced the existing assert values should be changed but rather add `assertStarted()`. Also you should call `fail` so it prints the status info and add `assertBackpressure()` to verify `setProducer` was called too.\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2016-08-02T12:22:11Z",
        "body": "Ok, mostly sounds good to me, except that original problem of `assertNoValues()` won't be solved without adding `assertStarted()` which is not great because basically I don't see cases when you'll need `assertNoValues()` without `assertStarted()`. Maybe reconsider?\n\nOther than that I can take this one to implement.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-02T12:26:41Z",
        "body": "What's the underlying issue? Are you forgetting to subscribe in your tests? Do you test operators that don't respond often that the asserts don't give you proper feedback?\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2016-08-02T13:17:19Z",
        "body": "Something like this:\n\n``` java\nObservable<Data> stream = streamUnderTest();\nTestSubscriber<Data> subscriber = new TestSubscriber<>();\n\n// Forgot to subscribe it.\n\n@Test\npublic void streamShouldHasNoDefaultValue() {\n  subscriber.assertNoValues();\n}\n```\n\nAnd when I came to add more tests for this stream of data I've found that subscriber was never subscribed and existing test was false positive. I understand that it's rare case because usually you will have other tests that will use same pair of stream and subscriber and fail without subscription, but anyway seems that `assertNoValues()` should always implicitly include `assertStarted()`.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-08T10:56:41Z",
        "body": "I don't think such programmer errors should be addressed by RxJava. Next time, you forget to call any assert methods and get a false positive, then you want RxJava to assert by just creating TestSubscriber or something - sorry if I put it so bluntly.\n"
      }
    ]
  },
  {
    "number": 4247,
    "title": "Question about SyncOnSubscribe / SubscriptionProducer",
    "created_at": "2016-07-27T15:31:51Z",
    "closed_at": "2016-07-28T07:46:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4247",
    "body": "Was diving into those two guys and noticed that in the `SubscriptionProducer#onNext` `actualSubscriber.onNext(value);` is called without checking `isUnsubscribed`. Is this wanted behavior and if so could you explain why?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4247/comments",
    "author": "vanniktech",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-27T15:46:07Z",
        "body": "There is a `tryUnsubscribe` after an iteration. \n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-07-28T07:46:15Z",
        "body": "Alright thanks a lot 👍 \n"
      }
    ]
  },
  {
    "number": 4227,
    "title": "Is it suitable for multi  io task of large file transfermation? ",
    "created_at": "2016-07-22T14:11:24Z",
    "closed_at": "2016-08-24T09:58:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4227",
    "body": "",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4227/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-22T16:41:08Z",
        "body": "Could you share some more detail about your use case? RxJava by itself doesn't do any disk or network IO.\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-07-23T02:56:08Z",
        "body": "My case is tranferring  multi files between two filesystem through network ,so I need a effiective task sheduler and io processing solution to make it work pretty.\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-07-23T02:57:43Z",
        "body": "Are there some  good suggestions for me? \n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-24T09:58:37Z",
        "body": "You should look at Spring 5.0, they have extensive reactive support over the network. Maybe you can send over bytes reactively.\n\nI'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4223,
    "title": "RxJavaErrorHandler handleError() method if can return a Throwable",
    "created_at": "2016-07-21T09:21:19Z",
    "closed_at": "2016-08-24T09:58:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4223",
    "body": "like this:\ne = RxJavaPlugins.getInstance().getErrorHandler().handleError(e)\nbecause sometimes i need a new exception when i use  RxJavaErrorHandler to control my exception\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4223/comments",
    "author": "duzechao",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-21T09:29:19Z",
        "body": "That call is a last resort when the original exception can't be delivered by other means (or you are in the `SafeSubscriber.onError`). You should consider remapping via `onErrorResumeNext(e -> Observable.error(other))`.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-24T09:58:57Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4218,
    "title": "complicated flow by using rxjava .",
    "created_at": "2016-07-20T10:09:11Z",
    "closed_at": "2016-07-21T07:40:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4218",
    "body": "for example:\n\n> List<Group> \n> Group ---> List<Child>\n> compose:\n>  List<Pair<Group,List<Child>>>\n\n   java implement should be like this:\n\n> ```\n>   List<Pair<Group,List<Child>>>  group_childs = new xxx;\n>    List<Group>  group = findGroups();\n>     for( group  ){\n>            group= list.get()\n>            List<Child> childs = findChilds(group);\n>           group_childs .add(group,childs)\n>    }`\n> ```\n\n  so , how to implement it by using rxjava? \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4218/comments",
    "author": "pinkApple",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-20T10:30:51Z",
        "body": "It depends on which of the sources you want reactive: `findGroups()` and/or `findChilds()`?\n\n1) None\nYou don't need RxJava and can go with plain looping.\n\n2) `findGroups()` is an `Observable<Group>`\n\n``` java\nfindGroups().map(g -> Pair.of(g, findChilds(g))).toList()...\n```\n\n3) `findChilds` is `Observable<Child>`\n\n``` java\nObservable.from(findGroups()).concatMap(g -> findChilds(g).toList().map(u -> Pair.of(g, u)))...\n```\n\n4) Both\n\n``` java\nfindGroups().concatMap(g -> findChilds(g).toList().map(u -> Pair.of(g, u)))...\n```\n"
      },
      {
        "user": "pinkApple",
        "created_at": "2016-07-20T11:04:33Z",
        "body": "@akarnokd \nboth findgroups and findchilds are db operation, \nsince rxjava can do background tasks as well,\nso i try them by async way. \nbut this logic may be too hard for newer;\nanyway, thank u;\n"
      },
      {
        "user": "pinkApple",
        "created_at": "2016-07-21T07:38:31Z",
        "body": "```\n    findGroups()\n            .flatMap(Observable::from)\n            .flatMap(\n                    g -> findChilds(g).map((List<Child> children)\n                            -> Pair.create(g, children)))\n            .toList()\n            .subscribe(pairs -> {\n                // adapter set List<Pair<Group, List<Child>>>\n            });\n```\n\ni implement it!  nice. \n"
      },
      {
        "user": "daschl",
        "created_at": "2016-07-21T12:21:03Z",
        "body": "@pinkApple in your case you probably want to use `forEach` instead of `subscribe`. On the other hand its considered bad practice to not implement an error handler on the subscriber like in your case, you'd just get an OnErrorNotImplementedException\n"
      },
      {
        "user": "pinkApple",
        "created_at": "2016-07-21T12:58:04Z",
        "body": "@daschl  yeah,  you are right.\n                forEach can do it as well.  i'm using rxjava just to test the data flow..\n                onError , onComplete do not implement in code.\n                 normally , i should use a subscriber.\n"
      }
    ]
  },
  {
    "number": 4214,
    "title": "BehaviorSubject that emits last item even after completion",
    "created_at": "2016-07-19T12:37:21Z",
    "closed_at": "2016-07-19T13:12:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4214",
    "body": "I'm looking for the following functionality: \n1. A subject that initially works like a BehaviorSubject. If I `create` it with no initial value, any subscribers will wait for the first value before `onNext` is called.\n2. Similarly, if `create` is called with an initial value, then any subscribers will be invoked with `onNext` immediately upon subscription, and after that whenever `onNext` is called on the subject.\n3. Upon calling `onComplete` on the subject, it effectively turns into a ReplySubject with the last emitted event and the completion event. As in, any subscriber that subscribes to the subject after `onComplete` is invoked will immediately be invoked with `onNext(lastItem)` followed by `onComplete()`.\n4. If `onComplete()` is called on the subject before an initial/first item is set/emitted, an error is thrown.\n\nDo something like this exist in RxJava? Cause I couldn't find it, and had to create it on my own. And if not, shouldn't this be a thing? It's sort of a computation that emits intermediate values, until when it's done, after that point it only emits the end-result again and again.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4214/comments",
    "author": "Alxandr",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-19T12:45:02Z",
        "body": "You can compose this from existing behavior.\n\n``` java\nReplaySubject.<T>create(1)\n.switchIfEmpty(Observable.<T>error(new IllegalStateException(\"Subject is empty\")));\n```\n"
      },
      {
        "user": "Alxandr",
        "created_at": "2016-07-19T13:12:57Z",
        "body": "Great. This seems to be working. I don't really like the `switchIfEmpty` solution, cause it does not actually throw on `onComplete()` call, but rather emits an error through the observable, but I can deal with that.\n"
      }
    ]
  },
  {
    "number": 4205,
    "title": "Option for Subscription to add self to CompositeSubscription",
    "created_at": "2016-07-15T12:25:50Z",
    "closed_at": "2016-07-16T08:58:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4205",
    "body": "Hey, when managing multiple subscriptions I am a little bit frustrated with a confused code the `CompositeSubscription` causes.\nIn following example you can see that the Observable itself is a little bit hidden.\n\n```\nCompositeSubscription compositeSubscription = new CompositeSubscription();\ncompositeSubscription.add(Observable.just(\"test\")\n    .subscribe(new Subscriber<String>() {\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(String s) {\n\n            }\n        }));\n```\n\nIt would be great to have something convinient. For example something as simple as one method in Subscriber\n\n```\n    public void addTo(@NonNull CompositeSubscription compositeSubscription) {\n        compositeSubscription.add(this);\n    } \n```\n\nThis way the previous example would change into:\n\n```\nCompositeSubscription compositeSubscription = new CompositeSubscription();\nObservable.just(\"test\")\n   .subscribe(new Subscriber<String>() {\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(String s) {\n\n            }\n        })\n   .addTo(compositeSubscription);\n```\n\nI am more than happy to make a pull request for such a thing.\n\nThanks.\nbakua\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4205/comments",
    "author": "bakua",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-15T13:03:07Z",
        "body": "I'm sorry but no. `Subscription` is a deliberately minimal interface with one objective: unsubscribe a potential chain of resources. Since we are **Java 6, no default methods are allowed** (besides, it would lead to cyclic dependency between the two), plus **we have to maintain binary compatibility** and changing `Subscription` into an abstract class would break it.\n\nWhy not have a static method somewhere which you import statically what does the boilerplate for you:\n\n``` java\npublic static <T> void subscribeForMe(\n        Observable<T> source, Subscriber<? super T> subscriber, \n        CompositeSubscription container) {\n    container.add(source.subscribe(subscriber));\n}\n\nCompositeSubscription compositeSubscription = new CompositeSubscription();\n\nsubscribeForMe(Observable.just(\"test\"), new Subscriber<String>() {\n            @Override public void onCompleted() { }\n\n            @Override public void onError(Throwable e) { }\n\n            @Override public void onNext(String s) {  }\n        }, \n    compositeSubscription);\n```\n"
      },
      {
        "user": "bakua",
        "created_at": "2016-07-15T13:23:34Z",
        "body": "Hi, sorry I've expressed myself incorrectly. My intention was not to extend Subscription interface, but rather to add method to Subscriber implementation.\n\nThere already is a method in Subscriber that does:\n\n```\npublic final void add(Subscription s) {\n    subscriptions.add(s);\n}\n```\n\nI'd love to have a 2nd one that works the way around:\n\n```\npublic final void addTo(Subscription s) {\n    s.add(this);\n}\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-15T13:33:53Z",
        "body": "That would still require the changing of `Subscription` thus my comment still stands.\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-07-15T14:13:45Z",
        "body": "This was also already suggested in #2919.\n"
      },
      {
        "user": "bakua",
        "created_at": "2016-07-16T05:37:03Z",
        "body": "I see, thanks. I took an inspiration from RxSwift where such an option exists.\n\n```\nObservable<Int>.interval(1.0, scheduler: MainScheduler.instance)     \n    .map({num in num * 10})\n    .subscribeNext({num in print(num)})\n    .addDisposableTo(disposeBag)\n```\n\nBut if it is not possible to have it in RxJava, feel free to close this issue.\n"
      }
    ]
  },
  {
    "number": 4202,
    "title": "Question about takeUntil and Subscription.unsubscribe()",
    "created_at": "2016-07-14T09:17:49Z",
    "closed_at": "2016-08-16T08:38:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4202",
    "body": "in android ,if I use takeUntil for any network and on activity destroy, I use PublishSubject.onNext(null), the relation is gone; if I use CompositeSubscription.add() for any network and on activity destroy, I use CompositeSubscription.unsubscribe(), the relation is gone. what is different ?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4202/comments",
    "author": "caoguodong",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-14T10:10:07Z",
        "body": "I'm sorry, I can't understand what you are asking. Could you post some example code?\n"
      },
      {
        "user": "alexandru-calinoiu",
        "created_at": "2016-07-14T11:02:41Z",
        "body": "You will have better luck with this type of questions on stackoverflow, the editing system there allows other people to help out with the actual question.\n\nJust use the rxjava tag.\n"
      },
      {
        "user": "caoguodong",
        "created_at": "2016-07-15T02:19:39Z",
        "body": "@akarnokd \nI'm sorry about my english, and I give some code in android.\n\n``` java\nPublishSubject<Void> detachSignal = PublishSubject.create();\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Observable<Object> observable = Observable.create(new Observable.OnSubscribe<Object>() {\n            @Override\n            public void call(Subscriber<? super Object> subscriber) {\n                System.out.print(\"this is a network\");\n            }\n        });\n\n        observable.takeUntil(detachSignal)\n                .subscribe(new Action1<Object>() {\n                    @Override\n                    public void call(Object o) {\n\n                    }\n                });\n\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        detachSignal.onNext(null);\n    }\n```\n\n``` java\nprivate CompositeSubscription mSubscription;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        mSubscription.add(Observable.create(new Observable.OnSubscribe<Object>() {\n            @Override\n            public void call(Subscriber<? super Object> subscriber) {\n                System.out.print(\"this is a network\");\n            }\n        }).subscribe(new Action1<Object>() {\n            @Override\n            public void call(Object o) {\n\n            }\n        }));\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        mSubscription.unsubscribe();\n    }\n```\n\nwhat is different for destroy the relation between Observer and  the Observered\n"
      },
      {
        "user": "caoguodong",
        "created_at": "2016-07-15T02:20:41Z",
        "body": "@alexandru-calinoiu \nthank you for you notice\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-15T07:07:14Z",
        "body": "They should be functionally identical if there is only a single consumer.\n"
      },
      {
        "user": "caoguodong",
        "created_at": "2016-07-18T02:30:37Z",
        "body": "@akarnokd thank you for your answer and if there are several consumer ， have any different？\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-18T06:51:47Z",
        "body": "The `detach` is shared between all of them so if you signal with it, all the other consumers and any future consumers will be completed.\n"
      },
      {
        "user": "caoguodong",
        "created_at": "2016-07-19T02:38:53Z",
        "body": "@akarnokd thank you so much, I got it.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-16T08:38:52Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4197,
    "title": "Question about Observable.using's resourceFactory & disposeAction",
    "created_at": "2016-07-13T13:04:54Z",
    "closed_at": "2016-08-16T08:39:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4197",
    "body": "I have a resource which I want to release upon unsubscribing of the Observable, and release action must be run on the same thread which I created the resource.\n\nSo I found `Observable.using` and assumed that resourceFactory & disposeAction will run on a same thread which I specified with `subscribeOn`.\n\nAt first it seems working as I expected, but I realized that sometimes disposeAction runs on different thread than I specified with `subscribeOn`\n\n``` java\npublic class UsingResourceSample {\n    public static void main(String[] args) throws InterruptedException {\n    for (int i = 0; i < 10; i++) {\n      Observable.using(() -> {\n            String factoryThread = \"Getting @\" + Thread.currentThread().toString();\n            System.out.println(factoryThread);\n            return factoryThread;\n          },\n          Observable::just,\n          (factoryThread) -> System.out.println(\"Closing @\" + Thread.currentThread().toString() + \", \" + factoryThread))\n          .subscribeOn(Schedulers.io())\n          .subscribe()\n          .unsubscribe();\n    }\n  }\n}\n```\n\nIf I run this code multiple times, most of the time it shows `Closing @ThreadA, Getting @ThreadA`, but sometimes it shows `Closing @ThreadB, Getting @ThreadA`.\n\nSo, here are questions:\n1. is this behavior intentional?\n2. is there any way to run resourceFactory & disposeAction to run on the same thread which I specified with `subscribeOn`?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4197/comments",
    "author": "yshrsmz",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-13T13:11:13Z",
        "body": "Hi.\n\n1) Yes. The operator doesn't deal with scheduling.\n2) Not with `subscribeOn`; try `unsubscribeOn` but you need a single-threaded `Scheduler` as all the default ones will give you different threads most likely.\n"
      },
      {
        "user": "yshrsmz",
        "created_at": "2016-07-14T02:38:02Z",
        "body": "thank you for the clarification!\nwill try single-thread approach, but I'm wondering if it becomes performance overhead.\nThough it may not suit the design of RxJava, it would be great if there is a method for setting both subcribeOn/unsubscribeOn as same thread at once\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-14T06:54:25Z",
        "body": "Once upon a time our `subscribeOn` did unsubscribe on the same thread but it was split into `unsubscribeOn`; I can't remember why. @zsxwing  ?\n"
      },
      {
        "user": "yshrsmz",
        "created_at": "2016-07-15T11:07:51Z",
        "body": "ok, I created this simple single-threaded scheduler pool.\nhope this works well\n\n``` java\npublic class SingleThreadSchedulerPool {\n    private final static AtomicLong COUNT = new AtomicLong(0L);\n    private final static List<Scheduler> SCHEDULERS = new ArrayList<>(){{\n        add(Schedulers.from(Executors.newSingleThreadExecutor(new RxThreadFactory(\"SingleThreadScheduler-1-\"))));\n        add(Schedulers.from(Executors.newSingleThreadExecutor(new RxThreadFactory(\"SingleThreadScheduler-2-\"))));\n        add(Schedulers.from(Executors.newSingleThreadExecutor(new RxThreadFactory(\"SingleThreadScheduler-3-\"))));\n    }};\n\n    private SingleThreadSchedulerPool() {\n        // no-op\n    }\n\n    public static Scheduler get() {\n        long current = COUNT.getAndIncrement();\n        return SCHEDULERS.get((int) (current % 3));\n    }\n}\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-16T08:39:33Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4164,
    "title": "Method for shutdown CachedObservable",
    "created_at": "2016-07-05T07:41:57Z",
    "closed_at": "2016-07-05T08:34:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4164",
    "body": "I have endless stream (which is not called onComplete at all). And I cache last value in it:\n\n```\nObservable<T> endlessStream = createStream().cache();\n\nSubscription s1 = endlessStream.subscribe(...)\nSubscription s2 = endlessStream.subscribe(...)\n```\n\nBy some condition endlessStream become not valid and I replace it (with switchMap, but it's not important).\n\n```\ns1.unsubscribe()\ns2.unsubscribe()\n```\n\nBut CachedObservable will always store connection to source stream (returned from createStream()). This leads to memory leak. How to disconnect CachedObservable from source observable?\n\nMore information:\n\nCachedObservable contains field state, which contain SerialSubscription to source observables (connection). If I call next hack, everything becomes OK:\n\n```\nprivate void disconnectCachedObservable(CachedObservable<T> observable) {\n    try {\n        Field fieldState = CachedObservable.class.getDeclaredField(\"state\");\n        fieldState.setAccessible(true);\n        Object state = fieldState.get(observable);\n        Field fieldConnection = state.getClass().getDeclaredField(\"connection\");\n        fieldConnection.setAccessible(true);\n        SerialSubscription subscription = (SerialSubscription) fieldConnection.get(state);\n        subscription.unsubscribe();\n    } catch (NoSuchFieldException e) {\n        e.printStackTrace();\n    } catch (IllegalAccessException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nBut reflection isn't good solution:(\n\nMaybe create public method it?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4164/comments",
    "author": "HotIceCream",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-05T08:19:59Z",
        "body": "You can use \n\n``` java\nreplay().autoConnect(1, toStop -> { /* store Subscription to cancel later */ });\n```\n\nwhich let's you stop the upstream by giving you a `Subscription`.\n"
      },
      {
        "user": "HotIceCream",
        "created_at": "2016-07-05T08:34:39Z",
        "body": "Oh yes. It's help. Thank you!\nI tried replay + autoConnect, but didn't know about second argument in autoConnect.\n"
      }
    ]
  },
  {
    "number": 4161,
    "title": "triggerActions doesn't work w/o advanceTimeBy",
    "created_at": "2016-07-04T13:27:57Z",
    "closed_at": "2016-08-10T16:43:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4161",
    "body": "So I have unit test:\n\n```\n @Test\n    public void interestingTest() {\n        TestSubscriber subscriber = new TestSubscriber();\n\n        List<Item> defaultList = new ArrayList<>();\n        Observable.concat(\n                memory.getItems(0, 20, item -> true),\n                disk.getItems(0, 20)\n                        .filter(items -> items != null && !items.isEmpty())\n                        .observeOn(uiScheduler),\n                cloud.getItems(TEST_USER_ID, 0, 20)\n                        .filter(items -> items != null && !items.isEmpty())\n                        .subscribeOn(ioScheduler)\n                        .observeOn(uiScheduler)\n        )\n                .firstOrDefault(defaultList, items -> items != null && !items.isEmpty())\n                .subscribe(subscriber);\n\n        uiScheduler.advanceTimeBy(0, TimeUnit.NANOSECONDS);\n        ioScheduler.triggerActions();\n        uiScheduler.triggerActions();\n\n        assertTrue(subscriber.getOnNextEvents().get(0) == defaultList);\n    }\n```\n\nmemory/disk/cloud are all mocked to return  Observable.just(new ArrayList<>())) so there is no any domain specific code.\n\nIt will work if I call `uiScheduler.advanceTimeBy(0, TimeUnit.NANOSECONDS)` even if I advance time with 0 {any timeunit}, but if I skip this line - testSubscriber won't get any items and test will fail. What's the reason of this behavior?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4161/comments",
    "author": "zoopolitic",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-05T07:02:13Z",
        "body": "I can't run your test because the missing references, but the following code works for me:\n\n``` java\npublic class Issue4161 {\n    @Test\n    public void interestingTest() {\n        AtomicInteger counter = new AtomicInteger();\n\n        TestScheduler test = Schedulers.test();\n\n        Worker w = test.createWorker();\n\n        try {\n\n            w.schedule(() -> counter.incrementAndGet());\n            w.schedule(() -> counter.incrementAndGet());\n\n            test.triggerActions();\n        } finally {\n            w.unsubscribe();\n        }\n\n        Assert.assertEquals(2, counter.get());\n    }\n}\n```\n"
      },
      {
        "user": "zoopolitic",
        "created_at": "2016-07-05T07:09:52Z",
        "body": "cloud/disk/memory just interfaces for abstraction that returns `Observable<T>`. As I said they are mocked so there is no any specific logic for returning data. The point is in: \n\n```\n.subscribeOn(ioScheduler)\n.observeOn(uiScheduler)\n```\n\nso request executes on different threads. If I'll remove schedulers switch test pass successfully, so the problem is in scheduling/triggering\n"
      },
      {
        "user": "zoopolitic",
        "created_at": "2016-07-05T07:18:46Z",
        "body": "@akarnokd Here is the full test that you can just copy paste:\n\n```\npublic class ATest {\n\n    private interface Gateway {\n\n        Observable<List<Item>> getItems();\n    }\n\n    private static class Item {\n\n        private final int id;\n\n        private Item(int id) {\n            this.id = id;\n        }\n    }\n\n    @Mock private Gateway memory;\n    @Mock private Gateway disk;\n    @Mock private Gateway cloud;\n\n    private TestScheduler ioScheduler;\n    private TestScheduler uiScheduler;\n\n    @Before public void setUp() {\n        MockitoAnnotations.initMocks(this);\n\n        ioScheduler = Schedulers.test();\n        uiScheduler = Schedulers.test();\n    }\n\n    @Test\n    public void interestingTest() {\n        TestSubscriber subscriber = new TestSubscriber();\n\n        when(memory.getItems()).thenReturn(Observable.just(new ArrayList<>()));\n        when(disk.getItems()).thenReturn(Observable.just(new ArrayList<>()));\n        when(cloud.getItems()).thenReturn(Observable.just(new ArrayList<>()));\n\n        List<Item> defaultList = new ArrayList<>();\n        Observable.concat(\n                memory.getItems(),\n                disk.getItems()\n                        .filter(items -> items != null && !items.isEmpty())\n                        .observeOn(uiScheduler),\n                cloud.getItems()\n                        .filter(items -> items != null && !items.isEmpty())\n                        .subscribeOn(ioScheduler)\n                        .observeOn(uiScheduler)\n        )\n                .firstOrDefault(defaultList, items -> items != null && !items.isEmpty())\n                .subscribe(subscriber);\n\n        uiScheduler.advanceTimeBy(0, TimeUnit.NANOSECONDS); // comment this and test will fail\n        ioScheduler.triggerActions();\n        uiScheduler.triggerActions();\n\n        assertTrue(subscriber.getOnNextEvents().get(0) == defaultList);\n    }\n}\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-05T08:37:15Z",
        "body": "What happens is that the uiScheduler schedules actions on ioScheduler which schedules actions on the uiScheduler again. If you remove the advanceTimeBy, the order changes to io->ui but then the io scheduler is not triggering the ui further on. If you add\n\n``` java\n\nuiScheduler.triggerActions(); // <--- add this\nioScheduler.triggerActions();\nuiScheduler.triggerActions();\n```\n\nor\n\n``` java\n\nioScheduler.triggerActions();\nuiScheduler.triggerActions();\nioScheduler.triggerActions();  // <-- add these again\nuiScheduler.triggerActions();\n```\n\nThe test passes again.\n"
      },
      {
        "user": "zoopolitic",
        "created_at": "2016-07-05T08:48:56Z",
        "body": "My mistake, schedulers in my case shares same instance, so for test I can use one TestScheduler passing it all around and trigger actions, right ? Or I'm misunderstand something?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-05T08:50:33Z",
        "body": "Yes.\n"
      },
      {
        "user": "zoopolitic",
        "created_at": "2016-07-05T09:12:43Z",
        "body": "Can you please describe a little bit more ? I've tested again and see that `ioScheduler` and `uiScheduler` does not share same instance. They are different and `Schedulers.test()` produces new instance with its own queue every call. So why  \n\n> uiScheduler schedules actions on ioScheduler which schedules actions on the uiScheduler again\n\n? Thanks.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-05T09:19:41Z",
        "body": "In your original test, they are independent schedulers and the test setup cross-scheduled activities. You have to trigger actions in both one after another until there are no more actions in either instance. If you call `test()` and assign its value to `ioScheduler` and `uiScheduler` there is no cross-scheduling `triggerActions` will exhaustively execute all pending tasks.\n"
      },
      {
        "user": "zoopolitic",
        "created_at": "2016-07-05T09:39:38Z",
        "body": "> You have to trigger actions in both one after another until there are no more actions in either instance\n\nIn original test I call `subscribeOn(ioScheduler).observeOn(uiScheduler)`. Schedulers are independent, you're right, but when I call triggerAction on ioScheduler - it should execute all pending tasks, same with uiScheduler, the question is why we need to call it more than 1 time on each scheduler. I think I misunderstand something in schedulers concept, because I don't understand why on 2 different schedulers we should call `triggerActions()` more than once\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-12T09:03:39Z",
        "body": "Two test schedulers have two distinct queues. A task running on one will add tasks to the other's queue but the `triggerAction` is confined to its own queue. Therefore, if there is a ping-pong between the schedulers, you have to repeatedly call `triggerAction` on both.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-10T16:43:06Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      },
      {
        "user": "yoelglus",
        "created_at": "2016-09-03T16:37:56Z",
        "body": "So it seems that if you remove the:\n`uiScheduler.advanceTimeBy(0, TimeUnit.NANOSECONDS);`\nand just reverse the order so:\n\n```\nuiScheduler.triggerActions();\nioScheduler.triggerActions();\n```\n\nit works.\n"
      }
    ]
  },
  {
    "number": 4159,
    "title": "1.x Subscriber receives value after unsubscription",
    "created_at": "2016-07-01T22:44:06Z",
    "closed_at": "2016-07-02T15:50:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4159",
    "body": "Is it expected that this test case fails?\n\nOr the OnSubscribe is incomplete with this design (missing explicit `isUnsubscribed()` check)?\n\n```\n@Test\npublic void testAfterUnsubscribeNoValue() throws InterruptedException {\n    TestSubscriber<String> ts = new TestSubscriber<>();\n    AtomicBoolean unsubscribed = new AtomicBoolean();\n    CountDownLatch latch = new CountDownLatch(2);\n\n    Observable<String> s1 = Observable.create(s -> {\n\n        Thread t = new Thread(() -> {\n            try {\n                Thread.sleep(1000);\n                s.onNext(\"should not be displayed\");\n                latch.countDown();\n            } catch (InterruptedException ignored) {\n            }\n        });\n\n        s.add(Subscriptions.create(() -> {\n            unsubscribed.set(true);\n            latch.countDown();\n        }));\n        t.start();\n    });\n\n    Subscription subscription = s1.subscribe(ts);\n    subscription.unsubscribe();\n\n    if (latch.await(2000, TimeUnit.MILLISECONDS)) {\n        ts.assertNoValues();\n        assertTrue(unsubscribed.get());\n        assertTrue(subscription.isUnsubscribed());\n    } else {\n        fail(\"timed out waiting for latch\");\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4159/comments",
    "author": "Diolor",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-02T09:18:49Z",
        "body": "When you use `create` _you_ have to ensure the `Observable` contracts are honored. Not sure what you wanted to achieve originally, but you can do it via standard operators:\n\n``` java\nObservable.just(1)\n.delay(1, TimeUnit.SECONDS, Schedulers.newThread())\n.map(v -> \"should not be displayed\")\n.subscribe(ts);\n```\n\nOtherwise yes, you should call `isUnsubscribed` before `onNext`ing.\n"
      },
      {
        "user": "Diolor",
        "created_at": "2016-07-02T15:53:43Z",
        "body": "I was interested when we are creating our own OnSubscribe subclasses for more complex observables, if we should care about the `isUnsubscribed` or not. Thanks for clarifying!\n"
      }
    ]
  },
  {
    "number": 4155,
    "title": "Operator Single.repeatWhen",
    "created_at": "2016-07-01T06:40:05Z",
    "closed_at": "2016-08-02T07:36:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4155",
    "body": "You can always use `Single.toObservable().repeatWhen()` to get a repeating `Single`, but I recently faced the situation that I needed the emitted success value inside the repetition logic, which obviously cannot be provided by `Observable.repeatWhen()`. So I was wondering if it would make sense to have some operator `Observable<T> repeatWhen(final Func1<? super Observable<T>, ? extends Observable<?>> notificationHandler)` in `Single` that behaves like its `Observable` counterpart, but emitting the success values instead of `void` items to the notification handler.\n\nDoes this make any sense?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4155/comments",
    "author": "twz123",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-20T11:55:19Z",
        "body": "You can achieve this effect with some deferring and state capture:\n\n``` java\nSingle.defer(() -> {\n    AtomicReference<T> successValue = new AtomicReference<>();\n    source.doOnSuccess(v -> successValue.lazySet(v))\n        .repeatWhen(o -> o.takeWhile(e -> checkRepeatIf(successValue.get())))\n});\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-02T07:36:01Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4104,
    "title": "Replay misbehaves, may not emit items until completion when observable is blocking (temporarily)",
    "created_at": "2016-06-24T15:26:17Z",
    "closed_at": "2016-07-29T08:10:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4104",
    "body": "The following test case replicates the issue.\n`publish` seems ok.\n\n``` java\nimport org.junit.Assert;\nimport org.junit.Test;\nimport rx.Observable;\nimport rx.observables.ConnectableObservable;\nimport rx.schedulers.Schedulers;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\n/**\n * Created by masc on 24/06/16.\n */\npublic class RxJavaReplayTest {\n    @Test\n    public void testDelayedSubscriptionWithBlockingObservable() throws InterruptedException {\n        // Time/delay for each item being emitted\n        int delay = 200;\n        // Number of observables\n        int count = 10;\n        // Number of items emitted\n        AtomicInteger emitCount = new AtomicInteger(0);\n\n        Stream<Observable<Integer>> ovStream = IntStream.range(0, count)\n                .mapToObj(i -> Observable.create(s -> {\n                    try {\n                        Thread.sleep(delay);\n                        int item = emitCount.incrementAndGet();\n                        System.out.println(String.format(\"Emitting [%d]\", item));\n                        s.onNext(item);\n                        s.onCompleted();\n                    } catch (Throwable e) {\n                        s.onError(e);\n                    }}));\n\n        List<Observable<Integer>> ovList = ovStream.collect(Collectors.toList());\n\n        ConnectableObservable<Integer> cov = Observable.merge(ovList)\n                .subscribeOn(Schedulers.newThread())\n                .replay();\n\n        // Cook it up\n        cov.connect();\n\n        // Wait until ~half the items have been emitted\n        Thread.sleep(delay * count / 2);\n\n        cov.subscribe(i -> {\n            Assert.assertFalse(\"Blocking until the party is over.\",\n                    i < count && emitCount.get() == count);\n            System.out.println(String.format(\"Observed [%d]\", i));\n        });\n\n        cov.toCompletable().await();\n        System.out.println(\"Done\");\n    }\n}\n```\n\nThe c# implementation of `replay` works as expected.\n\n``` csharp\nusing NUnit.Framework;\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Reactive.Linq;\nusing System.Reactive.Concurrency;\nusing System.Reactive.PlatformServices;\n\nnamespace RxTest\n{\n    [TestFixture()]\n    public class RxReplayTest\n    {\n        [Test()]\n        public void TestDelayedSubscriptionWithBlockingObservable()\n        {\n            // Time/delay for each item being emitted\n            var delay = 200;\n            // Number of observables\n            var count = 10;\n            // Number of items emitted\n            int emitCount = 0;              \n\n            // List of observables each emitting an item\n            var ovList = Enumerable.Range(1, count).Select(i => {\n                return Observable.Create<int>(s => {\n                    Thread.Sleep(delay);\n                    emitCount++;\n                    s.OnNext(emitCount);\n                    s.OnCompleted();\n                    return () => {};\n                });\n            }).ToList();\n\n            var cov = Observable\n                .Merge(ovList)\n                .SubscribeOn(NewThreadScheduler.Default)\n                .Replay();\n\n            // Cook it up\n            cov.Connect();\n\n            // Wait until ~half the items have been emitted\n            Thread.Sleep(delay * count / 2);\n\n            cov.Subscribe(i => {\n                var lEmitCount = emitCount;\n                // If previous items are observed even though all items have already been emitted, that's a fail\n                Assert.False(i < count && lEmitCount == count, \"Blocking until the party is over.\");\n                Console.WriteLine($\"Observed [{i}]\");\n            });\n\n            cov.Wait();\n            Console.WriteLine(\"Done\");\n        }\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4104/comments",
    "author": "masc3d",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-06-24T15:48:08Z",
        "body": "Our `replay` doesn't request until there is an actual child subscriber that requests something. The main reason is that unlike Rx.NET, we don't inject concurrency for you (Range goes async in Rx.NET) and a pre-started synchronous `replay()` may prevent progress on the thread that calls `connect()`. This is enabled by our advanced flow control architecture (i.e., backpressure) which is not available in Rx.NET.\n"
      },
      {
        "user": "masc3d",
        "created_at": "2016-06-24T16:05:17Z",
        "body": "I have used `Enumerable.Range` for convenience here, it doesn't affect the result of the test case. Updated the c# code, flattening the range.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-24T16:27:46Z",
        "body": "Right, I see now. Then its only my first sentence applies to this case: our replay doesn't request until there is an actual child subscriber that requests something.\n\nIf I add `cov.subscribe()` just after `cov.connect()`, your test passes.\n"
      },
      {
        "user": "masc3d",
        "created_at": "2016-06-24T16:36:04Z",
        "body": "yes, that's exactly the problem actually. Also when replacing the merged `Observable` with a single one emitting items over time the test passes, which is quite confusing and inconsistent from a consumer point of view.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-24T16:55:42Z",
        "body": "The problem with the \"immediately live\" consumption of any source is that it may lead to memory overflow, especially with a synchronous source. The current behavior is more lazy and does work only if something is actually observing the sequence.\n"
      },
      {
        "user": "masc3d",
        "created_at": "2016-06-24T16:55:54Z",
        "body": "There's an subscription actually, it's just delayed. \nSo to clarify, if all of those criteria are met:\n- Observables are merged\n- Observables perform a blocking operation\n- Subscription is delayed\n\nthe subscriber will not see any items until completion. \n"
      },
      {
        "user": "masc3d",
        "created_at": "2016-06-24T17:14:44Z",
        "body": "Btw I used `Thread.Sleep` to keep the code more concise, it's actually sufficient to return the `Observable` from a method for this to happen.\nThen you will see the issue even when \"immediately\" subscribing to it.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-24T17:17:58Z",
        "body": "Okay, I know what's happening now. When you subscribe to the merged sources, the background thread gets blocked by their sleep. When the subscriber subscribes, its request() will get scheduled behind their task (which is blocked) so until they run to completion, the child appears to be not requesting anything and will only receive the values once all sleeping is over. Unfortunately, blocking and backpressure doesn't play well together and usually results in such same-pool deadlock or drastic delays.\n"
      },
      {
        "user": "masc3d",
        "created_at": "2016-06-24T17:20:46Z",
        "body": "I found it also quite curious that it doesn't happen when using a single `Observable` instead of the merged one.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-24T17:42:07Z",
        "body": "If you have such blocking create() source, the best action is to apply `subscribeOn` on them directly and not on the merged stream.\n"
      },
      {
        "user": "masc3d",
        "created_at": "2016-06-24T18:05:24Z",
        "body": "Yes, there's quite a few workarounds for this, it's not what worries me. It's rather that this kind of behaviour will introduce subtle bugs which are hard to trace as soon as implementations are not specifically tailored to play well with a feature that's not even used. If the backpressure code has such implications and cannot be improved in this respect (can it?), wouldn't it be better to bypass it when it's not needed?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-24T18:21:18Z",
        "body": "We detached ourselves from the Rx.NET roots in many ways, mostly by introducing backpressure. We won't go back to a non-backpressured world with 1.x. However, 2.x does have backpressured (Flowable) and non-backpressured (Observable) types defined so there will be a choice.\n"
      },
      {
        "user": "masc3d",
        "created_at": "2016-06-24T18:30:44Z",
        "body": "That's good to know, thank you. I wasn't suggesting to drop backpressure support entirely, but to either improve it and/or bypass it selectively for the replay overloads which actually don't use it, which isn't a downgrade at all. It may even improve performance.\n"
      },
      {
        "user": "masc3d",
        "created_at": "2016-06-24T19:31:59Z",
        "body": "> If you have such blocking create() source, the best action is to apply subscribeOn on them directly and not on the merged stream.\n\nI tried to apply this, but yields the same result for the test case. I really wonder why the behavioural difference between a single and a merged `Observable` here alone wouldn't qualify as a defect?\n\nEdit: forgot to remove `subscribeOn` from the merged one. But it implies that every potentially blocking observable requires to implement this, in case it may be used with `replay` at some point down the chain.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-29T08:10:13Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4017,
    "title": "1.X: Why is CompletableSubscriber not a Subscription?",
    "created_at": "2016-06-17T12:21:44Z",
    "closed_at": "2016-06-21T21:23:04Z",
    "labels": [
      "Question",
      "Feature-Request"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4017",
    "body": "I see that `CompletableSubscriber` is not a `Subscription`, but `Subcription` is. So, when I use `Completable#subscribe(CompletableSubscriber)`, I cannot then unsubscribe if I want to.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4017/comments",
    "author": "bryant1410",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-06-17T12:45:23Z",
        "body": "`CompletableSubscriber` was designed along the Reactive-Streams pattern where cancellation support is injected via `onSubscribe` call. Consumers extending `CompletableSubscriber` then can decide individually if they want to expose this cancellation support to the outside world by implementing `Subscription` themselves. In contrast, `Subscriber` can never revoke its ability to be unsubscribed externally.\n\nIf you are using `subscribe()` or the lambda versions of `subscribe`, you get a `Subscription` back. As for the `subscribe(CompletableSubscriber)`, indeed we don't have a supporting class for it (as far as I remember). I'll post a PR for it today.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-21T21:23:04Z",
        "body": "Closing via #4020.\n"
      }
    ]
  },
  {
    "number": 4003,
    "title": "RxJavaPlugins.getInstance()",
    "created_at": "2016-06-12T16:55:25Z",
    "closed_at": "2016-06-17T18:35:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4003",
    "body": "Hello, \n\nI am trying to create a custom ErrorHandler for RxJava and while trying to get the RxJavaPlugins instance to register the ErrorHandler, it does not seem to be giving me access to the `.getInstance()`\npublic static method.\n\nI checked the RxJavaPlugins class and saw that `.getInstance()` is actually public. I can not understand though why I can not access it. \n\nI am using RxJava 1.1.5.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4003/comments",
    "author": "pavlospt",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-06-12T17:52:32Z",
        "body": "What IDE are you using? Is the JRE/JDK properly setup in your project? What is the actual error message when you write `RxJavaPlugins.getInstance()`?\n"
      },
      {
        "user": "pavlospt",
        "created_at": "2016-06-12T18:07:10Z",
        "body": "I am using Android Studio. JRE and JDK are correctly setup for the project. There is no error message actually. It just does not seem to have an available method called .getInstance(). \n"
      },
      {
        "user": "egor-n",
        "created_at": "2016-06-12T18:55:54Z",
        "body": "Are you sure your import points to `rx.plugins.RxJavaPlugins`?\n"
      },
      {
        "user": "pavlospt",
        "created_at": "2016-06-12T19:04:22Z",
        "body": "@egor-n Yes, that was my first check. \n"
      },
      {
        "user": "pavlospt",
        "created_at": "2016-06-17T18:35:06Z",
        "body": "Actually it was an IDE problem. Could not pinpoint exactly what was causing it. I am closing the issue per se. \n"
      }
    ]
  },
  {
    "number": 3999,
    "title": "Fail to build on 1.x branch",
    "created_at": "2016-06-07T19:44:39Z",
    "closed_at": "2016-06-22T13:42:34Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3999",
    "body": "Hi, learnt that 1.x is recent stable build I just checked whole branch out try to build, and it failed me epiclly, kept throw me\n\nMissing header in: src\\main\\java\\rx\\annotations\\Beta.java\nMissing header in: src\\main\\java\\rx\\annotations\\Experimental.java\nUnknown file extension: src\\main\\java\\rx\\internal\\operators\\README.md\nMissing header in: src\\main\\java\\rx\\internal\\util\\atomic\\AtomicReferenceArrayQueue.java\nMissing header in: src\\main\\java\\rx\\internal\\util\\atomic\\BaseLinkedAtomicQueue.java\nMissing header in: src\\main\\java\\rx\\internal\\util\\atomic\\SpscAtomicArrayQueue.java\nMissing header in: src\\main\\java\\rx\\internal\\util\\atomic\\SpscExactAtomicArrayQueue.java\nMissing header in: src\\main\\java\\rx\\internal\\util\\atomic\\SpscLinkedAtomicQueue.java\nMissing header in: src\\main\\java\\rx\\internal\\util\\atomic\\LinkedQueueNode.java\n\n \"Error occurred during initialization of VM\nCould not reserve enough space for 2097152KB object heap\nCould not write standard input into: Gradle Test Executor 1.\njava.io.IOException: The pipe is being closed\"\n\nError occurred during initialization of VM\nCould not reserve enough space for 2097152KB object heap\nCould not write standard input into: Gradle Test Executor 86.\njava.io.IOException: The pipe is being closed\n\nand few missing head of source file errors, and finally:\n\nFAILURE: Build failed with an exception.\n- What went wrong:\n  Execution failed for task ':test'.\n  > Process 'Gradle Test Executor 1' finished with non-zero exit value 1\n\nDid i miss anything or could it be attributed to my java 8? sad!\"\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3999/comments",
    "author": "saintor",
    "comments": [
      {
        "user": "artem-zinnatullin",
        "created_at": "2016-06-07T19:49:40Z",
        "body": "Looks like build tries to allocate 2gb of memory but your machine doesn't have enough.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-07T20:02:43Z",
        "body": "You need 2GB memory and a 64-bit JVM to run the tests.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-22T13:42:34Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      },
      {
        "user": "saintor",
        "created_at": "2016-06-23T13:30:14Z",
        "body": "Sure, just being inquisitive, how does it differ with Netty consider they are all event driven system \n\nThanx\n\nSent from Samsung Mobile\n\n<div>-------- Original message --------</div><div>From: David Karnok notifications@github.com </div><div>Date:2016/06/22  21:43  (GMT+08:00) </div><div>To: ReactiveX/RxJava RxJava@noreply.github.com </div><div>Cc: saintor 13916109686@163.com, Author author@noreply.github.com </div><div>Subject: Re: [ReactiveX/RxJava] Fail to build on 1.x branch (#3999) </div><div>\n</div>I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n\n—\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n"
      }
    ]
  },
  {
    "number": 3992,
    "title": "SyncOnSubscribe + FlatMap + SubscribeOn ",
    "created_at": "2016-06-06T09:19:09Z",
    "closed_at": "2016-06-30T14:42:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3992",
    "body": "using 'io.reactivex:rxjava:1.1.5'\n\nThe below JUnit test currently fails, it only processes up to the maxConcurrentWorkers calls before blocking indefinitely. This appears to be a combination of the SyncOnSubscribe.next call blocking (or returning without calling onNext), the flatMap being called before the subscribeOn, and the second flapMap taking a \"MaxConcurrent\" parameter.\n\nIf I move the commented subscribeOn statement to before the flatMap, then the test passes as expected.\n\nIf I remove the maxConcurrent parameter, the test passes as expected (though doesn't throttle the number of concurrent workers).\n\nIf I call onComplete instead of blocking from in the SyncOnSubscribe implementation then the test passes as expected.\n\nIs this a bug relating to flapMap / SyncOnSubscribe, or, am I implementing SyncOnSubscribe incorrectly? I tried this with an AsyncOnSubscribe implementation and had the same problem.\n\n``` Java\npublic class Tests {\n\n  class TestSyncSubscription extends SyncOnSubscribe<Integer, Integer> {\n\n      private int startValue;\n\n      public TestSyncSubscription(int startValue) {\n          this.startValue = startValue;\n      }\n\n      @Override\n      protected Integer generateState() {\n          return this.startValue;\n      }\n\n      @Override\n      protected Integer next(Integer state, Observer<? super Integer> observer) {\n          try {\n              if (state > 0) {\n                  observer.onNext(state);\n                  return --state;\n              } else {\n                  // Mimic a blocking operation.\n                  Thread.currentThread().suspend();\n                  return state;\n              }\n          } catch (Exception e) {\n              observer.onError(e);\n              return state;\n          }\n\n      }\n  }\n\n  @Test\n  public void flapMapBreaksFutureConcurrentFlapMap() throws InterruptedException { \n\n      final int numberOfItems = 20;\n      final int maxConcurrentWorkers = 5;\n      final int maxMsPerItem = 1000;\n      final int minMsPerItem = 0;\n\n      final int secondsToWaitForCompletion = 1 + (((numberOfItems / maxConcurrentWorkers) * maxMsPerItem) / 1000);\n      final Scheduler concurrentOperationsScheduler = Schedulers.io();\n      final Scheduler sourceScheduler = Schedulers.newThread();\n\n      Random rand = new Random();\n      CountDownLatch latch = new CountDownLatch(numberOfItems);\n\n      Observable<Integer> source = Observable\n              .create(new TestSyncSubscription(numberOfItems))\n              // putting subscribeOn here (before the flapMap), the test passes.\n              .flatMap(i -> Observable.just(i))\n              .subscribeOn(sourceScheduler); // because this subcribeOn is after flatMap the test fails.;\n\n      Subscription subscription =\n              source.flatMap(\n                      (path) -> Observable\n                      .just(path)\n                      .subscribeOn(concurrentOperationsScheduler)\n                      .map(\n                              i ->\n                              {\n                                  try {\n                                      Thread.sleep(minMsPerItem + rand.nextInt(maxMsPerItem - minMsPerItem));\n                                      latch.countDown();\n                                  } catch (Exception e) {\n                                      throw new RuntimeException(e);\n                                  }\n\n                                  return i;\n                              }),\n                      maxConcurrentWorkers)\n              .subscribe();\n\n      try {\n          latch.await(secondsToWaitForCompletion, TimeUnit.SECONDS);\n          long numberOfItemsProcessed = numberOfItems - latch.getCount();\n          assertEquals(String.format(\"All emitted items were not processed (%s of %s processed)\", numberOfItemsProcessed, numberOfItems), 20L, numberOfItemsProcessed);\n      } finally {\n          subscription.unsubscribe();\n      }\n  }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3992/comments",
    "author": "BEllis",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-06-06T10:46:22Z",
        "body": "Backpressure and blocking doesn't play nice together. It only works in the order: `subscribeOn` and then the blocking operation. Otherwise, you are blocking the handling of `request` calls, which are scheduled behind the blocking operation and thus never get to trigger emission.\n"
      },
      {
        "user": "BEllis",
        "created_at": "2016-06-06T17:18:19Z",
        "body": "So is there no other way do this while waiting for a blocking operation to complete? I tried just returning instead of suspending, but it still gets stuck until I call onComplete or onError.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-17T18:41:29Z",
        "body": "Sleeping by itself in the generator and map does work, but wait/notify style wakeup doesn't. Not sure what you tried to achieve, but I'd done something like this:\n\n``` java\nObservable.range(1, 20)\n.subscribeOn(io)\n.map(v -> getMaybeBlocking(v))\n.flatMap(v -> Observable.fromCallable(() -> process(v)).subscribeOn(scheduler), 5)\n.toBlocking()\n.subscribe(...)\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-30T14:42:28Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 3983,
    "title": "doOnSubscribe & doOnTerminate prevents invocation of producer function when using Observable.create",
    "created_at": "2016-06-02T14:06:03Z",
    "closed_at": "2016-06-09T11:23:17Z",
    "labels": [
      "Question",
      "Android"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3983",
    "body": "I am making an api call reactive with wrapping an async operation into Observable.create to make the result consumable as subscription. Also i want to automatically show an Android progressDialog when an subscriber subscribes and the api call gets invoked and dismiss it again when the call terminates (whether with error or successful)\n\n``` kotlin\nval producer = object : Observable.OnSubscribe<Result> {\n    var apiCancellation: ApiCancellation? = null\n\n    var progressDialog: ProgressDialog? = null\n\n    override fun call(t: Subscriber<in Result>) {\n        apiCancellation = api.call(operation) { result ->\n            if (result.isFailure) {\n                 t.onError(result.failure.exception())\n            }\n            else {\n                t.onNext(result.response)\n                t.onCompleted()\n            }\n        }\n    }\n}\n\nreturn Observable.create(producer)\n    .doOnSubscribe { producer.progressDialog = ProgressDialog.show(context, null, context.getString(R.string.msg_sending_invitation), true, false) }\n    .doOnTerminate { producer.progressDialog?.dismiss() }\n```\n\nhowever if i subscribe to returned observable the producer will never get invoked.\nif i remove the _doOnSubscribe_ and _doOnTerminate_ callbacks it'll work fine\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3983/comments",
    "author": "martyglaubitz",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-06-02T14:43:48Z",
        "body": "Maybe `doOnSubscribe` crashes if it is not invoked on the Android mainThread? Same for `doOnTerminate`?\n"
      },
      {
        "user": "martyglaubitz",
        "created_at": "2016-06-09T11:23:17Z",
        "body": "Ok, turns out i used the wrong context to create the progressdialog in which case the call just silently dies\n"
      }
    ]
  },
  {
    "number": 3976,
    "title": "Only part of chain executed after exception",
    "created_at": "2016-05-31T17:30:20Z",
    "closed_at": "2016-06-05T09:49:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3976",
    "body": "Hi. Rx java is pretty new to me and I have one problem that I can't understand. After exception only part of my operator chain is executed for next objects and I don't know why. \nI have kafka consumer that polls server for messages and then turns them in infinitie observable:\n\n<!-- language: lang-java-->\n\n```\npublic Observable<Event> consume() {\n    return Observable.create(subscriber -> {\n        try {\n            consumer.subscribe(Arrays.asList(topic));\n\n            while (running) {\n                ConsumerRecords<String, Event> records = consumer.poll(pollTimeout);\n                for (TopicPartition partition : records.partitions()) {\n                    for (ConsumerRecord<String, Event> record : records.records(partition)) {\n                        Event event= record.value();\n                        subscriber.onNext(event);\n\n                        long offfset = record.offset() + 1;\n                        consumer.commitSync(Collections.singletonMap(partition, new OffsetAndMetadata(offfset)));\n                        LOGGER.info(\"Comitted offset \"+offfset);\n                    }\n                }\n            }\n            subscriber.onCompleted();\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception thrown during events consuming\", ex);\n            subscriber.onError(ex);\n        }\n    });\n}\n```\n\nAnd here is my problem:\n\n```\n    public Observable<ProcessDoneEvent> doSth(Event event) {\n    String vin = event.getVin();\n    return vehicleStateRepository.getState(vin)\n            .filter(state -> shouldProcess(state, event))\n            .flatMap((State state) -> {\n                return backendService.getVehicle(vin)\n                        .map(this::getCarLicense)\n                        .flatMap((CarLicense carLicense) -> api.apiAction(carLicense)\n                                .map((ActionConfirmation confirmation) -> {\n                                    log(carLicense, confirmation, event);\n                                    return confirmation;\n                                })\n                                .flatMap((ActionConfirmation t) -> {\n                                    return vehicleStateRepository.saveState(vin, State.IDLE)\n                                            .map((String sth) -> createProcessDoneEvent(vin));\n                                }));\n            });\n}\n```\n\nIn normal situation all operators are executed, state is fetched from db, api is called and finally vehicle state is saved in db. And this is working fine for any amount of events.\n\nNow lets consider situation that timeout occurred in backendService.getVehicle(vin). Exception is handled in retry operator and we are ready for next events. And now what happens - for next events, only lines above api.apiAction(carLicense)(including) are executed and lines below are skipped. So result is that: vehicle state is fetched, api is called and then control returns to loop in message consumer so it's committing new offset without saving vehicle state to db and logging it. \n\nWhy is this happening? :(\n\nAlso here is code with subscription:\n\n```\n    public void startConsuming() {\n\n    consumer.consume() <- code in first posted snipplet\n            .flatMap(this::doAction)\n            .retry((count, e) -> {\n                LOGGER.error(\"aaaaaaaa\", e);\n                return true;\n            }).subscribe(subscriber);\n}\n\nprivate Observable<ProcessDoneEvent> doAction(Event event) {\n    if (Event.getEventType().equals(EventType.TYPE_ONE)) {\n        return process.doSth(event); <- this is method posted above\n    } else {\n        return process.doSthOther(event);\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3976/comments",
    "author": "slawomirbiernacki",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-31T20:12:29Z",
        "body": "For one, you didn't implement unsubscription in your `create`d `Observable` properly. You should check `subscriber.isUnsubscribed()` and quit the method if `true`. Second, many operators have either variants or parameters that allow delaying errors to the end, they should allow you to finish up with good values before failing/retrying.\n"
      },
      {
        "user": "slawomirbiernacki",
        "created_at": "2016-06-02T15:04:28Z",
        "body": "I changed my consumer loop to exit when subscriber.isUnsubscribed() and it looks like it was it! I will make further tests, please don't close issue yet but thank you very very much for now.\n"
      },
      {
        "user": "slawomirbiernacki",
        "created_at": "2016-06-05T09:49:03Z",
        "body": "ok everything is ok now. Thank you one more time.\n"
      }
    ]
  },
  {
    "number": 3973,
    "title": "Custom Terminal Operators",
    "created_at": "2016-05-31T13:31:32Z",
    "closed_at": "2016-05-31T16:34:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3973",
    "body": "I'd like to propose the addition of a generic terminal operation method on `rx.Observable` that would accept an implementation of a terminal operator interface and returns any generic type:\n\n``` java\nCompletionStage<Integer> stage = rx.Observable.just(1, 2, 3)\n    .map(value -> value * 2)\n    .max()\n    .terminate(TerminalOperators.toCompletionStage());\n```\n\nThe existing aggregate and collection operators are great, but they all currently produce `rx.Observable`.  In our project we mostly make use of Java 8 `CompletionStage<T>` as well as some assorted `Future<T>` implementations from other libraries.  We have static helper methods to convert from `rx.Observable` to `CompletionStage<T>` already, but it breaks the fluent API.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3973/comments",
    "author": "HaloFour",
    "comments": [
      {
        "user": "HaloFour",
        "created_at": "2016-05-31T14:07:39Z",
        "body": "Actually, it looks like the experimental method `rx.Observable#extend` will meet my needs.  I'll take a look at it and if it does I will close this issue.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-31T14:08:07Z",
        "body": "Yes, we have the `extend` operator (experimental) where you get an `OnSubscribe` value and can return whatever you want:\n\n`public <R> R extend(Func1<? super OnSubscribe<T>, ? extends R> conversion)`\n\nIts downside is that you get only an `OnSubscribe` on which you have to call `call(Subscriber<? super T>)` to get things running.\n"
      },
      {
        "user": "HaloFour",
        "created_at": "2016-05-31T14:34:02Z",
        "body": "@akarnokd\n\nYes, that does seem like a bit of a limitation.  In my case since I'm transforming the observable into a future-like I want to ensure that the observable emits exactly one result.  In my static helper method I use the `single()` function to ensure this.  It seems that with `extend` I'd be required to effectively reimplement the subscriber from `OperatorSingle`.  It might be nice to have an overload of `extend` that can accept a different interface capable of transforming the sequence before subscribing.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-31T15:25:35Z",
        "body": "@HaloFour. When the `extend` operator was introduced, I argued for using `Observable` but I was unable to convince the author. You don't need to reimplement all but use `Observable.create` to re-wrap the source:\n\n``` java\nObservable.just(1).extend(os -> Observable.create(os).toBlocking().first());\n```\n"
      },
      {
        "user": "HaloFour",
        "created_at": "2016-05-31T16:34:30Z",
        "body": "@akarnokd Ah, not too bad then:\n\n``` java\npublic static <T> Func1<? super Observable.OnSubscribe<T>, ? extends CompletionStage<T>> toCompletionStage() {\n    return onSubscribe -> {\n        CompletableFuture<T> future = new CompletableFuture<>();\n        Observable.create(onSubscribe)\n                .single()\n                .subscribe(future::complete, future::completeExceptionally);\n        return future;\n    };\n}\n\n// later\n\nObservable<Foo> observable = observeFoo();\nCompletionStage<Foo> stage = observable.extend(toCompletionStage());\n```\n"
      }
    ]
  },
  {
    "number": 3967,
    "title": "error when Zipping 2 publish subjects asynchroneously",
    "created_at": "2016-05-26T09:16:52Z",
    "closed_at": "2016-05-26T09:57:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3967",
    "body": "Hi,\n\nI'm having some weird problem I've tried to simplify.\n\nTake for instance the following code:\n\n``` java\n        for (int i = 0; i < 500; i++) {\n            Subject<Integer, Integer> s1 = PublishSubject.<Integer> create().toSerialized();\n            Subject<Integer, Integer> s2 = PublishSubject.<Integer> create().toSerialized();\n\n            Observable.zip(s1.single(), s2.toList(), (a, b) -> null)\n                .subscribeOn(Schedulers.io())\n                .subscribe(\n                    j -> {},\n                    t -> {\n                        t.printStackTrace();\n                    });\n\n            s1.onNext(1);\n            s2.onNext(1);\n            s1.onCompleted();\n            s2.onCompleted();\n        }\n        Thread.sleep(5000);\n```\n\nI'm often getting the following error:\n\n```\njava.util.NoSuchElementException: Sequence contains no elements\n    at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:131)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)\n    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.accept(SubjectSubscriptionManager.java:318)\n    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.emitLoop(SubjectSubscriptionManager.java:291)\n    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.emitFirst(SubjectSubscriptionManager.java:270)\n    at rx.subjects.PublishSubject$1.call(PublishSubject.java:66)\n    at rx.subjects.PublishSubject$1.call(PublishSubject.java:62)\n    at rx.subjects.SubjectSubscriptionManager.add(SubjectSubscriptionManager.java:95)\n    at rx.subjects.SubjectSubscriptionManager.call(SubjectSubscriptionManager.java:60)\n    at rx.subjects.SubjectSubscriptionManager.call(SubjectSubscriptionManager.java:35)\n    at rx.Observable.unsafeSubscribe(Observable.java:8172)\n    at rx.subjects.SerializedSubject$1.call(SerializedSubject.java:45)\n    at rx.subjects.SerializedSubject$1.call(SerializedSubject.java:41)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8172)\n    at rx.internal.operators.OperatorZip$Zip.start(OperatorZip.java:209)\n    at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:156)\n    at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:122)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8172)\n    at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n```\n\nI'm not sure what's going wrong here. It would seem that from time to time, the `s1` subject receives the onCompleted before the onNext.\n\nI saw that removing `.subscribeOn(Schedulers.io())` fixes this but I'd like to understand why.\nDepending on that I could come up with an other solution to what i'm trying to do.\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3967/comments",
    "author": "Crystark",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-26T09:25:37Z",
        "body": "Because you subscribe on a different thread, the two subjects don't have any subscriber yet when you call onXXX on them, dropping the values. Once zip can subscribe, both may end up being completed and thus the first source will signal the `NoSuchElementException`. \n"
      },
      {
        "user": "Crystark",
        "created_at": "2016-05-26T09:50:25Z",
        "body": "Indeed, I can see it now. Thanks for the explanation.\nSo if I understand this well, using a `ReplaySubject` seems to be the way to go if I want to keep this order of code ?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-26T09:51:50Z",
        "body": "Yes.\n"
      },
      {
        "user": "Crystark",
        "created_at": "2016-05-26T09:57:33Z",
        "body": "Thanks alot!\n"
      }
    ]
  },
  {
    "number": 3962,
    "title": "concatMap and Subject weirdness",
    "created_at": "2016-05-24T13:45:34Z",
    "closed_at": "2016-05-24T14:51:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3962",
    "body": "Hi,\n\nMaybe I just interpret it wrong but I found some unexpected behaviour.\n\n``` java\nObservable.just(1,2,3).concatMap(new Func1<Integer, Observable<String>>() { //flatmap <-- gets called 3 times\n    @Override\n    public Observable<String> call(Integer integer) {\n        return BehaviorSubject.create(\"one\"); //Observable.just(\"one\"); <-- This gets called 3 times\n    }\n}).subscribe(new Action1<String>() {\n    @Override\n    public void call(String s) {\n        //This gets called once... :(\n    }\n});\n```\n\nThe interesting thing is that if I use flatMap instead of concatMap the callback gets called 3 times. also if I don't use the subject but the Observable.just() it also gets called 3 times what I expect. Can someone describe me this outcome?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3962/comments",
    "author": "mateherber",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-24T14:23:20Z",
        "body": "You need a source to complete with `concatMap` before it can move to the next. `BehaviorSubject` emits its initial value and just waits there, never completing.\n"
      },
      {
        "user": "mateherber",
        "created_at": "2016-05-24T14:51:10Z",
        "body": "Thanks @akarnokd! That makes sense, should have figured it out myself\n"
      }
    ]
  },
  {
    "number": 3960,
    "title": "zip(o1, o2) doesn't unsubscribe from o1",
    "created_at": "2016-05-22T14:41:54Z",
    "closed_at": "2016-06-01T08:51:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3960",
    "body": "A simple example, looks ok\n\n``` java\nObservable<Integer> o1 = Observable.just(1)\n    .doOnCompleted(() -> System.out.println(\"o1 completed\"));\n\nObservable<Integer> o2 = Observable.just(1, 2, 3, 4)\n    .doOnCompleted(() -> System.out.println(\"o2 completed\"));\n\nObservable.zip(o1, o2, (integer1, integer2) -> null).subscribe();\n```\n\nOutput:\n\n```\no1 completed\n```\n\nNow swap o1 and o2\n\n``` java\nObservable<Integer> o1 = Observable.just(1, 2, 3, 4)\n    .doOnCompleted(() -> System.out.println(\"o1 completed\"));\n\nObservable<Integer> o2 = Observable.just(1)\n    .doOnCompleted(() -> System.out.println(\"o2 completed\"));\n\nObservable.zip(o1, o2, (integer1, integer2) -> null).subscribe();\n```\n\nOutput:\n\n```\no1 completed\no2 completed\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3960/comments",
    "author": "ultimate-deej",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-22T15:22:11Z",
        "body": "Zip uses a prefetch of 128 elements by default. Since both sources are synchronous, the second case takes all 4 from the first source, including completion, then moves onto `o2` which first emits 1, then its completion completes the whole sequence. Thus, you see both doOnCompleted executed.\n\nThe first case, `o1` signals 1 and completion, then once `o2` signals its 1, it is known `o2` won't ever signal more values, thus `o2` gets unsubscribed and never allowed to run to completion.\n\nBoth are the expected behavior. If you need resource cleanup associated with a sequence, you can't rely on doOnCompleted as sequences may get unsubscribed before that.\n"
      },
      {
        "user": "ultimate-deej",
        "created_at": "2016-05-22T16:47:53Z",
        "body": "I see, but isn't this implementation details?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-22T17:14:05Z",
        "body": "It is the explanation for what you experienced. The `zip` javadoc has this clause:\n\n> The resulting `Observable<R>` returned from `zip` will invoke `Observer#onNext`\n> as many times as the number of `onNext` invocations of the source Observable that emits the fewest\n> items.\n\nSince `zip`'s behavior seems to be confusing, maybe we could add a clause that `zip` completes eagerly if one of the sources emits fewer elements than the others and unsubscribes the rest.\n"
      },
      {
        "user": "ultimate-deej",
        "created_at": "2016-05-22T17:50:36Z",
        "body": "I agree that docs should be updated. Although the new clause you suggested needs to be more accurate:\n1. Examples in this issue contradict it\n2. If source observables emit equal number of elements (and not fewer), some (which? this one really bothers me) are still going to be unsubscribed.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-01T08:30:40Z",
        "body": "See the proposed documentation changes in #3981.\n"
      },
      {
        "user": "ultimate-deej",
        "created_at": "2016-06-01T08:51:11Z",
        "body": "Thanks, now I know what to expect from `zip`. The current implementation still feels unpolished to me, though.\n"
      }
    ]
  },
  {
    "number": 3956,
    "title": "Calling to Observable.toBlocking(). Always a bad practice?",
    "created_at": "2016-05-20T16:19:57Z",
    "closed_at": "2016-05-22T16:50:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3956",
    "body": "Hi.\n\nI have a library which returns observables. And I have another one which require to return the data in a synchronous way. \n\nParticularly, I’m talking about OkHttp Interceptors. I need to retrieve the oauth token in order to add it as header. But this data comes from an observable. \n\n``` java\npublic class TwitterInterceptor implements Interceptor {\n    @Override public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        Request newRequest = request.newBuilder()\n                .addHeader(\"oauth_token\", RxToken.getTwitterToken().toBlocking().first())\n                .build();\n        return chain.proceed(newRequest);\n    }\n}\n```\n\nCalling `toBlocking().first()` is the only way I can think to solve this problem. But I do not know if calling `toBlocking()` may have some unexpected effects (I mean I know that this observable resolves its task reading from disk or memory, so it is not a really heavy task). But because it seems to be not recommended to use it in production code, as a general rule.\n\nThanks. \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3956/comments",
    "author": "VictorAlbertos",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-21T08:21:19Z",
        "body": "`toBlocking` gets you out of the reactive world and is generally fine if you have to bridge legacy, non-reactive APIs with it. In your example, if you can't change the method to `Observable<Response> intercept(Chain chain)`, `toBlocking` is acceptable tradeoff.\n\nHowever, if you are in the reactive world and suddenly want to use `toBlocking` inside a sequence, there are almost always ways to not do that. A typical mistake that comes up is something like this:\n\n``` java\nsource.map(v -> someAPI(v).toBlocking().first())...\n```\n\nInstead, you should be using any of the `flatMap`, `concatMap`, etc.\n\n``` java\nsource.concatMap(v -> someAPI(v))...\n```\n"
      },
      {
        "user": "VictorAlbertos",
        "created_at": "2016-05-22T16:50:51Z",
        "body": "Thanks for the explanation David. \n"
      },
      {
        "user": "tomgallagher",
        "created_at": "2019-02-13T02:35:59Z",
        "body": "I've got a question about this. In Android, shouldInterceptRequest on a WebClient requires a returned value, either null or a WebResourceResponse. I would like to avoid having a blockingFirst() call. Ideally I would like to pass a reference to the return value into the Observable chain and then make the decision on blocking later on. But I can't see how to do this. "
      },
      {
        "user": "akarnokd",
        "created_at": "2019-02-13T12:52:39Z",
        "body": "@tomgallagher almost always is. If you have something specific, please ask the wider audience of StackOverflow about it."
      },
      {
        "user": "tomgallagher",
        "created_at": "2019-02-13T21:00:02Z",
        "body": "OK thanks. "
      }
    ]
  },
  {
    "number": 3955,
    "title": "concatMap not working",
    "created_at": "2016-05-20T10:24:55Z",
    "closed_at": "2016-06-17T08:07:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3955",
    "body": "Hello! I'm using a RxJava to login to server. I need to create next logic of login:\n**1. Get version of API from server and create (based on version) server urls\n2. Get tokens from the first server url\n3. If tokens received, I need to check if other servers (that I created in point 1) can be accessed by connecting to them**\n\nI writed next logic: \n\n```\n// getObservable() funcion;\nretrun Observable.create(new Observable.OnSubscribe<Integer>() {\n            @Override\n            public void call(Subscriber<? super Integer> subscriber) {\n                if (subscriber.isUnsubscribed()) return;\n//get version from server\n                int version = ServerAPI.getInstance(mContext).getVersion(User.this);\n                if (version < 5) {\n                    subscriber.onNext(AccountsAdapter.ERROR_OLD_API);\n                    subscriber.onCompleted();                 \n                    return;\n                }\n//get tokens\n                Pair<Integer,Tokens> data = ServerAPI.getInstance(mContext).getTokens(User.this, ServerAPI.GRANT_TYPE_PASSWORD);\n                if (data.first==ServerAPI.CODE_OK&&data.second.isValid()) {\n                    setAccessToken(data.second.getAccessToken());\n                    setRefreshToken(data.second.getRefreshToken());\n                    setUserId(data.second.getUserID());\n                    setApiVersion(data.second.getApiVersion());\n                    setTypeToken(data.second.getTokenType());\n                    setMacAlgorithm(data.second.getMacAlgorithm());\n                    setMacKey(data.second.getMacKey());\n                    setApiServer(createApiLink(version));\n                    setImagesServer(createImagesLink());\n //at this point result retuns to subscriber\n                    subscriber.onNext(data.first);\n                } else if (data.first==ServerAPI.CODE_OK\n                        ||data.first==ServerAPI.CODE_INVALID_RESPONSE_DATA) {\n                    subscriber.onNext(AccountsAdapter.ERROR_LOGIN_OR_PASS_INVALID);\n                } else {\n                    subscriber.onNext(data.first);\n                }\n                subscriber.onCompleted();\n            }\n        })\n               .concatMap(integer -> {\n// this code never called\n                if (integer==ServerAPI.CODE_OK) {\n// checking access to the servers\n                    return Observable.zip(getUserModules(), Observable.just(ServerAPI.getInstance(mContext).checkAccessToImagesServer(User.this)), (strings, aBoolean) -> {\n                        if (SystemUtils.isEmpty(strings)) {\n                            logOut();\n                            return AccountsAdapter.ERROR_INVALID_API_SERVER;\n                        } else if (aBoolean) {\n                            Users.getInstance(mContext).setCurrentUser(User.this);\n                            NotificationsManager.enableAllNotifications(mContext, getUserId());\n                            return ServerAPI.CODE_OK;\n                        } else {\n                            logOut();\n                            return AccountsAdapter.ERROR_INVALID_IMAGES_SERVER;\n                        }\n                    });\n                } else {\n                    return Observable.just(integer);\n                }\n            })\n         .subscribeOn(scheduler);\n```\n\nBut this Observable ignores concatMap and returns result from commented string. How to fix this?\n\nSubscriber is called by `getObservable().observeOn(AndroidSchedulers.mainThread()).subscribe();`\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3955/comments",
    "author": "personshelldon",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-20T10:30:04Z",
        "body": "RxJava is not using the builder pattern; each operator returns a new `Observable`. In your example, result won't change by calling `concatMap` on it. You should chain the `subscribeOn` after the application of `concatMap` return the resulting `Observable`.\n"
      },
      {
        "user": "personshelldon",
        "created_at": "2016-05-20T10:38:58Z",
        "body": "I don't understand what You say: I'm returning Observable with already concatMap implemented (I corrected code), but it does not work. Please, explain what I need to do in detailes to get this scheme to work? \nDocumentation says that concatMap will convert emitted items to another Observable, but concatMap ignores that items.\nSorry for my English.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-20T10:44:31Z",
        "body": "What do you get as `integer` in the `concatMap`? Did you debug your `OnSubscribe` implementation to see what it does and what it gets from the API calls?\n"
      },
      {
        "user": "personshelldon",
        "created_at": "2016-05-20T10:49:02Z",
        "body": "Ah, sorry, I understood Your words about the \"not builder pattern\" I need to write`result = result.concatmap()` instead of `result.concatMap()`. Thank You a lot. Now it is working fine.\n\nOne more question: there are many articles that that say `Observable.create()`causes memory leaks if do not call `subscriber.unsubscribe()` in `OnSubscribe()` implementation. Is that true? Or `subscriber.onComplete()` is enough?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-17T08:07:48Z",
        "body": "Sorry for the late response. If an `Observable` is run to completion, resources are released. Otherwise, if your activity is destroyed before that, you have to call `unsubscribe` manually. The problem with `create` is that people tend to implement it poorly, ignoring backpressure and most importantly, resource management.\n\nIf you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 3954,
    "title": "PublishSubject has 0 observers in some instances",
    "created_at": "2016-05-20T09:48:03Z",
    "closed_at": "2016-05-20T18:29:12Z",
    "labels": [
      "Question",
      "Android"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3954",
    "body": "So I am in `Activity A` then I launch `Activity B` (which has a custom `ImageView` with a `PublishSubject` with `setImage*` methods that call `publishSubject.onNext()` )\n\nThe first time launching `Activity B` it works fine, `onNext()` gets called and when I subscribe to the `PublishSubject`, the `Action1` `call()` method gets called .\n\nHowever, subsequent times of launching `Activity B` , `onNext()` will get called but inside of that method it attempts to loop through `state.observers()` which at this point is 0.\n\nWhy is that?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3954/comments",
    "author": "lawloretienne",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-20T10:24:20Z",
        "body": "Can you post a small example?\n"
      },
      {
        "user": "lawloretienne",
        "created_at": "2016-05-20T18:29:12Z",
        "body": "Nevermind I figured it out.  I was doing a call to load an Image with Picasso before I set up the ImageView subscription.  I don't know why that didn't fail 100% of the time. Anyway, I changed the ordering around and all works fine now.\n"
      }
    ]
  },
  {
    "number": 3939,
    "title": "What's the best way to have a side effect of a different type",
    "created_at": "2016-05-13T19:04:23Z",
    "closed_at": "2016-06-17T18:43:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3939",
    "body": "I'd like to have an `Observable` that represents some long running action, such as `Observable<ProgressEvent>` where the event holds progress information for the task, such as a status message or percentage completed.\n\nAt the end of the task I'd like to return a value of a different type. A trivial example would be counting the number of mis spelled words in some text. The progress would be processing word X of Y, but the result might be the list of mis-spelled words.\n\nThe first thing I looked at was`Subject`, but that won't work since the thing is really an `Observable` of the events and an `Observable` of the result, rather than an `Observable` an an `Observer` like `Subject`. Then I thought maybe simply extending `Observable` would work; I'd add an extra method `Optional<Result> result()` which would return the result of the computation after `onComplete`. But you \"lose\" the type of the `Observable` if you call other methods on it like a map, then a filter. You can get around that obviously, either extending all of the methods on Observable to return the subtype, or saving the variable, then chaining method calls to it, then finally, getting the result.\n\nI also considered adding the `result` method to the event interface such that the last call to `onNext` would have an event whose `Optional<Result>` is not empty. This seems pretty easy, but did not feel like the cleanest solution.\n\nWondering if there's a mechanism in the framework that I missed, or some best practice for this type of situation that I'm not aware of.\n\nThe reason I don't return an `Observable<Result>` in the first place is I wanted the caller to have the option of subscribing to the event stream to do something like show a progress monitor.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3939/comments",
    "author": "mhgrove",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2016-05-14T10:31:48Z",
        "body": "Trying again with formatting fixed.\n\nYou could emit a custom object that has a `ProgressEvent` and `List<String>`\nbeing the list of misspelled words so far (only needs to have real content till the last emission though) and then:\n\n``` java\nobservable\n    .doOnNext(x -> updateProgress(x.event))\n    .last()\n    .map(x -> x.list);\n```\n"
      },
      {
        "user": "mhgrove",
        "created_at": "2016-05-16T15:17:03Z",
        "body": "Yeah, that's similar to what I had stubbed out:\n\n```\n    public interface ProgressEvent<T> {\n\n        public long progress();\n        public long maxProgress();\n\n        public default Optional<T> result() {\n            return Optional.empty();\n        }\n    }\n```\n\nThat's the event that any `Observable` emitted that was a process that reported progress on the creation of a result.\n\nIt had not occurred to me `last().map(ProgressEvent::result).map(Optional::get)` could pretty cleanly get the result of the operation. I had been trying to use `compose`, `extend`, or `lift`, but those couldn't really be provided by the caller since the functions would need the state of the process being observed to potentially build the result. Extending `Observable` didn't feel clean, nor did hacking the builder creating the process to add observers to the resulting `Observable` or having it provide the function needed to get the final result.\n\n`last`/`map` seems like it might be the best option.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-17T18:43:42Z",
        "body": "Looks like the question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 3933,
    "title": "BackPressure and nested flatMap",
    "created_at": "2016-05-12T10:28:40Z",
    "closed_at": "2016-05-14T08:26:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3933",
    "body": "Hi, can someone explain why the following code (without nested flatmap)\n\n<div class=\"highlight highlight-source-java\"><pre>\nObservable.from(new IterateOverFloat(1))) //\n                .flatMap(__ -> Observable.create(new OnSubscribeFromIterable<>(new IterateOverFloat(10_000_000)))) //\n                .flatMap(Observable::just) //\n                .observeOn(Schedulers.computation()) //\n                .subscribe();\n</pre></div>\n\ngoes through method `slowPath(long)` of `OnSubscribeFromIterable.IterableProducer`,\n\nwhile the following code (with nested flat map)\n\n<div class=\"highlight highlight-source-java\"><pre>\nObservable.from(new IterateOverFloat(1)) //\n                .flatMap(__ -> Observable.create(new OnSubscribeFromIterable<>(new IterateOverFloat(10_000_000))) //\n                        .flatMap(Observable::just)) //\n                .observeOn(Schedulers.computation()) //\n                .subscribe();\n</pre></div>\n\ngoes through method `fastPath()` ?\n\n`IterateOverFloat` is just a basic iterable that produces the asked number of floats.\n\nI've tested with both RxJava-1.1.0 and 1.1.5 with the same results.\n\nEDIT : ok, I have looked around a bit more, and here is what I have found.\nI have created an Observable with backpressure support, which prints the first number of requested items:\n\n<div class=\"highlight highlight-source-java\"><pre>\nObservable<Long> myObsWithBackPressureSupport = Observable.create(subs -> {\n            subs.setProducer(new Producer() {\n\n                AtomicBoolean bool = new AtomicBoolean(true);\n\n                @Override\n                public void request(long n) {\n                    if(bool.getAndSet(false)){\n                        System.out.println(\"request \" + n);\n                    }\n                    \n                    LongStream.range(0, n).forEach(subs::onNext);\n                }\n                \n            });\n        });\n</pre></div>\n\n\nand I used it the following ways: \n\n<div class=\"highlight highlight-source-java\"><pre>\n// case 1\nmyObsWithBackPressureSupport //\n        .observeOn(Schedulers.computation()) //\n        .subscribe();\n\n// case 2\nmyObsWithBackPressureSupport //\n        .flatMap(l -> Observable.just(l)) //\n        .observeOn(Schedulers.computation()) //\n        .subscribe();\n</pre></div>\n\n\nIn case 1, first request of 128 items.\nIn case 2, first request of Long.MAX_VALUE items.\n\nI have concluded that using `flatMap` disables the backpressure support. Can someone tell me if I am right and if it is an intended behavior ?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3933/comments",
    "author": "feneuilflo",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-12T17:31:56Z",
        "body": "FlatMap has multiple entry points: one front and any number of inner sequences. \n\nBy default, `flatMap` requests the `Long.MAX_VALUE` - which is called unbounded mode - from its main upstream, which may trigger the fast-paths in sources. \n\nThe inner, mapped sequences, request a fixed amount - default 128 - and keeps requesting as those inner values get consumed and merged into the output sequence. This doesn't trigger the fast-paths in most inner sequences. \n\nYou can restrict the outer unbounded mode by setting the `maxConcurrency` parameter but you can't unbound the inner sequences. \n\nIf you are dealing with inner `Iterable`s, you can avoid the genreal overhead by using `flatMapIterable`.\n"
      },
      {
        "user": "feneuilflo",
        "created_at": "2016-05-14T08:26:27Z",
        "body": "Thanks for this answer. Using the `maxConcurrency` parameter has solved my problem.\n"
      }
    ]
  },
  {
    "number": 3930,
    "title": "Dynamically push data to observable without changing subscriber",
    "created_at": "2016-05-11T09:08:32Z",
    "closed_at": "2016-06-22T08:09:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3930",
    "body": "I'd like to create an observable and dynamically push data to it. I create the following code to do it:\n\n```\n        Observable\n                .create(new Observable.OnSubscribe<Object>() {\n                    @Override\n                    public void call(Subscriber<? super Object> subscriber) {\n                        eventSubscriber = subscriber;\n                    }\n                })\n                .flatMap(new Func1<Object, Observable<Object>>() {\n                    @Override\n                    public Observable<Object> call(Object Object) {\n                        // perform some transformation.\n                    }\n                })\n                .subscribe(new Action1<Object>() {\n                    @Override\n                    public void call(Object object) {\n                        // perform some action.\n                    }\n                });\n\n         .....\n\n        // Other place that generates data\n        eventSubscriber.onNext(data);\n```\n\nHowever, the problem is that whenever there's new data pushed to the observable, transformed by the flatMap, and consumed by the subscription,  the `eventSubscriber` will be updated with a new subscriber. Is there a way to avoid this? \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3930/comments",
    "author": "cffan",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-11T09:17:15Z",
        "body": "Yes, use `PublishSubject`.\n\n``` java\nPublishSubject<Integer> ps = PublishSubject.create();\n\nps.flatMap(v -> transform(v)).subscribe(...);\n\nps.onNext(data);\n```\n"
      },
      {
        "user": "cffan",
        "created_at": "2016-05-12T15:03:12Z",
        "body": "Thanks @akarnokd. I tried PublishSubject but it has the effect of creating duplicated events. For example, here's a simplified version of my code:\n\n```\nPublishSubject<Integer> ps = PublishSubject.create();\n\nObservable<Integer> o1;\nObservable<Integer> o2;\no1 = ps.flatMap(v -> return o2);\no2 = ps.flatMap(v -> return o1);\n\no1.subscribe(v -> print(v));\n\n# Generate some data\nps.onNext(1);\nps.onNext(2);\nps.onNext(1);\nps.onNext(2);\n\n# Results:\n1\n2\n1\n1\n2\n2\n2\n```\n\nThe reason I need to write code like this is for simulating a finite state machine. `o1` and `o2` are like states and they goes to each other when seeing some events.\n"
      },
      {
        "user": "abersnaze",
        "created_at": "2016-05-12T16:13:01Z",
        "body": "I'm not entirely sure what your goal is but if I was going to make a finite state machine I would base it on the scan or reduce operator.\n\n```\nObservable<Input> src;\nObservable<State> lastState = src.reduce(INIT_STATE, this::lookupNextStateForCurrentStateAndInput)\n\nif (lastState.toBlocking().single().isTermainal()) {\n    System.out.println(\"woo it matched\");\n} else {\n    System.out.println(\"failed to match input\");\n}\n```\n"
      },
      {
        "user": "cffan",
        "created_at": "2016-05-13T14:31:29Z",
        "body": "Thanks @abersnaze. I've considered using scan/reduce operators, but flatMap gives me advantage over scan/reduce in terms of code structure. I'll try to illustrate it using the following codes.\n\nUsing flatMap:\n\n```\nObservable<Input> events;\nObservable<State> startState;\nObservable<State> finalState;\nstartState =\n  events.flatMap(e -> {\n    Observable<State> nextState = startState;\n    if (event is A) {\n      nextState = finalState;\n    }\n    return nextState.startWith(e);\n  });\nfinalState =\n  events.flatMap(e -> {\n    Observable<State> nextState = finalState;\n    if (event is C) {\n      nextState = startState;\n    }\n    return nextState.startWith(e);\n  });\n\nstartState.subscribe(e -> {\n  if (event is A) {\n    // do something with A\n  } else if (event is B) {\n    // do something with B\n  } else if (event is C) {\n    // do something with C\n  }\n});\n```\n\nUsing reduce:\n\n```\nObservable<Input> events;\nObservable<State> states =\n  events.reduce(START_STATE, (curState, event) -> {\n    State nextState = curState;\n    if (curState == START_STATE) {\n      if (event is A) {\n        nextState = FINAL_STATE;\n        // do something with A\n      } else if (event is B) {\n        // do something with B\n      }\n    } else if (curState == FINAL_STATE) {\n      if (event is C) {\n        nextState = START_STATE;\n        // do something with C\n      }\n    }\n  });\n```\n\nThe difference is that, with the flatMap approach, I could separate state transition and event handling. The piece of codes looks modular and flat. While with the reduce approach, things are mixed up. Especially in my case where there are a lot of states and events. The codes are harder to read.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-22T08:09:10Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 3929,
    "title": ".groupBy should not hold strong references to keys",
    "created_at": "2016-05-11T09:08:08Z",
    "closed_at": "2016-05-11T12:43:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3929",
    "body": "Actual result: .groupBy maintains internal map with strong references to keys. In case when key is large object, or references another large objects, this can lead to OOM eventually.\n\nExpected result: groupBy keeps week references to keys, which does not prevent GC from collecting the keys.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3929/comments",
    "author": "gumanoid",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-11T09:22:19Z",
        "body": "GroupBy has to remember the whole key because values have to go to the associated `GroupedObservable`. A weak key would imply groups get recreated multiple times or worse, an old group's `getKey()` suddenly returning `null`.\n\nYou could try extracting only the necessary key material into a separate, independent data class and use that in the keyselector:\n\n``` java\nsource.groupBy(v -> new MyKey(v.name, v.age))...\n```\n"
      },
      {
        "user": "gumanoid",
        "created_at": "2016-05-11T12:29:25Z",
        "body": "Thanks for quick reply.\nLightweight key is the best solution of course, but I'm not sure it's always a possible one.\nI guess you're right about weak refs also. I spent extra half an our in attempts to invent feasible solutions for various scenarios with weak refs and GC, and failed.\nAt least the key extractor can return weak refs, if this is the only way.\nCan be closed.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-11T12:43:54Z",
        "body": "Yes, if your key class depends on a `List<String>` with million items then it is hard to avoid the retention. A possible solution is perhaps to reduce that large data amount with a hash function (SHA256) which gives a manageable key size at the cost of a very low chance of key collision.\n"
      },
      {
        "user": "abersnaze",
        "created_at": "2016-05-12T01:59:15Z",
        "body": "If you unsubscribe from the GroupedObservables it should remove the reference to the key so that it can be GC'd.  If a new value that maps to the old key shows up a new GroupedObservable is started up.\n\n```\nimport java.util.concurrent.TimeUnit;\nimport rx.Observable;\n\npublic class Main {\n    public static void main(String[] args) {\n        Observable<Long> fast = Observable.interval(10, TimeUnit.MILLISECONDS).map(i -> i * 2).take(10);\n        Observable<Long> slow = Observable.interval(20, TimeUnit.MILLISECONDS).map(i -> i * 2 + 1).take(10);\n\n        fast.mergeWith(slow)//\n                .groupBy(i -> i % 2)\n                .flatMap(grp -> {\n                    System.out.println(\"New group for key \" + grp.getKey());\n                    Observable<Long> timeLimitedGrp = grp.take(100, TimeUnit.MILLISECONDS).doOnUnsubscribe(() -> System.out.println(\"Unsub group for key \" + grp.getKey()));\n                    // do other stuff\n                    return timeLimitedGrp;\n                })\n                .toBlocking()\n                .forEach(System.out::println);\n    }\n}\n```\n\nproduces the output\n\n```\nNew group for key 0\n0\n2\nNew group for key 1\n1\n4\n6\n3\n8\n10\n5\n12\n7\n14\n16\n18\n9\nUnsub group for key 0\n11\nUnsub group for key 1\nNew group for key 1\n13\n15\n17\n19\nUnsub group for key 1\n\n```\n"
      }
    ]
  },
  {
    "number": 3920,
    "title": "a Subscriber object  only has effect when be subscribed first time by Observable.just(...).subscribe()",
    "created_at": "2016-05-09T07:34:28Z",
    "closed_at": "2016-05-18T22:44:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3920",
    "body": "I just test Observable.just(...) by click a button;\n`private void rxUseJustCreateObserable(){\n        Log.d(TAG,\"rxUseJustCreateObserable\");\n        Observable<String> observable = Observable.just(\"just 1\",\"just 2\");\n       ...}`\n\n**1.**if I use `observable.subscribe(mSubscriber);`  only the first time when I click button it has effect;\n\n**2.**if I use `observable.subscribe(new Subscriber<String>(){...});` every time I click  button, it's has effect;\n\nwhat the different between **1** and**2** ?\ncould anyone give me an answer?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3920/comments",
    "author": "gaobq",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-09T07:41:00Z",
        "body": "`Subscriber` instances are not reusable, you may want to use `Observer` instead.\n"
      },
      {
        "user": "gaobq",
        "created_at": "2016-05-09T07:48:00Z",
        "body": "@akarnokd  ,thanks \n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2016-05-18T22:42:15Z",
        "body": "Looks like it can be closed.\n"
      }
    ]
  },
  {
    "number": 3908,
    "title": "How to delay to call “onError”? concatDelayError is not ok.",
    "created_at": "2016-05-05T09:48:26Z",
    "closed_at": "2016-06-17T18:58:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3908",
    "body": "My requirement is read data from local database first, and then read data from network. The following is the code:\n\n```\n    Observable<String> obsLocal =\n            Observable.<String>create(subscriber -> {\n                //do work\n               for(int i=0;i<Integer.MAX_VALUE / 10; i++){\n\n               }\n                subscriber.onNext(\"local\");\n                subscriber.onCompleted();\n            });\n\n        Observable<String> obsNet =\n            Observable.<String>create(subscriber -> {\n                subscriber.onNext(\"net\");\n                subscriber.onCompleted();\n            });\n\n  Observable.<String>concat(obsLocal, obsNet)\n            .subscribeOn(Schedulers.io())\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(v->{\n                LogUtil.d(\"onNext \" + v);\n            }, throwable -> {\n                LogUtil.d(\"onerror \");\n            }, ()->{\n                LogUtil.d(\"oncomplete \");\n            });\n```\n\nNow, if no error, everything is ok.\n\nBut if an error occurs, the execution will break immediately. \n\nIf I use the following code:\n\n```\n Observable<String> obsNet =\n                Observable.<String>create(subscriber -> {\n                subscriber.onError(new RuntimeException());\n            });\n```\n\nobsLocal would stop immediately too.\n\nI expect onError is called after obsLocal executing completely. How can I do?\n\nBy the way, concatDelayError is not ok.\n\nIf you have any suggestion or solution, please let me know. Thanks a lot!\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3908/comments",
    "author": "superyfwy",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-09T21:42:39Z",
        "body": "What's happening is that the error cuts ahead of the value in `observeOn`. You have to use `observeOn(scheduler, true)` to delay the error itself and keep the total event order.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-17T18:58:38Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 3891,
    "title": "Testing subscriber and error handling",
    "created_at": "2016-04-28T13:05:06Z",
    "closed_at": "2016-06-19T10:51:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3891",
    "body": "Hi! I want to test how my code handles events and errors coming from am observable. I create observable in one method and subscribe to it in another, using Schedulers.io() and AndroidSchedulers.mainThread(). Is it possible to test subscriber's behavior? And, more importantly, should I do it?\n\nWhen I do something like the code below, I keep getting NullPointerException on .subscribeOn(...).\nExample:\n\n``` java\npublic class FeedLoader { \n    public Observable<FeedResponse> loadFeedsList() {\n        return feedWebService.getFeeds();\n    }\n}\n\npublic class FeedSubscriber {\n    feedLoader = new FeedLoader();\n\n    public void loadFeedsList() {\n        feedLoader.loadFeedsList()\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(feeds -> {\n                    getView().setToolbarPager(adapter);\n                }, throwable -> {\n                    getView().showConnectionError();\n                });\n    }\n}\n\npublic class SubscriberTest {\n@Mock\nBlaFeedLoader feedLoader;\n\n...\nwhen(feedLoader.loadFeedsList())\n                .thenReturn(Observable.<FeedResponse>error(new Throwable(\"Connection error\")));\n\nfeedSubscriber.loadFeedList();\n\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3891/comments",
    "author": "aleien",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-06-17T20:27:09Z",
        "body": "My guess is that the `feedSubscriber` instantiates the `FleedLoader` and doesn't use the `BlaFeedLoader` at all. Therefore the `when` doesn't apply and either `feedWebService` or `feedWebService.getFeeds()` is `null` by default.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-19T10:51:48Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      },
      {
        "user": "rachitmishra",
        "created_at": "2017-11-14T11:34:58Z",
        "body": "I also have the same questions, and these are the answers I have found:\r\n\r\n1. Should we test subscriber part -> Yes\r\n2. How do we do that?\r\n\r\n- Mock the observable\r\n- Call the subscriber on TestScheduler or immediate thread\r\n- verify functions are called using mockito"
      }
    ]
  },
  {
    "number": 3876,
    "title": "How to replay with filters?",
    "created_at": "2016-04-22T15:25:16Z",
    "closed_at": "2016-06-22T08:08:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3876",
    "body": "From a `Observable<Pair<Long ,Boolean>>` that never completes, I want to be able to split it up into never ending streams of `Observable<Boolean>` for any given long, these streams should replay the last value and start with `false` if the boolean is missing.\n\nIs there an existing combination of operators that can do something like this ?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3876/comments",
    "author": "adipascu",
    "comments": [
      {
        "user": "abersnaze",
        "created_at": "2016-04-22T17:47:08Z",
        "body": "How do you want to store the `Observable<Boolean>`? It seem like you would want to use `groupBy` to get the individual `GroupedObserable<Long, Boolean>` then subscribe to each of those with a `BehaviorSubject` then put those in a global `ConcurrentHashMap<Long, BehaviorSubject<Boolean>>`. Here is some code:\n\n``` java\npublic class Main {\n    public static class Pair<A, B> {\n        public final A a;\n        public final B b;\n\n        public Pair(A a, B b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        public A getA() {\n            return a;\n        }\n\n        public B getB() {\n            return b;\n        }\n    }\n\n    public static void main(String[] args) {\n        // create an infinite source\n        Observable<Pair<Integer, Boolean>> src = Observable.create(SyncOnSubscribe.createSingleState(Random::new, (rnd, next) -> {\n            next.onNext(new Pair<>(rnd.nextInt(30), rnd.nextBoolean()));\n        }));\n        src = src.subscribeOn(Schedulers.newThread());\n\n        // make a thread safe place where producers and consumers get/put subjects\n        ConcurrentHashMap<Integer, BehaviorSubject<Boolean>> grpSubjects = new ConcurrentHashMap<>();\n\n        // for each group boolean for a long\n        src.groupBy(Pair::getA).forEach(grp -> {\n            // get the subject that we should send the booleans to\n            BehaviorSubject<Boolean> grpSubject = grpSubjects.computeIfAbsent(grp.getKey(), (l) -> BehaviorSubject.create());\n\n            System.out.println(\"starting subject for group \" + grp.getKey());\n            // send just the booleans\n            grp.map(Pair::getB).subscribe(grpSubject);\n        });\n\n        // get the group for 20 and if it doesn't exist default to false.\n        BehaviorSubject<Boolean> grpSubject = grpSubjects.computeIfAbsent(20, (l) -> BehaviorSubject.create(false));\n        grpSubject.take(10).toBlocking().forEach(System.out::println);\n    }\n}\n```\n\nproduces the output\n\n```\nstarting subject for group 16\nstarting subject for group 5\nstarting subject for group 21\nstarting subject for group 13\nstarting subject for group 10\nstarting subject for group 3\nstarting subject for group 18\nstarting subject for group 17\nstarting subject for group 11\nstarting subject for group 0\nstarting subject for group 25\nstarting subject for group 15\nstarting subject for group 7\nstarting subject for group 8\nstarting subject for group 4\nstarting subject for group 2\nstarting subject for group 6\nstarting subject for group 20\nstarting subject for group 27\nstarting subject for group 28\nstarting subject for group 29\nstarting subject for group 22\nstarting subject for group 24\nstarting subject for group 1\nstarting subject for group 9\nstarting subject for group 12\nstarting subject for group 14\nfalse\nfalse\ntrue\nstarting subject for group 19\ntrue\nstarting subject for group 23\ntrue\nstarting subject for group 26\nfalse\nfalse\ntrue\nfalse\ntrue\n```\n"
      },
      {
        "user": "adipascu",
        "created_at": "2016-04-26T10:22:20Z",
        "body": "@abersnaze this solution works but doesn't clean itself up if there are no downstream subscribers.\nIf there are no downstream subscribers for a key, I'd like it to clean up the stored value and reset to the default value (false here).\nAlso this snippet contains non-reactive code, can this be done just using a combination of rx operators ? \n\nI am planning on creating an operator for this purpose but I don't want to reinvent the wheel if there are other operators that can suit my needs.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-17T20:09:37Z",
        "body": "I guess you mean the latest, which implies that each Observable<Boolean> itself should be a hot observable. \n\nIf the `Observable<Pair<Long, Boolean>>` itself is hot, you could just simply filter and map it individually for your subscriber:\n\n``` java\nPublishSubject<Pair<Long, Boolean>> source = ...\n\npublic Subscription observe(long key, Subscriber<Boolean> subscriber) {\n    return source\n        .filter(pair -> pair.first == key)\n        .map(pair -> pair.second)\n        .startWith(false)\n        .subscribe(subscriber);\n}\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-22T08:08:28Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 3875,
    "title": "How can i do this?",
    "created_at": "2016-04-22T07:02:39Z",
    "closed_at": "2016-04-22T07:37:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3875",
    "body": "[Uploading Help.txt…]()\n\nimport java.util.List;\n\npublic class aaa {\n    List<Data> list;\n\n```\nprivate int getCount(){\n    //for\n\n//how can i do this whith Rxjava.....thanks\n    int size=list.size();\n    int count=0;\n    for(int i=0;i<size;i++){\n\n        count=count+list.get(i).count;\n\n    }\n\n  return count;\n}\n\n\n\n\n\nclass Data{\n\n    String name=\"\";\n    int count;\n\n\n}\n```\n\n}\n\nI have a List<Data> and Data have an int count,i want use `Rxjava` to get All count of this List ,how can i do it?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3875/comments",
    "author": "zlm54585652",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-04-22T07:09:34Z",
        "body": "First, how would you do it with plain Java?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-22T07:42:34Z",
        "body": "``` java\nObservable.from(list)            // <-- loop over each item\n.map(item -> item.count)         // <-- extract count from each item\n.reduce(0, (a, b) -> a + b);     // <-- sum up the counts\n.subscribe(System.out::println); // <-- get the final sum\n```\n"
      }
    ]
  },
  {
    "number": 3873,
    "title": "initial value factory overload for scan?",
    "created_at": "2016-04-21T23:43:48Z",
    "closed_at": "2016-05-21T09:17:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3873",
    "body": "I was just using `Observable.scan()` and it has a method with an initial value but no method with an intial value factory like:\n\n``` java\npublic final <R> Observable<R> scan(Func0<R> initialValue, Func2<R, ? super T, R> accumulator); \n```\n\nI can work around this with `defer` but are people happy if I submit a PR with a factory parameter (and perhaps for the `reduce` method as well)?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3873/comments",
    "author": "davidmoten",
    "comments": [
      {
        "user": "zsxwing",
        "created_at": "2016-04-22T00:05:51Z",
        "body": "See #3667\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-21T09:17:38Z",
        "body": "Closing as duplicate to #3667.\n"
      }
    ]
  },
  {
    "number": 3869,
    "title": "wondering",
    "created_at": "2016-04-20T10:13:38Z",
    "closed_at": "2016-05-21T09:14:09Z",
    "labels": [
      "Question",
      "Android"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3869",
    "body": "``` java\nObservable\n.just(mToast)\n.observeOn(AndroidSchedulers.mainThread())\n.subscribe(new Action1<Toast>() {\n    @Override\n    public void call(Toast toast) {\n       if (mToast == null) {\n          mToast = Toast.makeText(MainActivity.this, \"test==================\", Toast.LENGTH_SHORT);\n       } else {\n           mToast.setText(\"test====================\");\n       }\n       mToast.show();\n   }\n}).unsubscribe();\n```\n\nwhy the toast can‘t show？\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3869/comments",
    "author": "longshiming",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-04-20T10:24:32Z",
        "body": "You unsubscribe immediately and the value may not ever reach the action at all.\n"
      },
      {
        "user": "longshiming",
        "created_at": "2016-04-20T10:29:09Z",
        "body": "its not order？first ，perform the action,then ,perform unsubscribe().\n\nOr rather, at what time should I perform unsubscribe?\n"
      },
      {
        "user": "zsxwing",
        "created_at": "2016-04-20T17:21:15Z",
        "body": "@longshiming the problem is in `.observeOn(AndroidSchedulers.mainThread())`. I guess your code was running in the main thread. Then `.observeOn(AndroidSchedulers.mainThread())` will emit the element to the main handler queue. After your codes finishes, unsubscribe has been called. Therefore when the element is polled  from the queue, it will be ignored.\n"
      },
      {
        "user": "longshiming",
        "created_at": "2016-04-22T08:17:31Z",
        "body": "@zsxwing Thanks. AndroidSchedulers. MainThread () can run time-consuming tasks？\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2016-04-22T08:49:57Z",
        "body": "No, it's a bad idea because it'll block main thread of Android app, UI will freeze and Android OS may display ANR dialog. \n"
      },
      {
        "user": "longshiming",
        "created_at": "2016-04-22T08:52:57Z",
        "body": "@artem-zinnatullin Thanks\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-21T09:14:09Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 3857,
    "title": "about concat operator ",
    "created_at": "2016-04-14T07:58:29Z",
    "closed_at": "2016-05-13T12:14:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3857",
    "body": "I use rxjava 1.1.3\n\n```\n    private void test() {\n        testConcat().subscribe(new Action1() {\n            @Override\n            public void call(Object o) {\n                Ln.e(\"onNext call\");\n            }\n        }, new Action1<Throwable>() {\n            @Override\n            public void call(Throwable throwable) {\n                Ln.e(\"onError call\");\n            }\n        }, new Action0() {\n            @Override\n            public void call() {\n                Ln.e(\"onComplete call\");\n            }\n        });\n    }\n\n    @RxLogObservable\n    private Observable testConcat() {\n        return Observable.concat(o1(), o2())\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread());\n    }\n\n    @RxLogObservable\n    private Observable o1() {\n        return Observable.create(new Observable.OnSubscribe<Object>() {\n            @Override\n            public void call(Subscriber<? super Object> subscriber) {\n                subscriber.onNext(\"hello\");\n                subscriber.onCompleted();\n            }\n        });\n    }\n\n    @RxLogObservable\n    private Observable o2() {\n        return Observable.create(new Observable.OnSubscribe<Object>() {\n            @Override\n            public void call(Subscriber<? super Object> subscriber) {\n                throw OnErrorThrowable.from(new RuntimeException(\"sorry\"));\n//                subscriber.onNext(\"sorry\");\n//                subscriber.onCompleted();\n            }\n        });\n    }\n```\n\nI call test() method log:\n\n```\n04-14 15:50:15.022 12350-12350/com.test D/RxJavaConcat: Frodo => [@Observable :: @InClass -> RxJavaConcat :: @Method -> testConcat()]\n04-14 15:50:15.023 12350-12350/com.test D/RxJavaConcat: Frodo => [@Observable :: @InClass -> RxJavaConcat :: @Method -> o1()]\n04-14 15:50:15.024 12350-12350/com.test D/RxJavaConcat: Frodo => [@Observable :: @InClass -> RxJavaConcat :: @Method -> o2()]\n04-14 15:50:15.024 12350-12350/com.test D/RxJavaConcat: Frodo => [@Observable#testConcat -> onSubscribe()]\n04-14 15:50:15.025 12350-25780/com.test D/RxJavaConcat: Frodo => [@Observable#o1 -> onSubscribe()]\n04-14 15:50:15.025 12350-25780/com.test D/RxJavaConcat: Frodo => [@Observable#o1 -> onNext() -> hello]\n04-14 15:50:15.025 12350-25780/com.test D/RxJavaConcat: Frodo => [@Observable#o1 -> onCompleted()]\n04-14 15:50:15.025 12350-25780/com.test D/RxJavaConcat: Frodo => [@Observable#o1 -> onTerminate()]\n04-14 15:50:15.025 12350-25780/com.test D/RxJavaConcat: Frodo => [@Observable#o1 -> @Emitted -> 1 element :: @Time -> 0 ms]\n04-14 15:50:15.025 12350-25780/com.test D/RxJavaConcat: Frodo => [@Observable#o1 -> @SubscribeOn -> RxCachedThreadScheduler-3 :: @ObserveOn -> RxCachedThreadScheduler-3]\n04-14 15:50:15.025 12350-25780/com.test D/RxJavaConcat: Frodo => [@Observable#o1 -> onUnsubscribe()]\n04-14 15:50:15.025 12350-25780/com.test D/RxJavaConcat: Frodo => [@Observable#o2 -> onSubscribe()]\n04-14 15:50:15.026 12350-25780/com.test D/RxJavaConcat: Frodo => [@Observable#o2 -> onError() -> 'java.lang.RuntimeException: sorry']\n04-14 15:50:15.026 12350-25780/com.test D/RxJavaConcat: Frodo => [@Observable#o2 -> onTerminate()]\n04-14 15:50:15.026 12350-25780/com.test D/RxJavaConcat: Frodo => [@Observable#o2 -> @Emitted -> 0 elements :: @Time -> 0 ms]\n04-14 15:50:15.063 12350-12350/com.test D/RxJavaConcat: Frodo => [@Observable#testConcat -> onError() -> 'java.lang.RuntimeException: sorry']\n04-14 15:50:15.063 12350-12350/com.test D/RxJavaConcat: Frodo => [@Observable#testConcat -> onTerminate()]\n04-14 15:50:15.063 12350-12350/com.test D/RxJavaConcat: Frodo => [@Observable#testConcat -> @Emitted -> 0 elements :: @Time -> 38 ms]\n04-14 15:50:15.063 12350-12350/com.test E/(RxJavaConcat.java:185): main onError call\n04-14 15:50:15.063 12350-12350/com.test D/RxJavaConcat: Frodo => [@Observable#testConcat -> @SubscribeOn -> main :: @ObserveOn -> main]\n04-14 15:50:15.063 12350-12350/com.test D/RxJavaConcat: Frodo => [@Observable#testConcat -> onUnsubscribe()]\n04-14 15:50:15.064 12350-12350/com.test D/RxJavaConcat: Frodo => [@Observable#o2 -> @SubscribeOn -> RxCachedThreadScheduler-3 :: @ObserveOn -> main]\n04-14 15:50:15.064 12350-12350/com.test D/RxJavaConcat: Frodo => [@Observable#o2 -> onUnsubscribe()]\n```\n\nSo my question is: why \"onNext call\" is not called\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3857/comments",
    "author": "csshuai",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-04-14T08:19:54Z",
        "body": "By default, errors may cut ahead of `onNext` calls in `observeOn`. Use the `observeOn(Scheduler s, boolean delayError)` overload.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-13T12:14:30Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 3854,
    "title": "What's the difference between publish().refcount() and using subjects as a event bus? Which is preferable?",
    "created_at": "2016-04-13T07:28:04Z",
    "closed_at": "2016-05-13T12:15:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3854",
    "body": "I was thinking of implementing an EventBus using Rx in android and everywhere I could only see Subjects being used as the main component. But then I found that you could use publish() to broadcast to multiple subscribers. Now I'm in a quandry. Could you help me out by giving an explanation?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3854/comments",
    "author": "masterlittle",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-05T07:37:37Z",
        "body": "There are differences. `publish` is applied on a source, requires backpressure-aware source, prefetches some amount of events and you have to connect it by hand. You can't just drive it with onNexts manually, but `PublishSubject` can be.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-13T12:15:02Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 3847,
    "title": "I use scan operator,but it not work when just one value or first event",
    "created_at": "2016-04-10T15:54:23Z",
    "closed_at": "2016-06-17T20:21:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3847",
    "body": "I use the `rxjava` version `1.1.0`,and use scan operator such as:\n\n```\nObservable.just(\"Hello, world!\").scan(new Func2<String, String, String>() {\n        @Override\n        public String call(String s, String s2) {\n            Log.e(\"test\", s);\n            return s;\n        }\n    }).subscribe(new Action1<String>() {\n        @Override\n        public void call(String s) {\n            Log.e(\"test\", s);\n        }\n    });\n```\n\n the `scan()` not invoke.\n\nor \n\n```\nRxView.clicks(btn).map(new Func1<Void, Integer>() {\n        @Override\n        public Integer call(Void aVoid) {\n            times = times + 1;\n            return times;\n        }\n    }).timestamp().scan(new Func2<Timestamped<Integer>, Timestamped<Integer>,               Timestamped<Integer>>() {\n        @Override\n        public Timestamped<Integer> call(Timestamped<Integer> integerTimestamped, Timestamped<Integer> integerTimestamped2) {\n  Log.e(\"integerTimestamped:\", integerTimestamped.getValue() + \"\");\n  Log.e(\"integerTimestamped\", integerTimestamped.getTimestampMillis() + \"\");\n  Log.e(\"integerTimestamped2:\", integerTimestamped2.getValue() + \"\");\n  Log.e(\"integerTimestamped2\", integerTimestamped2.getTimestampMillis() + \"\");\n  return Timestamped<>(integerTimestamped2.getTimestampMillis(),times);\n        }\n    }).subscribe(new Action1<Timestamped<Integer>>() {\n        @Override\n        public void call(Timestamped<Integer> integerTimestamped) {\n            if (integerTimestamped.getValue() == 5) {\n                firstClickTime = 0;\n                times = 0;\n                Toast.makeText(MainActivity.this,\n                    \"test\",\n                    Toast.LENGTH_LONG).show();\n            }\n\n        }\n    });\n```\n\n when click btn first time ,the `scan()` also not invok\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3847/comments",
    "author": "carl1990",
    "comments": [
      {
        "user": "abersnaze",
        "created_at": "2016-04-10T16:40:30Z",
        "body": "That overload of scan is only invokes the function when there are more than one onNext.  change the first example to either:\nA) use the scan( Func0, Func2 )\nB) use just(\"hello\", \"world\")\n\n> On Apr 10, 2016, at 08:54, carl notifications@github.com wrote:\n> \n> I use the rxjava version 1.1.0,and use scan operator such as:\n> \n> Observable.just(\"Hello, world!\").scan(new Func2<String, String, String>() {\n>         @Override\n>         public String call(String s, String s2) {\n>             Log.e(\"test\", s);\n>             return s;\n>         }\n>     }).subscribe(new Action1<String>() {\n>         @Override\n>         public void call(String s) {\n>             Log.e(\"test\", s);\n>         }\n>     });\n> the scan() not invoke.\n> \n> or\n> \n> RxView.clicks(btn).map(new Func1<Void, Integer>() {\n>         @Override\n>         public Integer call(Void aVoid) {\n>             times = times + 1;\n>             return times;\n>         }\n>     }).timestamp().scan(new Func2<Timestamped<Integer>, Timestamped<Integer>,               Timestamped<Integer>>() {\n>         @Override\n>         public Timestamped<Integer> call(Timestamped<Integer> integerTimestamped, Timestamped<Integer> integerTimestamped2) {\n>   Log.e(\"integerTimestamped:\", integerTimestamped.getValue() + \"\");\n>   Log.e(\"integerTimestamped\", integerTimestamped.getTimestampMillis() + \"\");\n>   Log.e(\"integerTimestamped2:\", integerTimestamped2.getValue() + \"\");\n>   Log.e(\"integerTimestamped2\", integerTimestamped2.getTimestampMillis() + \"\");\n>   return Timestamped<>(integerTimestamped2.getTimestampMillis(),times);\n>         }\n>     }).subscribe(new Action1<Timestamped<Integer>>() {\n>         @Override\n>         public void call(Timestamped<Integer> integerTimestamped) {\n>             if (integerTimestamped.getValue() == 5) {\n>                 firstClickTime = 0;\n>                 times = 0;\n>                 Toast.makeText(MainActivity.this,\n>                     \"test\",\n>                     Toast.LENGTH_LONG).show();\n>             }\n> \n> ```\n>     }\n> });\n> ```\n> \n> when click btn first time ,the scan() also not invok\n> \n> —\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly or view it on GitHub\n"
      },
      {
        "user": "carl1990",
        "created_at": "2016-04-11T08:30:58Z",
        "body": "Thanks ,is mean the `scan` overload  is a feature not a bug?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-17T20:21:05Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 3844,
    "title": "delaySubscription(Observable) breaks upstream unsubscription",
    "created_at": "2016-04-08T18:26:09Z",
    "closed_at": "2016-04-09T08:44:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3844",
    "body": "This test case is failing (tested with 1.1.2):\n\n``` java\n  @Test\n  public void testWithSubjects() {\n    PublishSubject<Integer> delayUntil = PublishSubject.create();\n    PublishSubject<Integer> interrupt = PublishSubject.create();\n    final AtomicBoolean subscribed = new AtomicBoolean(false);\n\n    Observable.just(1)\n        .doOnSubscribe(() -> subscribed.set(true))\n        .delaySubscription(delayUntil)\n        .takeUntil(interrupt)\n        .subscribe();\n\n    interrupt.onNext(9000);\n    delayUntil.onNext(1);\n\n    assertFalse(subscribed.get());\n  }\n\n```\n\nI stumbled upon this using `Completable.andThen` (which delegates to `delaySubscription`).\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3844/comments",
    "author": "hannesstruss",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T18:31:47Z",
        "body": "TakeUntil subscribes to its source before the subscription to upstream could happen. This is partly due to how `lift` works and partly to allow interrupting a synchronous source as it would otherwise possibly rush through without letting the operator subscribe to the until source.\n"
      },
      {
        "user": "hannesstruss",
        "created_at": "2016-04-08T19:02:22Z",
        "body": "In other words, `takeUntil` only guarantees to suppress emission of items given a condition, but does not guarantee what happens upstream?\n\n(I was confused, as the analogous example with time based `delaySubscription` works:)\n\n``` java\n  @Test\n  public void testWithSubjects() {\n    PublishSubject<Integer> interrupt = PublishSubject.create();\n    final AtomicBoolean subscribed = new AtomicBoolean(false);\n    TestScheduler testScheduler = new TestScheduler();\n\n    Observable.just(1)\n        .doOnSubscribe(() -> subscribed.set(true))\n        .delaySubscription(1, TimeUnit.SECONDS, testScheduler)\n        .takeUntil(interrupt)\n        .subscribe();\n\n    interrupt.onNext(9000);\n    testScheduler.advanceTimeBy(1, TimeUnit.SECONDS);\n\n    assertFalse(subscribed.get());\n  }\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T19:22:34Z",
        "body": "Interesting. The second case shouldn't pass either. I'll investigate.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T19:41:58Z",
        "body": "Okay, I was wrong. Both tests should pass because they verify that the subscription doesn't happen - as expected. There is a bug in the non-timed `delaySubscription` that doesn't propagate the unsubscription properly. I'll post a PR to fix that.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T19:57:05Z",
        "body": "Fix posted: #3845\n"
      },
      {
        "user": "hannesstruss",
        "created_at": "2016-04-09T08:44:57Z",
        "body": "This works in 1.1.3, thanks so much! ✨ \n"
      }
    ]
  },
  {
    "number": 3843,
    "title": "Unexpected behavior",
    "created_at": "2016-04-08T05:57:48Z",
    "closed_at": "2016-04-08T08:57:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3843",
    "body": "``` java\nimport rx.Observable;\n\npublic class RxTest {\n\n    public static void main(String[] args) {\n        Observable.<String>create(subscriber -> {\n            subscriber.onNext(\"as\");\n            subscriber.onNext(\"asd\");\n        })\n                .map(s -> {\n                    if (s.length() < 3) {\n                        throw new RuntimeException(\"\");\n                    }\n                    return 1;\n                })\n                .flatMap(o -> {\n                    System.out.println(\"flatMap\");\n                    return Observable.just(true);\n                })\n                .subscribe(System.out::println, t -> {});\n    }\n}\n```\n\nOutput:\n\n```\nflatMap\n```\n\nBut, if we comment line with `throw new RuntimeException(\"\")` output will be:\n\n```\nflatMap\ntrue\nflatMap\ntrue\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3843/comments",
    "author": "nikialeksey",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T07:11:33Z",
        "body": "This is the expected behavior. `map` crashes and `flatMap` is skipped.\n"
      },
      {
        "user": "nikialeksey",
        "created_at": "2016-04-08T07:56:37Z",
        "body": "Wow! Be careful:\n1. emit \"as\": `throw` -> `flatMap` is skiped\n2. emit \"asd\": go to `flatMap`, output `\"flatMap\"`, but where is output in `subscribe`?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T08:10:31Z",
        "body": "The problem is that your `create` ignores unsubscription and thus violates the `Observable` contract. If you add \n\n``` java\n     if (subscriber.isUnsubscribed()) return;\n```\n\nin between the two calls to `onNext`, nothing is printed.\n"
      },
      {
        "user": "nikialeksey",
        "created_at": "2016-04-08T08:57:41Z",
        "body": "Oh! Thank you for explanation!\n"
      },
      {
        "user": "adipascu",
        "created_at": "2016-04-08T09:05:50Z",
        "body": "@akarnokd can the observable be unsubscribed on a different thread ? Can it get unsubscribed after the check to isUnsubscribed is done but before calling onNext?\n"
      }
    ]
  },
  {
    "number": 3833,
    "title": "OperatorSwitch Backpressure",
    "created_at": "2016-04-05T15:57:11Z",
    "closed_at": "2016-04-05T17:43:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3833",
    "body": "Debugging an issue with `switchMap` led me to reviewing the `OperatorSwitch` code. I think it might be wrong in its approach on backpressure (at least when used as `switchMap`), but before attempting code wanted to discuss conceptually. (Note that I have not considered `switchOnNext` or `switchOnEmpty` where the current approach may be fine.)\n\nRight now it appears to pass-thru the `requestN` value from downstream to the upstream. This doesn't seem correct for a `switchMap` case. Instead I think it should be have as follows:\n- request 2 on initial subscribe\n- map starts on first received onNext\n- downstream `request(n)` is propagated to the inner Observable\n- onNext invoked a second time with new Observable\n- request(1) upwards to allow the upstream to send a new Observable\n- propagate remaining `request(n)` from downstream to the new inner\n\nIn other words, quite similar to how `concatMap` works for maintaining the `request(n)` value across inner Observables, except that it unsubscribes the previous inner on receiving a new Observable. \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3833/comments",
    "author": "benjchristensen",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2016-04-05T15:57:34Z",
        "body": "cc @jspahrsummers\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-05T16:15:11Z",
        "body": "The `OperatorSwitch` does unbounded-in on the outer `Observable` but keeps track of the emission from each inner `Observable`. When the switch happens, all unfulfilled request will be forwarded to the new inner `Observable`.\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2016-04-05T17:02:43Z",
        "body": "That's not the behavior I'm seeing. Looks like I need to create a unit test. \n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2016-04-05T17:43:54Z",
        "body": "... and of course can't reproduce in a simple unit test. Confusing bloody bug. I'll re-open another legit issue if I can track it down. \n\nThanks @akarnokd \n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-05T21:10:41Z",
        "body": "Could you share a little bit more about your issue? What operators were involved? Was heavy switching involved with async sources or consumption?\n"
      }
    ]
  },
  {
    "number": 3813,
    "title": "OnSubscribeCombineLatest#MultiSourceProducer request method get different result?",
    "created_at": "2016-03-31T09:17:24Z",
    "closed_at": "2016-04-02T23:13:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3813",
    "body": "In request method,there is a line code ':o.unsafeSubscribe(s);' and I find the unsafeSubscribe()'s note is 'Subscribes to an Observable and invokes {@link OnSubscribe} function without any contract protection,error handling, unsubscribe, or execution hooks.'.\nThis is my code:\n\n``` java\nObservable<Long> observable1 = Observable.interval(0, 1000, TimeUnit.MILLISECONDS)\n                    .map(new Func1<Long, Long>() {\n                        @Override\n                        public Long call(Long aLong) {\n                            return aLong * 5;\n                        }\n                    }).take(5);\n            Observable<Long> observable2 = Observable.interval(500, 1500, TimeUnit.MILLISECONDS)\n                    .map(new Func1<Long, Long>() {\n                        @Override\n                        public Long call(Long aLong) {\n                            return aLong * 10;\n                        }\n                    }).take(4);\n            Observable.combineLatest(observable2, observable1, new Func2<Long, Long, Long>() {\n                @Override\n                public Long call(Long aLong, Long aLong2) {\n                    Log.i(\"ppppp\", \"combineLatest aLong = \" + aLong + \"   aLong2 =\" + aLong2);\n                    return aLong + aLong2;\n                }\n            }).subscribe(new Subscriber<Long>() {\n                @Override\n                public void onCompleted() {\n                    System.out.println(\"Sequence complete.\");\n                }\n                @Override\n                public void onError(Throwable e) {\n                    System.err.println(\"Error: \" + e.getMessage());\n                }\n                @Override\n                public void onNext(Long aLong) {\n                    System.out.println(\"combineLatest Next: \" + aLong);\n                }\n            });\n```\n\nI run this code and get two different results.\n(1)\n Next: 0\n Next: 5\n Next: 10\n Next: 20\n Next: 25\n Next: 35\n Next: 40\n Next: 50\n(2)\n Next: 0\n Next: 5\n Next: 15\n Next: 20\n Next: 25\n Next: 35\n Next: 40\n Next: 50\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3813/comments",
    "author": "fanturbo",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-31T14:23:08Z",
        "body": "You have two intervals which will fire together at t = 2000 ms where there is no guarantee which will arrive first to the sum in combineLatest.\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-04-01T01:37:30Z",
        "body": "@akarnokd thanks.I want to ask another question.combineLatest opreator's explanation is 'Combines a collection of source Observables by emitting an item that aggregates the latest values of **each of the source Observables each time an item is received from any of the source Observables**, where this aggregation is defined by a specified function.‘.\nWhen observable1 emit the first item,and the observable2 doesn't emit the first item,why the Combines don't emit the result?In my code I think it should print this:\nNext: 0\nNext: 0\nNext: 5\nNext: 15\nNext: 20\nNext: 25\nNext: 35\nNext: 40\nNext: 50\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-01T06:54:04Z",
        "body": "By definition, combineLatest emits only when all sources have emitted at least one item. Otherwise you wouldn't have a full row of values to work with.\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-04-01T08:00:53Z",
        "body": "In other words, combineLatest emits when all sources have emiited at least one item,and then if one of source Observables emits an item, the Combines will emits their results?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-01T08:08:24Z",
        "body": "If you have a full row, that is the first time the combiner function is called.\n\n``` java\nPublishSubject<String> a = PublishSubject.create();\nPublishSubject<String> b = PublishSubject.create();\nPublishSubject<String> c = PublishSubject.create();\n\nObservable.combineLatest(a, b, c, (u, v, w) -> u + v + w).subscribe(System.out::println);\n\na.onNext(\"1\");\nb.onNext(\"1\");\na.onNext(\"2\");\nb.onNext(\"2\");\nb.onNext(\"3\");\nSystem.out.println(\"Full row:\");\nc.onNext(\"1\");\n```\n\nIt will print\n\n```\nFull row:\n231\n```\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-04-01T08:39:22Z",
        "body": "@akarnokd thanks for your reply.Your sample is awesome.(ps:Did you find my english is very poor? )\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-02T23:13:22Z",
        "body": "It was readable.\n"
      }
    ]
  },
  {
    "number": 3811,
    "title": "About Subscriber",
    "created_at": "2016-03-30T10:25:44Z",
    "closed_at": "2016-04-02T23:13:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3811",
    "body": "When I watch the source code of operators, I found that in order to keep the unsubscribe chain, the parent subscriber always created by two way:\n\n```\nSubscriber<T> parent = new Subscriber(child){ ... };\n```\n\nor\n\n```\nSubscriber<T> parent = new Subscriber{ ... };\nchild.add(parent);\n```\n\nI know that the first one can pass through the producer.\nAnd, What else can decide the choosing? \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3811/comments",
    "author": "dieyidezui",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-30T10:36:31Z",
        "body": "If the parent may issue `unsubscribe` on its own, you have to chose the second pattern because otherwise the call may go downstream and cause trouble.\n"
      },
      {
        "user": "dieyidezui",
        "created_at": "2016-03-30T10:39:38Z",
        "body": "@akarnokd Thanks a lot.It is really helpful.\n"
      }
    ]
  },
  {
    "number": 3802,
    "title": "OperatorWithLatestFrom",
    "created_at": "2016-03-28T03:10:05Z",
    "closed_at": "2016-05-05T07:40:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3802",
    "body": "Here is some code in  OperatorWithLatestFrom.java.\nI feel a little puzzled.if(o == EMPTY), we do nothing.\nWhy not add a sentence like `request(1)` to support backpressure.\n\n```\n        public void onNext(T t) {\n            Object o = current.get();\n            if (o != EMPTY) {\n                try {\n                    @SuppressWarnings(\"unchecked\")\n                    U u = (U)o;\n                    R result = resultSelector.call(t, u);\n\n                    s.onNext(result);\n                } catch (Throwable e) {\n                    Exceptions.throwOrReport(e, this);\n                }\n            }\n        }\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3802/comments",
    "author": "dieyidezui",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-28T08:05:07Z",
        "body": "Because that's what `combineLatest` does. This operator allows the other stream to whizz through and just get the latest whenever the main sequence fires.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-05T07:40:32Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 3801,
    "title": "PublishSubject: OnNext Not delivered or OnNext delivered on wrong Thread",
    "created_at": "2016-03-27T20:58:37Z",
    "closed_at": "2016-03-27T21:36:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3801",
    "body": "I was writing some automated test to verify the behaviour of PublishSubject and I noticed strange and unexpected behaviour when the subject is subscribed on a Scheduler. If I do not put a sleep after the subscriber, I will not get the onNext items but the onCompleted is called on the correct Thread. If I put a sleep after subscribing, the subscriber receives the onNext items but on the wrong thread. It receives the onNext items on the thread that called the subject.onNext.\n\nI wrote some unit test to show the behaviour. Both tests will fail with rxjava 1.1.2. Is this a bug or is this expected behavior and where can I find this in the documentation? \n\n``` java\nimport org.junit.Test;\nimport rx.observers.TestSubscriber;\nimport rx.subjects.PublishSubject;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static rx.schedulers.Schedulers.newThread;\n\npublic class PublishSubjectTest {\n\n    @Test\n    public void subscribeOn_WhenNoSleep_ThenNoOnNextReceived() throws InterruptedException {\n\n        // GIVEN\n        PublishSubject<String> subject = PublishSubject.create();\n        Thread currentThread = Thread.currentThread();\n        TestSubscriber<String> subscriber = new TestSubscriber<>();\n\n        // WHEN\n        subject.subscribeOn(newThread()).subscribe(subscriber);\n        subject.onNext(\"one\");\n        subject.onCompleted();\n\n        // THEN\n        subscriber.awaitTerminalEvent();\n        assertThat(subscriber.getLastSeenThread()).isNotSameAs(currentThread);\n        assertThat(subscriber.getOnNextEvents()).containsOnly(\"one\");\n\n    }\n\n    @Test\n    public void subscribeOn_WhenSleep_ThenOnNextReceivedButOnWrongThread() throws InterruptedException {\n\n        // GIVEN\n        PublishSubject<String> subject = PublishSubject.create();\n        Thread currentThread = Thread.currentThread();\n        TestSubscriber<String> subscriber = new TestSubscriber<>();\n\n        // WHEN\n        subject.subscribeOn(newThread()).subscribe(subscriber);\n        Thread.sleep(2000);\n        subject.onNext(\"one\");\n        subject.onCompleted();\n\n        // THEN\n        subscriber.awaitTerminalEvent();\n        assertThat(subscriber.getOnNextEvents()).containsOnly(\"one\");\n        assertThat(subscriber.getLastSeenThread()).isNotSameAs(currentThread);\n\n    }\n\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3801/comments",
    "author": "bdeneuter",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-27T21:14:05Z",
        "body": "The problem is that you use `subscribeOn` instead of `observeOn` to move the delivery of events to another thread. When you `subscribeOn`, that delays the real subscription to `PublishSubject` by some amount, giving enough time to `onNext` to be observed by no one. You see only `onCompleted` because `PublishSubject` replays the terminal event to late `Subscriber`s.\n"
      },
      {
        "user": "bdeneuter",
        "created_at": "2016-03-27T21:30:20Z",
        "body": "Thx David,\n\nIndeed, observeOn seems to solve the behaviour I was seeing. With subsribeOn and waiting long enough for the subscription to succeed, can you also explain why the terminal event is delivered on the main thread and not on the scheduler thread?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-27T21:35:01Z",
        "body": "You are racing with the subscription and by chance, it is possible the subscription happens in time for onComplete to pass through directly to the Subscriber.\n"
      },
      {
        "user": "bdelville",
        "created_at": "2018-07-17T00:52:10Z",
        "body": "Hi\r\n\r\nI am not sure about the racing condition explanation, because I can reproduce it with a BehaviorSubject too (with onNext() called after subscription and timer before it)\r\n\r\n```\r\n@Test\r\n  public void testSubjectThreadFollowSubscribeOn() {\r\n    TestObserver<String> tester = new TestObserver<>();\r\n    BehaviorSubject<Integer> source = BehaviorSubject.create();\r\n    String currentThread = Thread.currentThread().getName();\r\n\r\n    source\r\n        .subscribeOn(Schedulers.io())\r\n        .take(1)\r\n        .map(o -> Thread.currentThread().getName())\r\n        .subscribe(tester);\r\n    source.onNext(1);\r\n\r\n    tester.awaitCount(1);\r\n    tester.assertValue(threadAfterSubscribeOn -> !threadAfterSubscribeOn.equals(currentThread));\r\n}\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-07-17T06:37:04Z",
        "body": "You still have a race where onNext could find an already subscribed observer and signal the first item on the test thread."
      }
    ]
  },
  {
    "number": 3800,
    "title": "OperatorToObservableSet",
    "created_at": "2016-03-27T12:09:45Z",
    "closed_at": "2016-05-05T07:40:55Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3800",
    "body": "Consider the use case of getting a unique collection of events. Currently I'm doing something like that:\n\n``` java\no.distinct().toList();\n```\n\nor even\n\n``` java\no.distinct().toList().map(list -> new HashSet<>(list));\n```\n\n`distinct` allocates a `HashSet` with all the items, `toList` creates a `LinkedList` which is later transformed into `ArrayList`. I would be more performant if we get pass the HashSet in the first place.\n\nBesides, in most cases I would prefer receiving a `Set` not a list of unique items.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3800/comments",
    "author": "defHLT",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-27T14:07:58Z",
        "body": "We have the `collect` operator for this. \n"
      },
      {
        "user": "wendigo",
        "created_at": "2016-03-27T15:53:05Z",
        "body": "`observable.collect(HashSet::new, Set::add)`\n"
      },
      {
        "user": "defHLT",
        "created_at": "2016-03-27T17:34:06Z",
        "body": "True! Then I wonder why `toList` is not implemented in terms of `OperatorScan` + `last`. `toList` seems to be faster.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-27T17:48:09Z",
        "body": "The current implementation of toList exploits the underlying structure of the data collection problem to be more efficient.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-05T07:40:55Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 3788,
    "title": "toList() does not work",
    "created_at": "2016-03-22T07:48:05Z",
    "closed_at": "2016-03-22T10:36:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3788",
    "body": "I have one Observable below . \n\n```\nComApi.getInstance().getRegionList().compose(RxUtil.background())\n                .filter(resRegionModel -> resRegionModel != null)\n                .map(ResRegionsModel::getData)\n                .flatMap(Observable::from)\n                .filter(dataEntity -> dataEntity != null)\n                .map(this::convert)\n                .doOnNext(adapter::replaceWith)  // this can work, it will receive data one by one.\n                .toList()\n                .doOnNext(adapter::replaceWith) // but this callback will not be called .while after toList()..it can \n                                                                      // not receive data by once. \n                .doOnError(Throwable::printStackTrace)\n                .subscribe();\n```\n\nthis is my first catch problem while I using toList(). I don't know how to fix this issue.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3788/comments",
    "author": "sharyuke",
    "comments": [
      {
        "user": "sharyuke",
        "created_at": "2016-03-22T07:57:02Z",
        "body": "```\n\n    /**\n     * 获取区域列表\n     *\n     * @return 区域列表\n     */\n    public Observable<ResRegionsModel> getRegionList() {\n        return Observable.create(subscriber -> subscriber.add(mComInterface.getRegionList(IndoorunSDKDataCenter.APP_KEY_VALUE,\n                IndoorunSDKDataCenter.getInstance().getPhoneUUID(), IndoorunSDKDataCenter.SESSION_KEY_VALUE, \"1\")\n                .doOnNext(resRegionModel -> {\n                    if (resRegionModel != null && resRegionModel.isSuccess()) {\n                        subscriber.add(Observable.just(resRegionModel.getData())\n                                .doOnNext(TableRegionDao.getInstance()::syncInsert)\n                                .flatMap(Observable::from)\n                                .filter(dataEntity -> dataEntity.getFloorList() != null)\n                                .flatMap(dataEntity2 -> Observable.from(dataEntity2.getFloorList()))\n                                .toList()\n                                .flatMap(TableRegionFloorDao.getInstance()::insert)\n                                .onErrorResumeNext(Observable.empty())\n                                .compose(background())\n                                .subscribe());\n                    }\n                })\n                .doOnNext(subscriber::onNext)\n                .compose(background())\n                .subscribe()));\n    }\n\n```\n\nthis is ComApi.getInstance().getRegionList() method. \n"
      },
      {
        "user": "sharyuke",
        "created_at": "2016-03-22T08:01:00Z",
        "body": "when I change  ComApi.getInstance().getRegionList()  to this , and toList() worked. I want to know why\n\n```\n\n    /**\n     * 获取区域列表\n     *\n     * @return 区域列表\n     */\n    public Observable<ResRegionsModel> getRegionList() {\n        return mComInterface.getRegionList(IndoorunSDKDataCenter.APP_KEY_VALUE,\n                IndoorunSDKDataCenter.getInstance().getPhoneUUID(), IndoorunSDKDataCenter.SESSION_KEY_VALUE, \"1\")\n                .doOnNext(resRegionModel -> {\n                    if (resRegionModel != null && resRegionModel.isSuccess()) {\n                        Observable.just(resRegionModel.getData())\n                                .doOnNext(TableRegionDao.getInstance()::syncInsert)\n                                .flatMap(Observable::from)\n                                .filter(dataEntity -> dataEntity.getFloorList() != null)\n                                .flatMap(dataEntity2 -> Observable.from(dataEntity2.getFloorList()))\n                                .toList()\n                                .flatMap(TableRegionFloorDao.getInstance()::insert)\n                                .onErrorResumeNext(Observable.empty())\n                                .compose(background())\n                                .subscribe();\n                    }\n                })\n                .compose(background());\n    }\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-22T09:22:56Z",
        "body": "Something doesn't call `onCompleted`, but I can't tell what because you are using some unconventional dataflow structure.\n"
      },
      {
        "user": "sharyuke",
        "created_at": "2016-03-22T09:34:55Z",
        "body": "@akarnokd yes, it is custom Observable ,created by Observable.create(OnSubscriber subscriber), but I think it should work, and it worked actually until toList() method.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-22T10:10:53Z",
        "body": "If you are using `create()`, you are at your own and you have to honor the contracts and expectations of operators. Operators can't know if you just forgot to call `onCompleted` or you never intended to do so. See `just`, `fromCallable` and `from` as alternatives to `create()`.\n"
      },
      {
        "user": "sharyuke",
        "created_at": "2016-03-22T10:15:17Z",
        "body": "Did You meaning I must call subscriber.onComplete() method? let me have a try.\n"
      },
      {
        "user": "sharyuke",
        "created_at": "2016-03-22T10:21:56Z",
        "body": "@akarnokd yes! You are right! it worked!!! thanks a lot !!!! \n"
      }
    ]
  },
  {
    "number": 3786,
    "title": "timeout eats exceptions",
    "created_at": "2016-03-21T09:51:29Z",
    "closed_at": "2016-03-21T16:16:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3786",
    "body": "If I have a custom Observable that published some exceptions in onError, chaining such observable with timeout(time, units, MyCustomTimeoutException()) hides exceptions that are sent by custom observable.\n\nSome example.\nSecurityException and IllegalArgumentException never reach my subscriber.\n\n```\nfun getLocation(): Observable<Location> {\n        return requestSingleLocation()\n                .subscribeOn(schedulers.loopedIo)\n                .timeout(LOCATION_REQUEST_TIMEOUT,\n                         TimeUnit.SECONDS,\n                         Observable.error(NetworkLocationTimeoutException()))\n                .first()\n    }\n\n    private fun requestSingleLocation(): Observable<Location> {\n        return Observable.create<Location> { subscriber ->\n\n            try {\n                val knownLocation = locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)\n                knownLocation?.apply {\n                    subscriber.onNext(this)\n                }\n\n                locationManager.requestSingleUpdate(LocationManager.NETWORK_PROVIDER, LocationChangedListener {\n                    subscriber.onNext(it)\n                    subscriber.onCompleted()\n                }, null)\n\n            } catch (securityException: SecurityException) {\n                subscriber.onError(securityException)\n            } catch (illegalArgumentException: IllegalArgumentException) {\n                subscriber.onError(illegalArgumentException)\n            }\n        }\n    }\n\n```\n\nFollowing test fails:\n\n```\n@Test\n    fun getLocationProcessesSecurityException() {\n        // given\n\n        val securityException = SecurityException()\n        given(locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)).willReturn(location)\n        given(locationManager.requestSingleUpdate(BDDMockito.anyString(), any(), any())).willThrow(securityException)\n        val testSubscriber = TestSubscriber<Location>()\n\n        // when\n        classToTest.getLocation().subscribe(testSubscriber)\n\n        // then\n        testSubscriber.assertError(securityException)\n    }\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3786/comments",
    "author": "AAverin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-21T10:58:37Z",
        "body": "This test works for me:\n\n``` java\n@Test\npublic void testErrorTimeout() {\n    TestSubscriber<Object> ts =  TestSubscriber.create();\n\n    SecurityException se = new SecurityException();\n    Observable.error(se)\n    .subscribeOn(Schedulers.io())\n    .timeout(1, TimeUnit.SECONDS, Observable.error(new TestException()))\n    .subscribe(ts)\n    ;\n\n    ts.awaitTerminalEvent();\n    ts.assertError(se);\n}\n```\n\nIt seems you did forget to await the terminal event and thus the test thread completes before the error is propagated.\n"
      },
      {
        "user": "AAverin",
        "created_at": "2016-03-21T12:06:43Z",
        "body": "Still getting No Errors message\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-21T12:11:00Z",
        "body": "Print out the content of `ts.getOnNextEvents()` list before asserting to see if the mocking of `requestSingleUpdate` didn't work (maybe it runs the body but only throws after it?).\n"
      },
      {
        "user": "AAverin",
        "created_at": "2016-03-21T12:19:56Z",
        "body": "I have modified your test example and made it fail\n\n```\n class TestClass {\n\n    }\n\n    @Test\n    fun testErrorTimeout() {\n        val ts: TestSubscriber<TestClass> = TestSubscriber.create()\n\n        val se = SecurityException()\n\n        Observable.merge(Observable.just(TestClass()), Observable.error(SecurityException())).first()\n                .subscribeOn(Schedulers.io())\n                .timeout(1, TimeUnit.SECONDS, Observable.error(NetworkLocationTimeoutException()))\n                .subscribe(ts)\n\n        ts.awaitTerminalEvent()\n        ts.assertError(se)\n    }\n```\n"
      },
      {
        "user": "AAverin",
        "created_at": "2016-03-21T12:20:10Z",
        "body": "Sorry, it's in Kotlin though\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-21T12:40:37Z",
        "body": "> first()\n> Returns an Observable that emits only the very first item emitted by the source Observable, or notifies of an NoSuchElementException if the source Observable is empty.\n\nThat also means it cuts any subsequent events, including errors.\n"
      },
      {
        "user": "AAverin",
        "created_at": "2016-03-21T12:41:58Z",
        "body": "Hmm. What I need is either a successful result - TestClass returned, or a custom error message.\nWithout .first() I will get both even in case of success because `timeout` will wait for subsequent events until timer runs out.\n"
      },
      {
        "user": "AAverin",
        "created_at": "2016-03-21T12:43:42Z",
        "body": "Ok, can confirm that sample test passes without `first()`.\nCan you suggest any other way of achieving desired result?\nThanks\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-21T12:55:18Z",
        "body": "I'm not sure what you want to achieve. Timeout should not even happen, unless `getLastKnownLocation` or `requestSingleLocation` really take a long time to return or throw.\n"
      },
      {
        "user": "AAverin",
        "created_at": "2016-03-21T12:59:26Z",
        "body": "Well, they can.\nUser may be in a bad connection place and these call can take a long time.\nI need to make sure that if they really take a long time - I get a custom exception to gracefully handle the case in the UI.\n\nImplementation with `first()` works in the UI - I correctly get either a success, or a custom exception in case of long response.\nBut I also need to cover this with tests, and looks like I may have a problem=)\nAnd looks like `first()` might be not a correct solution - if `getLastKnownLocation` will return valid result, but `requestSingleLocation` would throw an exception - my code will not get it\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-21T13:11:57Z",
        "body": "You mean the case when timeout happens before the `requestSingleLocation` throws?\n"
      },
      {
        "user": "AAverin",
        "created_at": "2016-03-21T13:16:00Z",
        "body": "`getLastKnownLocation` is a relatevely fast call and will just return null in case there is no last known location\n`requestSingleLocation`, on the other hand, can take a while.\n\nThe problem in my code is that I can't use `first()` at all - I will loose my updated location if there was a known location.\nSo I need a timeout() operator that will work only if there are no items emmited, but would not wait for subsequent items.\n\nRemoving the `first` will lead to a situation when I will get onNext() and then onError() from the timeout because there was no 2nd onNext event with new item - my observable isn't hot and is expected to emmit only single set of items, starting with some cached old result\n"
      },
      {
        "user": "AAverin",
        "created_at": "2016-03-21T15:45:00Z",
        "body": "Issue resolved, thanks for your help a lot!\nProblem was that I didn't call onCompleted() for my custom subscriber due to a small mistake in the code.\nonCompleted correctly unsubscribes timeout\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-21T16:16:46Z",
        "body": "Great to hear it!\n"
      }
    ]
  },
  {
    "number": 3776,
    "title": "Why does affect not calling subsciber.onCompleted() when applying operator observable.toList()?",
    "created_at": "2016-03-17T10:54:04Z",
    "closed_at": "2016-03-17T11:45:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3776",
    "body": "Hi!\n\nIf I create an observable using `Observable.create()` and I don’t call onCompleted on its `subscriber`, following chaining operation `toList()` does not get executed.\n\n``` java\nprivate Observable<List<String>> createObservable() {\n        return Observable.create(subscriber -> {\n                subscriber.onNext(\"\");\n                subscriber.onCompleted(); //if onCompleted is not called the operations chained after calling flatMapIterable() -> toList() do not execute\n            })\n            .map(string -> Arrays.asList(\"1\", \"2\", \"3\"));\n    }\n```\n\n``` java\ncreateObservable()\n                .flatMapIterable(strings -> strings)\n                .map(string -> string)\n                .toList()\n                .map(strings -> strings); //this line is not executed if the source observable does not call onCompleted()\n```\n\nIs this the expected behaviour?\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3776/comments",
    "author": "VictorAlbertos",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-17T10:57:12Z",
        "body": "Yes. `toList` gives you the complete list of all values, but it has to know when there are no more values. Without `onCompleted()` it can't know you forgot it or it got just delayed a bit.\n"
      },
      {
        "user": "VictorAlbertos",
        "created_at": "2016-03-17T10:58:03Z",
        "body": "Thanks!\n"
      }
    ]
  },
  {
    "number": 3770,
    "title": "when I use retryWhen (new RetryWithDelay (3,2000)) time",
    "created_at": "2016-03-15T07:13:14Z",
    "closed_at": "2016-03-15T10:33:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3770",
    "body": "Hello , when I use retryWhen (new RetryWithDelay (3,2000)) time , bindDialogLoading (progressDialog, psu) also followed repeated , resulting in dialog.show () is performed three times , is there any way you can solve this problem\n\n``` java\n Observable<LoginModel<User>> psu = postLoginResultUsecase.execute();\n            BindDialog.bindDialogLoading(progressDialog,psu).retryWhen(new RetryWithDelay(3,2000)).subscribe(new Subscriber<LoginModel<User>>() {\n                @Override\n                public void onStart() {\n                    super.onStart();\n                    Log.e(\"onStart=======\",\"==\");\n                }\n\n                @Override\n                public void onCompleted() {\n                    Log.e(\"onCompleted=======\",\"==\");\n                }\n\n                @Override\n                public void onError(Throwable e) {\n                    Log.e(\"Throwable=======\",\"===\");\n\n                }\n                @Override\n                public void onNext(LoginModel<User> userLoginModel) {\n                    System.out.println(userLoginModel);\n                    listener.onSuccess();\n                }\n            });\n```\n\n``` java\npublic class BindDialog {\n    public static final String TAG = \"BindDialog\";\n    public static final <T> Observable<T> bindDialogLoading(final Dialog dlg, final Observable<T> source) {\n        final Observable<T> o = source.observeOn(AndroidSchedulers.mainThread());\n        return o.lift(new Observable.Operator<T, T>() {\n            @Override\n            public Subscriber<? super T> call(final Subscriber<? super T> child) {\n                return new Subscriber<T>() {\n                    @Override\n                    public void onStart() {\n                        super.onStart();\n                        Log.e(\"onStart=======\",\"dialog show\");\n                        new Handler(Looper.getMainLooper()).post(new Runnable() {\n                            @Override\n                            public void run() {\n                                dlg.show();\n                                Log.e(\"onStart===\",\"dialog show\");\n                            }\n                        });\n                        child.onStart();\n                    }\n\n                    @Override\n                    public void onCompleted() {\n                        dlg.dismiss();\n                        Log.e(\"onCompleted===\",\"dialog dismiss\");\n\n                        child.onCompleted();\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        dlg.dismiss();\n                        Log.e(\"onError===\",\"dialog dismiss\");\n\n                        child.onError(e);\n                    }\n\n                    @Override\n                    public void onNext(T t) {\n                        Log.e(\"onNext===\",\"dialog dismiss\");\n                        dlg.dismiss(); // Dismiss dialog or update it. Its depend your logic.\n                        child.onNext(t);\n                    }\n                };\n            }\n        });\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3770/comments",
    "author": "guoyoujin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-15T10:28:30Z",
        "body": "Just add a variable that remembers the `onStart` has been executed already.\n\n``` java\npublic static final <T> Observable<T> bindDialogLoading(final Dialog dlg, final Observable<T> source) {\n   final AtomicBoolean once = new AtomicBoolean();\n   // ...\n            @Override\n                    public void onStart() {\n                        if (!once.compareAndSet(false, true)) {\n                            return;\n                        }\n                       // ...\n```\n"
      },
      {
        "user": "guoyoujin",
        "created_at": "2016-03-15T10:33:21Z",
        "body": "@akarnokd ,Here is my solution would be to try your method\n\n```\n            BindDialog.bindDialogLoading(progressDialog, psu.retryWhen(new RetryWithDelay(3,2000))).subscribe(new Subscriber<LoginModel<User>>() {\n                @Override\n                public void onStart() {\n                    super.onStart();\n                }\n\n                @Override\n                public void onCompleted() {\n\n                }\n\n                @Override\n                public void onError(Throwable e) {\n\n                }\n\n                @Override\n                public void onNext(LoginModel<User> userLoginModel) {\n                    System.out.println(userLoginModel);\n                    listener.onSuccess();\n                }\n            });\n```\n"
      }
    ]
  },
  {
    "number": 3769,
    "title": "I would like to achieve a common dialog",
    "created_at": "2016-03-15T04:07:10Z",
    "closed_at": "2016-03-16T01:26:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3769",
    "body": "Hello I would like to achieve a common dialog, do not know how to achieve better, like the code below each had to re-write it again , which is not what I wanted\n\n``` java\npostLoginResultUsecase.execute().retryWhen(new RetryWithDelay(3,2000)).subscribe(new Subscriber<LoginModel<User>>() {\n                @Override\n                public void onStart() {\n                    super.onStart();\n                    progressDialog.show();\n                }\n\n                @Override\n                public void onCompleted() {\n                    progressDialog.dismiss();\n                }\n\n                @Override\n                public void onError(Throwable e) {\n                    progressDialog.dismiss();\n                }\n\n                @Override\n                public void onNext(LoginModel<User> userLoginModel) {\n                    System.out.println(userLoginModel);\n                    progressDialog.dismiss();\n                    listener.onSuccess();\n                }\n            });\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3769/comments",
    "author": "guoyoujin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-15T10:15:03Z",
        "body": "I don't understand what the problem is. Do you want this logic be type-independent?\n\n``` java\npublic static <T> void observe(Observable<T> o, Listener listener, Dialog progressDialog) {\n    o.retryWhen(new RetryWithDelay(3,2000)).subscribe(new Subscriber<T>() {\n                @Override\n                public void onStart() {\n                    super.onStart();\n                    progressDialog.show();\n                }\n\n                @Override\n                public void onCompleted() {\n                    progressDialog.dismiss();\n                }\n\n                @Override\n                public void onError(Throwable e) {\n                    progressDialog.dismiss();\n                }\n\n                @Override\n                public void onNext(T v) {\n                    System.out.println(v);\n                    progressDialog.dismiss();\n                    listener.onSuccess();\n                }\n            });\n}\n\nobserve(postLoginResultUsecase.execute(), listener, progressDialog);\n\nobserve(someRequest.execute(), listener, progressDialog);\n\nobserve(otherRequest.execute(), listener, progressDialog);\n```\n"
      },
      {
        "user": "guoyoujin",
        "created_at": "2016-03-15T10:25:19Z",
        "body": "@akarnokd Thank you，I have found a solution, may be my description of the problem is unclear , please forgive me ,This is the solution I found , can some advice\n\n```\npublic class BindDialog {\n    public static final String TAG = \"BindDialog\";\n    public static final <T> Observable<T> bindDialogLoading(final Dialog dlg, final Observable<T> source) {\n        final Observable<T> o = source.observeOn(AndroidSchedulers.mainThread());\n        return o.lift(new Observable.Operator<T, T>() {\n            @Override\n            public Subscriber<? super T> call(final Subscriber<? super T> child) {\n                return new Subscriber<T>() {\n                    @Override\n                    public void onStart() {\n                        super.onStart();\n                        Log.e(\"onStart=======\",\"dialog show\");\n                        new Handler(Looper.getMainLooper()).post(new Runnable() {\n                            @Override\n                            public void run() {\n                                dlg.show();\n                                Log.e(\"onStart===\",\"dialog show\");\n                            }\n                        });\n                        child.onStart();\n                    }\n                    @Override\n                    public void onCompleted() {\n                        dlg.dismiss();\n                        Log.e(\"onCompleted===\",\"dialog dismiss\");\n\n                        child.onCompleted();\n                    }\n                    @Override\n                    public void onError(Throwable e) {\n                        dlg.dismiss();\n                        Log.e(\"onError===\",\"dialog dismiss\");\n\n                        child.onError(e);\n                    }\n                    @Override\n                    public void onNext(T t) {\n                        Log.e(\"onNext===\",\"dialog dismiss\");\n                        dlg.dismiss(); // Dismiss dialog or update it. Its depend your logic.\n                        child.onNext(t);\n                    }\n                };\n            }\n        });\n    }\n}\n\n\nuse\n\n\n\nBindDialog.bindDialogLoading(progressDialog,postLoginResultUsecase.execute().retryWhen(new RetryWithDelay(3,2000))).subscribe(new Subscriber<LoginModel<User>>() {\n                @Override\n                public void onStart() {\n                    super.onStart();\n                }\n\n                @Override\n                public void onCompleted() {\n\n                }\n\n                @Override\n                public void onError(Throwable e) {\n\n                }\n\n                @Override\n                public void onNext(LoginModel<User> userLoginModel) {\n                    System.out.println(userLoginModel);\n                    listener.onSuccess();\n                }\n            });\n```\n"
      }
    ]
  },
  {
    "number": 3758,
    "title": "Threading in a SerializedSubject",
    "created_at": "2016-03-14T02:29:05Z",
    "closed_at": "2016-05-05T07:42:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3758",
    "body": "With usual `Observable`, the `Observer` is executed on the same thread as the one that the `Observable` is created. With `SerializedSubject`, there's some magic that is unclear. Below is the code snippet:\n\n``` scala\nobject Launcher extends App {\n  val pubSub = PublishSubject.create[Int]\n  val serSub = new SerializedSubject(pubSub)\n  val observable = Observable.just(1, 2).subscribeOn(Schedulers.computation())\n\n  serSub.subscribe(new Action1[Int] {\n    override def call(t: Int): Unit =\n      println(s\"Subject subscribeOn $t, ${Thread.currentThread().getName}\")\n  })\n\n  observable.subscribe(serSub)\n  Observable.just(6).subscribe(serSub)\n\n  while (true) {}\n}\n```\n\nOne would expect that the numbers 1 and 2 are printed inside some computation thread, and the 6 is printed inside main thread. Now, if I remove the `Observable.just(6)` line, everything is printed inside the computation thread. Is that the expected behavior? If so, how does the `SerializedSubject` decide which thread to run?\n\nNow, I can modify a code a bit (publish to pubSub and subscribe to serSub)\n\n``` scala\nobject Launcher extends App {\n  val pubSub = PublishSubject.create[Int]\n  val serSub = new SerializedSubject(pubSub)\n  val observable = Observable.just(1, 2).subscribeOn(Schedulers.computation())\n\n  serSub.subscribe(new Action1[Int] {\n    override def call(t: Int): Unit =\n      println(s\"Subject subscribeOn $t, ${Thread.currentThread().getName}\")\n  })\n\n  observable.subscribe(pubSub)\n  Observable.just(6, 7, 8, 9, 10).subscribe(pubSub)\n\n  while (true) {}\n}\n```\n\nthen things get printed in the expected thread. Is this the legit way to do it if I want this behavior?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3758/comments",
    "author": "a-reisberg",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2016-03-14T09:12:40Z",
        "body": "I'm not looking at the source code at the moment but I suspect my description won't be far off the mark.  When a thread A sends an item to a `PublishSubject` that item is added to a queue and if no drain loop is currently running on that queue (to emit the elements in the queue to all the subscribers of the `PublishSubject`) then the thread A runs the drain on the queue and will emit items on thread A. If thread B is currently running the drain loop then it will iterate through the queue items emitting them and eventually pop the element off the queue that thread A put there and emit it (on thread B).\n\nThus what you are seeing is a race to get the drain loop by the main thread and the computation thread.\n\nDoes that help?\n"
      },
      {
        "user": "a-reisberg",
        "created_at": "2016-03-14T14:09:50Z",
        "body": "@davidmoten Thanks a lot! But I'm still a bit confused. So essentially, I have\n\n```\nval pubSub = PublishSubject.create[Int]\nval serSub = new SerializedSubject(pubSub)\n```\n\nand all my actions are subscribed to `serSub`. Now, if I do `onNext` on `serSub` from two threads, it's always the case that everything gets invoked on just one of the thread, which is the behavior that you described. But if I do `onNext` on `pubSub` from two different threads, then the actions are executed in the correct thread.\n\nIt would be great to know if these are expected behaviors, and moreover, if the second way (`onNext` on `pubSub` but `subscribe` to `serSub`) is a legal way to use a `SerializedSubject`.\n\nThanks!!!\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-14T17:17:43Z",
        "body": "Calling `onNext` from multiple threads on a `PublishSubject` violates its contract. It's just coincidental that such call doesn't cause problems with the Subscriber downstream. If you want to stay on the \"correct\" thread, don't use a Subject but set up a sequence for each thread via `subscribeOn`.\n"
      },
      {
        "user": "a-reisberg",
        "created_at": "2016-03-14T18:25:34Z",
        "body": "@akarnokd Thanks for the reply. Just to confirm, calling `onNext` from multiple threads on a `PublishSubject` still violate the contract, even if I only subscribes to the `SerializedSubject`?\n\nCould you please explain more about what you mean by setting up a sequence for each thread?\n\nMy main goal was to create an `EventBus` using RxJava. Instead of using `Subject`, what should I use instead?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-14T18:36:32Z",
        "body": "> still violate the contract\n\nYes. SerializedSubject wraps the PublishSubject and makes sure concurrent calls to SerializedSubject.onNext are serialized into a single, likely hopping, thread thus `PublishSubject` will be driven by non-concurrent onNext calls.\n\nIf you can distingush between events, then you can have different receivers:\n\n``` java\nSubject<Integer, Integer> subject = PublishSubject.<Integer>create().toSerialized();\n\nObservable<Integer> odd = subject.filter(v -> v % 2 != 0).observeOn(Schedulers.io());\nObservable<Integer> even = subject.filter(v -> v % 2 == 0).observeOn(Schedulers.newThread());\n\nodd.subscribe(...);\neven.subscribe(...);\n```\n"
      },
      {
        "user": "a-reisberg",
        "created_at": "2016-03-14T20:27:07Z",
        "body": "@akarnokd That's a very helpful answer! I noticed that you are using `observeOn` in your example instead of `subscribeOn` (as you mentioned in the previous comment). Since `subscribeOn` usually changes the thread up in the stream, I would expect that it changes the thread where the `subject`'s `onNext` is called and hence, where the subscribed action is executed. However, when I play with it, `subscribeOn` doesn't actually affect anything. Is it because `SerializedSubject` doing some _serializing_ which makes `subscribeOn` useless? \n\nIn general, due to what @davidmoten said, the actual thread where things get executed (without using `observeOn` to modify it) is essentially only determined at run time. Is my understanding correct?\n\nThanks again!\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-14T20:40:58Z",
        "body": "There is a significant difference between `subscribeOn` and `observeOn`. Simply put, `subscribeOn` moves the subscription to another thread:\n\n``` java\nsubject.subscribe(...); // current thread\n\nexecutor.submit(() -> subject.subscribe(...)); // another thread\n```\n\n and `observeOn` moves the observation of onXXX calls to another thread:\n\n``` java\nsubscriber.onNext(...); // current thread\n\nexecutor.submit(() -> subscriber.onNext(...)); // other thread\n```\n"
      },
      {
        "user": "abersnaze",
        "created_at": "2016-03-14T22:21:34Z",
        "body": "I like describing them as if they were for loops.  `subscribeOn` as scheduling outside the for loop:\n`executor.submit( () -> for(item : items) { onNext(item); } )`\nand `observeOn` as scheduling inside the for loop:\n`for(item : items) { executor.submit( () -> onNext(item); } )`\n"
      },
      {
        "user": "a-reisberg",
        "created_at": "2016-03-14T23:55:49Z",
        "body": "@akarnokd and @abersnaze So usually, people say that `subscribeOn` changes the thread _upstream_, is it because things are evaluated lazily, when the for loop is inside the new thread, the items are evaluated on the new thread as well?\n\nSo now, back to my question about `SerializedSubject`. Due to some magic that `SerializedSubject` does, the actual thread where an `Action` (in `subject.subscribe(...)`) is executed is undetermined until real time right?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-02T23:21:11Z",
        "body": "If there is an emission race from multiple sources to a `SerializedSubject`, any of the participating thread may end up emitting to the subscriber's onNext method and keep emitting the other's values as well.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-05T07:42:23Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      },
      {
        "user": "tsxsandianshui",
        "created_at": "2016-05-05T07:44:03Z",
        "body": "what\n"
      }
    ]
  },
  {
    "number": 3748,
    "title": "replay().connect() does not complete on current thread",
    "created_at": "2016-03-11T13:10:57Z",
    "closed_at": "2016-03-11T14:14:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3748",
    "body": "This test case:\n\n``` java\n  @Test\n  public void test() {\n    final AtomicBoolean onNext = new AtomicBoolean(false);\n    final AtomicBoolean onCompleted = new AtomicBoolean(false);\n\n    Observable<String> o = Observable.just(\"Hallo\")\n        .doOnNext(new Action1<String>() {\n          @Override\n          public void call(String s) {\n            onNext.set(true);\n          }\n        })\n        .doOnCompleted(new Action0() {\n          @Override\n          public void call() {\n            onCompleted.set(true);\n          }\n        });\n\n    ConnectableObservable<String> connectable = o.replay();\n    connectable.connect();\n\n    assertTrue(onNext.get());\n    assertTrue(onCompleted.get());\n  }\n```\n\nstarted failing for me on the latest snapshot. `git bisect` says c925e860c01c30edc15c59c592c1d5e9b9777a90 is the first bad commit. `.publish()` is not affected.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3748/comments",
    "author": "hannesstruss",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-11T13:28:32Z",
        "body": "Previously, `just()` didn't support backpressure and emitted its value immediately after subscription. Now it waits for a proper downstream request which doesn't happen because `replay()` requests upstream only when there is a downstream request. Just add `connectable.subscribe()` to trigger `just()`.\n"
      },
      {
        "user": "hannesstruss",
        "created_at": "2016-03-11T14:14:19Z",
        "body": "@akarnokd Thanks for the explanation!\n"
      }
    ]
  },
  {
    "number": 3743,
    "title": "Caused by: rx.exceptions.MissingBackpressureException",
    "created_at": "2016-03-07T09:53:07Z",
    "closed_at": "2016-04-02T23:21:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3743",
    "body": "java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:60)\n    at android.os.Handler.handleCallback(Handler.java:733)\n    at android.os.Handler.dispatchMessage(Handler.java:95)\n    at android.os.Looper.loop(Looper.java:136)\n    at android.app.ActivityThread.main(ActivityThread.java:5315)\n    at java.lang.reflect.Method.invokeNative(Native Method)\n    at java.lang.reflect.Method.invoke(Method.java:515)\n    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:864)\n    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:680)\n    at dalvik.system.NativeStart.main(Native Method)\nCaused by: rx.exceptions.OnErrorNotImplementedException\n    at rx.Observable$27.onError(Observable.java:7535)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:154)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:111)\n    at rx.internal.operators.OperatorSubscribeOn$1$1$1.onError(OperatorSubscribeOn.java:71)\n    at rx.internal.operators.OperatorOnBackpressureDrop$2.onError(OperatorOnBackpressureDrop.java:76)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:197)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:170)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    ... 9 more\nCaused by: rx.exceptions.MissingBackpressureException\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext(OperatorObserveOn.java:138)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n    at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:51)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n    at java.lang.Thread.run(Thread.java:841)\nrx.exceptions.OnErrorNotImplementedException\n    at rx.Observable$27.onError(Observable.java:7535)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:154)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:111)\n    at rx.internal.operators.OperatorSubscribeOn$1$1$1.onError(OperatorSubscribeOn.java:71)\n    at rx.internal.operators.OperatorOnBackpressureDrop$2.onError(OperatorOnBackpressureDrop.java:76)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:197)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:170)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at android.os.Handler.handleCallback(Handler.java:733)\n    at android.os.Handler.dispatchMessage(Handler.java:95)\n    at android.os.Looper.loop(Looper.java:136)\n    at android.app.ActivityThread.main(ActivityThread.java:5315)\n    at java.lang.reflect.Method.invokeNative(Native Method)\n    at java.lang.reflect.Method.invoke(Method.java:515)\n    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:864)\n    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:680)\n    at dalvik.system.NativeStart.main(Native Method)\nCaused by: rx.exceptions.MissingBackpressureException\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext(OperatorObserveOn.java:138)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n    at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:51)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n    at java.lang.Thread.run(Thread.java:841)\nrx.exceptions.MissingBackpressureException\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext(OperatorObserveOn.java:138)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n    at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:51)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n    at java.lang.Thread.run(Thread.java:841)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3743/comments",
    "author": "itxuye",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-07T13:30:00Z",
        "body": "You applied the `onBackpressureDrop` at the wrong location. You should apply it just after `interval`.\n"
      },
      {
        "user": "itxuye",
        "created_at": "2016-03-08T01:58:45Z",
        "body": "@akarnokd Thanks for your answer. But i don‘t known what's wrong in my code.\n`Observable.timer(1, 1, TimeUnit.SECONDS)\n        .map(aLong -> calcLeftTime())\n        .observeOn(AndroidSchedulers.mainThread())\n        .onBackpressureDrop()\n        .subscribeOn(Schedulers.io())\n        .subscribe(new Action1<Long>() {\n          @Override public void call(Long aLong) {\n            if (aLong > 0) {\n              countTime.updateShow(aLong);\n            } else {\n              countTime.setVisibility(View.INVISIBLE);\n            }\n          }\n        }, Throwable::printStackTrace);`\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2016-03-08T02:03:26Z",
        "body": "@itxuye \n1. Apply `onBackpressureDrop()` after `timer()`\n2. You don't need `subscribeOn()` since `Observable.timer()` will run on `Schedulers.computation()` by default and you're not overriding it via `subscribeOn()`.\n"
      },
      {
        "user": "itxuye",
        "created_at": "2016-03-08T02:11:05Z",
        "body": "@artem-zinnatullin  Thanks.\n"
      },
      {
        "user": "abersnaze",
        "created_at": "2016-03-08T02:24:16Z",
        "body": "The reason is the observeOn is a producer/consumer queue between the timer and the work being done in the main thread. That queue is filling up because the producer is faster.\n"
      },
      {
        "user": "Kolyall",
        "created_at": "2016-09-06T09:01:10Z",
        "body": "@artem-zinnatullin Thanks.\n"
      }
    ]
  },
  {
    "number": 3739,
    "title": "SafeSubscriber.java the 141 line always throw the exception",
    "created_at": "2016-03-02T09:08:55Z",
    "closed_at": "2016-03-02T09:56:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3739",
    "body": "SafeSubscriber.java the 141 line always throw the nullpointexception\nthe actual'subscriber is null,but I don't know why\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3739/comments",
    "author": "petma",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-02T09:34:40Z",
        "body": "Do you have a code example to help us repoduce the problem?\n"
      },
      {
        "user": "petma",
        "created_at": "2016-03-02T09:54:00Z",
        "body": "I find out the reason:\n\n``` java\n  public Subscriber<Week> getSubscriber() {\n        return new Subscriber<Week>() {\n……\n          @Override\n            public void onNext(Week week) {\n                iView.setModel(week);\n                iView.setLoading(false);\n                if(week!=null) {\n                    onCompleted();\n                }\n\n            }  \n……\n}}\n```\n\nin Activity which implements iView.setModel<T>,I do this work:\n\n``` java\n @Override\n    public void setModel(Week week) {\n        if(week!=null) {\n            mSyllabusView.setWeek(week);\n            mSyllabusView.show();\n        }else{\n            times--;\n            if(times>0) {\n                syllabusPresenter.start();\n            }\n        }\n    }\n```\n\nand the really error is from  mSyllabusView.show(); this method throws a nullpoint exception.but It does't  evident in the console;\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-02T09:56:53Z",
        "body": "Great!\n"
      }
    ]
  },
  {
    "number": 3736,
    "title": "How to get filtered POJO when used getXXX()?",
    "created_at": "2016-02-27T03:44:59Z",
    "closed_at": "2016-04-11T08:05:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3736",
    "body": "```\n.flatMap(new Func1<Area, Observable<Store>>() {\n    @Override\n     public Observable<Store> call(Area area) {\n        return Observable.from(area.getStores());\n     }\n})\n.filter(new Func1<Store, Boolean>() {\n    @Override\n    public Boolean call(Store store) {\n        return store.getName().contains(text);\n    }\n})\n```\n\n> i want to get the filtered **Area**\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3736/comments",
    "author": "deviltsw",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2016-02-27T10:16:25Z",
        "body": "One way is to wrap every instance of Store with its Area:\n\n``` java\n.flatMap(area -> \n    Observable.from(area.getStores())\n        .map(store -> new Wrapper(area, store)))\n.filter(wrapper -> wrapper.store().getName().contains(text))\n.map(wrapper ->wrapper.area());\n```\n"
      },
      {
        "user": "kotucz",
        "created_at": "2016-02-27T10:20:16Z",
        "body": "or you could use this trick\n\n```\noa.flatMap(new Func1<Area, Observable<Area>>() {\n        @Override\n        public Observable<Area> call(final Area area) {\n            return Observable.from(area.getStores())\n                    .filter(new Func1<Store, Boolean>() {\n                        @Override\n                        public Boolean call(Store store) {\n                            return store.getName().contains(text);\n                        }\n                    })\n                    .map(new Func1<Store, Area>() {\n                        @Override\n                        public Area call(Store store) {\n                            return area;\n                        }\n                    });\n        }\n    });\n```\n\nbut you maybe do not need to wrap Stores in the `Observable` so this should be fine too\n\n```\noa.filter(new Func1<Area, Boolean>() {\n        @Override\n        public Boolean call(Area area) {\n            return areaHasStoreWithText(area, text);\n        }\n    });\n```\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2016-02-27T10:42:16Z",
        "body": "One thing to note is that my suggestion and @kotucz first suggestion both potentially produce multiple copies of `Area` so you might want to use `.distinct()`.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-02T23:22:53Z",
        "body": "@deviltsw Are the answers satisfactory?\n"
      },
      {
        "user": "deviltsw",
        "created_at": "2016-04-11T08:05:13Z",
        "body": "@akarnokd yes.\n"
      }
    ]
  },
  {
    "number": 3735,
    "title": "observable.toBlocking().toFuture().get(timeout, timeUnit) does not timeout",
    "created_at": "2016-02-25T10:10:53Z",
    "closed_at": "2016-03-14T01:25:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3735",
    "body": "The use case is pretty simple. Am I getting something wrong or is this a bug ? \n\n```\ndef observable = Observable.from(new CompletableFuture()) // never completes\nobservable.toBlocking().toFuture().get(1, TimeUnit.SECONDS) // never completes either\n```\n\nThis should throw a TimeoutException after a second but actually blocks forever.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3735/comments",
    "author": "prismec",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-02-25T10:27:30Z",
        "body": "Observing a Future blocks the current thread so when you call `get()` it blocks further up and never gets to the timeout part. This is why there is an overload of `from(Future, long, TimeUnit)` to timeout directly with a future. Now since RxJava is Java 6. It doesn't know about `CompletableFuture` so can't utilize its non-blocking continuation style API that would otherwise allow the `get()` to timeout.\n\nYou can apply `.subscribeOn(Schedulers.io())` to make that first blocking wait happen on a different thread so your main thead is free to wait for the get with timeout.\n"
      },
      {
        "user": "prismec",
        "created_at": "2016-02-25T11:48:57Z",
        "body": "Thanks! \n\nIt could be worth a consideration to support Java 8 Futures in RxJava ?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-02-25T11:54:32Z",
        "body": "Oh sorry, I wrote the wrong version number. As it seems, both RxJava 1 and 2 are set out to remain Java **6** compatible and thus we can't really support those newer APIs in the core library. Your best bet is to find some other library and conversions or write the necessary source operator yourself.\n"
      }
    ]
  },
  {
    "number": 3730,
    "title": "Request: Completable.andThen(Single)",
    "created_at": "2016-02-24T13:44:32Z",
    "closed_at": "2016-05-05T07:43:01Z",
    "labels": [
      "Question",
      "Feature-Request",
      "PR welcome"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3730",
    "body": "To match `Completable#andThen(Observable<T> next)` it would be nice if there were an operator like this:\n\n```\npublic <T> Single<T> andThen(Single<T> next)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3730/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-02-24T17:47:20Z",
        "body": "I don't know, do you want the next's value replace the first's value?\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-02-24T17:50:08Z",
        "body": "There is no first value because the method is on `Completable`. It's essentially a `flatMap`.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-02-24T18:01:35Z",
        "body": "Right, didn't connect `Completable`. I don't see any problem with such an overload. PRs are welcome.\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-02-24T18:13:31Z",
        "body": "I'll probably give it a go this weekend if no-one else has started.\n"
      },
      {
        "user": "stevegury",
        "created_at": "2016-02-24T18:17:47Z",
        "body": "Sounds good, glad to review a PR.\n"
      },
      {
        "user": "geralt-encore",
        "created_at": "2016-03-05T19:51:23Z",
        "body": "Will implementation be just like:\n\n```\n    public final <T> Single<T> andThen(Single<T> next) {\n        requireNonNull(next);\n        return next.toObservable().delaySubscription(toObservable()).toSingle();\n    }\n```\n\nOr is it a bad practice to use these wrappers internally?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-08T10:11:04Z",
        "body": "If you took the time and implement this operator directly, that would be great.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-05T07:43:01Z",
        "body": "Closing via #3799\n"
      }
    ]
  },
  {
    "number": 3728,
    "title": "Data emitted from Observer does not trigger the Subscriber. ",
    "created_at": "2016-02-24T10:49:18Z",
    "closed_at": "2016-04-02T23:25:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3728",
    "body": "We have a scenario, where in we switch off the BLE Enabled device and then the Android App screen shall grey out. But when the switch off the BLE Enabled device,\ninstead of Greying out, the screen remains freezed and UI does not respond\nNone of the methods like onNext(), onCompleted() and onError() in the subscriber are called after executing the Observable.\n\n``` java\nprivate void subscribeToConnEvents() {           \n Subscriber<ConnService.ConnEvent> subscriber = new Subscriber<ConnService.ConnEvent>() {\n  @Override \n  public void onCompleted() {\n            }         \n     @Override            \n public void onError(Throwable e) {              }         \n     @Override           \n  public void onNext(ConnService.ConnEvent connEvent) {                              }       \n  };        \n SerializedSubscriber<ConnService.ConnEvent> serializedSubscriber = \n     new SerializedSubscriber<>(subscriber);             \n }\n```\n\nBelow is the Observable code from which the subscriber shall be called:\n\nIn the Below Code the connectionStateSubject gets initialized in the Constructor\n\n``` java\nprivate SerializedSubject<ConnEvent, ConnEvent> connectionStateSubject;\n\npublic void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {\n    super.onConnectionStateChange(gatt, status, newState);     \nBluetoothDevice device = gatt.getDevice();     \nString address = gatt.getDevice().getAddress();     \nConnectionEvent event = new ConnectionEvent();     \nevent.deviceAddress = address;   \n   if (newState == BluetoothProfile.STATE_DISCONNECTED) {\n       event.status = ConnectionStatus.STATE_DISCONNECTED;\nconnectionStateSubject.onNext(event);                 \n//edit.putInt(\"conn\",0).commit();  \n   } }\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3728/comments",
    "author": "ram115880",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-02-24T11:27:21Z",
        "body": "Could you revise your question, the examples don't make any sense to me at the moment.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-02T23:25:39Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 3725,
    "title": "ArrayIndexOutOfBoundsException caused by ReplaySubject.java:459 in ArrayList",
    "created_at": "2016-02-22T23:33:43Z",
    "closed_at": "2016-04-02T23:24:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3725",
    "body": "I wrote some testcode that causes an `ArrayIndexOutOfBoundsException` on almost every run and i do not understand why, how to avoid it or if this is a bug in (rx)java.\n\nThe exception is thrown in `ArrayList#add(E e)` by calling `elementData[size++] = e;` where a call of `ensureCapacityInternal(size+1)` should have made sure that the capacity is sufficient. I assume some concurrency-related problem.\n\nWhat the code was intended to do:  Start a new \"WorkerThread\" every second that produces Strings at a given rate and collect the resulting items of all those workers (here called \"Minions\") in one re-playable `Observable<String>`. \nThe actual parameters are just set to increase probability of this exception to be thrown.\n\n``` java\npackage mypackage;\n\nimport rx.Observable;\nimport rx.Scheduler;\nimport rx.observables.ConnectableObservable;\nimport rx.schedulers.Schedulers;\nimport rx.subjects.ReplaySubject;\n\nimport java.util.Iterator;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestOutOfBounds {\n\n    public static void main(String... args) throws InterruptedException {\n        boolean exitAfterIdling = false;\n        boolean spamConsole = false;\n\n        ConnectableObservable<String> someWorker = makeWorker(\"Some Worker\", 1000, Schedulers.newThread(), 5); //Sends one Item per second, and finishes after 5 items\n\n        /* Everything runs fine with these values\n        //Milliseconds our workers will take for each item\n        long minionDelay = 500;\n        //how many items each worker produces\n        int minionWorkload = 5;\n        */\n\n        //Problems start here\n        //FIXME: ArrayIndexOutOfBoundsException with these values\n        //Milliseconds our workers will take for each item\n        long minionDelay = 1;\n        //how many items each worker produces\n        int minionWorkload = 50000;\n\n\n        ConnectableObservable<ConnectableObservable<String>> minions =\n                Observable.range(0, 20) //make 20 minions\n                        .map(i -> makeWorker(\"Minion \" + i, minionDelay, Schedulers.newThread(), minionWorkload))//map number to minion instances\n                        .subscribeOn(Schedulers.newThread())\n                        .replay(); //make sure we dont loose any\n\n\n        final ReplaySubject<String> minionOutput = ReplaySubject.create();\n\n        minions.subscribe(minion -> {\n            //forward all items to the ReplaySubject\n            minion.subscribe(minionOutput::onNext);\n        });\n\n        //start one per second\n        minions.subscribe(minion -> {\n            try {\n                //We want to simmulate some setup time/latency;\n                //So we connect one per second\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"Connecting a Minion\");\n            minion.connect();\n        });\n\n        //\"merging items emmitted of someWorker and our minions;\n        Observable<String> allWork = Observable.merge(someWorker, minionOutput);\n        //make it replayable to make sure we do not loose items and have it wait for connection\n        ConnectableObservable<String> replayableWork = allWork.replay();\n\n        if(spamConsole) {\n            //Show everything our workers emmited\n            replayableWork.map(s->\"Subscriber 1: \" + s ).subscribe(System.out::println);\n        }\n\n        minions.connect();\n        someWorker.connect();\n\n        if (exitAfterIdling) {\n            //If for 5 seconds no new items come in we assume to have finished\n            //FIXME: does not work, if @code{exitAfterIdling} is true we immediatly terminate here\n            replayableWork.timeout(5, TimeUnit.SECONDS).doOnNext(foo -> {\n                System.out.println(\"Looks like we are done\");\n                System.exit(0);\n            }).subscribe();\n        }\n\n        //Begin observing work results\n        replayableWork.connect();\n\n        //Wait some time to let some work accumulate to test if second subscriber gets all items\n        Thread.sleep(5000);\n        System.out.println(\"2nd Subscriber\");\n        if(spamConsole) {\n            replayableWork.subscribe(s -> {\n                System.out.println(\"Subscriber 2: \" + s);\n            });\n        }\n\n        while (true) {\n            //Keep the Programm running untill told otherwise\n            System.out.println(\"Mainthread Idle\");\n            Thread.sleep(10000);\n        }\n    }\n\n    public static ConnectableObservable<String> makeWorker(String name, long delay, Scheduler scheduler, final int ammount) {\n        final Iterator<Integer> counter = makeCounter(ammount);\n        Observable<String> worker = Observable.create(subscriber -> {\n            System.out.println(\"Starting Worker-Subsciber \\\"\" + name + \"\\\" for \" + ammount + \" lots of work\");\n            int lastCount = 0;\n            subscriber.onStart();\n            while (counter.hasNext() && !subscriber.isUnsubscribed()) {\n                lastCount = counter.next() + 1;\n\n                try {\n                    //Simmulate hard work by doing nothing\n                    subscriber.onNext(\"Work from \\\"\" + name + \"\\\"\" + \" (\" + lastCount + \"/\" + ammount + \")\");\n                    Thread.currentThread().sleep(delay);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (!subscriber.isUnsubscribed()) {\n                System.out.println(\"Worker-Subscriber \\\"\" + name + \"\\\" finished after \" + lastCount + \"/\" + ammount + \" lots of work\");\n                subscriber.onCompleted();\n            } else {\n                System.out.println(\"Worker-Subscriber \\\"\" + name + \"\\\" was unsuscribed and finished after \" + lastCount + \"/\" + ammount + \" lots of work\");\n            }\n\n\n        });\n        //make this connectable so we dont miss one of our workers items\n        return worker.subscribeOn(scheduler).replay();//;\n    }\n\n\n    /**Just a counter, could be done with range, but was intended to test with somthing statefull*/\n    private static Iterator<Integer> makeCounter(final int ammount) {\n        return new Iterator<Integer>() {\n            private int counter = 0;\n            @Override\n            public boolean hasNext() {return counter < ammount;}\n            @Override\n            public Integer next() {return counter++;}\n        };\n    }\n}\n```\n\nthis usually results in an exception (some time with much lower index):\n\n```\nException in thread \"RxNewThreadScheduler-4\" Exception in thread \"RxNewThreadScheduler-7\" Exception in thread \"RxNewThreadScheduler-3\" java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:60)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: rx.exceptions.OnErrorNotImplementedException: 10390\n    at rx.Observable$27.onError(Observable.java:8139)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:157)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120)\n    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:200)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:144)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:150)\n    at rx.internal.operators.OperatorReplay$UnboundedReplayBuffer.replay(OperatorReplay.java:821)\n    at rx.internal.operators.OperatorReplay$ReplaySubscriber.replay(OperatorReplay.java:559)\n    at rx.internal.operators.OperatorReplay$ReplaySubscriber.onNext(OperatorReplay.java:450)\n    at rx.internal.operators.OperatorSubscribeOn$1$1.onNext(OperatorSubscribeOn.java:53)\n    at mypackage.TestOutOfBounds.lambda$makeWorker$0(TestOutOfBounds.java:24)\n    at mypackage.TestOutOfBounds$$Lambda$1/1567581361.call(Unknown Source)\n    at rx.Observable.unsafeSubscribe(Observable.java:8314)\n    at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    ... 7 more\nCaused by: java.lang.ArrayIndexOutOfBoundsException: 10390\n    at java.util.ArrayList.add(ArrayList.java:459)\n    at rx.subjects.ReplaySubject$UnboundedReplayState.next(ReplaySubject.java:459)\n    at rx.subjects.ReplaySubject.onNext(ReplaySubject.java:371)\n    at mypackage.TestOutOfBounds$$Lambda$5/1948591192.call(Unknown Source)\n    at rx.Observable$27.onNext(Observable.java:8144)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:139)\n    ... 17 more\njava.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:60)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: rx.exceptions.OnErrorNotImplementedException: 10390\n    at rx.Observable$27.onError(Observable.java:8139)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:157)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120)\n    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:200)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:144)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:150)\n    at rx.internal.operators.OperatorReplay$UnboundedReplayBuffer.replay(OperatorReplay.java:821)\n    at rx.internal.operators.OperatorReplay$ReplaySubscriber.replay(OperatorReplay.java:559)\n    at rx.internal.operators.OperatorReplay$ReplaySubscriber.onNext(OperatorReplay.java:450)\n    at rx.internal.operators.OperatorSubscribeOn$1$1.onNext(OperatorSubscribeOn.java:53)\n    at mypackage.TestOutOfBounds.lambda$makeWorker$0(TestOutOfBounds.java:24)\n    at mypackage.TestOutOfBounds$$Lambda$1/1567581361.call(Unknown Source)\n    at rx.Observable.unsafeSubscribe(Observable.java:8314)\n    at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    ... 7 more\nCaused by: java.lang.ArrayIndexOutOfBoundsException: 10390\n    at java.util.ArrayList.add(ArrayList.java:459)\n    at rx.subjects.ReplaySubject$UnboundedReplayState.next(ReplaySubject.java:459)\n    at rx.subjects.ReplaySubject.onNext(ReplaySubject.java:371)\n    at mypackage.TestOutOfBounds$$Lambda$5/1948591192.call(Unknown Source)\n    at rx.Observable$27.onNext(Observable.java:8144)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:139)\n    ... 17 more\njava.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:60)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: rx.exceptions.OnErrorNotImplementedException: 10390\n    at rx.Observable$27.onError(Observable.java:8139)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:157)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120)\n    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:200)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:144)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:150)\n    at rx.internal.operators.OperatorReplay$UnboundedReplayBuffer.replay(OperatorReplay.java:821)\n    at rx.internal.operators.OperatorReplay$ReplaySubscriber.replay(OperatorReplay.java:559)\n    at rx.internal.operators.OperatorReplay$ReplaySubscriber.onNext(OperatorReplay.java:450)\n    at rx.internal.operators.OperatorSubscribeOn$1$1.onNext(OperatorSubscribeOn.java:53)\n    at mypackage.TestOutOfBounds.lambda$makeWorker$0(TestOutOfBounds.java:24)\n    at mypackage.TestOutOfBounds$$Lambda$1/1567581361.call(Unknown Source)\n    at rx.Observable.unsafeSubscribe(Observable.java:8314)\n    at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    ... 7 more\nCaused by: java.lang.ArrayIndexOutOfBoundsException: 10390\n    at java.util.ArrayList.add(ArrayList.java:459)\n    at rx.subjects.ReplaySubject$UnboundedReplayState.next(ReplaySubject.java:459)\n    at rx.subjects.ReplaySubject.onNext(ReplaySubject.java:371)\n    at mypackage.TestOutOfBounds$$Lambda$5/1948591192.call(Unknown Source)\n    at rx.Observable$27.onNext(Observable.java:8144)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:139)\n    ... 17 more\n```\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3725/comments",
    "author": "Hauke85",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-02-23T09:25:05Z",
        "body": "I've run your code several times and it didn't crash. The exception may only happen if you call `onNext` of the `minionOutput` concurrently; the example doesn't seem to do this.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-02T23:24:51Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 3723,
    "title": "SerializedBehaviorSubject",
    "created_at": "2016-02-19T20:33:24Z",
    "closed_at": "2016-02-23T08:19:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3723",
    "body": "Looking at the changes in #2470, a useful `getValue()` method was added to `BehaviorSubject`. This goes away though if you want to serialize it. Would there be feasible to have something like a `SerializedBehaviorSubject` that maintains the API of `BehaviorSubject`?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3723/comments",
    "author": "ZacSweers",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-02-19T20:39:01Z",
        "body": "You can keep a reference to the original BehaviorSubject; the method is threadsafe by itself.\n"
      },
      {
        "user": "ZacSweers",
        "created_at": "2016-02-23T08:19:16Z",
        "body": "Ah! Good to know, thanks!\n"
      }
    ]
  },
  {
    "number": 3716,
    "title": "flatMapIterable and toList combination issue",
    "created_at": "2016-02-16T08:42:14Z",
    "closed_at": "2016-02-17T06:22:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3716",
    "body": "In the following code the \"three\" and \"done\" never appears in the output. Looks like the problem is in `toList` call. Am i using it wrong?\n\n```\nPublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\nObservable<Boolean> observable = mBooleanPublishSubject.asObservable().share();\nobservable\n        .doOnNext(__ -> System.out.println(\"one\"))\n        .flatMap(__ -> Observable.just(Arrays.asList(1, 2, 3, 4)))\n        .flatMapIterable(number -> number)\n        .doOnNext(v -> System.out.println(\"two \" + v))\n        .toList()\n        .doOnNext(v -> System.out.println(\"three \" + v))\n        .subscribe(v -> System.out.println(\"done\"));\nmBooleanPublishSubject.onNext(true);\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3716/comments",
    "author": "httpdispatch",
    "comments": [
      {
        "user": "MyDogTom",
        "created_at": "2016-02-16T14:09:30Z",
        "body": "`toList` waits for `onCompleted` event. In your case there is no `onCompleted` event. Add `mBooleanPublishSubject.onCompleted();` and you will see others outputs.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-02-17T06:22:43Z",
        "body": "Thanks for the explanation. It works like this\n\n```\nPublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n        Observable<Boolean> observable = mBooleanPublishSubject.asObservable().share();\n        observable\n                .doOnNext(__ -> System.out.println(\"one\"))\n                .flatMap(__ -> Observable.just(Arrays.asList(1, 2, 3, 4))\n                        .flatMapIterable(number -> number)\n                        .doOnNext(v -> System.out.println(\"two \" + v))\n                        .toList()\n                        .doOnNext(v -> System.out.println(\"three \" + v)))\n                .doOnNext(v -> System.out.println(\"four \" + v))\n                .subscribe(v -> System.out.println(\"done\"));\n        mBooleanPublishSubject.onNext(true);\n        mBooleanPublishSubject.onNext(true);\n```\n"
      }
    ]
  },
  {
    "number": 3715,
    "title": "What is the best way to keep receive items in the subscriber after the error",
    "created_at": "2016-02-16T06:07:31Z",
    "closed_at": "2016-03-21T07:54:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3715",
    "body": "I have a PublishSubject which triggers simultaneous downloading operations. The results of that operations are zipped and handled with a single subscription. I want to know what is the best approach to keep receive all future events from the publish subject after the error occurs in one of the downloading process (without try/catch). I've implemented the test case to demonstrate the behaviour. It works as expected but doesn't look very elegant.\n\n```\n@Test public void testOnErrorResumeNext() {\n    PublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n    mBooleanPublishSubject.asObservable()\n            .doOnNext(__ -> System.out.println(\"mBooleanPublishSubject: on value emitted \" + System.currentTimeMillis()))\n            .flatMap(b -> Observable\n                    .defer(() -> Observable\n                            .zip(\n                                    Observable\n                                            .just(b)\n                                            .map(__ -> 1),\n                                    Observable\n                                            .just(b)\n                                            .flatMap(__ -> {\n                                                if (Math.random() > 0.8) {\n                                                    System.out.println(\"Generate error\");\n                                                    throw new RuntimeException(\"test\");\n                                                } else {\n                                                    return Observable.just(2);\n                                                }\n                                            })\n                                    , (integer, integer2) -> integer + integer2))\n                    .onErrorResumeNext(t -> {\n                        System.out.println(\"onErrorResumeNext\" + t.getMessage());\n                        return Observable.empty();\n                    }))\n            .doOnNext(__ -> System.out.println(\"zip value emitted \" + System.currentTimeMillis()))\n            .doOnCompleted(() -> System.out.println(\"zip value completed \" + System.currentTimeMillis()))\n            .doOnError(t -> System.out.println(\"zip value error \" + System.currentTimeMillis()))\n\n            .subscribe(v -> System.out.println(\"done \" + v + \" \" + System.currentTimeMillis()));\n\n    mBooleanPublishSubject.onNext(true);\n    mBooleanPublishSubject.onNext(true);\n    mBooleanPublishSubject.onNext(true);\n    mBooleanPublishSubject.onNext(true);\n    mBooleanPublishSubject.onNext(true);\n    mBooleanPublishSubject.onNext(true);\n    mBooleanPublishSubject.onNext(true);\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3715/comments",
    "author": "httpdispatch",
    "comments": [
      {
        "user": "httpdispatch",
        "created_at": "2016-02-24T08:12:58Z",
        "body": "Looks like defer call can be omited in this example and it will work. Looks little better\n\n```\nmBooleanPublishSubject.asObservable()\n        .doOnNext(__ -> System.out.println(\"mBooleanPublishSubject: on value emitted \" + System.currentTimeMillis()))\n        .flatMap(b -> Observable\n                        .zip(\n                                Observable\n                                        .just(b)\n                                        .map(__ -> 1),\n                                Observable\n                                        .just(b)\n                                        .flatMap(__ -> {\n                                            if (Math.random() > 0.8) {\n                                                System.out.println(\"Generate error\");\n                                                throw new RuntimeException(\"test\");\n                                            } else {\n                                                return Observable.just(2);\n                                            }\n                                        })\n                                , (integer, integer2) -> integer + integer2)\n                        .onErrorResumeNext(t -> {\n                            System.out.println(\"onErrorResumeNext \" + t.getMessage());\n                            return Observable.just(5);\n                        })\n        )\n        .doOnNext(__ -> System.out.println(\"zip value emitted \" + System.currentTimeMillis()))\n        .doOnCompleted(() -> System.out.println(\"zip value completed \" + System.currentTimeMillis()))\n        .doOnError(t -> System.out.println(\"zip value error \" + System.currentTimeMillis()))\n        .subscribe(v -> System.out.println(\"done \" + v + \" \" + System.currentTimeMillis()));\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-14T01:22:16Z",
        "body": "Errors are sequence-terminating events so you need to wrap them into `Notification` objects for example. So instead of calling onError on a Subject, you create a `PublishSubject<Notification<T>>` and call onNext with `Notification.createOnError()`.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-03-21T07:54:08Z",
        "body": "Thanks, that may help.\n"
      }
    ]
  },
  {
    "number": 3708,
    "title": "Single and Completable takeUntil()",
    "created_at": "2016-02-14T11:21:45Z",
    "closed_at": "2016-03-14T01:13:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3708",
    "body": "In reading the original PR for `Single`, I saw Ben was OK with adding a `takeUntil(Single/Observable)` operator for `Single` later. I was wondering if this was still the plan, and if you would be open to contributions on this front. Same with `Completable`.\n\nOne caveat that I've thought of is that there's a potentially conflicting contact with `Single` and `takeUntil()` in the sense that `takeUntil()` calls `onCompleted()` in observables, but `Single`s will actually go to `onError()` if `onCompleted()` is called before any events are emitted (and by extension `onSuccess()`). Not sure what the clear path would be, but it seems like `Single`s would have to only unsubscribe and not propagate any notifications, differing from `Observable`s and likely `Completable`s in this regard.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3708/comments",
    "author": "ZacSweers",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-02-14T11:37:42Z",
        "body": "`Single.takeUntil` still has to emit an onSuccess or onError; you need to emit a `NoSuchElementException` from the other `Single.onSuccess`. Unsubscribing the main and not emitting anything is bad because it keeps the subscribers hanging. I don't think it is worth it.\n\n`Completable.takeUntil` is just `completable.ambWith(other)`.\n"
      },
      {
        "user": "ZacSweers",
        "created_at": "2016-02-14T17:32:21Z",
        "body": "The completable makes sense. For `Single`, do you think there's a feasible way to do a sort of takeUntil-like behavior where it completes/unsubscribes on the emission of another observable/single? \n\nI'm working on some lifecycle handling for android, and a use case that's worked well in the past is to emit lifecycle events via behaviorsubject and then just `takeUntil(lifecycleSubject.filter(e -> e == DETACH))`. The idea is you want it to unsubscribe when the detach happens, and perhaps out of convenience we've always been using the fact that takeUntil would call onComplete and eventually cause it to unsubscribe. \n"
      },
      {
        "user": "ZacSweers",
        "created_at": "2016-02-14T17:36:08Z",
        "body": "It seems like forcing an onSuccess or onError defeats the purpose of having a subscription that supports `unsubscribe` prior to that.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-02-14T17:47:57Z",
        "body": "The best you can do with `takeUntil` is to signal an error, like `CancellationException` similar to how `Future` does.\n"
      },
      {
        "user": "ZacSweers",
        "created_at": "2016-02-15T03:49:04Z",
        "body": "I see. Would that be something you guys would be open to as PR? Or at least consider making `Single#lift()` public since it's still experimental? Otherwise it doesn't seem like it's possible in the current API. Could catch existing `NoSuchElementException`s but there'd be no way to know if it was due to completion or cancellation. \n\nAlternatively, would there be a simple way to potentially swallow that error upstream rather than force the subscriber to handle it?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-02-15T07:15:27Z",
        "body": "We are open for PRs.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-14T01:13:35Z",
        "body": "Closing via #3712\n"
      },
      {
        "user": "ZacSweers",
        "created_at": "2016-03-14T01:29:34Z",
        "body": "Actually this just reminded me, would we want `Single` and `Observable` overloads for `Completable`, or just use `amb` and call `toCompletable` on those when passing them in?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-14T18:14:48Z",
        "body": "Maybe, submit a PR and let's see the opinions.\n"
      },
      {
        "user": "ZacSweers",
        "created_at": "2016-03-16T11:41:22Z",
        "body": "Will do, though likely not until this weekend or next week\n"
      }
    ]
  },
  {
    "number": 3679,
    "title": "Actual exception is being hidden by OnErrorFailedException",
    "created_at": "2016-02-08T22:41:25Z",
    "closed_at": "2016-06-02T05:42:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3679",
    "body": "Using RxJava 1.10 (and similar issue on 1.0.15), I stumbled upon a mysterious stack trace that made no sense in my app, after a lot of debugging, I found that RxJava will report the wrong exception in some scenarios. For example, if you run this sample code:\n\n```\nObservable.just(1).doOnNext(new Action1<Integer>() {\n        @Override public void call(Integer val) {\n            throw new IllegalStateException(\"doOnNextException\");\n        }\n    }).retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\n        @Override public Observable<?> call(Observable<? extends Throwable> errorObservable) {\n            return errorObservable.flatMap(new Func1<Throwable, Observable<?>>() {\n                @Override public Observable<?> call(Throwable throwable) {\n                    return Observable.just(3).delay(1, TimeUnit.SECONDS).doOnNext(\n                            new Action1<Integer>() {\n                                @Override public void call(Integer integer) {\n                                    throw new UnsupportedOperationException(\"retry exception\");\n                                }\n                            });\n                }\n            });\n        }\n    }).subscribe(new Subscriber<Integer>() {\n        @Override public void onCompleted() {\n            Log.v(\"EX\", \"onCompleted\");\n        }\n\n        @Override public void onError(Throwable e) {\n            Log.v(\"EX\", \"onError\");\n            throw new IllegalThreadStateException();\n        }\n\n        @Override public void onNext(Integer integer) {\n            Log.v(\"EX\", \"onNext\");\n        }\n    });\n```\n\nThe expected behaviour should be that `IllegalThreadStateException` (thrown within the `onError` handler of the subscriber) is included as the cause. However, the actual stack trace contains `UnsupportedOperationException` as the cause - which is not the problem in the code snippet above. the `UnsupportedOperationException` is totally fine, but the problem arises when `onError` throws.\n\nThis leads to a stack trace that points to the wrong cause and does not include the actual cause (which would be the `IllegalThreadStateException`). If I removed the `retryWhen()` block - then the stack trace correctly includes `IllegalThreadStateException` as the exception from within `onError`.\n\nThe (incorrect) trace from the code snippet above:\n\n```\nProcess: com.example.mydemoapp, PID: 14118\njava.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:62)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n    at java.lang.Thread.run(Thread.java:818)\n Caused by: rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:194)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120)\n    at rx.internal.operators.OnSubscribeRedo$4$1.onError(OnSubscribeRedo.java:331)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:240)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:776)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:537)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:526)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:810)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:71)\n    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:187)\n    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:82)\n    at rx.internal.operators.OperatorDelay$1$3.call(OperatorDelay.java:88)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422) \n    at java.util.concurrent.FutureTask.run(FutureTask.java:237) \n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152) \n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265) \n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112) \n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587) \n    at java.lang.Thread.run(Thread.java:818) \n Caused by: rx.exceptions.CompositeException: 2 exceptions occurred. \n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:194) \n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120) \n    at rx.internal.operators.OnSubscribeRedo$4$1.onError(OnSubscribeRedo.java:331) \n    at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:240) \n    at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:776) \n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:537) \n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:526) \n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:810) \n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:71) \n    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:187) \n    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:82) \n    at rx.internal.operators.OperatorDelay$1$3.call(OperatorDelay.java:88) \n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55) \n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422) \n    at java.util.concurrent.FutureTask.run(FutureTask.java:237) \n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152) \n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265) \n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112) \n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587) \n    at java.lang.Thread.run(Thread.java:818) \n Caused by: rx.exceptions.CompositeException$CompositeExceptionCausalChain: Chain of Causes for CompositeException In Order Received =>\n    at android.util.Log.getStackTraceString(Log.java:504)\n    at com.android.internal.os.RuntimeInit.Clog_e(RuntimeInit.java:59)\n    at com.android.internal.os.RuntimeInit.access$200(RuntimeInit.java:43)\n    at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:91)\n    at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)\n    at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:66)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422) \n    at java.util.concurrent.FutureTask.run(FutureTask.java:237) \n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152) \n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265) \n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112) \n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587) \n    at java.lang.Thread.run(Thread.java:818) \n Caused by: java.lang.UnsupportedOperationException: retry exception\n    at com.example.mydemoapp.MainActivity$3$1$1.call(MainActivity.java:74)\n    at com.example.mydemoapp.MainActivity$3$1$1.call(MainActivity.java:72)\n    at rx.Observable$11.onNext(Observable.java:4445)\n    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:80)\n    at rx.internal.operators.OperatorDelay$1$3.call(OperatorDelay.java:88)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422) \n    at java.util.concurrent.FutureTask.run(FutureTask.java:237) \n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152) \n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265) \n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112) \n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587) \n    at java.lang.Thread.run(Thread.java:818) \n Caused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: 3\n    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:187)\n    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:82)\n    at rx.internal.operators.OperatorDelay$1$3.call(OperatorDelay.java:88) \n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55) \n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422) \n    at java.util.concurrent.FutureTask.run(FutureTask.java:237) \n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152) \n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265) \n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112) \n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587) \n    at java.lang.Thread.run(Thread.java:818) \n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3679/comments",
    "author": "ktchernov",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-02-09T12:21:29Z",
        "body": "You shoudn't throw from `Observer.onError` or `Subscriber.onError` but there are safeguards which have to wrap exceptions and deliver it somewhere upstream.\n"
      },
      {
        "user": "ktchernov",
        "created_at": "2016-02-09T20:40:55Z",
        "body": "> You shoudn't throw from Observer.onError or Subscriber.onError but there are safeguards which have to wrap exceptions and deliver it somewhere upstream.\n\nThis is just an example to illustrate the problem, my point was not that there shouldn't be exception, my point is that the cause exception that `OnErrorFailedException` wraps is the wrong exception and not the cause.\n\nInstead the log is of an exception which is already handled. This is confusing and can take a lot of time to understand and to find the actual cause.\n\nFor example, in my app there is a rare bug somewhere inside my `onError` handler, which causes an exception, but I don't know which line inside my handler throws or what exception it throws because I do not see the actual stack trace. Instead I see the error that caused the `onError` to be invoked.\n\nIf you run the same example above with the `retryWhen` removed, you get the correct exception (note **IllegalStateException** is at the bottom of the stack trace, while in the first stack trace above the already-handled **UnsupportedOperationException** is at the bottom of the stack trace):\n\n```\nrx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:194)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:71)\n    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:187)\n    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:82)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.subscribe(Observable.java:8191)\n    at rx.Observable.subscribe(Observable.java:8158)\n    at com.example.mydemoapp.MainActivity.testRetryError(MainActivity.java:65)\n    at com.example.mydemoapp.MainActivity.onOptionsItemSelected(MainActivity.java:53)\n    at android.app.Activity.onMenuItemSelected(Activity.java:2908)\n    at android.support.v4.app.FragmentActivity.onMenuItemSelected(FragmentActivity.java:361)\n    at android.support.v7.app.AppCompatActivity.onMenuItemSelected(AppCompatActivity.java:147)\n    at android.support.v7.view.WindowCallbackWrapper.onMenuItemSelected(WindowCallbackWrapper.java:100)\n    at android.support.v7.view.WindowCallbackWrapper.onMenuItemSelected(WindowCallbackWrapper.java:100)\n    at android.support.v7.app.ToolbarActionBar$2.onMenuItemClick(ToolbarActionBar.java:68)\n    at android.support.v7.widget.Toolbar$1.onMenuItemClick(Toolbar.java:172)\n    at android.support.v7.widget.ActionMenuView$MenuBuilderCallback.onMenuItemSelected(ActionMenuView.java:760)\n    at android.support.v7.view.menu.MenuBuilder.dispatchMenuItemSelected(MenuBuilder.java:811)\n    at android.support.v7.view.menu.MenuItemImpl.invoke(MenuItemImpl.java:152)\n    at android.support.v7.view.menu.MenuBuilder.performItemAction(MenuBuilder.java:958)\n    at android.support.v7.view.menu.MenuBuilder.performItemAction(MenuBuilder.java:948)\n    at android.support.v7.view.menu.MenuPopupHelper.onItemClick(MenuPopupHelper.java:191)\n    at android.widget.AdapterView.performItemClick(AdapterView.java:310)\n    at android.widget.AbsListView.performItemClick(AbsListView.java:1145)\n    at android.widget.AbsListView$PerformClick.run(AbsListView.java:3042)\n    at android.widget.AbsListView$3.run(AbsListView.java:3879)\n    at android.os.Handler.handleCallback(Handler.java:739)\n    at android.os.Handler.dispatchMessage(Handler.java:95)\n    at android.os.Looper.loop(Looper.java:148)\n    at android.app.ActivityThread.main(ActivityThread.java:5417)\n    at java.lang.reflect.Method.invoke(Native Method)\n    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\n    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\n Caused by: rx.exceptions.CompositeException: 2 exceptions occurred. \n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:194) \n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120) \n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:71) \n    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:187) \n    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:82) \n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46) \n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35) \n    at rx.Observable$2.call(Observable.java:162) \n    at rx.Observable$2.call(Observable.java:154) \n    at rx.Observable.subscribe(Observable.java:8191) \n    at rx.Observable.subscribe(Observable.java:8158) \n    at com.example.mydemoapp.MainActivity.testRetryError(MainActivity.java:65) \n    at com.example.mydemoapp.MainActivity.onOptionsItemSelected(MainActivity.java:53) \n    at android.app.Activity.onMenuItemSelected(Activity.java:2908) \n    at android.support.v4.app.FragmentActivity.onMenuItemSelected(FragmentActivity.java:361) \n    at android.support.v7.app.AppCompatActivity.onMenuItemSelected(AppCompatActivity.java:147) \n    at android.support.v7.view.WindowCallbackWrapper.onMenuItemSelected(WindowCallbackWrapper.java:100) \n    at android.support.v7.view.WindowCallbackWrapper.onMenuItemSelected(WindowCallbackWrapper.java:100) \n    at android.support.v7.app.ToolbarActionBar$2.onMenuItemClick(ToolbarActionBar.java:68) \n    at android.support.v7.widget.Toolbar$1.onMenuItemClick(Toolbar.java:172) \n    at android.support.v7.widget.ActionMenuView$MenuBuilderCallback.onMenuItemSelected(ActionMenuView.java:760) \n    at android.support.v7.view.menu.MenuBuilder.dispatchMenuItemSelected(MenuBuilder.java:811) \n    at android.support.v7.view.menu.MenuItemImpl.invoke(MenuItemImpl.java:152) \n    at android.support.v7.view.menu.MenuBuilder.performItemAction(MenuBuilder.java:958) \n    at android.support.v7.view.menu.MenuBuilder.performItemAction(MenuBuilder.java:948) \n    at android.support.v7.view.menu.MenuPopupHelper.onItemClick(MenuPopupHelper.java:191) \n    at android.widget.AdapterView.performItemClick(AdapterView.java:310) \n    at android.widget.AbsListView.performItemClick(AbsListView.java:1145) \n    at android.widget.AbsListView$PerformClick.run(AbsListView.java:3042) \n    at android.widget.AbsListView$3.run(AbsListView.java:3879) \n    at android.os.Handler.handleCallback(Handler.java:739) \n    at android.os.Handler.dispatchMessage(Handler.java:95) \n    at android.os.Looper.loop(Looper.java:148) \n    at android.app.ActivityThread.main(ActivityThread.java:5417) \n    at java.lang.reflect.Method.invoke(Native Method) \n    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726) \n    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616) \n Caused by: rx.exceptions.CompositeException$CompositeExceptionCausalChain: Chain of Causes for CompositeException In Order Received =>\n    at android.util.Log.getStackTraceString(Log.java:338)\n    at com.android.internal.os.RuntimeInit.Clog_e(RuntimeInit.java:61)\n    at com.android.internal.os.RuntimeInit.-wrap0(RuntimeInit.java)\n    at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:86)\n    at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)\n    at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)\n Caused by: java.lang.IllegalStateException: doOnNextException\n    at com.example.mydemoapp.MainActivity$3.call(MainActivity.java:63)\n    at com.example.mydemoapp.MainActivity$3.call(MainActivity.java:61)\n    at rx.Observable$11.onNext(Observable.java:4445)\n    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:80)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n at rx.Observable$2.call\n```\n"
      },
      {
        "user": "ktchernov",
        "created_at": "2016-03-13T01:28:20Z",
        "body": "Simpler way to reproduce is to just throw within a `doOnError()` - the exception that is thrown is swallowed and is not part of the causal chain.\n\n```\n    Observable.just(1).doOnNext(new Action1<Integer>() {\n        @Override public void call(Integer val) {\n            throw new IllegalStateException(\"doOnNextException\");\n        }\n    }).doOnError(new Action1<Throwable>() {\n                @Override public void call(Throwable throwable) {\n                    throw new UnsupportedOperationException(\"onError exception\");\n                }\n    }).subscribe(new Subscriber<Integer>() {\n        @Override public void onCompleted() {\n            Log.v(\"EX\", \"onCompleted\");\n        }\n\n        @Override public void onError(Throwable e) {\n            Log.v(\"EX\", \"onError\");\n            throw new IllegalThreadStateException();\n        }\n\n        @Override public void onNext(Integer integer) {\n            Log.v(\"EX\", \"onNext\");\n        }\n    });\n```\n"
      },
      {
        "user": "premnirmal",
        "created_at": "2016-05-25T19:54:15Z",
        "body": "I see this issue too. When I see logs via crashlytics the stacktrace just shows the composite exception but not the details of the actual crash in `onError()`. I see there's a bug in `CompositeException.java`. Fixing in a new PR\n"
      },
      {
        "user": "zsxwing",
        "created_at": "2016-06-02T05:42:00Z",
        "body": "Closing via #3977\n"
      }
    ]
  },
  {
    "number": 3674,
    "title": "concat not subscribing to the next source if requested is at 0",
    "created_at": "2016-02-05T19:48:44Z",
    "closed_at": "2016-03-14T01:07:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3674",
    "body": "The following test fails because the sequence misses the last value of the source:\n\n``` java\n    @Test\n    public void publishConcatBackpressure() {\n        TestSubscriber<Integer> ts = TestSubscriber.create(5);\n\n        Observable.range(1, 6)\n        .publish(o -> Observable.concat(o.take(5), o.takeLast(5)))\n        .subscribe(ts);\n\n        ts.requestMore(1);\n\n        ts.assertValues(1, 2, 3, 4, 5, 6);\n        ts.assertNoErrors();\n        ts.assertCompleted();\n    }\n```\n\nThe operator `publish()` has the property that if all subscribers unsubscribe but the upstream hasn't completed yet, it \"slowly\" consumes the upstream until a subscriber shows up (at which case it consumes the upstream at the rate of the slowest subscriber again). This may be a discussable property (i.e., why not \"pause\" until more interesting parties show up), but when it is combined with `concat`, unexpected data loss may happen.\n\n`concat` seems to be implemented in a way that if a source completes on a request boundary, that is downstream's requested count is zero, it doesn't subscribe to the next immediately but only when the downstream requests more. This might be a residue from a case where the next source ignores backpressure (`just`?) and would flood the downstream that didn't request anything yet. However, such sources would ignore any request amount anyway so this behavior might be unnecessary.\n\nIn the test above, this is simulated by an initial request of 5. After the `subscribe` returns, however, the `publish()` already consumed the rest of the source so the `requestMore(1)` making the `concat` subscribe to the second part, there is no value available anymore. (Besides, it won't complete either, see #3673 .)\n\nI'm not sure if these two behaviors are bugs or just unexpected but legal outcomes, so my question is what should we do about them. I believe, tests exist that verify both `concat` and `publish()` for their current behavior.\n\nThe fix to `publish()` would be to remove the `n == 0` case in its drain loop, making it pause when nobody is interested; and the fix to `concat` would be a different completion-subscription trampolining that subscribes immediately to the next but doesn't request anything (or zero). \n\nBoth can individually ensure the continuity of values in the example above.\n\nThoughts?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3674/comments",
    "author": "akarnokd",
    "comments": [
      {
        "user": "ZacSweers",
        "created_at": "2016-02-07T20:54:28Z",
        "body": "Might want to @ mention people to get this on their radar\n"
      },
      {
        "user": "stevegury",
        "created_at": "2016-02-08T23:25:28Z",
        "body": "It makes sense to pause the publish operator when no one is subscribed, and now `concat` have to  subscribe immediately to the next source without requesting any data (until the subscriber does).\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-02-08T23:55:49Z",
        "body": "See #3681 that solves this issue without changing `concat` whose behavior is somewhat expected.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-14T01:07:37Z",
        "body": "Closing via #3681\n"
      }
    ]
  },
  {
    "number": 3666,
    "title": "Ambiguous reference error raised by error-prone",
    "created_at": "2016-02-03T17:35:59Z",
    "closed_at": "2016-03-14T01:09:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3666",
    "body": "Compiling with error-prone (Gradle error-prone plugin version 0.0.8, java full version \"1.8.0_60-b27\") raises ambiguous reference error while calling Observable.subscribe(Subscriber) method. \nThe conflict is with Observable.subscribe(Observer) as Subscriber implements Observer interface.\n\nObservable.subscribe(Observer) method checks if the Observer passed in, is an instanceof Subscriber and calls Observable.subscribe(Subscriber).\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3666/comments",
    "author": "ppeeth",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-02-09T14:30:34Z",
        "body": "Those are there for historical reasons and I haven't run into issues with javac/Eclipse regarding them.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-14T01:09:12Z",
        "body": "Let me know if you have further issues.\n"
      }
    ]
  },
  {
    "number": 3656,
    "title": "Take and debounce usage",
    "created_at": "2016-01-29T10:30:55Z",
    "closed_at": "2016-01-29T12:20:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3656",
    "body": "I have the next test case\n\n``` @Test\n    public void testLimitAndPublishSubject() throws InterruptedException {\n        PublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n        mBooleanPublishSubject.asObservable()\n                .doOnEach(__ -> System.out.println(\"on value emitted \"+System.currentTimeMillis()))\n                .take(1)\n                .doOnEach(__ -> System.out.println(\"on value emitted 2 \"+System.currentTimeMillis()))\n                .debounce(1000, TimeUnit.MILLISECONDS)\n                .doOnEach(__ -> System.out.println(\"on value emitted 3 \"+System.currentTimeMillis()))\n                .subscribe(__ -> System.out.println(\"done \"+System.currentTimeMillis()));\n        mBooleanPublishSubject.onNext(true);\n        Thread.sleep(1000);\n        mBooleanPublishSubject.onNext(true);\n        Thread.sleep(2000);\n    }\n```\n\nand the output is\n\n```\non value emitted 1454063289770\non value emitted 2 1454063289770\non value emitted 2 1454063289779\non value emitted 3 1454063289780\ndone 1454063289780\non value emitted 3 1454063289780\n```\n\nI can't figure out why the `on value emitted 2` and `on value emitted 3` appears in the log twice and why the debounce delay doesn't work. Can somebody please help?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3656/comments",
    "author": "httpdispatch",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-01-29T11:47:03Z",
        "body": "Hi. The debounce doesn't work because with `take(1)` you immediately complete the stream which forces debounce to emit (because no further value will come thus it's safe to emit the last value).\n\nAs for why the duplication, doesn't look to me right either so I'll investigate it further.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-01-29T11:49:54Z",
        "body": "Thank You for the help. Should i use flatMap or defer to overcome the debounce issue?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-01-29T11:50:54Z",
        "body": "The reason you see the duplication because you peek via `doOnEach` which is get called for `onNext` and `onCompleted` in your test. You can see this if you append the `__` to the output:\n\n``` java\n.doOnEach(__ -> System.out.println(\"on value emitted \"+System.currentTimeMillis() + __))\n```\n\nwhich prints:\n\n```\non value emitted 1454068146563[rx.Notification@1e307009 OnNext true]\non value emitted 2 1454068146563[rx.Notification@1e307009 OnNext true]\non value emitted 2 1454068146565[rx.Notification@4edde6e5 OnCompleted]\non value emitted 3 1454068146565[rx.Notification@1e307009 OnNext true]\ndone 1454068146565\non value emitted 3 1454068146565[rx.Notification@4edde6e5 OnCompleted]\n```\n\nIf you are not interested in all the event types, use `doOnNext` instead.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-01-29T11:52:26Z",
        "body": "Oh, thank you very much for explanation\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-01-29T11:53:30Z",
        "body": "> Thank You for the help. Should i use flatMap or defer to overcome the debounce issue?\n\nThat do you want to achieve in the first place? Using `take(1).debounce()` is pointless because there won't be more values for debounce to work on.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-01-29T11:55:02Z",
        "body": "I want the subscription to work like a replacement for CountDownTimer. When first event arrives - timer starts. All next events should be ignored\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-01-29T11:57:03Z",
        "body": "In this case, you can use delay instead:\n\n``` java\nsource.take(1).delay(1, TimeUnit.SECONDS)...\n```\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-01-29T12:20:44Z",
        "body": "Looks like flatMap also works, but your solution is much better. Thank You very much for your help\n"
      }
    ]
  },
  {
    "number": 3632,
    "title": "Why I import rxJava source code into Eclipse that I need add invokedynamic.jar to the project?",
    "created_at": "2016-01-22T10:44:50Z",
    "closed_at": "2016-02-09T14:23:09Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3632",
    "body": "",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3632/comments",
    "author": "StayZeal",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-01-25T13:01:46Z",
        "body": "It never happened to me. Can you share some more detail?\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2016-01-31T02:24:27Z",
        "body": "@StayZeal ping!\n"
      }
    ]
  },
  {
    "number": 3616,
    "title": "Join operator incorrect sequence",
    "created_at": "2016-01-14T14:10:45Z",
    "closed_at": "2016-03-14T17:11:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3616",
    "body": "I found a weird bug where join operator is emitting incorrect sequence in **some** Android devices. Here is the block of code that I am using:\n\n```\nObservable.just(\"A\", \"B\")\n        .join(Observable.just(1),\n                new Func1<String, Observable<Object>>() {\n                    @Override\n                    public Observable<Object> call(String s) {\n                        return Observable.never();\n                    }\n                }, new Func1<Integer, Observable<Object>>() {\n                    @Override\n                    public Observable<Object> call(Integer integer) {\n                        return Observable.never();\n                    }\n                }, new Func2<String, Integer, String>() {\n                    @Override\n                    public String call(String s, Integer integer) {\n                        return s + \" \" + integer;\n                    }\n                })\n        .subscribe(new Action1<String>() {\n            @Override\n            public void call(String s) {\n                System.out.println(s);\n            }\n        });\n```\n\nExpected sequence:\n\n```\nA1\nB1\n```\n\nIncorrect sequence:\n\n```\nB1\nA1\n```\n\nAfter digging in `rx.internal.operators.OnSubscribeJoin` class. I found this:\n\n```\nfinal class ResultSink {\n        final CompositeSubscription group;\n        final Subscriber<? super R> subscriber;\n        final Object guard = new Object();\n        /** Guarded by guard. */\n        boolean leftDone;\n        /** Guarded by guard. */\n        int leftId;\n        /** Guarded by guard. */\n        final Map<Integer, TLeft> leftMap;\n        /** Guarded by guard. */\n        boolean rightDone;\n        /** Guarded by guard. */\n        int rightId;\n        /** Guarded by guard. */\n        final Map<Integer, TRight> rightMap;\n\n        public ResultSink(Subscriber<? super R> subscriber) {\n            this.subscriber = subscriber;\n            this.group = new CompositeSubscription();\n            this.leftMap = new HashMap<Integer, TLeft>();\n            this.rightMap = new HashMap<Integer, TRight>();\n        }\n        ....\n}\n```\n\nI suspect the cause is because it's using `HashMap` to store left and right emitted values. Causing incorrect order in the values since `HashMap` cannot guarantee the order of the entries. It should uses `LinkedHashMap` to maintain the order of the entries.\nAny thoughts? Or did I miss something here? Thanks!\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3616/comments",
    "author": "spaiman",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-01-14T14:21:19Z",
        "body": "There was never a guaranteed order and even .Net has  no guarantees, not to mention the two platform produce in different order from the beginning\n"
      },
      {
        "user": "spaiman",
        "created_at": "2016-01-14T16:34:31Z",
        "body": "By looking at the marble diagram, I thought that the order is guaranteed. I think it should be stated in the Javadoc to avoid confusion for anyone else. Anyway, thanks for the heads up @akarnokd!\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-14T00:51:03Z",
        "body": "See #3756\n"
      },
      {
        "user": "spaiman",
        "created_at": "2016-03-14T02:38:00Z",
        "body": "Great! Thanks @akarnokd :+1: \n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-14T17:11:32Z",
        "body": "Closing via #3756.\n"
      }
    ]
  },
  {
    "number": 3611,
    "title": "GroupedObservable -> toBlocking() - hang forever",
    "created_at": "2016-01-11T13:31:57Z",
    "closed_at": "2016-01-11T20:42:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3611",
    "body": "Found an issue where `groupObservable.toBlocking()` hangs.\n\n`rxjava:1.1.0`\n\n```\nObservable\n            .just(1, 1, 2, 3, 4, 4, 5)\n            .groupBy(new Func1<Integer, Boolean>() {\n                @Override\n                public Boolean call(Integer integer) {\n                    return integer % 2 == 0;\n                }\n            }).subscribe(new Action1<GroupedObservable<Boolean, Integer>>() {\n            @Override\n            public void call(GroupedObservable<Boolean, Integer> grouped) {\n                List<Integer> first = grouped.toList().toBlocking().first();\n                Timber.d(first.size() + \" (Even: \" + grouped.getKey() + \")\");\n            }\n        });\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3611/comments",
    "author": "palaima",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-01-11T15:47:43Z",
        "body": "Hi. This is expected as the `toBlocking` gives access to blocking functions that may block the sequence. In this case, the problem is that `toList` expects a complete stream and won't emit until it receives an `onCompleted` event, Since you applied `toBlocking().first()`, that will block the current thread until it receives a single element which `toList` can't ever produce; the whole chain up to the producing `just` is blocked. The usual solution is to use `flatMap` and do some non-blocking processing with `GroupedObservable`:\n\n``` java\nObservable.just(1, 1, 2, 3, 4, 4, 5)\n.groupBy(v -> v % 2 == 0)\n.flatMap(g -> g.toList().doOnNext(first ->\n    Timber.d(first.size() + \" (Even: \" + g.getKey() + \")\")).ignoreElements())\n.subscribe(v -> { }, Throwable::printStackTrace);\n```\n"
      },
      {
        "user": "palaima",
        "created_at": "2016-01-11T20:42:51Z",
        "body": "Thanks for clarification!\n"
      }
    ]
  },
  {
    "number": 3608,
    "title": "Computation Scheduler stopping/slowing items from processing",
    "created_at": "2016-01-07T16:02:33Z",
    "closed_at": "2016-01-07T20:03:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3608",
    "body": "I am having a problem with trying to multi-thread my application to improve performance. My actual application follows a similar structure to the code below (except using real data and doing real work). I am using a flatMap so that I can simultaneously process the items on mutliple threads since the map work can potentially take a lot of time. \n\nWhat I am seeing, is when an item takes a long time to process in the map, it stops the items from being processed by other threads in the pool. In this example, I am seeing 11 items waiting till after the \"Done Sleeping...\" to be processed. The point of the multi-threading is for those items to be all processed in parallel with the item that is processing slowly.\n\nI noticed by switching to a FixedThreadPool Scheduler, it works as expected and the other threads pick up all the items remaining to be processed. \n\nWhy does the computation scheduler act like this? Is it a bug, or is there something I am not understanding?\n\nThe code snippet is in Groovy and I am using RxJava 1.1.0.\n\n```\nimport rx.Observable\nimport rx.Scheduler\nimport rx.schedulers.Schedulers\n\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.Executors\n\ndef threadpool = Executors.newFixedThreadPool(8)\ndef latch = new CountDownLatch(1)\n\n// Using a fixed thread pool works\n//Scheduler scheduler = Schedulers.from(threadpool)\n\n// Using the computation thread pool doesn't\nScheduler scheduler = Schedulers.computation()\n\nObservable.from(1..100).flatMap {\n    Observable.just(it).subscribeOn(scheduler).map {\n        if (it == 5) {\n            println \"${Thread.currentThread().name} - Sleeping... ${it}\"\n            // simulate long work here - only on certain items\n            Thread.sleep(15_000)\n            println \"${Thread.currentThread().name} - Done Sleeping... ${it}\"\n        }\n        return it\n    }\n}.subscribe ({\n    println \"${Thread.currentThread().name} - Got a num: ${it}\"\n}, {\n    println \"Error\"\n    it.printStackTrace()\n    threadpool.shutdown()\n    latch.countDown()\n}, {\n    println 'Complete'\n    threadpool.shutdown()\n    latch.countDown()\n})\nlatch.await()\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3608/comments",
    "author": "ottboy4",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-01-07T17:30:24Z",
        "body": "Hi. This code doesn't exhibit any unexpected delays: it emits all but one value and waits for the 15s sleep. I get a bunch of thread prints on my i7 4770K (4 core, 8 threads)\n\n``` java\nObservable.range(1, 100)\n    .flatMap(v -> Observable.just(v)\n            .subscribeOn(Schedulers.computation())\n            .map(u -> {\n                System.out.printf(\"P | %s: %s%n\", Thread.currentThread(), u);\n                if (u == 5) {\n                    try {\n                        Thread.sleep(15_000);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n                return u;\n            }))\n    .doOnNext(v -> {\n        System.out.printf(\"  | %s: %s%n\", Thread.currentThread(), v);\n    }).toBlocking().subscribe();\n```\n\nBecause `flatMap` routes to a single thread, it may get stuck with one particular thread when merged, but it shouldn't block of the other threads.\n"
      },
      {
        "user": "ottboy4",
        "created_at": "2016-01-07T17:50:46Z",
        "body": "akarnokd,\n\nHere is the exact output when I run the java code from your comment (I added in a timestamp on the print outs).\n\nNotice how 13, 21, 29, 37, etc do not get processed till After 5 prints out in the doOnNext? So you are seeing different results than this?\n\nI am using java 8u45.\n\n```\nP | 11:47:47:333 Thread[RxComputationThreadPool-6,5,main]: 4\n  | 11:47:47:336 Thread[RxComputationThreadPool-6,5,main]: 4\nP | 11:47:47:337 Thread[RxComputationThreadPool-6,5,main]: 12\nP | 11:47:47:337 Thread[RxComputationThreadPool-8,5,main]: 6\nP | 11:47:47:337 Thread[RxComputationThreadPool-4,5,main]: 2\nP | 11:47:47:337 Thread[RxComputationThreadPool-2,5,main]: 8\nP | 11:47:47:337 Thread[RxComputationThreadPool-1,5,main]: 7\nP | 11:47:47:337 Thread[RxComputationThreadPool-3,5,main]: 1\nP | 11:47:47:337 Thread[RxComputationThreadPool-5,5,main]: 3\n  | 11:47:47:337 Thread[RxComputationThreadPool-6,5,main]: 12\nP | 11:47:47:337 Thread[RxComputationThreadPool-7,5,main]: 5\nP | 11:47:47:339 Thread[RxComputationThreadPool-6,5,main]: 20\n  | 11:47:47:339 Thread[RxComputationThreadPool-6,5,main]: 20\nP | 11:47:47:340 Thread[RxComputationThreadPool-6,5,main]: 28\n  | 11:47:47:340 Thread[RxComputationThreadPool-6,5,main]: 28\nP | 11:47:47:340 Thread[RxComputationThreadPool-6,5,main]: 36\n  | 11:47:47:341 Thread[RxComputationThreadPool-6,5,main]: 36\nP | 11:47:47:344 Thread[RxComputationThreadPool-6,5,main]: 44\n  | 11:47:47:344 Thread[RxComputationThreadPool-6,5,main]: 44\nP | 11:47:47:344 Thread[RxComputationThreadPool-1,5,main]: 15\nP | 11:47:47:344 Thread[RxComputationThreadPool-5,5,main]: 11\nP | 11:47:47:344 Thread[RxComputationThreadPool-8,5,main]: 14\nP | 11:47:47:345 Thread[RxComputationThreadPool-5,5,main]: 19\nP | 11:47:47:345 Thread[RxComputationThreadPool-5,5,main]: 27\nP | 11:47:47:346 Thread[RxComputationThreadPool-5,5,main]: 35\nP | 11:47:47:346 Thread[RxComputationThreadPool-5,5,main]: 43\nP | 11:47:47:346 Thread[RxComputationThreadPool-5,5,main]: 51\nP | 11:47:47:346 Thread[RxComputationThreadPool-5,5,main]: 59\nP | 11:47:47:347 Thread[RxComputationThreadPool-5,5,main]: 67\nP | 11:47:47:347 Thread[RxComputationThreadPool-5,5,main]: 75\nP | 11:47:47:345 Thread[RxComputationThreadPool-1,5,main]: 23\n  | 11:47:47:345 Thread[RxComputationThreadPool-6,5,main]: 1\nP | 11:47:47:345 Thread[RxComputationThreadPool-3,5,main]: 9\nP | 11:47:47:345 Thread[RxComputationThreadPool-2,5,main]: 16\nP | 11:47:47:345 Thread[RxComputationThreadPool-4,5,main]: 10\nP | 11:47:47:348 Thread[RxComputationThreadPool-2,5,main]: 24\nP | 11:47:47:348 Thread[RxComputationThreadPool-3,5,main]: 17\n  | 11:47:47:348 Thread[RxComputationThreadPool-6,5,main]: 2\nP | 11:47:47:348 Thread[RxComputationThreadPool-2,5,main]: 32\nP | 11:47:47:347 Thread[RxComputationThreadPool-1,5,main]: 31\nP | 11:47:47:347 Thread[RxComputationThreadPool-5,5,main]: 83\nP | 11:47:47:349 Thread[RxComputationThreadPool-5,5,main]: 91\nP | 11:47:47:349 Thread[RxComputationThreadPool-5,5,main]: 99\nP | 11:47:47:345 Thread[RxComputationThreadPool-8,5,main]: 22\nP | 11:47:47:349 Thread[RxComputationThreadPool-1,5,main]: 39\nP | 11:47:47:349 Thread[RxComputationThreadPool-2,5,main]: 40\nP | 11:47:47:350 Thread[RxComputationThreadPool-1,5,main]: 47\nP | 11:47:47:350 Thread[RxComputationThreadPool-2,5,main]: 48\n  | 11:47:47:348 Thread[RxComputationThreadPool-6,5,main]: 3\nP | 11:47:47:348 Thread[RxComputationThreadPool-3,5,main]: 25\nP | 11:47:47:348 Thread[RxComputationThreadPool-4,5,main]: 18\nP | 11:47:47:351 Thread[RxComputationThreadPool-4,5,main]: 26\nP | 11:47:47:351 Thread[RxComputationThreadPool-4,5,main]: 34\nP | 11:47:47:351 Thread[RxComputationThreadPool-3,5,main]: 33\nP | 11:47:47:351 Thread[RxComputationThreadPool-3,5,main]: 41\nP | 11:47:47:352 Thread[RxComputationThreadPool-3,5,main]: 49\nP | 11:47:47:352 Thread[RxComputationThreadPool-3,5,main]: 57\nP | 11:47:47:352 Thread[RxComputationThreadPool-3,5,main]: 65\n  | 11:47:47:350 Thread[RxComputationThreadPool-6,5,main]: 6\nP | 11:47:47:350 Thread[RxComputationThreadPool-2,5,main]: 56\nP | 11:47:47:350 Thread[RxComputationThreadPool-1,5,main]: 55\nP | 11:47:47:350 Thread[RxComputationThreadPool-8,5,main]: 30\nP | 11:47:47:353 Thread[RxComputationThreadPool-2,5,main]: 64\nP | 11:47:47:352 Thread[RxComputationThreadPool-3,5,main]: 73\n  | 11:47:47:353 Thread[RxComputationThreadPool-6,5,main]: 7\nP | 11:47:47:351 Thread[RxComputationThreadPool-4,5,main]: 42\n  | 11:47:47:354 Thread[RxComputationThreadPool-6,5,main]: 8\nP | 11:47:47:354 Thread[RxComputationThreadPool-3,5,main]: 81\nP | 11:47:47:354 Thread[RxComputationThreadPool-2,5,main]: 72\nP | 11:47:47:353 Thread[RxComputationThreadPool-8,5,main]: 38\nP | 11:47:47:353 Thread[RxComputationThreadPool-1,5,main]: 63\nP | 11:47:47:355 Thread[RxComputationThreadPool-8,5,main]: 46\nP | 11:47:47:354 Thread[RxComputationThreadPool-2,5,main]: 80\nP | 11:47:47:354 Thread[RxComputationThreadPool-3,5,main]: 89\n  | 11:47:47:354 Thread[RxComputationThreadPool-6,5,main]: 9\nP | 11:47:47:354 Thread[RxComputationThreadPool-4,5,main]: 50\n  | 11:47:47:355 Thread[RxComputationThreadPool-6,5,main]: 10\nP | 11:47:47:355 Thread[RxComputationThreadPool-3,5,main]: 97\n  | 11:47:47:356 Thread[RxComputationThreadPool-6,5,main]: 11\nP | 11:47:47:355 Thread[RxComputationThreadPool-2,5,main]: 88\nP | 11:47:47:356 Thread[RxComputationThreadPool-2,5,main]: 96\nP | 11:47:47:355 Thread[RxComputationThreadPool-8,5,main]: 54\nP | 11:47:47:355 Thread[RxComputationThreadPool-1,5,main]: 71\nP | 11:47:47:357 Thread[RxComputationThreadPool-8,5,main]: 62\n  | 11:47:47:356 Thread[RxComputationThreadPool-6,5,main]: 14\nP | 11:47:47:356 Thread[RxComputationThreadPool-4,5,main]: 58\n  | 11:47:47:357 Thread[RxComputationThreadPool-6,5,main]: 15\nP | 11:47:47:357 Thread[RxComputationThreadPool-8,5,main]: 70\nP | 11:47:47:357 Thread[RxComputationThreadPool-1,5,main]: 79\nP | 11:47:47:357 Thread[RxComputationThreadPool-8,5,main]: 78\n  | 11:47:47:357 Thread[RxComputationThreadPool-6,5,main]: 16\nP | 11:47:47:357 Thread[RxComputationThreadPool-4,5,main]: 66\n  | 11:47:47:358 Thread[RxComputationThreadPool-6,5,main]: 17\nP | 11:47:47:358 Thread[RxComputationThreadPool-8,5,main]: 86\nP | 11:47:47:358 Thread[RxComputationThreadPool-1,5,main]: 87\nP | 11:47:47:358 Thread[RxComputationThreadPool-8,5,main]: 94\n  | 11:47:47:358 Thread[RxComputationThreadPool-6,5,main]: 18\nP | 11:47:47:358 Thread[RxComputationThreadPool-4,5,main]: 74\nP | 11:47:47:359 Thread[RxComputationThreadPool-4,5,main]: 82\nP | 11:47:47:359 Thread[RxComputationThreadPool-4,5,main]: 90\nP | 11:47:47:358 Thread[RxComputationThreadPool-1,5,main]: 95\n  | 11:47:47:359 Thread[RxComputationThreadPool-6,5,main]: 19\nP | 11:47:47:363 Thread[RxComputationThreadPool-4,5,main]: 98\n  | 11:47:47:363 Thread[RxComputationThreadPool-6,5,main]: 22\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 23\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 24\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 25\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 26\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 27\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 30\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 31\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 32\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 33\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 34\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 35\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 38\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 39\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 40\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 41\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 42\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 43\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 46\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 47\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 48\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 49\n  | 11:47:47:367 Thread[RxComputationThreadPool-6,5,main]: 50\n  | 11:47:47:367 Thread[RxComputationThreadPool-6,5,main]: 51\n  | 11:47:47:367 Thread[RxComputationThreadPool-6,5,main]: 54\n  | 11:47:47:367 Thread[RxComputationThreadPool-6,5,main]: 55\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 56\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 57\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 58\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 59\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 62\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 63\n  | 11:47:47:369 Thread[RxComputationThreadPool-6,5,main]: 64\n  | 11:47:47:370 Thread[RxComputationThreadPool-6,5,main]: 65\n  | 11:47:47:370 Thread[RxComputationThreadPool-6,5,main]: 66\n  | 11:47:47:370 Thread[RxComputationThreadPool-6,5,main]: 67\n  | 11:47:47:370 Thread[RxComputationThreadPool-6,5,main]: 70\n  | 11:47:47:370 Thread[RxComputationThreadPool-6,5,main]: 71\n  | 11:47:47:374 Thread[RxComputationThreadPool-6,5,main]: 72\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 73\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 74\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 75\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 78\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 79\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 80\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 81\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 82\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 83\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 86\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 87\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 88\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 89\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 90\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 91\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 94\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 95\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 96\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 97\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 98\n  | 11:47:47:378 Thread[RxComputationThreadPool-6,5,main]: 99\nP | 11:47:47:378 Thread[RxComputationThreadPool-6,5,main]: 52\n  | 11:47:47:378 Thread[RxComputationThreadPool-6,5,main]: 52\nP | 11:47:47:378 Thread[RxComputationThreadPool-6,5,main]: 60\n  | 11:47:47:378 Thread[RxComputationThreadPool-6,5,main]: 60\nP | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 68\n  | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 68\nP | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 76\n  | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 76\nP | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 84\n  | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 84\nP | 11:47:47:380 Thread[RxComputationThreadPool-6,5,main]: 92\n  | 11:47:47:380 Thread[RxComputationThreadPool-6,5,main]: 92\nP | 11:47:47:380 Thread[RxComputationThreadPool-6,5,main]: 100\n  | 11:47:47:380 Thread[RxComputationThreadPool-6,5,main]: 100\n  | 11:48:02:339 Thread[RxComputationThreadPool-7,5,main]: 5\nP | 11:48:02:339 Thread[RxComputationThreadPool-7,5,main]: 13\n  | 11:48:02:339 Thread[RxComputationThreadPool-7,5,main]: 13\nP | 11:48:02:339 Thread[RxComputationThreadPool-7,5,main]: 21\n  | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 21\nP | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 29\n  | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 29\nP | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 37\n  | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 37\nP | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 45\n  | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 45\nP | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 53\n  | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 53\nP | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 61\n  | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 61\nP | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 69\n  | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 69\nP | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 77\n  | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 77\nP | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 85\n  | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 85\nP | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 93\n  | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 93\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-01-07T18:32:26Z",
        "body": "Okay, now I see it. What happens is that the threads of the computation scheduler get assigned to in a round-robin fashion, the 13th, 21th, etc value will queue up behind 5 and won't get executed until the sleep runs out.\n\nThe reason the fixed threadpool works is because it doesn't have value-to-thread pinning like the computation scheduler. Since each value runs individually, a pool thread can pick it any time and execute it; nobody has to wait on a sleeping thread if there are enough available threads.\n"
      },
      {
        "user": "ottboy4",
        "created_at": "2016-01-07T19:21:11Z",
        "body": "Great explanation. I believe I understand it now.\n\nHowever, why is it that the computation scheduler performs like that? Is there a benefit of doing it that way?\nFrom what I can see in this example I would rather have the functionality of the fixed thread pool over using the computation scheduler. \n\nThe main reason this is an issue is I specify maxConcurrent in the flatMap (since my producer produces items faster than my threads can process the items). Which this now causes the rest of the items to not be processed till my slow thread finishes.\n\nTry this code now, with the maxConcurrent specified. Now you should see that it processes about half the items and stops (waiting on the slow thread), then after the slow thread picks up the rest of the items are processed.\n\n```\nObservable.range(1, 100)\n        .flatMap(v -> Observable.just(v)\n                .subscribeOn(Schedulers.computation())\n                .map(u -> {\n                    System.out.printf(\"P | %s: %s%n\", Thread.currentThread(), u);\n                    if (u == 5) {\n                        try {\n                            Thread.sleep(15_000);\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    return u;\n                }), 8)\n        .doOnNext(v -> {\n            System.out.printf(\"  | %s: %s%n\", Thread.currentThread(), v);\n        }).toBlocking().subscribe();\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-01-07T19:45:51Z",
        "body": "> Is there a benefit of doing it that way?\n\nYes, schedulers create workers, which are practically threads, that execute the work sequentially in respect of each other. This is in line with the sequential requirement of subscribers thus there is no need and overhead of making every inner component fully thread safe. In addition, this pinning gives cache locality. In summary, it has performance benefits.\n\nUsing `Scheduler.from` doesn't have this same-thread guarantee (although it is sequential still) and hops threads at random. This is generally slower but can handle your blocking situation much better.\n\n> Which this now causes the rest of the items to not be processed till my slow thread finishes.\n\nthreads are round robin assigned to values but this time you can have only 8 concurrent subscriptions. After a dozen elements, all that remains are those who have been assigned the thread that is blocked.\n"
      },
      {
        "user": "ottboy4",
        "created_at": "2016-01-07T20:03:19Z",
        "body": "Perfect. Thank you for the explanation.\n\nFor my case, I will probably switch over to `Scheduler.from` with a fixed thread pool since that will give me better performance for what I am trying to achieve. \n"
      }
    ]
  },
  {
    "number": 3598,
    "title": "BehaviorSubject deadlocks when using subject.single().toBlocking().single()",
    "created_at": "2016-01-05T00:31:43Z",
    "closed_at": "2016-01-05T16:50:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3598",
    "body": "When I use `.single().toBlocking().single()` on a `BehaviorSubject` (where a default item has been set), it will deadlock the following test. When `.take(1).toBlocking().single()` is used, the test completes successfully.\n\n``` java\nSystem.out.println(\"take(1) started\");\nBehaviorSubject.create(\"Item\").take(1).toBlocking().single();\nSystem.out.println(\"take(1) finished\");\n\nSystem.out.println(\"single() started\");\nBehaviorSubject.create(\"Item\").single().toBlocking().single(); // Deadlocks here\nSystem.out.println(\"single() finished\");\n```\n\nAm I doing something wrong here?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3598/comments",
    "author": "austynmahoney",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-01-05T08:12:51Z",
        "body": "`Observable.single` requires 1 element and 1 completion signal to emit a single item or 2 elements to emit an overflow error. Since there is no more item, the second stream will hang indefinitely. This is the expected behavior.\n"
      },
      {
        "user": "austynmahoney",
        "created_at": "2016-01-05T16:50:35Z",
        "body": "Thanks for the confirmation.\n"
      }
    ]
  },
  {
    "number": 3594,
    "title": "Why the executors only use one thread?",
    "created_at": "2015-12-30T11:27:23Z",
    "closed_at": "2015-12-31T10:09:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3594",
    "body": "I have created a fixed thread-pool to process an event emit per 300 milliseconds and assume the process need 1000 millisecond. Suppose the multi-thread will work but only one thread reused.\n\nIf i set the sleepTime smaller than 300ms, the processing thread change, but that is useless.\n\nQuestions: What can I do to make it concurrent? Why the program reuse the thread?\n\nThank you in advance\n\n``` java\npublic static void main(String[] args) throws InterruptedException {\n    long sleepTime = 1000;\n    ExecutorService e = Executors.newFixedThreadPool(3);\n\n    Observable.interval(300, TimeUnit.MILLISECONDS)\n    .subscribeOn(Schedulers.computation())\n    .flatMap(new Func1<Long, Observable<Long>>() {\n        @Override\n        public Observable<Long> call(Long pT) {\n            return Observable.just(pT).subscribeOn(Schedulers.from(e));\n        }\n    })\n    .doOnNext(new Action1<Long>() {\n\n        @Override\n        public void call(Long pT) {\n            try {\n                Thread.sleep(sleepTime);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    })\n    .subscribe(new Action1<Long>() {\n\n        @Override\n        public void call(Long pT) {\n            System.out.println(\"i am \" + pT + \"in thread:\" + Thread.currentThread().getName());\n\n        }\n    });\n\n\n    Thread.sleep(50000);\n    e.shutdownNow();\n\n}\n\n\n\ni am 0in thread:pool-1-thread-1\ni am 1in thread:pool-1-thread-1\ni am 2in thread:pool-1-thread-1\ni am 3in thread:pool-1-thread-1\ni am 4in thread:pool-1-thread-1\ni am 5in thread:pool-1-thread-1\ni am 6in thread:pool-1-thread-1\ni am 7in thread:pool-1-thread-1\ni am 8in thread:pool-1-thread-1\ni am 9in thread:pool-1-thread-1\ni am 10in thread:pool-1-thread-1\ni am 11in thread:pool-1-thread-1\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3594/comments",
    "author": "rockman12352",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-12-30T12:09:59Z",
        "body": "Its a thread pool and if you don't have high enough throughput, it won't even create new threads. That single thread can serve all tasks easily.\n"
      },
      {
        "user": "rockman12352",
        "created_at": "2015-12-30T14:46:33Z",
        "body": "@akarnokd Thank you for your reply. I have set sleep time, it doesn't count?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-12-30T14:53:51Z",
        "body": "What happens is that the first `just` value runs on the other scheduler and gets blocked by sleep so that the other values have plenty of time to run and get queued up in flatMap. Once the first thread unblocks it finds a ton of values available and resumes emitting on the same thread. Thus, on the output side, only one thread shows up but inside, just execute on the rest of the thread. put doOnNext on those inner sequences and see where they run.\n"
      },
      {
        "user": "rockman12352",
        "created_at": "2015-12-30T17:24:53Z",
        "body": "@akarnokd With your advice, i modify the code. just and sleep are not in the same thread. So it should not effect each other\n"
      },
      {
        "user": "rockman12352",
        "created_at": "2015-12-31T02:40:19Z",
        "body": "@akarnokd Finally, i got what you mean, you are right!  Million thanks!\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-12-31T10:09:02Z",
        "body": "Great!\n"
      }
    ]
  },
  {
    "number": 3593,
    "title": "Intellij auto import error ",
    "created_at": "2015-12-30T10:19:17Z",
    "closed_at": "2016-02-09T14:16:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3593",
    "body": "Bad   method call from inside of a branch Exception Details: Location: nebula/core/NamedContainerProperOrder. (Ljava/lang/Class;Lorg/gradle/internal/reflect/Instantiator;Lgroovy/lang/Closure;)V @125: invokespecial Reason: Error exists in the bytecode Bytecode: 0000000: b800 173a 0406 bd00 2859 032b 5359 042c 0000010: 5359 052d 5359 10ff 1205 b800 2e2a 5fab 0000020: 0000 0147 0000 0006 d8f5 c64c 0000 0039 0000030: e5f5 61f5 0000 0064 11f8 6d3a 0000 009b 0000040: 4408 d7d4 0000 00d2 59b0 7b8f 0000 00fd 0000050: 741a af72 0000 0128 5f5a 5903 32b8 0034 0000060: c000 365f 5904 3212 38b8 003c c000 385f 0000070: 5905 3212 3eb8 003c c000 3e5f 57b7 0040 0000080: a700 f05f 5a59 0332 b800 34c0 0036 5f59 0000090: 0432 1238 b800 3cc0 0038 5f59 0532 123e 00000a0: b800 3cc0 003e 5f59 0632 1242 b800 3cc0 00000b0: 0042 5f57 b700 45a7 00b9 5f5a 5903 32b8 00000c0: 0034 c000 365f 5904 3212 38b8 003c c000 00000d0: 385f 5905 3212 3eb8 003c c000 3e5f 5906 00000e0: 3212 47b8 003c c000 475f 57b7 004a a700 00000f0: 825f 5a59 0332 b800 34c0 0036 5f59 0432 0000100: 1238 b800 3cc0 0038 5f59 0532 1247 b800 0000110: 3cc0 0047 5f57 b700 4da7 0057 5f5a 5903 0000120: 32b8 0034 c000 365f 5904 3212 38b8 003c 0000130: c000 385f 5905 3212 42b8 003c c000 425f 0000140: 57b7 0050 a700 2c5f 5a59 0332 b800 34c0 0000150: 0036 5f59 0432 1238 b800 3cc0 0038 5f57 0000160: b700 19a7 000d bb00 5259 1254 b700 57bf 0000170: 572a b600 1d3a 0519 052a 5fb5 001f 1905 0000180: 57b1 Stackmap Table: full_frame(@88,{UninitializedThis,Object[#54],Object[#56],Object[#71],Object[#91]},{Object[#93],UninitializedThis}) full_frame(@131,{UninitializedThis,Object[#54],Object[#56],Object[#71],Object[#91]},{Object[#93],UninitializedThis}) full_frame(@186,{UninitializedThis,Object[#54],Object[#56],Object[#71],Object[#91]},{Object[#93],UninitializedThis}) full_frame(@241,{UninitializedThis,Object[#54],Object[#56],Object[#71],Object[#91]},{Object[#93],UninitializedThis}) full_frame(@284,{UninitializedThis,Object[#54],Object[#56],Object[#71],Object[#91]},{Object[#93],UninitializedThis}) full_frame(@327,{UninitializedThis,Object[#54],Object[#56],Object[#71],Object[#91]},{Object[#93],UninitializedThis}) full_frame(@358,{UninitializedThis,Object[#54],Object[#56],Object[#71],Object[#91]},{Object[#93],UninitializedThis}) full_frame(@368,{Object[#2],Object[#54],Object[#56],Object[#71],Object[#91]},{Object[#93]}) \n\nAny idea to fix the issue?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3593/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "zsxwing",
        "created_at": "2015-12-30T18:15:02Z",
        "body": "How did you import it? I guess it may because the version conflicts of gradle. Could you just use the default gradle wrapper to import?\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-01-01T14:41:21Z",
        "body": "Thanks, I will try your solution tomorrow.\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2016-01-31T03:07:06Z",
        "body": "@suiwenfeng any news? If you've resolved this issue — please close it or add more info to continue investigation, thanks!\n"
      }
    ]
  },
  {
    "number": 3581,
    "title": "observable.first() not working properly after grouping data",
    "created_at": "2015-12-18T00:08:57Z",
    "closed_at": "2016-01-31T02:58:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3581",
    "body": "I am calling things like this\n\n```\nObservable.just(1, 2, 3, 4, 5, 6)\n                .groupBy(i -> i % 3)\n                .flatMap(o -> o.first())\n                .subscribe(System.out::println);\n```\n\nIdeally this should return 1,2,3\nBut the result is - \n\n```\n1\n2\n3\n4\n5\n6\n```\n\ngot this issue in version 1.0.10 and 1.1.0 as well\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3581/comments",
    "author": "eyeced",
    "comments": [
      {
        "user": "zsxwing",
        "created_at": "2015-12-18T00:15:40Z",
        "body": "This is expected. `groupBy` will emit a new `Observable` if the previous `Observable` of the same group is subscribed.\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2015-12-21T04:50:07Z",
        "body": "This has been discussed in #3411. It's about time I made this clearer in the javadoc so I'll knock up a PR soon.\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2016-01-31T02:49:42Z",
        "body": "Looks like this issue can be closed? \n"
      },
      {
        "user": "zsxwing",
        "created_at": "2016-01-31T02:58:29Z",
        "body": "#3584 has updated the doc.\n"
      }
    ]
  },
  {
    "number": 3571,
    "title": "OperatorTake/SafeSubscriber fail to propagate an exception",
    "created_at": "2015-12-11T12:00:58Z",
    "closed_at": "2016-03-14T00:30:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3571",
    "body": "Here is a rough version of my code:\n\n``` java\nObject state = ...\nAction1<Object> action = ...\n\nObservable.timer(delayMs, TimeUnit.MILLISECONDS, SchedulerUtils.mainThread())\n    .doOnUnsubscribe(() -> <unrelated code>)\n    .first()\n    .takeUntil(anotherObserbable)\n    .filter(time -> <unrelated code>)\n    .subscribe(ok -> action.call(state))\n```\n\nWhen `action.call` throws, the following seems to happen:\n- SafeSubscriber notifies my RxJavaErrorHandler about the exception - a ClassCastException, to be precise. This is actually useless, because the handler is global and does not have a clue about that particular exception, and whether onError will be able to handle it or not. All of this is ok.\n- The exception is further handled by SafeSubscriber by producing an OnErrorNotImplemented exception and throwing it. My RxJavaErrorHandler is not notified about that exception, which may or may not be ok.\n- OperatorTake decides to silently swallow the exception, because it is. well, _completed_. Or, maybe, someone else does, I can't make heads or tails of RxJava logging at that point. Regardless, the exception never reaches Scheduler or any of my global exception handling routines.\n\nI believe, that there is a single thing, that should be done there: make SafeSubscriber directly call current `Thread.UncaughtExceptionHandler` with OnErrorNotImplemented before attempting to throw it. \"Unsafe\" operators may be incapable of handling exceptions at that point, and the situation, when observable without onError throws, is a hopeless condition anyway.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3571/comments",
    "author": "Alexander--",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-12-11T15:18:12Z",
        "body": "Hi.\n\nThe problem with `onError` is that it can only safely travel downstream, but if it missed that opportunity (i.e., by happening after a terminal event or due to an unimplemented error handler) it can't go anywhere else but to the plugin error handler. \n\nYou may think the uncaught exception handler is a viable option but its behavior is platform dependent: on desktop, it either gets swallowed or printed to the console; on Android, it will crash the entire application.\n\nPropagating fatal exceptions also has its limits. At best, they can only go as far as the next asynchronous boundary at which point there is nowhere to go. \n\nThe second problem I believe the misguide caused by the case where there is no async boundary (because you have a completely synchronous sequence) and your `subscribe` method will throw in the current thread, strenghtening the classical try-catch world view unfortunately.\n\nThis means you can't reliably get away from handling exceptions either via the `onErrorXXX` method or simply using the `subscribe(Action1<T>, Action1<Throwable>)` overload which will call the second action with the exception thrown from the first one properly.\n"
      },
      {
        "user": "Alexander--",
        "created_at": "2015-12-11T18:15:49Z",
        "body": "Sorry, but this is not a question. This is a bug report. If you plan to argue in favor of silently swallowing exceptions, say so and close it. I can patch the library just fine.\n\n> You may think the uncaught exception handler is a viable option but its behavior is platform dependent\n\nAs long as error handler is controlled by myself, it is fine. Unfortunately, OnErrorNotImplementedException does not reach any handlers in example above.\n\n> you can't reliably get away from handling exceptions either via the onErrorXXX method or simply using the subscribe\n\nBullshit. `onError` isn't supposed to throw, this is stated numerous times in RxJava documentation. This is exactly why another way to propagate the fatal exception has to be used. `Thread.UncaughtExceptionHandler` is the most sensible of such methods, used by every single error reporting framework out there. But I would be fine with applying a workaround in form RxJavaErrorHandler. Unfortunately, that does not get called either.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-12-11T18:40:44Z",
        "body": "Could you post a runnable JUnit test method that demonstrates the problem?\n\nAs for the workaround, you can use the two parameter subscribe:\n\n``` java\nObservable.just(1)\n        .subscribe(v -> { throw new RuntimeException(); },\n                e -> Thread.currentThread()\n                .getUncaughtExceptionHandler()\n                .uncaughtException(Thread.currentThread(), e)\n        );\n```\n"
      }
    ]
  },
  {
    "number": 3558,
    "title": "BlockingObservable.blockForSingle() can throw exception that doesn't have a stacktrace for the current thread",
    "created_at": "2015-12-04T16:29:46Z",
    "closed_at": "2016-03-14T00:29:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3558",
    "body": "lines 452:\n\n```\n       if (returnException.get() != null) {\n            if (returnException.get() instanceof RuntimeException) {\n                throw (RuntimeException) returnException.get();\n            } else {\n                throw new RuntimeException(returnException.get());\n            }\n        }\n```\n\n`throw (RuntimeException) returnException.get();` throws an exception for another thread resulting in unhelpful stack traces such as \n\n```\njava.util.NoSuchElementException: Sequence contains no elements\n    at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:131)\n    at rx.internal.operators.OperatorTake$1.onCompleted(OperatorTake.java:50)\n    at rx.internal.operators.OperatorFilter$1.onCompleted(OperatorFilter.java:42)\n    at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:44)\n    at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:69)\n    at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:51)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:744)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3558/comments",
    "author": "cer",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-12-08T21:42:03Z",
        "body": "We wanted to avoid wrapping a `RuntimeException`. The analogous `Future.get()` does wrap everything and throws a checked `ExecutionException`. Even if we wrap the exception into an unchecked exception in the operator, that counts as an incompatible API change.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-14T00:29:06Z",
        "body": "I'm closing this. Let me know if you have further questions.\n"
      }
    ]
  },
  {
    "number": 3557,
    "title": "onErrorResumeNext/OperatorOnErrorResumeNextViaFunction ignoring unsubscription?",
    "created_at": "2015-12-04T09:45:35Z",
    "closed_at": "2015-12-04T13:54:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3557",
    "body": "I first wanted to ask, just in case, to check if the behavior I'm going to describe is the expected.\n\nIt happens that using the operator `OperatorOnErrorResumeNextViaFunction` seems to ignore the **unsubscription** event.\n\nI had this code for testing it.\n\n``` java\n        final AtomicBoolean readyToUnsubscribe = new AtomicBoolean(false);\n        final AtomicBoolean readyToFail = new AtomicBoolean(false);\n        final ReentrantLock lock = new ReentrantLock();\n        final Condition rtuCond = lock.newCondition();\n        final Condition rtfCond = lock.newCondition();\n\n\n        Subscription subscribe = Observable.create(\n                new Observable.OnSubscribe<String>() {\n                    @Override\n                    public void call(Subscriber<? super String> subscriber) {\n                        lock.lock();\n                        System.out.println(\"Subscription started: \" + !subscriber.isUnsubscribed());\n                        readyToUnsubscribe.set(true);\n                        rtuCond.signal();\n                        try {\n                            while (!readyToFail.get()) {\n                                rtfCond.await();\n                            }\n                        } catch (InterruptedException e) {\n                            Exceptions.throwIfFatal(e);\n                        } finally {\n                            lock.unlock();\n                        }\n                        System.out.println(\"Gonna fail\");\n                        throw new RuntimeException(\"Yup Crashing Bad!\");\n                    }\n                }\n        )\n                .onErrorResumeNext(\n                        new Func1<Throwable, Observable<? extends String>>() {\n                            @Override\n                            public Observable<? extends String> call(Throwable throwable) {\n                                return Observable.just(\"Recovered from: \" + throwable.getMessage());\n                            }\n                        }\n                )\n                .subscribeOn(Schedulers.io())\n                .subscribe(\n                        new Action1<String>() {\n                            @Override\n                            public void call(String s) {\n                                System.out.println(\"Got message: \" + s);\n                            }\n                        },\n                        new Action1<Throwable>() {\n                            @Override\n                            public void call(Throwable throwable) {\n                                throwable.printStackTrace(System.err);\n                            }\n                        },\n                        new Action0() {\n                            @Override\n                            public void call() {\n                                System.out.println(\"Completed\");\n                            }\n                        }\n                );\n\n        lock.lock();\n        while (!readyToUnsubscribe.get()) {\n            rtuCond.await();\n        }\n        subscribe.unsubscribe();\n        System.out.println(\"Now this is unsubscribed\");\n        readyToFail.set(false);\n        rtfCond.signal();\n        lock.unlock();\n```\n\nWhich gives the output\n\n```\nSubscription started: true\nNow this is unsubscribed\nGonna fail\nGot message: Recovered from: Yup Crashing Bad!\nCompleted\n```\n\nAnd I would have expected none of the Obsever's methods to be called indeed, that is last two lines of output should't be there. But this is my understanding, can somebody confirm if this should be considered a bug, or is it expected behavior of the onErrorResumeNext operator?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3557/comments",
    "author": "davidgarciaanton",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-12-04T10:16:14Z",
        "body": "Unsubscription is best effort so events may still slip through. In particular, `just` ignores backpressure and unsubscription completely. If you use `just(\"Recovered from: \" + throwable.getMessage(), \"\")`, it won't emit anything because that overload is more eager with unsubscription.\n"
      },
      {
        "user": "davidgarciaanton",
        "created_at": "2015-12-04T13:54:44Z",
        "body": "OK!\n\nThanks a lot @akarnokd for the clarification, so the problem was somewhere else I didn't just imagine. Thanks for pointing that out.\n\nJust closing this, as for me it's now clear.\n"
      }
    ]
  },
  {
    "number": 3554,
    "title": "Observable.combineLatest ignores onCompleted?",
    "created_at": "2015-12-03T07:23:10Z",
    "closed_at": "2016-02-09T14:13:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3554",
    "body": "Hello. This is the code:\n\n``` java\nimport rx.Observable;\nimport rx.subjects.PublishSubject;\n\nfinal class OnNextIngored {\n\n   public static void main(final String[] args) {\n\n      final PublishSubject<Integer> publisher = PublishSubject.create();\n\n      // pass any arg to fail the day!\n      final boolean doFail = args.length != 0;\n\n      final Observable<Integer> possiblyFail\n         = Observable.<Integer>create(subscriber\n                                      -> {\n\n                                         if (doFail) {\n                                            subscriber.onError(new RuntimeException(\"blah\"));\n                                         } else {\n                                            subscriber.onNext(2);\n                                            subscriber.onCompleted();\n                                         }\n                                      });\n\n      publisher\n         .startWith(// combine latest ignores onCompleted ?\n                    Observable.combineLatest(possiblyFail ,\n                                             Observable.just(1),\n                                             (l, r) -> r + l)\n                    .take(2))\n         .onErrorResumeNext(Observable.just(4))\n         .subscribe(i -> {\n               log(\"i is: \" + i);\n            },\n            e -> {\n               log(\"error is: \" + e);\n            },\n            () -> {\n               log(\"completed\");\n            } );\n\n      publisher.onNext(5);\n      publisher.onNext( 6 );\n      publisher.onNext(7);\n   }\n\n   private static void log(final String s) {\n      System.out.println(s);\n   }\n}\n```\n\nDepending on value of doFail (which can be changed by passing arg to test app) the conveyor receives or does not receive onCompleted and thus it does or does not ignore onNext:\n\n```\n[elk@qulix-elktop java-rxjava]$ java -cp rxjava-1.0.16.jar:. OnNextIngored 4\ni is: 4\ncompleted\n[elk@qulix-elktop java-rxjava]$ java -cp rxjava-1.0.16.jar:. OnNextIngored \ni is: 3\ni is: 5\ni is: 6\ni is: 7\n```\n\nIs it expected behavior? If yes, why?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3554/comments",
    "author": "alosich",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-12-03T09:09:46Z",
        "body": "You don't call `publisher.onCompleted()` so the Subscriber won't receive it. If you start it to make error, it completes because the `onErrorResumeNext` receives the error before `publisher` is subscribed by `startWith`.\n"
      },
      {
        "user": "alosich",
        "created_at": "2015-12-03T09:26:32Z",
        "body": "@akarnokd ok, it seems I got it, thanks.\n"
      }
    ]
  },
  {
    "number": 3541,
    "title": "Recommended way of applying operators to items in sequence of collections?",
    "created_at": "2015-11-26T12:11:41Z",
    "closed_at": "2015-11-26T17:00:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3541",
    "body": "When I want to transform the items in collections emitted in a stream, I find myself doing something like this:\n\n``` java\nObservable<List<Integer>> integerLists = …\n// Emits [1, 2, 3], [4, 5, 6]\n\nintegerLists.concatMap(list -> Observable.from(list).map(x -> x * 2).toList())\n// Emits  [2, 4, 6], [8, 10,12]\n```\n\nIs there are cleaner/recommended way to achieve the same that doesn't require the 'Observable.from … toList' bit?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3541/comments",
    "author": "danhawkes",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-11-26T12:20:52Z",
        "body": "If you want to avoid in-place mutation, you can use Java Streams which looks almost the same:\n\n``` java\nObservable<List<Integer>> source = Observable.just(\n    Arrays.asList(1, 2, 3), Arrays.asList(4, 5, 6));\n\nsource.map(list -> list.stream().map(i -> i * 2).collect(Collectors.toList()))\n.subscribe(System.out::println);\n```\n\nSo essentially the pattern stays the same.\n"
      },
      {
        "user": "danhawkes",
        "created_at": "2015-11-26T17:00:04Z",
        "body": "Right, ok. Thanks for the answer.\n"
      }
    ]
  },
  {
    "number": 3538,
    "title": "AttachSubscriptionOperator",
    "created_at": "2015-11-23T15:45:29Z",
    "closed_at": "2015-11-24T10:27:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3538",
    "body": "Here is an example of an operator that attaches a `Subscription` to the operator's subscriber:\n\n```\npublic class AttachSubscriptionOperator<T> implements Observable.Operator<T, T> {\n\n    private final Subscription subscription;\n\n    public AttachSubscriptionOperator(Subscription subscription) {\n        this.subscription = subscription;\n    }\n\n    @Override\n    public Subscriber<? super T> call(Subscriber<? super T> child) {\n        child.add(subscription);\n        return child;\n    }\n\n}\n```\n\nDoes it make sense to create a PR with an `Observable#attach()` method? I personally find it useful but is it really or indicates bad code design (because the subscriptions are getting attached to subscribers, thus creating confusion)?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3538/comments",
    "author": "Diolor",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-11-23T16:11:33Z",
        "body": "Why would you want to attach a Subscription to every Subscriber that comes along?\n"
      },
      {
        "user": "Diolor",
        "created_at": "2015-11-23T19:29:55Z",
        "body": "I used it with a ConnectableObservable so there was just one Subscriber in that case.\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2015-11-24T09:45:30Z",
        "body": "The operator you describe already exists and is called `.doOnUnsubscribe`.\n\nA quick note for you that the Operator as you've coded it has a bug in that the `onStart` method of `child` would be called twice.  For this reason the implementation of `doOnUnsubscribe` returns `Subscribers.wrap(child)` instead of `child`.\n"
      },
      {
        "user": "Diolor",
        "created_at": "2015-11-24T10:27:46Z",
        "body": "thanks for all the info @davidmoten :+1: \n"
      }
    ]
  },
  {
    "number": 3533,
    "title": "Adjust backpressure buffer (onBackpressureLatest/observeOn used)",
    "created_at": "2015-11-18T22:22:01Z",
    "closed_at": "2016-03-14T00:18:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3533",
    "body": "RxJava 1.0.16:\n\nI have an `interval()` which emits items (created in `computation` thread) with a rate of e.g. 100ms.\nI then change the thread and my scheduler can consume with are rate of 1s and requests 1 item per time.\n\n(Android) code:\n\n``` java\ninterval(0, 100, TimeUnit.MILLISECONDS) // computation thread\n        .doOnNext(aLong -> wtf(\"Interval onNext\", String.valueOf(aLong)))\n        .onBackpressureLatest()\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe(new Subscriber<Long>() {\n\n            @Override\n            public void onStart() {Consumed\n                super.onStart();\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                e.printStackTrace();\n            }\n\n            @Override\n            public void onNext(Long aLong) {\n                try {\n                    Thread.sleep(1000);\n                    wtf(\"Consumed\", String.valueOf(aLong));\n                    request(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n```\n\nThe code above will print:\n\n```\nInterval onNext: 0\nInterval onNext: 1\n    ...\nInterval onNext: 10\nConsumed: 0\nInterval onNext: 11\n// and after a while:\nInterval onNext: 162\nConsumed: 15\nInterval onNext: 163\n    ...\nInterval onNext: 173\nConsumed: 162\nInterval onNext: 174\n```\n\n---\n##### Feature question/proposal:\n\nThe jump form \"Consumed 15\" to \"324\" is because the RxRingBuffer.SIZE in Android is 16. The only way to make it lower number is to create a new `OperatorObserveOn` which requests 1 instead of the 16. Which is ugly solution. Any thoughts on that?\n\n---\n##### Question:\n\nEven if my new \"OperatorObserveOn\" which requests only 1 item (described above) is used instead of the observeOn, then the \"Consumed\" will not be a sequence of 16 but a \"more real time-ish\" result:\n\n```\nInterval onNext: 0\n    ...\nInterval onNext: 10\nConsumed: 0\nInterval onNext: 11\n    ...\nInterval onNext: 20\nConsumed: 10\nInterval onNext: 21\n    ...\nInterval onNext: 30\nConsumed: 20\n```\n\nStill, the \"Consumed\" is receiving the emition of the last \"Inverval onNext\". Is the lock in `OperatorOnBackpressureLatest.LatestEmitter` working as expected?\nIs something like \"as soon as my subscriber requests I want the really latest object - drop the previous ones\" with RxJava? The example below will look like the expected behavior. Assuming always that we have a slower consumption that object generation and different threads. \n\n```\nInterval onNext: 0\n    ...\nInterval onNext: 10\nConsumed: 10\nInterval onNext: 11\n    ...\nInterval onNext: 20\nConsumed: 20\nInterval onNext: 21\n    ...\nInterval onNext: 30\nConsumed: 30\n```\n\n---\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3533/comments",
    "author": "Diolor",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-02-09T14:11:20Z",
        "body": "The operator `onBackpressureLatest` can introduce disontinuity, especially if the drain happens on another thread and the latest value keeps changing underneath even if there are plenty of requests.\n\nThe javadoc states this:\n\n> Note that due to the nature of how backpressure requests are propagated through subscribeOn/observeOn, requesting more than 1 from downstream doesn't guarantee a continuous delivery of onNext events.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-14T00:18:47Z",
        "body": "I don't know if `observeOn` will expose its prefetch amount in 1.x.\n\nI'm closing this old question for now. Let me know if you need further assistance.\n"
      }
    ]
  },
  {
    "number": 3522,
    "title": "Why does the scan operator only emit the initialValue when receiving the first value from the observable (or on completion)?",
    "created_at": "2015-11-13T14:20:11Z",
    "closed_at": "2015-11-13T14:56:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3522",
    "body": "Hello, I am wondering why the scan() method with an initialValue only emits the initialValue when the first value from the observable arrives. I had expected this to happen instantly upon subscription. \n\nFor now, I worked around this issue by NOT providing an initialValue, and adding \".startWith()\" to the observable I am scanning. \n\nIn the `OperatorScan` class:\n\n``` java\n\n        return new Subscriber<T>(child) {\n            ...\n\n            @Override\n            public void onNext(T currentValue) {\n                emitInitialValueIfNeeded(child);\n                ...\n                child.onNext(this.value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                child.onError(e);\n            }\n\n            @Override\n            public void onCompleted() {\n                emitInitialValueIfNeeded(child);\n                child.onCompleted();\n            }\n        }\n```\n\nExample scenario: scan an observable that counts from 0 to 4, emitting a number every second.\n\n``` java\nObservable\n    .create(new Observable.OnSubscribe<Integer>() {\n        @Override\n        public void call(Subscriber<? super Integer> subscriber) {\n            for (int i = 0; i < 5; i++) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    subscriber.onError(e);\n                }\n                subscriber.onNext(i);\n            }\n            subscriber.onCompleted();\n        }\n    })\n    .scan(0, new Func2<Integer, Integer, Integer>() {\n        @Override\n        public Integer call(Integer sum, Integer nextNumber) {\n            return sum + nextNumber;\n        }\n    })\n```\n\nThe timeline of this observable would be:\n\n0ms : subscribe()\n1000ms: 0 <- the initial value\n1001ms: 0 <- the acummulated result of 0 + the initial value\n2000ms: 1 <- the accumulated result of 1 + 0\n3000ms: 3 <- the accumulated result of 2 + 1\n4000ms: 6 <- the accumulated result of 3 + 2\n5000ms: 10 <- the accumulated result of 4 + 6\n\nMy question is: why does this happen lazily. Why not immediately call `child.onNext(initialValue)` when the subscription starts? Why does the given example not produce value 0 at 1 ms? \n\nThank you in advance.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3522/comments",
    "author": "amoerie",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-11-13T14:38:30Z",
        "body": "This was a bug with 1.0.14 and has been fixed in 1.0.15. You should, however, switch to 1.0.16 instead as 1.0.15 had a regression bug with null initial value.\n"
      },
      {
        "user": "amoerie",
        "created_at": "2015-11-13T14:56:50Z",
        "body": "Ah ok, I was indeed not running on the latest version, my apologies. That seems to have fixed the problem! Thanks for the quick response.\n"
      }
    ]
  },
  {
    "number": 3520,
    "title": "Timeout exception occurs on unexpected thread",
    "created_at": "2015-11-13T09:29:44Z",
    "closed_at": "2016-02-09T14:05:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3520",
    "body": "Not sure if this is a bug or a misunderstanding of the way timeouts should work.\n\nWhen specifiying a timeout on an observable in combination with a Scheduler to observeOn, the exception exception handling code does not occur on the scheduler but on an RxComputationThread. For an example see the test class below. This has 2 tests which both create an Observable and modify it to observe on a custom scheduler with a single named thread. One throws an exception explicitly and we can see the onError() method being called on the named thread. The second specifies a timeout of 100ms then delays by a second before sending emissions, so causing a TimeoutException - however this exception happens on a computation thread.\n\nIn my production code I'm using JavaFX and am specifying a scheduler that runs on the JavaFX thread so I can update controls and display error popups safely, but if a timeout occurs I'm having to wrap in a  Runnable and call Platform.runLater() which seems to defeat the point. I can't find any explicit documentation on this so not sure whether this is intentional or a bug, or whether I'm using it incorrectly.\n\n**EDIT**: It seems that ordering the timeout() call **before** the observeOn() call has the desired result - is this the way it should be used?\n# \n\n``` java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\n\nimport org.junit.Test;\nimport rx.Observable;\nimport rx.Scheduler;\nimport rx.Subscriber;\nimport rx.schedulers.Schedulers;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests to ensure RxJava events are on the expected threads\n */\npublic class RxJavaThreadTest {\n\n  @Test\n  public void sendValuesAndException() throws InterruptedException {\n    Observable<String> observable = createObservable(this::sendValuesAndThrowable);\n    MySubscriber subscriber = new MySubscriber();\n    observable\n          .observeOn(createNamedScheduler(\"My thread\"))\n          .subscribe(subscriber);\n    subscriber.awaitCompletion();\n\n    assertThat(subscriber.getThrowable()).hasMessage(\"my exception\");\n    assertThat(subscriber.onErrorThreadName()).isEqualTo(\"My thread\");\n  }\n\n  @Test\n  public void timeout() throws InterruptedException {\n    Observable<String> observable = createObservable(this::sendValuesWithDelay);\n    MySubscriber subscriber = new MySubscriber();\n    observable\n          .observeOn(createNamedScheduler(\"My thread\"))\n          .timeout(100, TimeUnit.MILLISECONDS)\n          .subscribe(subscriber);\n    subscriber.awaitCompletion();\n\n    assertThat(subscriber.getThrowable()).isExactlyInstanceOf(TimeoutException.class);\n    assertThat(subscriber.onErrorThreadName()).isEqualTo(\"My thread\");\n  }\n\n  private Scheduler createNamedScheduler(String name) {\n    return Schedulers.from(Executors.newSingleThreadExecutor(runnable -> new Thread(runnable, name)));\n  }\n\n  private Observable<String> createObservable(Consumer<Subscriber<? super String>> consumer) {\n    return Observable.create(new Observable.OnSubscribe<String>() {\n      @Override\n      public void call(Subscriber<? super String> sub) {\n        consumer.accept(sub);\n      }\n    });\n  }\n\n  private void sendValuesAndThrowable(Subscriber<? super String> sub) {\n    sub.onNext(\"a\");\n    sub.onNext(\"b\");\n    sub.onNext(\"c\");\n    sub.onError(new Exception(\"my exception\"));\n  }\n\n  private void sendValuesWithDelay(Subscriber<? super String> sub) {\n    //Pause for a second before sending data\n    try {\n      Thread.sleep(1000);\n    } catch (InterruptedException e) {\n      //ignore\n    }\n    sub.onNext(\"a\");\n    sub.onNext(\"b\");\n    sub.onNext(\"c\");\n    sub.onCompleted();\n  }\n\n  private static class MySubscriber extends Subscriber<String> {\n\n    private final CountDownLatch latch = new CountDownLatch(1);\n    private final List<String> collectedValues = new ArrayList<>();\n    private Throwable throwable = null;\n    private String onErrorThreadName = null;\n\n\n    @Override\n    public void onCompleted() {\n      latch.countDown();\n    }\n\n    @Override\n    public void onError(Throwable throwable) {\n      this.throwable = throwable;\n      this.onErrorThreadName = Thread.currentThread().getName();\n      latch.countDown();\n    }\n\n    @Override\n    public void onNext(String value) {\n      collectedValues.add(value);\n    }\n\n    public void awaitCompletion() throws InterruptedException {\n      latch.await();\n    }\n\n    public Throwable getThrowable() {\n      return throwable;\n    }\n\n    public List<String> getCollectedValues() {\n      return Collections.unmodifiableList(collectedValues);\n    }\n\n    public String onErrorThreadName() {\n      return onErrorThreadName;\n    }\n  }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3520/comments",
    "author": "jpmoore40",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-11-13T09:55:55Z",
        "body": "`timeout` has a `Scheduler` parameter and you can specify what scheduler will issue the `TimeoutException`. The default is `computation`. By having `observeOn` after `timeout`, you can make sure that all events above `observeOn` will be on the required thread.\n"
      }
    ]
  },
  {
    "number": 3494,
    "title": "switchIfEmpty() causes \"more items arrived than were requested\" in bizarre case",
    "created_at": "2015-11-04T17:19:06Z",
    "closed_at": "2016-02-09T14:04:00Z",
    "labels": [
      "Bug",
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3494",
    "body": "This is the simplest reproduction I could conjure up of this problem:\n\n``` java\n    Observable.just(1)\n        .flatMap(n -> {\n          return Observable.just(null, null)\n              .filter(o -> o != null)\n              .switchIfEmpty(Observable.empty().switchIfEmpty(Observable.just(\"Hello\")));\n        })\n        .subscribe(System.out::println);\n```\n\nThis will spit out `onError` with the error message \"more items arrived than were requested\".\n\nThis appears to be a regression. It works on RxJava 1.0.11 but fails on every version since then (including 1.0.15, the latest).\n\nAdding in a `take(1)` seems to fix the problem (as a workaround).\n\nFor completeness, here is the exception:\n\n```\nException in thread \"main\" rx.exceptions.OnErrorNotImplementedException: more items arrived than were requested\n    at rx.Observable$27.onError(Observable.java:7996)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:158)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:119)\n    at rx.internal.util.ScalarSynchronousObservable$2$1.onError(ScalarSynchronousObservable.java:140)\n    at rx.internal.operators.OperatorSwitchIfEmpty$AlternateSubscriber.onError(OperatorSwitchIfEmpty.java:116)\n    at rx.internal.operators.OperatorSwitchIfEmpty$AlternateSubscriber.onError(OperatorSwitchIfEmpty.java:116)\n    at rx.Observable.unsafeSubscribe(Observable.java:8178)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.subscribeToAlternate(OperatorSwitchIfEmpty.java:78)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.onCompleted(OperatorSwitchIfEmpty.java:71)\n    at rx.Observable$EmptyHolder$1.call(Observable.java:1073)\n    at rx.Observable$EmptyHolder$1.call(Observable.java:1070)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8171)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.subscribeToAlternate(OperatorSwitchIfEmpty.java:78)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.onCompleted(OperatorSwitchIfEmpty.java:71)\n    at rx.internal.operators.OperatorFilter$1.onCompleted(OperatorFilter.java:42)\n    at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.fastpath(OnSubscribeFromIterable.java:129)\n    at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:70)\n    at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.setProducer(OperatorSwitchIfEmpty.java:63)\n    at rx.Subscriber.setProducer(Subscriber.java:205)\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:49)\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8171)\n    at rx.internal.util.ScalarSynchronousObservable$2.call(ScalarSynchronousObservable.java:133)\n    at rx.internal.util.ScalarSynchronousObservable$2.call(ScalarSynchronousObservable.java:125)\n    at rx.Observable.subscribe(Observable.java:8266)\n    at rx.Observable.subscribe(Observable.java:8233)\n    at rx.Observable.subscribe(Observable.java:7987)\n    at net.danlew.experiments.Tester.main(Tester.java:40)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)\nCaused by: java.lang.IllegalStateException: more items arrived than were requested\n    at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)\n    at rx.internal.operators.OperatorSwitchIfEmpty$AlternateSubscriber.onNext(OperatorSwitchIfEmpty.java:122)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable.unsafeSubscribe(Observable.java:8171)\n    ... 33 more\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3494/comments",
    "author": "dlew",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-11-04T18:32:27Z",
        "body": "The cause for this exception is that `just` doesn't support backpressure and emits immediately. For a workaround, you can apply `onBackpressureBuffer` to `just(\"Hello\")`.\n"
      },
      {
        "user": "dlew",
        "created_at": "2015-11-04T21:48:24Z",
        "body": "Thanks for the workaround, that fixes it for now.\n\nWould it be so bad to have `just` support backpressure? I mean, it will need to support it in RxJava 2.0 anyways - it's not like things aren't already headed that way.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-11-04T22:20:52Z",
        "body": "I'll post a PR tomorrow with benchmark to see how the overheads change.\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2015-11-05T04:40:29Z",
        "body": "@dlew Thanks for finding another instance of backpressure failure caused by `just`. I've been collecting them! (#3044). I think it's time backpressure support for `just` happened.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-11-05T16:09:02Z",
        "body": "Fix posted: #3496.\n"
      },
      {
        "user": "zsxwing",
        "created_at": "2015-11-05T23:35:27Z",
        "body": "I remember we don't require that the user's Observable should support backpressure. So the user could just implement an `Observable` like `just(1)`. Right?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-02-09T14:04:00Z",
        "body": "Just now supports backpressure and will be part of 1.1.1.\n"
      }
    ]
  },
  {
    "number": 3466,
    "title": "SwitchMap with connectable's Replay raise exception",
    "created_at": "2015-10-22T13:31:12Z",
    "closed_at": "2015-10-24T12:02:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3466",
    "body": "For the following code:\n\n``` java\nConnectableObservable<Long> replayObs = Observable.interval(3, TimeUnit.SECONDS)\n        .startWith(-5L)\n        .switchMap(aLong -> {\n            if (aLong == 2L) {\n                return Observable.error(new NullPointerException());\n            } else {\n                return Observable.just(aLong);\n            }\n        })\n        .replay(1);\n\nreplayObs.connect(Actions.empty());\n\nreplayObs\n        .subscribe(s -> {\n            Log.wtf(\"MainActivity \", \"call \" + s);\n        }, throwable -> {\n            Log.wtf(\"MainActivity \", throwable);\n        });\n```\n\nIt emmits the following:\n\n```\nMainActivity: call -5\nMainActivity: java.lang.IllegalStateException: more items arrived than were requested\nMainActivity:     at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)\n```\n\nI realize that the `.connect` is happening before the first `.subscribe` but if I have `.flatpMap` instead, which has a different producer, it doesn't complain.\n\nThis is the simplest way to raise the exception:\n\n``` java\nConnectableObservable<Long> replayObs = Observable.just(1l)\n        .switchMap(Observable::just)\n    //  .onBackpressureBuffer(1)\n        .replay(1);\n```\n\nAdding a onBackpreassureBuffer(1) before the .replay() solves the problem. Is that a correct solution? Is that a bug in the `ProducerArbiter`?\n\n---\n\nFull stacktrace:\n\n```\njava.lang.IllegalStateException: more items arrived than were requested\n    at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)\n    at rx.internal.operators.OperatorSwitch$SwitchSubscriber.emit(OperatorSwitch.java:162)\n    at rx.internal.operators.OperatorSwitch$InnerSubscriber.onNext(OperatorSwitch.java:277)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable.unsafeSubscribe(Observable.java:7710)\n    at rx.internal.operators.OperatorSwitch$SwitchSubscriber.onNext(OperatorSwitch.java:105)\n    at rx.internal.operators.OperatorSwitch$SwitchSubscriber.onNext(OperatorSwitch.java:60)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:7710)\n    at rx.internal.operators.OperatorReplay.connect(OperatorReplay.java:285)\n    at com.lorentzos.rxexperiment.MainActivity.onCreate(MainActivity.java:42)\n    at android.app.Activity.performCreate(Activity.java:5990)\n    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1106)\n    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2309)\n    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2418)\n    at android.app.ActivityThread.access$900(ActivityThread.java:154)\n    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1321)\n    at android.os.Handler.dispatchMessage(Handler.java:102)\n    at android.os.Looper.loop(Looper.java:135)\n    at android.app.ActivityThread.main(ActivityThread.java:5289)\n    at java.lang.reflect.Method.invoke(Native Method)\n    at java.lang.reflect.Method.invoke(Method.java:372)\n    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:904)\n    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:699)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3466/comments",
    "author": "Diolor",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2015-10-24T10:36:59Z",
        "body": "What's happening here is that you are using sources that don't support backpressure. `Observable.interval()` doesn't support backpressure so combine it with `.onBackpressureXXX()`. Ditto for `Observable.just` with one parameter (with two or more does support backpressure).\n\nI'm actually intrigued to see this one because I hadn't yet been able to bring about backpressure exceptions using `Observable.just(t)` (see #3044). Thanks!\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2015-10-24T10:43:27Z",
        "body": "Distilling this test case a bit further:\n\nThis one fails with `java.lang.IllegalStateException: more items arrived than were requested`:\n\n``` java\nConnectableObservable<Integer> o = Observable\n    .just(1,2)\n    .switchMap(x -> Observable.just(x))\n    .replay();\no.connect();\no.subscribe();\n```\n\nThis one does not fail:\n\n``` java\nConnectableObservable<Integer> o = Observable\n    .just(1,2)\n    .switchMap(x -> Observable.just(x).onBackpressureBuffer())\n    .replay();\no.connect();\no.subscribe();\n```\n"
      },
      {
        "user": "Diolor",
        "created_at": "2015-10-24T12:02:22Z",
        "body": "Thanks @davidmoten, I saw today that `just(t1, t2)` is using a producer which handles back pressure, `just(t1)` doesn't.\n\nI will close this, since #3044 is open.\n\nThanks! :+1: \n"
      }
    ]
  },
  {
    "number": 3464,
    "title": "Scheduler Synchronization?",
    "created_at": "2015-10-21T23:01:25Z",
    "closed_at": "2015-10-22T16:47:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3464",
    "body": "Hi all,\n\nFor the last couple of days I've been struggling with what appears to be a concurrency issue. I've got two streams concat'd together with Observable.concat(). The first stream completes successfully, but the second stream is never subscribed; effectively stopping execution. Every once in a while (maybe 1/100 executions) I get a \"good\" execution which actually does complete and everything looks dandy.\n\nI've tried making a test case which illustrates the issue, but I can't seem to reproduce it in stand-alone code. At this point I'm fairly stumped, and I'm hoping someone on here can point me in the right direction.\n\nThe test case I've been using to try and reproduce is included below. It illustrates what I'm _trying_ to accomplish. There are two operations concatenated together: cache, publish. The cache operation is a concatenation of the update and delete operations. All cache operations should occur on the cache scheduler, while the publish operation should occur on the publish scheduler. This is to prevent concurrent access to the cache's underlying data store.\n\nIn my actual code the 'cache' operation is subscribed to, and it executes the first of its two inner operations (update, but not delete). The publish operation is obviously also never executed since it depends on the cache operation completing.\n\nUsing the debugger I've determined that when the cache update operation calls `onCompleted()`, it ends up in the `OperatorConcat` at this method with an empty `queue`:\n\n```\nvoid subscribeNext() {\n            if (requested > 0) {\n                Object o = queue.poll();\n                if (nl.isCompleted(o)) {\n                    child.onCompleted();\n                } else if (o != null) {\n                    Observable<? extends T> obs = nl.getValue(o);\n                    currentSubscriber = new ConcatInnerSubscriber<T>(this, child, arbiter);\n                    current.set(currentSubscriber);\n                    obs.unsafeSubscribe(currentSubscriber);\n                }\n            } else {\n                // requested == 0, so we'll peek to see if we are completed, otherwise wait until another request\n                Object o = queue.peek();\n                if (nl.isCompleted(o)) {\n                    child.onCompleted();\n                }\n            }\n        }\n```\n\nI believe this is what causes the cache delete operation to not be subscribed (the empty `queue`). It appears that the same thread which executes the cache update operation is also used to call `subscribeNext`, so it doesn't have a chance to actually complete and update the `queue` with the next operation. I could be totally off base here, and as I mentioned before I can't seem to reproduce this with tests.\n\nDoes anyone have an idea what could be going wrong? It seems like it's probably my fault, but I can't figure out what I've done wrong.\n\n_Note:_ I've tried removing everything from the bodies of cache update and cache delete to no avail. It appears that even when all the operations do is call `subscriber.onCompleted()` the concat operator still gets stuck. But not in tests...\n\nHere's the test case:\n\n```\n// Spock Unit Test\ndef testConcurrencyIssue() {\n    given:\n        def ts = new TestSubscriber<Void>()\n        def test = WeirdnessTest.getTestObservable()\n\n    when:\n        println \"\\n\\nTest:\"\n        test.subscribe(ts)\n        ts.awaitTerminalEvent()\n        println \"Done: ${ts.getOnNextEvents()}\"\n\n    then:\n        ts.assertCompleted()\n}\n\n// Supporting Test Code\npublic class WeirdnessTest {\n    public static final Observable<JsonResult> getTestObservable() {\n        // In my code 'source' is an observable which requests data from the network.\n        // For test purposes, this should suffice:\n        Observable<JsonResult> source = Observable.just(new JsonResult(\"/server/information\", \"{ \\\"version\\\": 1.0 }\"));\n\n        // Note: `onNextDo` is a custom operator. The implementation is included below (could be the problem?).\n        return source\n                .lift(new onNextDo<>(new Func1<JsonResult, Observable<?>>() {\n                    @Override\n                    public Observable<?> call(JsonResult result) {\n                        return getCacheAndPublishObservable(result.path, result.json);\n                    }\n                }));\n    }\n\n    public static final Observable<Void> getCacheAndPublishObservable(String path, String json) {\n        // Combine the cache + publish observables.\n        return Observable.concat(\n                getCacheObservable(path, json),  // Completes succesfully\n                getPublishObservable(path, json) // Never subscribed to\n        );\n    }\n\n    public static final Observable<Void> getCacheObservable(final String path, final String json) {\n        final ThreadFactory   factory        = new ThreadFactoryBuilder().setNameFormat(\"TestThread-%d\").build();\n        final ExecutorService cacheExecutor  = Executors.newSingleThreadExecutor(factory);\n        final Scheduler       cacheScheduler = Schedulers.from(cacheExecutor);\n\n        // Create an observable which will update the data cache\n        Observable<Void> update = Observable.create(new Observable.OnSubscribe<Void>() {\n            @Override\n            public void call(Subscriber<? super Void> subscriber) {\n                // Note: The body here doesn't seem to matter.\n                System.out.println(\"[Cache] Update: \"+path+\", \"+json);\n                subscriber.onCompleted();\n            }\n        }).subscribeOn(cacheScheduler);\n\n        // Create an observable which will delete the data cache if needed\n        Observable<Void> delete = Observable.create(new Observable.OnSubscribe<Void>() {\n            @Override\n            public void call(Subscriber<? super Void> subscriber) {\n                // Note: The body here doesn't seem to matter.\n                System.out.println(\"[Cache] Delete: \"+path+\", \"+json);\n                subscriber.onCompleted();\n            }\n        }).subscribeOn(cacheScheduler);\n\n        return Observable.concat(update, delete);\n    }\n\n    public static final Observable<Void> getPublishObservable(final String path, final String json) {\n        ExecutorService executor         = Executors.newSingleThreadExecutor();\n        Scheduler       publishScheduler = Schedulers.from(executor);\n\n        // Create an observable which dispatches the data\n        Observable<Void> publish = Observable.create(new Observable.OnSubscribe<Void>() {\n            @Override\n            public void call(Subscriber<? super Void> subscriber) {\n                // Note: The body here doesn't seem to matter.\n                System.out.println(\"[Publish]: Dispatch \"+path+\", \"+json);\n                subscriber.onCompleted();\n            }\n        }).subscribeOn(publishScheduler);\n\n        return publish;\n    }\n\n    public static final class JsonResult {\n        public String path;\n        public String json;\n\n        public JsonResult(String path, String json) {\n            this.path = path;\n            this.json = json;\n        }\n\n        @Override\n        public String toString() {\n            return \"JsonResult(\"+path+\", \"+json+\")\";\n        }\n    }\n\n    /**\n     * Injects a side effect Observable into the stream upon receiving an onNext event. The `effect`\n     * Observable is executed before forwarding the original event.\n     * <p/>\n     * If the `effect` Observable sends an error, the error are forwarded to the parent Observable\n     * without sending the value that triggered the side-effect.\n     *\n     * @param <T> The type emitted by onNext of the parent Observable.\n     */\n    public static final class onNextDo<T> implements Observable.Operator<T, T> {\n        private final Func1<T, Observable<?>> mEffect;\n        private final flatMap<T, T> mFlatMap;\n\n        public onNextDo(Func1<T, Observable<?>> effect) {\n            assert( effect != null );\n            mEffect = effect;\n            mFlatMap = new flatMap<>(new Func1<T, Observable<? extends T>>() {\n                @Override\n                public Observable<? extends T> call(T t) {\n                    Observable<?> sideEffect = Observable.empty();\n                    Observable<T> value = Observable.empty();\n                    try {\n                        sideEffect = mEffect.call(t);\n                        value = sideEffect.lift(new then<>(Observable.just(t)));\n                    }catch(Exception e){\n                        e.printStackTrace();\n                        return Observable.error(e);\n                    }\n\n                    return value;\n                }\n            });\n        }\n\n        @Override\n        public Subscriber<? super T> call(final Subscriber<? super T> subscriber) {\n            return mFlatMap.call(subscriber);\n        }\n    }\n\n    /**\n     * Implementation of {@link Observable#flatMap(Func1)} which conforms to the {@link\n     * rx.Observable.Operator} interface. This operator can be useful when implementing other operators.\n     *\n     * @param <R>\n     * @param <T>\n     */\n    public static final class flatMap<R, T> implements Observable.Operator<R, T> {\n        private final Func1<? super T, ? extends Observable<? extends R>> mFunction;\n\n        public flatMap(Func1<? super T, ? extends Observable<? extends R>> function) {\n            mFunction = function;\n        }\n\n        @Override\n        public Subscriber<? super T> call(Subscriber<? super R> subscriber) {\n            OperatorMap<T, Observable<? extends R>> map = new OperatorMap<>(mFunction);\n            OperatorMerge<R> merge = OperatorMerge.instance(false);\n\n            return map.call(merge.call(subscriber));\n        }\n    }\n\n    /**\n     * Ignores all emissions from the source observable. Once the source completes, the provided\n     * observable will be subscribed to.\n     *\n     * @param <T> The type of objects emitted by the source observable.\n     */\n    public class then<R, T> implements Observable.Operator<R, T> {\n        private final Observable<R> mNextObservable;\n\n        public then(Observable<R> nextObservable) {\n            assert( nextObservable != null );\n            mNextObservable = nextObservable;\n        }\n\n        @Override\n        public Subscriber<? super T> call(final Subscriber<? super R> subscriber) {\n            final MultipleAssignmentSubscription mas = new MultipleAssignmentSubscription();\n            subscriber.add(mas);\n\n            Subscriber<T> parent = new Subscriber<T>() {\n                @Override\n                public void onNext(T t) {\n                    // Ignored.\n                }\n\n                @Override\n                public void onError(Throwable e) {\n                    subscriber.onError(e);\n                }\n\n                @Override\n                public void onCompleted() {\n                    Subscriber<R> subscriberR = Subscribers.wrap(subscriber);\n                    mas.set(subscriberR);\n                    mNextObservable.subscribe(subscriberR);\n                }\n            };\n\n            mas.set(parent);\n            return parent;\n        }\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3464/comments",
    "author": "fougere-mike",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-10-22T07:34:50Z",
        "body": "Hi. \n\nWhenever I see the use of `Observable.create` or `Observable.lift`, that is a sign for trouble. Why did you implement all those operators instead of using standard RxJava methods?\n\nRegardless, one possible source for the problems is `just` because it doesn't support backpressure and thus it can overflow the request tracking inside `concat` which throws an `IllegalStateException` from `produced`. It is possible this exception gets swallowed somewhere and thus the stream ends up hanging. Try and using `just(m).onBackpressureBuffer()` everywhere and see if it still hangs.\n"
      },
      {
        "user": "fougere-mike",
        "created_at": "2015-10-22T15:55:30Z",
        "body": "Thanks for the reply. I've tried adding `onBackpressureBuffer()` to all the `.just` calls, but it has no effect. \n\nTo answer your question: I'm using custom operators to achieve behaviour that I don't believe is available as a single operator. For example: `then` is equivalent to `ignoreElementsThen()` which is not yet available (currently awaiting merge #3443). `onNextDo` is for async side-effects. It's `doOnNext`'s async cousin. I realise I can achieve the same effect by chaining several existing rx operators, but that leads to a lot of code clutter where I have to use the same 3 or 4 operators over and over again. It's much cleaner imo to use a custom operator.\n\nWith that said, I'm clearly an rx newb so if there are better solutions I'm all ears!\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-10-22T16:10:41Z",
        "body": "I don't see anything outstanding in your custom implementations so my guess is that the problem may be in the unshown code.\n\nTo rule out `concat`, use `merge` with `maxConcurrency = 1` which subscribes to a single source at a time.\n"
      },
      {
        "user": "fougere-mike",
        "created_at": "2015-10-22T16:47:45Z",
        "body": "You are correct. The issue was in the unshown code (of course, haha). I had been using a combination of operators to `concatIfEmpty` -- I just removed those lines and it stopped hanging.\n\nA quick google search revealed the `switchIfEmpty` operator -- which solves the problem and doesn't hang.\n\nAll appears well. I just need to spend a bit more time learning all the built-ins. Thanks for the help!\n"
      }
    ]
  },
  {
    "number": 3457,
    "title": "Need help simplifying fallback",
    "created_at": "2015-10-17T01:43:31Z",
    "closed_at": "2016-03-14T00:09:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3457",
    "body": "We have a stream which depends on a condition to wether send its values or switch to fallback stream emitting original values immediately and then combining as follows\n\n``` java\npublic class Main {\n  public static void main(String... args) {\n    stream()\n        .switchMap(streamValues -> {\n          if (streamValues.size() >= atLeastThisMany()) {\n            return Observable.just(streamValues);\n          }\n          return fallbackStream()\n              .flatMap(fallbackValues -> {\n                List<String> combined = new ArrayList<>(streamValues);\n                combined.addAll(fallbackValues);\n                return Observable.just(combined);\n              })\n              .startWith(streamValues);\n        }).subscribe(System.out::println);\n  }\n\n  static int atLeastThisMany() {\n    return 2; // Actually a runtime value\n  }\n\n  static Observable<List<String>> stream() {\n    return Observable.just(Collections.singletonList(\"A\")); // varies\n  }\n\n  static Observable<List<String>> fallbackStream() {\n    return Observable.just(Arrays.asList(\"B\", \"C\")); // varies\n  }\n}\n```\n\nWhen `atLeastThisMany` returns 2 or greater expected output would be\n\n```\n[A]\n[A, B, C]\n```\n\nWhen `atLeastThisMany` returns 1 or less expected output would be just\n\n```\n[A]\n```\n\nIs there a better approach for this?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3457/comments",
    "author": "eveliotc",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-02-09T14:00:53Z",
        "body": "You could just use `map` and return combined directly\n\n``` java\nreturn fallbackStream()\n              .map(fallbackValues -> {\n                List<String> combined = new ArrayList<>(streamValues);\n                combined.addAll(fallbackValues);\n                return combined;\n              })\n```\n"
      }
    ]
  },
  {
    "number": 3446,
    "title": "How can I use OperatorConcat<T>?",
    "created_at": "2015-10-14T16:31:52Z",
    "closed_at": "2016-02-09T13:56:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3446",
    "body": "I'm trying to write an operator `then<R,T>` which ignores all emissions from the source (except errors), and continues with a second Observable when completed.\n\nSomething like:\n\n```\n// Typical Case\nObservable.just(1, 2, 3, 4, 5)\n   .lift(new then<String, Integer>(Observable.just(\"Hello\")))\n   .subscribe(new Action1<String>() {\n      @Override\n      public void call(String s) {\n         // Called once with \"Hello\"\n      });\n\n// Source Errors\nObservable.<Integer>error(new RuntimeException())\n   .lift(new then<String, Integer>(Observable.just(\"Hello\")))  // <-- the second observable should never be subscribed to since the source error'd\n   .subscribe(new Action1<String>() {\n      @Override\n      public void call(String s) {\n         // Not Called\n\n      }, new Action1<Throwable>() {\n      @Override\n      public void call(Throwable e) {\n        System.out.println(\"Error: \"+e); // Should be called with the RuntimeException from above\n\n      }\n   });\n```\n\nI've come up with an implementation using `ignoreElements` + `map` + `concatWith`:\n\n```\n    public static <R, T> Observable<? extends R> then(Observable<T> source, Observable<R> other) {\n        return source\n                .ignoreElements()\n                .map(new Func1<T, R>() {\n                    @Override\n                    public R call(T integer) {\n                        return null;\n                    }\n                }).concatWith(other);\n    }\n```\n\nI'm quite new to writing custom operators, and I can't quite figure out how to translate that static function into an operator. I've written a few operators by composing the provided Operator\\* types, but I'm having trouble with this one.\n\nAny help would be greatly appreciated :)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3446/comments",
    "author": "fougere-mike",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2015-10-14T16:32:53Z",
        "body": "This is discussed in #3113 and implemented awaiting merge in #3443.\n"
      },
      {
        "user": "fougere-mike",
        "created_at": "2015-10-14T17:12:48Z",
        "body": "Ok, well that eliminates the need for my operator, but I'm still interested in how it could be correctly implemented using lift(). I'm sure I'll be writing more operators in the future so I'd like to have a better understanding of how they work. \n\nThis is what I've come up with:\n\n```\n/**\n * Ignores all emissions from the source observable. Once the source completes, the provided\n * observable will be subscribed to. If the source errors, the error will terminate the stream and\n * the provided observable will not be subscribed to.\n *\n * @param <T> The type of objects emitted by the source observable.\n * @param <R> The type of objects emitted by the provided `next` observable.\n */\npublic class then<R, T> implements Observable.Operator<R, T> {\n    private final OperatorIgnoreElements<T> mIgnoreElements;\n    private final OperatorMap<T, R> mMap;\n    private final OperatorConcat<R> mConcat;\n\n    private final Observable<R> mNextObservable;\n\n    public then(Observable<R> nextObservable) {\n        assert( nextObservable != null );\n        mNextObservable = nextObservable;\n        mIgnoreElements = OperatorIgnoreElements.instance();\n        mMap = new OperatorMap<>(new Func1<T, R>() {\n            @Override\n            public R call(T t) {\n                return null;\n            }\n        });\n        mConcat = OperatorConcat.instance();\n    }\n\n    @Override\n    public Subscriber<? super T> call(final Subscriber<? super R> subscriber) {\n        // TODO: Compose operators...\n    }\n}\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-10-14T18:29:46Z",
        "body": "This is \"super easy\" to implement as an `Operator`:\n\n``` java\npublic final class Then<T, R> implements Operator<R, T> {\n    final Observable<R> other;\n\n    public Then(Observable<R> other) {\n        this.other = other;\n    }\n\n    @Override\n    public Subscriber<? super T> call(final Subscriber<? super R> t) {\n        MultipleAssignmentSubscription mas = new MultipleAssignmentSubscription();\n        t.add(mas);\n\n        Subscriber<T> parent = new Subscriber<T>() {\n            @Override\n            public void onNext(T t) {\n                // ignored\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                t.onError(e);\n            }\n\n            @Override\n            public void onCompleted() {\n                Subscriber<R> tr = Subscribers.wrap(t);\n                mas.set(tr);\n                other.subscribe(tr);\n            }\n        };\n\n        mas.set(parent);\n\n        return parent;\n    }\n}\n```\n"
      },
      {
        "user": "fougere-mike",
        "created_at": "2015-10-14T20:04:05Z",
        "body": "Awesome, thanks! \n\nI have a few questions about your solution:\n1. Shouldn't it check if the subscriber has unsubscribed before calling `t.onError(e)`?\n2. Why is the MultipleAssignmentSubscription needed? I'm a bit of an rx newbie, so it's not clear to me why you can't just return the `parent` subscriber directly.\n\nCheers!\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-02-09T13:56:28Z",
        "body": "1) unnecessary\n2) so the unsubscription from the child can target both the first parent and the second subscriber.\n"
      }
    ]
  },
  {
    "number": 3432,
    "title": "okhttp callback function onFailure donot catch OnErrorNotImplementedException",
    "created_at": "2015-10-10T07:49:34Z",
    "closed_at": "2016-02-09T13:50:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3432",
    "body": "okhttp 2.4.0\n\n```\n        @Override\n        public void onFailure(Request request, IOException e) {\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"url: \").append(request.urlString());\n            builder.append(\"\\n\");\n            builder.append(\"error: \").append(e.getMessage());\n            Logger.e(builder.toString());\n\n            if (mSubscriber.isUnsubscribed()) {\n                return;\n            }\n\n            try {\n                mSubscriber.onError(null);\n            } catch (OnErrorNotImplementedException ex) {\n                // donot reach here but crash\n            }\n        }\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3432/comments",
    "author": "hamberluo",
    "comments": [
      {
        "user": "artem-zinnatullin",
        "created_at": "2015-10-10T15:03:16Z",
        "body": "The problem is that you're passing `null` as an error. As a result you get `CompositeException` with pretty long stacktrace caused by `NullPointerException`  inside of `OnErrorNotImplementedException` constructor (what a lol)!\n1. Don't pass `null` as an error and your code will start working.\n2. Swallowing exceptions is not a very great idea, consider adding `onError` implementation to the subscribers. \n"
      },
      {
        "user": "hamberluo",
        "created_at": "2015-10-12T04:56:09Z",
        "body": "when i add `onError` implementation and passing `nonnull`, the problem still exists.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-10-12T05:48:14Z",
        "body": "@hamberluo What is exactly your problem?\n"
      }
    ]
  },
  {
    "number": 3431,
    "title": "Zip$InnerSubscriber does not respect backpressure on RxRingBuffer",
    "created_at": "2015-10-10T01:16:14Z",
    "closed_at": "2015-10-12T20:46:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3431",
    "body": "This test throws a `MissingBackpressureException` while attempting to call onNext on the internal RxRingBuffer. This can be solved by adding a `.onBackpressureDrop()` to the interval observable before zipping. \n\n``` java\nObservable<Integer> cache = Observable.range(1, 50).cache().repeat();\nObservable<Long> interval = Observable.interval(10_000, TimeUnit.NANOSECONDS);\nObservable.zip(interval, cache, (i, c) ->c).toBlocking().last();\n```\n\nStacktrace:\n\n```\nException in thread \"main\" java.lang.RuntimeException: rx.exceptions.MissingBackpressureException\n    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:455)\n    at rx.observables.BlockingObservable.last(BlockingObservable.java:219)\n    at wtf.WTF.main(WTF.java:31)\nCaused by: rx.exceptions.MissingBackpressureException\n    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:352)\n    at rx.internal.operators.OperatorZip$Zip$InnerSubscriber.onNext(OperatorZip.java:329)\n    at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:52)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3431/comments",
    "author": "stealthcode",
    "comments": [
      {
        "user": "zsxwing",
        "created_at": "2015-10-10T05:27:59Z",
        "body": "This looks right. `interval` doesn't support `backpressure`. There is nothing to do for `Zip$InnerSubscriber`.\n"
      },
      {
        "user": "stealthcode",
        "created_at": "2015-10-12T20:21:45Z",
        "body": "Thanks,  yes I realized this. I'm not sure that there can be any better solution, but there is no obvious solution from the stack trace since the Zip doesn't have context of the subscriber above it (or which observable's onNext caused the problem).\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-10-12T20:43:57Z",
        "body": "This is why 2.0 operators track their clients requested amount and report the MissingBackpressureException themselves.\n"
      },
      {
        "user": "stealthcode",
        "created_at": "2015-10-12T20:46:40Z",
        "body": "Okay great. Thanks.\n"
      }
    ]
  },
  {
    "number": 3379,
    "title": "OnSubscribeCombineLatest#MultiSourceProducer#collectedValues leaks?",
    "created_at": "2015-09-27T18:17:22Z",
    "closed_at": "2015-10-01T10:39:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3379",
    "body": "It looks to me that it should be cleared when the child `subscriber` is unsubscribed.\n\nThe issue is that when I keep a subscription this automatically mean that I will keep a reference to the latest emitted value even if the subscription is unsubscribed. This prevents us from using `combineLatest` on memory-heavy objects.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3379/comments",
    "author": "konmik",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-09-27T18:47:51Z",
        "body": "Why do you keep the subscription once the sequence is unsubscribed through it? Even if the array is cleared, its surroundings will keep leaking.\n"
      },
      {
        "user": "konmik",
        "created_at": "2015-09-27T19:07:04Z",
        "body": "I keep subscription because I don't want to attach side-effects to the chain clearing the reference to the subscription when it is completed. I find it a good idea to follow some functional practices when using RxJava.\n\nWhy the environment would leak? The value has been passed into the chain, that's it.\n"
      },
      {
        "user": "konmik",
        "created_at": "2015-09-28T07:46:07Z",
        "body": "So, should I write something like this?\n\n``` java\n    Subscription subscription;\n\n    void connect() {\n        subscription = combineLatest(api.login(), heavyViewThatDisappearsAndAppearsRandomly)\n            .doOnUnsubscribe(() -> subscription = null) // THIS \n            .subscribe( -> view.onLoginCompleted(loginOk));\n    }\n```\n\nLooks super-ugly.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-28T08:53:22Z",
        "body": "The setting of the subscription may race with each other. Instead:\n\n``` java\nCompositeSubscription composite = new CompositeSubscription();\n\nvoid connect();\n    Subscriber<T> subscriber = new Subscriber<T>() {\n         // onNext logic here\n    });\n    composite.add(subscriber);\n\n    combineLatest(...)\n    .doOnUnsubscribe(() -> composite.remove(subscriber))\n    .subscribe(subscriber);\n}\n```\n"
      },
      {
        "user": "konmik",
        "created_at": "2015-09-28T09:03:20Z",
        "body": "So, if there is no guarantee that operators will not leak events after unsubscription, should I apply this pattern _always_? I think that having such guarantee would simplify the RxJava usage a lot.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-28T09:27:31Z",
        "body": "I've seen some people creating their own `Subscriber` wrapper which has nulls out the reference to the original in case of a terminal event. Otherwise, cleaning up in operators all the time may hinder performance in case the references go away anyways.\n"
      },
      {
        "user": "konmik",
        "created_at": "2015-09-28T10:02:00Z",
        "body": "I don't see how performance can be hindered. OK, understood. I'll write my own wrapping function around rx ro prevent leaks.\n"
      }
    ]
  },
  {
    "number": 3375,
    "title": "2.x: Merge and Queue Pooling",
    "created_at": "2015-09-25T03:28:18Z",
    "closed_at": "2015-09-25T19:17:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3375",
    "body": "@akarnokd Reading through the `merge` code in 2.x, it appears to not use pooling any longer. As soon as contention happens, it allocates a new array. We have proven previously as we've iterated on `merge` that we can't allocate arrays for every `InnerSubscriber`. What new data or evidence suggests that we can ignore past findings and do without pooling?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3375/comments",
    "author": "benjchristensen",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-09-25T03:35:50Z",
        "body": "Is it perhaps that the only time they are allocated is when contention occurs, and contention is already costly enough that the extra allocation no longer matters?\n\nTrying to match this design up with past efforts on `merge` ...\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-25T07:26:01Z",
        "body": "> it appears to not use pooling any longer\n\nThat's right.\n\n> As soon as contention happens, it allocates a new array\n\nIt's a Queue but yes.\n\n> We have proven previously as we've iterated on merge that we can't allocate arrays for every InnerSubscriber\n\nTrue, doesn't happen until contention.\n\n> What new data or evidence suggests that we can ignore past findings and do without pooling?\n\n#3352. Async performance improved over 1.x. Synchronous tests don't allocate any queue.\n\n> contention is already costly enough that the extra allocation no longer matters?\n\nIn 1.x the pooling and the inner synchronization of the RxRingBuffer contributed even more to the contention. If there are multiple async sources and all but one encounter a contention, they all start to contend on the pool. This is a transient event and if the sequences are long-running, doesn't appear on measurements. However, short lived sequences encounter this much more frequently.\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2015-09-25T19:17:48Z",
        "body": "Great, thanks for confirming my understanding and clarifying more. \n"
      }
    ]
  },
  {
    "number": 3368,
    "title": "Hundreds of 2.x operators/classes for NbpObservable",
    "created_at": "2015-09-21T08:14:33Z",
    "closed_at": "2015-09-25T18:15:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3368",
    "body": "I believe I can derive non-backpressure operators from backpressured operators with a relatively simple process (delete backpressure related fields, fix up the classes). Such task would take me 1-1.5 days tops and I can do it in a single PR. The work, unlike the run on the backpressured, can now be done in parallel as there aren't really and cross-dependencies or algorithmic challenges; it's mostly a simple mechanical process. Once all of them is \"ported\", the NbpObservable can be modified to access them in one PR.\n\nHowever, this is at least 20kloc for classes and another 20kloc for unit test where such large amount of change is practically non-reviewable.\n\nMy question is, how should this be handled? One by one and with 200+ PRs or batched into ~1kloc chunks and thus within ~40 PRs?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3368/comments",
    "author": "akarnokd",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-09-22T02:59:04Z",
        "body": "Go ahead and do it as a big commit (or a few big commits) and I'll treat it special with a :+1: just to get it in, like you did all the rest in 2.x. Then I'll start reviewing it as part of the 2.x branch and we can do revisions through the normal PR process as we do a thorough review. \n"
      },
      {
        "user": "stevegury",
        "created_at": "2015-09-22T04:24:52Z",
        "body": "I agree, that's a valid use case where we can break the rule and only do one big PR.\nThanks for doing this.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-25T18:15:51Z",
        "body": "Merged in #3371 \n"
      }
    ]
  },
  {
    "number": 3367,
    "title": "propagating request when using flatMap",
    "created_at": "2015-09-20T09:50:42Z",
    "closed_at": "2015-09-25T18:16:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3367",
    "body": "Hi, \n\nI ve this piece of code : \n\n```\nObservable\n    .from(IntStream.range(1, 20).boxed().collect(Collectors.toList()))\n    .map(i -> {\n                System.out.println(\"Step :\"+i);\n                return i;\n            })\n    .flatMap(elt ->\n                            Observable\n                                    .just(elt).observeOn(Schedulers.io())\n                                    .map(String::valueOf)\n\n            )\n    .subscribe(new Subscriber<String>() {\n\n                @Override\n                public void onStart() {\n                    request(1);\n                }\n\n                @Override\n                public void onCompleted() {}\n\n                @Override\n                public void onError(Throwable throwable) {}\n\n                @Override\n                public void onNext(String s) {\n                    System.out.println(\"Next : \" + s);\n                }\n            });\n```\n\nI expect this on the logs : \n\nStep : 1\nNext : 1\n\nBut Instead I've this : \n\nStep :1\nStep :2\nNext : 1\nStep :3\nStep :4\nStep :5\nStep :6\nStep :7\n...\n\nWhy does the request is not propagating to the source when I use flatMap ?\n\nThanks for your help! \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3367/comments",
    "author": "larousso",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2015-09-20T22:06:12Z",
        "body": "You've only requested one so that is all you get arriving to the subscriber. The other log lines are because `flatMap` requests 128 (or 16 on Android) regardless of how many were requested of it and then buffers. When you request more `flatMap` will empty its buffer.\n\nIf you put a `request(1)` just after  `System.out.println(\"Next : \" + s);` then your stream will report all to the subscriber.\n"
      },
      {
        "user": "larousso",
        "created_at": "2015-09-21T06:22:29Z",
        "body": "Ok thanks. \nI didn't know that flatMap was buffering. It was the missing information :) \n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-25T18:16:58Z",
        "body": "@davidmoten :+1:\n"
      }
    ]
  },
  {
    "number": 3344,
    "title": "subscribe vs unsafeSubscribe",
    "created_at": "2015-09-14T15:56:04Z",
    "closed_at": "2015-09-14T18:19:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3344",
    "body": "What's the difference between `subscribe` and `unsafeSubscribe`?\n\nThe javadoc mentions that `unsafeSubscribe` should only be used for `Observable.Operator`, I'm assuming that includes `Observable.OnSubscribe`. Also, it briefly mentions nested subscriptions but it doesn't explain the difference in behavior of `subscribe` and `unsafeSubscribe`.\n\nAlso, is there guidance on when `Subscribers.wrap` should be used?\n\nHere's a snippet that I thought would behave the same, however `unsafeSubscribe` is working and `subscribe` is timing out.\n\n``` java\n  public static Observable<Long> foo() {\n    return Observable.create(subscriber -> {\n      Observable.timer(1, TimeUnit.MILLISECONDS)\n          .unsafeSubscribe(Subscribers.wrap(subscriber));\n    });\n  }\n\n  public static Observable<Long> foo2() {\n    return Observable.create(subscriber -> {\n      Observable.timer(1, TimeUnit.MILLISECONDS)\n          .subscribe(Subscribers.wrap(subscriber));\n    });\n  }\n\n  public static void main(String[] args) {\n    long result = foo().flatMap(value -> foo())\n        .timeout(1, TimeUnit.SECONDS)\n        .toBlocking().single();\n    System.out.println(\"result = \" + result);\n\n\n    long result2 = foo2().flatMap(value -> foo2())\n        .timeout(1, TimeUnit.SECONDS)\n        .toBlocking().single();\n    System.out.println(\"result2 = \" + result2);\n  }\n```\n\n```\nresult = 0\nException in thread \"main\" java.lang.RuntimeException: java.util.concurrent.TimeoutException\n    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:455)\n    at rx.observables.BlockingObservable.single(BlockingObservable.java:331)\n    at Foo.main(Foo.java:39)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)\nCaused by: java.util.concurrent.TimeoutException\n    at rx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.onTimeout(OperatorTimeoutBase.java:169)\n    at rx.internal.operators.OperatorTimeout$1$1.call(OperatorTimeout.java:42)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3344/comments",
    "author": "vadims",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-09-14T16:53:43Z",
        "body": "Hello,\n\nthe difference is that `subscribe` wraps the `Subscriber` into a `SafeSubscriber` which captures exceptions thrown from the wrapped Subscriber's `onXXX` methods and unsubscribes both the upstream and downstream on a terminal event. `unsafeSubscribe` doesn't do this and is mainly there to avoid the wrapping overhead as much as possible.\n\nWhat happens here with `foo2` is that this downstream-directed unsubscription from `SafeSubscriber` cancels the merge operation which then cancels the inner `foo2` call and simply stops emitting anything (not even terminal events) and the next operator - timeout - will time out.\n\nGenerally, I'd warn against using `create` to roll your own source because there are subtle and less-subtle things that can go wrong.\n"
      },
      {
        "user": "vadims",
        "created_at": "2015-09-14T18:19:06Z",
        "body": "Thanks for the explanation, I think the javadoc could be improved to mention this.\n"
      }
    ]
  },
  {
    "number": 3343,
    "title": " Equivalent with CompletableFuture.complete",
    "created_at": "2015-09-14T06:10:07Z",
    "closed_at": "2015-09-25T18:18:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3343",
    "body": "Hi,\nDose Rxjava Observable has equivalent with CompletableFuture.complete?\nlike: CompletableFuture future=new CompletableFuture();\n       ...do  something...\n       future.complete(xxx)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3343/comments",
    "author": "GrapeBaBa",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-09-14T06:25:12Z",
        "body": "You can use a Subject for that type of 'promise' usage. \n\nSubject s = ReplaySubject.create()\n... do something ...\ns.onCompleted()\n\nOr for the more idiomatic approach, create a lazy Observable:\n\nreturn Observable.create(s -> {\n  ... do something ...\n  s.onCompleted()\n});\n\n> On Sep 13, 2015, at 11:10 PM, Chen Kai notifications@github.com wrote:\n> \n> Hi,\n> Dose Rxjava Observable has equivalent with CompletableFuture.complete?\n> like: CompletableFuture future=new CompletableFuture();\n> ...do something...\n> future.complete(xxx)\n> \n> —\n> Reply to this email directly or view it on GitHub.\n"
      },
      {
        "user": "GrapeBaBa",
        "created_at": "2015-09-14T10:06:31Z",
        "body": "Awesome.\n\n发自我的 iPhone\n\n> 在 2015年9月14日，下午2:25，Ben Christensen notifications@github.com 写道：\n> \n> You can use a Subject for that type of 'promise' usage. \n> \n> Subject s = ReplaySubject.create()\n> ... do something ...\n> s.onCompleted()\n> \n> Or for the more idiomatic approach, create a lazy Observable:\n> \n> return Observable.create(s -> {\n> ... do something ...\n> s.onCompleted()\n> });\n> \n> > On Sep 13, 2015, at 11:10 PM, Chen Kai notifications@github.com wrote:\n> > \n> > Hi,\n> > Dose Rxjava Observable has equivalent with CompletableFuture.complete?\n> > like: CompletableFuture future=new CompletableFuture();\n> > ...do something...\n> > future.complete(xxx)\n> > \n> > —\n> > Reply to this email directly or view it on GitHub.\n> > \n> > —\n> > Reply to this email directly or view it on GitHub.\n"
      }
    ]
  },
  {
    "number": 3338,
    "title": "Should withLatestFrom behave like zip in terms of buffering?",
    "created_at": "2015-09-11T08:44:00Z",
    "closed_at": "2015-09-11T09:06:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3338",
    "body": "I've just picked up withLatestFrom and I expected it to behave a bit like zip in terms of buffering source1 until source2 initially emits.  Am I missing something?  Is there something in the pipeline (for what I appreciate is an experimental operator) or could/ should it be enhanced to behave more like zip?\n\nUsing 1.0.13\n\nExamples of both below:\n# Zip Example Test\n\n```\n        testScenario\n                .given()\n                .theStreamUnderTest((s1, s2) -> s1.zipWith(s2, (z, n) -> z + n))\n\n                .when()\n                .theSubscriber().subscribes()\n                .source1().emits(\"a\")\n                .source1().emits(\"b\")\n                .source1().emits(\"c\")\n                .source2().emits(1)\n                .source2().emits(2)\n                .source2().emits(3)\n                .source1().completes()\n\n                .then()\n                .theSubscribers()\n                .renderedStream().isEqualTo(\"[a1]-[b2]-[c3]-|\");\n\n```\n# WithLatestFrom Test\n\n```\n       testScenario\n                .given()\n                .theStreamUnderTest((s1, s2) -> s1.withLatestFrom(s2, (z, n) -> z + n))\n                .theRenderer(s -> s)\n\n                .when()\n                .theSubscriber().subscribes()\n                .source1().emits(\"a\")\n                .source2().emits(1)\n                .source1().emits(\"b\")\n                .source2().emits(2)\n                .source1().emits(\"c\")\n                .source1().completes()\n\n                .then()\n                .theSubscribers()\n                .renderedStream().isEqualTo(\"[a1]-[b1]-[c2]-|\");\n```\n\nActually emits [b1]-[c2]-|\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3338/comments",
    "author": "leonjones1974",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-09-11T08:53:38Z",
        "body": "This is by design and matches how combineLatest doesn't combine until all sources have produced at least one value.\n"
      },
      {
        "user": "leonjones1974",
        "created_at": "2015-09-11T09:06:37Z",
        "body": "OK, TY\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-11T09:15:05Z",
        "body": "You can achieve this via the following construct:\n\n``` java\nObservable<Integer> source = Observable.range(1, 10);\n\nPublishSubject<Integer> other = PublishSubject.create();\n\nsource\n.delaySubscription(() -> other)\n.withLatestFrom(other, (a, b) -> a + b)\n.subscribe(System.out::println);\n\nother.onNext(10);\n```\n\nIf you excuse me, now I have to file a bugfix against 2.x :)\n"
      },
      {
        "user": "leonjones1974",
        "created_at": "2015-09-11T09:17:16Z",
        "body": "Ah, it's nicer than my solution - thanks again\n"
      }
    ]
  },
  {
    "number": 3337,
    "title": "2.x: Observable.generate confusing with Subscriber",
    "created_at": "2015-09-09T22:54:34Z",
    "closed_at": "2016-08-23T10:12:29Z",
    "labels": [
      "Question",
      "Discussion"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3337",
    "body": "It is confusing that the `Observable.generate` methods pass in a `Subscriber` that has an `onSubscribe` method on them. When using `generate` I should never have to or be able to call `onSubscribe` and involve myself in the flow control.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3337/comments",
    "author": "benjchristensen",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-09-10T07:04:18Z",
        "body": "I tried to avoid adding to many new interfaces. We can change it to something like `GenerateOutput`, `ChildObserver`, `ClientObserver` or `OutputObserver`.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-19T21:06:02Z",
        "body": "/cc @JakeWharton\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-08-21T00:40:19Z",
        "body": "We should probably avoid using the `Observer` term since this interface can be re-used for both `Observable` and `Flowable`'s `generate` methods and `Observer` is only associated with non-backpressure types.\n\nIt could be called `Emitter` and both `FlowableEmitter` and `ObservableEmitter` could extend from it.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-23T10:12:29Z",
        "body": "Closing via #4410.\n"
      }
    ]
  },
  {
    "number": 3219,
    "title": "Different behaviour of replay between 1.0.13 and 1.0.14",
    "created_at": "2015-08-28T07:04:06Z",
    "closed_at": "2016-02-09T13:36:53Z",
    "labels": [
      "Bug",
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3219",
    "body": "I am not sure my implementation is good. But I notice that given the following code (in scala):\n\n``` scala\nval password = BehaviorSubject[String](\"\")\nval passwordIsValid = (false +: password.map(s => s.length >= 8)).\n  doOnSubscribe(println(\"on subscribe\")).\n  doOnNext(v => println(s\"do on next => $v\")).\n  replay(1)\n\npasswordIsValid.connect\n\npassword.onNext(\"1\")\npassword.onNext(\"12\")\npassword.onNext(\"12345678\")\n\npasswordIsValid.subscribe(v => println(s\"another password => $v\"))\n```\n\nthe output by RxJava 1.0.13 is:\n\n```\non subscribe\ndo on next => false\ndo on next => false\ndo on next => false\ndo on next => false\ndo on next => true\nanother password => true\n```\n\nwhich is what I want.\n\nhowever the output by RxJava 1.0.14 is different.\n\n```\non subscribe\ndo on next => false\nanother password => false\ndo on next => true\nanother password => true\n```\n\nwhich doesn't make sense to me.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3219/comments",
    "author": "rayshih",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-08-28T07:21:09Z",
        "body": "Could you post the example in plain Java?\n"
      },
      {
        "user": "rayshih",
        "created_at": "2015-08-28T08:28:15Z",
        "body": "The following is the equivalent java code (except the log function)\n\n``` java\nBehaviorSubject<String> password = BehaviorSubject.create(\"\");\n\nConnectableObservable<Boolean> passwordIsValid = password.map(new Func1<String, Boolean>() {\n    @Override\n    public Boolean call(String s) {\n        return s.length() >= 8;\n    }\n}).startWith(false).\ndoOnSubscribe(new Action0() {\n    @Override\n    public void call() {\n        Log.d(\"RxBug\", \"on subscribe\");\n    }\n}).\ndoOnNext(new Action1<Boolean>() {\n    @Override\n    public void call(Boolean v) {\n        Log.d(\"RxBug\", \"do on next => \" + v);\n    }\n}).replay(1);\n\npasswordIsValid.connect();\n\npassword.onNext(\"1\");\npassword.onNext(\"12\");\npassword.onNext(\"12345678\");\npasswordIsValid.subscribe(new Action1<Boolean>() {\n    @Override\n    public void call(Boolean v) {\n        Log.d(\"RxBug\", \"another password => \" + v);\n    }\n});\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-08-28T08:34:48Z",
        "body": "Thanks. Without `startWith`, this variant gives a reasonable output:\n\n``` java\n        BehaviorSubject<String> password = BehaviorSubject.create(\"\");\n\n        ConnectableObservable<String> valid = password\n                .map(s -> s + \": \" + (s.length() >= 8))\n                .doOnSubscribe(() -> System.out.println(\"onSubscribe\"))\n                .doOnNext(v -> System.out.println(\"onNext -> \" + v))\n                .replay(1)\n                ;\n\n        valid.connect();\n\n        password.onNext(\"1\");\n        password.onNext(\"12\");\n        password.onNext(\"12345678\");\n\n        valid.forEach(System.out::println);\n```\n\n```\nonSubscribe\nonNext -> : false\nonNext -> 1: false\nonNext -> 12: false\nonNext -> 12345678: true\n12345678: true\n```\n\nI'll check what's different with `startWith`.\n"
      },
      {
        "user": "rayshih",
        "created_at": "2015-08-28T08:37:28Z",
        "body": "yup, I have checked that before. It behaves correctly without `startWith`\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-08-28T08:58:48Z",
        "body": "`replay()` in 1.0.14 supports downstream backpressure and expects upstream backpressure. This required request coordination among child subscribers. \n\nIf there are no child subscribers to begin with (at `connect()` for example), replay doesn't request anything. Without request, the concat in startWith won't subscribe to just(false). Since false isn't observed, `concat` won't continue with the `BehaviorSubject` that has 0 subscribers at the time, dropping your `1` and `12` values but holding onto `12345678`. When you do subscribe to the `ConnectableObservable`, `just(false)` and the latest value of the `BehaviorSubject` is received.\n\nWithout `startWith`, it works as `BehaviorSubject` disregards backpressure and pushes its values down to `replay()` that dutifully buffers them as long as it can.\n\nIn contrast, publish() slowly consumes its source if there are no child subscribers to it. Otherwise, the behavior you are expecting wasn't codified in our unit tests (therefore the updated replay() operator shipped). I have to think about if this is actually achievable or not. Until then, you can get back the old behavior:\n\n``` java\n   // ...\n\n   valid.subscribe();\n   valid.connect();\n\n   password.onNext(\"1\");\n   // ...\n```\n\nThis will consume the upstream whether there are other subscribers or not.\n"
      },
      {
        "user": "rayshih",
        "created_at": "2015-08-28T09:05:24Z",
        "body": "Thanks. I currently downgrade to 1.0.13, is that ok? Or you suggest to use 1.0.14 and do `subscribe` before `connect`?\n"
      }
    ]
  },
  {
    "number": 3218,
    "title": "2.0 TestSubscriber.assertValue should not assert completion",
    "created_at": "2015-08-28T03:58:11Z",
    "closed_at": "2016-02-09T13:37:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3218",
    "body": "Right now TestSubscriber.assertValue has this:\n\n``` java\n    public final void assertValue(T value) {\n        String prefix = \"\";\n        if (done.getCount() != 0) {\n            prefix = \"Subscriber still running! \";\n        }\n```\n\nIt should not assert completion, as that means values can't progressively be asserted while synchronously delivering values prior to completion. \n\nSame for the other assertValue methods.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3218/comments",
    "author": "benjchristensen",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-08-28T05:40:14Z",
        "body": "It doesn't assert it, just prefixes the error message to let the dev know if the subscriber hung. Such ability in 1.x could have saved me hours with some bugs.\n"
      }
    ]
  },
  {
    "number": 3187,
    "title": "MissingBackpressureException when not using Backpressure",
    "created_at": "2015-08-25T16:07:45Z",
    "closed_at": "2015-08-25T17:34:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3187",
    "body": "Hey, I'm seeing a crash on my Android app but I'm not sure exactly what's causing the crash (Exception included at the bottom). We don't use or request backpressure anywhere in our app. This is on RxJava `1.0.13`. My only thought would be that maybe some other RX operator is doing this.\n\nFor instance, we have a zip operator:\n\n``` Java\nObservable.zip(\n        new ObservableThatRunsInThread1(),\n        new ObservableThatRunsInThread2(),\n        new ObservableThatRunsInThread3(),\n        new ObservableThatRunsInThread4(),\n        new Func4<Object, Object, Object, Object, Response>() {\n            @Override public Response call(Object o1, Object o2, Object o3, Object o4) {\n                return new Response(o1, o2, o3, o4);\n            }\n        }\n);\n```\n\nCould the multiple threads possibly be causing a race condition, or something of the sort? I'm a bit stuck at this point. Thanks!\n\n``` Java\njava.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:60)\n       at android.os.Handler.handleCallback(Handler.java:739)\n       at android.os.Handler.dispatchMessage(Handler.java:95)\n       at android.os.Looper.loop(Looper.java:145)\n       at android.app.ActivityThread.main(ActivityThread.java:5835)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java:372)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1399)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1194)\nCaused by: rx.exceptions.OnErrorNotImplementedException\n       at rx.Observable$30.onError(Observable.java:7540)\n       at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:154)\n       at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:111)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:197)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:170)\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n       at android.os.Handler.handleCallback(Handler.java:739)\n       at android.os.Handler.dispatchMessage(Handler.java:95)\n       at android.os.Looper.loop(Looper.java:145)\n       at android.app.ActivityThread.main(ActivityThread.java:5835)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java:372)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1399)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1194)\nCaused by: rx.exceptions.MissingBackpressureException\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext(OperatorObserveOn.java:138)\n       at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:51)\n       at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n       at java.lang.Thread.run(Thread.java:818)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3187/comments",
    "author": "ScottPierce",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-08-25T16:39:52Z",
        "body": "It appears your periodic timer overflows the observeOn buffer. You have to apply `onBackpressureDrop`.\n"
      },
      {
        "user": "ScottPierce",
        "created_at": "2015-08-25T16:54:17Z",
        "body": "Oh, so this is happening with a timer? I see it now with the `OnSubscribeTimerPeriodically`.\n\nOn all timers should I be applying backpressure drop? If I use RxJava for any sort of timers, in what cases should I be worried about this exception?\n\nThanks for your fast reply!\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-08-25T17:02:48Z",
        "body": "If you don't mind losing a tick with a periodic timer then `onBackpressureDrop` should work. Otherwise, if you thing it is just a transitional effect, you can use `onBackpressureBuffer`.\n\nIf you encounter this exception, you should verify all the operators do support backpressure. If not, you need to apply one of the `onBackpressureXXX` methods. If all the operators support backpressure yet you encounter this exception, it is possible that there is a bug in one of the operators and you should report it here.\n"
      },
      {
        "user": "ScottPierce",
        "created_at": "2015-08-25T17:27:47Z",
        "body": "So in instances where we have a long running timer like this:\n\n``` Java\nmSubscription = Observable.timer(0L, 1L, TimeUnit.SECONDS)\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe(new Action1<Long>() {\n            @Override public void call(final Long l) {\n            }\n        });\n```\n\nWould you recommend putting the `.onBackpressureDrop()` above or below the `.observeOn()`?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-08-25T17:30:52Z",
        "body": "Above.\n"
      },
      {
        "user": "ScottPierce",
        "created_at": "2015-08-25T17:34:43Z",
        "body": "Thank you, I appreciate you being so helpful. :-)\n"
      }
    ]
  },
  {
    "number": 3179,
    "title": "Observable NullPointerException",
    "created_at": "2015-08-23T09:30:38Z",
    "closed_at": "2015-08-23T10:08:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3179",
    "body": "There is an error which makes me so puzzled，and here is the code:\n\n```\n    protected void subscribeToDataStoreInternal() {\n        Observable<Photo> observable = preProcess(\n                Observable.<DiscoverPage>concat(TRDiscover.findDiscoverPage(), request()));\n        if (null != observable&&null!=mSubscriber) {\n            observable.subscribe(\n                    mSubscriber::onRefreshNext,\n                    mSubscriber::onError,\n                    mSubscriber::onCompleted);\n        }\n    }\n```\n\nThe exception as follow:\n    java.lang.NullPointerException\n            DiscoverViewModel.subscribeToDataStoreInternal(DiscoverViewModel.java:39)\n    mSubscriber::onRefreshNext\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3179/comments",
    "author": "fandong12388",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-08-23T09:36:42Z",
        "body": "Is mSubscriber set to null somewhere?\n"
      },
      {
        "user": "fandong12388",
        "created_at": "2015-08-23T10:08:59Z",
        "body": "thanks,I fingered out! mSubscriber is null!\n"
      }
    ]
  },
  {
    "number": 3178,
    "title": "How to create a set of separated eventhandler",
    "created_at": "2015-08-22T20:07:02Z",
    "closed_at": "2015-11-09T21:33:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3178",
    "body": "Hello there, suppouse i've an observable that emits user events. For clarity lets assume the emitted events are \"Point(x,y)\" coordinates on where the user taps on the screen.\n\nThen i've multiple pieces of code capable of handling these coordinates and decide accordingly how to \"react\". Example:\n1. RectClickHandler - Handles only coordinates that are inside a given rectangle (say, a rectangle-shaped button)\n2. NavigationClickHandler - Handles only coordinates within navigation elements\n\nLets say I've 3 buttons on my screen (3 x RectClickHandler) and 1 NavigationElement. \n\nGiven the single emitting Observable what would be the best way to replicate this non-reactive code:\n\n``` java\n\n RectClickHandler btn1;\n RectClickHandler btn2;\n RectClickHandler btn3;\n\n PointHandler pointHandlers[] = new PointHandlers[]{btn1, btn2, btn3, navHandler}; \n new PointEmitterObservable().\n   subscribe(\n       point -> {\n          for (PointHandler ph: pointHandlers) {\n            if (ph.canHandle(point)) {\n               ph.reactToPoint(point);\n               break;\n            }\n          }\n      }\n  );\n```\n\nShould i use `.toList().filter(btn1).filter(btn2).filter(btn3)...` ?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3178/comments",
    "author": "vekexasia",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-09-03T13:21:22Z",
        "body": "Do you want to process the point further on? If not, then your approach looks fine to me.\n"
      }
    ]
  },
  {
    "number": 3146,
    "title": "OnSubscribeCombineLatest MultiSourceProducer request method",
    "created_at": "2015-08-10T21:06:54Z",
    "closed_at": "2015-09-03T07:31:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3146",
    "body": "Why is the AtomicBolean started get and compareAndSet methods both called in the if statement on line 114 of the OnSubscribeCombineLatest class?\n\nif (!started.get() && started.compareAndSet(false, true)) \n\nIs compareAndSet alone not good enough?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3146/comments",
    "author": "wrightm",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-08-10T21:40:21Z",
        "body": "It is much faster that way because after the first call, all subsequent calls would fail the CAS and it costs 15-45 cycles whereas `get()` is likely to  cost 3-10 cycles only. Since `request` is called quite frequently, the optimization helps greatly in reducing the overhead. See the `AtomicPerf` benchmark that measures this effect. \n\nHowever, if said check is likely to get executed once, the extra get actually makes it slightly slower (something to do with how CPUs behave when they read-then-write the same memory location). Therefore, we don't call `get()` in, for example, Subscription implementations.\n"
      },
      {
        "user": "wrightm",
        "created_at": "2015-08-10T22:01:16Z",
        "body": "Thank you for your clear explanation. \n\nSo when we expect get() to return true proportionally more often than false and request to be executed a reasonable number of times we can use this \"pattern\" to potentially improve performance. \n\nI will run the benchmark to see the effects.\n"
      }
    ]
  },
  {
    "number": 3139,
    "title": "Fusing filter() with an emission/drain loop",
    "created_at": "2015-08-09T01:55:04Z",
    "closed_at": "2016-02-09T13:32:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3139",
    "body": "I've been experimenting with operator fusion (for my future work chapter in my dissertation) and it is simple to inline a filter function into the emission/drain loop so that the overhead of `request(1)` for a skipped value can be avoided/amortized, giving some interesting throughput improvements. \n\nHere are some benchmark (i7 4770K, Windows 7 x64, Java 8u51, JMH 1.10.3) results that compare an RxJava from().filter() with an absolute minimalist Reactive-Streams implementation of the two operators + fusing capability:\n\n```\nBenchmark                (times)   Mode  Cnt         Score        Error  Units\nFilterPerf.filter              1  thrpt   15  24873462,666 ? 419852,680  ops/s\nFilterPerf.filter           1000  thrpt   15    723886,848 ?   2070,738  ops/s\nFilterPerf.filter        1000000  thrpt   15       661,785 ?     23,987  ops/s\nFilterPerf.filter3             1  thrpt   15  22287395,076 ?  62387,334  ops/s\nFilterPerf.filter3          1000  thrpt   15    216723,981 ?    480,625  ops/s\nFilterPerf.filter3       1000000  thrpt   15       217,875 ?      0,464  ops/s\nFilterPerf.filterNoFuse        1  thrpt   15  21124310,001 ? 215214,806  ops/s\nFilterPerf.filterNoFuse     1000  thrpt   15    217239,919 ?    671,578  ops/s\nFilterPerf.filterNoFuse  1000000  thrpt   15       211,587 ?      3,689  ops/s\nFilterPerf.rxFilter            1  thrpt   15   3775438,637 ?  44175,577  ops/s\nFilterPerf.rxFilter         1000  thrpt   15    159261,153 ?    986,562  ops/s\nFilterPerf.rxFilter      1000000  thrpt   15       163,976 ?      1,132  ops/s\nFilterPerf.rxFilter3           1  thrpt   15   2906599,609 ?  17758,800  ops/s\nFilterPerf.rxFilter3        1000  thrpt   15     76846,788 ?    742,776  ops/s\nFilterPerf.rxFilter3     1000000  thrpt   15        78,284 ?      0,997  ops/s\n```\n\nObservations:\n- RxJava has quite the overhead of creating a sort lived observable sequence observable sequence.\n- RxJava's `Func1<T, Boolean>` has higher overhead than a primitive boolean returning predicate from Java 8  (+33% throughput).\n- Fusing a filter into an emission loop can decrease the overhead drastically. Fusing 3 filters has the roughly the same throughput as having 1 unfused filter.\n\nI personally don't often use `filter()` so I don't know if there is some typical chain of operators involving filter that could be optimized this way. Even if `filter()` is not fused into `from()`, combining subsequent filter functions can reduce the allocation cost of a chain (similar fusing is possible with `map()`).\n\nThoughts?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3139/comments",
    "author": "akarnokd",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2015-08-10T07:41:37Z",
        "body": "Looks great. I've been meaning to put through optimizations with empty for a while (not inlining of course just straightforward collapsing of composed operators).\n\nA common pattern for me is `create(AbstractOnSubscribe).map().filter()...` so I'd like to see `map` and `filter` fusion. \n"
      },
      {
        "user": "stealthcode",
        "created_at": "2015-08-10T22:03:52Z",
        "body": "Sounds promising. I'm certainly interested in seeing more about this. \n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-02-09T13:32:49Z",
        "body": "Operator-fusion, if it ever happens, will take care of this in 2.x.\n"
      }
    ]
  },
  {
    "number": 3136,
    "title": ".dematerialize() backpressure",
    "created_at": "2015-08-07T04:29:28Z",
    "closed_at": "2015-09-03T07:36:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3136",
    "body": "Follow on from #3098 \n\nAt the moment in theory `.dematerialize()` supports backpressure but it does so with what I suspect is an undesirable effect.\n\nConsider the observable `Observable.just(onNext(1), onNext(2), completed()).dematerialize()`\n\nIf I request 2 from this observable then I will receive 1, 2 as emissions but will not receive the `completed` notification till I request one more.\n\nI lean towards changing `dematerialize` so that in the case above the `completed` notification arrives with the 1, and 2 on a request of 2. The operator would need to buffer one emission until termination.\n\nAre people happy for me to submit a PR with this change?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3136/comments",
    "author": "davidmoten",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2015-08-08T00:13:28Z",
        "body": "Notice also that because of the behaviour of existing `dematerialize` the following operations which I would hope together to be a no-op is not:\n\n`.materialize().dematerialize()`\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-08-08T00:40:29Z",
        "body": "If you introduce queueing, it will penalize all events. Most consumers will keep requesting more so the final completion value should't be that far behind.\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2015-08-10T03:40:26Z",
        "body": "Yep that's true.  I'm happy not to change it. I'll leave the issue open for a week in case anyone wants to have a say and then close.\n"
      }
    ]
  },
  {
    "number": 3131,
    "title": "Concat / MergeWithDelay errors jump the queue when switching threads",
    "created_at": "2015-08-05T18:40:05Z",
    "closed_at": "2015-09-03T07:43:35Z",
    "labels": [
      "Question",
      "Feature-Request"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3131",
    "body": "Hi! I'm pretty new to RxJava, so I might be misunderstanding things.\n\nSo this works as expected:\n\n```\n    TestSubscriber<String> testSubscriber = new TestSubscriber<>();\n    Observable.concat(\n            Observable.just(\"A\")\n                    .doOnNext(str -> str.length()),\n            Observable.error(new NullPointerException())\n    ).subscribeOn(Schedulers.io())\n            .observeOn(Schedulers.immediate())\n            .subscribe(testSubscriber);\n    testSubscriber.assertValues(\"A\");\n    testSubscriber.assertError(NullPointerException.class);\n```\n\nBut when I `subscribeOn(Schedulers.io())` and `observeOn(AndroidSchedulers.mainThread())` (not this test specifically, but on a device), the error jumps the queue, and I'll never receive \"A\". Is this supposed to happen? \n\nNote that the `doOnNext` does get called. It only jumps the queue in the Subscriber. Also, when I put breakpoints to debug, sometimes the error would not jump the queue, so I suspect it's a race condition?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3131/comments",
    "author": "pterhx",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-08-11T23:03:36Z",
        "body": "`observeOn` when run with a truly async scheduler will make sure the error reaches the downstream even if there are other values queued up. `immediate()` is not a real scheduler and keeps everything in sequence.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-03T07:43:35Z",
        "body": "There are plans/preview implementation for 2.x to allow specifying error delay behavior on more kinds of operators, not just merge/flatMap. I don't really see this feature being added to 1.x in a short timeframe due to API concerns.\n"
      }
    ]
  },
  {
    "number": 3125,
    "title": "Subscriber onErrror not called if exception is null",
    "created_at": "2015-07-31T16:01:25Z",
    "closed_at": "2015-09-03T07:40:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3125",
    "body": "rxjava version 1.0.13\n\nSubscriber onErrror not called if exception passed to onError is null.\n\n @Override\npublic void onError(Throwable e) {\n           //this is method in subscriber\n}\n\nIf this is called onError is not called\n subscriber.onError(null); \nif works if\n subscriber.onError(new Exception()); \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3125/comments",
    "author": "martinvandzura",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-07-31T16:03:52Z",
        "body": "In what context does this happen?\n"
      },
      {
        "user": "martinvandzura",
        "created_at": "2015-07-31T16:33:40Z",
        "body": "I have observable:\n\n``` java\nObservable.create(new Observable.OnSubscribe<ArrayList<String>>() {\n    @Override\n    public void call(Subscriber<? super ArrayList<String>> subscriber) {\n         ArrayList<String> result = new RestApi().getFromUrl(\"someurl\");\n         if (result != null) {\n            subscriber.onNext(result);\n            subscriber.onCompleted();\n         } else {\n            subscriber.onError(null); //this doesn't work\n            //  subscriber.onError(new Exception());//this works\n         }\n    }\n});\n\nSubscriber<ArrayList<String>> subscriber = new Subscriber<ArrayList<String>>() {\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n             //this is not called when  subscriber.onError(null);\n            }\n\n            @Override\n            public void onNext(ArrayList<String> result) {\n            }\n        };\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-07-31T16:45:01Z",
        "body": "Your example works for me if I put `System.out.println(e);` into the onError method and prints `null`.\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2015-07-31T17:42:46Z",
        "body": "@akarnokd I've found that `TestSubscriber.assertError()` does not allow to use `null` as error because it uses `error.equals(...)` which throws `NullPointerException` if we pass `null` as error, so I made PR for that and also added test which asserts that we can pass `null` as error to the subscriber.\n\nSee PR #3126.\n\n@vandzi I think you have some problem in your code, try to remove anything but `subscriber.onError(null)` and check that subscriber receives in in `onError()`.\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2015-08-12T22:20:44Z",
        "body": "It is invalid to call `onError(null)`. Similar to how \"throw null\" is invalid. \n"
      },
      {
        "user": "martinvandzura",
        "created_at": "2015-08-17T07:40:18Z",
        "body": "If onError(null) is invalid, it will be good to throw exception if null is passed as parameter. This way you will not figure out there is problem until you realise that callback is not called.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-03T07:40:03Z",
        "body": "Whenever you want to throw or send `null` throw or send `new NullPointerException()` instead.\n"
      }
    ]
  },
  {
    "number": 3122,
    "title": "NoSuchMethodError + delaySubscription() causes BlockingObservable hang forever",
    "created_at": "2015-07-29T22:13:27Z",
    "closed_at": "2016-02-09T13:32:08Z",
    "labels": [
      "Bug",
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3122",
    "body": "Recently I stumbled upon issue, where `.toBlocking().single()` hanged forever. After painful debugging I traced it down to issue during our build/deploy pipeline which resulted in `NoSuchMethodError` thrown from one of the libraries. This error was swallowed completely by RxJava, and the end result was a hanging thread.\n\nHere is a minimal test case to reproduce the issue:\n\n```\nObject result = Observable\n    .create(subscriber -> {\n        subscriber.onNext(\"item 1\");\n        if (true) throw new NoSuchMethodError();\n        subscriber.onCompleted();\n    })\n    .delaySubscription(() -> Observable.just(\"delay\"))\n    .toBlocking()\n    .single();\nSystem.out.println(result);\n```\n\nThis will hang like that:\n\n```\n\"main\" #1 prio=5 os_prio=0 tid=0x000000000217e000 nid=0x1d80 waiting on condition [0x000000000207e000]\njava.lang.Thread.State: WAITING (parking)\n    at sun.misc.Unsafe.park(Native Method)\n    ...\n    at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)\n    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:461)\n    at rx.observables.BlockingObservable.single(BlockingObservable.java:341)\n    at Sandbox.main(Sandbox.java:14)\n```\n\nOf course I've fixed it by fixing our build/deploy pipeline, but I'm reporting it because the swallowed exception makes such issues really hard to debug. If the RxJava could somehow report it and/or not hang, it would be nice.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3122/comments",
    "author": "gdela",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-07-30T11:13:58Z",
        "body": "The `lift` operator doesn't use `Exceptions.throwIfFatal` but only checks for `OnErrorNotImplementedException` and tries to send the error back downstream which is dropped because the take inside the `delaySubscription` operator is already completed at that point. @davidmoten, would you like to locate such cases in the codebase?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-02-09T13:32:08Z",
        "body": "This should be fixed and if not already, released with the next version.\n"
      }
    ]
  },
  {
    "number": 3107,
    "title": "OnSubscribeMulticastSelector - can we remove?",
    "created_at": "2015-07-24T06:03:49Z",
    "closed_at": "2015-07-24T11:34:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3107",
    "body": "unused class, can we remove?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3107/comments",
    "author": "davidmoten",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-07-24T08:52:28Z",
        "body": "Fine with me.\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2015-07-24T11:34:21Z",
        "body": "Is used!\n"
      }
    ]
  },
  {
    "number": 3106,
    "title": "OperatorOnErrorFlatMap - can we remove?",
    "created_at": "2015-07-24T06:01:30Z",
    "closed_at": "2015-07-24T10:58:31Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3106",
    "body": "The class `OperatorOnErrorFlatMap` is not used and I see bugs in its implementation anyway (unsubscribe of `child` does not unsubscribe `resume` subscription). Can we remove?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3106/comments",
    "author": "davidmoten",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-07-24T07:18:17Z",
        "body": "Yes\n"
      }
    ]
  },
  {
    "number": 3087,
    "title": "Accepting Collection<Observable<T>> as argument in Observable.concat or Observable.amb ...",
    "created_at": "2015-07-17T06:54:14Z",
    "closed_at": "2016-02-09T13:30:46Z",
    "labels": [
      "Question",
      "Feature-Request"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3087",
    "body": "This is not really an issue but a comment. \nI don't understand why your Observable.concat, Observable.amb or Observable.combineLatest don't take a Collection of Observable<T> as argument. Maybe something like concatAll would be great. \n\nThat would be practical. I know you can do the trick without, but I don't see any obvious reasons why not providing the option in the first place. \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3087/comments",
    "author": "jeremieSimon",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-08-12T23:26:44Z",
        "body": "- There is an `amb(Iterable)` overload which is more broad and should suffice.\n- I don't see any reason for `combineLatest` to have at least `Collection`, but that would be an incompatible API change by now.\n- There was a `concat(Iterable)` proposed a long time ago but was rejected because of API surface concerns (too many overloads).\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-25T18:31:44Z",
        "body": "I've looked at `combineLatest` and the reason it limits the the number of concurrent sources due to the limits of RxRingBuffer: the buffer size is predetermined and the downstream request have to be divided among sources. That means each source has to be requested 1 element at least.\n\nI'd also let you know that 2.x doesn't have this limitation and the other operators have extra overloads you were looking for.\n\nI don't know if or when this feature-request for 1.x gets accepted.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-02-09T13:30:46Z",
        "body": "Both `amb` and `combineLatest` now have an overload with `Iterable`. If you wish, you can post a PR for `concat()`.\n"
      }
    ]
  },
  {
    "number": 3084,
    "title": "combineLatest with throttle and one observable completing.",
    "created_at": "2015-07-16T20:08:08Z",
    "closed_at": "2015-09-25T18:33:31Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3084",
    "body": "Should an observable created using combineLatest complete when one of the child observables completes or should it wait until all of them complete?    \n\nFailing test:\n\n``` java\n   @Test\n    public void shouldFinishOnlyAfterBothFinish() {\n        @SuppressWarnings(\"unchecked\")\n        Observer<String> observer = mock(Observer.class);\n        TestScheduler s = new TestScheduler();\n        PublishSubject<String> a = PublishSubject.create();\n        PublishSubject<String> b = PublishSubject.create();\n\n\n        final Observable<String> throttledB = b.throttleLast(5, TimeUnit.MILLISECONDS, s);\n        Observable.combineLatest(a, throttledB, new Func2<String, String, String>() {\n            @Override public String call(String s, String s2) {\n                return s + s2;\n            }\n        }).subscribe(observer);\n\n        // send events with simulated time increments\n        s.advanceTimeTo(0, TimeUnit.MILLISECONDS);\n        a.onNext(\"a\");\n        a.onCompleted();\n\n        b.onNext(\"1\");\n        s.advanceTimeTo(2, TimeUnit.MILLISECONDS);\n        b.onNext(\"2\");\n        s.advanceTimeTo(4, TimeUnit.MILLISECONDS);\n        b.onNext(\"3\");\n        b.onCompleted();\n\n        InOrder inOrder = inOrder(observer);\n        inOrder.verify(observer).onNext(\"a3\");\n        inOrder.verifyNoMoreInteractions();\n\n    }\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3084/comments",
    "author": "Laimiux",
    "comments": [
      {
        "user": "artem-zinnatullin",
        "created_at": "2015-07-16T20:49:47Z",
        "body": "`CombineLatest` should complete only after completion of all child observables.\n"
      },
      {
        "user": "Laimiux",
        "created_at": "2015-07-17T17:21:45Z",
        "body": "That's what I thought. Strange thing is that actually combineLatest observable doesn't complete, but onNext from one of the child observables that has throttleLast is not being delivered.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-08-12T23:41:18Z",
        "body": "What happens is that `throttleLast` can't sample b because it completes and the final `\"3\"` is not emitted, this is the expected behavior. If you give `\"3\"` some time before completing via `s.advanceTimeTo(10, TimeUnit.MILLISECONDS);`, you'll see the output `\"a3\"` and a completion event.\n"
      }
    ]
  },
  {
    "number": 3074,
    "title": "Reference leak via SafeSubscriber.actual?",
    "created_at": "2015-07-14T15:41:39Z",
    "closed_at": "2016-02-09T13:28:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3074",
    "body": "Is there any reason for SafeSubscriber to retain `actual` after `unsubscribe()`? I'm seeing a reference leak through the actual subscriber, and it looks like it should probably be broken by dropping that reference.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3074/comments",
    "author": "loganj",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-07-17T07:02:55Z",
        "body": "If the actual leaks it means the Subscriber leaks because it is retained somewhere outside the library. Otherwise, it provides performance benefits and avoids null checks.\n"
      },
      {
        "user": "loganj",
        "created_at": "2015-07-20T14:54:30Z",
        "body": "I _was_ holding a reference to the _Subscription_, but it had been unsubscribed. Nulling that reference allowed the Subscriber to be collected. I suppose it was naive to expect that unsubscribing a Subscription would release internal references, but there's no indication in the API how Subscription behaves with respect to references, or how a user should manage them to avoid leaks. It also appears to be inconsistent, unless I'm misreading (entirely possible): SubscriptionList and CompositeSubscription, for instance, do appear to release references to their member Subscriptions when unsubscribed.\n"
      },
      {
        "user": "loganj",
        "created_at": "2015-07-21T17:36:26Z",
        "body": "For what it's worth, it looks like SubscriptionList got the same change I'm proposing in #1440, as a response to discussion in #1292.\n"
      },
      {
        "user": "adipascu",
        "created_at": "2015-07-21T17:36:38Z",
        "body": "I also faced this undocumented behaviour, now I release my **Subscribtion** references or use a **SubscriptionList**\nThis should be documented !\nAlso I don't see any performance issues, the SafeSubscriber already checks if onCompleted or onError was previously called via the boolean field named **done**\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-25T18:35:41Z",
        "body": "Improving the documentation is a good thing and I encourage you, @loganj  or @adi1133 to post a PR with your proposed changes.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-11-09T21:47:13Z",
        "body": "Any move on this issue?\n"
      },
      {
        "user": "adipascu",
        "created_at": "2015-11-09T22:26:39Z",
        "body": "Does this issue only involve SafeSubscriber ?\n"
      }
    ]
  },
  {
    "number": 3054,
    "title": "Deadlock in toBlocking().single()",
    "created_at": "2015-06-29T11:29:53Z",
    "closed_at": "2016-02-09T13:27:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3054",
    "body": "It is sample code.\nIf there is no deadlock, it prints 0 to 999. But it doesn't. Some number is missing.\n\n``` java\nfor (int x = 0; x < 1000; x++) {\n    Observable.merge(Observable.just(x).subscribeOn(Schedulers.io()),\n            Observable.just(x).subscribeOn(Schedulers.io()))\n            .toList()\n            .map(i -> {\n        return Observable.from(i).subscribeOn(Schedulers.io()).toList().toBlocking().single();\n    }).subscribeOn(Schedulers.io()).subscribe(System.out::println);\n}\n```\n\nI am tracing this issue for a while. I found the root cause finally. When completeInner is happen in merge, the inner subscriber will be unsubscribed and the worker of the inner subscriber is unsubscribed and released. The last inner subscriber will call the onCompleted of toList. Then, toList will be executed in the released worker.\n\nIf you call toBlocking() after toList. The released worker will be blcoked. Waiting for the next work is done. But sometimes the released worker will be get again and the next work is pedding. This is a deadlock.\n\nI have a workaround right now. Add a observeOn(Schedulers.io()) after merge().toList(). But I have no idea how to fix it. So I create this issue.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3054/comments",
    "author": "Wendly",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-06-29T13:26:28Z",
        "body": "This is a same-pool deadlock situation. The worker of one of the async `just` gets put back into pool but the same thread will emit the `onCompleted()` and trigger the execution of the `map()` which starts a blocking call and receives the same IO worker it is currently executing on and schedules the `from()` behind itself, blocks and thus deadlocks due to itself.\n\nIf you use `computation()` or `newThread()` in the inner `subscribeOn`, there is no deadlock. Generally though, blocking and non-blocking streaming doesn't mix well and you should avoid using `toBlocking()` inside a sequence (as an exit point it is fine). Use either `flatMap` or `concatMap` to keep the stream non-blocking.\n\nGenerally, I'm not sure if such case can be fixed: merge would need to not unsubscribe its very last inner, but there could be pending scalar emissions and the emission might be eventually triggered by a request from another thread. Tracking the number of `ScheduledAction`s doesn't work either because even if a wip counter is maintained, a never-run action won't decrement its value and may never reach the 0 = release thread state.\n"
      }
    ]
  },
  {
    "number": 3046,
    "title": "NullPointerException at rx.exceptions.CompositeException.getListOfCauses(CompositeException.java:245)",
    "created_at": "2015-06-23T12:54:15Z",
    "closed_at": "2015-08-12T23:50:50Z",
    "labels": [
      "Bug",
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3046",
    "body": "I use RxAndroid library in my project and I have next exception :\n\nE/AndroidRuntime(27849): Error reporting crash\nE/AndroidRuntime(27849): java.lang.NullPointerException\nE/AndroidRuntime(27849): at rx.exceptions.CompositeException.getListOfCauses(CompositeException.java:245)\nE/AndroidRuntime(27849): at rx.exceptions.CompositeException.getCause(CompositeException.java:100)\nE/AndroidRuntime(27849): at android.util.Log.getStackTraceString(Log.java:454)\nE/AndroidRuntime(27849): at android.util.Slog.e(Slog.java:151)\nE/AndroidRuntime(27849): at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:109)\nE/AndroidRuntime(27849): at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)\nE/AndroidRuntime(27849): at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)\nE/AndroidRuntime(27849): at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:66)\nE/AndroidRuntime(27849): at android.os.Handler.handleCallback(Handler.java:733)\nE/AndroidRuntime(27849): at android.os.Handler.dispatchMessage(Handler.java:95)\nE/AndroidRuntime(27849): at android.os.Looper.loop(Looper.java:146)\nE/AndroidRuntime(27849): at android.app.ActivityThread.main(ActivityThread.java:5653)\nE/AndroidRuntime(27849): at java.lang.reflect.Method.invokeNative(Native Method)\nE/AndroidRuntime(27849): at java.lang.reflect.Method.invoke(Method.java:515)\nE/AndroidRuntime(27849): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1291)\nE/AndroidRuntime(27849): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1107)\nE/AndroidRuntime(27849): at dalvik.system.NativeStart.main(Native Method)\n\nSomebody know how can I fix it ?\nThank you\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3046/comments",
    "author": "sgonchar",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-06-23T15:54:01Z",
        "body": "It appears you have a `null` exception added to a composite somewhere. What operators are you using. Do you call `onError(null)` somewhere by accident? \n"
      },
      {
        "user": "sgonchar",
        "created_at": "2015-06-24T07:01:58Z",
        "body": "I try to get throwable.getMessage callback and have this null pointer.\nI already find the reason. I make mistake at URL and try to connect to non-existent URL. I changed it and all is fine.\nI think you need handle this null pointer in other way, because currently I can't normally find the reason of exception.\nThank you\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-08-12T23:50:50Z",
        "body": "Fix already delivered. Thank you for reporting.\n"
      }
    ]
  },
  {
    "number": 3038,
    "title": "Variants of first, single etc. which return Single",
    "created_at": "2015-06-21T23:44:42Z",
    "closed_at": "2015-06-24T19:52:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3038",
    "body": "Now that we have the concept of a \"Single\", I think it would make sense that any operator which returns an observable which is guaranteed to return exactly one item or fail would be a Single. Examples would be operators like single, first, toList, takeFirst, takeLast etc.\n\nI understand that to maintain source and binary compatibility, the existing definitions of these would need to be unchanged so would it be possible to create some sort of conversion mechanism to turn an observable into a Single?\n\nIf this would be acceptable I would be happy to try my hand in writing such a conversion mechanism depending on how complex it would have to be. I have been using Rx for a while now but as of yet have not actually written something which interacts with low level Rx stuff (e.g. a custom operator)\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3038/comments",
    "author": "LalitMaganti",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-06-23T17:38:09Z",
        "body": "Yes we will want something to convert, such as `Single.from(Observable o)` or `Observable.toSingle()`.\n\nThe `toSingle()` method should behave similarly to `single()` except return a `Single`. \n\nAwkward, but all we can do during 1.x.\n\nIt would be great if you want to contribute this and start the design discussion. Note that public APIs contributions can often go through a lot of back and forth as we discuss them since we are stuck with them forever once we let them in.\n"
      }
    ]
  },
  {
    "number": 3016,
    "title": "Confusing semantics between cache(int) and replay(int)",
    "created_at": "2015-06-10T16:23:36Z",
    "closed_at": "2015-08-13T00:08:31Z",
    "labels": [
      "Question",
      "Documentation"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3016",
    "body": "It seems misleading that `replay(1).refCount()` != `cache(1)`, especially when `replay().refCount()` == `cache()`.\n\nIt's especially odd because each one cannot mimic the behavior of the other - `cache()` has no variant that limits the number of items to replay, whereas `replay()` has no variant that allows you to hint how large the `ReplaySubject` should be.\n\nI see that this has been covered before (#1591, #2913), but I still feel like something could be done to clear up the matter. Not exactly sure what - maybe all it'd take is not having the javadoc for `cache()` reference `replay()`.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3016/comments",
    "author": "dlew",
    "comments": [
      {
        "user": "fabianeichinger",
        "created_at": "2015-06-12T14:42:44Z",
        "body": "I agree that caching a limited number of elements using `cache()` would be handy sometimes, but it is important to note that `replay().refCount()` does not behave equal to `cache()` in all situations.\n\nFor example:\n\n```\nint i = 0; // actually a field or static\nObservable<Integer> cached = Observable\n            .defer(() -> Observable.just(i++, i++))\n            .cache();\ncached.subscribe(i -> System.out.println(\"sub 1: \" + i));\ncached.subscribe(i -> System.out.println(\"sub 2: \" + i));\n```\n\nprints\n\n```\nsub 1: 0\nsub 1: 1\nsub 2: 0\nsub 2: 1\n```\n\ncompared to\n\n```\nint i = 0; // actually a field or static\nObservable<Integer> replayed = Observable\n            .defer(() -> Observable.just(i++, i++))\n            .replay().refCount();\nreplayed.subscribe(i -> System.out.println(\"sub 1: \" + i));\nreplayed.subscribe(i -> System.out.println(\"sub 2: \" + i));\n```\n\nwhich results in\n\n```\nsub 1: 0\nsub 1: 1\nsub 2: 2\nsub 2: 3\n```\n"
      },
      {
        "user": "dlew",
        "created_at": "2015-06-12T18:51:56Z",
        "body": "That's interesting; I didn't know that `refCount` actively unsubscribes from the base subscription, though I guess it wouldn't really work otherwise.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-06-17T12:58:41Z",
        "body": "If the upstream terminates, all subscribers go away and `refCount` starts from zero again.\n\nI'm proposing the `autoConnect()` operator in #3023 so you can use `replay(10).autoConnect()` for now instead of a bounded `cache()`.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-08-13T00:08:31Z",
        "body": "I hope this problem has been clarified via the javadoc and the new autoConnect operator in release 1.0.14.\n"
      }
    ]
  },
  {
    "number": 2994,
    "title": "Thread safety question",
    "created_at": "2015-05-30T10:00:25Z",
    "closed_at": "2015-05-31T03:12:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2994",
    "body": "When we include state in a `Subscriber` subclass my understanding is that we don't need to make that state volatile, that visiblity issues are handled somewhere for the `onNext`, `onComplete`, `onError` calls but I'm not sure where. \n\nFor example I can make a stream switch threads for the `onNext` call using `concat` as below and the dumped stack trace is below it. What I can't see is that the field `count` has been synchronized between the changeover of threads. What is the explanation for this one?\n\n``` java\npublic static void main(String[] args) throws InterruptedException {\n        final CountDownLatch latch = new CountDownLatch(1);\n        Observable<Long> o = Observable.interval(100, TimeUnit.MILLISECONDS).take(1);\n        Observable.concat(o,o).subscribe(new Subscriber<Long>() {\n\n            int count = 0;\n\n            @Override\n            public void onCompleted() {\n                latch.countDown();\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Long t) {\n                count += 1;\n                System.out.println(Thread.currentThread().getName() + \" \" + count);\n                Thread.currentThread().dumpStack();\n            }});\n        latch.await();\n    }\n```\n\nOutput:\n\n```\nRxComputationThreadPool-1 1\nRxComputationThreadPool-2 2\n```\n\nThread dump at `subscriber.onNext`:\n\n```\nat com.github.davidmoten.rx.testing.TestingHelperConcatTest$2.onNext(TestingHelperConcatTest.java:63)\n    at com.github.davidmoten.rx.testing.TestingHelperConcatTest$2.onNext(TestingHelperConcatTest.java:1)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:130)\n    at rx.observers.SerializedObserver.onNext(SerializedObserver.java:159)\n    at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java:95)\n    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onNext(OperatorConcat.java:211)\n    at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:67)\n    at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:51)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2994/comments",
    "author": "davidmoten",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-05-30T10:45:00Z",
        "body": "There is a `synchronized` block or an atomic write operation after the calls to onXXX which flush the write buffer (release). Before an onXXX is called, there is another `synchronized` block or atomic read/write which forces the re-read of field values after it. Since onXXX are always called between these elements, there are no visibility issues between subsequent calls.\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2015-05-30T10:59:49Z",
        "body": "Thanks @akarnokd, so a synchronized read/write in `SerializedObserver` cascades synchronization to the fields of its final members (`actual`) and so on till we get to the `count` field?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-05-30T11:10:55Z",
        "body": "Think of these blocks as commits to a transaction. Everything written before will be visible to subsequent reads.\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2015-05-30T11:45:43Z",
        "body": "I'm browsing JSR-133 and haven't spotted yet how the scope of the `synchronized` block visiblity guarantees extends down to the objects in a chain of final fields. Do you have a favourite reference for this sort of stuff?\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2015-05-31T03:12:04Z",
        "body": "`happens-before` seems to cover it. For every article I read I have more unanswered questions. Plenty more reading to come it seems. Thanks for your input.\n"
      }
    ]
  },
  {
    "number": 2962,
    "title": "Throwables, throwIfFatal and addValueAsLastCause usage",
    "created_at": "2015-05-19T06:54:33Z",
    "closed_at": "2016-02-09T13:17:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2962",
    "body": "I've seen many places so far where once a Throwable is caught, we check for its fatality and attach the last value to it, however, many other places don't do this. Should the following pattern be universally applied?\n\n``` java\nT v = ...\ntry {\n    doSomeWork(v);    \n} catch (Throwable e) {\n    Exceptions.throwIfFatal(e);\n    Throwable e1 = OnErrorThrowable.addValueAsLastCause(e, v);\n    // child.onError(e1)\n    // plugin.handleError(e2)\n    return;\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2962/comments",
    "author": "akarnokd",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-08-28T17:43:50Z",
        "body": "I only ever considered it needed when wrapping around user provided functions. Is there a use case that isn't a user function where we need it?\n"
      },
      {
        "user": "stealthcode",
        "created_at": "2015-08-28T20:02:57Z",
        "body": "Is this implemented in #3183?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-08-28T20:05:43Z",
        "body": "Only those places that didn't conflict with my other PRs.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-02-09T13:17:56Z",
        "body": "Several fixes delivered.\n"
      }
    ]
  },
  {
    "number": 2958,
    "title": "Backpressure and \"nested Observables\"",
    "created_at": "2015-05-17T09:09:30Z",
    "closed_at": "2015-08-13T00:23:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2958",
    "body": "Hi,\n\nI encountered a behavior with Backpressure that I found weird.\nHere is a working example (in Groovy) with backpressure : \n\n```\nrx.Observable.from([1, 2, 3, 4])\n    .flatMap({ rx.Observable.just(it+1) })\n    .delay(2, java.util.concurrent.TimeUnit.SECONDS)\n    .subscribe(new rx.Subscriber<Integer>() {\n      public void onStart() {\n        request(2);\n      }\n      public void onNext(Integer t) {\n        println(t)\n        request(1);\n      }\n      public void onCompleted() { }\n      public void onError(Throwable e) { }\n    });\n\n// Prints : \n2\n3 //waits 2 seconds here\n4\n5\n```\n\nLet's apply `delay` directly on the Observable into the `flatMap` Operator : \n\n```\nrx.Observable.from([1, 2, 3, 4])\n    .flatMap({rx.Observable.just(it+1).delay(2, java.util.concurrent.TimeUnit.SECONDS)})\n    .subscribe(new rx.Subscriber<Integer>() {\n      public void onStart() {\n        request(2);\n      }\n      public void onNext(Integer t) {\n        println(t)\n        request(1);\n      }\n      public void onCompleted() { }\n      public void onError(Throwable e) { }\n    });\n\n// Prints : \n// waits 2 seconds\n2\n5\n4\n3// In a random order\n```\n\nI can't see why the second one is not acting like the first, printing 2 results, waiting 2 seconds before printing 2 other ones.\nIs this the normal behavior? Why? How should I do to achieve such a thing?\n\nThanks a lot for your hard work and this amazing library ;)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2958/comments",
    "author": "HugoCrd",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-05-17T11:05:12Z",
        "body": "They work as expected. \n\nThe first case, you should see a 2 second delay before 2 too, but because you delay request(1) as well, the next value will get 2 second delay relative to that.\n\nIn the second case, since all just values are delayed independently and emit from different threads, the end result order is random.\n\nYou can use timeinterval() to see the delays between values.\n"
      },
      {
        "user": "HugoCrd",
        "created_at": "2015-05-17T16:51:34Z",
        "body": "So `rx.Observable.just(it+1)` are all subscribed when I subsribe to the Observable. In that case I understand why they all complete at the same time.\n\nI thought backpressure would allow me to subscribe to whatever[1] is into the `flatMap` when `request(1)` is called (and not before).\n\nWell I got some other solutions to do that, but I was happy to use backpressure in a real case ;)\n\n[1] which in my real world problem is not a `delay` but a long processing\n"
      }
    ]
  },
  {
    "number": 2952,
    "title": "Runtime Error",
    "created_at": "2015-05-15T06:51:23Z",
    "closed_at": "2015-08-13T00:24:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2952",
    "body": "com.example.demo.MainActivity.onCreate\nFATAL EXCEPTION: main\ncom.android.internal.os.ZygoteInit.main\ncom.android.internal.policy.impl.PhoneLayoutInflater.onCreateView\ncom.android.internal.policy.impl.PhoneWindow.setContentView(PhoneWindow.java:290)\ncom.example.demo.MainActivity.onCreate\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2952/comments",
    "author": "ronakvbhalani",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-05-15T07:01:10Z",
        "body": "Could you be more specific? What kind of application is this, what does it try to accomplish and what is the concrete underlying exception?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-08-13T00:24:33Z",
        "body": "The question is not specific enough and stale. I'm closing this.\n"
      }
    ]
  },
  {
    "number": 2947,
    "title": "TestObserver thread-safety",
    "created_at": "2015-05-14T01:18:16Z",
    "closed_at": "2015-05-14T14:45:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2947",
    "body": "Disclaimer: I understand, that `TestObserver` and `TestSubscriber` were made for Unit testing purposes, but they are pretty convenient because you can record received notifications and emissions, make assertions and so on, so we used them it in our Integration test and faced problem with thread-safety of `TestObserver`.\n\nThe problem is that `TestObserver` uses `ArrayList` to store notifications and received items, in case of multi-threaded `Observable` `ArrayList` may be corrupted and tests can fail randomly.\n\nWhat do you think about using thread-safe list implementation in `TestObserver`? It should not break public API. I can prepare PR for that.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2947/comments",
    "author": "artem-zinnatullin",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-05-14T05:21:53Z",
        "body": "None of these types are thread safe and are not supposed to be as Observables are single threaded. We do not serialize by default for performance reasons. \n\nIf you need to serialize a Subject, use the toSerialized() method. An Observer should never need to be thread safe unless an Observable is breaking the contract, in which case use Observable.serialize()\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2015-05-14T12:41:49Z",
        "body": "Oh.. Dived in sources for couple hours, wrote several questions and then deleted them, now I understand more. Thanks.\n\nOne question left: am I correct that there is no need to serialize `PublishSubject` because it's already serialized per each `Observer`, because each `Observer` wrapped into `SubjectSubscriptionManager.SubjectObserver` which is serialized?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-05-14T13:09:34Z",
        "body": "No. You need to front-serialize a `PublishSubject` via `toSerialized()`. Technically, a concurrent `onNext()` call doesn't break `PublishSubject` itself but observers don't and shouldn't anticipate concurrent calls to their `onXXX` methods.\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2015-05-14T14:45:16Z",
        "body": "Checked sources again, now I see. Thanks! Issue solved.\n"
      }
    ]
  },
  {
    "number": 2893,
    "title": "Proposal: plugin to statically check for OnErrorNotImplementedException",
    "created_at": "2015-04-19T21:58:29Z",
    "closed_at": "2015-08-28T17:39:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2893",
    "body": "Something that may be useful in the future is a plugin that checks every for subscription and .toBlocking() up the chain to see if there is potential for a user-defined error.\n\nExample:\n\n```\npublic Observable<Integer> toInt(final String s){\n    return Observable.create((Subscriptor sub) -> {\n        try {\n            sub.onNext(Integer.parseInt(s));\n            sub.onCompleted();\n        } catch (NumberFormatExcetption e) {\n            sub.onError(e);\n        }\n });\n\npublic void main(){\n    toInt(\"5\").subscribe((Integer number) -> Systemout.println(number); )\n}\n```\n\nIn this example the toInt() line would get a warning not because the result is analyzed but because it can be checked that the producer can launch an exception and the subscriber may not recover from it.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2893/comments",
    "author": "pakoito",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-04-20T05:18:24Z",
        "body": "Exceptions are first class citizens in RxJava and they can appear virtually everywhere.\n"
      },
      {
        "user": "pakoito",
        "created_at": "2015-04-20T08:35:19Z",
        "body": "And many cases can not be analyzed, yes. This propose only covers the subset of them that can. Same as with NPE warnings on IntelliJ.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-04-20T08:53:48Z",
        "body": "The best one can do is to warn when you use `subscribe(Action1)` instead of the other subscribe methods.\n"
      },
      {
        "user": "pakoito",
        "created_at": "2015-04-20T08:58:47Z",
        "body": "Fair enough.\n"
      }
    ]
  },
  {
    "number": 2889,
    "title": "Observable#repeatWhen",
    "created_at": "2015-04-18T00:03:15Z",
    "closed_at": "2016-03-13T23:24:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2889",
    "body": "I'm trying to leverage the `repeatWhen` operator, but its behavior doesn't seem to be following the documentation.\nI'm probably not using it correctly, but I can't see exactly what I'm doing wrong, and I also noticed that this operator is lacking test coverage.\n\n``` java\nfinal AtomicInteger i = new AtomicInteger(0);\nfinal Observable<?> timer = Observable.timer(100, TimeUnit.MILLISECONDS)\n        .take(6)\n        .cache();\n\nfinal Observable<Integer> result = Observable.defer(() -> Observable.just(i.getAndIncrement()))\n        .repeatWhen(observable -> timer)\n        .cache();\n\nresult\n        .subscribe(System.out::println);\n\n// wait for result to complete.\nresult\n        .toList()\n        .toBlocking()\n        .first();\n```\n\nI would expect this to print `0, 1, 2, 3, 4, 5` and then complete, but instead `result` is only emitting 0 and completing.\n\nNote that what I'm trying to accomplish is more complex than this (this example in particular could be implemented with `timer()` + `map()`).\nIn my example the observable returned from `repeatWhen` is a `subject` to which I send values to make the resulting `Observable` repeat itself, but I simplified this for illustration purposes.\n\nCould somebody point to what I'm doing wrong, or whether there's a better way to implement what I described?\n\nThank you.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2889/comments",
    "author": "NachoSoto",
    "comments": [
      {
        "user": "wendigo",
        "created_at": "2015-04-18T10:34:55Z",
        "body": "Your first observable does not emmit onError notification so basically repeatWhen will never kick in ;) (it will resubscribe only onError notification)\n"
      },
      {
        "user": "NachoSoto",
        "created_at": "2015-04-18T19:25:00Z",
        "body": "Isn't that only relevant for `retryWhen`?\n\nIn any case, I reaized that a much simpler solution for my problem is using `flatMap`, though I'd still like to understand the semantics of this operator.\n\nThanks for your reply!\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-04-20T05:40:57Z",
        "body": "This appears to be a bug with repeatWhen (I can't find any unit test for this operator).\n\nEdit: quick clarification: `Observable.timer(100, TimeUnit.MILLISECONDS)` fires only once so you should see only 1 repetition.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-04-20T06:39:14Z",
        "body": "I've looked into repeatWhen and it is unclear to me how the returned observable from the user function should affect the resubscription. It seems you can't dismiss the incoming `observable` and return something independent because the returned observable `timer` will be subscribed to immediately. My guess is that you need to map/flatMap over the `observable` to return a possible delay for the resubscription:\n\n``` java\nAtomicInteger c = new AtomicInteger();\nObservable.just(1)\n.repeatWhen(o -> o.flatMap(v -> {\n    if (c.getAndIncrement() == 0) {\n        return Observable.just(1);\n    }\n    return Observable.empty();\n}))\n.subscribe(System.out::println, Throwable::printStackTrace, () -> System.out.println(\"Done\"));\n```\n\nBut this never prints \"Done\".\n\n/cc @benjchristensen @stealthcode \n"
      },
      {
        "user": "alcarvalho",
        "created_at": "2015-05-03T16:39:55Z",
        "body": "@akarnokd, for me your example is working as expected.\n\nIf you `flatMap` the observable `o` given by `repeatWhen`, it will emit all observables inside it but will only complete when `o` completes. If you keep feeding it with empty observers it won't complete. But it won't repeat, because it only repeats if you emit something.\n\nThis will print \"Done\", but only one \"1\", of course:\n\n```\nAtomicInteger c = new AtomicInteger();\nObservable.just(1)\n.repeatWhen(o -> o.flatMap(v -> {\n    if (c.getAndIncrement() == 0) {\n        return Observable.just(1);\n    }\n    return Observable.empty();\n}).take(1))\n.subscribe(System.out::println, Throwable::printStackTrace, () -> System.out.println(\"Done\"));\n```\n\nUnless I'm missing something, that's the intended behavior, right?\n"
      },
      {
        "user": "stealthcode",
        "created_at": "2015-06-05T19:26:31Z",
        "body": "@NachoSoto Your usage of repeatWhen should map the given observable and return it. The reason you are not seeing any repeats is because you are throwing away the feedback loop and we are unable to subscribe to it. Instead we are subscribing to your `timer` observable. Here is a functioning example with the desired delay. \n\n``` java\n        CountDownLatch l = new CountDownLatch(50);\n        Observable.defer(() -> Observable.just(i.getAndIncrement()))\n                .repeatWhen(observable -> observable.delay(100, TimeUnit.MILLISECONDS))\n                .subscribe((t) -> {\n                    System.out.println(t);\n                   l.countDown(); \n                });\n        l.await();\n```\n"
      },
      {
        "user": "stealthcode",
        "created_at": "2015-06-05T19:32:12Z",
        "body": "Oh and one more thing. You can get the desired effect of `final Observable<?> timer = Observable.timer(100, TimeUnit.MILLISECONDS).take(6)` with the following.\n\n``` java\nCountDownLatch l = new CountDownLatch(50);\nObservable.defer(() -> Observable.just(i.getAndIncrement()))\n        .repeatWhen(observable -> observable.delay(100, TimeUnit.MILLISECONDS).take(6))\n        .subscribe((t) -> {\n            System.out.println(t);\n            l.countDown(); \n        });\nl.await();\n```\n\n**output**\n\n```\n0\n1\n2\n3\n4\n5\n6\n```\n"
      },
      {
        "user": "stealthcode",
        "created_at": "2015-06-05T19:40:16Z",
        "body": "@akarnokd The case you point out seems like a bug to me. The final subscriber after the repeatWhen should always receive the onCompleted. Emitting an empty observable from the notificationHandler in a `repeatWhen` will propagate the onCompleted event to the child subscriber effectively terminating the observable chain. Its interesting that when I change the flatMap to a takeWhile the subscriber does execute it's onCompleted.\n\n``` java\nAtomicInteger c = new AtomicInteger();\nObservable.just(1)\n    .repeatWhen(o -> o.takeWhile((v -> c.getAndIncrement() == 0)))\n    .subscribe(System.out::println, Throwable::printStackTrace, () -> System.out.println(\"Done\"));\n```\n\n**output**\n\n```\n1\n1\nDone\n```\n"
      },
      {
        "user": "stealthcode",
        "created_at": "2015-06-09T17:33:11Z",
        "body": "/cc @davidmoten is there a unit test covering this use case in #2997?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-13T23:24:27Z",
        "body": "I now understand the intent behind this operator and @stealthcode 's example with delay works as expected.\n"
      }
    ]
  },
  {
    "number": 2841,
    "title": "How to indication if Observable succeeds or has an error outside of that Observable",
    "created_at": "2015-03-23T13:46:01Z",
    "closed_at": "2015-05-20T08:12:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2841",
    "body": "Hi,\n\nWe have a StoreService that calls an update(key, content) method which is using the couchbase client to do get-->change_content-->replace. As part of that process we are using the Observable retryWhen to handle Exceptions. In case the retry exceeds the maximum retries it just passes the Exception along, which then triggers the onError method. \n\nWhat we would like to do in case the Error cannot be handled is to throw an Exception from the update(key, content) method to the StoreService, but we have failed to do so.\n\nWe have tried to throw an Exception from the onError method but it doesn't get thrown out of the Observable. We also tried throwing a RuntimeException but it didn't work as well. We tried using a DTO that has a boolean isFailed member in it: we create the DTO before the Observable and in case of an error the DTO's isFailed is set to true inside the onError. After the Observable we check if the DTO isFailed and if so throw an exception. That didn't work either - the change that happened in the onError didn't propagate outside of the Observable (why?)\n\nReally need your help on this!\n\nThanks in advance,\nOfir\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2841/comments",
    "author": "gadafix",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-03-24T07:21:23Z",
        "body": "I don't fully understand your case. How would you expect to throw \"outside\" the Observable. If you have an Observable, you propagate any errors by sending them to your subscriber via onError. Can you give us some example code what you'd like to do?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-05-20T08:12:25Z",
        "body": "Closing due to inactivity. If you have any further questions, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 2833,
    "title": "IllegalThreadStateException on shutdown from maven exec plugin",
    "created_at": "2015-03-17T23:17:30Z",
    "closed_at": "2015-08-13T00:45:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2833",
    "body": "When I run a java program that uses RxJava via the maven exec plugin (`mvn exec:java`) I get this warning on program completion. \n\n```\n[WARNING] NOTE: 1 thread(s) did not finish despite being asked to  via interruption. This is not a problem with exec:java, it is a problem with the running code. Although not serious, it should be remedied.\n```\n\nIs this something we can address?\n\nFull trace:\n\n```\n[WARNING] Warning: killAfter is now deprecated. Do you need it ? Please comment on MEXEC-6.\n[WARNING] thread Thread[RxComputationThreadPool-1,5,au.gov.amsa.risky.format.NetcdfFixesWriterMain] was interrupted but is still alive after waiting at least 14999msecs\n[WARNING] thread Thread[RxComputationThreadPool-1,5,au.gov.amsa.risky.format.NetcdfFixesWriterMain] will linger despite being asked to die via interruption\n[WARNING] NOTE: 1 thread(s) did not finish despite being asked to  via interruption. This is not a problem with exec:java, it is a problem with the running code. Although not serious, it should be remedied.\n[WARNING] Couldn't destroy threadgroup org.codehaus.mojo.exec.ExecJavaMojo$IsolatedThreadGroup[name=au.gov.amsa.risky.format.NetcdfFixesWriterMain,maxpri=10]\njava.lang.IllegalThreadStateException\n        at java.lang.ThreadGroup.destroy(ThreadGroup.java:775)\n        at org.codehaus.mojo.exec.ExecJavaMojo.execute(ExecJavaMojo.java:328)\n        at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101)\n        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209)\n        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)\n        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)\n        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84)\n        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59)\n        at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183)\n        at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161)\n        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:320)\n        at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156)\n        at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537)\n        at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196)\n        at org.apache.maven.cli.MavenCli.main(MavenCli.java:141)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:606)\n        at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)\n        at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)\n        at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)\n        at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2833/comments",
    "author": "davidmoten",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-03-18T07:17:02Z",
        "body": "Can you do a threaddump in that 15 seconds to see who is blocking the executor?\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2015-03-18T10:26:55Z",
        "body": "This is the program I ran\n\n``` java\nimport rx.Observable;\nimport rx.schedulers.Schedulers;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        Observable.just(1).subscribeOn(Schedulers.computation()).toBlocking()\n                .first();\n        System.out.println(\"finished\");\n    }\n}\n```\n\nHere's the thread dump during the 15s wait:\n\n```\nFull thread dump Java HotSpot(TM) 64-Bit Server VM (25.40-b25 mixed mode):\n\n\"Attach Listener\" #13 daemon prio=9 os_prio=0 tid=0x00007fc908001000 nid=0xd7b runnable [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n\"RxComputationThreadPool-1\" #12 daemon prio=5 os_prio=0 tid=0x00007fc8f4020000 nid=0xd52 waiting on condition [0x00007fc921365000]\n   java.lang.Thread.State: WAITING (parking)\n    at sun.misc.Unsafe.park(Native Method)\n    - parking to wait for  <0x00000000ef864920> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1081)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)\n    at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n\n\"Service Thread\" #9 daemon prio=9 os_prio=0 tid=0x00007fc9540d4800 nid=0xd4f runnable [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n\"C1 CompilerThread3\" #8 daemon prio=9 os_prio=0 tid=0x00007fc9540c7800 nid=0xd4e waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n\"C2 CompilerThread2\" #7 daemon prio=9 os_prio=0 tid=0x00007fc9540c5000 nid=0xd4d waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n\"C2 CompilerThread1\" #6 daemon prio=9 os_prio=0 tid=0x00007fc9540c3800 nid=0xd4c waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n\"C2 CompilerThread0\" #5 daemon prio=9 os_prio=0 tid=0x00007fc9540c0800 nid=0xd4b waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n\"Signal Dispatcher\" #4 daemon prio=9 os_prio=0 tid=0x00007fc9540bf000 nid=0xd4a runnable [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n\"Finalizer\" #3 daemon prio=8 os_prio=0 tid=0x00007fc954087000 nid=0xd49 in Object.wait() [0x00007fc922e48000]\n   java.lang.Thread.State: WAITING (on object monitor)\n    at java.lang.Object.wait(Native Method)\n    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)\n    - locked <0x00000000f2585148> (a java.lang.ref.ReferenceQueue$Lock)\n    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)\n    at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)\n\n\"Reference Handler\" #2 daemon prio=10 os_prio=0 tid=0x00007fc954084800 nid=0xd48 in Object.wait() [0x00007fc922f49000]\n   java.lang.Thread.State: WAITING (on object monitor)\n    at java.lang.Object.wait(Native Method)\n    at java.lang.Object.wait(Object.java:502)\n    at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:157)\n    - locked <0x00000000f259a048> (a java.lang.ref.Reference$Lock)\n\n\"main\" #1 prio=5 os_prio=0 tid=0x00007fc95400a000 nid=0xd3e in Object.wait() [0x00007fc959f80000]\n   java.lang.Thread.State: TIMED_WAITING (on object monitor)\n    at java.lang.Object.wait(Native Method)\n    at java.lang.Thread.join(Thread.java:1253)\n    - locked <0x00000000ef8c1770> (a java.lang.Thread)\n    at org.codehaus.mojo.exec.ExecJavaMojo.joinThread(ExecJavaMojo.java:408)\n    at org.codehaus.mojo.exec.ExecJavaMojo.terminateThreads(ExecJavaMojo.java:451)\n    at org.codehaus.mojo.exec.ExecJavaMojo.execute(ExecJavaMojo.java:324)\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:133)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:108)\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:76)\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:116)\n    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:361)\n    at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:155)\n    at org.apache.maven.cli.MavenCli.execute(MavenCli.java:584)\n    at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:213)\n    at org.apache.maven.cli.MavenCli.main(MavenCli.java:157)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)\n\n\"VM Thread\" os_prio=0 tid=0x00007fc95407f800 nid=0xd47 runnable \n\n\"GC task thread#0 (ParallelGC)\" os_prio=0 tid=0x00007fc95401f000 nid=0xd3f runnable \n\n\"GC task thread#1 (ParallelGC)\" os_prio=0 tid=0x00007fc954021000 nid=0xd40 runnable \n\n\"GC task thread#2 (ParallelGC)\" os_prio=0 tid=0x00007fc954022800 nid=0xd41 runnable \n\n\"GC task thread#3 (ParallelGC)\" os_prio=0 tid=0x00007fc954024800 nid=0xd42 runnable \n\n\"GC task thread#4 (ParallelGC)\" os_prio=0 tid=0x00007fc954026000 nid=0xd43 runnable \n\n\"GC task thread#5 (ParallelGC)\" os_prio=0 tid=0x00007fc954028000 nid=0xd44 runnable \n\n\"GC task thread#6 (ParallelGC)\" os_prio=0 tid=0x00007fc954029800 nid=0xd45 runnable \n\n\"GC task thread#7 (ParallelGC)\" os_prio=0 tid=0x00007fc95402b800 nid=0xd46 runnable \n\n\"VM Periodic Task Thread\" os_prio=0 tid=0x00007fc9540d7000 nid=0xd50 waiting on condition \n\nJNI global references: 48\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-18T10:33:16Z",
        "body": "Sending interrupt to a threadpool doesn't work; one needs to call shutdown on them directly. But since RxJava doesn't support shutdown, you can't really do this.\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2015-03-18T10:36:37Z",
        "body": "Could we support manual shutdown so that I can make some call to a static method at the end of my program and have stuff cleaned up?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-18T10:49:48Z",
        "body": "There was a PR for shutting down schedulers (and allow them to start again) but it died.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-05-20T08:24:57Z",
        "body": "Is this still relevant? Maybe we should reopen/continue a discussion about shutdownable schedulers elsewhere.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-08-13T00:45:54Z",
        "body": "See #3149.\n"
      }
    ]
  },
  {
    "number": 2829,
    "title": "Propagate error from observer/subscriber upward to a source",
    "created_at": "2015-03-17T10:44:32Z",
    "closed_at": "2015-05-20T08:25:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2829",
    "body": "Let's imagine I have some API that provides Observer or Subscriber. User can subscribe it to some source (Observable) and produce messages. If Something went wrong on my side I want to raise error so user can decide what to do with this error (because only user can know what to do).\n\nSo I can do something like that:\n\n``` kotlin\n    (0..10000).toObservable().\n            retry().\n            unsafeSubscribe (subscriber<Int>().onNext {\n                println(\"$it\")\n                throw RuntimeException(\"expected at $it\")\n            })\n```\n\nThis will simply hang at 0 (so it works as I want). Hover if I use subscribe instead of unsafeSubscribe then I can't propagate error so it is impossible to do what I need and can't force user to always use unsafeSubscribe.\n\nThe obvious solution is to not propagate error at all but user can't know that shit happened and don't know when to resubscribe.\n\nSo am I doing something wrong or missing something?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2829/comments",
    "author": "cy6erGn0m",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-03-24T07:31:32Z",
        "body": "You could use flatMap followed by retry to restart the stream in the following way:\n\n```\nObservable.range(0, 10000).flatMap(\n                v -> v == 10 ? Observable.error(new RuntimeException()) : Observable.just(v))\n               .retry(5).subscribe(System.out::println, Throwable::printStackTrace);\n```\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2015-03-25T16:00:12Z",
        "body": "`unsafeSubscribe` is called \"unsafe\" for a reason :-) It is intended for \"internal\" style code, such as implementing custom operators. There is really no good reason for normal code to ever use it. \n\nAs @akarnokd says, errors should be handled through composition and if retries are wanted then use `retry` or `retryWhen`. \n\nHere is a variant that logs the issue only and retries\"\n\n``` java\n[stream-with-occasional-error]\n     .map(i -> doing-stuff)\n     .doOnError(e -> e.printStackTrace())\n     .retry()\n     .subscribe(...)\n```\n"
      },
      {
        "user": "cy6erGn0m",
        "created_at": "2015-03-25T16:04:25Z",
        "body": "Well, the question was: is there way to resubscribe if error happens in subscriber, not in source observable. I see no way to do it anyway so the only solution is to rework and make observable from subscriber\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2015-03-25T21:21:17Z",
        "body": "Just move the logic in your subscriber to `doOnNext` or use an `Operator` with `lift` so that it is upstream of the retry operator and then subscribe with no argument.\n\nThat is:\n\n``` java\nObservable.range(0,1000)\n    .doOnNext(actionThatMightThrowException)\n    .retry()\n    .subscribe();\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-05-20T08:25:59Z",
        "body": "Closing due to inactivity. If you have any further questions, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 2805,
    "title": "PublishSubject does not honour subscribeOn",
    "created_at": "2015-03-05T12:23:53Z",
    "closed_at": "2015-03-12T23:11:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2805",
    "body": "In the code below, the subscriber gets called in main thread itself. If we remove the sleep, subscriber is not even called. Tried version 1.0.7, 1.0.6 and 1.0.4. My understanding is that the subscriber will be called in the passed executor.\n\n``` java\n  public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n        Scheduler scheduler = Schedulers.from(executor);\n\n        Subject<Integer, Integer> sub = PublishSubject.create();\n        // BufferUntilSubscriber.create();\n        sub.subscribeOn(scheduler).subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer t1) {\n                // This prints 'main'\n                System.out.println(Thread.currentThread());\n            }\n        });\n\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e1) {\n            e1.printStackTrace();\n        }\n\n        sub.onNext(1);\n    }\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2805/comments",
    "author": "ashish-tyagi",
    "comments": [
      {
        "user": "ashish-tyagi",
        "created_at": "2015-03-05T12:31:50Z",
        "body": "If we use BufferUntilSubscriber, the behavior is even more puzzling. If there is no sleep, the subscriber gets called in the executor thread. If we put some sleep, the subscriber gets called in main thread.  Should not the behavior be consistent, sleep or no sleep?\n\n``` java\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n        Scheduler scheduler = Schedulers.from(executor);\n\n        Subject<Integer, Integer> sub = BufferUntilSubscriber.create();\n        sub.subscribeOn(scheduler).subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer t1) {\n                System.out.println(Thread.currentThread());\n            }\n        });\n\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e1) {\n            e1.printStackTrace();\n        }\n\n        sub.onNext(1);\n    }\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-05T15:45:20Z",
        "body": "Your first example subscribes on the given thread but receives values from the same thread your PublishSubject is emitting. You need `observeOn` to put those values to the desired thread.\n"
      },
      {
        "user": "ashish-tyagi",
        "created_at": "2015-03-05T20:48:21Z",
        "body": "Yes, observeOn works fine.\n\nThe behavior in second example is still inconsistent.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-05T21:24:38Z",
        "body": "In the second example, there is a race between the main thread emission and when the BufferUntilSubscriber starts to replay any buffered value. If the main thread is slow, the BufferUntilSubscriber wins but is empty at that point and just relays any value. If the main thread is fast, the BufferUntilSubscriber receives the value first, then it is subscribed to on the specified thread and immediately replays this buffered value.\n"
      },
      {
        "user": "ashish-tyagi",
        "created_at": "2015-03-12T23:11:10Z",
        "body": "Thanks for the info. I had a misunderstanding on how onSubscribe() should work.\n"
      }
    ]
  },
  {
    "number": 2789,
    "title": "Combining merge and mergeMaxConcurrent",
    "created_at": "2015-03-02T17:26:21Z",
    "closed_at": "2015-03-11T13:46:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2789",
    "body": "I'm writing a combined merge for 2.0 and have some questions:\n- In the 1.0 `merge`, the scalar queue is bounded and may throw `MissingBackpressureException` if more than `RxRingBuffer.SIZE` scalars are merged without downstream requests. Do we want to keep this behavior switch to an unbounded queue?\n- In the current `mergeMaxConcurrent`, upstream's backpressure-support is loosely handled: `mergeMaxConcurrent` requests `maxConcurrent` but queues `Observable`s that arrive after the limit. Do we wan't to keep this behavior or throw `MissingBackpressureException`?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2789/comments",
    "author": "akarnokd",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-03-05T06:00:04Z",
        "body": "> switch to an unbounded queue\n\nWhy would we want an unbounded queue? That would break backpressure and allow buffer bloat.\n\n> queues Observables that arrive after the limit\n\nThat sounds like a problem in our current implementation. It should use `request(n)` backpressure semantics to request only enough to fill the `maxConcurrent`. We should definitely not queue `Observable`s in an unbounded buffer. \n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-05T10:47:30Z",
        "body": "> Why would we want an unbounded queue? That would break backpressure and allow buffer bloat.\n\nCurrent 1.x merge requests `Long.MAX_VALUE` from upstream. If all of those are `ScalarSynchronousObservable`s, the merge will throw a `MissingBackpressureException`. So are we essentially saying: you can merge any number of non-scalar Observables but you can only merge RxRingBuffer.SIZE scalar observables at the same time?\n"
      }
    ]
  },
  {
    "number": 2653,
    "title": "onBackpressureBlock() blocks forever when subscribe and observe on newThread",
    "created_at": "2015-02-13T03:24:35Z",
    "closed_at": "2015-02-13T21:14:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2653",
    "body": "``` Java\n        Observable<Integer> source = Observable.range(0,1000)\n                .onBackpressureBlock()\n                .subscribeOn(Schedulers.newThread())\n                .observeOn(Schedulers.newThread());\n\n        source.subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer i) {\n                try {\n                    Thread.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(i);\n            }\n        });\n\n        try {\n            Thread.sleep(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n```\n\nThe output gives only 0 to 127, where I expected it to be 0 to 999.\nThis behavior exists in both 1.0.6 and master. Is this a bug or I used it incorrectly?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2653/comments",
    "author": "FinalVersion",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-02-13T07:35:00Z",
        "body": "Hi. What's happening is that subscribeOn routes all backpressure requests to the same thread doing the range emission which blocks. You need to move the `subscribeOn` before the `onBackpressureBlock`.\n"
      },
      {
        "user": "FinalVersion",
        "created_at": "2015-02-13T08:30:57Z",
        "body": "Wow, I didn't notice such subtle difference. Though I haven't quite understood what really happens under the hood, it works anyway. Thank you!\n"
      }
    ]
  },
  {
    "number": 2608,
    "title": "Run two observables sequentially, using result from first observable in second observable (question)",
    "created_at": "2015-02-05T10:47:15Z",
    "closed_at": "2015-03-11T13:59:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2608",
    "body": "I'm probably overlooking something basic (sorry for that), this seems like it should be easy to do.\n\nI have an Identifier class:\n\n```\nclass Identifier {\n    int id;\n    String value;\n    Ticket[] tickets;\n\n    void setTickets(Ticket[] tickets) { this.tickets = tickets; }\n}\n```\n\nAnd two separate API calls, (1) one for retrieving an identifier based on the identifier value (not the id), and (2) one for retrieving the tickets for an identifier using the identifier id:\n1. `Observable<Identifier> getIdentifier(String identifierValue);`\n2. `Observable<Ticket[]> getTickets(int identifierId);`\n\nI want to create a method with the following signature:\n`Observable<Identifier> getIdentifierWithTickets(String identifierValue);`\n\nthat combines the two observables to create an `Observable<Identifier>` that:\n1. Retrieves the identifier based on the identifierValue.\n2. Retrieves the tickets for that identifier and assigns them to that identifier.\n\nI've tried several operators but I can't find the right one. The `zipWith` operator runs the two observables in parallel so that didn't work. I can perhaps use `flatMap` but then I have to create a new observable that transforms `Observable<Ticket[]>` into `Observable<Identifier>`.\n\nLike I said, I feel that I'm missing something very basic here, anyone please help.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2608/comments",
    "author": "riley-van-hengstum",
    "comments": [
      {
        "user": "riley-van-hengstum",
        "created_at": "2015-02-05T11:29:16Z",
        "body": "**Update**\n\nThis is what I have so far:\n\n``` java\npublic Observable<Identifier> getIdentifierWithTickets(String identifierValue) {\n    return service.getIdentifier(identifierValue)\n            .flatMap(new Func1<Identifier, Observable<Identifier>>() {\n                @Override\n                public Observable<Identifier> call(final Identifier identifier) {\n                    return service.getTickets(identifier.getId())\n                            .flatMap(new Func1<Ticket[], Observable<Identifier>>() {\n                                @Override\n                                public Observable<Identifier> call(Ticket[] tickets) {\n                                    identifier.setTickets(tickets);\n                                    return Observable.just(identifier);\n                                }\n                            });\n                }\n            });\n}\n```\n\nThis works, but it seems a bit convoluted. Is there any way to simplify this?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-02-05T11:51:44Z",
        "body": "I think you don't need the second `flatMap`s since you return a single value for each; `map` should do it.\n"
      },
      {
        "user": "riley-van-hengstum",
        "created_at": "2015-02-05T12:58:58Z",
        "body": "@akarnokd Thanks, I overlooked that. This simplifies things:\n\n``` java\npublic Observable<Identifier> getIdentifierWithTickets(String identifierValue) {\n    return service.getIdentifier(identifierValue)\n            .flatMap(new Func1<Identifier, Observable<Identifier>>() {\n                @Override\n                public Observable<Identifier> call(final Identifier identifier) {\n                    return service.getTickets(identifier.getId())\n                            .map(new Func1<Ticket[], Identifier>() {\n                                @Override\n                                public Identifier call(Ticket[] tickets) {\n                                    identifier.setTickets(tickets);\n                                    return identifier;\n                                }\n                            });\n                }\n            });\n}\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-11T13:59:21Z",
        "body": "I'm closing this due to lack of activity. If you have further questions, don't hesitate to reopen this issue or post a new one.\n"
      },
      {
        "user": "madnotdead",
        "created_at": "2017-08-16T15:14:48Z",
        "body": "Wow! This is what i was looking for. In my case i have to login in and with the retrieved User save the token value. Then make a call to another api to get a date based on the user token. So my case was similar to this, mainly because i need to chain api call. Thanks for sharing!"
      },
      {
        "user": "yterletskyi",
        "created_at": "2017-08-27T13:46:12Z",
        "body": "Thanks for solution, `flatMap` worked for me too!"
      },
      {
        "user": "parikshitdutta",
        "created_at": "2018-07-12T12:25:42Z",
        "body": "Probably we can make it a bit less convoluted, besides using map for obvious reason:\r\n\r\n```\r\npublic Observable<Identifier> getIdentifierWithTickets(String identifierValue) {\r\n     return service.getIdentifier(identifierValue)\r\n          .flatMap(identifier -> {\r\n               return service.getTickets(identifier.getId())\r\n                    .map(tickets -> identifier.setTickets(tickets));\r\n          });\r\n}\r\n```\r\n\r\n"
      },
      {
        "user": "scamexdotexe",
        "created_at": "2018-09-20T21:15:49Z",
        "body": "@madnotdead how did you go about that login? My case is quite similar, I have to get the time first from the server and convert it to timestamp and use it as one of the parameters for login (second api call)."
      }
    ]
  },
  {
    "number": 2606,
    "title": "OperatorMerge question (synchronous processsing)",
    "created_at": "2015-02-05T01:20:32Z",
    "closed_at": "2015-03-11T14:01:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2606",
    "body": "A  question about `OperatorMerge`: I see this pattern in the source:\n\n```\nactual.onNext(t.get());\nMergeProducer.REQUESTED.decrementAndGet(mergeProducer);\n```\n\nI wonder why these two statements are not reversed in order to assist in processing of a synchronous merge (the `onNext` may call `request(n)` synchronously which I assume has a go at draining the queue and may overreport because `REQUESTED` hasn't been decremented yet). I suspect this is dealt with as surely a unit test would have coverage of this.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2606/comments",
    "author": "davidmoten",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2015-02-05T01:23:24Z",
        "body": "oh, there is an emit lock, looks ok\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2015-02-05T01:25:32Z",
        "body": "There should be no locks held while emitting. If there is that is a problem. \n"
      },
      {
        "user": "davidmoten",
        "created_at": "2015-02-05T01:26:37Z",
        "body": "not a normal lock but rather just a boolean flag under the covers \n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-02-05T07:23:02Z",
        "body": "Because it would allow concurrent emission. Let's assume requested == 1. If a concurrent emission is attempted while onNext is going, the counter would increment to 2 and since it wasn't null, the drain is skipped. Now if swapped, requested becomes 0 and onNext is going. A concurrent emission now succeeds incrementing 0 -> 1 and enters the drain loop, decrements the value back to 0 and calls onNext. If requested is close to Long.MAX_VALUE, we don't really care if an emission attempt can't increment above this value since essentially unlimited amount was requested.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-11T14:01:47Z",
        "body": "I'm closing this due to inactivity. If you have further questions, please don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 2605,
    "title": "Observable hangs",
    "created_at": "2015-02-05T00:48:51Z",
    "closed_at": "2015-03-11T14:02:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2605",
    "body": "This is the continuation of my old issue #2588 \n I took the Thread dump. One thread is in Running state always , This happens after i used Scheduler.io()\n\n```\n\"RxCachedThreadScheduler-1\" daemon prio=5 tid=0x00007fb1ec9bb800 nid=0xa103 runnable [0x0000000115eee000]\n   java.lang.Thread.State: RUNNABLE\n  at java.net.SocketInputStream.socketRead0(Native Method)\n  at java.net.SocketInputStream.read(SocketInputStream.java:152)\n  at java.net.SocketInputStream.read(SocketInputStream.java:122)\n  at oracle.net.ns.Packet.receive(Unknown Source)\n  at oracle.net.ns.DataPacket.receive(Unknown Source)\n  at oracle.net.ns.NetInputStream.getNextPacket(Unknown Source)\n  at oracle.net.ns.NetInputStream.read(Unknown Source)\n  at oracle.net.ns.NetInputStream.read(Unknown Source)\n  at oracle.net.ns.NetInputStream.read(Unknown Source)\n  at oracle.jdbc.driver.T4CMAREngine.unmarshalUB1(T4CMAREngine.java:1104)\n  at oracle.jdbc.driver.T4CMAREngine.unmarshalSB1(T4CMAREngine.java:1075)\n  at oracle.jdbc.driver.T4C8Oall.receive(T4C8Oall.java:480)\n  at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:219)\n  at oracle.jdbc.driver.T4CPreparedStatement.executeForRows(T4CPreparedStatement.java:970)\n  at oracle.jdbc.driver.OraclePreparedStatement.executeBatch(OraclePreparedStatement.java:10690)\n  - locked <0x00000007b13c0988> (a oracle.jdbc.driver.T4CPreparedStatement)\n  - locked <0x00000007b13147b0> (a oracle.jdbc.driver.T4CConnection)\n  at org.hibernate.jdbc.BatchingBatcher.doExecuteBatch(BatchingBatcher.java:70)\n  at org.hibernate.jdbc.AbstractBatcher.executeBatch(AbstractBatcher.java:268)\n  at org.hibernate.engine.ActionQueue.executeActions(ActionQueue.java:266)\n  at org.hibernate.engine.ActionQueue.executeActions(ActionQueue.java:168)\n  at org.hibernate.event.def.AbstractFlushingEventListener.performExecutions(AbstractFlushingEventListener.java:321)\n  at org.hibernate.event.def.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:50)\n  at org.hibernate.impl.SessionImpl.flush(SessionImpl.java:1027)\n  at org.hibernate.impl.SessionImpl.managedFlush(SessionImpl.java:365)\n  at org.hibernate.transaction.JDBCTransaction.commit(JDBCTransaction.java:137)\n  at org.springframework.orm.hibernate3.HibernateTransactionManager.doCommit(HibernateTransactionManager.java:657)\n  at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:755)\n  at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:724)\n  at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:387)\n  at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:120)\n  at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)\n  at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)\n  at com.sun.proxy.$Proxy114.entitlementRecordsOfQuery(Unknown Source)\n  at com.umapranesh.service.DefaultEntitlementStrategy.getRecordsOfQuery(DefaultEntitlementStrategy.java:153)\n  at com.umapranesh.service.DefaultEntitlementStrategy$1.call(DefaultEntitlementStrategy.java:71)\n  at com.umapranesh.service.DefaultEntitlementStrategy$1.call(DefaultEntitlementStrategy.java:1)\n  at rx.Observable.unsafeSubscribe(Observable.java:7326)\n  at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n  at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:47)\n  at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n  at java.util.concurrent.FutureTask.run(FutureTask.java:262)\n  at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)\n  at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)\n  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n  at java.lang.Thread.run(Thread.java:745)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2605/comments",
    "author": "pradhakrishnan",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-02-05T05:43:26Z",
        "body": "If it is hung, it is hung reading IO according to that stack:\n\n> at java.net.SocketInputStream.socketRead0(Native Method)\n\nWhat makes you think Rx has anything to do with the thread not completing while reading IO?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-11T14:02:13Z",
        "body": "I'm closing this due to inactivity. If you have further questions, please don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 2597,
    "title": "scan with retry",
    "created_at": "2015-02-04T09:33:07Z",
    "closed_at": "2015-05-20T09:09:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2597",
    "body": "Hi, let's say for example I have this code:\n\n``` java\nObservable.range(1,100)\n        .scan(1, (p, i) -> {\n            if (i == 10 && start) {\n                start = false;\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            return p * i;\n        })\n        .retry()\n        .doOnNext(System.out::println)\n        .subscribe();\n```\n\nIts output is:\n\n```\n1\n1\n2\n6\n24\n120\n720\n5040\n40320\n362880\n362880\n1\n1\n2\n6\n24\n120\n720\n5040\n40320\n362880\n3628800\n39916800\n479001600\n1932053504\n...\n```\n\nI want the `retry` operator to cause the observable to start from where it stopped (10 in this case). Is there a way to do this purely, without saving the state etc.?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2597/comments",
    "author": "david-hoze",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-02-04T09:48:47Z",
        "body": "You could use `distinct()` to skip over or don't throw in the function:\n\n``` java\n(p, i) -> {\n    while (true) {\n        try {\n            if (i == 10 && start) {\n                start = false;\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            break;\n        } catch (Throwable t) {\n        }\n    }\n    return p * i;\n}\n```\n"
      },
      {
        "user": "david-hoze",
        "created_at": "2015-02-04T10:11:56Z",
        "body": "Hi, in my use case I actually need to handle the error in the subscriber, so I need to throw..\nUsing `distinct` like this:\n\n``` java\nObservable.range(1,100)\n        .scan(1, (p, i) -> {\n            if (i == 10 && start) {\n                start = false;\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            return p * i;\n        })\n        .distinct()\n        .retry()\n        .doOnNext(System.out::println)\n        .subscribe();\n```\n\nyields the same behavior, as the first run and the second run of the `interval`+`scan` do not emit consequent non-distinct values (the repetition only happens after 10 cycles).\n\nHowever, for some reason using `distinct` like this (after the `retry`):\n\n``` java\nObservable.range(1,100)\n        .scan(1, (p, i) -> {\n            if (i == 10 && start) {\n                start = false;\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            return p * i;\n        })\n        .retry()\n        .distinct()\n        .doOnNext(System.out::println)\n        .subscribe();\n```\n\noutputs:\n\n```\n1\n2\n6\n24\n120\n720\n5040\n40320\n362880\n```\n\nand stops there.. Couldn't figure out why, is this the desired behavior?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-02-04T10:17:49Z",
        "body": "The latter works for me with 1.0.5 and prints:\n\n```\n1\n2\n6\n24\n120\n720\n5040\n40320\n362880\n3628800\n39916800\n479001600\n1932053504\n1278945280\n2004310016\n2004189184\n-288522240\n-898433024\n109641728\n-2102132736\n-1195114496\n-522715136\n862453760\n-775946240\n2076180480\n-1853882368\n1484783616\n-1375731712\n-1241513984\n1409286144\n738197504\n-2147483648\n0\n```\n"
      },
      {
        "user": "david-hoze",
        "created_at": "2015-02-04T13:57:43Z",
        "body": "Thanks, you're right, after I upgraded it's working.\nI just realized though that the example I gave didn't model the problem I'm trying to solve very well, so I'll try to give a better one:\n\n``` java\nObservable.interval(1, TimeUnit.SECONDS)\n        .map(i -> { Calendar cal = Calendar.getInstance();\n            cal.getTime();\n            SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\");\n            return sdf.format(cal.getTime());})\n        .scan(\"\", (times, time) -> {\n            if (time.endsWith(\"5\")) {\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            return times + \",\" + time;\n        })\n        .retry()\n        .doOnNext(System.out::println)\n        .subscribe();\n```\n\nSo now I'm trying to aggregate the emitted times. The output is:\n\n```\n,13:42:40\n,13:42:40,13:42:41\n,13:42:40,13:42:41,13:42:42\n,13:42:40,13:42:41,13:42:42,13:42:43\n,13:42:40,13:42:41,13:42:42,13:42:43,13:42:44\n,13:42:40,13:42:41,13:42:42,13:42:43,13:42:44\n,13:42:46\n,13:42:46,13:42:47\n,13:42:46,13:42:47,13:42:48\n,13:42:46,13:42:47,13:42:48,13:42:49\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50,13:42:51\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50,13:42:51,13:42:52\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50,13:42:51,13:42:52,13:42:53\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50,13:42:51,13:42:52,13:42:53,13:42:54\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50,13:42:51,13:42:52,13:42:53,13:42:54\n,13:42:56\n,13:42:56,13:42:57\n,13:42:56,13:42:57,13:42:58\n,13:42:56,13:42:57,13:42:58,13:42:59\n,13:42:56,13:42:57,13:42:58,13:42:59,13:43:00\n,13:42:56,13:42:57,13:42:58,13:42:59,13:43:00,13:43:01\n...\n```\n\nSo I'm losing the numbers I already got. Can I gracefully handle the error and get the correct aggregation without using state?\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2015-02-04T17:48:49Z",
        "body": "Generally I'd recommend doing the data validation before the `scan` so that you're filtering out bad data. Especially since your validation does not depend on the accumulated state.\n\nIf you want to be aware of the errors, do a side-effect where you pass the error events off to a logger or different Observable sequence but prevent the terminal state from propagating. This would remove the need for `retry` and error handling inside `scan`.\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2015-02-04T18:06:31Z",
        "body": "Here are a variety of approaches:\n\n``` java\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\nimport rx.exceptions.OnErrorThrowable;\nimport rx.subjects.PublishSubject;\n\npublic class ScanErrorExample {\n\n    public static void main(String... args) {\n        System.out.println(\"scanWithErrorThrownAndDropped -------------------------------\");\n        scanWithErrorThrownAndDropped();\n        System.out.println(\"scanWithErrorThrownAndLogged -------------------------------\");\n        scanWithErrorThrownAndLogged();\n        System.out.println(\"scanWithErrorEvent -------------------------------\");\n        scanWithErrorEvent();\n        System.out.println(\"scanWithFilteredData -------------------------------\");\n        scanWithFilteredData();\n        System.out.println(\"-------------------------------\");\n    }\n\n    public static void scanWithErrorThrownAndDropped() {\n        data()\n                .map(time -> {\n                    if (time.endsWith(\"5\")) {\n                        throw OnErrorThrowable.from(new Exception(\"wow\"));\n                    } else {\n                        return time;\n                    }\n                })\n                .retry()\n                .scan(\"\", (times, time) -> {\n                    return times + \",\" + time;\n                })\n                .take(15)\n                .toBlocking().forEach(System.out::println);\n    }\n\n    public static void scanWithErrorThrownAndLogged() {\n        data()\n                .map(time -> {\n                    if (time.endsWith(\"5\")) {\n                        throw OnErrorThrowable.from(new Exception(\"wow\"));\n                    } else {\n                        return time;\n                    }\n                })\n                .doOnError(e -> System.out.println(\"Error: \" + e))\n                .retry()\n                .scan(\"\", (times, time) -> {\n                    return times + \",\" + time;\n                })\n                .take(15)\n                .toBlocking().forEach(System.out::println);\n    }\n\n    public static void scanWithErrorEvent() {\n        PublishSubject<Exception> errors = PublishSubject.create();\n        errors.forEach(e -> System.out.println(\"Error: \" + e));\n\n        data()\n                .doOnNext(time -> {\n                    if (time.endsWith(\"5\")) {\n                        errors.onNext(new Exception(\"wow\"));\n                        // or just log them\n                    }\n                })\n                .filter(time -> !time.endsWith(\"5\"))\n                .retry()\n                .scan(\"\", (times, time) -> {\n                    return times + \",\" + time;\n                })\n                .take(15)\n                .toBlocking().forEach(System.out::println);\n    }\n\n    public static void scanWithFilteredData() {\n        data()\n                .filter(time -> !time.endsWith(\"5\"))\n                .scan(\"\", (times, time) -> {\n                    return times + \",\" + time;\n                })\n                .take(15)\n                .toBlocking().forEach(System.out::println);\n    }\n\n    public static Observable<String> data() {\n        return Observable.interval(1, TimeUnit.SECONDS)\n                .map(i -> {\n                    Calendar cal = Calendar.getInstance();\n                    cal.getTime();\n                    SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\");\n                    return sdf.format(cal.getTime());\n                });\n    }\n\n}\n```\n\nIf you need the error data inside the scan as well, then instead of throwing, convert it to a type that you treat as an event that your scan logic can understand. \n"
      },
      {
        "user": "david-hoze",
        "created_at": "2015-02-04T23:26:12Z",
        "body": "Hi, thanks a lot :+1:, I think the `scanWithErrorEvent` solves my problem.\nAre subjects considered hacky?\nHow about this approach instead:\n\n``` java\n    public static void scanWithErrorObservable() {\n        Observable<String> dataObservable = data();\n\n        dataObservable\n                .filter(time -> !time.endsWith(\"5\"))\n                .scan(\"\", (times, time) -> {\n                    return times + \",\" + time;\n                })\n                .take(15)\n                .toBlocking().forEach(System.out::println);\n\n        dataObservable\n                .filter(time -> time.endsWith(\"5\"))\n                .map(time -> new Exception(\"wow\"))\n                .take(15)\n                .toBlocking().forEach(e -> System.out.println(\"Error: \" + e));\n    }\n```\n\nAlso, on a general note, the fact that error propagation always unsubscribes and the only way to gracefully handle it is to resubscribe seems to limit the fluency of RxJava in a lot of use cases. The solutions suggested here show that there is no fluent way of propagating errors without disrupting the normal flow of events. I think a more straightforward solution will be:\n\n``` java\n    private static class AccumulatedState {\n        private AccumulatedState() {\n            times = \"\";\n        }\n\n        String times;\n        Throwable throwable;\n    }\n\n    public static void scanWithErrorContext() {\n        data()\n                .scan(new AccumulatedState(), (accumulatedState, time) -> {\n                    if (time.endsWith(\"5\"))\n                        accumulatedState.throwable = new Exception(\"wow\");\n                    else {\n                        accumulatedState.throwable = null;\n                        accumulatedState.times = accumulatedState.times + \",\" + time;\n                    }\n                    return accumulatedState;\n                })\n                .take(15)\n                .toBlocking()\n                .forEach(accumulatedState -> {\n                    if (accumulatedState.throwable != null) {\n                        System.out.println(\"Error: \" + accumulatedState.throwable);\n                    } else {\n                        System.out.println(accumulatedState.times);\n                    }\n                });\n    }\n```\n\nBut it seems so generic that it should be part of the framework (something like `subscriber.onSilentError`).\nThanks, Amitai.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-05-20T09:09:03Z",
        "body": "I'm closing this due to inactivity. If you have further questions, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 2577,
    "title": "Unused method",
    "created_at": "2015-01-31T22:26:23Z",
    "closed_at": "2015-02-01T09:13:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2577",
    "body": "Hi\nI think that `shutdown()` method of `rx.internal.util.ObjectPool` is never used. The result is that every ObjectPool schedules an instance of `Action0` in constructor and NEVER unsubscribes the `schedulerWorker`.\n\nIs that intentional?\n\nI know why all object pools are static :), but this is some kind of leak - 5 workers working forever :)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2577/comments",
    "author": "jakudlaty",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-01-31T23:25:01Z",
        "body": "The current Scheduler behavior is not container-friendly (i.e., Tomcat will complain about RxJava threads). These pools were introduced to increase performance and are never explicitly terminated (they stop on JVM exit). There was some movement to make schedulers shutdownable but the discussion stopped after a while and certain decisions were not made. This leak is at least minimal.\n"
      },
      {
        "user": "jakudlaty",
        "created_at": "2015-01-31T23:30:08Z",
        "body": "Thanks for quick answer :)\n"
      },
      {
        "user": "jakudlaty",
        "created_at": "2015-02-01T01:40:58Z",
        "body": "Should I close the issue?\n"
      }
    ]
  },
  {
    "number": 2539,
    "title": "SerializedObserver swallows post-termination exceptions",
    "created_at": "2015-01-25T14:59:47Z",
    "closed_at": "2015-02-05T14:37:04Z",
    "labels": [
      "Question",
      "Discussion"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2539",
    "body": "The purpose of the class is to ensure event delivery contract, but when serializing multiple event sources in operators, non-fatal errors get swallowed after a terminal event. Because these exceptions might be still worth receiving somehow, I suggest routing them to the plugin's error handler.\n\nThoughts?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2539/comments",
    "author": "akarnokd",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-01-26T16:57:13Z",
        "body": "There's no good answer for this as any operator can ignore events after a terminal operator as they are outside the contract. \n\nThe `SerializedObserver` class is only for serializing, not for any other contract enforcement, but any operator can choose to enforce it. For example, `merge` is strict about terminal events as it uses it to do cleanup whereas `map` is lenient because it is a simple operator. \n"
      }
    ]
  },
  {
    "number": 2537,
    "title": "Issue with amb operator",
    "created_at": "2015-01-24T18:12:39Z",
    "closed_at": "2015-01-24T22:39:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2537",
    "body": "I am getting below error when i tried to get the value using toBlocking()\nError:\njava.util.NoSuchElementException: Sequence contains no elements\n    at rx.internal.operators.OperatorSingle$1.onCompleted(OperatorSingle.java:82)\n    at rx.internal.operators.OperatorTake$1.onCompleted(OperatorTake.java:50)\n    at rx.internal.operators.OnSubscribeAmb$AmbSubscriber.onCompleted(OnSubscribeAmb.java:297)\n    at rx.internal.operators.OperatorFilter$1.onCompleted(OperatorFilter.java:42)\n    at rx.internal.operators.OperatorSubscribeOn$1$1$1.onCompleted(OperatorSubscribeOn.java:66)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:42)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:30)\n    at rx.Observable.unsafeSubscribe(Observable.java:8587)\n    at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:43)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:262)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    at java.lang.Thread.run(Thread.java:745)\n\n```\nprivate Observable<RecordStatus> linearStatus = Observable.create();\nprivate Observable<RecordStatus> nlvStatus = Observable.create();\n\nif(LINEAR.equals(message)){\n    linearStatus = getVideoStatusOnSubscribe(message);\n}\nif(NONLINEAR.equals(message)){\n    nlvStatus = getVideoStatusOnSubscribe(message);\n}\n\nObservable<RecordStatus> obStatus = Observable.amb(linearStatus.subscribeOn(Schedulers.io()).filter(new Func1<RecordStatus, Boolean>() {\n\n    @Override\n    public Boolean call(RecordStatus t1) {\n        return t1.equals(RecordStatus.CURRENT);\n    }\n}), nlvStatus.subscribeOn(Schedulers.io()).filter(new Func1<RecordStatus, Boolean>() {\n\n    @Override\n    public Boolean call(RecordStatus t1) {\n        return t1.equals(RecordStatus.CURRENT);\n    }\n})\nRecordStatus status = obStatus.toBlocking().first();\n\n private Observable<RecordStatus> getVideoStatusOnSubscribe(\n    final String message) {\n    return Observable.create(new OnSubscribe<RecordStatus>() {\n\n    @Override\n    public void call(Subscriber<? super RecordStatus> subscriber) {\n        subscriber.onNext(restTemplate.postForObject(url, message, String.class););\n        subscriber.onCompleted();\n    }\n});\n}\n```\n\nCould someone please help me to fix this.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2537/comments",
    "author": "pradhakrishnan",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-01-24T18:20:41Z",
        "body": "All of your sources where filterd to emptyness and first() expects at least a single value. You can use firstOrDefault instead to avoid the exception.\n"
      },
      {
        "user": "pradhakrishnan",
        "created_at": "2015-01-24T18:38:55Z",
        "body": "It works, Thanks Akarnokd.\n"
      },
      {
        "user": "pradhakrishnan",
        "created_at": "2015-01-24T23:23:16Z",
        "body": "Hi Akarnokd,\nI have tried using that, some times it works, but most of the time it is giving default value.  Is there anything wrong in my code?\n\n```\nprivate Observable<RecordStatus> linearStatus = Observable.create();\nprivate Observable<RecordStatus> nlvStatus = Observable.create();\n\nif(LINEAR.equals(message)){\n    linearStatus = getVideoStatusOnSubscribe(message);\n}\nif(NONLINEAR.equals(message)){\n    nlvStatus = getVideoStatusOnSubscribe(message);\n}\n\nObservable<RecordStatus> obStatus = Observable.amb(linearStatus.subscribeOn(Schedulers.io()).filter(new Func1<RecordStatus, Boolean>() {\n\n    @Override\n    public Boolean call(RecordStatus t1) {\n        return t1.equals(RecordStatus.CURRENT);\n    }\n}), nlvStatus.subscribeOn(Schedulers.io()).filter(new Func1<RecordStatus, Boolean>() {\n\n    @Override\n    public Boolean call(RecordStatus t1) {\n        return t1.equals(RecordStatus.CURRENT);\n    }\n})\nRecordStatus status = obStatus.toBlocking().firstOrDefalut(RecordStatus.DEFAULT);\nSystem.out.println(\"Final status Status === \"+status);\n\n private Observable<RecordStatus> getVideoStatusOnSubscribe(\n    final String message) {\n    return Observable.create(new OnSubscribe<RecordStatus>() {\n\n    @Override\n    public void call(Subscriber<? super RecordStatus> subscriber) {\n        RecordStatus status = (RecordStatus) restTemplate.postForObject(url, message, String.class);\n        logger.info(\"Thread \"+ Thread.currentThread().getId() + \" for \"+ message\n                        + \" giving status \"+status);\n        subscriber.onNext(status);\n        subscriber.onCompleted();\n    }\n});\n}\n\n```\n\nOutput trace:\n\n157 [2015-01-24 18:08:49,917] [main] WARN  com.umapranesh.sample.observable.asynceventhandler.GetVideoStatusEventHandler  - ****_Status Event**_*\\* \ncom.umapranesh.sample.observable.GetVideoStatusMessage\nFinal status Status === DEFAULT\nThread 10 for LINEAR giving status INVALID\nThread 11 for NONLINEAR giving status CURRENT\n\nThread 11 is giving the value what i expected, but before that observable returns the default value.\n"
      }
    ]
  },
  {
    "number": 2525,
    "title": "How to stop observable execution",
    "created_at": "2015-01-23T18:45:15Z",
    "closed_at": "2015-01-23T20:07:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2525",
    "body": "Hi,\n\nI have some set of observable which I am executing in parallel. I need to get the value of observable who is completing first. If the return value meets my requirement then i need to stop the execution of other observables. I couldn't find the example for that. \n\nI could do this scenario through Callable interface and CompletionService interface from concurrent package.\n\nsample code using concurrent package\n\n```\n@Autowired\nprivate CompletionService<Result> cService;\n\nList<Future<Result>> statusList = new ArrayList<Future<Result>>();\ntry{\nfor(String str: strLst){\n        statusList.add(cService.submit(new GetItemOnCallable(msg)));\n    }\n\n    for(int i =0; i < statusList.size(); i++){\n        Result status = cService.take().get();\n        if(null != status){\n         if(staus.equals(Result.SUCCESS))\n         break;\n    }\n}finally{\nfor(Future<Result> statusFuture: statusList){\n    statusFuture.cancel(true);\n}\n}\n```\n\nIs there any way to achieve this using observable?\nCan someone please help on this.\n\nRegards\nPranesh\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2525/comments",
    "author": "pradhakrishnan",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-01-23T19:07:13Z",
        "body": "We have the `amb` operator which streams the first responding source observable. You could filter your sources then amb them to get the first matching value:\n\n``` java\namb(source1.filter(predicate), source2.filter(predicate))\n```\n"
      },
      {
        "user": "pradhakrishnan",
        "created_at": "2015-01-23T19:35:39Z",
        "body": "Thanks Akarnokd. \n"
      },
      {
        "user": "pradhakrishnan",
        "created_at": "2015-01-23T20:01:29Z",
        "body": "It works fine. Thanks Akarnokd. \nI have one question on this. What will happen if none of my source observable meets my filter.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-01-23T20:04:19Z",
        "body": "You get an empty sequence which just calls onCompleted.\n"
      },
      {
        "user": "pradhakrishnan",
        "created_at": "2015-01-23T20:05:29Z",
        "body": "Got it!!! Thanks Akarnokd.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-01-23T20:07:01Z",
        "body": "You are welcome.\n"
      }
    ]
  },
  {
    "number": 2479,
    "title": "Targeting the work thread for a TrampolineScheduler",
    "created_at": "2015-01-21T19:12:50Z",
    "closed_at": "2015-03-11T14:13:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2479",
    "body": "So, `TrampolineScheduler` says work will run on the current thread. If I'm using `scheduleOn(Schedulers.trampoline()` in part of my Observable chain, how do I change which thread the sequential trampoline work is actually run on?\n\nMy assumption is it's something like this, wrapping it in another `scheduleOn`:\n\n```\n.scheduleOn(Schedulers.trampoline())\n.scheduleOn(Schedulers.io())  // Or whatever scheduler you want the work done on.\n```\n\nThis does look a bit funny and would require extra commenting to explain to a casual observer. If that's the case, would it make sense to add a static constructor for trampoline that can wrap another scheduler? Like:\n\n```\n.scheduleOn(TrampolineScheduler.on(Schedulers.io())\n```\n\nor even:\n\n```\n.scheduleOn(TrampolineScheduler.on(worker))\n```\n\nI can whip up a PR for such a thing if it would be helpful. If wrapping schedulers isn't the right way to do it, what is? :)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2479/comments",
    "author": "jnlopar",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-01-21T23:06:31Z",
        "body": "The `TrampolineScheduler` is rarely used directly. It exists primarily to serve the `repeat`/`retry` recursive use cases. Dropping it into a normal `Observable` chain using `subscribeOn` is effectively a \"no op\" since it won't change behavior or where it executes. \n\nWhat are you trying to achieve?\n"
      },
      {
        "user": "jnlopar",
        "created_at": "2015-01-21T23:13:09Z",
        "body": "So there may be a much better solution for this, but I have a pipeline of requests to do more work. In this case, it's requesting the next page in a request. So I may have two Observables of events of users asking for next/prev pages (through scroll events, buttons, whatever). Anyway, part of my requirements are that only one of these operations be done at once, and ignore incoming requests until ready for a new one. I was planning on using `onBackpressureDrop` to accomplish that part.\n\nAnyway, the trampoline seemed to be the right way to enforce a sequence of a single action at a time, but it sounds like there might be a better way.\n\nSo, laying out the full scenario in another way, there are actually two paginations possible, next or previous. I have an Observable coming in for each so I can get the latest for each end. When a new page comes in, one or both of these may update. The signals to fetch a new continuation come in separately. If a user scrolls down to the bottom of a page (requesting a 'next') page, then we should be able to grab the latest next continuation (possibly with `sample`) and process it, as long as there is no currently processing continuation in the pipeline.\n\nHope that made a little bit of sense at least. :)\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2015-01-21T23:21:50Z",
        "body": "It sounds like you're trying to do flow control with user events. This sounds directionally like `debounce` and  `switchOnNext` are where you should be looking. \n\n> enforce a sequence of a single action at a time\n\nYou can just `merge` the 2 Observables together and it will give you a single stream. \n\n> ignore incoming requests until ready for a new one\n\nDepends on what you mean by \"ready for a new one\". Is that based on user event? If so, then something like `switch` is probably relevant. I would need to understand the use case better to provide more guidance. Generally when dealing with user events all previous items should be cancelled and the latest event acted upon. This is what debounce/switch can help you achieve. \n"
      },
      {
        "user": "jnlopar",
        "created_at": "2015-01-21T23:28:49Z",
        "body": "So, we don't want to trigger a new page load (network request) until the previous one has finished. We enforce that 2-ways, so only a next or previous call on a page can be going, not both at once. So if a user keeps triggering the event that would load, we don't do extra work or spam the requests. We also don't want to queue up the user's request, since it's a transient event. Basically, from fetch page start -> fetch page end, we ignore the user input, and then start listening again after the page is fetched (or canceled, etc..) \n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-11T14:13:51Z",
        "body": "I'm closing this due to inactivity. If you have further questions, please don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 1939,
    "title": "How to chain calls, depending on result ?",
    "created_at": "2014-12-08T14:33:32Z",
    "closed_at": "2015-03-11T14:14:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/1939",
    "body": "Hello,\n\nIn my webapp, I have to chain two async calls : \nThe first call gives me a list of dog ids. \nThe second call gives me a Dog (found by its id).\n\nIn my code, i'd like to write something like :\n\n```\nfinal Observable<RxMessage<String>> observable1 = asyncCallForDogIds(..);\n\nfinal List<Dog> dogs = new ArrayList<>();\nobservable1.subscribe(\n    // onNext\n    (RxMessage<String> message) -> {\n        final String id = readId(message);\n\n        final Observable<RxMessage<String>> observable2 = someAsyncCallForOneDogId(id, ..);\n\n        final Dog dog = readFromSomeMessage2(...);\n        dogs.add(dog);\n    },\n\n    // onError\n    (Throwable err) -> error(err, ..),\n\n    // onCompleted\n    () -> resume(dogs, ..));\n```\n\nWhat would be the best way to do that ?\nTh.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/1939/comments",
    "author": "thierryler",
    "comments": [
      {
        "user": "hamidp",
        "created_at": "2014-12-08T14:55:25Z",
        "body": "You want `flatMap` so roughly:\n\n```\nasyncCallForDogIds(..)\n    .map(this::readId)\n    .flatMap(dogId -> someAsyncCallForOneDogId(id, ..))\n    .map(this::readFromSomeMessage2)\n```\n"
      },
      {
        "user": "thierryler",
        "created_at": "2014-12-09T09:18:49Z",
        "body": "Yes that looks what I need. Thx. But how do I process the onError and onCompleted ? for each async call\n"
      },
      {
        "user": "hamidp",
        "created_at": "2014-12-09T13:06:38Z",
        "body": "Those will propagate down the chain. If any Observable emits an error it will be sent down to your subscriber.\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2014-12-09T17:54:06Z",
        "body": "If you want to handle errors for each call you put the `onErrorResumeNext` or similar handlers on each of the async calls. \n\n``` java\nasyncCallForDogIds(..)\n    .map(this::readId)\n    .flatMap(dogId -> {\n             return someAsyncCallForOneDogId(id, ..)\n                             .onErrorResumeNext(errorHandlingHere)\n    })\n    .map(this::readFromSomeMessage2)\n```\n"
      },
      {
        "user": "thierryler",
        "created_at": "2014-12-10T09:47:01Z",
        "body": "Thx for those great answers.\n\nI'm getting a little confused. What about if my first call returns an object that contains many ids, and I have to process the second call for each id :\n\nI was thinking about something like this :\n\n```\nfinal Observable<RxMessage<String>> observable1 = doCallThatReturnBoxes(userId);\n\nBox box = null;\nobservable1\n    .flatMap(new Func1<RxMessage<String>, Observable<RxMessage<String>>>() \n        public Observable<RxMessage<String>> call(RxMessage<String> message) {\n            box = readBoxFromMessage(message);\n\n            final List<String> ids = box.getItemIds();\n\n            // Here I need to call doCallThatReturnOneItemDetails for each id\n            // How do I create an Observable from the ids list ?\n\n        }\n        .subscribe(\n            // onNext\n            (RxMessage<String> message) -> {\n                final BoxItem boxItem = readBoxItemFromMessage(message);\n\n                box.getItems.add(boxItem);\n            },\n\n            // onError\n            (Throwable err) -> error(err, response, resp),\n\n            // onCompleted\n            () -> resume(response, resp)\n        );\n```\n\nAnd if my first call returns a list of boxies ? like this ? \n\n```\nfinal List<Box> boxies = new ArrayList<>();\nobservable1\n    .flatMap(new Func1<RxMessage<String>, Observable<RxMessage<String>>>() \n        public Observable<RxMessage<String>> call(RxMessage<String> message) {\n            final Box box = readBoxFromMessage(message);\n            boxies.add(box);\n\n            final List<String> ids = box.getItemIds();\n\n            // Here I need to call doCallThatReturnOneItemDetails for each id\n            // How do I create an Observable from the ids list ?\n\n        }\n        .subscribe(\n            // onNext\n            (RxMessage<String> message) -> {\n                final BoxItem boxItem = readBoxItemFromMessage(message);\n\n                // Here how to specify the good box ?\n                box.getItems.add(boxItem);\n            },\n\n            // onError\n            (Throwable err) -> error(err, response, resp),\n\n            // onCompleted\n            () -> resume(response, resp)\n        );\n\n```\n\nHow do I associate the item details with the good box ?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-11T14:14:42Z",
        "body": "I'm closing this due to inactivity. If you have further questions, please don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 1741,
    "title": "Observer.empty() vs EmptyObserver",
    "created_at": "2014-10-10T03:29:51Z",
    "closed_at": "2014-10-10T03:44:23Z",
    "labels": [
      "Enhancement",
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/1741",
    "body": "The behavior between Observer.empty() and `EmptyObserver` is different. This seems confusing.\n\n`EmptyObserver` swallows errors whereas `Observer.empty()` will throw `OnErrorNotImplementedException` if `onError` is invoked.\n\nThoughts on what we should do?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/1741/comments",
    "author": "benjchristensen",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2014-10-10T03:36:29Z",
        "body": "I think deleting `EmptyObserver` is the best approach. It serves no value.\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2014-10-10T03:45:45Z",
        "body": "I deleted `EmptyObserver` and updated the `Observers.empty()` javadocs to be clear that it throws `OnErrorNotImplementedException`. \n\nIf someone wants to swallow errors they need to actively code for that. RxJava will not swallow errors itself.\n"
      },
      {
        "user": "headinthebox",
        "created_at": "2014-10-10T05:49:12Z",
        "body": "Like!\n"
      }
    ]
  },
  {
    "number": 1636,
    "title": "How to properly terminal Observable sequences",
    "created_at": "2014-08-27T21:59:04Z",
    "closed_at": "2014-08-29T23:00:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/1636",
    "body": "``` java\nObservable<Boolean> obs1;\nObservable<Boolean> obs2;\n\nresult = obs1\n.flatmap(value -> {\n   if (value) {\n      // terminate result observable\n      // the only way i see right now is to do\n      BehaviorSubject<Boolean> terminator = BehaviorSubject.create();\n      terminator.onNext(new TerminateException());\n      return terminator;\n   } else {\n       return obs2;\n   }\n});\n\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/1636/comments",
    "author": "buildbreaker",
    "comments": [
      {
        "user": "headinthebox",
        "created_at": "2014-08-27T22:17:48Z",
        "body": "You just return `Observable.empty()` if you want to terminate successfully, or `Observable.error(new TerminateException())` if you want to terminate unsuccessfully (probably not). \n"
      },
      {
        "user": "buildbreaker",
        "created_at": "2014-08-28T17:33:41Z",
        "body": "Thank you for your response @headinthebox!\n\nI believe I do want to terminate unsuccessfully since at the end of my flatmap as I would like to have an action regardless of what value was originally. I actually have a flatmap chain of similar flatmaps that was mentioned above:\n\n``` java\nresult = obs1\n.flatmap(value -> {\n   if (value) {\n      return Observable.error(new TerminateException());\n   } else {\n       return obs2;\n   }\n})\n.flatmap(value -> {\n  if (value) {\n    return Observable.from(new Object());\n  } else {\n    return Observable.error(newTerminateException());\n  }\n})\n.doOnEach( value -> {\n  // Always do something\n})\n.subscribe(...); \n```\n\nI have tried and having an Observable.error(new TerminateException()) works for this case but I'm not sure if this is the best way to go about the problem.\n"
      },
      {
        "user": "headinthebox",
        "created_at": "2014-08-28T17:42:23Z",
        "body": "It is the best way; if you find yourself using subjects, typically you are _wrong_. \n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2014-08-28T19:08:34Z",
        "body": "You can also use `takeUntil` or `takeWhile` to terminate the source when a condition or event occurs instead of forcing an artificial `onError` event. In other words, unsubscribing is the \"clean shutdown\" approach and `takeUntil` and `takeWhile` are typical approaches to shutting down.\n"
      },
      {
        "user": "buildbreaker",
        "created_at": "2014-08-29T16:42:24Z",
        "body": "@headinthebox\nI finally switched to using Observable.empty() and it has worked for me!\n\n@benjchristensen \nUnfortunately, \"takeWhile\" doesn't terminate on false for me. I needed to terminate on false.\n"
      }
    ]
  },
  {
    "number": 1539,
    "title": "Need help with composition of several observables.",
    "created_at": "2014-08-01T02:38:04Z",
    "closed_at": "2014-08-01T04:47:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/1539",
    "body": "``` java\nObservable<String> observable1;\nObservable<Boolean> observable2;\nObservable<Void> observable3;\n```\n\nI need to to create observable3 that will produce values on every change of observable1 when observable2 last value is True.\n\nWill appreciate any help.\n\n(By the way, I'm using Java 6.)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/1539/comments",
    "author": "buildbreaker",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2014-08-01T04:12:10Z",
        "body": "do you mean latest value of obs2 is true or last value?\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2014-08-01T04:20:22Z",
        "body": "Here are some options that might get you moving in the direction you want:\n\n``` java\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\n\npublic class CombineLatestAndFilter {\n\n    public static void main(String[] args) {\n        Observable<String> observable1 = Observable.interval(1, TimeUnit.MILLISECONDS).map(i -> \"value_\" + i);\n        Observable<Boolean> observable2 = Observable.interval(7, TimeUnit.MILLISECONDS).map(i -> i % 2 == 0 ? true : false).startWith(false);\n\n        /*\n         * Solution A\n         * \n         * This works as long as you're okay if the last observable1 value is emitted when observable2 changes from false to true\n         */\n        Observable<String> observable3a = Observable.combineLatest(observable1, observable2, (o1, o2) -> {\n            System.out.println(\"        o1: \" + o1 + \" o2: \" + o2);\n            return new Object[] { o1, o2 }; // poor excuse for a tuple\n            }).filter(oo -> (Boolean) oo[1]).map(oo -> (String) oo[0]);\n\n        /*\n         * Solution B\n         * \n         * This adds 'distinctUntilChanged' so that it won't emit during the change from false -> true.\n         * However, this means it could also skip values from observable1 if duplicates are expected, so it can only be used if\n         * the values are expected to be unique.\n         */\n        Observable<String> observable3b = Observable.combineLatest(observable1, observable2, (o1, o2) -> {\n            System.out.println(\"        o1: \" + o1 + \" o2: \" + o2);\n            return new Object[] { o1, o2 }; // poor excuse for a tuple\n            }).distinctUntilChanged(oo -> (String) oo[0]).filter(oo -> (Boolean) oo[1]).map(oo -> (String) oo[0]);\n\n        /*\n         * Solution C\n         * \n         * This gets more complicated by zipping observable1 with a range to index it so we can de-dupe on the index number\n         * instead of the value in case we need to handle possible duplicate values and solution A above is not okay.\n         */\n        Observable<Object[]> observable1withIndex = observable1.zipWith(Observable.range(0, Integer.MAX_VALUE), (v, i) -> new Object[] { v, i });\n        Observable<String> observable3c = Observable.combineLatest(observable1withIndex, observable2, (o1, o2) -> {\n            System.out.println(\"        o1: \" + o1[0] + \" index: \" + o1[1] + \" o2: \" + o2);\n            return new Object[] { o1[1], \"repetitive-value\", o2 }; // poor excuse for a tuple\n            }).distinctUntilChanged(oo -> oo[0]).filter(oo -> (Boolean) oo[2]).map(oo -> (String) oo[1]);\n\n        observable3a.take(20).toBlocking().forEach(System.out::println);\n        //        observable3b.take(20).toBlocking().forEach(System.out::println);\n        //        observable3c.take(20).toBlocking().forEach(System.out::println);\n    }\n}\n```\n"
      },
      {
        "user": "buildbreaker",
        "created_at": "2014-08-01T04:47:17Z",
        "body": "@benjchristensen Thank you for your quick response. This was very helpful!\n\nI believe the solution A you've suggested will suffice with solving my problem.\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2014-08-01T04:49:53Z",
        "body": "Great, good luck!\n"
      }
    ]
  },
  {
    "number": 1424,
    "title": "Custom subject that stores last value but emits it only once",
    "created_at": "2014-07-11T02:23:59Z",
    "closed_at": "2014-10-07T22:33:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/1424",
    "body": "I will try to describe this by example. \n\nThere is a rest operation that provides observable result:\n\nCustomSubject<TResult> result = restClient.doSmth();\n// subject could be hidden for consumer and represented as observable.\n\nView needs to react on result of this rest call once.\n\nView subscribes on this subject when it resumes and unsubscribe when it pauses. \n\nView could be paused while rest call is in progress and resumed after rest call was performed.\n\nI need to reflect result in the view when it resumed. But I only need to react on it once. So if user will pause and resume app again I won't react on rest call result again.\n\nAny suggestions how to build such subject?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/1424/comments",
    "author": "lexer",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2014-07-11T07:02:42Z",
        "body": "Hi. I'd use some message identity, let's say an always incrementing long as part of the result of restClient. Then, the client would keep a lastSeen value and drop anything that's lower or equal. This way, you can use a (possibly bounded) ReplaySubject.\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2014-08-08T20:39:21Z",
        "body": "Why do you need it to only emit once? Are you subscribing to it more than once?\n\nFor example, \n\n``` java\nObservable o = restObservable.cache();\no.subscribe(); // eagerly kick it off\n// time passes\no.subscribe(mySubscriber);\n// you now receive the value if it's there, or wait for the callback\n```\n\nSince it's a REST call, it would be a new `Observable` each time anyways, so I don't understand the need to have more than above.\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2014-10-07T22:33:48Z",
        "body": "Closing out as stale.\n"
      }
    ]
  },
  {
    "number": 7,
    "title": "Observable: abstract or final",
    "created_at": "2013-01-16T21:40:25Z",
    "closed_at": "2013-01-23T21:07:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7",
    "body": "There is discussion about whether Observable should be a \"final class\" and only be usable via Observable.create(Func) or whether we should leave it as abstract.\n\nDiscuss and decide ...\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7/comments",
    "author": "benjchristensen",
    "comments": [
      {
        "user": "abersnaze",
        "created_at": "2013-01-16T22:58:52Z",
        "body": "I vote not final.\nIf it were final then it would be impossible to extend Observable to add operators and still interoperate with other code that uses Observable.\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2013-01-16T23:13:42Z",
        "body": "Agreed\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2013-01-23T21:07:01Z",
        "body": "We have decided to not make it final.\n\nBut we also have changed it from being abstract to a normal concrete class.\n\nThe 'subscribe' implementation is passed in via a protected constructor or using Observable.create(Func1)\n"
      }
    ]
  }
]