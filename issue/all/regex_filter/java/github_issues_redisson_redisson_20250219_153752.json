[
  {
    "number": 6443,
    "title": "Order Guarantees with the Async API",
    "created_at": "2025-02-18T17:09:07Z",
    "closed_at": "2025-02-19T09:56:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6443",
    "body": "Hey,\nI’m wondering if the following example guarantees execution order:\n```\nRBucket<String> bucket = redisson.getBucket(\"key\");\n\nbucket.setAsync(\"value\"); // Fire SET without waiting\nRFuture<String> future = bucket.getAsync(); \n\nfuture.thenAccept(System.out::println); \n```\nDoes SET always execute before GET, even though SET wasn’t explicitly awaited?\n\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6443/comments",
    "author": "barshaul",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2025-02-19T08:58:52Z",
        "body": "Hi,\n\nNo, due to the asynchronous nature of the connections handling. \n\nTo achieve that you can create a Redisson instance with `сonnectionPoolSize = 1`."
      },
      {
        "user": "barshaul",
        "created_at": "2025-02-19T09:56:35Z",
        "body": "Ack, that answers my question. Thanks! "
      },
      {
        "user": "mrniko",
        "created_at": "2025-02-19T10:50:04Z",
        "body": "@barshaul \n\nTo achieve that you can create a Redisson instance with `сonnectionPoolSize = 1`"
      }
    ]
  },
  {
    "number": 6419,
    "title": "batch delete: What is the difference between 'RBatch.execute delete keys' and 'Keys.delete keys'",
    "created_at": "2025-02-05T04:16:17Z",
    "closed_at": "2025-02-17T05:50:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6419",
    "body": "I know how RBatch works: In default mode, store batched invocations in memory on Redisson side and execute them on Redis.\nBut I don't know how 'keys.delete keys' works.\nWhat's the difference between them?\n\n```java\n        RBatch batch = redissonClient.createBatch();\n        for (String key : keys) {\n            batch.getBucket(key).deleteAsync();\n        }\n        List<?> responses = batch.execute().getResponses();\n```\n```java\n        long deleteCount = redissonClient.getKeys().delete(keys);\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6419/comments",
    "author": "extraSix",
    "comments": [
      {
        "user": "lyrric",
        "created_at": "2025-02-06T07:37:37Z",
        "body": "`  long deleteCount = redissonClient.getKeys().delete(keys);` using one command like `del key1 key2 key3`\n```  RBatch batch = redissonClient.createBatch();\n        for (String key : keys) {\n            batch.getBucket(key).deleteAsync();\n        }\n        List<?> responses = batch.execute().getResponses();``` i think it would using multi commands, like `del key1; del key2;`\n"
      },
      {
        "user": "mrniko",
        "created_at": "2025-02-17T05:50:33Z",
        "body": "getKeys().delete(keys); uses a single command in non-clustered mode, whereas for cluster mode this command is sent to all master nodes."
      }
    ]
  },
  {
    "number": 6315,
    "title": "Redisson is shutdown",
    "created_at": "2024-12-04T02:54:58Z",
    "closed_at": "2024-12-04T09:40:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6315",
    "body": "### Redisson Version\r\n3.13.2\r\n\r\n### What is the Actual behavior?\r\nan error is reported by refreshing the local cache through Redis when the k8s pod is destroyed\r\n\r\n### Redisson configuration\r\n\r\n\r\n    @Bean\r\n    public StringRedisTemplate stringRedisTemplateMenu() {\r\n        StringRedisTemplate template = new StringRedisTemplate();\r\n        template.setConnectionFactory(redissonMenuConnectionFactory());\r\n        return template;\r\n    }\r\n    @Bean\r\n    public RedisConnectionFactory redissonMenuConnectionFactory() {\r\n        return new RedissonConnectionFactory(redissonMenu());\r\n    }\r\n    @Bean(destroyMethod = \"shutdown\")\r\n    public RedissonClient redissonMenu() {\r\n        if (StringUtils.isBlank(redissonMenuProperties.getSingleServerConfig().getPassword())) {\r\n            redissonMenuProperties.getSingleServerConfig().setPassword(null);\r\n        }\r\n        Config config = null;\r\n        try {\r\n            config = Config.fromJSON(JSON.toJSONString(redissonMenuProperties));\r\n        } catch (Exception e) {\r\n            log.error(\"spring.redisson-menu 配置异常:{}\", e.getMessage(), e);\r\n            throw new BaseBizException(BaseErrorEnum.UNKNOW_SYSTEM_ERROR, \"spring.redisson-menu 配置读取异常\");\r\n        }\r\n        config.setCodec(new org.redisson.client.codec.StringCodec());\r\n        return Redisson.create(config);\r\n    }\r\n\r\n### Additional information\r\n`nested exception is org.redisson.RedissonShutdownException: Redisson is shutdown org.springframework.dao.InvalidDataAccessApiUsageException: Redisson is shutdown; nested exception is org.redisson.RedissonShutdownException: Redisson is shutdown\\n\\tat org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:48)\\n\\tat org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:35)\\n\\tat org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:44)\\n\\tat org.redisson.spring.data.connection.RedissonConnection.transform(RedissonConnection.java:217)\\n\\tat org.redisson.spring.data.connection.RedissonConnection.syncFuture(RedissonConnection.java:212)\\n\\tat org.redisson.spring.data.connection.RedissonConnection.sync(RedissonConnection.java:378)\\n\\tat org.redisson.spring.data.connection.RedissonConnection.read(RedissonConnection.java:759)\\n\\tat org.redisson.spring.data.connection.RedissonConnection.get(RedissonConnection.java:493)\\n\\tat org.springframework.data.redis.connection.DefaultStringRedisConnection.get(DefaultStringRedisConnection.java:404)\\n\\tat org.springframework.data.redis.core.DefaultValueOperations$1.inRedis(DefaultValueOperations.java:57)\\n\\tat org.springframework.data.redis.core.AbstractOperations$ValueDeserializingRedisCallback.doInRedis(AbstractOperations.java:60)\\n\\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:228)\\n\\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:188)\\n\\tat org.springframework.data.redis.core.AbstractOperations.execute(AbstractOperations.java:96)\\n\\tat org.springframework.data.redis.core.DefaultValueOperations.get(DefaultValueOperations.java:53)\\n ...`\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6315/comments",
    "author": "LHH7049",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-12-04T06:30:24Z",
        "body": "This is an expected behavior since pod is shutdown."
      },
      {
        "user": "LHH7049",
        "created_at": "2024-12-04T09:40:48Z",
        "body": "> This is an expected behavior since pod is shutdown.\r\n\r\nfine, thanks"
      }
    ]
  },
  {
    "number": 6306,
    "title": "Some version conflict issues asked",
    "created_at": "2024-11-28T09:28:49Z",
    "closed_at": "2024-11-29T07:42:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6306",
    "body": "My jdk version is 1.8.241, spring boot version is 2.6.6, and redisson-spring-boot-starter version is 3.38.1. The production boot was successful. But once you access redis through redisson, java.lang.NoClassDefFoundError appears: Could not initialize class org. Redisson. Spring.. The data connection. RedissonConnection, want to ask is how to return a responsibility? I checked the version documentation and found that I need to upgrade to spring boot3.x.Can I fix this problem without upgrading the spring boot version? Because 3.38.1 has some features that will be used",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6306/comments",
    "author": "Noel443",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-11-28T09:31:07Z",
        "body": "you need to exclude redisson-spring-data-xx dependency from redisson-spring-boot-starter and add redisson-spring-data-26"
      }
    ]
  },
  {
    "number": 6305,
    "title": "How to get/delete all the semaphores which I have created?",
    "created_at": "2024-11-27T12:22:56Z",
    "closed_at": "2024-12-30T17:16:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6305",
    "body": "I have created a bunch of semaphores with a prefix. I want to fetch/clear all of them at once. is this possible?\r\nCurrently I can fetch/remove only the semaphores whose keys are available using Redisson.getSemaphore() method.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6305/comments",
    "author": "Shashi-KumarP",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-12-30T17:16:51Z",
        "body": "Try `getKeys().deleteByPattern()` method"
      }
    ]
  },
  {
    "number": 6285,
    "title": "lock key with : character",
    "created_at": "2024-11-16T06:10:03Z",
    "closed_at": "2025-01-07T07:14:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6285",
    "body": "**Redisson version**\r\n3.17.4\r\n\r\n**code**\r\n`RLock lock = redissonClient.getLock(\"xxxx:xxxxx\");`\r\n\r\n**throw exception**\r\nWRONGTYPE Operation against a key holding the wrong kind of value. channel: [xxxx] command: (EVAL), promise: java.util.concurrent.CompletableFuture@4518f29f[Not completed], params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('**hincrby**', KEYS[1], ARGV[2], 1); redis.call(..., 1, xxxx, 20000, f3cd76a5-06cd-4c5c-8e85-41106bc62f8f:334]\r\n\r\nI can't modify the key, How can I resolve this issue?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6285/comments",
    "author": "LovelyCodeBear",
    "comments": [
      {
        "user": "lyrric",
        "created_at": "2024-11-18T07:38:49Z",
        "body": "Maybe the key of lock exist in redis.\r\nChange another key or delete the key in redis."
      },
      {
        "user": "mrniko",
        "created_at": "2025-01-07T07:14:53Z",
        "body": "Unable to reproduce it with the test below:\r\n\r\n```java\r\n        Lock lock = redisson.getLock(\"lock:test\");\r\n        lock.lock();\r\n        lock.unlock();\r\n\r\n        lock.lock();\r\n        lock.unlock();\r\n```"
      }
    ]
  },
  {
    "number": 6260,
    "title": "update redisson from 3.11.2 to 3.17.5",
    "created_at": "2024-11-02T06:18:12Z",
    "closed_at": "2024-11-05T12:49:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6260",
    "body": "Our production project has been using Redisson version 3.11.2. Recently, we plan to upgrade Redisson to version 3.17.5. However, we noticed that the pingTimeout, failedAttempts, and reconnectionTimeout configuration nodes in our redisson.yaml seem to have changed. We have the following questions:\r\n\r\nIs failedAttempts replaced by failedSlaveCheckInterval?\r\nIs reconnectionTimeout replaced by failedSlaveReconnectionInterval?\r\nWe couldn’t find a corresponding replacement property for pingTimeout. Is there an alternative property for this, or can it be removed directly?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6260/comments",
    "author": "rxb1992",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-11-05T12:49:59Z",
        "body": "`failedAttempts` has been replaced by `failedSlaveNodeDetector`\r\n`reconnectionTimeout` has been replaced by `failedSlaveReconnectionInterval`\r\n\r\n`pingTimeout` was a ping timeout used in `Node.ping() and `Node.pingAll()` operations. Removed without replacement."
      }
    ]
  },
  {
    "number": 6247,
    "title": "Redisson reconnection error ?",
    "created_at": "2024-10-25T01:33:44Z",
    "closed_at": "2024-12-18T06:35:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6247",
    "body": "k8s cluster deployment  java service（user Redisson connection redis cluster），has 6 nodes ，this 6 nodes tarted successfully and run for some time ,suddenly two nodes connection error，other 4 nodes are running properly. this two nodes reconnection fail.\r\nerror mesage as follow:\r\n`\r\nCaused by: org.redisson.client.RedisNodeNotFoundException: Node: NodeSource [slot=392, addr=redis://10.233.66.20:6379, redisClient=null, redirect=MOVED, entry=null] hasn't been discovered yet. Increase value of retryAttempts and/or retryInterval settings.\r\n`\r\n\r\n**redisson config as follow:**\r\n\r\n`\r\n\r\n   @Primary\r\n   @Bean\r\n    private Redisson create(){\r\n        log.info(\"Redisson init start...\");\r\n\r\n        List<String> clusterNodes = new ArrayList<>();\r\n        for (int i = 0; i < redisProps.getCluster().getNodes().size(); i++) {\r\n            clusterNodes.add(\"redis://\" + redisProps.getCluster().getNodes().get(i));\r\n        }\r\n        Config config = new Config();\r\n        ClusterServersConfig clusterServersConfig = config.setConnectionListener(new RedissonConnectionListener())\r\n                .useClusterServers()\r\n                .setReadMode(ReadMode.MASTER)\r\n                .setSubscriptionMode(SubscriptionMode.MASTER)\r\n                .addNodeAddress(clusterNodes.toArray(new String[clusterNodes.size()]));\r\n        clusterServersConfig.setPassword(redisProps.getPassword())\r\n                .setTimeout(redisProps.getTimeout());\r\n        return (Redisson) Redisson.create(config);\r\n    }\r\n`\r\n\r\n`\r\n@Data\r\n@Component\r\n@ConfigurationProperties(prefix = \"spring.redis\")\r\npublic class RedisProps {\r\n    /**\r\n     * timeout\r\n     */\r\n    private Integer timeout;\r\n    /**\r\n     * password\r\n     */\r\n    private String password;\r\n    /**\r\n     * cluster nodes\r\n     */\r\n    private Cluster cluster;\r\n\r\n    public static class Cluster {\r\n        private List<String> nodes;\r\n\r\n        public List<String> getNodes() {\r\n            return nodes;\r\n        }\r\n\r\n        public void setNodes(List<String> nodes) {\r\n            this.nodes = nodes;\r\n        }\r\n    }\r\n}\r\n`\r\n\r\n**yml as follow:**\r\n\r\n`\r\nspring:\r\n  cache:\r\n    type: redis\r\n  redis:\r\n    cluster:\r\n      nodes:  ${REDIS_CLUSTER}\r\n    timeout: 15000\r\n`",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6247/comments",
    "author": "Breathtak",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-11-01T10:31:03Z",
        "body": "Can you set `trace` logging level for `org.redisson` package and share output since the application start moment?"
      }
    ]
  },
  {
    "number": 6243,
    "title": "Client unable to discover new slaves after node type upgrade",
    "created_at": "2024-10-22T19:01:37Z",
    "closed_at": "2024-12-30T17:20:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6243",
    "body": "Our cache cluster has 1 shard with 2 read replicas.\r\n\r\nExpected behavior\r\nWhen the Redis cluster node type got upgraded in aws(elastic cache for redis), it will update the cluster with new node type and IPs. After the replacement client should be able to discover the new nodes(master and slave) again.\r\n\r\nActual behavior\r\nRedisson client is unable to discover the new slave nodes. And it is still trying to connect to old read replicas.\r\n\r\nWe are seeing below logs in output-\r\n```\r\nAddress: <IP Address of Old Read Replica>:<Redis Port>\r\nCommand execution timeout (1000ms) for command: PING, Redis client: [addr=rediss://<IP Address of Old Read Replica>:<Redis Port>]\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6243/comments",
    "author": "Gaurang-nits",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-10-23T07:34:51Z",
        "body": "Which Redisson version?\r\nCan you share the logs with `trace` logging level for `org.redisson` from application start moment till the failover?"
      },
      {
        "user": "Gaurang-nits",
        "created_at": "2024-10-23T23:30:15Z",
        "body": "@mrniko We are using 3.37.0 version of Redisson.\r\nWe didn't had `trace` logging level for `org.redisson` enabled from application so unfortunately we won't have the log from the live environment. \r\nI am trying to check if i can reproduce the same in development or local env. "
      },
      {
        "user": "Gaurang-nits",
        "created_at": "2024-10-24T18:29:44Z",
        "body": "I was not able to reproduce in Dev environment. Also no logs published in trace mode for `org.redisson`."
      },
      {
        "user": "mrniko",
        "created_at": "2024-11-01T10:33:06Z",
        "body": "> Also no logs published in trace mode for org.redisson.\r\n\r\nYou need to make sure that logger is setup properly"
      },
      {
        "user": "mrniko",
        "created_at": "2024-12-23T07:30:33Z",
        "body": "Any update?"
      }
    ]
  },
  {
    "number": 6214,
    "title": "Redisson master slave mode and kubernetes headless service for slaves",
    "created_at": "2024-10-05T15:12:24Z",
    "closed_at": "2024-11-01T12:07:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6214",
    "body": "Should it be possible to use kubernetes headless service for slave connections when using Redisson in master slave mode?\r\n\r\nI tried that but I see all the time this kind of logs:\r\n\r\n05.10.2024 18:05:59.274 [INFO] org.redisson.connection.DNSMonitor Detected DNS change. Slave redis-replicas.test.svc.cluster.local has changed ip from x.x.x.x to y.y.y.y\r\n05.10.2024 18:05:59.284 [INFO] org.redisson.connection.ConnectionsHolder 1 connections initialized for redis-replicas.test.svc.cluster.local/y.y.y.y:6379]\r\n05.10.2024 18:05:59.538 [INFO] org.redisson.connection.ConnectionsHolder 24 connections initialized for redis-replicas.test.svc.cluster.local/y.y.y.y:6379]\r\n\r\nThe ips in the log messages  are the actual pod ips, which you get from the headless service. \r\n\r\nThe configuration for the slaveAddresses:\r\n\"slaveAddresses\": [\r\n      \"rediss://redis-replicas.test.svc.cluster.local:6379\"\r\n    ],",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6214/comments",
    "author": "jhamalainen",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-11-01T12:10:08Z",
        "body": "You need to upgrade to 3.32.0 version or higher"
      }
    ]
  },
  {
    "number": 6211,
    "title": "How to turn on logging",
    "created_at": "2024-10-03T07:12:31Z",
    "closed_at": "2024-11-01T12:06:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6211",
    "body": "I'm using RedissonClient in my application programmatically. How can i turn on some logging for Redisson Client, so that i can know the real reason behind InterruptedException.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6211/comments",
    "author": "srijithunni7182",
    "comments": [
      {
        "user": "arulned",
        "created_at": "2024-10-12T18:50:09Z",
        "body": "@srijithunni7182  Did you try enabling DEBUG level on 'org.redisson'?"
      }
    ]
  },
  {
    "number": 6208,
    "title": "Redisson Stop Connecting to a node after unable to connect , Even if Node is discoverable after some time still it throws Node Not found exctpion",
    "created_at": "2024-09-30T09:16:27Z",
    "closed_at": "2025-01-29T06:38:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6208",
    "body": "I have faced an issue with redisson (in Redis Cluster). Below is the Scenario faced\r\nApplication was running fine , and at a point of time we got Unable to connect exception to one of the nodes in the cluster (All other nodes was getting connected and queries were getting processed) . Below was the exception i have received\r\n\r\n`org.redisson.client.RedisTimeoutException: Unable to acquire connection! java.util.concurrent.CompletableFuture@4730b985[Completed exceptionally]Increase connection pool size or timeout. Node source: NodeSource [slot=13523, addr=null, redisClient=null, redirect=null, entry=null], command: (EVAL), params: [local v = redis.call('hget', KEYS[1], ARGV[1]); redis.call('hset', KEYS[1], ARGV[1], ARGV[2]); return v, 1, ST:_09281418_a116e1c0-9788-4ecc-becb-92bd9f2d5612, PooledUnsafeDirectByteBuf(ridx: 0, widx: 47, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 37, cap: 256)] after 0 retry attempts\r\n`\r\n ```\r\n-  RequestId:11281418425138804_1 Exception:\r\norg.redisson.client.RedisNodeNotFoundException: Node: NodeSource [slot=11581, addr=redis://ip6:6379, redisClient=null, redirect=MOVED, entry=null] hasn't been discovered yet. Increase value of retryAttempts and/or retryInterval settings.\r\n \r\n```\r\nWe can see this pattern repeating for 30 requests immediately after this  post which only RedisNodeNotFoundException happend.  And all this issue was happening only to a particular node in cluster , Other node request were getting processed without any issues. This issue got fixed immediately after restarting the application \r\n\r\nIs there any configuration which will say like if there is x connection failures continously then do not connect to the node again ?\r\n\r\nBelow is my redisson configuration\r\nclusterServersConfig:\r\n  idleConnectionTimeout: 30000\r\n  connectTimeout: 1000\r\n  timeout: 600\r\n  retryAttempts: 0\r\n  retryInterval: 0\r\n  password:xxxxxxx\r\n  loadBalancer:\r\n    class: org.redisson.connection.balancer.RoundRobinLoadBalancer\r\n  slaveConnectionMinimumIdleSize: 24\r\n  slaveConnectionPoolSize: 200\r\n  masterConnectionMinimumIdleSize: 24\r\n  masterConnectionPoolSize: 200\r\n  readMode: MASTER\r\n  nodeAddresses:\r\n          - redis://ip1:6379\r\n          - redis://ip2:6380\r\n          - redis://ip3:6379\r\n          - redis://ip4:6380\r\n          - redis://ip5:6379\r\n          - redis://ip6:6380\r\n  scanInterval: 1000\r\n  pingConnectionInterval: 30000",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6208/comments",
    "author": "rahulkrishnan244",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-10-01T08:22:15Z",
        "body": "I need Redisson logs\r\n\r\n> after this post which only RedisNodeNotFoundException happend\r\n\r\nThis happens after failover"
      },
      {
        "user": "mrniko",
        "created_at": "2024-10-01T08:25:14Z",
        "body": "You can try to define `failedSlaveNodeDetector = new FailedConnectionDetector(180000).` Redis slave node will be disconnected if it has ongoing connection errors in `checkInterval` time interval."
      }
    ]
  },
  {
    "number": 6207,
    "title": "High Connection Count After Migrating to Redisson",
    "created_at": "2024-09-30T03:26:03Z",
    "closed_at": "2024-11-01T12:10:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6207",
    "body": "Hi @mrniko,\r\n\r\nChecking on my redis connection metric, I found out that there's high spike on connection metric to my redis.\r\nBefore migrating, usually there's only 40-50 active connection, but now it can ranged from 500-1000 connections.\r\n\r\nI used default configuration for connection pool size and there's no change on my backend APIs logic.\r\nThere's no issue regarding connection pool yet, but should i be worried ?\r\nIs there any adjustment i shoud do?\r\n\r\nThank you. ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6207/comments",
    "author": "grhamuda",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-09-30T17:39:36Z",
        "body": "> Before migrating\r\n\r\nFrom which to which version?"
      },
      {
        "user": "grhamuda",
        "created_at": "2024-10-01T03:02:20Z",
        "body": "> From which to which version?\r\n\r\nmigrating from lettuce to redisson 3.34.1 @mrniko "
      },
      {
        "user": "mrniko",
        "created_at": "2024-10-01T06:24:46Z",
        "body": "Redisson default configuration is different. You need to revise it."
      },
      {
        "user": "grhamuda",
        "created_at": "2024-10-03T02:35:47Z",
        "body": "this is my redisson config\r\n\r\n```\r\n@Data\r\n@Component\r\n@ConfigurationProperties(prefix = \"redisson\")\r\npublic class RedissonProperties {\r\n  private int timeout = 5000;\r\n  private int connectTimeout = 5000;\r\n  private int retryAttempts = 1;\r\n  private int pingConnectionInterval = 30000;\r\n}\r\n```\r\n\r\n```\r\nprivate Config getRedissonConfig(String host) {\r\n    // Create Redisson Client Configuration\r\n    Config config = new Config();\r\n    config.useClusterServers()\r\n        .addNodeAddress(REDIS_PROTOCOL + host + REDIS_PORT)\r\n        .setReadMode(ReadMode.MASTER_SLAVE)\r\n        .setLoadBalancer(new RoundRobinLoadBalancer())\r\n        .setTimeout(redissonProperties.getTimeout())\r\n        .setConnectTimeout(redissonProperties.getConnectTimeout())\r\n        .setRetryAttempts(redissonProperties.getRetryAttempts())\r\n        .setPingConnectionInterval(redissonProperties.getPingConnectionInterval());\r\n    return config;\r\n  }\r\n```\r\n\r\nafaik default master and slave connection pool is only 24, but why on my metric it shown >500 ?\r\ncould you please give me guidance to what configuration i should revisit?\r\n\r\nthank you"
      },
      {
        "user": "grhamuda",
        "created_at": "2024-10-03T07:15:41Z",
        "body": "might be related with #4803 "
      },
      {
        "user": "mrniko",
        "created_at": "2024-10-03T12:14:41Z",
        "body": "default value for `slaveConnectionPoolSize` and `masterConnectionPoolSize` is 64. try to reduce these values to 24."
      }
    ]
  },
  {
    "number": 6156,
    "title": "sharing article about using local cache with Spring and redisson community",
    "created_at": "2024-09-11T13:25:30Z",
    "closed_at": "2024-11-01T12:15:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6156",
    "body": "Hi Redisson Team \r\nFirst thanks a lot for this amazing library \r\nI found a way to use local cache with Spring and redisson community \r\nis there any issue if I publish an article about that?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6156/comments",
    "author": "nawwardev",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-09-11T15:21:54Z",
        "body": "Hi,\r\n\r\nThank you! No problem if you publish an article."
      }
    ]
  },
  {
    "number": 6138,
    "title": "How to confg global NameMapper?",
    "created_at": "2024-09-02T07:50:35Z",
    "closed_at": "2024-11-01T12:35:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6138",
    "body": null,
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6138/comments",
    "author": "LuCas-MoringStar",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-11-01T12:34:49Z",
        "body": "```java\r\n        config.useSingleServer()\r\n                .setNameMapper(new NameMapper() {\r\n                    @Override\r\n                    public String map(String name) {\r\n                        return name + \":suffix:\";\r\n                    }\r\n\r\n                    @Override\r\n                    public String unmap(String name) {\r\n                        return name.replace(\":suffix:\", \"\");\r\n                    }\r\n                });\r\n```"
      }
    ]
  },
  {
    "number": 6129,
    "title": "After the redisson version was upgraded, the memory usage became 2-3 times the original",
    "created_at": "2024-08-29T02:23:51Z",
    "closed_at": "2024-09-05T09:07:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6129",
    "body": "Redisson version was upgraded from 3.11.1 to 3.14.0. Why did the memory usage become 2-3 times the original? After analysis, it was found that the default encoding changed from FstCodec to MarshallingCodec. Is this related?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6129/comments",
    "author": "bitkbitk",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-08-29T03:56:29Z",
        "body": "It might be. Both are buggy. Did you try Kryo5Codec?"
      },
      {
        "user": "bitkbitk",
        "created_at": "2024-08-29T05:19:54Z",
        "body": "> Both are buggy\r\n\r\nYou mean the official recommendation is to use Kryo5Codec？"
      },
      {
        "user": "mrniko",
        "created_at": "2024-08-30T06:23:27Z",
        "body": "Yes"
      }
    ]
  },
  {
    "number": 6126,
    "title": "com.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: 89",
    "created_at": "2024-08-27T06:43:58Z",
    "closed_at": "2024-08-30T02:39:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6126",
    "body": "When executing the command to obtain value in bulk, an error occurs.\r\n\r\nException in thread \"main\" org.redisson.client.RedisException: Unexpected exception while processing command\r\n\tat org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:369)\r\n\tat org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:182)\r\n\tat org.redisson.command.CommandBatchService.execute(CommandBatchService.java:260)\r\n\tat org.redisson.RedissonBatch.execute(RedissonBatch.java:233)\r\n\tat ValueTest.main(ValueTest.java:70)\r\nCaused by: com.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: 89\r\n\tat com.esotericsoftware.kryo.util.DefaultClassResolver.readClass(DefaultClassResolver.java:159)\r\n\tat com.esotericsoftware.kryo.Kryo.readClass(Kryo.java:758)\r\n\tat com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:869)\r\n\tat org.redisson.codec.Kryo5Codec$4.decode(Kryo5Codec.java:153)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:442)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:292)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:230)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:146)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:508)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n\r\nHere's the testing code.\r\n\r\n\r\n`      RBatch batchValue = redisClient.createBatch();\r\n        for (Key key : keyList) {\r\n            String keyType = key.getKeyType();\r\n            String keyStr = key.getKey();\r\n            if (keyType.equals(KeyTypeEnum.STRING.getRTypeName())) {\r\n                batchValue.getBucket(keyStr).getAsync();\r\n            }\r\n            if (keyType.equals(KeyTypeEnum.SET.getRTypeName())) {\r\n                batchValue.getSet(keyStr).readAllAsync();\r\n            }\r\n            if (keyType.equals(KeyTypeEnum.ZSET.getRTypeName())) {\r\n                batchValue.getScoredSortedSet(keyStr).valueRangeAsync(0, -1);\r\n            }\r\n            if (keyType.equals(KeyTypeEnum.HASH.getRTypeName())) {\r\n                batchValue.getMap(keyStr).readAllEntrySetAsync();\r\n            }\r\n            if (keyType.equals(KeyTypeEnum.LIST.getRTypeName())) {\r\n                batchValue.getList(keyStr).readAllAsync();\r\n            }\r\n            if (keyType.equals(KeyTypeEnum.NONE.getRTypeName())) {\r\n                batchValue.getBucket(keyStr).getAsync();\r\n            }\r\n        }\r\n\r\n        BatchResult<?> batchResult = batchValue.execute();`\r\nWe are seeing this exceptions lately for Redisson 3.34.1.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6126/comments",
    "author": "Wanan520521",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-08-27T06:48:41Z",
        "body": "Which Redisson version did you use before?"
      },
      {
        "user": "Wanan520521",
        "created_at": "2024-08-27T06:52:21Z",
        "body": "> Which Redisson version did you use before?\r\nAlso 3.34.1, this is a new feature we have developed\r\n"
      }
    ]
  },
  {
    "number": 6117,
    "title": "Caused by: org.redisson.client.RedisException: java.lang.InterruptedException",
    "created_at": "2024-08-23T08:50:08Z",
    "closed_at": "2024-09-12T07:42:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6117",
    "body": "`Caused by: org.redisson.client.RedisException: java.lang.InterruptedException | at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:113) | at org.redisson.RedissonObject.get(RedissonObject.java:83) | at org.redisson.RedissonObject.isExists(RedissonObject.java:234) | at com.x.x.x.caching.facade.impl.RedisElastiCache.getFromCache(RedisElastiCache.java:103) | ... 195 more | Caused by: java.lang.InterruptedException | at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:347) | at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1908) | at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:109) `\r\n\r\nWe are seeing this exceptions multiple times lately for Redisson 3.18\r\nWhich metrics we should be checking & how to fix this issue ?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6117/comments",
    "author": "harshalthakre",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-08-23T09:42:44Z",
        "body": "Something is interrupting the caller thread."
      },
      {
        "user": "harshalthakre",
        "created_at": "2024-08-26T07:29:51Z",
        "body": "Is this a issue within Redisson client ? or from the caller ?\r\nAny lead on path forward to solve this ?\r\n\r\nI was thinking if increasing netty threads would solve this problem. Thoughts ? "
      },
      {
        "user": "mrniko",
        "created_at": "2024-08-26T07:58:03Z",
        "body": "Can you share a full stacktrace?"
      },
      {
        "user": "harshalthakre",
        "created_at": "2024-09-12T07:44:03Z",
        "body": "Hey Can we get more info on this before resolving issue ?"
      }
    ]
  },
  {
    "number": 6112,
    "title": "With redisson latest version 3.35.0 quarkus application is not starting",
    "created_at": "2024-08-22T12:36:52Z",
    "closed_at": "2024-08-22T14:08:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6112",
    "body": "Hi @mrniko \r\nRedis version : 7.x.x\r\nRedisson version: 3.35.0\r\nRedisson configuration: \r\n`quarkus.redisson.codec=com.xxx.xxx.CustomLZ4Codec\r\nquarkus.redisson.address-resolver-group-factory=com.xxx.xxx..redisson.CustomizedSequentialDnsAddressResolverFactory\r\nquarkus.redisson.cluster-servers-config.node-addresses=redis://redis:6379`\r\n\r\njboss.marshalling version:\r\n`\r\norg.jboss.marshalling:jboss-marshalling:2.1.4.Final\r\n`\r\n\r\nError:\r\n`\r\nFailed to start application (with profile [dev]): java.lang.RuntimeException: Failed to start quarkus\r\n\tat io.quarkus.runner.ApplicationImpl.doStart(Unknown Source)\r\n\tat io.quarkus.runtime.Application.start(Application.java:101)\r\n\tat io.quarkus.runtime.ApplicationLifecycleManager.run(ApplicationLifecycleManager.java:111)\r\n\tat io.quarkus.runtime.Quarkus.run(Quarkus.java:71)\r\n\tat io.quarkus.runtime.Quarkus.run(Quarkus.java:44)\r\n\tat io.quarkus.runtime.Quarkus.run(Quarkus.java:124)\r\n\tat io.quarkus.runner.GeneratedMain.main(Unknown Source)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\r\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\r\n\tat io.quarkus.runner.bootstrap.StartupActionImpl$1.run(StartupActionImpl.java:113)\r\n\tat java.base/java.lang.Thread.run(Thread.java:833)\r\nCaused by: java.lang.RuntimeException: Error injecting com.logicmonitor.metricsprocessor.cache.CompanyCache com.logicmonitor.metricsprocessor.metricsinput.kafka.ApacheClientKafkaNormalInput.companyCache\r\n\tat com.logicmonitor.metricsprocessor.metricsinput.kafka.ApacheClientKafkaNormalInput_Bean.doCreate(Unknown Source)\r\n\tat com.logicmonitor.metricsprocessor.metricsinput.kafka.ApacheClientKafkaNormalInput_Bean.create(Unknown Source)\r\n\tat com.logicmonitor.metricsprocessor.metricsinput.kafka.ApacheClientKafkaNormalInput_Bean.create(Unknown Source)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext.createInstanceHandle(AbstractSharedContext.java:119)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext$1.get(AbstractSharedContext.java:38)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext$1.get(AbstractSharedContext.java:35)\r\n\tat io.quarkus.arc.generator.Default_jakarta_enterprise_context_ApplicationScoped_ContextInstances.c7(Unknown Source)\r\n\tat io.quarkus.arc.generator.Default_jakarta_enterprise_context_ApplicationScoped_ContextInstances.computeIfAbsent(Unknown Source)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext.get(AbstractSharedContext.java:35)\r\n\tat com.logicmonitor.metricsprocessor.metricsinput.kafka.ApacheClientKafkaNormalInput_Observer_startup_g2WpEPLXLEAkABvQonJZZIL4LXg.notify(Unknown Source)\r\nCaused by: java.lang.RuntimeException: Error injecting com.logicmonitor.metricsprocessor.cache.CompanyCache com.logicmonitor.metricsprocessor.metricsinput.kafka.ApacheClientKafkaNormalInput.companyCache\r\n\r\n\tat io.quarkus.arc.impl.EventImpl$Notifier.notifyObservers(EventImpl.java:351)\r\n\tat io.quarkus.arc.impl.EventImpl$Notifier.notify(EventImpl.java:333)\r\n\tat io.quarkus.arc.impl.EventImpl.fire(EventImpl.java:80)\r\n\tat io.quarkus.arc.runtime.ArcRecorder.fireLifecycleEvent(ArcRecorder.java:155)\r\n\tat io.quarkus.arc.runtime.ArcRecorder.handleLifecycleEvents(ArcRecorder.java:106)\r\n\tat io.quarkus.deployment.steps.LifecycleEventsBuildStep$startupEvent1144526294.deploy_0(Unknown Source)\r\n\tat io.quarkus.deployment.steps.LifecycleEventsBuildStep$startupEvent1144526294.deploy(Unknown Source)\r\n\t... 13 more\r\nCaused by: java.lang.RuntimeException: Error injecting com.logicmonitor.metricsprocessor.metricsbackup.DataBackupUtility com.logicmonitor.metricsprocessor.cache.impl.CompanyCacheImpl.dataBackupUtility\r\n\tat com.logicmonitor.metricsprocessor.cache.impl.CompanyCacheImpl_Bean.doCreate(Unknown Source)\r\nCaused by: java.lang.RuntimeException: Error injecting com.logicmonitor.metricsprocessor.metricsbackup.DataBackupUtility com.logicmonitor.metricsprocessor.cache.impl.CompanyCacheImpl.dataBackupUtility\r\n\r\n\tat com.logicmonitor.metricsprocessor.cache.impl.CompanyCacheImpl_Bean.create(Unknown Source)\r\n\tat com.logicmonitor.metricsprocessor.cache.impl.CompanyCacheImpl_Bean.create(Unknown Source)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext.createInstanceHandle(AbstractSharedContext.java:119)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext$1.get(AbstractSharedContext.java:38)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext$1.get(AbstractSharedContext.java:35)\r\n\tat io.quarkus.arc.impl.LazyValue.get(LazyValue.java:32)\r\n\tat io.quarkus.arc.impl.ComputingCache.computeIfAbsent(ComputingCache.java:69)\r\n\tat io.quarkus.arc.impl.ComputingCacheContextInstances.computeIfAbsent(ComputingCacheContextInstances.java:19)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext.get(AbstractSharedContext.java:35)\r\n\tat com.logicmonitor.metricsprocessor.cache.impl.CompanyCacheImpl_Bean.get(Unknown Source)\r\n\tat com.logicmonitor.metricsprocessor.cache.impl.CompanyCacheImpl_Bean.get(Unknown Source)\r\n\t... 30 more\r\nCaused by: java.lang.RuntimeException: Error injecting org.redisson.api.RedissonClient com.logicmonitor.metricsprocessor.metricsbackup.DataBackupUtility.redisClient\r\n\tat com.logicmonitor.metricsprocessor.metricsbackup.DataBackupUtility_Bean.doCreate(Unknown Source)\r\n\tat com.logicmonitor.metricsprocessor.metricsbackup.DataBackupUtility_Bean.create(Unknown Source)\r\nCaused by: java.lang.RuntimeException: Error injecting org.redisson.api.RedissonClient com.logicmonitor.metricsprocessor.metricsbackup.DataBackupUtility.redisClient\r\n\r\n\tat com.logicmonitor.metricsprocessor.metricsbackup.DataBackupUtility_Bean.create(Unknown Source)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext.createInstanceHandle(AbstractSharedContext.java:119)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext$1.get(AbstractSharedContext.java:38)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext$1.get(AbstractSharedContext.java:35)\r\n\tat io.quarkus.arc.impl.LazyValue.get(LazyValue.java:32)\r\n\tat io.quarkus.arc.impl.ComputingCache.computeIfAbsent(ComputingCache.java:69)\r\n\tat io.quarkus.arc.impl.ComputingCacheContextInstances.computeIfAbsent(ComputingCacheContextInstances.java:19)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext.get(AbstractSharedContext.java:35)\r\n\tat com.logicmonitor.metricsprocessor.metricsbackup.DataBackupUtility_Bean.get(Unknown Source)\r\n\tat com.logicmonitor.metricsprocessor.metricsbackup.DataBackupUtility_Bean.get(Unknown Source)\r\n\t... 42 more\r\nCaused by: jakarta.enterprise.inject.CreationException: com.fasterxml.jackson.databind.exc.ValueInstantiationException: Cannot construct instance of `com.logicmonitor.metricsprocessor.metricsbackup.CustomLZ4Codec`, problem: RIVER\r\n at [Source: (StringReader); line: 2, column: 75] (through reference chain: org.redisson.config.Config[\"codec\"])\r\n\tat io.quarkus.redisson.client.runtime.RedissonClientProducer_ProducerMethod_create_VH06TQCYPIlKWuSlr9UZ1TMEbDQ_Bean.create(Unknown Source)\r\nCaused by: jakarta.enterprise.inject.CreationException: com.fasterxml.jackson.databind.exc.ValueInstantiationException: Cannot construct instance of `com.logicmonitor.metricsprocessor.metricsbackup.CustomLZ4Codec`, problem: RIVER\r\n\r\n\tat io.quarkus.redisson.client.runtime.RedissonClientProducer_ProducerMethod_create_VH06TQCYPIlKWuSlr9UZ1TMEbDQ_Bean.create(Unknown Source)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext.createInstanceHandle(AbstractSharedContext.java:119)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext$1.get(AbstractSharedContext.java:38)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext$1.get(AbstractSharedContext.java:35)\r\n\tat io.quarkus.arc.impl.LazyValue.get(LazyValue.java:32)\r\n\tat io.quarkus.arc.impl.ComputingCache.computeIfAbsent(ComputingCache.java:69)\r\n\tat io.quarkus.arc.impl.ComputingCacheContextInstances.computeIfAbsent(ComputingCacheContextInstances.java:19)\r\n\tat io.quarkus.arc.impl.AbstractSharedContext.get(AbstractSharedContext.java:35)\r\n\tat io.quarkus.redisson.client.runtime.RedissonClientProducer_ProducerMethod_create_VH06TQCYPIlKWuSlr9UZ1TMEbDQ_Bean.get(Unknown Source)\r\n\tat io.quarkus.redisson.client.runtime.RedissonClientProducer_ProducerMethod_create_VH06TQCYPIlKWuSlr9UZ1TMEbDQ_Bean.get(Unknown Source)\r\n\t... 54 more\r\nCaused by: com.fasterxml.jackson.databind.exc.ValueInstantiationException: Cannot construct instance of `com.logicmonitor.metricsprocessor.metricsbackup.CustomLZ4Codec`, problem: RIVER\r\n at [Source: (StringReader); line: 2, column: 75] (through reference chain: org.redisson.config.Config[\"codec\"])\r\n\tat com.fasterxml.jackson.databind.exc.ValueInstantiationException.from(ValueInstantiationException.java:47)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.instantiationException(DeserializationContext.java:2014)\r\nCaused by: com.fasterxml.jackson.databind.exc.ValueInstantiationException: Cannot construct instance of `com.logicmonitor.metricsprocessor.metricsbackup.CustomLZ4Codec`, problem: RIVER\r\n\r\n\tat com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.wrapAsJsonMappingException(StdValueInstantiator.java:598)\r\n\tat com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.rewrapCtorProblem(StdValueInstantiator.java:621)\r\n\tat com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createUsingDefault(StdValueInstantiator.java:280)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:298)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:177)\r\n\tat com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase._deserializeWithNativeTypeId(TypeDeserializerBase.java:269)\r\n\tat com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:106)\r\n\tat com.fasterxml.jackson.databind.deser.AbstractDeserializer.deserializeWithType(AbstractDeserializer.java:263)\r\n\tat com.fasterxml.jackson.databind.deser.impl.MethodProperty.deserializeAndSet(MethodProperty.java:138)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:310)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:177)\r\n\tat com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:342)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4905)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3848)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3816)\r\n\tat org.redisson.config.ConfigSupport.fromYAML(ConfigSupport.java:159)\r\n\tat io.quarkus.redisson.client.runtime.RedissonClientProducer.create(RedissonClientProducer.java:85)\r\n\tat io.quarkus.redisson.client.runtime.RedissonClientProducer_ProducerMethod_create_VH06TQCYPIlKWuSlr9UZ1TMEbDQ_Bean.doCreate(Unknown Source)\r\n\t... 65 more\r\nCaused by: java.lang.IllegalArgumentException: RIVER\r\n\tat org.redisson.codec.MarshallingCodec.<init>(MarshallingCodec.java:222)\r\n\tat org.redisson.codec.MarshallingCodec.<init>(MarshallingCodec.java:195)\r\nCaused by: java.lang.IllegalArgumentException: RIVER\r\n\r\n\tat org.redisson.codec.MarshallingCodec.<init>(MarshallingCodec.java:191)\r\n\tat com.logicmonitor.metricsprocessor.metricsbackup.CustomLZ4Codec.<init>(CustomLZ4Codec.java:34)\r\n\tat java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\r\n\tat java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)\r\n\tat java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\r\n\tat java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)\r\n\tat java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)\r\n\tat com.fasterxml.jackson.databind.introspect.AnnotatedConstructor.call(AnnotatedConstructor.java:121)\r\n\tat com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createUsingDefault(StdValueInstantiator.java:278)\r\n\t... 80 more\r\n`\r\n\r\nCustomLZ4Codec looks like:\r\n\r\n`\r\npublic class CustomLZ4Codec extends BaseCodec {\r\n\r\n    private static final int DECOMPRESSION_HEADER_SIZE = Integer.SIZE / 8;\r\n    private final LZ4Factory factory = LZ4Factory.nativeInstance();\r\n\r\n    private final Codec innerCodec;\r\n\r\n    public CustomLZ4Codec() {\r\n        this(new MarshallingCodec());\r\n    }\r\n\r\n    public CustomLZ4Codec(Codec innerCodec) {\r\n        this.innerCodec = innerCodec;\r\n    }\r\n\r\n    public CustomLZ4Codec(ClassLoader classLoader) {\r\n        this(new MarshallingCodec(classLoader));\r\n    }\r\n\r\n    public CustomLZ4Codec(ClassLoader classLoader, CustomLZ4Codec codec) throws ReflectiveOperationException {\r\n        this(copy(classLoader, codec.innerCodec));\r\n    }\r\n\r\n    private final Decoder<Object> decoder = new Decoder<Object>() {\r\n        @Override\r\n        public Object decode(ByteBuf buf, State state) throws IOException {\r\n            int decompressSize = buf.readInt();\r\n            ByteBuf out = ByteBufAllocator.DEFAULT.buffer(decompressSize);\r\n            try {\r\n                LZ4SafeDecompressor decompressor = factory.safeDecompressor();\r\n                ByteBuffer outBuffer = out.internalNioBuffer(out.writerIndex(), out.writableBytes());\r\n                int pos = outBuffer.position();\r\n                decompressor.decompress(buf.internalNioBuffer(buf.readerIndex(), buf.readableBytes()), outBuffer);\r\n                int compressedLength = outBuffer.position() - pos;\r\n                out.writerIndex(compressedLength);\r\n                return innerCodec.getValueDecoder().decode(out, state);\r\n            } finally {\r\n                out.release();\r\n            }\r\n        }\r\n    };\r\n\r\n    private final Encoder encoder = new Encoder() {\r\n\r\n        @Override\r\n        public ByteBuf encode(Object in) throws IOException {\r\n            ByteBuf bytes = null;\r\n            try {\r\n                LZ4Compressor compressor = factory.fastCompressor();\r\n                bytes = innerCodec.getValueEncoder().encode(in);\r\n                ByteBuffer srcBuf = bytes.internalNioBuffer(bytes.readerIndex(), bytes.readableBytes());\r\n\r\n                int outMaxLength = compressor.maxCompressedLength(bytes.readableBytes());\r\n                ByteBuf out = ByteBufAllocator.DEFAULT.buffer(outMaxLength + DECOMPRESSION_HEADER_SIZE);\r\n                out.writeInt(bytes.readableBytes());\r\n                ByteBuffer outBuf = out.internalNioBuffer(out.writerIndex(), out.writableBytes());\r\n                int pos = outBuf.position();\r\n\r\n                compressor.compress(srcBuf, outBuf);\r\n\r\n                int compressedLength = outBuf.position() - pos;\r\n                out.writerIndex(out.writerIndex() + compressedLength);\r\n                return out;\r\n            } finally {\r\n                if (bytes != null) {\r\n                    bytes.release();\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    @Override\r\n    public Decoder<Object> getValueDecoder() {\r\n        return decoder;\r\n    }\r\n\r\n    @Override\r\n    public Encoder getValueEncoder() {\r\n        return encoder;\r\n    }\r\n\r\n}\r\n`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6112/comments",
    "author": "subhanus",
    "comments": [
      {
        "user": "subhanus",
        "created_at": "2024-08-22T12:38:16Z",
        "body": "It was working fine with redisson version \r\n`org.redisson:redisson-quarkus-30:3.27.2`"
      },
      {
        "user": "subhanus",
        "created_at": "2024-08-22T14:08:40Z",
        "body": "We found the issue:\r\nSince 3.29.0 version redisson has removed the `org.jboss.marshalling.*` from the Jar artifact.\r\nWe will need to explicitly add them in our project."
      },
      {
        "user": "mrniko",
        "created_at": "2024-08-22T14:49:58Z",
        "body": "This codec has been deprecated since version 3.19.0"
      },
      {
        "user": "subhanus",
        "created_at": "2024-08-22T14:57:48Z",
        "body": "@mrniko \r\nYes we understand that, but since we already have encrypted data using marshalling codec and there is not option to decrypt data written in redis  using the newer KryoCodec/Kryo5Codec/LZ4CodecV2 we had to stick with deprecated codec.\r\n\r\nIf you can suggest/implement some mechanisms to migrate the data it will be very helpful."
      },
      {
        "user": "mrniko",
        "created_at": "2024-08-22T15:20:57Z",
        "body": "The only solution here is a migration like in any other database."
      }
    ]
  },
  {
    "number": 6088,
    "title": "What's the difference of LocalCachedMap between open source version and pro version?",
    "created_at": "2024-08-15T02:11:58Z",
    "closed_at": "2024-08-17T12:07:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6088",
    "body": "As it said only pro version support ultra-fast read/write, what does it mean？",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6088/comments",
    "author": "jaggerwang",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-08-15T05:44:02Z",
        "body": "Another Redis commands processing engine is used"
      },
      {
        "user": "jaggerwang",
        "created_at": "2024-08-16T01:05:54Z",
        "body": "In the same usage scenario, how many times is the performance of the Pro version compared to the open source version? The open source version does indeed use local caching to accelerate, right."
      },
      {
        "user": "mrniko",
        "created_at": "2024-08-17T12:07:33Z",
        "body": "> how many times is the performance of the Pro version compared to the open source version?\r\n2 or 4. depending on the use case.\r\n\r\n> The open source version does indeed use local caching to accelerate, right.\r\nRight, but Redis commands processing acceleration isn't available in the open-source version."
      }
    ]
  },
  {
    "number": 6070,
    "title": "fix wiki 14. Integration with frameworks (markdown)",
    "created_at": "2024-08-01T07:51:07Z",
    "closed_at": "2024-12-23T10:37:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6070",
    "body": "Fix a syntax issue in LocalCachedMapOptions setup.\r\nCurrent Code\r\n\r\n```java\r\nLocalCachedMapOptions options = LocalCachedMapOptions.defaults()\r\n                .evictionPolicy(EvictionPolicy.LFU)\r\n                .timeToLive(48, TimeUnit.MINUTES)\r\n                .maxIdle(24, TimeUnit.MINUTES);\r\n                .cacheSize(1000);\r\n```\r\n\r\n\r\nFix\r\nUpdate the code to correctly chain the .cacheSize(1000) method:\r\n```java\r\nLocalCachedMapOptions options = LocalCachedMapOptions.defaults()\r\n                .evictionPolicy(EvictionPolicy.LFU)\r\n                .timeToLive(48, TimeUnit.MINUTES)\r\n                .maxIdle(24, TimeUnit.MINUTES)\r\n                .cacheSize(1000);\r\n```\r\nplease，thank you\r\nBy the way, why can’t I submit changes to the wiki?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6070/comments",
    "author": "jieyangxchen",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-12-23T10:37:06Z",
        "body": "Fixed. Thanks for report"
      }
    ]
  },
  {
    "number": 6062,
    "title": "Are RMap `getMap`, `putAll`, `put`, `remove` operations atomic & threadsafe?",
    "created_at": "2024-07-26T12:03:45Z",
    "closed_at": "2024-07-27T15:26:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6062",
    "body": "Hello,\r\nWe are using Redisson library for Redis and we are utilizing Hash data structure to store an object with different properties.  \r\nWe have 2 Kafka listeners, which listen for incoming messages, and store the data in a Redis hash.  \r\nThe question here being, are the  `getMap`, `putAll`, `put`, `remove` operations atomic & threadsafe?  \r\nHere are code snippets which illustrate what we are doing.\r\n\r\nFirst listener:\r\n```\r\n@KafkaListener(topics = \"${kafka.consumer.topic1}\")\r\npublic void topic1Listener(String message) {\r\n    try {\r\n        RandomObject randomObject = objectMapper.readValue(message, RandomObject.class);\r\n        boolean exists = redissonClient.getMap(randomObject.getUserId().toString()).isExists();\r\n        Map<String, String> fillMap = new HashMap<>();\r\n        fillMap.put(\"property1\", \"property1-value\");\r\n        fillMap.put(\"property2\", \"property1-value\");\r\n\r\n        if (!exists) {\r\n            List<RandomItem> randomItems = restClient.getRandomItems(randomObject.getUserId());\r\n            for (RandomItem randomItem : randomItems) {\r\n                fillMap.put(randomItem.getId(), objectMapper.writeValueAsString(randomItem));\r\n            }\r\n        }\r\n        redissonClient.getMap(randomObject.getUserId().toString(), StringCodec.INSTANCE).putAll(fillMap);\r\n\r\n        final RMap<String, String> map = redissonClient.getMap(randomObject.getUserId().toString(), StringCodec.INSTANCE);\r\n        List<RandomItem> randomItems = new ArrayList<>();\r\n\r\n        for (Object key : map.keySet()) {\r\n            if (!key.equals(\"property1\") && !key.equals(\"property2\")) {\r\n                RandomItem randomItem = objectMapper.readValue(map.get(key), RandomItem.class);\r\n                randomItems.add(randomItem);\r\n            }\r\n        }\r\n        RandomObject1 randomObject1 = objectMapper.readValue(map.get(\"property1\"), RandomObject1.class);\r\n        RandomObject2 randomObject2 = RandomObject2.builder()\r\n                .items(randomItems)\r\n                .property2(objectMapper.readValue(map.get(\"property2\"), new TypeReference<>() {}))\r\n                .property1(randomObject1)\r\n                .build();\r\n        kafkaTemplate.send(outputTopic, randomObject.getUserId().toString(), objectMapper.writeValueAsString(randomObject2));\r\n    } catch (Exception e) {\r\n        System.out.println(e.getMessage());\r\n    }\r\n}\r\n```\r\n\r\nSecondlistener:\r\n```\r\n@KafkaListener(topics = \"${kafka.consumer.topic2}\")\r\npublic void topic2Listener(ConsumerRecord<String, String> consumerRecord) {\r\n    try {\r\n        String userId = consumerRecord.key().split(\"-\")[0];\r\n        boolean exists = redissonClient.getMap(userId).isExists();\r\n        if (!exists) {\r\n            Long numericUserId = Long.parseLong(userId);\r\n            Map<String, String> fillMap = new HashMap<>();\r\n            UserDTO userDto = userClient.getUserById(numericUserId);\r\n            List<RandomItem> randomItems = restClient.getRandomItems(numericUserId);\r\n            for (RandomItem randomItem : randomItems) {\r\n                fillMap.put(randomItem.getId(), objectMapper.writeValueAsString(randomItem));\r\n            }\r\n            List<RandomItem2> randomItems2 = restClient2.getRandomItems(numericUserId);\r\n            fillMap.put(\"property1\", objectMapper.writeValueAsString(userDto));\r\n            fillMap.put(\"property2\", objectMapper.writeValueAsString(randomItems2));\r\n            redissonClient.getMap(userId, StringCodec.INSTANCE).putAll(fillMap);\r\n        }\r\n\r\n        if (consumerRecord.value() == null) {\r\n            redissonClient.getMap(userId, StringCodec.INSTANCE).remove(consumerRecord.key());\r\n        } else {\r\n            redissonClient.getMap(userId, StringCodec.INSTANCE).put(consumerRecord.key(), consumerRecord.value());\r\n        }\r\n\r\n        final RMap<String, String> map = redissonClient.getMap(userId, StringCodec.INSTANCE);\r\n        List<RandomItem> randomItems = new ArrayList<>();\r\n\r\n        for (Object key : map.keySet()) {\r\n            if (!key.equals(\"property1\") && !key.equals(\"property2\")) {\r\n                RandomItem randomItem = objectMapper.readValue(map.get(key), RandomItem.class);\r\n                randomItems.add(randomItem);\r\n            }\r\n        }\r\n\r\n        RandomObject1 randomObject1 = objectMapper.readValue(map.get(\"property1\"), RandomObject1.class);\r\n        RandomObject2 randomObject2 = RandomObject2.builder()\r\n                .items(randomItems)\r\n                .property2(objectMapper.readValue(map.get(\"property2\"), new TypeReference<>() {}))\r\n                .property1(randomObject1)\r\n                .build();\r\n        kafkaTemplate.send(outputTopic, userId, objectMapper.writeValueAsString(randomObject2));\r\n    } catch (Exception e) {\r\n        System.out.println(e.getMessage());\r\n    }\r\n}\r\n```\r\n\r\nIs this the right way to do the hash operations in Redisson and are they thread safe/atomic?\r\n`redissonClient.getMap(userId, StringCodec.INSTANCE)`\r\n`redissonClient.getMap(userId, StringCodec.INSTANCE).remove(consumerRecord.key());`\r\n`redissonClient.getMap(randomObject.getUserId().toString(), StringCodec.INSTANCE).putAll(fillMap);`\r\n\r\nAnd after that do the reading in order to send the data downstream via Kafka\r\n`final RMap<String, String> map = redissonClient.getMap(userId, StringCodec.INSTANCE);`",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6062/comments",
    "author": "AleksandarTokarev",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-07-27T15:26:50Z",
        "body": "Yes, they are."
      },
      {
        "user": "AleksandarTokarev",
        "created_at": "2024-07-27T15:51:10Z",
        "body": "@mrniko \r\nAm i using the API in a proper way?\r\n` redissonClient.getMap(randomObject.getUserId().toString(), StringCodec.INSTANCE).putAll(fillMap);`\r\nor i should be using it by getting the reference once and doing the `put`, `remove`, `putAll`, `readAllMap` operations by first getting the RMap, then using them? (as shown below)\r\n```\r\nfinal RMap<String, String> map = redissonClient.getMap(userId, StringCodec.INSTANCE);\r\nmap.putAll(fillMap);\r\nmap.remove(\"key\");\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2024-09-02T15:54:04Z",
        "body": "@AleksandarTokarev \r\n\r\nThere is no difference, but I would prefer the example you provided. "
      }
    ]
  },
  {
    "number": 6027,
    "title": "SET in pipeline don't return result of an operation",
    "created_at": "2024-07-11T11:33:16Z",
    "closed_at": "2024-07-11T13:32:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6027",
    "body": "Why it's not possible to change commandsToRemove in RedissonConnection? Why SET operation in this list?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6027/comments",
    "author": "Borodalum",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-07-11T11:55:58Z",
        "body": "Since it's a void command"
      },
      {
        "user": "Borodalum",
        "created_at": "2024-07-11T11:57:55Z",
        "body": "> Since it's a void command\r\n\r\nBut why it's don't return boolean with true if ok and false if it's not?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-07-11T13:08:30Z",
        "body": "the exception is returned in case of error"
      }
    ]
  },
  {
    "number": 6018,
    "title": "\"Unable to connect\" message after Connection created - part 2",
    "created_at": "2024-07-08T13:22:08Z",
    "closed_at": "2024-07-22T06:40:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6018",
    "body": "Hi, I'm using redis to cache object in spring boot reactive env with mongodb in java 17.\r\nwhen I try to test I start the container \r\n```java\r\n@TestConfiguration\r\n@Testcontainers\r\n@RunWith(SpringJUnit4ClassRunner.class)\r\npublic class RedisTestContainerConfig {\r\n    @Container\r\n    public static GenericContainer redisContainer = new GenericContainer(DockerImageName.parse(\"redis:7.2.5\"))\r\n        .withExposedPorts(6379);\r\n    static {\r\n        redisContainer.start();\r\n    }\r\n}\r\n```\r\nand I read in log \r\n```\r\norg.redisson.client.RedisConnection      : Connection created [addr=redis://127.0.0.1:6379]\r\n```\r\nbut after, when the test start \r\n```\r\n org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 127.0.0.1/127.0.0.1:6379\r\n```\r\nI thought that the problem was the lazyInitialization and I'm trying to set it true adding lazyInitialization: true in redisson configuration\r\n```\r\n{\r\n    \"singleServerConfig\": {\r\n        \"address\": \"redis://127.0.0.1:6379\"\r\n    },\r\n    \"lazyInitialization\": true\r\n}\r\n```\r\nbut the log report error parsing configuration. \r\n\r\nHere the log without lazyInitialization\r\n\r\n```\r\n2024-07-08 10:00:49.479 DEBUG 46878 --- [isson-netty-2-2] org.redisson.client.RedisConnection      : Connection created [addr=redis://127.0.0.1:6379]\r\n2024-07-08 10:00:49.479 DEBUG 46878 --- [isson-netty-2-4] org.redisson.client.RedisConnection      : Connection created [addr=redis://127.0.0.1:6379]\r\n2024-07-08 10:00:49.479 DEBUG 46878 --- [isson-netty-2-3] org.redisson.client.RedisConnection      : Connection created [addr=redis://127.0.0.1:6379]\r\n2024-07-08 10:00:49.489  WARN 46878 --- [           main] r.c.GenericReactiveWebApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'redisConfig' defined in file [/home/alobefaro/Perso/development/service/target/classes/com/telit/glpe/service/config/RedisConfig.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'redissonReactive' defined in class path resource [org/redisson/spring/starter/RedissonAutoConfigurationV2.class]: Unsatisfied dependency expressed through method 'redissonReactive' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redisson' defined in class path resource [org/redisson/spring/starter/RedissonAutoConfigurationV2.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redisson' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 127.0.0.1/127.0.0.1:6379\r\n2024-07-08 10:00:49.527 ERROR 46878 --- [           main] o.s.boot.SpringApplication               : Application run failed\r\n.....................\r\nCaused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redisson' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 127.0.0.1/127.0.0.1:6379\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:648)\r\n\t... 118 common frames omitted\r\nCaused by: org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 127.0.0.1/127.0.0.1:6379\r\n\tat org.redisson.connection.pool.ConnectionPool.lambda$createConnection$1(ConnectionPool.java:153)\r\n\tat java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863)\r\n\tat java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841)\r\n\tat java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)\r\n\tat java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)\r\n\tat org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:317)\r\n\tat org.redisson.connection.pool.ConnectionPool.lambda$createConnection$7(ConnectionPool.java:276)\r\n\tat java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863)\r\n\tat java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841)\r\n\tat java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)\r\n\tat java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)\r\n\tat org.redisson.client.RedisClient$1$2.run(RedisClient.java:235)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.runTask(AbstractEventExecutor.java:173)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:166)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:470)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:569)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:840)\r\nCaused by: java.util.concurrent.CompletionException: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: 127.0.0.1/127.0.0.1:6379\r\n\tat java.base/java.util.concurrent.CompletableFuture.encodeRelay(CompletableFuture.java:368)\r\n\tat java.base/java.util.concurrent.CompletableFuture.completeRelay(CompletableFuture.java:377)\r\n\tat java.base/java.util.concurrent.CompletableFuture$UniRelay.tryFire(CompletableFuture.java:1097)\r\n\t... 11 common frames omitted\r\nCaused by: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: 127.0.0.1/127.0.0.1:6379\r\nCaused by: java.net.ConnectException: Connection refused\r\n\tat java.base/sun.nio.ch.Net.pollConnect(Native Method)\r\n\tat java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)\r\n\tat java.base/sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:946)\r\n\tat io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:337)\r\n\tat io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:776)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:840)\r\n```\r\n\r\n\r\nHow can I set it? \r\nAnd do you think it is the right way to fix my problem?\r\n\r\nthanks",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6018/comments",
    "author": "antoniolobefaro",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-07-22T06:40:09Z",
        "body": "`Connection refused: 127.0.0.1/127.0.0.1:6379\r\nCaused by: java.net.ConnectException: Connection refused`\r\n\r\nyou need to check the network connection"
      },
      {
        "user": "mhbahmani",
        "created_at": "2024-07-22T06:46:28Z",
        "body": "Hi,\r\nI have a slightly different issue. In my case, there is no error regarding the connection refused. 10.10.10.43:6379 is a valid address and I can connect to this endpoint with redis-cli. so I'm sure there is no network issue.\r\n\r\nI want to connect to a sentinel, and 10.10.10.43:6379 is a returned redis instance (by sentinels).\r\n\r\nHere is my log, just before the application crashes:\r\n\r\n```\r\n{\"msg\":\"Application run failed Error creating bean with name 'redisCache' defined in URL [jar:nested:/backend/services/test/test.jar/!BOOT-INF/classes/!/company/delive\r\nry/infrastructure/cache/RedisCache.class]: Unsatisfied dependency expressed through constructor parameter 1: Error creating bean with name 'redissonReactive' defined in clas\r\ns path resource [org/redisson/spring/starter/RedissonAutoConfigurationV2.class]: Unsatisfied dependency expressed through method 'redissonReactive' parameter 0: Error creati\r\nng bean with name 'redisson' defined in class path resource [org/redisson/spring/starter/RedissonAutoConfigurationV2.class]: Failed to instantiate [org.redisson.api.Redisson\r\nClient]: Factory method 'redisson' threw exception with message: java.util.concurrent.ExecutionException: org.redisson.client.RedisConnectionException: Unable to connect to \r\nRedis server: 10.10.10.43/10.10.10.43:6379\",\"hostname\":\"test-pod-59dd7f5d7f-82vpn\",\"stacktrace\":\"org.springframework.beans.factory.UnsatisfiedDependencyException\\norg.springfr\r\namework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:798)\\norg.springframework.beans.factory.support.ConstructorResolver.autowireCo\r\nnstructor(ConstructorResolver.java:237)\\norg.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.\r\njava:1355)\\norg.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1192)\\norg.springframewor\r\nk.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:562)\\norg.springframework.beans.factory.support.AbstractAutow\r\nireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:522)\\norg.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanF\r\nactory.java:325)\\norg.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)\\norg.springframework.beans.facto\r\nry.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:323)\\norg.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)\\n\r\norg.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:975)\\norg.springframework.context.support.Abstr\r\nactApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:959)\\norg.springframework.context.support.AbstractApplicationContext.refresh(AbstractAp\r\nplicationContext.java:624)\\norg.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:66)\\norg.sprin\r\ngframework.boot.SpringApplication.refresh(SpringApplication.java:754)\\norg.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456)\\norg.springframe\r\nwork.boot.SpringApplication.run(SpringApplication.java:334)\\norg.springframework.boot.SpringApplication.run(SpringApplication.java:1354)\\norg.springframework.boot.SpringAppl\r\nication.run(SpringApplication.java:1343)\\ncompany.test.TestApplicationKt.main(TestApplication.kt:19)\\njava.base/jdk.internal.reflect.DirectMethodHandleAccessor.inv\r\noke(DirectMethodHandleAccessor.java:103)\\njava.base/java.lang.reflect.Method.invoke(Method.java:580)\\norg.springframework.boot.loader.launch.Launcher.launch(Launcher.java:91\r\n)\\norg.springframework.boot.loader.launch.Launcher.launch(Launcher.java:53)\\norg.springframework.boot.loader.launch.JarLauncher.main(JarLauncher.java:58)\",\"level\":50,\"v\":1,\"\r\nthread_name\":\"main\",\"time\":1721628810140}\r\n```"
      },
      {
        "user": "antoniolobefaro",
        "created_at": "2024-07-22T09:04:39Z",
        "body": "Hi @mrniko ,\r\n\r\nbut before the connection refused I received \r\n\r\n`org.redisson.client.RedisConnection      : Connection created [addr=redis://127.0.0.1:6379]`"
      },
      {
        "user": "mrniko",
        "created_at": "2024-07-22T09:20:10Z",
        "body": "@antoniolobefaro \r\n\r\nThere is might be a connections amount limit"
      }
    ]
  },
  {
    "number": 6004,
    "title": "Lambda task not work  in RExecutorService",
    "created_at": "2024-07-01T08:58:57Z",
    "closed_at": "2024-12-18T06:40:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6004",
    "body": "redisson version is 3.28.0 and redis version is 6.0.9 when i run \r\n\r\n rExecutorService.submit((Runnable & Serializable) () -> {\r\n                logger.info(\"test-1-sleep-\" + j);\r\n            });\r\nit's always report  Error ,how can i deal with this  thank you.\r\n\r\njava.lang.reflect.InvocationTargetException: null\r\n\tat sun.reflect.GeneratedMethodAccessor75.invoke(Unknown Source) ~[na:na]\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_221]\r\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_221]\r\n\tat org.redisson.executor.RedissonExecutorRemoteService.invokeMethod(RedissonExecutorRemoteService.java:106) ~[redisson-3.28.0.jar:3.28.0]\r\n\tat org.redisson.RedissonRemoteService.lambda$executeMethod$14(RedissonRemoteService.java:448) [redisson-3.28.0.jar:3.28.0]\r\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[na:1.8.0_221]\r\n\tat java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:266) ~[na:1.8.0_221]\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java) ~[na:1.8.0_221]\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[na:1.8.0_221]\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[na:1.8.0_221]\r\n\tat java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_221]\r\nCaused by: java.lang.IllegalStateException: Unable to initialize codec with ClassLoader parameter\r\n\tat org.redisson.executor.TasksRunnerService.decode(TasksRunnerService.java:311) ~[redisson-3.28.0.jar:3.28.0]\r\n\tat org.redisson.executor.TasksRunnerService.executeRunnable(TasksRunnerService.java:329) ~[redisson-3.28.0.jar:3.28.0]\r\n\tat org.redisson.executor.TasksRunnerService.executeRunnable(TasksRunnerService.java:349) ~[redisson-3.28.0.jar:3.28.0]\r\n\t... 11 common frames omitted\r\nCaused by: java.io.IOException: unexpected exception type\r\n\tat java.io.ObjectStreamClass.throwMiscException(ObjectStreamClass.java:1736) ~[na:1.8.0_221]\r\n\tat java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1266) ~[na:1.8.0_221]\r\n\tat java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2078) ~[na:1.8.0_221]\r\n\tat java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573) ~[na:1.8.0_221]\r\n\tat java.io.ObjectInputStream.readObject(ObjectInputStream.java:431) ~[na:1.8.0_221]\r\n\tat org.redisson.executor.TasksRunnerService.decode(TasksRunnerService.java:293) ~[redisson-3.28.0.jar:3.28.0]\r\n\t... 13 common frames omitted\r\nCaused by: java.lang.reflect.InvocationTargetException: null\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_221]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_221]\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_221]\r\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_221]\r\n\tat java.lang.invoke.SerializedLambda.readResolve(SerializedLambda.java:230) ~[na:1.8.0_221]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_221]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_221]\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_221]\r\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_221]\r\n\tat java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1260) ~[na:1.8.0_221]\r\n\t... 17 common frames omitted\r\nCaused by: java.lang.IllegalArgumentException: Invalid lambda deserialization\r\n\tat com.redisson.a1分布式执行服务.Test2Controller2.$deserializeLambda$(Test2Controller2.java:27) ~[classes/:na]\r\n\t... 27 common frames omitted",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6004/comments",
    "author": "helensway",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-08-03T04:53:30Z",
        "body": "Unable to reproduce it with the latest version and KryoCodec used as a codec. Which codec do you use?"
      }
    ]
  },
  {
    "number": 5996,
    "title": "How do RSemaphore and RCountDownLatch awaits are implemented",
    "created_at": "2024-06-29T01:23:04Z",
    "closed_at": "2024-07-25T17:27:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5996",
    "body": "How do RSemaphore and RCountDownLatch awaits get to know when the counter is reached to zero. Is it pub/sub in the background or some BLPOP kind of implementation? ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5996/comments",
    "author": "nirupamadsk",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-07-25T17:27:50Z",
        "body": "pubsub is used"
      }
    ]
  },
  {
    "number": 5990,
    "title": "\"Unable to connect\" message after Connection created",
    "created_at": "2024-06-25T08:09:04Z",
    "closed_at": "2024-07-06T06:12:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5990",
    "body": "Hi, I'm using redis to cache object in spring boot reactive env with mongodb in java 17.\r\nwhen I try to test I start the container \r\n```java\r\n@TestConfiguration\r\n@Testcontainers\r\n@RunWith(SpringJUnit4ClassRunner.class)\r\npublic class RedisTestContainerConfig {\r\n    @Container\r\n    public static GenericContainer redisContainer = new GenericContainer(DockerImageName.parse(\"redis:7.2.5\"))\r\n        .withExposedPorts(6379);\r\n    static {\r\n        redisContainer.start();\r\n    }\r\n}\r\n```\r\nand I read in log \r\n```\r\norg.redisson.client.RedisConnection      : Connection created [addr=redis://127.0.0.1:6379]\r\n```\r\nbut after, when the test start \r\n```\r\n org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 127.0.0.1/127.0.0.1:6379\r\n```\r\nI thought that the problem was the lazyInitialization and I'm trying to set it true adding lazyInitialization: true in redisson configuration\r\n```\r\n{\r\n    \"singleServerConfig\": {\r\n        \"address\": \"redis://127.0.0.1:6379\"\r\n    },\r\n    \"lazyInitialization\": true\r\n}\r\n```\r\nbut the log report error parsing configuration. \r\nHow can I set it? \r\nAnd do you think it is the right way to fix my problem?\r\n\r\nthanks",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5990/comments",
    "author": "antoniolobefaro",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-06-26T08:30:30Z",
        "body": "Can you share Redisson log with `trace` logging level for `org.redisson` package?"
      },
      {
        "user": "antoniolobefaro",
        "created_at": "2024-07-08T10:23:17Z",
        "body": "Sorry @mrniko, holidays.\r\n```\r\n2024-07-08 10:00:49.479 DEBUG 46878 --- [isson-netty-2-2] org.redisson.client.RedisConnection      : Connection created [addr=redis://127.0.0.1:6379]\r\n2024-07-08 10:00:49.479 DEBUG 46878 --- [isson-netty-2-4] org.redisson.client.RedisConnection      : Connection created [addr=redis://127.0.0.1:6379]\r\n2024-07-08 10:00:49.479 DEBUG 46878 --- [isson-netty-2-3] org.redisson.client.RedisConnection      : Connection created [addr=redis://127.0.0.1:6379]\r\n2024-07-08 10:00:49.489  WARN 46878 --- [           main] r.c.GenericReactiveWebApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'redisConfig' defined in file [/home/alobefaro/Perso/development/service/target/classes/com/telit/glpe/service/config/RedisConfig.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'redissonReactive' defined in class path resource [org/redisson/spring/starter/RedissonAutoConfigurationV2.class]: Unsatisfied dependency expressed through method 'redissonReactive' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redisson' defined in class path resource [org/redisson/spring/starter/RedissonAutoConfigurationV2.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redisson' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 127.0.0.1/127.0.0.1:6379\r\n2024-07-08 10:00:49.527 ERROR 46878 --- [           main] o.s.boot.SpringApplication               : Application run failed\r\n.....................\r\nCaused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redisson' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 127.0.0.1/127.0.0.1:6379\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:648)\r\n\t... 118 common frames omitted\r\nCaused by: org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 127.0.0.1/127.0.0.1:6379\r\n\tat org.redisson.connection.pool.ConnectionPool.lambda$createConnection$1(ConnectionPool.java:153)\r\n\tat java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863)\r\n\tat java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841)\r\n\tat java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)\r\n\tat java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)\r\n\tat org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:317)\r\n\tat org.redisson.connection.pool.ConnectionPool.lambda$createConnection$7(ConnectionPool.java:276)\r\n\tat java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863)\r\n\tat java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841)\r\n\tat java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)\r\n\tat java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)\r\n\tat org.redisson.client.RedisClient$1$2.run(RedisClient.java:235)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.runTask(AbstractEventExecutor.java:173)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:166)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:470)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:569)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:840)\r\nCaused by: java.util.concurrent.CompletionException: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: 127.0.0.1/127.0.0.1:6379\r\n\tat java.base/java.util.concurrent.CompletableFuture.encodeRelay(CompletableFuture.java:368)\r\n\tat java.base/java.util.concurrent.CompletableFuture.completeRelay(CompletableFuture.java:377)\r\n\tat java.base/java.util.concurrent.CompletableFuture$UniRelay.tryFire(CompletableFuture.java:1097)\r\n\t... 11 common frames omitted\r\nCaused by: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: 127.0.0.1/127.0.0.1:6379\r\nCaused by: java.net.ConnectException: Connection refused\r\n\tat java.base/sun.nio.ch.Net.pollConnect(Native Method)\r\n\tat java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)\r\n\tat java.base/sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:946)\r\n\tat io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:337)\r\n\tat io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:776)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:840)\r\n```"
      }
    ]
  },
  {
    "number": 5970,
    "title": "Inconsistent Behavior of fastRemove with Uninitialized Local Caches",
    "created_at": "2024-06-19T08:21:48Z",
    "closed_at": "2024-08-13T08:35:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5970",
    "body": "I have a Redisson local cache used in different microservices in my system with the following configuration, which is initialized on demand into a `static final ConcurrentHashMap<String, RLocalCachedMap<?, ?>> store = new ConcurrentHashMap<>()`. To remove a key from the local cache across all instances, I use `org.redisson.api.RMap#fastRemove`.\r\n\r\nConfiguration of local cache:\r\n\r\n```java\r\nLocalCachedMapOptions.<Key, Value>defaults()\r\n    .timeToLive(10, TimeUnit.MINUTES)\r\n    .reconnectionStrategy(ReconnectionStrategy.CLEAR)\r\n    .syncStrategy(LocalCachedMapOptions.SyncStrategy.UPDATE)\r\n    .storeMode(StoreMode.LOCALCACHE)\r\n```\r\n\r\nHowever, I encountered an issue. If the cache is first initialized in one instance and then I attempt to fastRemove an entry from another instance (which did not have the local cache initialized yet), the entry stays in the caches of all instances where it was already initialized.\r\n\r\nI suspect the cause is the following code, where the fastRemove only dispatches the invalidate message to other instances if the value in the local cache is not null. I expected that fastRemove, as per the Javadoc \"`Works faster than removeAsync(Object) but not returning the value,`\" would not access the value at all and would simply remove it and propagate the deletion to all instances.\r\n\r\n```java\r\n@Override\r\nprotected RFuture<Long> fastRemoveOperationAsync(K... keys) {\r\n    if (storeMode == LocalCachedMapOptions.StoreMode.LOCALCACHE) {\r\n        long count = 0;\r\n        for (K k : keys) {\r\n            CacheKey cacheKey = localCacheView.toCacheKey(k);\r\n            CacheValue val = cacheRemove(cacheKey);\r\n            if (val != null) { // this evaluates to false as there are no entries yet, since it is being currently initialized\r\n                count++;\r\n                LocalCachedMapInvalidate msg = new LocalCachedMapInvalidate(instanceId, cacheKey.getKeyHash());\r\n                listener.getInvalidationTopic().publishAsync(msg);\r\n            }\r\n        }\r\n        return new CompletableFutureWrapper<>(count);\r\n    }\r\n```\r\n\r\nIs this the expected behavior?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5970/comments",
    "author": "prouzpe3",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-08-13T08:35:15Z",
        "body": "You're right. This is an expected behavior. Invalidation message is sent only for existing entries."
      }
    ]
  },
  {
    "number": 5967,
    "title": "从3.17.0升级到3.28.0后，所有缓存的对象序列化都失败了",
    "created_at": "2024-06-18T10:28:52Z",
    "closed_at": "2024-06-19T03:41:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5967",
    "body": "springboot版本从 2.7.x 升级到 3.2.x 。\r\nredission版本从：3.17.0 升级到 3.28.0 。\r\njdk从 8 升级到 21\r\n其他未变。\r\n缓存序列化对象都是失效了。取值出来是异常的。",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5967/comments",
    "author": "qiuyueovo",
    "comments": [
      {
        "user": "qiuyueovo",
        "created_at": "2024-06-18T10:34:57Z",
        "body": "3.17.0 的序列化方法为：oldConf.setCodec(new MarshallingCodec());\r\n3.28.0 的序列化方法为： oldConf.setCodec(new Kryo5Codec());"
      },
      {
        "user": "qiuyueovo",
        "created_at": "2024-06-18T10:49:49Z",
        "body": "目前我的处理方法是：从 3.17版本中复制出 MarshallingCodec。然后引用这个方法理论上来讲是可以的。我只测试了一个类"
      },
      {
        "user": "mrniko",
        "created_at": "2024-06-19T08:09:34Z",
        "body": "all you need to do is just to specify MarshallingCodec as a codec explicitly."
      },
      {
        "user": "qiuyueovo",
        "created_at": "2024-06-20T01:34:28Z",
        "body": "Yes, that's how I handle it now. Before, all settings were default, and no serialization method was set. Through other people's issue comments, I found a similar problem. I looked at the source code and now it has been successfully solved. Thank you"
      }
    ]
  },
  {
    "number": 5917,
    "title": "Redisson with redis-cluster worse performance than redis standalone",
    "created_at": "2024-05-29T08:24:50Z",
    "closed_at": "2024-06-04T12:43:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5917",
    "body": "At my company, we have an installation of **Redis standalone** (no replicas) which we are considering as a shared point for a _microservices architecture_ running on a _Kubernetes Cluster_.\r\nWe wish to achieve scalability, and to do so, we thought it was appropriate to use **Redis-Cluster** instead, considering that we are dealing with hundreds of pods in r/w.\r\n\r\nAfter the installation of redis-cluster, we run multiple tests, but **we had worse performances** in comparison of the standalone one.\r\n\r\nCurrently, we are tracking multiple insertion times and taking them as statistics. \r\nOur pods are Java microservices using Redisson as the preferred client pointing to a Kubernetes Service.\r\nThe way we are building the connection is this:\r\n`config.useClusterServers().addNodeAddress(\"redis://redis-cluster.redis-cluster.svc.cluster.local:6379\").setPassword(\"myPwd\").setRetryAttempts(10);`\r\nwhere we point at a service that redirects the connections to {redis-cluster-0, ... , redis-cluster-5}. Is this approach correct from Redisson or using a service instead of specifing the addresses of redis-cluster-0, ... redis-cluster-5 causes a performance decrease?\r\nIs there some configuration we could change to increase performance in Redisson? \r\n\r\nThank you in advance for you help and time.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5917/comments",
    "author": "stefanofalangone",
    "comments": [
      {
        "user": "WPCode",
        "created_at": "2024-05-30T18:54:40Z",
        "body": "Following. We encountered the exact same performance issue here as well. We have 3000 hashes which are shared across 5 redis nodes deployed in k8s statefulset. Writing the same data took double the time (4min) it took for standalone single redis server (2min). We are not sure whether it's due to redisson library or something else. Any suggestions?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-31T06:21:33Z",
        "body": "it can be caused by Redis cluster redirects. Can you set `trace` logging level for `org.redisson` package and share output?"
      },
      {
        "user": "stefanofalangone",
        "created_at": "2024-06-04T07:25:41Z",
        "body": "I can confirm it was most probably due to redirects, as stated by @mrniko. \r\n@WPCode I suggest you try putting the addresses of the nodes deployed rather than that of the service and see if it solves."
      }
    ]
  },
  {
    "number": 5893,
    "title": "RLocalCachedMap local cache use?",
    "created_at": "2024-05-21T09:09:24Z",
    "closed_at": "2024-05-22T11:38:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5893",
    "body": "if the data change on redis server，can we get the new data in local cache? or the server will info client the change?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5893/comments",
    "author": "KYV365",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-05-21T12:30:52Z",
        "body": "pubsub message should be send after change if data updated without Redisson client."
      },
      {
        "user": "KYV365",
        "created_at": "2024-05-22T01:47:46Z",
        "body": "> pubsub message should be send after change if data updated without Redisson client.\r\n\r\nbut the new data can not get by method cachedValues()"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-22T05:32:33Z",
        "body": "you need to set `syncStrategy = UPDATE` local cache setting"
      },
      {
        "user": "KYV365",
        "created_at": "2024-05-22T07:23:58Z",
        "body": "> you need to set `syncStrategy = UPDATE` local cache setting\r\n\r\nthanks for your reply"
      }
    ]
  },
  {
    "number": 5882,
    "title": "Here’s the issue we encountered with `redisson-3.11.5.jar`",
    "created_at": "2024-05-20T02:52:53Z",
    "closed_at": "2024-05-21T06:06:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5882",
    "body": "\r\nOur service connects to the SLB (Server Load Balancer) using a domain name, which maps through a port to the Redis server nodes.\r\n\r\nFor example:\r\n- Service IP --> Domain A:2700 --> EIP (10.75.10.20):27000 --> Redis server: 10.65.10.30:27000\r\n\r\nThe Redis sentinel nodes are:\r\n- 10.65.10.30:27000\r\n- 10.65.10.40:27000\r\n- 10.65.10.50:27000\r\n\r\nRedisson performs two types of checks: `scheduleSentinelDNSCheck` and `scheduleChangeCheck`. These checks result in the following situations:\r\n\r\n- `redis://10.75.10.20:27000 added`\r\n- `redis://10.75.10.20:27000 was down`\r\n- `redis://10.65.10.30:27000 added`\r\n- `redis://10.65.10.30:27000 was down`\r\n\r\nThis causes a polling effect, even though they ultimately point to the correct sentinel nodes.\r\n\r\n### How to Resolve This Issue\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5882/comments",
    "author": "githuailoveyou",
    "comments": [
      {
        "user": "githuailoveyou",
        "created_at": "2024-05-20T03:09:59Z",
        "body": "scheduleSentinelDNSCheck will add 10.75.10.20 to the sentinels.\r\nscheduleChangeCheck (when it uses 10.65.10.30:27000 to connect and retrieve other sentinels: redis://10.65.10.20:27000, redis://10.75.10.40:27000 and add 10.65.10.30:27000 to a newUris list to form a new set of three sentinels) will remove 10.75.10.20 from the sentinels.\r\n\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-20T06:58:52Z",
        "body": "because 10.65.10.30 doesn't have 10.75.10.20 in sentinel list. You can verify this by setting `trace` logging level for `org.redisson` package and check returned sentinels list by each sentinel."
      },
      {
        "user": "githuailoveyou",
        "created_at": "2024-05-20T08:06:50Z",
        "body": "Yes, it seems that Redisson doesn't fully support this SLB-based connection method, right? Although it doesn't directly impact business functionality, it does lead to continuous adjustments in the sentinels variable, otherwise we'll keep seeing \"down added\" occurrences. Now, the issue we're facing is that the service logs continue to record these changes persistently. How should I address this? Should we consider abandoning the use of SLB?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-20T08:17:31Z",
        "body": "Does it mean that with SLB the same Redis node has two IPs ? one is defined in sentinel configs and another is used for SLB?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-20T08:20:16Z",
        "body": "Did you try `natMapper` setting ? to resolve EIP to a real Redis node IP"
      },
      {
        "user": "githuailoveyou",
        "created_at": "2024-05-20T08:35:08Z",
        "body": "> Does it mean that with SLB the same Redis node has two IPs ? one is defined in sentinel configs and another is used for SLB?\r\n\r\n\"Yes, the reason we use SLB (Server Load Balancer) is because we have multiple Redis instances deployed on the same machine, each with 2 IP addresses.\r\n\r\nAll services are connected via domain names. Most of the Redis instances are in master-slave mode to ensure failover. Therefore, we adopt the SLB approach. We dynamically modify the server addresses under the SLB port after detecting master-slave switches.\""
      },
      {
        "user": "githuailoveyou",
        "created_at": "2024-05-20T08:38:30Z",
        "body": "> Did you try `natMapper` setting ? to resolve EIP to a real Redis node IP\r\n\r\nCan't make your own turn?  We don't really want to change the code"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-20T09:09:31Z",
        "body": "Unfortunately, it's a specific case. You can define natMapper like below.\r\n\r\n```java\r\n                .setNatMapper(new NatMapper() {\r\n                    @Override\r\n                    public RedisURI map(RedisURI uri) {\r\n                        if (uri.getHost().equals(\"10.75.10.20\")) {\r\n                            return new RedisURI(uri.getScheme(), \"10.65.10.20\", uri.getPort());\r\n                        }\r\n                        ...\r\n                    }\r\n                })\r\n```"
      },
      {
        "user": "githuailoveyou",
        "created_at": "2024-05-20T09:14:36Z",
        "body": "> 不幸的是，这是一个具体案例。您可以像下面一样定义 natMapper。\r\n> \r\n> ```java\r\n>                 .setNatMapper(new NatMapper() {\r\n>                     @Override\r\n>                     public RedisURI map(RedisURI uri) {\r\n>                         if (uri.getHost().equals(\"10.75.10.20\")) {\r\n>                             return ew RedisURI(uri.getScheme(), \"10.65.10.20\", uri.getPort());\r\n>                         }\r\n>                         ...\r\n>                     }\r\n>                 })\r\n> ```\r\n\r\nthank you"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-21T06:06:25Z",
        "body": "Another solution is to use `org.redisson.api.HostNatMapper` implementation.\r\n\r\n```java\r\nMap<String, String> map = new HashMap<>();\r\nmap.put(\"10.75.10.20\", \"10.65.10.20\");\r\n\r\nconfig.setNatMapper(new HostNatMapper(map))\r\n```"
      }
    ]
  },
  {
    "number": 5878,
    "title": "The cluster switches the master/slave nodes, causing an issue",
    "created_at": "2024-05-17T03:24:09Z",
    "closed_at": "2024-06-06T06:49:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5878",
    "body": "Different projects use Redission, different versions. respectively   cn.keking.spring-boot-klock-starter.1.4-RELEASE  with version 3.2.0,\r\nOther projects use 3.17.3 and 3.23.4, and in the same cluster in the production environment, the project reports an error after the master-slave switchover occurs, as follows:\r\n\r\norg.redisson.cluster.ClusterConnectionManager operationComplete [Can't execute CLUSTER_NODES with /172.25.2.21:6379 org.redisson.client.RedisTimeoutException: Command execution timeout for /172.25.2.21:6379\r\n\tat org.redisson.client.RedisConnection$2.run(RedisConnection.java:189)\r\n\tat io.netty.util.concurrent.PromiseTask.runTask(PromiseTask.java:98)\r\n\tat io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:153)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.runTask(AbstractEventExecutor.java:174)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:167)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:470)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:569)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)\r\n**another  msg:**\r\nruoyi-bondgo-api io.netty.util.concurrent.DefaultPromise notifyListener0 [An exception was thrown by org.redisson.command.CommandAsyncService$9.operationComplete() org.redisson.client.RedisNodeNotFoundException: Node: /172.25.2.20:6379 for slot: 4318 hasn't been discovered yet\r\n\tat org.redisson.connection.MasterSlaveConnectionManager.getEntry(MasterSlaveConnectionManager.java:683)\r\n\tat org.redisson.connection.MasterSlaveConnectionManager.connectionWriteOp(MasterSlaveConnectionManager.java:673)\r\n\tat org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:489)\r\n\tat org.redisson.command.CommandAsyncService.checkAttemptFuture(CommandAsyncService.java:737)\r\n\tat org.redisson.command.CommandAsyncService.access$300(CommandAsyncService.java:80)\r\n\tat org.redisson.command.CommandAsyncService$9.operationComplete(CommandAsyncService.java:596)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:590)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:583)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:559)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:492)\r\n\tat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:636)\r\n\tat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:629)\r\n\tat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:118)\r\n\tat org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:98)\r\n\tat org.redisson.client.protocol.CommandData.tryFailure(CommandData.java:79)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:246)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:126)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:529)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5878/comments",
    "author": "ftqiao",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-05-17T05:07:26Z",
        "body": "Can you share Redisson logs since the application start moment?"
      }
    ]
  },
  {
    "number": 5858,
    "title": "SentinelConnectionManager管理类中的NetUtil.createByteArrayFromIpAddressString(addr.getHost()) == null这个条件是不是有问题呢",
    "created_at": "2024-05-11T03:23:28Z",
    "closed_at": "2024-06-17T11:25:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5858",
    "body": "SentinelConnectionManager管理类中的NetUtil.createByteArrayFromIpAddressString(addr.getHost()) == null判断条件在什么时候为空，是不是应该写成不为空的时候\r\n添加sentinelHosts.add(addr);\r\n这方法的意思是哨兵地址的时候添加，还是没有哨兵地址的时候添加，",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5858/comments",
    "author": "lcwlv929",
    "comments": [
      {
        "user": "lcwlv929",
        "created_at": "2024-05-11T08:15:14Z",
        "body": "重新描述一下问题\r\n应用redission连接哨兵，哨兵配置了三个地址，代码在调用到SentinelConnectionManager的public SentinelConnectionManager(SentinelServersConfig cfg, Config configCopy)方法时，for循环中可以获取到三个地址，但是在验证方法if (NetUtil.createByteArrayFromIpAddressString(addr.getHost()) == null && !addr.getHost().equals(\"localhost\")) {\r\n                sentinelHosts.add(addr);\r\n            }\r\n中，因为NetUtil.createByteArrayFromIpAddressString(addr.getHost()) 有返回值，不是空，\r\n导致地址不能添加到哨兵地址中，最终会导致无法连接。\r\n异常后系统会报org.redisson.client.RedisConnectionException Create breakpoint:SENTINEL SENTINELS command returns less than 2 nodes or connection can't be established to some of them!"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-13T05:42:44Z",
        "body": "Sorry, I don't understand the issue."
      }
    ]
  },
  {
    "number": 5849,
    "title": "Which version is the current stable version?",
    "created_at": "2024-05-07T03:51:23Z",
    "closed_at": "2024-05-08T10:21:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5849",
    "body": "Which stable version of Redisson is currently recommended for production use, or which version has been verified in online production environments, and what is considered the relatively optimal version?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5849/comments",
    "author": "sunnan211",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-05-07T03:55:41Z",
        "body": "the latest one."
      },
      {
        "user": "sunnan211",
        "created_at": "2024-05-07T08:36:53Z",
        "body": "I have another question to consult. The current version of Redis we are using in our company is 6.2.6, while the latest version available online is 7.4.2. If I do not change the version of Redis but only upgrade Redisson, will the functionalities mentioned in the fix log be effective? Or is there a need for the versions of Redisson and Redis to be consistent with each other in some way?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-08T10:21:09Z",
        "body": "> If I do not change the version of Redis but only upgrade Redisson, will the functionalities mentioned in the fix log be effective? \r\n\r\nyes"
      }
    ]
  },
  {
    "number": 5830,
    "title": "Issue with Kryo5Codec in combination with org.springframework.cache.support.NullValue",
    "created_at": "2024-04-30T10:11:54Z",
    "closed_at": "2024-12-23T11:00:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5830",
    "body": "Hi,\r\n\r\nI'm currently having an issue with the Spring Cache implementation in combination with Redisson. \r\nThe JCacheCache class provided by Redisson extends `org.springframework.cache.support.AbstractValueAdaptingCache`. In the method `protected Object fromStoreValue(@Nullable Object storeValue)` of the class AbstractValueAdaptingCache, there is an if condition, that check if the storeValue is equal to NullValue.INSTANCE using ==. \r\n\r\n```\r\nprotected Object fromStoreValue(@Nullable Object storeValue) {\r\n\tif (this.allowNullValues && storeValue == NullValue.INSTANCE) {\r\n\t\treturn null;\r\n\t}\r\n\treturn storeValue;\r\n}\r\n```\r\n\r\nThis condition evaluated to false in my case, because the instance of storeValue was not the same instance as NullValue.INSTANCE. Reason is the deserialisation, that was done by Kryo. It seems, that Kryo changes the constructor to \"public\" using reflections and creates a new instance by calling the constructor. It does not call the \"readResolve()\" method of NullValue class, which would return NullValue.INSTANCE.\r\nIs this a known issue? The only solution I came up with is extending the Kryo5Codec and adding a custom Serializer for NullValue.class. Is there another way to fix this issue?\r\n\r\nBest regards",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5830/comments",
    "author": "MrKanister2000",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-04-30T12:12:56Z",
        "body": "> The JCacheCache class provided by Redisson\r\n\r\nSorry, Redisson doesn't implement such class"
      },
      {
        "user": "MrKanister2000",
        "created_at": "2024-04-30T13:07:27Z",
        "body": "> Sorry, Redisson doesn't implement such class\r\n\r\nYep sry, my bad. I got confused with the class names. JCacheCache is part of the Spring package. \r\nNevertheless, the `org.redisson.jcache.JCache` class returns a new instance of NullValue from the cache, because of the Kryo deserialization issue I described. Any hint how to fix this?\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2024-04-30T13:18:30Z",
        "body": "Can you add the code below into org.redisson.codec.Kryo5Codec#createKryo method and say if it works?\r\n\r\n```java\r\nif (com.esotericsoftware.kryo.util.Util.isClassAvailable(\"org.springframework.cache.support.NullValue\")) {\r\n   kryo.addDefaultSerializer(Class.forName(\"org.springframework.cache.support.NullValue\"), new JavaSerializer());\r\n}\r\n```"
      },
      {
        "user": "MrKanister2000",
        "created_at": "2024-04-30T14:06:05Z",
        "body": "Yes, it works, thanks. Do you see any trade-offs (like performance) when using the JavaSerializer?\r\n\r\nMy first solution was extending the Kryo5Codec class:\r\n\r\n```\r\npublic class MyKryo5Codec extends Kryo5Codec {\r\n\r\n    @Override\r\n    protected Kryo createKryo(ClassLoader classLoader) {\r\n        Kryo kryo = super.createKryo(classLoader);\r\n\r\n        kryo.addDefaultSerializer(NullValue.class, new NullValueSerializer(kryo, NullValue.class));\r\n\r\n        return kryo;\r\n    }\r\n}\r\n```\r\n\r\nand creating a custom NullValueSerializer:\r\n\r\n```\r\npublic class NullValueSerializer extends FieldSerializer<NullValue> {\r\n\r\n    public NullValueSerializer(Kryo kryo, Class type) {\r\n        super(kryo, type);\r\n    }\r\n\r\n    @Override\r\n    public NullValue read(Kryo kryo, Input input, Class type) {\r\n        return (NullValue) NullValue.INSTANCE;\r\n    }\r\n}\r\n```\r\n\r\nBut your solution has a way smaller footprint than mine."
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-01T05:08:01Z",
        "body": "Thanks for testing. In your example Spring become a required dependency because of explicit NullValue class definition which I would like to avoid. It would be great if you rewrite it without explicit NullValue definition."
      }
    ]
  },
  {
    "number": 5813,
    "title": "How do i disable Redisson Cache mechanisam",
    "created_at": "2024-04-25T10:33:20Z",
    "closed_at": "2024-04-25T11:51:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5813",
    "body": "Am using EhCache in my sprint boot Hibernate application.\r\n\r\nNow am using Redission library to store the data to Redis.\r\n\r\nAm getting Multi-Cache exception when both EhCache and Reddison being used together.\r\nCaused by: javax.cache.CacheException: Multiple CachingProviders have been configured when only a single CachingProvider is expected\r\n\r\nIs there a way to avoid Redission Caching and use only EhCache.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5813/comments",
    "author": "ygravikiran",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-04-25T11:51:01Z",
        "body": "the only way is to delete META-INF\\services\\javax.cache.spi.CachingProvider file in jar"
      }
    ]
  },
  {
    "number": 5810,
    "title": "Register a module with JsonJacksonCodec within YAML configuration",
    "created_at": "2024-04-23T10:04:28Z",
    "closed_at": "2024-04-27T14:25:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5810",
    "body": "Hello!\r\n\r\nRegular user of Redisson here. I wanted to use the external configuration from YAML. I always initialized my `Config` from code.\r\n\r\nEverything is working perfectly! But I wondered if there was any documentation on the `codec` field?\r\n\r\nI am using the `JsonJacksonCodec` with the following config entry:\r\n```YAML\r\ncodec: !!org.redisson.codec.JsonJacksonCodec {}\r\n```\r\n\r\nI want to register custom modules, such as the `JavaTImeModule` (`com.fasterxml.jackson.datatype.jsr310.JavaTimeModule`). I inspected the source code and saw that this field is maybe using some really deep Jackson features to construct a class from a configuration.\r\n\r\nIs any configuration sample or example provided? Or is there any Jackson article who explains this feature?\r\n\r\nI am using the latest Redisson version.\r\n\r\nAfter getting an answer, I'll make sure to PR some documentation additions in order to cover this case correctly :)\r\n\r\nThanks a lot!\r\nAdam.\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5810/comments",
    "author": "dandan2611",
    "comments": [
      {
        "user": "raja2102598",
        "created_at": "2024-04-23T10:29:38Z",
        "body": "Hi @dandan2611, I think there is no direct way to register custom modules from yaml file.\r\n\r\n\r\nOther option is override the JsonJacksonCodec and register your modules then give your customClass in the yaml config."
      },
      {
        "user": "dandan2611",
        "created_at": "2024-04-27T14:25:03Z",
        "body": "Alright, I'll do that. Thank you!"
      }
    ]
  },
  {
    "number": 5796,
    "title": "Redisson 3.5 Compatibility with Redis 6.2/7.0",
    "created_at": "2024-04-19T07:05:08Z",
    "closed_at": "2024-04-19T08:11:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5796",
    "body": "Hi Team,\r\n\r\nWe are currently planning to migrate from REDIS 3.2 to either REDIS 6.2 or REDIS 7.0. Will there be any compatibility issues with using Redisson 3.5 to access REDIS 6.2 or REDIS 7.0.\r\n\r\nIf there will be a large compatibility issue, which is the minimum Redisson version that we could use to enable us to access our target REDIS version?\r\n\r\nAdditional info, we are currently using Java8 and it will be hard for us to migrate to higher versions of Java at the moment.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5796/comments",
    "author": "alecasuncion",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-04-19T08:11:46Z",
        "body": "Hi,\r\n\r\nlatest Redisson version is still JDK8 compatible. \r\n\r\n3.5.x version is compatible with Redis 6.2 and 7.0 version. "
      }
    ]
  },
  {
    "number": 5785,
    "title": "Lua throwing error for bitmap operations",
    "created_at": "2024-04-15T08:50:13Z",
    "closed_at": "2024-04-16T05:53:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5785",
    "body": "Use case : We are using BITMAP on one of our use case, where we are sending the key array and ARG array as arguement for the evalSHA. \r\nOn lua script, it gonna iteratively traverse the ARG array and set the corresponding bit on the redis.\r\n\r\n\r\nLUA script\r\n\r\n`local key = KEYS[1]\r\nlocal cntr = 0\r\nfor _, userId in ipairs(ARGV) do\r\n    local bitIndex = tonumber(userId)\r\n    redis.call('SETBIT', key, bitIndex, 1)\r\n    cntr = cntr + 1\r\nend\r\nreturn cntr`\r\n\r\n\r\nClient Redisson v3.27.2\r\nMode : Master-slave\r\n\r\n\r\nSample code \r\n\r\nOn post construct we are loading the lua script to the redis server\r\n\r\naudienceDataRedisSha = redissonClient.getScript(BitSetCodec.INSTANCE).scriptLoad(luaScript);\r\n\r\n`redissonClient\r\n            .getScript(BitSetCodec.INSTANCE)\r\n            .evalSha(\r\n                redisKey,\r\n                RScript.Mode.READ_WRITE,\r\n                audienceDataRedisSha,\r\n                RScript.ReturnType.INTEGER,\r\n                Collections.singletonList(redisKey),\r\n                1234,\r\n                12343,\r\n                8655,\r\n                92949,\r\n                23344242,\r\n                234434,\r\n                8888,\r\n                22);`\r\n\r\nI have tried executing the lua script directly on the redis cli, that worked with expected result.\r\njava.lang.UnsupportedOperationException: null\r\n\tat org.redisson.client.codec.BitSetCodec.getValueEncoder(BitSetCodec.java:61)\r\n\tat org.redisson.command.CommandAsyncService.encode(CommandAsyncService.java:834)\r\n\tat org.redisson.RedissonScript.encode(RedissonScript.java:201)\r\n\tat org.redisson.RedissonScript.evalShaAsync(RedissonScript.java:234)\r\n\tat org.redisson.RedissonScript.evalSha(RedissonScript.java:258)\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5785/comments",
    "author": "ShashankSByakod37",
    "comments": [
      {
        "user": "ShashankSByakod37",
        "created_at": "2024-04-15T08:50:47Z",
        "body": "@mrniko Can you pls help here?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-04-16T05:45:36Z",
        "body": "BitSetCodec class is for internal purposes only."
      },
      {
        "user": "ShashankSByakod37",
        "created_at": "2024-04-16T06:14:43Z",
        "body": "@mrniko I even tried with the different classes too, still getting the same result. What should be the ideal codec for this?"
      }
    ]
  },
  {
    "number": 5779,
    "title": "EMF | OPTION_USE_PACKAGE_NS_URI_AS_LOCATION ",
    "created_at": "2024-04-14T17:46:59Z",
    "closed_at": "2024-04-15T05:36:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5779",
    "body": "In the provided Java call stack, it appears that HttpURLConnection is attempting to establish a connection. \r\n4XESTACKTRACE                at sun/net/www/protocol/http/HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1238)\r\n4XESTACKTRACE                at sun/net/www/protocol/http/HttpURLConnection.plainConnect0(HttpURLConnection.java:1174)\r\n4XESTACKTRACE                at sun/net/www/protocol/http/HttpURLConnection.plainConnect(HttpURLConnection.java:1068)\r\n4XESTACKTRACE                at sun/net/www/protocol/http/HttpURLConnection.connect(HttpURLConnection.java:1002)\r\n\r\nI'm seeking guidance on how to disable this behavior. \r\n\r\nI suspect that the EMF framework might be initiating unnecessary connections. \r\n\r\nI would like to utilize the OPTION_USE_PACKAGE_NS_URI_AS_LOCATION feature to address this issue. \r\n\r\nCould you please advise on how to set OPTION_USE_PACKAGE_NS_URI_AS_LOCATION to false so that the EMF framework does not wait for the connection?\r\n\r\nHere is the full call stack.\r\n\r\n```\r\nJava callstack:\r\n4XESTACKTRACE                at java/net/PlainSocketImpl.socketConnect(Native Method)\r\n4XESTACKTRACE                at java/net/AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:380)\r\n5XESTACKTRACE                   (entered lock: java/net/SocksSocketImpl@0x00000007FB649CF8, entry count: 1)\r\n4XESTACKTRACE                at java/net/AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:236)\r\n4XESTACKTRACE                at java/net/AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:218)\r\n4XESTACKTRACE                at java/net/SocksSocketImpl.connect(SocksSocketImpl.java:403)\r\n4XESTACKTRACE                at java/net/Socket.connect(Socket.java:682)\r\n4XESTACKTRACE                at java/net/Socket.connect(Socket.java:622)\r\n4XESTACKTRACE                at sun/net/NetworkClient.doConnect(NetworkClient.java:192)\r\n4XESTACKTRACE                at sun/net/www/http/HttpClient.openServer(HttpClient.java:494)\r\n4XESTACKTRACE                at sun/net/www/http/HttpClient.openServer(HttpClient.java:589)\r\n5XESTACKTRACE                   (entered lock: sun/net/www/http/HttpClient@0x00000007FB649DB8, entry count: 1)\r\n4XESTACKTRACE                at sun/net/www/http/HttpClient.<init>(HttpClient.java:256)\r\n4XESTACKTRACE                at sun/net/www/http/HttpClient.New(HttpClient.java:360)\r\n4XESTACKTRACE                at sun/net/www/http/HttpClient.New(HttpClient.java:378)\r\n4XESTACKTRACE                at sun/net/www/protocol/http/HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1238)\r\n4XESTACKTRACE                at sun/net/www/protocol/http/HttpURLConnection.plainConnect0(HttpURLConnection.java:1174)\r\n4XESTACKTRACE                at sun/net/www/protocol/http/HttpURLConnection.plainConnect(HttpURLConnection.java:1068)\r\n4XESTACKTRACE                at sun/net/www/protocol/http/HttpURLConnection.connect(HttpURLConnection.java:1002)\r\n4XESTACKTRACE                at sun/net/www/protocol/http/HttpURLConnection.getInputStream0(HttpURLConnection.java:1582(Compiled Code))\r\n5XESTACKTRACE                   (entered lock: sun/net/www/protocol/http/HttpURLConnection@0x00000007FB649E28, entry count: 2)\r\n4XESTACKTRACE                at sun/net/www/protocol/http/HttpURLConnection.getInputStream(HttpURLConnection.java:1510)\r\n5XESTACKTRACE                   (entered lock: sun/net/www/protocol/http/HttpURLConnection@0x00000007FB649E28, entry count: 1)\r\n4XESTACKTRACE                at org/eclipse/emf/ecore/resource/impl/URIConverterImpl.createURLInputStream(URIConverterImpl.java:566)\r\n4XESTACKTRACE                at org/eclipse/emf/ecore/resource/impl/URIConverterImpl.createInputStream(URIConverterImpl.java:453)\r\n4XESTACKTRACE                at org/eclipse/emf/ecore/xmi/impl/XMLHandler.getPackageForURI(XMLHandler.java:2292(Compiled Code))\r\n4XESTACKTRACE                at org/eclipse/emf/ecore/sdo/util/DataGraphResourceFactoryImpl$DataGraphResourceImpl$LoadImpl$2.getPackageForURI(DataGraphResourceFactoryImpl.java:685)\r\n4XESTACKTRACE                at org/eclipse/emf/ecore/xmi/impl/XMLHandler.getFactoryForPrefix(XMLHandler.java:2186(Compiled Code))\r\n4XESTACKTRACE                at org/eclipse/emf/ecore/xmi/impl/XMLHandler.createObjectByType(XMLHandler.java:1156)\r\n4XESTACKTRACE                at org/eclipse/emf/ecore/sdo/util/DataGraphResourceFactoryImpl$DataGraphResourceImpl$LoadImpl$2.handleFeature(DataGraphResourceFactoryImpl.java:587)\r\n4XESTACKTRACE                at org/eclipse/emf/ecore/xmi/impl/XMLHandler.processElement(XMLHandler.java:898(Compiled Code))\r\n4XESTACKTRACE                at org/eclipse/emf/ecore/xmi/impl/XMLHandler.startElement(XMLHandler.java:873(Compiled Code))\r\n4XESTACKTRACE                at org/eclipse/emf/ecore/xmi/impl/XMLHandler.startElement(XMLHandler.java:641(Compiled Code))\r\n4XESTACKTRACE                at org/apache/xerces/parsers/AbstractSAXParser.startElement(Bytecode PC:299(Compiled Code))\r\n4XESTACKTRACE                at org/apache/xerces/impl/XMLDocumentFragmentScannerImpl.scanStartElement(Bytecode PC:311(Compiled Code))\r\n4XESTACKTRACE                at org/apache/xerces/impl/XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Bytecode PC:416(Compiled Code))\r\n4XESTACKTRACE                at org/apache/xerces/impl/XMLDocumentFragmentScannerImpl.scanDocument(Bytecode PC:26(Compiled Code))\r\n4XESTACKTRACE                at org/apache/xerces/parsers/XML11Configuration.parse(Bytecode PC:134(Compiled Code))\r\n4XESTACKTRACE                at org/apache/xerces/parsers/XML11Configuration.parse(Bytecode PC:29(Compiled Code))\r\n4XESTACKTRACE                at org/apache/xerces/parsers/XMLParser.parse(Bytecode PC:11(Compiled Code))\r\n4XESTACKTRACE                at org/apache/xerces/parsers/AbstractSAXParser.parse(Bytecode PC:43(Compiled Code))\r\n4XESTACKTRACE                at org/apache/xerces/jaxp/SAXParserImpl$JAXPSAXParser.parse(Bytecode PC:53(Compiled Code))\r\n4XESTACKTRACE                at org/apache/xerces/jaxp/SAXParserImpl.parse(Bytecode PC:61(Compiled Code))\r\n4XESTACKTRACE                at org/eclipse/emf/ecore/xmi/impl/XMLLoadImpl.load(XMLLoadImpl.java:236)\r\n4XESTACKTRACE                at org/eclipse/emf/ecore/xmi/impl/XMLResourceImpl.doLoad(XMLResourceImpl.java:179)\r\n4XESTACKTRACE                at org/eclipse/emf/ecore/resource/impl/ResourceImpl.load(ResourceImpl.java:1094(Compiled Code))\r\n4XESTACKTRACE                at org/eclipse/emf/ecore/sdo/impl/EDataGraphImpl$EDataGraphExternalizable.readExternal(EDataGraphImpl.java:598)\r\n4XESTACKTRACE                at org/jboss/marshalling/river/RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1444(Compiled Code))\r\n4XESTACKTRACE                at org/jboss/marshalling/river/RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:298(Compiled Code))\r\n4XESTACKTRACE                at org/jboss/marshalling/river/BlockUnmarshaller.readObject(BlockUnmarshaller.java:149(Compiled Code))\r\n4XESTACKTRACE                at org/jboss/marshalling/river/BlockUnmarshaller.readObject(BlockUnmarshaller.java:135(Compiled Code))\r\n4XESTACKTRACE                at org/eclipse/emf/ecore/sdo/impl/EDataGraphImpl$EDataObjectExternalizable.readExternal(EDataGraphImpl.java:650)\r\n4XESTACKTRACE                at org/jboss/marshalling/river/RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1444(Compiled Code))\r\n4XESTACKTRACE                at org/jboss/marshalling/river/RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:298(Compiled Code))\r\n4XESTACKTRACE                at org/jboss/marshalling/river/RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:246(Compiled Code))\r\n4XESTACKTRACE                at org/jboss/marshalling/river/RiverUnmarshaller.readFields(RiverUnmarshaller.java:1879(Compiled Code))\r\n4XESTACKTRACE                at org/jboss/marshalling/river/RiverUnmarshaller.doInitSerializable(RiverUnmarshaller.java:1793(Compiled Code))\r\n4XESTACKTRACE                at org/jboss/marshalling/river/RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1421(Compiled Code))\r\n4XESTACKTRACE                at org/jboss/marshalling/river/RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:298(Compiled Code))\r\n4XESTACKTRACE                at org/jboss/marshalling/river/RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:231(Compiled Code))\r\n4XESTACKTRACE                at org/jboss/marshalling/AbstractObjectInput.readObject(AbstractObjectInput.java:41)\r\n4XESTACKTRACE                at org/redisson/codec/MarshallingCodec.lambda$new$0(MarshallingCodec.java:146)\r\n4XESTACKTRACE                at org/redisson/codec/MarshallingCodec$$Lambda$26/0x0000000000000000.decode(Bytecode PC:6)\r\n4XESTACKTRACE                at org/redisson/client/handler/CommandDecoder.decode(CommandDecoder.java:383(Compiled Code))\r\n4XESTACKTRACE                at org/redisson/client/handler/CommandDecoder.decodeList(CommandDecoder.java:420(Compiled Code))\r\n4XESTACKTRACE                at org/redisson/client/handler/CommandDecoder.decode(CommandDecoder.java:392(Compiled Code))\r\n4XESTACKTRACE                at org/redisson/client/handler/CommandDecoder.decodeCommandBatch(CommandDecoder.java:271(Compiled Code))\r\n4XESTACKTRACE                at org/redisson/client/handler/CommandDecoder.decodeCommand(CommandDecoder.java:210(Compiled Code))\r\n4XESTACKTRACE                at org/redisson/client/handler/CommandDecoder.decode(CommandDecoder.java:137(Compiled Code))\r\n4XESTACKTRACE                at org/redisson/client/handler/CommandDecoder.decode(CommandDecoder.java:113(Compiled Code))\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5779/comments",
    "author": "Masood312",
    "comments": [
      {
        "user": "Masood312",
        "created_at": "2024-04-14T18:11:01Z",
        "body": "@mrniko, do you have any suggestion.  "
      },
      {
        "user": "mrniko",
        "created_at": "2024-04-15T05:36:28Z",
        "body": "That's an interesting issue. MarshallingCodec was deprecated long time ago. You need to use Kryo5Codec instead, which is default one now."
      }
    ]
  },
  {
    "number": 5772,
    "title": "Will the key expiration listener not be automatically deleted?",
    "created_at": "2024-04-11T10:38:08Z",
    "closed_at": "2024-05-01T06:50:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5772",
    "body": "When I use the addListener method of RBucket to add a key expiration listener to a key, the key expires and is deleted, but the listener is not automatically deleted. I create the key again and add the listener, and the listener's logic will execute multiple times, indicating that the listener added for the first time has not been removed.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5772/comments",
    "author": "BubblingXuYijie",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-05-01T06:50:10Z",
        "body": "Redis doesn't delete listeners automatically. Moreover automatic listeners removal may lead to incorrect behavior."
      }
    ]
  },
  {
    "number": 5767,
    "title": "Some questions about RedisCommandExecutionException: CLUSTERDOWN The cluster is down",
    "created_at": "2024-04-09T12:35:04Z",
    "closed_at": "2024-04-09T13:15:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5767",
    "body": "Auditor, this is happening on my current server. Can you give me a general troubleshooting direction?\r\n\r\nredisson.version : 3.15.5\r\nredis version: 6.2.6\r\n\r\nCurrently the following exception occurs on the host:\r\n\r\n```java\r\n2024-04-09 00:36:37,792 [http-nio-8088-exec-35] ERROR [o.a.c.c.C.[.[localhost].[/].[dispatcherServlet]] DirectJDKLog.java:175 - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception\r\norg.springframework.data.redis.RedisSystemException: Error in execution; nested exception is io.lettuce.core.RedisCommandExecutionException: CLUSTERDOWN The cluster is down\r\n\tat org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convert(LettuceExceptionConverter.java:54)\r\n\tat org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convert(LettuceExceptionConverter.java:52)\r\n\tat org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convert(LettuceExceptionConverter.java:41)\r\n\tat org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:44)\r\n\tat org.springframework.data.redis.FallbackExceptionTranslationStrategy.translate(FallbackExceptionTranslationStrategy.java:42)\r\n\tat org.springframework.data.redis.connection.lettuce.LettuceConnection.convertLettuceAccessException(LettuceConnection.java:273)\r\n\tat org.springframework.data.redis.connection.lettuce.LettuceStringCommands.convertLettuceAccessException(LettuceStringCommands.java:799)\r\n\tat org.springframework.data.redis.connection.lettuce.LettuceStringCommands.get(LettuceStringCommands.java:68)\r\n\tat org.springframework.data.redis.connection.DefaultedRedisConnection.get(DefaultedRedisConnection.java:266)\r\n\tat org.springframework.data.redis.core.DefaultValueOperations$1.inRedis(DefaultValueOperations.java:57)\r\n\tat org.springframework.data.redis.core.AbstractOperations$ValueDeserializingRedisCallback.doInRedis(AbstractOperations.java:60)\r\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:228)\r\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:188)\r\n\tat org.springframework.data.redis.core.AbstractOperations.execute(AbstractOperations.java:96)\r\n\tat org.springframework.data.redis.core.DefaultValueOperations.get(DefaultValueOperations.java:53)\r\n\tat cloud.ato.system.security.JwtAuthenticationFilter.doFilterInternal(JwtAuthenticationFilter.java:71)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n\tat org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:52)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n\tat org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n\tat org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n\tat cloud.ato.system.filter.ValidateCodeFilter.doFilterInternal(ValidateCodeFilter.java:35)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n\tat org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n\tat org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:92)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n\tat org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)\r\n\tat org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n\tat org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n\tat org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n\tat org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)\r\n\tat org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)\r\n\tat org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)\r\n\tat org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)\r\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\r\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)\r\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)\r\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\r\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373)\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590)\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: io.lettuce.core.RedisCommandExecutionException: CLUSTERDOWN The cluster is down\r\n\tat io.lettuce.core.ExceptionFactory.createExecutionException(ExceptionFactory.java:135)\r\n\tat io.lettuce.core.ExceptionFactory.createExecutionException(ExceptionFactory.java:108)\r\n\tat io.lettuce.core.protocol.AsyncCommand.completeResult(AsyncCommand.java:120)\r\n\tat io.lettuce.core.protocol.AsyncCommand.complete(AsyncCommand.java:111)\r\n\tat io.lettuce.core.protocol.CommandWrapper.complete(CommandWrapper.java:59)\r\n\tat io.lettuce.core.cluster.ClusterCommand.complete(ClusterCommand.java:63)\r\n\tat io.lettuce.core.protocol.CommandHandler.complete(CommandHandler.java:654)\r\n\tat io.lettuce.core.protocol.CommandHandler.decode(CommandHandler.java:614)\r\n\tat io.lettuce.core.protocol.CommandHandler.channelRead(CommandHandler.java:565)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:792)\r\n\tat io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:475)\r\n\tat io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\t... 1 common frames omitted\r\n2024-04-09 00:36:38,302 [redisson-timer-7-1] ERROR [org.redisson.client.handler.PingConnectionHandler] PingConnectionHandler.java:89 - Unable to send PING command over channel: [id: 0x3913639b, L:/172.22.30.5:40842 - R:/172.22.30.5:9002]\r\norg.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://172.22.30.5:9002]\r\n```\r\n\r\nRedisson config:\r\n```java\r\npublic RedissonClient redissonClient() {\r\n        String address = \"redis://\" + URL + \":\" + PORT;\r\n        Config config = new Config();\r\n        config.useClusterServers()\r\n                .addNodeAddress(address)\r\n                .setRetryInterval(6000)\r\n                .setTimeout(6000)\r\n                .setMasterConnectionMinimumIdleSize(3)\r\n                .setSlaveConnectionMinimumIdleSize(3)\r\n                .setPassword(PASSWORD);\r\n        return Redisson.create(config);\r\n    }\r\n```\r\n\r\nI tried to find the server manufacturer and found out that there is no problem with the intranet. At the same time, rabbitMQ can also be used normally. Only redisson has an abnormal situation that cannot be accessed, causing the data here to be unable to be used normally. Please help me find the problem.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5767/comments",
    "author": "0x7ffffff",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-04-09T13:15:43Z",
        "body": "> io.lettuce.core.RedisCommandExecutionException: CLUSTERDOWN The cluster is down\r\n\r\nSorry, but it's a Lettuce driver exception. "
      }
    ]
  },
  {
    "number": 5749,
    "title": " Unsupported protocol version 34",
    "created_at": "2024-04-03T09:41:22Z",
    "closed_at": "2024-04-13T04:51:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5749",
    "body": "**Version**:\r\n```\r\n<dependency>\r\n      <groupId>org.redisson</groupId>\r\n      <artifactId>redisson-spring-data-22</artifactId>\r\n      <version>3.15.4</version>\r\n    </dependency>\r\n```\r\n**Background**:\r\nPreviously I wrote some data in default codec() through Redisson, now I want to switch the encoding to **JSON**. \r\nBoth **old** data and **new** data are exist in the map, for example:\r\n```\r\n10.169.75.15:6379[9]> hkeys gw_cluster_names\r\n1) \"\\\"gateway\\\"\"\r\n2) \"\\\"10.169.66.94:8443\\\"\"\r\n3) \"\\\"10.169.66.147:8443\\\"\"\r\n4) \"\\x04>\\x1110.169.66.94:8443\"\r\n5) \"\\x04>\\x1210.169.66.147:8443\"\r\n6) \"\\x04>\\agateway\"\r\n```\r\nIt reports the following error:\r\n```\r\n2024-04-03 10:44:41 [redisson-netty-2-13,null] ERROR CommandPubSubDecoder - [bTxId: , bSpanId: , bMode: ] Unable to decode data. channel: [id: 0x945b1674, L:/10.169.67.100:62282 - R:/10\r\n.169.75.15:6379], reply: ReplayingDecoderByteBuf(ridx=330, widx=330) (CommandPubSubDecoder.java:76)\r\njava.io.IOException: Unsupported protocol version 34\r\n        at org.jboss.marshalling.river.RiverUnmarshaller.start(RiverUnmarshaller.java:1375)\r\n        at org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:145)\r\n        at org.redisson.codec.BaseEventCodec.decode(BaseEventCodec.java:53)\r\n        at org.redisson.codec.MapCacheEventCodec$1.decode(MapCacheEventCodec.java:39)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:358)\r\n        at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:402)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:367)\r\n        at org.redisson.client.handler.CommandPubSubDecoder.decodeCommand(CommandPubSubDecoder.java:72)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:88)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498)\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355)\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)\r\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.base/java.lang.Thread.run(Thread.java:832)\r\n2024-04-03 10:44:41 [redisson-netty-2-13,null] ERROR ErrorsLoggingHandler - [bTxId: , bSpanId: , bMode: ] Exception occured. Channel: [id: 0x945b1674, L:/10.169.67.100:62282 - R:/10.169\r\n.75.15:6379] (ErrorsLoggingHandler.java:47)\r\nio.netty.handler.codec.DecoderException: java.io.IOException: Unsupported protocol version 34\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355)\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)\r\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.base/java.lang.Thread.run(Thread.java:832)\r\nCaused by: java.io.IOException: Unsupported protocol version 34\r\n        at org.jboss.marshalling.river.RiverUnmarshaller.start(RiverUnmarshaller.java:1375)\r\n        at org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:145)\r\n        at org.redisson.codec.BaseEventCodec.decode(BaseEventCodec.java:53)\r\n        at org.redisson.codec.MapCacheEventCodec$1.decode(MapCacheEventCodec.java:39)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:358)\r\n        at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:402)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:367)\r\n        at org.redisson.client.handler.CommandPubSubDecoder.decodeCommand(CommandPubSubDecoder.java:72)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:88)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498)\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n        ... 17 common frames omitted\r\n```\r\nThe stack trace can't tell that which line of my code called it.\r\nCan anyone help with this question?\r\nThanks in advance!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5749/comments",
    "author": "willzgw",
    "comments": [
      {
        "user": "willzgw",
        "created_at": "2024-04-05T01:59:17Z",
        "body": "It looks like the same map cannot store data in both encoding formats.\r\nThis error is no longer reported after I used two separate maps."
      },
      {
        "user": "mrniko",
        "created_at": "2024-04-13T04:51:52Z",
        "body": "it's a bad practice to store data in different formats in the same map. "
      }
    ]
  },
  {
    "number": 5748,
    "title": "java.lang.NoClassDefFoundError: com/esotericsoftware/kryo/serializers/DefaultSerializers$UUIDSerializer",
    "created_at": "2024-04-03T09:17:59Z",
    "closed_at": "2024-04-03T10:28:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5748",
    "body": "redisson version: 3.27.2\r\n\r\n\r\ncode\r\n```code\r\n  Config config = new Config();\r\n        config.useSingleServer()\r\n                .setAddress(\"redis://host\")\r\n                .setPassword(\"xxxxxx\")\r\n                .setDatabase(0);\r\n        RedissonClient client = Redisson.create(config);\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5748/comments",
    "author": "lchaofu",
    "comments": [
      {
        "user": "vithu30",
        "created_at": "2024-06-17T10:32:21Z",
        "body": "@lchaofu how did u resolve the above issue?"
      },
      {
        "user": "lchaofu",
        "created_at": "2024-06-17T10:58:44Z",
        "body": "> @lchaofu how did u resolve the above issue?\r\n\r\nThe codec version in the project is inconsistent with the Redisson codec version"
      }
    ]
  },
  {
    "number": 5743,
    "title": "enables references  to the same object and cyclic graphs to be serialized ",
    "created_at": "2024-04-01T07:45:19Z",
    "closed_at": "2024-11-01T12:23:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5743",
    "body": "I'm trying to save a recursive object in Redis. For example:\r\n\r\n\r\n\r\n`public Test(){\r\nTest test;\r\n}`\r\nI noticed that the codec implementation is Kryo5Codec, which is set with kryo.setReferences(false); when initializing the Kryo object:\r\n\r\n`    protected Kryo createKryo(ClassLoader classLoader) {\r\n        Kryo kryo = new Kryo();\r\n        if (classLoader != null) {\r\n            kryo.setClassLoader(classLoader);\r\n        }\r\n        kryo.setInstantiatorStrategy(new SimpleInstantiatorStrategy());\r\n        kryo.setRegistrationRequired(false);\r\n        kryo.setReferences(false);\r\n        kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\r\n        kryo.addDefaultSerializer(UUID.class, new DefaultSerializers.UUIDSerializer());\r\n        kryo.addDefaultSerializer(URI.class, new DefaultSerializers.URISerializer());\r\n        kryo.addDefaultSerializer(Pattern.class, new DefaultSerializers.PatternSerializer());\r\n        return kryo;\r\n    }`\r\n    \r\n    \r\nTo solve this, I overrode it like so:\r\n\r\n\r\n    \r\n    `public class CustomKryoCodec extends Kryo5Codec {\r\n\r\n\t@Override\r\n\tprotected Kryo createKryo(ClassLoader classLoader) {\r\n\t\tKryo kryo = super.createKryo(classLoader);\r\n\t\tkryo.setReferences(true);\r\n\t\treturn kryo;\r\n\t}\r\n\r\n}`\r\n\r\nand set the Redisson config with:\r\n\r\n`config.setCodec(new CustomKryoCodec());`\r\n\r\n\r\nIs there native support in Redisson for working with recursive objects?\r\n\r\n\r\n Redisson version: 3.23.2\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5743/comments",
    "author": "yarivMobitti",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-11-01T12:23:01Z",
        "body": "`useReferences` setting added in 3.36.0 version"
      }
    ]
  },
  {
    "number": 5729,
    "title": "Create a Serializer using Spring IoC",
    "created_at": "2024-03-27T16:54:41Z",
    "closed_at": "2024-05-08T10:25:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5729",
    "body": "Hi,\r\n\r\nI'm evaluating Redisson as an alternative to Hazelcast in a spring boot application, and at the moment I'm using Kryo5Codec.\r\n\r\nTaking as reference the example from the documentation:\r\n\r\n```\r\npublic class AddressSerializer extends Serializer<Address> {\r\n\r\n     @Override\r\n     public void write(Kryo kryo, Output output, Address address) {\r\n         output.writeString(address.getStreet());\r\n         output.writeString(address.getCity());\r\n         output.writeString(address.getCountry());\r\n     }\r\n\r\n     @Override\r\n     public Address read(Kryo kryo, Input input, Class<Address> type) {\r\n         return new Address(input.readString(), input.readString(), input.readString());\r\n     }\r\n}\r\n```\r\n\r\nI would like to know if it is possible to inject dependencies with @Autowired at field, constructor or setter level. I have been doing several tests based on the Kryo5Codec class itself, but still without success. \r\n\r\nThanks in advance,\r\nAntonio\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5729/comments",
    "author": "jrx-amf",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-05-08T10:25:03Z",
        "body": "Sorry, it's a question about Kryo5 and Spring integration. Can you refer it to Kryo Team?"
      },
      {
        "user": "jrx-amf",
        "created_at": "2024-05-09T12:28:49Z",
        "body": "Hi @mrniko, yes of course. Thanks for your time & attention. "
      }
    ]
  },
  {
    "number": 5727,
    "title": "Problems using TransmittableThreadLocal in NameMapper",
    "created_at": "2024-03-27T06:58:38Z",
    "closed_at": "2024-11-07T10:11:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5727",
    "body": "NameMapper cannot get the value in InheritableThreadLocal. Even if I use TransmittableThreadLocal and set setExecutor and setNettyExecutor, I cannot get the variable in the child thread in unmap.\r\n```java\r\npublic class KeyPrefixHandler implements NameMapper {\r\n  public String map(String name) { return name; }\r\n  public String unmap(String name) {\r\n    // Neither in the main thread nor in the child thread\r\n    System.out.println(TEMP.get()); // null\r\n    return name;\r\n  }\r\n}\r\n\r\n@AutoConfiguration\r\npublic class RedisConfig {\r\n  @Bean\r\n  public RedissonAutoConfigurationCustomizer redissonCustomizer(RedissonProperties redissonProperties) {\r\n    return config -> {\r\n      config.useSingleServer().setNameMapper(new KeyPrefixHandler(redissonProperties.getKeyPrefix()))\r\n      int threads = Runtime.getRuntime().availableProcessors() * 2;\r\n      if (config.getThreads() != 0) {\r\n          threads = config.getThreads();\r\n      }\r\n      config.setExecutor(TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(threads, new DefaultThreadFactory(\"redisson\"))));\r\n      config.setNettyExecutor(TtlExecutors.getTtlExecutor(new ThreadPerTaskExecutor(new DefaultThreadFactory(\"redisson-netty\"))));\r\n      // ...\r\n    }\r\n  }\r\n}\r\n\r\npublic class Test {\r\n  private static final ThreadLocal<Boolean> TEMP = new TransmittableThreadLocal<>();\r\n\r\n  public static void main(String[] args) {\r\n    TEMP.set(true);\r\n    Stream<String> stream = redissonClient.getKeys().getKeysStreamByPattern(\"test:*\");\r\n    stream.collect(Collectors.toList());\r\n    TEMP.remove();\r\n  }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5727/comments",
    "author": "yixiaco",
    "comments": [
      {
        "user": "yixiaco",
        "created_at": "2024-04-27T04:10:22Z",
        "body": "@mrniko Can you help me with this question and see if there is any progress?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-11-07T10:11:00Z",
        "body": "`NameMapper.unmap()` method is called by the netty thread during Redis response decoding process and not in a main thread."
      }
    ]
  },
  {
    "number": 5703,
    "title": "redisson_delay Prefix disappears",
    "created_at": "2024-03-22T00:56:15Z",
    "closed_at": "2024-05-01T06:53:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5703",
    "body": "I use redission as the delay queue in my project, but after a period of normal operation, the generated delay queue does not have the prefix redisson_delay_queue:, only the queue code given.\r\n< dependency >.\r\n< groupId > org.redisson < / groupId >.\r\n< artifactId > redisson-spring-boot-starter < / artifactId >.\r\n< version > 3.16.2 < / version >.\r\n< / dependency >",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5703/comments",
    "author": "chen9ian9",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-03-29T14:56:51Z",
        "body": "any code example to reproduce it?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-04-10T04:57:39Z",
        "body": "What is the value for Redis `maxmemory-policy` setting?"
      }
    ]
  },
  {
    "number": 5701,
    "title": "Hibernate 2L writes the active Entity to the cache, but it still queries from the database every time.",
    "created_at": "2024-03-21T07:53:12Z",
    "closed_at": "2024-04-16T06:11:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5701",
    "body": "I use Spring Boot 3.2.2 and hibernate version: 6.4.1, I am using Redis cache actively. I'm trying to activate the Hibernate 2L Cache. as I mentioned, it writes to CACHE, **but it still pulls it from the database every time.**\r\n\r\n```\r\n<dependency>\r\n                <groupId>org.redisson</groupId>\r\n                <artifactId>redisson-hibernate-6</artifactId>\r\n                <version>3.27.2</version>\r\n            </dependency>\r\n\r\n```\r\n**application.properties**\r\n```\r\nspring.jpa.properties.hibernate.cache.use_second_level_cache=true\r\nspring.jpa.properties.hibernate.cache.use_query_cache=true\r\nspring.jpa.properties.hibernate.cache.factory_class=org.redisson.hibernate.RedissonRegionFactory\r\n```\r\n\r\n**redisson.yaml**\r\n```\r\nsingleServerConfig:\r\n  address: \"redis://redis.payment:27000\"\r\n```\r\n\r\n**My UserType Entity**\r\n```\r\n@Entity\r\n@Table(name = \"USERTYPE\")\r\n@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)\r\npublic class UserType extends BaseEntity implements Serializable {\r\n    @Id\r\n    @Column\r\n    private Long id;\r\n\r\n    @OneToMany(mappedBy = \"userType\", cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)\r\n    private List<UserTypeTranslate> translateList;\r\n}\r\n\r\n```\r\n\r\n**My UserTypeTranslate Entity**\r\n```\r\n@Entity\r\n@Table(name = \"USERTYPETRANSLATE\")\r\n@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)\r\npublic class UserTypeTranslate extends LanguageEntity implements Serializable {\r\n\r\n    @Id\r\n    @Column(name = \"ID\")\r\n    private Long id;\r\n\r\n    @Column\r\n    private String name;\r\n\r\n    @ManyToOne(fetch = FetchType.LAZY)\r\n    @JoinColumn(name = \"USERTYPEID\", referencedColumnName = \"ID\")\r\n    private UserType userType;\r\n\r\n}\r\n```\r\n\r\n**My Repository class**\r\n```\r\nimport com.payment.data.domain.UserType;\r\nimport com.payment.data.repository.ParameterEntityRepository;\r\nimport org.springframework.data.jpa.repository.JpaSpecificationExecutor;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport java.util.Optional;\r\n\r\n@Repository\r\npublic interface UserTypeRepository\r\n        extends ParameterEntityRepository<UserType, Long>, JpaSpecificationExecutor<UserType> {\r\n    \r\n}\r\n```\r\n\r\n**My Business Service**\r\n```\r\n    public List<UserTypeDto> findAllUserType() {\r\n        List<UserTypeDto> resultList = new ArrayList<>();\r\n        userTypeRepository.findAll().forEach(userType -> resultList.add(userTypeMapper.toDto(userType)));\r\n        return resultList;\r\n    }\r\n\r\n\r\n    public UserTypeDto findById(Long id) {\r\n        UserTypeDto dto = userTypeMapper.toDto(userTypeRepository.findById(id).orElse(null));\r\n        return dto;\r\n    }\r\n\r\n```\r\n\r\n**redis-cli caches**\r\n```\r\n 1) \"com.payment.data.domain.UserTypeTranslate\"\r\n 2) \"redisson__execute_task_once_latch:{com.payment.data.domain.UserType}\"\r\n 3) \"redisson-hibernate-timestamp\"\r\n 4) \"com.payment.data.domain.UserType\"\r\n 5) \"redisson__execute_task_once_latch:{com.payment.data.domain.UserTypeTranslate}\"\r\n```\r\n\r\n\r\n**Log**\r\n**First request**\r\n```\r\n2024-03-21 12:28:32.777  INFO [Payment,231920eac57ccff0dbe1ff94868725d2,1a14515245a5f932] user1 2743744 --- [nio-9101-exec-1] c.a.f.c.i.p.HeaderValidatorInterceptor   : HeaderValidatorInterceptor is running : HeaderValidatorInterceptor\r\n2024-03-21 12:28:32.955 DEBUG [Payment,231920eac57ccff0dbe1ff94868725d2,1706a9885cf4b6b6] user1 2743744 --- [nio-9101-exec-1] o.h.SQL                                  : select ut1_0.id,ut1_0.code,ut1_0.createdate,ut1_0.createuser,ut1_0.updatedate,ut1_0.updateuser,ut1_0.versionid from usertype ut1_0 where ut1_0.id in (?)\r\n2024-03-21 12:28:32.972 TRACE [Payment,231920eac57ccff0dbe1ff94868725d2,1706a9885cf4b6b6] user1 2743744 --- [nio-9101-exec-1] o.h.o.j.bind                             : binding parameter (1:BIGINT) <- [61036]\r\n2024-03-21 12:28:33.081 DEBUG [Payment,231920eac57ccff0dbe1ff94868725d2,640290cfa62e8823] user1 2743744 --- [nio-9101-exec-1] o.h.SQL                                  : select utt1_0.id,utt1_0.createdate,utt1_0.createuser,utt1_0.description,utt1_0.langcode,utt1_0.name,utt1_0.updatedate,utt1_0.updateuser,utt1_0.usertypeid,utt1_0.versionid from usertypetranslate utt1_0 where utt1_0.usertypeid=? and utt1_0.langcode=?\r\n2024-03-21 12:28:33.081 TRACE [Payment,231920eac57ccff0dbe1ff94868725d2,640290cfa62e8823] user1 2743744 --- [nio-9101-exec-1] o.h.o.j.bind                             : binding parameter (1:BIGINT) <- [61036]\r\n2024-03-21 12:28:33.081 TRACE [Payment,231920eac57ccff0dbe1ff94868725d2,640290cfa62e8823] user1 2743744 --- [nio-9101-exec-1] o.h.o.j.bind                             : binding parameter (2:VARCHAR) <- [tr]\r\n2024-03-21 12:28:33.123 DEBUG [Payment,231920eac57ccff0dbe1ff94868725d2,640290cfa62e8823] user1 2743744 --- [nio-9101-exec-1] o.h.c.s.s.AbstractReadWriteAccess        : Caching data from load [region=`com.payment.data.domain.UserTypeTranslate` (AccessType[read-write])] : key[com.payment.data.domain.UserTypeTranslate#53813] -> value[CacheEntry(com.payment.data.domain.UserTypeTranslate)]\r\n2024-03-21 12:28:33.224 DEBUG [Payment,231920eac57ccff0dbe1ff94868725d2,640290cfa62e8823] user1 2743744 --- [nio-9101-exec-1] o.h.c.s.s.AbstractReadWriteAccess        : Checking writeability of read-write cache item [timestamp=`7008291308015616`, version=`0`] : txTimestamp=`7008310529507328`, newVersion=`0`\r\n2024-03-21 12:28:33.224 DEBUG [Payment,231920eac57ccff0dbe1ff94868725d2,640290cfa62e8823] user1 2743744 --- [nio-9101-exec-1] o.h.c.s.s.AbstractReadWriteAccess        : Cache put-from-load [region=`AccessType[read-write]` (com.payment.data.domain.UserTypeTranslate), key=`com.payment.data.domain.UserTypeTranslate#53813`, value=`CacheEntry(com.payment.data.domain.UserTypeTranslate)`] failed due to being non-writable\r\n\r\n```\r\n\r\n**Second request**\r\n```\r\n2024-03-21 12:28:51.111  INFO [Payment,38f2560f55dd64f08dd34dd1b462c76f,1b75b51a041fd34e] user1 2743744 --- [nio-9101-exec-2] c.a.f.c.i.p.HeaderValidatorInterceptor   : HeaderValidatorInterceptor is running : HeaderValidatorInterceptor\r\n2024-03-21 12:28:51.188 DEBUG [Payment,38f2560f55dd64f08dd34dd1b462c76f,e7502958f28a7ef3] user1 2743744 --- [nio-9101-exec-2] o.h.SQL                                  : select ut1_0.id,ut1_0.code,ut1_0.createdate,ut1_0.createuser,ut1_0.updatedate,ut1_0.updateuser,ut1_0.versionid from usertype ut1_0 where ut1_0.id in (?)\r\n2024-03-21 12:28:51.189 TRACE [Payment,38f2560f55dd64f08dd34dd1b462c76f,e7502958f28a7ef3] user1 2743744 --- [nio-9101-exec-2] o.h.o.j.bind                             : binding parameter (1:BIGINT) <- [61036]\r\n2024-03-21 12:28:51.266 DEBUG [Payment,38f2560f55dd64f08dd34dd1b462c76f,063a1bbbe2301ef6] user1 2743744 --- [nio-9101-exec-2] o.h.SQL                                  : select utt1_0.id,utt1_0.createdate,utt1_0.createuser,utt1_0.description,utt1_0.langcode,utt1_0.name,utt1_0.updatedate,utt1_0.updateuser,utt1_0.usertypeid,utt1_0.versionid from usertypetranslate utt1_0 where utt1_0.usertypeid=? and utt1_0.langcode=?\r\n2024-03-21 12:28:51.266 TRACE [Payment,38f2560f55dd64f08dd34dd1b462c76f,063a1bbbe2301ef6] user1 2743744 --- [nio-9101-exec-2] o.h.o.j.bind                             : binding parameter (1:BIGINT) <- [61036]\r\n2024-03-21 12:28:51.266 TRACE [Payment,38f2560f55dd64f08dd34dd1b462c76f,063a1bbbe2301ef6] user1 2743744 --- [nio-9101-exec-2] o.h.o.j.bind                             : binding parameter (2:VARCHAR) <- [tr]\r\n2024-03-21 12:28:51.305 DEBUG [Payment,38f2560f55dd64f08dd34dd1b462c76f,063a1bbbe2301ef6] user1 2743744 --- [nio-9101-exec-2] o.h.c.s.s.AbstractReadWriteAccess        : Caching data from load [region=`com.payment.data.domain.UserTypeTranslate` (AccessType[read-write])] : key[com.payment.data.domain.UserTypeTranslate#53813] -> value[CacheEntry(com.payment.data.domain.UserTypeTranslate)]\r\n2024-03-21 12:28:51.322 DEBUG [Payment,38f2560f55dd64f08dd34dd1b462c76f,063a1bbbe2301ef6] user1 2743744 --- [nio-9101-exec-2] o.h.c.s.s.AbstractReadWriteAccess        : Checking writeability of read-write cache item [timestamp=`7008291308015616`, version=`0`] : txTimestamp=`7008310604443648`, newVersion=`0`\r\n2024-03-21 12:28:51.322 DEBUG [Payment,38f2560f55dd64f08dd34dd1b462c76f,063a1bbbe2301ef6] user1 2743744 --- [nio-9101-exec-2] o.h.c.s.s.AbstractReadWriteAccess        : Cache put-from-load [region=`AccessType[read-write]` (com.payment.data.domain.UserTypeTranslate), key=`com.payment.data.domain.UserTypeTranslate#53813`, value=`CacheEntry(com.payment.data.domain.UserTypeTranslate)`] failed due to being non-writable\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5701/comments",
    "author": "zoroglu",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-03-21T09:24:21Z",
        "body": "can you activate sql trace and share the logs? you can do it with `hibernate.show_sql=true` setting"
      },
      {
        "user": "mrniko",
        "created_at": "2024-03-21T09:25:06Z",
        "body": "Also please set `hibernate.generate_statistics=true`"
      },
      {
        "user": "mrniko",
        "created_at": "2024-03-21T09:25:18Z",
        "body": "Did you set `hibernate.cache.use_query_cache=true` ?"
      },
      {
        "user": "zoroglu",
        "created_at": "2024-03-21T09:26:51Z",
        "body": "I set hibernate.cache.use_query_cache=true. But I forgot to mention this parameter. I will add this parameter to question"
      },
      {
        "user": "zoroglu",
        "created_at": "2024-03-21T09:33:40Z",
        "body": "> can you activate sql trace and share the logs? you can do it with `hibernate.show_sql=true` setting\r\n\r\nI added log to question"
      },
      {
        "user": "mrniko",
        "created_at": "2024-04-16T06:11:23Z",
        "body": "You need to set `hibernate.generate_statistics=true` and find in logs when the entity is got evicted from the cache. It usually caused if it was updated or you execute native SQL queries."
      },
      {
        "user": "srirajk",
        "created_at": "2024-05-10T18:51:01Z",
        "body": "I have the very similar issue and did everything as per documented. Also I am not sure what's the solution or it was accidentally closed?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-12-02T11:54:16Z",
        "body": "@srirajk \r\n\r\nCan you share the configuration?"
      }
    ]
  },
  {
    "number": 5689,
    "title": "why Redisson.java Declare the class as final?",
    "created_at": "2024-03-19T02:43:57Z",
    "closed_at": "2024-03-19T06:33:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5689",
    "body": "redisson 3.17.6  , i write a aspect to monitor api operation,it is work well\r\nexample:\r\n` @Pointcut(\"execution(* org.redisson.api.*.*(..))\")`\r\n\r\nupgrade to 3.27.2 , An error was reported when the application was started：\r\n`Caused by: org.springframework.aop.framework.AopConfigException: Could not generate CGLIB subclass of class org.redisson.Redisson: Common causes of this problem include using a final class or a non-visible class; nested exception is java.lang.IllegalArgumentException: Cannot subclass final class org.redisson.Redisson\r\n\tat org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:208) ~[spring-aop-5.1.6.RELEASE.jar:5.1.6.RELEASE]\r\n\tat org.springframework.aop.framework.ProxyFactory.getProxy(ProxyFactory.java:110) ~[spring-aop-5.1.6.RELEASE.jar:5.1.6.RELEASE]\r\n\tat org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.createProxy(AbstractAutoProxyCreator.java:471) ~[spring-aop-5.1.6.RELEASE.jar:5.1.6.RELEASE]\r\n\tat org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:350) ~[spring-aop-5.1.6.RELEASE.jar:5.1.6.RELEASE]`\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5689/comments",
    "author": "zyong2004",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-03-19T05:30:19Z",
        "body": "To avoid bugs with improperly extended classes."
      },
      {
        "user": "zyong2004",
        "created_at": "2024-03-19T05:57:15Z",
        "body": "Is there an interface that can be used as a monitoring item?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-03-19T06:05:46Z",
        "body": "Redisson object implements RedissonClient interface. You can use it."
      },
      {
        "user": "zyong2004",
        "created_at": "2024-03-19T06:28:57Z",
        "body": "It doesn't work with aop because Redison.java declares the class final"
      },
      {
        "user": "mrniko",
        "created_at": "2024-03-19T06:32:45Z",
        "body": "try to use Delegation pattern"
      }
    ]
  },
  {
    "number": 5665,
    "title": "Redisson RBucket addListener功能没效果",
    "created_at": "2024-03-04T09:29:54Z",
    "closed_at": "2024-03-06T06:40:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5665",
    "body": "RBucket<RedisReqVO> bucketRedisVo = redissonClient.getBucket(\"redisson:bucket:listener:object\");\r\nbucketRedisVo.addListener(new SetObjectListener() {\r\n    @Override\r\n    public void onSet(String name) {\r\n        log.info(\"Key:{} Object设置了\", name);\r\n    }\r\n});\r\n\r\n如上代码，在set值时，监听器没有反应，在redis-cli中也没有查询到相应的topic。是我对RBucket的监听理解有问题吗？",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5665/comments",
    "author": "sunyuanfeng",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-03-06T06:40:39Z",
        "body": "You need to define `notify-keyspace-events` setting in Redis configuration. It may have `KEA` value."
      }
    ]
  },
  {
    "number": 5659,
    "title": "When readMode is used ?",
    "created_at": "2024-02-29T02:57:27Z",
    "closed_at": "2024-04-13T08:09:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5659",
    "body": "Hi\r\nI don't understand when the readMode configuration is used.\r\n\r\nIf I am using 'advanced' redisson object like RBucket, RedissonMap (spring boot cache) ...\r\nwill redisson go to the correct node so I don't get stale data ?\r\nOr will it go to a slave node if readMode is SLAVE, for a 'get' operation and I can get stale data because of the redis replication lag ?\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5659/comments",
    "author": "CyrilDevOps",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-02-29T07:33:38Z",
        "body": "If readMode = SLAVE then getting stale data is possible."
      },
      {
        "user": "Sableng001",
        "created_at": "2024-02-29T09:21:33Z",
        "body": "Maka Data bisa Di gunakan kembali"
      }
    ]
  },
  {
    "number": 5654,
    "title": "Redis Scaling Issue with Redisson Client",
    "created_at": "2024-02-24T21:51:33Z",
    "closed_at": "2024-02-28T10:27:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5654",
    "body": "We are running a delayed queue in redis using redisson client. We are using a t3.small elastcache instance and our application has redisson version 3.23.5 with Spring boot 3.x and Java 17.\r\nWe are not setting any TTL for our records. Our records go to a blocking queue once its delay period is over. We are seeing high CPU spikes when there is increase in traffic to Redis. How can we mitigate this? \r\nI tried using replicas and clustered mode but apparently they are not working here.\r\n\r\nMy redis config-\r\n`CommandsLoadBalancer loadBalancer = new CommandsLoadBalancer();\r\n    loadBalancer.setAddress(\"redis://test-0001-002.qqqq.0001.aps1.cache.amazonaws.com:6379\");\r\n    loadBalancer.setCommands(\r\n        List.of(RedisCommands.READONLY.getName(), RedisCommands.LPOP.getName(), RedisCommands.BLPOP_VALUE.getName()));\r\n    redisConfig\r\n        .useClusterServers()\r\n        .setScanInterval(2000)\r\n        .setConnectTimeout(5000)\r\n        .setIdleConnectionTimeout(5000)\r\n        .setTimeout(10000)\r\n        .setFailedSlaveReconnectionInterval(1000)\r\n        .setRetryAttempts(5)\r\n        .setRetryInterval(2000)\r\n        .setLoadBalancer(loadBalancer)\r\n//        .setLoadBalancer(new WeightedRoundRobinBalancer())\r\n        .setReadMode(ReadMode.SLAVE)\r\n        .addNodeAddress(\"redis://test-0001-001.qqqq.0001.aps1.cache.amazonaws.com:6379\")\r\n        .addNodeAddress(\"redis://test-0001-002.qqqq.0001.aps1.cache.amazonaws.com:6379\");\r\n\r\n    redisConfig\r\n        .setTransportMode(TransportMode.NIO)\r\n        .setThreads(64)\r\n        .setNettyThreads(128);\r\n    return Redisson.create(redisConfig);`\r\n\r\nMy redis code-\r\n`public TestRedisDelay(RedissonClient managedClient, String queuePrefix, ObjectMapper objectMapper) {\r\n    this.destinationQueue = managedClient.getBlockingQueue(queuePrefix + \"test\");\r\n    this.delayedQueue = managedClient.getDelayedQueue(this.destinationQueue);\r\n\r\n    this.objectMapper = objectMapper;\r\n  }\r\n\r\npublic void pushToDelayedQueue(TestRequest testRequest) {\r\n      try {\r\n        String jsonTestRequest = objectMapper.writeValueAsString(testRequest);\r\n        this.delayedQueue.offer(jsonTestRequest, 5L, TimeUnit.MINUTES);\r\n      } catch (Exception e) {\r\n        log.error(\"ERR_CONVERTING_TO_JSON_NODE :: {} :: REQ- {}\", e.getMessage(), testRequest);\r\n      }\r\n  }\r\n\r\npublic TestRequest fetchRequests() {\r\n      TestRequest testRequest = null;\r\n      try {\r\n        String revampedQueueRequest = destinationQueue.poll();\r\n        if(!Strings.isEmpty(revampedQueueRequest)) {\r\n          testRequest = objectMapper.readValue(revampedQueueRequest, TestRequest.class);\r\n        }\r\n      } catch (Exception e) {\r\n        log.error(\"ERR_FETCHING FROM QUEUE :: {}\", e.getMessage());\r\n      }\r\n\r\n    return testRequest;\r\n  }`\r\n\r\nCan someone please suggest anything?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5654/comments",
    "author": "Alok-Kumar-9",
    "comments": [
      {
        "user": "Alok-Kumar-9",
        "created_at": "2024-02-24T21:53:02Z",
        "body": "Also I am not able to perform read operations from slave/secondary node of redis cluster. I wanted to it for better performance. However I know it is not a good practice."
      },
      {
        "user": "mrniko",
        "created_at": "2024-02-26T06:52:27Z",
        "body": "CommandsLoadBalancer won't help here since LPOP and BLPOP_VALUE commands are always executed on master. try to add more master nodes."
      },
      {
        "user": "Alok-Kumar-9",
        "created_at": "2024-02-26T12:26:20Z",
        "body": "@mrniko \r\nAs far as I have read and understood, redis delayed queues are internally created as a sorted set and list. And the sorted set always lies on only one shard. So how will horizontal scaling ie, adding more shards/master nodes help here?\r\n\r\nOr is there any other way to add more master nodes in a single shard only?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-02-28T10:25:32Z",
        "body": "> So how will horizontal scaling ie, adding more shards/master nodes help here?\r\n\r\nYes."
      }
    ]
  },
  {
    "number": 5651,
    "title": "Exception in redission netty thread throw java.lang.OutOfMemoryError: Java heap space",
    "created_at": "2024-02-23T14:17:29Z",
    "closed_at": "2024-03-08T10:26:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5651",
    "body": "Hi Guys,\r\n\r\nI am using redis: 3.26.0 using JSON config with a single redis instance (I am using OpenJDK 17). After running for many hours, I get a crash with the following exception. What could be the cause? Is it due to some bug in redisson OR wrong configurations?\r\n\r\n`21-Feb-2024 21:04:09.134 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [\"http-nio-8081\"]\r\n21-Feb-2024 21:04:09.144 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [\"https-openssl-nio2-0.0.0.0-8443\"]\r\n21-Feb-2024 21:04:09.146 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in [100710] milliseconds\r\nAssertion failed: jSessionInfoObject != 0, file ../../common/src/util_conversion.c, line 1002\r\nException in thread \"http-nio-8081-Poller\" java.lang.OutOfMemoryError: Java heap space\r\n22-Feb-2024 04:23:53.506 SEVERE [http-nio-8081-exec-25824] org.apache.coyote.AbstractProtocol$ConnectionHandler.process Failed to complete processing of a request\r\n\tjava.lang.OutOfMemoryError: Java heap space\r\nException in thread \"redisson-netty-1-6\"`\r\n\r\nConfig\r\n-------------\r\n {\r\n\t\"singleServerConfig\": {\r\n\t\t\"idleConnectionTimeout\": 20000,\r\n\t\t\"connectTimeout\": 15000,\r\n\t\t\"timeout\": 3000,\r\n\t\t\"retryAttempts\": 3,\r\n\t\t\"retryInterval\": 1000,\r\n\t\t\"pingConnectionInterval\": 10000,\r\n\t\t\"password\": null,\r\n\t\t\"subscriptionsPerConnection\": 5,\r\n\t\t\"clientName\": null,\r\n\t\t\"address\": \"redis://192.168.103.71:6379\",\r\n\t\t\"subscriptionConnectionMinimumIdleSize\": 1,\r\n\t\t\"subscriptionConnectionPoolSize\": 50,\r\n\t\t\"connectionMinimumIdleSize\": 10,\r\n\t\t\"connectionPoolSize\": 64,\r\n\t\t\"database\": 0,\r\n\t\t\"dnsMonitoringInterval\": 5000\r\n\t},\r\n\t\"threads\": 16,\r\n\t\"nettyThreads\": 32,\r\n\t\"codec\": null\r\n}\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5651/comments",
    "author": "maliksajidhussain",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-02-24T05:55:35Z",
        "body": "I need a memory dump. Without that it's hard to know the cause."
      }
    ]
  },
  {
    "number": 5648,
    "title": "订阅消失",
    "created_at": "2024-02-23T04:25:06Z",
    "closed_at": "2024-02-23T08:16:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5648",
    "body": "\r\nredission 版本： redisson-all-3.16.1\r\n出现的问题： 订阅了9个通道，   运行过程中莫名的消失了4个，  只留下5个。   重启后恢复   运行一段时间就又丢了4个   每次丢的是固定的4个。  为什么 怎么解决",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5648/comments",
    "author": "flybh521",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-02-23T08:16:23Z",
        "body": "Fixed in 3.19.0 version"
      }
    ]
  },
  {
    "number": 5633,
    "title": "Will already authenticated connections continue to work after refreshing credentials via credentialsResolver dynamically? ",
    "created_at": "2024-02-14T22:13:57Z",
    "closed_at": "2024-02-15T07:20:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5633",
    "body": "Will already authenticated connections continue to work after refreshing credentials via credentialsResolver dynamically? \r\n\r\nThe javadoc for credentialsResolver say, so my question is will already authenticated old connections continue to work when the password is rotated?\r\n\r\n```\r\n* Credentials resolver object which is invoked during connection/reconnection process.\r\n * It makes possible to specify dynamically changing Redis credentials.\r\n ```\r\nWhen using retryAttempts > 1, for example the old connection stopped working due to expired credentials, will Redission internally create new connection by calling resolve() method before throwing exception to client? ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5633/comments",
    "author": "rgampa",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-02-15T07:20:28Z",
        "body": "> will already authenticated old connections continue to work when the password is rotated?\r\n\r\nOn WRONGPASS error a connection will be reconnected with authentication data got from credentialsResolver. It was fixed in 3.26.0 version."
      }
    ]
  },
  {
    "number": 5629,
    "title": "Time to live for cache",
    "created_at": "2024-02-13T17:59:01Z",
    "closed_at": "2024-02-19T11:00:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5629",
    "body": "As per current implementation time to live uses the milliseconds and internally in the code, t is being converted into Integer value.\r\nThe issue here is we need to set the cahce for 1 week or 1 day , in both cases the milisec conversion can breach the value of max int value. So is there any fix for it \r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5629/comments",
    "author": "DEEP-GIT-RCI",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-02-14T13:39:20Z",
        "body": "Which API method do you mean?\r\n\r\nDuration is converted to a long value"
      }
    ]
  },
  {
    "number": 5606,
    "title": "RLocalCachedMap ttl and eviction ",
    "created_at": "2024-02-01T23:34:27Z",
    "closed_at": "2024-04-16T06:17:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5606",
    "body": "I use RLocalCachedMap in my spring boot application to boost the performance. One thing I observed when I’m writing my unit test is in order to make ttl or max idle time working, I need to set a value (> 0) to the cache size. The ttl or max idle time settings will only kick in when the cache is full and a new entry is added. Is this the intended behavior?\r\n\r\nSetting the cache size to 0 doesn’t seem to activate the ttl and max idle time behavior. The RLocalCachedMap.cachemap.size will keep increasing.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5606/comments",
    "author": "cgpoh",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-04-16T06:17:57Z",
        "body": "> Is this the intended behavior?\r\n\r\nYes.\r\n\r\nYou can use CAFFEINE local cache implementation instead.\r\n\r\n```java\r\nLocalCachedMapOptions opts = LocalCachedMapOptions.name(\"test\").cacheProvider(CacheProvider.CAFFEINE);\r\n```"
      }
    ]
  },
  {
    "number": 5602,
    "title": "org.redisson.client.RedisTimeoutException: Command still hasn't been written into connection!",
    "created_at": "2024-02-01T11:00:09Z",
    "closed_at": "2024-02-15T08:43:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5602",
    "body": "报错日志：\r\n2024-01-25 00:00:11 [schedule-pool-2] ERROR o.s.s.s.TaskUtils$LoggingErrorHandler - Unexpected error occurred in scheduled task\r\norg.springframework.dao.QueryTimeoutException: Command still hasn't been written into connection! Check connection with Redis node: 172.30.0.48/172.30.0.48:6379 for TCP packet drops. Try to increase nettyThreads setting.  Node source: NodeSource [slot=null, addr=null, redisClient=[addr=redis://172.30.0.48:6379], redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=30, freeConnectionsCounter=value:98:queue:0, freezeReason=null, client=[addr=redis://172.30.0.48:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1677992605 [redisClient=[addr=redis://172.30.0.48:6379], channel=[id: 0x668c97e9, L:/172.30.0.64:57798 - R:172.30.0.48/172.30.0.48:6379], currentCommand=null, usage=1], command: (SCAN), params: [92, MATCH, apollo_heart_beat*, COUNT, 10] after 3 retry attempts; nested exception is org.redisson.client.RedisTimeoutException: Command still hasn't been written into connection! Check connection with Redis node: 172.30.0.48/172.30.0.48:6379 for TCP packet drops. Try to increase nettyThreads setting.  Node source: NodeSource [slot=null, addr=null, redisClient=[addr=redis://172.30.0.48:6379], redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=30, freeConnectionsCounter=value:98:queue:0, freezeReason=null, client=[addr=redis://172.30.0.48:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1677992605 [redisClient=[addr=redis://172.30.0.48:6379], channel=[id: 0x668c97e9, L:/172.30.0.64:57798 - R:172.30.0.48/172.30.0.48:6379], currentCommand=null, usage=1], command: (SCAN), params: [92, MATCH, apollo_heart_beat*, COUNT, 10] after 3 retry attempts\r\n\tat org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:48)\r\n\tat org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:35)\r\n\tat org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:44)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.transform(RedissonConnection.java:204)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.syncFuture(RedissonConnection.java:199)\r\n\tat org.redisson.spring.data.connection.RedissonConnection$1.doScan(RedissonConnection.java:281)\r\n\tat org.springframework.data.redis.core.ScanCursor.scan(ScanCursor.java:90)\r\n\tat org.springframework.data.redis.core.ScanCursor.hasNext(ScanCursor.java:184)\r\n\tat com.city.lidar.schedule.ApolloCheckStatus.lambda$getKeysWithPrefix$0(ApolloCheckStatus.java:93)\r\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:224)\r\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:191)\r\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:178)\r\n\tat com.city.lidar.schedule.ApolloCheckStatus.getKeysWithPrefix(ApolloCheckStatus.java:98)\r\n\tat com.city.lidar.schedule.ApolloCheckStatus.checkStatus(ApolloCheckStatus.java:107)\r\n\tat sun.reflect.GeneratedMethodAccessor219.invoke(Unknown Source)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.springframework.scheduling.support.ScheduledMethodRunnable.run(ScheduledMethodRunnable.java:84)\r\n\tat org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54)\r\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\r\n\tat java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: org.redisson.client.RedisTimeoutException: Command still hasn't been written into connection! Check connection with Redis node: 172.30.0.48/172.30.0.48:6379 for TCP packet drops. Try to increase nettyThreads setting.  Node source: NodeSource [slot=null, addr=null, redisClient=[addr=redis://172.30.0.48:6379], redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=30, freeConnectionsCounter=value:98:queue:0, freezeReason=null, client=[addr=redis://172.30.0.48:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1677992605 [redisClient=[addr=redis://172.30.0.48:6379], channel=[id: 0x668c97e9, L:/172.30.0.64:57798 - R:172.30.0.48/172.30.0.48:6379], currentCommand=null, usage=1], command: (SCAN), params: [92, MATCH, apollo_heart_beat*, COUNT, 10] after 3 retry attempts\r\n\tat org.redisson.command.RedisExecutor$1.run(RedisExecutor.java:253)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715)\r\n\tat io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790)\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\t... 1 common frames omitted\r\n\r\n\r\n### **version：**\r\nredisson：3.17.6\r\n\r\n\r\n**### redis config：**\r\nredisson:\r\n  keyPrefix:\r\n  threads: 16\r\n  nettyThreads: 32\r\n  transportMode: \"NIO\"\r\n  singleServerConfig:\r\n    clientName: nnn\r\n    connectionMinimumIdleSize: 32\r\n    connectionPoolSize: 100\r\n    idleConnectionTimeout: 10000\r\n    timeout: 3000\r\n    retryAttempts: 3\r\n    retryInterval: 1500\r\n    subscriptionConnectionMinimumIdleSize: 1\r\n    subscriptionConnectionPoolSize: 50\r\n    subscriptionsPerConnection: 5\r\n    dnsMonitoringInterval: 5000\r\n\r\n\r\n\r\n The above error logic is executed in a scheduled task, but I am not sure if it is due to this issue.\r\nAfter a scan request error occurs, all subsequent errors are the same. I searched for the answer on the issues page, but couldn't find it. But it is unclear whether this issue has been fixed,\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5602/comments",
    "author": "tianheilea",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-02-15T08:43:41Z",
        "body": "Try to increase nettyThreads setting"
      }
    ]
  },
  {
    "number": 5598,
    "title": "How Redisson handles connections to AWS elasticache read replica when it goes under patching/maintenance",
    "created_at": "2024-01-31T03:40:07Z",
    "closed_at": "2024-02-08T11:39:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5598",
    "body": "if AWS elasticache read replica is under patching/maintenance, would redisson automatically divert the requests to other replica or master node?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5598/comments",
    "author": "gargniks",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-02-08T11:39:21Z",
        "body": "Yes. As soon as new topology will be discovered."
      }
    ]
  },
  {
    "number": 5578,
    "title": "org.redisson.client.WriteRedisConnectionException: Unable to write command into connection!",
    "created_at": "2024-01-20T15:54:24Z",
    "closed_at": "2024-06-06T07:00:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5578",
    "body": "Hi All,\r\n\r\nPlease let me know who can help me on this.\r\n\r\nI have EKS cluster\r\nRedis master -1 pod\r\nRedis Replica -1 pod\r\napplication pods are 2\r\nPostgress db is also there\r\n\r\nI will be keep on getting below error in redis replica pods and master is unable to connect to redis. Application gets failing and we have netflix conductor whose workflows keeps on failing and struck. Please let me know the fix.\r\nError:\r\n\r\norg.redisson.client.WriteRedisConnectionException: Unable to write command into connection!\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5578/comments",
    "author": "RafiyaB",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-06-06T07:00:02Z",
        "body": "You need to check the network and Redis configuration."
      }
    ]
  },
  {
    "number": 5575,
    "title": "RedissonDelayedQueue stop transfer timeout elements to destination queue",
    "created_at": "2024-01-19T05:06:20Z",
    "closed_at": "2024-12-23T11:10:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5575",
    "body": "After using for a while, the RedissonDelayedQueue stop work。All added elements are backlogged in the queue，even if many elements have already timeout。 When I restarted the application，all the elements will transfer to the destination queue。\r\nThe code is as follows\r\n\r\n```\r\n   @PostConstruct\r\n    private void init() {\r\n           StringCodec codec = new StringCodec();\r\n           rBlockingQueue = redissonClient.getBlockingQueue(\"xxx\", codec);\r\n           delayedQueue = redissonClient.getDelayedQueue(rBlockingQueue);\r\n           ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2);\r\n           executorService.scheduleAtFixedRate(this::executeDelayJob, 60, 15, TimeUnit.SECONDS);\r\n    }\r\n\r\n    private void executeDelayJob() {\r\n            String xxx = rBlockingQueue.poll();\r\n    }\r\n```\r\n\r\nI try to used \r\n`pubsub numsub redisson_delay_queue_channel:{xxx}`\r\n`redisson_delay_queue_channel:{xxx}`\r\n`(integer) 0`\r\n\r\nfind that redission client and redis subscriptions are disconnected, it caused RedissonDelayedQueue stop work\r\nMy Redisson version is 3.11.0",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5575/comments",
    "author": "lzy-125",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-12-23T11:10:22Z",
        "body": "It can be connected to the issues with topic resubscription which were fixed in 3.13.1, 3.16.5, 3.19.0. \r\n\r\nTry 3.19.0 or higher version."
      }
    ]
  },
  {
    "number": 5563,
    "title": "Two different threads have reported acquiring a lock with the same key  at the same time",
    "created_at": "2024-01-14T10:23:42Z",
    "closed_at": "2024-01-16T05:56:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5563",
    "body": "Redisson version :\r\n```\r\n<dependency>\r\n    <groupId>org.redisson</groupId>\r\n    <artifactId>redisson-spring-boot-starter</artifactId>\r\n    <version>3.17.4</version>\r\n</dependency>\r\n```\r\n        \r\nHere is my code:\r\n\r\n```\r\nprivate void generate() {\r\n        RLock lock = redisson.getLock(key);\r\n        try {\r\n            String threadName = Thread.currentThread().getName();\r\n            boolean locked = lock.tryLock();\r\n            if (locked && shouldGenerateTask() {\r\n                log.info(\"locked by key:{} with thread：{}\", key, threadName);\r\n                saveTask();\r\n            }\r\n        } catch (Exception e) {\r\n            Thread.currentThread().interrupt();\r\n        } finally {\r\n            if (lock.isHeldByCurrentThread()) {\r\n                lock.unlock();\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n2024-01-12T12:00:07.514288425Z 2024-01-12 12:00:07.514  INFO 7 --- [  XNIO-1 task-4] .s.p.a.t.c.h.i.test : locked by key:App:Procurement:PENDING_PRICING:1400_65_2 with thread：XNIO-1 task-4\r\n\r\n2024-01-12T12:00:07.542088285Z 2024-01-12 12:00:07.541  INFO 7 --- [  XNIO-1 task-2] .s.p.a.t.c.h.i.test : locked by key:App:Procurement:PENDING_PRICING:1400_65_2 with thread：XNIO-1 task-2",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5563/comments",
    "author": "OuDale",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-01-15T07:28:32Z",
        "body": "Please share the code to reproduce the issue. "
      },
      {
        "user": "mrniko",
        "created_at": "2024-01-15T07:29:30Z",
        "body": "Make sure that the lock wasn't unlocked by the time when the second thread acquired it."
      },
      {
        "user": "OuDale",
        "created_at": "2024-01-15T08:42:49Z",
        "body": "> Make sure that the lock wasn't unlocked by the time when the second thread acquired it.\r\n\r\nThanks reply,  \r\n1. the log shows that the two threads acquired the lock in a very short period of time. I don't think it is the case of releasing and acquiring the lock again.\r\n2. I didn't assigned a leaseTime and unlocked in finally body.\r\n\r\n\r\n```\r\nprivate void generate() {\r\n        RLock lock = redisson.getLock(key);\r\n        try {\r\n            String threadName = Thread.currentThread().getName();\r\n            boolean locked = lock.tryLock();\r\n            if (locked && shouldGenerateTask() {\r\n                log.info(\"locked by key:{} with thread：{}\", key, threadName);\r\n                saveTask();\r\n            }\r\n        } catch (Exception e) {\r\n            Thread.currentThread().interrupt();\r\n        } finally {\r\n            if (lock.isHeldByCurrentThread()) {\r\n                lock.unlock();\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n```\r\n2024-01-12T12:00:07.514288425Z 2024-01-12 12:00:07.514 INFO 7 --- [ XNIO-1 task-4] .s.p.a.t.c.h.i.test : locked by key:App:Procurement:PENDING_PRICING:1400_65_2 with thread：XNIO-1 task-4\r\n\r\n2024-01-12T12:00:07.542088285Z 2024-01-12 12:00:07.541 INFO 7 --- [ XNIO-1 task-2] .s.p.a.t.c.h.i.test : locked by key:App:Procurement:PENDING_PRICING:1400_65_2 with thread：XNIO-1 task-2\r\n```"
      },
      {
        "user": "OuDale",
        "created_at": "2024-01-15T08:51:20Z",
        "body": "This is occurring in a concurrent scenario where the real situation involves listening to a database change data capture (CDC). Then, two threads simultaneously acquire the lock and save two separate task data."
      },
      {
        "user": "mrniko",
        "created_at": "2024-01-15T08:55:15Z",
        "body": "Can you add `log.info(\"unlocked1 by key:{} with thread：{}\", key, threadName);` after `if (lock.isHeldByCurrentThread()) {`\r\n\r\nadd `log.info(\"unlocked2 by key:{} with thread：{}\", key, threadName);` after `lock.unlock();`"
      },
      {
        "user": "OuDale",
        "created_at": "2024-01-16T02:20:15Z",
        "body": "thanks for your help"
      }
    ]
  },
  {
    "number": 5557,
    "title": "Problem with ZSet expiring",
    "created_at": "2024-01-10T11:55:35Z",
    "closed_at": "2024-01-12T14:46:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5557",
    "body": "Redis version - 6.2.4\r\nRedisson version - 3.17.7\r\n\r\nWe encountered a problem when the service was rebooted, the `ZSet` keys in Redis stopped expiring. We are using the reactive implementation of `RSetCache`. I believe this is because data about the keys being examined is lost. But for example, for the `Hash` structure in Redis, the data is stored in `redisson__timeout__set`. Why isn't there something like this for `ZCache`? Could u help us to solve the problem?\r\n\r\n```\r\n  private RSetCacheReactive<HistoryMessage> getOrCreateCache(String key) {\r\n        return client.reactive().getSetCache(HISTORY_MESSAGE_CACHE + key, codec);\r\n    }\r\n\r\n  public Mono<Boolean> add(@NonNull HistoryMessage message) {\r\n        return getOrCreateCache(generateKey(message)).add(message, config.getTtl(), config.getUnit());\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5557/comments",
    "author": "immmus",
    "comments": [
      {
        "user": "immmus",
        "created_at": "2024-01-11T09:05:30Z",
        "body": "@mrniko Hello!\r\nIn our case, we have many ZSet's which don't update or update rarely. In most of cases the data is read and waited for eviction. ttl = 14 DAYS.\r\nI noticed that when new data is added to a set, outdated data is evicted, but in our case, sets may never be updated again, but wait until the end of their life. Because of this, our cache is overflowing.\r\nPerhaps you can advise us on some solution to this case or suggest another data structure to solve this problem?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-01-12T08:33:36Z",
        "body": "@immmus \r\n\r\nYou need to invoke getSetCache() per name at least once after restart. Since eviction is scheduled in this method call."
      },
      {
        "user": "immmus",
        "created_at": "2024-01-12T08:36:43Z",
        "body": "> @immmus\r\n> \r\n> You need to invoke getSetCache() per name at least once after restart. Since eviction is scheduled in this method call.\r\n\r\nOkay, but what if there are millions of names?;)"
      },
      {
        "user": "mrniko",
        "created_at": "2024-01-12T09:20:08Z",
        "body": "> Okay, but what if there are millions of names?;)\r\n\r\nThere is SetCacheV2 structure which handles this case, but it's available only in PRO version."
      },
      {
        "user": "immmus",
        "created_at": "2024-01-12T09:28:22Z",
        "body": "> > Okay, but what if there are millions of names?;)\r\n> \r\n> There is SetCacheV2 structure which handles this case, but it's available only in PRO version.\r\n\r\nI see this is a pity. If I were you, I would clarify all these implications in the documentation. I think many people encounter these issues only when using your library, although you have a checkmark in the eviction column, although this does not work properly. \r\n\r\nThank you for answers."
      },
      {
        "user": "mrniko",
        "created_at": "2024-01-12T09:55:13Z",
        "body": "Thank you for your feedback. I have add the description of `entry eviction`  and `advanced entry eviction` features."
      }
    ]
  },
  {
    "number": 5544,
    "title": "In read-write separation mode, how to ensure that the data read is the latest?",
    "created_at": "2024-01-02T10:10:05Z",
    "closed_at": "2024-04-13T08:10:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5544",
    "body": "Hello everyone, does redission support the scenario of writing first and then reading data immediately in the same thread like Apache ShardingSphere, forcing the data to be read from the main library? This is done to solve the problem that the delay in master-slave replication data causes the read operation to obtain data that is not the latest.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5544/comments",
    "author": "liuxinwen",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-01-04T04:33:03Z",
        "body": "you can do it with RBucket.getAndSet() method"
      }
    ]
  },
  {
    "number": 5539,
    "title": "  In scenarios where network jitter leads to connection interruption, the code logic cannot continue after reconnection",
    "created_at": "2023-12-29T03:00:11Z",
    "closed_at": "2024-04-18T05:48:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5539",
    "body": "Expected behavior：\r\nWhen network recovers，redisson re-establish the connection and continue the code logic.\r\n\r\nActual behavior:\r\nWhen network recovers and the connection has been re-establish, The detailed error report is as follows:\r\n```\r\n[redisson-timer-4-1] ERROR org.redisson.client.handler.PingConnectionHandler - Unable to send PING command over channel: [id: 0xa3c219f7, L:/10.0.16.8:44854 - R:10.0.16.6/10.0.16.6:6379]\r\norg.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://10.0.16.6:6379]\r\n        at org.redisson.client.RedisConnection.lambda$async$0(RedisConnection.java:256)\r\n        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715)\r\n        at io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34)\r\n        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703)\r\n        at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790)\r\n        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.base/java.lang.Thread.run(Thread.java:829)\r\n...(many 'Unable to send PING command over channel' errors)...\r\n[redisson-timer-4-1] ERROR org.redisson.client.handler.PingConnectionHandler - Unable to send PING command over channel: [id: 0xf94ff1c0, L:/10.0.16.8:45156 - R:10.0.16.6/10.0.16.6:6379]\r\norg.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://10.0.16.6:6379]\r\n        at org.redisson.client.RedisConnection.lambda$async$0(RedisConnection.java:256)\r\n        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715)\r\n        at io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34)\r\n        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703)\r\n        at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790)\r\n        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.base/java.lang.Thread.run(Thread.java:829)\r\n[redisson-timer-4-1] ERROR org.redisson.cluster.ClusterConnectionManager - Unable to execute (CLUSTER NODES)\r\norg.redisson.client.RedisTimeoutException: Command execution timeout for command: (CLUSTER NODES), params: [], Redis client: [addr=redis://10.0.16.6:6379]\r\n        at org.redisson.client.RedisConnection.lambda$async$0(RedisConnection.java:256)\r\n        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715)\r\n        at io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34)\r\n        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703)\r\n        at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790)\r\n        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.base/java.lang.Thread.run(Thread.java:829)\r\n```\r\n\r\nHere is my test code:\r\n```Java\r\npackage org.example;\r\nimport org.redisson.Redisson;\r\nimport org.redisson.api.RAtomicLong;\r\nimport org.redisson.api.RedissonClient;\r\nimport org.redisson.config.Config;\r\nimport org.redisson.connection.balancer.RoundRobinLoadBalancer;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws IOException {\r\n        Config config = Config.fromYAML(new File(\"/data/home/sharmaxia/redissontest/src/main/resources/config-file.yaml\"));\r\n        RedissonClient redisson = Redisson.create(config);\r\n        int i = 0;\r\n        while(i++ < 1000000){\r\n            RAtomicLong atomicLong = redisson.getAtomicLong(Integer.toString(i));\r\n            atomicLong.getAndDecrement();\r\n        }\r\n        redisson.shutdown();\r\n    }\r\n}\r\n```\r\n\r\nAnd the config:\r\n```\r\nclusterServersConfig:\r\n  idleConnectionTimeout: 10000\r\n  connectTimeout: 10000\r\n  timeout: 3000\r\n  retryAttempts: 3\r\n  retryInterval: 1500\r\n  password: ********\r\n  loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}\r\n  nodeAddresses:\r\n    - \"redis://10.0.16.6:6379\"\r\n  scanInterval: 1000\r\nthreads: 0\r\nnettyThreads: 0\r\ncodec: !<org.redisson.codec.JsonJacksonCodec> {}\r\ntransportMode: NIO\r\nlockWatchdogTimeout: 30000\r\nkeepPubSubOrder: true\r\n```\r\n\r\nThe issue can be reproduced by using the following command to simulate network interruption and recovering:\r\n```\r\nsudo iptables -A INPUT -s 10.0.16.6 -p tcp --sport 6379 -m conntrack --ctstate NEW,ESTABLISHED -j DROP\r\n\r\nsudo iptables -D INPUT -s 10.0.16.6 -p tcp --sport 6379 -m conntrack --ctstate NEW,ESTABLISHED -j DROP\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5539/comments",
    "author": "sharmaxia",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-04-18T05:48:36Z",
        "body": "These errors happen only for a short period of time after network interruption."
      }
    ]
  },
  {
    "number": 5532,
    "title": "Several different errors like SlaveConnectionPool no available entries, NOAUTH and slaves added\\remove events cause connection issues.",
    "created_at": "2023-12-24T00:23:01Z",
    "closed_at": "2025-01-16T12:05:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5532",
    "body": "Hey,\r\n\r\nI saw that similar issues have been addressed recently but seems we're keep facing them with redisson version 3.24.1 where they were fixed.\r\n\r\nWe use AWS elasticache with clustered mode and autoscaling.\r\n\r\nThis is our redisson config:\r\n```\r\n          config\r\n              .useClusterServers()\r\n              .addNodeAddress(\r\n                  getAddress(redisProperties.getHost(), redisProperties.getPort()));\r\n```\r\n\r\nWe use defaults for master\\slave connection pool sizes.\r\n\r\nI believe that all these issues are related so I list them here:\r\n1. We constantly see that slaves are added and removed:\r\n```\r\nslave: rediss://xx.xx.xx.xx:6379 added for slot ranges: [[3243-11434]]\r\n24 connections initialized for xx.xx.xx.xx/xx.xx.xx.xx:6379\r\nslave rediss://xx.xx.xx.xx:6379 removed for slot ranges: [[3243-11434]]\r\nslave: rediss://xx.xx.xx.xx:6379 added for slot ranges: [[3243-11434]]\r\n24 connections initialized for xx.xx.xx.xx/xx.xx.xx.xx:6379\r\nslave rediss://xx.xx.xx.xx:6379 removed for slot ranges: [[3243-11434]]\r\n```\r\nWe see these messages regardless of any actual failovers or slot rebalancing in elasticache, NODE LIST keeps resulting in the same output but these messages keep showing, sometimes as frequently as every couple of minutes.\r\n\r\n2. Whenever there is a \"removed for slot ranges\" message without subsequent \"added for slot ranges\" message we start getting NOAUTH connection errors:\r\n```\r\norg.redisson.client.RedisAuthRequiredException: NOAUTH Authenticati.. .2.1.9.1.1.1.1.1.1.u.concurrent.CompletableFuture@38703397[Not completed, 2 dependents], command=(READONLY), params=[], codec=null]\r\n\t... 32 common frames omitted\r\nWrapped by: java.util.concurrent.CompletionException: org.redisson.client.RedisAuthRequiredException: NOAUTH Authenticati.. .2.1.9.1.1.1.1.1.1.u.concurrent.CompletableFuture@38703397[Not completed, 2 dependents], command=(READONLY), params=[], codec=null]\r\n\tat j.b.u.c.CompletableFuture.encodeThrowable(CompletableFuture.java:331)\r\n\tat j.b.u.c.CompletableFuture.completeThrowable(CompletableFuture.java:346)\r\n\tat j.b.u.c.CompletableFuture$BiRelay.tryFire(CompletableFuture.java:1423)\r\n\tat j.b.u.c.CompletableFuture.postComplete(CompletableFuture.java:506)\r\n\tat j.b.u.c.CompletableFuture.completeExceptionally(CompletableFuture.java:2094)\r\n\tat o.r.client.protocol.CommandData.tryFailure(CommandData.java:87)\r\n\tat o.r.c.handler.CommandDecoder.decode(CommandDecoder.java:368)\r\n\tat o.r.c.handler.CommandDecoder.decodeCommand(CommandDecoder.java:205)\r\n\tat o.r.c.handler.CommandDecoder.decode(CommandDecoder.java:144)\r\n\tat o.r.c.handler.CommandDecoder.decode(CommandDecoder.java:120)\r\n\tat i.n.h.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:529)\r\n\tat i.n.h.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat i.n.h.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)\r\n\tat i.n.c.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)\r\n\tat i.n.c.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\n\tat i.n.c.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\r\n\tat io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1382)\r\n\tat io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1245)\r\n\tat io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1294)\r\n```\r\n`Unable to unfreeze entry: [freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:64:queue:0, freeConnectionsAmount=0, freeConnectionsCounter=value:78:queue:0, freezeReason=MANAGER, client=[addr=rediss://xx.xx.xx.xx:6379], nodeType=SLAVE] attempt: 1 of 3`\r\n\r\nWe use a credential resolver in our redisson config which makes the password to be sent with each request so I doubt that this NOAUTH message is the actual issue here.\r\n\r\n3. We see plenty of `org.redisson.client.RedisConnectionException: SlaveConnectionPool no available Redis entries` which I guess is the result of issues 1 + 2.\r\n\r\nIt seems that this issue happens mostly during high loads, after restarts it seems to go away until the next time.\r\n\r\nFrom some reading I did here in other issues, I understand that it might be some DNS related issue, if that's actually it:\r\n1. We have around 12 pods with redisson clients running, these errors occur usually in 1-2 pods and not in the others, how come DNS works properly in some and not in others?\r\n2. Will the usage of SequentialDnsAddressResolverFactory with non default concurrency level help here? Do I also need to set a ttl for netty dns cache? \r\n\r\nThanks.\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5532/comments",
    "author": "yizmailovSF",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-12-25T12:18:10Z",
        "body": "Hello,\r\n\r\n> Will the usage of SequentialDnsAddressResolverFactory with non default concurrency level help here? \r\n\r\nYes, it can help. Try to pass 1 to its constructor."
      },
      {
        "user": "yizmailovSF",
        "created_at": "2023-12-25T12:45:44Z",
        "body": "> Hello,\r\n> \r\n> > Will the usage of SequentialDnsAddressResolverFactory with non default concurrency level help here?\r\n> \r\n> Yes, it can help. Try to pass 1 to its constructor.\r\n\r\nHey @mrniko, tried that and it didn't help, I also tried to create a custom SequentialDnsAddressResolverFactory with a low value for dns cache.\r\n\r\nIt's not a DNS issue, I verified that same hosts always resolve to the same IP address and there is always 1 to 1 mapping between a host and an IP.\r\n\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2023-12-25T12:51:38Z",
        "body": "> We use a credential resolver in our redisson config which makes the password to be sent with each request so I doubt that this NOAUTH message is the actual issue here.\r\n\r\nMake sure that the CredentialsResolver object returns a non-null password "
      },
      {
        "user": "mrniko",
        "created_at": "2023-12-25T12:53:15Z",
        "body": "> It's not a DNS issue, I verified that same hosts always resolve to the same IP address and there is always 1 to 1 mapping between a host and an IP.\r\n\r\nOther hosts many not reach dns requests limit."
      },
      {
        "user": "yizmailovSF",
        "created_at": "2023-12-25T13:15:01Z",
        "body": "> > We use a credential resolver in our redisson config which makes the password to be sent with each request so I doubt that this NOAUTH message is the actual issue here.\r\n> \r\n> Make sure that the CredentialsResolver object returns a non-null password\r\n\r\nCredentialsResolver always resolves to a valid passowrd.\r\n\r\n> > It's not a DNS issue, I verified that same hosts always resolve to the same IP address and there is always 1 to 1 mapping between a host and an IP.\r\n> \r\n> Other hosts many not reach dns requests limit.\r\n\r\nhmm if it were some dns limit I would have expected to see the same issues on other pods but out of 12-15 pods we have that use redisson it usually happens on no more than 2-3 at the same time."
      },
      {
        "user": "yizmailovSF",
        "created_at": "2023-12-25T18:51:30Z",
        "body": "@mrniko It seems that these added\\removed for slot ranges do not appear when I set just 1 replica node per shard, as soon as I scale it up these messages show up regularly even though cluster nodes response doesn't change. "
      },
      {
        "user": "mrniko",
        "created_at": "2023-12-26T06:24:34Z",
        "body": "Can you set `trace` logging level for `org.redisson` package and share the log since the application start till the moment then you get an error after slaves scaling?"
      },
      {
        "user": "yizmailovSF",
        "created_at": "2023-12-27T08:30:13Z",
        "body": "> Can you set `trace` logging level for `org.redisson` package and share the log since the application start till the moment then you get an error after slaves scaling?\r\n\r\nNot sure that I'll be able to get trace logs in this environment, after I change the shards to have just 1 replica per shard I don't see these \"false\" slave added\\removed for slot ranges messages, will wait couple of more days to see if the issue is reproduced.\r\n\r\nthanks."
      },
      {
        "user": "yizmailovSF",
        "created_at": "2024-01-23T13:28:33Z",
        "body": "@mrniko Unfortunately I'm not able to get debug\\trace logs for this scenario but it's pretty consistent, whenever we have more than 1 replica per shard we have these \"removed for slot ranges\" messages followed by these NOAUTH errors.\r\n\r\nWhen it's just a single replica all works fine.\r\n\r\nAny idea what could be the reason?  "
      },
      {
        "user": "mrniko",
        "created_at": "2025-01-16T12:05:01Z",
        "body": "Incorrect slave adding/removing was fixed in 3.29.0 version."
      }
    ]
  },
  {
    "number": 5518,
    "title": "cluster nodes timeout is same as config timeout ?",
    "created_at": "2023-12-21T11:48:02Z",
    "closed_at": "2025-01-17T15:51:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5518",
    "body": "\r\nWe encountered a problem with Redisson. The error message says 'Not all slots covered! Only XXX slots are available\r\n\r\nWe suspect that the Redis command 'cluster nodes' is slow, even though the configured timeout is the same. However, we set a very short timeout.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5518/comments",
    "author": "qqwangxiaow",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2025-01-17T15:51:08Z",
        "body": "There was a bug in cluster topology fixed in 3.36.0 which may cause that. Please upgrade"
      }
    ]
  },
  {
    "number": 5515,
    "title": "Command Execution Timeout for Command : (AUTH)",
    "created_at": "2023-12-20T07:35:44Z",
    "closed_at": "2024-08-09T06:44:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5515",
    "body": "Hello,\r\n\r\nI am trying to connect redis server with password but I am getting timeout exception. I read same questions but didnt help me. Currently I am using 3.24.3 version redisson, Here is my config,\r\n\r\n    Config config = new Config();\r\n    config.useClusterServers().addNodeAddress(endpoint) //endpoint = redis://+url+:6379\r\n          .setPassword(password)\r\n              .setSslEnableEndpointIdentification(false)\r\n        .setMasterConnectionMinimumIdleSize(2)\r\n              .setMasterConnectionPoolSize(3)\r\n              .setConnectTimeout(10000)\r\n              .setTimeout(10000);\r\n    \r\n\r\n    return Redisson.create(config);\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5515/comments",
    "author": "Ataoglan",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-12-20T07:48:24Z",
        "body": "Can you set `trace` logging level for `org.redisson` package and share the output since the application start moment?"
      },
      {
        "user": "Ataoglan",
        "created_at": "2023-12-20T08:23:15Z",
        "body": "```\r\n2023-12-20T11:03:04.665+03:00 TRACE 76011 --- [isson-netty-1-6] o.r.client.handler.CommandEncoder        : channel: [id: 0x6386b25d, L:/192.000:61755 - R:test.redis.com/192.000:6379] message: *2\r\n$4\r\nAUTH(password masked)\r\n2023-12-20T11:03:04.665+03:00 TRACE 76011 --- [isson-netty-1-6] o.r.client.handler.CommandEncoder        : channel: [id: 0x6386b25d, L:/192.000:61755 - R:test.redis.com/192.000:6379] message: *1\r\n$4\r\nPING\r\n\r\n2023-12-20T11:03:14.585+03:00  WARN 76011 --- [           main] o.r.cluster.ClusterConnectionManager     : null\r\n2023-12-20T11:03:16.477+03:00 DEBUG 76011 --- [isson-netty-1-9] org.redisson.client.RedisConnection      : Connection created [addr=redis://test.redis.com:6379]\r\n2023-12-20T11:03:16.577+03:00 TRACE 76011 --- [isson-netty-1-9] o.r.client.handler.CommandEncoder        : channel: [id: 0x7b6410e1, L:/192.000:61758 - R:test.redis.com/192.000:6379] message: *2\r\n$4\r\nAUTH(password masked)\r\n2023-12-20T11:03:16.577+03:00 TRACE 76011 --- [isson-netty-1-9] o.r.client.handler.CommandEncoder        : channel: [id: 0x7b6410e1, L:/192.000:61758 - R:test.redis.com/192.000:6379] message: *1\r\n$4\r\nPING\r\n\r\n2023-12-20T11:03:26.096+03:00  WARN 76011 --- [           main] o.r.cluster.ClusterConnectionManager     : null\r\n2023-12-20T11:03:27.607+03:00 DEBUG 76011 --- [sson-netty-1-12] org.redisson.client.RedisConnection      : Connection created [addr=redis://test.redis.com:6379]\r\n2023-12-20T11:03:27.688+03:00 TRACE 76011 --- [sson-netty-1-12] o.r.client.handler.CommandEncoder        : channel: [id: 0x3af5d340, L:/192.000:61761 - R:test.redis.com/192.000:6379] message: *2\r\n$4\r\nAUTH(password masked)\r\n2023-12-20T11:03:27.689+03:00 TRACE 76011 --- [sson-netty-1-12] o.r.client.handler.CommandEncoder        : channel: [id: 0x3af5d340, L:/192.000:61761 - R:test.redis.com/192.000.23.42:6379] message: *1\r\n$4\r\nPING\r\n\r\n2023-12-20T11:03:37.608+03:00  WARN 76011 --- [           main] o.r.cluster.ClusterConnectionManager     : null\r\n2023-12-20T11:03:37.618+03:00  WARN 76011 --- [           main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: Factory method 'redissonClient' threw exception with message: Can't connect to servers!\r\n2023-12-20T11:03:37.619+03:00  INFO 76011 --- [nformed client)] net.spy.memcached.MemcachedConnection    : Shut down memcached client\r\n2023-12-20T11:03:37.620+03:00  INFO 76011 --- [           main] org.eclipse.jetty.server.Server          : Stopped Server@7604198a{STOPPING}[11.0.17,sto=0]\r\n2023-12-20T11:03:37.623+03:00  INFO 76011 --- [           main] o.e.jetty.server.handler.ContextHandler  : Stopped o.s.b.w.e.j.JettyEmbeddedWebAppContext@4597e6e3{application,/,[file:///private/var/folders/lx/pt8b_xmj3zl1gk3k8slk56wm0000gp/T/jetty-docbase.8102.9751972298805093555/, jar:file:/Users/ozcan/.m2/repository/org/webjars/swagger-ui/5.2.0/swagger-ui-5.2.0.jar!/META-INF/resources],STOPPED}\r\n2023-12-20T11:03:37.635+03:00  INFO 76011 --- [           main] .s.b.a.l.ConditionEvaluationReportLogger : \r\n\r\nError starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.\r\n2023-12-20T11:03:37.646+03:00 ERROR 76011 --- [           main] o.s.boot.SpringApplication               : Application run failed\r\n```"
      },
      {
        "user": "Ataoglan",
        "created_at": "2023-12-20T08:27:43Z",
        "body": "with cli I can ping the redis server btw @mrniko "
      },
      {
        "user": "mrniko",
        "created_at": "2023-12-20T09:33:39Z",
        "body": ">  Exception encountered during context initialization - cancelling refresh attempt: Factory method 'redissonClient' threw exception with message: Can't connect to servers!\r\n\r\nCan you share the full stacktrace?"
      },
      {
        "user": "Ataoglan",
        "created_at": "2023-12-20T10:50:49Z",
        "body": "at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:650) ~[spring-beans-6.0.13.jar:6.0.13]\r\n\t... 60 common frames omitted\r\nCaused by: org.redisson.client.RedisConnectionException: Can't connect to servers!\r\n\tat org.redisson.cluster.ClusterConnectionManager.doConnect(ClusterConnectionManager.java:164) ~[redisson-3.25.1.jar:3.25.1]\r\n\tat org.redisson.connection.MasterSlaveConnectionManager.connect(MasterSlaveConnectionManager.java:196) ~[redisson-3.25.1.jar:3.25.1]\r\n\tat org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:220) ~[redisson-3.25.1.jar:3.25.1]\r\n\tat org.redisson.Redisson.<init>(Redisson.java:65) ~[redisson-3.25.1.jar:3.25.1]\r\n\tat org.redisson.Redisson.create(Redisson.java:110) ~[redisson-3.25.1.jar:3.25.1]\r\n\tat rotate.app.config.RedisConfig.redissonClient(RedisConfig.java:35) ~[classes/:na]\r\n\tat rotate.app.config.RedisConfig$$SpringCGLIB$$0.CGLIB$redissonClient$0(<generated>) ~[classes/:na]\r\n\tat rotate.app.config.RedisConfig$$SpringCGLIB$$FastClass$$1.invoke(<generated>) ~[classes/:na]\r\n\tat org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:258) ~[spring-core-6.0.13.jar:6.0.13]\r\n\tat org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331) ~[spring-context-6.0.13.jar:6.0.13]\r\n\tat rotate.app.config.RedisConfig$$SpringCGLIB$$0.redissonClient(<generated>) ~[classes/:na]\r\n\tat java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104) ~[na:na]\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:578) ~[na:na]\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:139) ~[spring-beans-6.0.13.jar:6.0.13]\r\n\t... 61 common frames omitted\r\nCaused by: java.util.concurrent.ExecutionException: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (AUTH), params: (password masked), Redis client: [addr=redis://test.redis.com:6379]\r\n\tat java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:396) ~[na:na]\r\n\tat java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096) ~[na:na]\r\n\tat org.redisson.cluster.ClusterConnectionManager.doConnect(ClusterConnectionManager.java:96) ~[redisson-3.25.1.jar:3.25.1]\r\n\t... 74 common frames omitted\r\nCaused by: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (AUTH), params: (password masked), Redis client: [addr=redis://test.redis.com:6379]\r\n\tat org.redisson.client.RedisConnection.lambda$async$0(RedisConnection.java:256) ~[redisson-3.25.1.jar:3.25.1]\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715) ~[netty-common-4.1.100.Final.jar:4.1.100.Final]\r\n\tat io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34) ~[netty-common-4.1.100.Final.jar:4.1.100.Final]\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703) ~[netty-common-4.1.100.Final.jar:4.1.100.Final]\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790) ~[netty-common-4.1.100.Final.jar:4.1.100.Final]\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503) ~[netty-common-4.1.100.Final.jar:4.1.100.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.100.Final.jar:4.1.100.Final]\r\n\tat java.base/java.lang.Thread.run(Thread.java:1589) ~[na:na]\r\n\r\nany idea @mrniko "
      },
      {
        "user": "mrniko",
        "created_at": "2023-12-26T06:48:52Z",
        "body": "try `rediss://` url prefix"
      }
    ]
  },
  {
    "number": 5509,
    "title": "RedisTimeoutException",
    "created_at": "2023-12-18T02:49:39Z",
    "closed_at": "2024-11-01T12:37:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5509",
    "body": "Version: 3.24.1\r\n```\r\n2023-12-18T04:11:16.409+08:00 org.redisson.client.RedisTimeoutException: Command execution timeout for command: (CLUSTER NODES), params: [], Redis client: [addr=redis://192.168.0.1:7000]\r\n2023-12-18T04:11:16.409+08:00   at org.redisson.client.RedisConnection.lambda$async$0(RedisConnection.java:256) ~[redisson-3.24.1.jar!/:3.24.1]\r\n2023-12-18T04:11:16.409+08:00   at io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715) ~[netty-common-4.1.97.Final.jar!/:4.1.97.Final]\r\n2023-12-18T04:11:16.409+08:00   at io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34) ~[netty-common-4.1.97.Final.jar!/:4.1.97.Final]\r\n2023-12-18T04:11:16.409+08:00   at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703) ~[netty-common-4.1.97.Final.jar!/:4.1.97.Final]\r\n2023-12-18T04:11:16.409+08:00   at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790) ~[netty-common-4.1.97.Final.jar!/:4.1.97.Final]\r\n2023-12-18T04:11:16.409+08:00   at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503) ~[netty-common-4.1.97.Final.jar!/:4.1.97.Final]\r\n2023-12-18T04:11:16.409+08:00   at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.97.Final.jar!/:4.1.97.Final]\r\n2023-12-18T04:11:16.409+08:00   at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_212]\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5509/comments",
    "author": "MochaMousse",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-11-01T12:37:41Z",
        "body": "Upgrade to 3.36.0 version or higher"
      }
    ]
  },
  {
    "number": 5503,
    "title": "Thread block when use FairLock if lock unlock",
    "created_at": "2023-12-14T09:26:08Z",
    "closed_at": "2024-11-01T12:40:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5503",
    "body": "when i use fairlock，\r\n\r\nif 2 thread come in，\r\nif Thread-1 service spend more time (like 40s， watchdog 30s fresh)，\r\nafter a while Thread-2 will have to count a negative ttl，\r\nthen it will call `future.getNow().getLatch().acquireUninterruptibly();`.\r\n\r\nWhen Thread-1 unlock, the quere which in redis will be remove, but Thread-2 will always block.\r\n\r\ni don't know it right thing? Why Thread-2 have to block?\r\n\r\nMy redisson version is 3.12.0",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5503/comments",
    "author": "UncleJuJu",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-06-06T08:12:38Z",
        "body": "Is there any code to reproduce it?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-11-01T12:40:21Z",
        "body": "Try 3.32.0 version has a fix for the issue with incorrect calculation of the remaining ttl."
      }
    ]
  },
  {
    "number": 5501,
    "title": "The RTopic listener under the redis cluster cannot receive messages after a period of time",
    "created_at": "2023-12-13T11:52:23Z",
    "closed_at": "2023-12-15T06:48:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5501",
    "body": "redisson version：3.15.6\r\nredis cluster version：5.0.4\r\n\r\nHello, when we recently used redisson to connect to the redis cluster, we found that the RTopic listener always failed to receive messages after the service had been running for a period of time. This problem did not occur when we used sentinel mode before, and in redis It doesn't happen when the pressure is low. Is there any solution?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5501/comments",
    "author": "yanhuilin",
    "comments": [
      {
        "user": "yanhuilin",
        "created_at": "2023-12-15T06:47:42Z",
        "body": "This problem has been solved. We increased the number of idle subscription connections and the number of subscriptions per connection. The reason may be that extensive use of RLock results in insufficient connections. Each RLock will apply for an RTopic. At this time, a problem is triggered. After the subscription is disconnected, it will not continue to reconnect, resulting in the resident listener not being able to get the connection to receive information."
      },
      {
        "user": "mrniko",
        "created_at": "2023-12-15T07:33:12Z",
        "body": "With the latest version I'm getting the error below in case of subscription connections starvation. I recommend to update the Redisson version.\r\n\r\n`Unable to acquire connection for subscription after 3 attempts. Increase 'subscriptionsPerConnection' and/or 'subscriptionConnectionPoolSize' parameters.`"
      }
    ]
  },
  {
    "number": 5492,
    "title": "NullPointerException at RedissonBaseLock.evalWriteAsync",
    "created_at": "2023-12-08T03:18:33Z",
    "closed_at": "2023-12-08T09:21:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5492",
    "body": "java.lang.NullPointerException: null\r\n        at org.redisson.RedissonBaseLock.evalWriteAsync(RedissonBaseLock.java:217) ~[redisson-3.16.8.jar!/:3.16.8]\r\n        at org.redisson.RedissonFairLock.tryLockInnerAsync(RedissonFairLock.java:156) ~[redisson-3.16.8.jar!/:3.16.8]\r\n        at org.redisson.RedissonLock.tryAcquireAsync(RedissonLock.java:173) ~[redisson-3.16.8.jar!/:3.16.8]\r\n        at org.redisson.RedissonLock.tryAcquire(RedissonLock.java:144) ~[redisson-3.16.8.jar!/:3.16.8]\r\n        at org.redisson.RedissonLock.tryLock(RedissonLock.java:218) ~[redisson-3.16.8.jar!/:3.16.8]\r\n\r\nsource code \r\n\r\n```\r\nprotected <T> RFuture<T> evalWriteAsync(String key, Codec codec, RedisCommand<T> evalCommandType, String script, List<Object> keys, Object... params) {\r\n        MasterSlaveEntry entry = commandExecutor.getConnectionManager().getEntry(getRawName());\r\n        int availableSlaves = entry.getAvailableSlaves();\r\n\r\n        CommandBatchService executorService = createCommandBatchService(availableSlaves);\r\n        RFuture<T> result = executorService.evalWriteAsync(key, codec, evalCommandType, script, keys, params);\r\n        if (commandExecutor instanceof CommandBatchService) {\r\n            return result;\r\n        }\r\n\r\n        RFuture<BatchResult<?>> future = executorService.executeAsync();\r\n        CompletionStage<T> f = future.handle((res, ex) -> {\r\n            if (ex == null && res.getSyncedSlaves() != availableSlaves) {\r\n                throw new CompletionException(new IllegalStateException(\"Only \"\r\n                                                        + res.getSyncedSlaves() + \" of \" + availableSlaves + \" slaves were synced\"));\r\n            }\r\n\r\n            return result.getNow();\r\n        });\r\n        return new CompletableFutureWrapper<>(f);\r\n}\r\n```\r\nint availableSlaves = entry.getAvailableSlaves();  this line has occurred npe.\r\nRedis version\r\n6.2.4\r\n\r\nRedisson version 3.16.8",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5492/comments",
    "author": "youxiaxiaomage",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-12-08T09:21:01Z",
        "body": "Fixed in 3.17.7 version."
      }
    ]
  },
  {
    "number": 5479,
    "title": "org.redisson.client.RedisException: CROSSSLOT Keys in request don't hash to the same slot.",
    "created_at": "2023-12-04T03:53:40Z",
    "closed_at": "2023-12-04T10:46:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5479",
    "body": "I encountered the following issues while using RQueue#V pollLastAndOfferFirstTo(String queueName).\r\n\r\nRedis version 6.2.6\r\nRedisson version 3.23.5\r\nMode cluster\r\n\r\nConfig config = new Config();\r\n        config.useClusterServers().setTimeout(5000);\r\n        String url = \"redis://172.XX.XX.XXX:6666\";\r\n        String url1 = \"redis://172.XX.XX.XXX:6666\";\r\n        String url2 = \"redis://172.XX.XX.XXX:6666\";\r\n        config.useClusterServers().addNodeAddress(url, url1, url2);\r\n        config.useClusterServers().setPassword(\"abc\");\r\n        RedissonClient redissonClient = Redisson.create(config);\r\n\r\n        String key1 = \"redis_key_1\";\r\n        RDeque<String> deque = redissonClient.getDeque(key1);\r\n        deque.addFirst(\"aaaa\");\r\n        String key2 = \"redis_key_2\";\r\n        RDeque<String> deque1 = redissonClient.getDeque(key1);\r\n        Object o = deque1.pollLastAndOfferFirstTo(key2);\r\n\r\n\r\n\r\n ERROR:org.redisson.client.RedisException: CROSSSLOT Keys in request don't hash to the same slot. channel: [id: 0x6617f095, L:/XXX.XX.XX.XXX:54612 - R:XXX.XX.XX.XXX/XXX.XX.XX.XXX:6666] command: (RPOPLPUSH), promise: java.util.concurrent.CompletableFuture@6b7aa9b3[Not completed, 1 dependents], params: [redis_key_1, redis_key_2]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:381)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:205)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:144)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:120)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5479/comments",
    "author": "iridescenceZz",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-12-04T10:46:52Z",
        "body": "both keys should be located on the same slot."
      },
      {
        "user": "iridescenceZz",
        "created_at": "2023-12-05T01:47:36Z",
        "body": "> both keys should be located on the same slot.\r\n\r\nI know ，I can set two keys on the same slot by using redis_key_{xxx}, but this is not friendly to the business."
      },
      {
        "user": "mrniko",
        "created_at": "2023-12-05T07:58:20Z",
        "body": "I'm afraid there is no other way to do it."
      }
    ]
  },
  {
    "number": 5454,
    "title": "Unable to send PING command over channel",
    "created_at": "2023-11-24T09:39:49Z",
    "closed_at": "2023-12-11T09:11:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5454",
    "body": "When using  redission 3.13.1 , find this problem When the application is running normally .\r\nUnder what circumstances would this problem occur?\r\n\r\nexception log：\r\no.r.c.handler.PingConnectionHandler     |Unable to send PING command over channel: [id: 0x6be72845, L:/195.161.226.24:49486 - R:/10.104.129.24:6379]\r\nio.netty.util.concurrent.DefaultPromise$LeanCancellationException: null\r\nio.netty.util.concurrent.DefaultPromise.cancel(...)(Unknown Source)\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5454/comments",
    "author": "lcvg",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-12-12T08:51:18Z",
        "body": "Did you resolve it?"
      },
      {
        "user": "wjdxw",
        "created_at": "2024-04-08T02:36:39Z",
        "body": "@lcvg  can you tell me how to fix this question? i has the same problems"
      },
      {
        "user": "lcvg",
        "created_at": "2024-04-08T03:24:42Z",
        "body": "> @lcvg can you tell me how to fix this question? i has the same problems\r\n\r\nYou can try setting the pingConnectionInterval and nettyThreads parameters larger."
      }
    ]
  },
  {
    "number": 5453,
    "title": "lettuce and redission-spring-boot-starter cannot be used at the same time",
    "created_at": "2023-11-24T03:08:54Z",
    "closed_at": "2024-09-14T06:54:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5453",
    "body": "\r\nThe redisTemplate originally built by LettuceConnectionFactory in the project could not be started after the redission-spring-boot-starter was introduced. After the analysis, LettuceConnectionFactory and RedissonConnectionFactory in RedissonAutoConfiguration cannot exist at the same time, is there a way to solve the problem of this redisTemplate using lettuce and then using redission",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5453/comments",
    "author": "OakLi",
    "comments": [
      {
        "user": "activx",
        "created_at": "2024-09-13T12:15:28Z",
        "body": "Hi!, I resolved this issue using the following approach:\r\n\r\n```\r\n@Configuration\r\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) \r\n@Import(RedisAutoConfiguration.class)\r\npublic class RedisAutoConfigOrderConfiguration {\r\n}\r\n```\r\nI added empty configuration with HIGHEST  order, and imported RedusAutoConfig"
      }
    ]
  },
  {
    "number": 5451,
    "title": "Large number of org.redisson.PubSubMessageListener objects",
    "created_at": "2023-11-23T15:19:24Z",
    "closed_at": "2024-03-03T10:56:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5451",
    "body": "@mrniko We are seeing a large number of PubSubPatternMessageListener objects that are causing OutOfMemory issues.\r\nWe are using redisson version 3.23.5. \r\nCan you please let us know when do we create PubSubMessageListener objects. We have quite a large number of them >1000k that are holding references to heavier objects that we have otherwise discarded from our end but seems that the pubsubmessage listener is holding references to them causing OOM.\r\n\r\nWhen analysing OOM, we check for the GC root for the pub sub message listener object and we see some Concurrent Hash Map Node. Not sure if there is any static map that is causing this issue.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5451/comments",
    "author": "jainyash88",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-11-29T09:27:48Z",
        "body": "PubSubPatternMessageListener might be created by RLocalCachedMap instance"
      },
      {
        "user": "jainyash88",
        "created_at": "2023-11-29T09:45:29Z",
        "body": "@mrniko We are using RLocalCachedMap from beginning. So it was there even with 3.18. However we see the GC root for the objects that are held by the NoneCacheMap inside of PubSubPatternMessageListener holding this. Is there a way that we can ensure this would not be used and or cleared?"
      },
      {
        "user": "mrniko",
        "created_at": "2023-11-29T09:48:45Z",
        "body": "Is there any way to reproduce it?"
      }
    ]
  },
  {
    "number": 5437,
    "title": "Is the getLock method thread-safe?",
    "created_at": "2023-11-17T02:36:22Z",
    "closed_at": "2024-08-09T07:16:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5437",
    "body": "I would like to know if the following method is thread-safe and if it is then there is no need to create a new instance on every request?\r\n\r\n```java\r\norg.redisson.api.RedissonClient.getLock(...)\r\n```\r\n\r\nIf you can reuse instances you don't need to recreate them every time a request comes in!\r\n\r\n```java\r\n    @Override\r\n    public RLock getLock(String name) {\r\n        return new RedissonLock(connectionManager.getCommandExecutor(), name);\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5437/comments",
    "author": "tianmingxing",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-08-09T07:16:33Z",
        "body": "It's fully thread-safe."
      }
    ]
  },
  {
    "number": 5435,
    "title": "Unable to unfreeze entry is fixed under which fixes in 3.23.2 version ?",
    "created_at": "2023-11-16T12:47:12Z",
    "closed_at": "2024-02-15T10:14:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5435",
    "body": "**Unable to unfreeze entry** this error is fixed under which fixes in 3.23.2 version ?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5435/comments",
    "author": "Shalaka1197",
    "comments": [
      {
        "user": "Shalaka1197",
        "created_at": "2023-11-17T09:59:15Z",
        "body": "@mrniko Please can you check and reply on this ?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-02-15T10:14:20Z",
        "body": "yes"
      }
    ]
  },
  {
    "number": 5433,
    "title": "org.redisson.api.RMap#entrySet(java.lang.String, int)  use keyPattern query ，but no result。",
    "created_at": "2023-11-15T07:36:56Z",
    "closed_at": "2024-08-09T07:27:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5433",
    "body": "```\r\n        RMapCache<String, String> test_concurrent = redissonClient.getMapCache(\"test_concurrent\");\r\n        String put = test_concurrent.put(\"123-456-abc-6\", \"21211\");\r\n        System.out.println(test_concurrent.entrySet(\"123-???-abc-6\")); // not found any res\r\n        System.out.println(test_concurrent.entrySet(\"123-*-abc-6\")); // not found any res\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5433/comments",
    "author": "roebuck99",
    "comments": [
      {
        "user": "roebuck99",
        "created_at": "2023-11-15T07:38:35Z",
        "body": "redisson version   \r\n        <dependency>\r\n            <groupId>org.redisson</groupId>\r\n            <artifactId>redisson</artifactId>\r\n            <version>3.20.0</version>\r\n        </dependency>"
      },
      {
        "user": "mrniko",
        "created_at": "2024-08-09T07:27:49Z",
        "body": "You need to define it like below:\r\n\r\n```java\r\nRMap<String, Object> map = redissonClient.getMapCache(\"test_concurrent\", \r\n                                                            new CompositeCodec(StringCodec.INSTANCE, valueCodec, valueCodec));\r\n```"
      }
    ]
  },
  {
    "number": 5421,
    "title": "为啥 3.24.3 中使用 netty 的 4.1.34.Final 然后这个里面 没有 DnsNameResolverBuilder.socketChannelType 这个 method ，直接报错了",
    "created_at": "2023-11-09T08:32:25Z",
    "closed_at": "2023-11-09T12:25:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5421",
    "body": "nested exception is java.lang.NoSuchMethodError: io.netty.resolver.dns.DnsNameResolverBuilder.socketChannelType(Ljava/lang/Class;)Lio/netty/resolver/dns/DnsNameResolverBuilder; ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5421/comments",
    "author": "1650987523",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-11-09T12:25:40Z",
        "body": "You need to update netty libraty."
      }
    ]
  },
  {
    "number": 5406,
    "title": "Why does not use ConcurrentMap<K, V> as local cache for RedissonLocalCacedMap?",
    "created_at": "2023-11-01T09:27:33Z",
    "closed_at": "2024-05-08T10:37:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5406",
    "body": "Hi,\r\nI'm using RedissonLocalCacedMap and just read data from local use `getCachedMap().get(objectKey)` and I just facing with slow response time on PROD environment.\r\nThe root cause: Netty version 4.1.94.Final makes `localCacheView.toCacheKey(key)` run into slowness and `getCachedMap().get(objectKey)` becomes slow. Upgrading netty to 4.1.100.Final helps to fix the problem.\r\nAnd I just wonder that in RedissonLocalCacedMap.class why doesn't Redisson use `private ConcurrentMap<K, V> cache;`  instead of `private ConcurrentMap<CacheKey, CacheValue> cache;`? It will help the local run faster than the current.\r\n\r\nThank you\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5406/comments",
    "author": "lehuuthanh5",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-05-08T10:37:26Z",
        "body": "> private ConcurrentMap<K, V> cache; instead of private ConcurrentMap<CacheKey, CacheValue> cache;\r\n\r\nTo avoid serializing the entire key key during cache invalidation."
      }
    ]
  },
  {
    "number": 5389,
    "title": "KryoException. Stackoverflow occured because of infinite recursion",
    "created_at": "2023-10-21T10:46:07Z",
    "closed_at": "2024-11-01T12:38:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5389",
    "body": "Hi,\r\n\r\nI have a project where I use RedissonSpringCacheManager with RedissonClient default configuration.\r\nI am using @Cacheable annotation to cache Entities (unfortunatelly for now I can't change Entities to DTOs because the project is too big).\r\n\r\nPlease check sample code to better explain the issue I have:\r\nEntities:\r\n```\r\n@Entity\r\npublic class User implements Serializable {\r\n    @Id\r\n    @Column(name = \"user_id\")\r\n    private Long id;\r\n    @OneToMany(fetch = FetchType.EAGER, mappedBy = \"user\", cascade = CascadeType.ALL)\r\n    private Set< Address> addresses\r\n}\r\n\r\n@Entity\r\n@Table(name = \"address\")\r\npublic class Address implements Serializable {\r\n    @Id\r\n    private Long id;\r\n    @ManyToOne\r\n    @JoinColumn(name = \"user_id\", referencedColumnName = \"user_id\", nullable = false)\r\n    private User user;\r\n}\r\n```\r\nCache configuration:\r\n```\r\n@Bean\r\nCacheManager cacheManager(RedissonClient redissonClient) {\r\n    Map<String, CacheConfig> config = new HashMap<>();\r\n    config.put(\"users\", new CacheConfig(liveTime, idleTime));\r\n    return new RedissonSpringCacheManager(redissonClient, config);\r\n}\r\n```\r\n\r\nMethod used for caching:\r\n```\r\n@Cacheable(cacheNames = users, key = \"#p0\", condition = \"#p0 != null\", unless = \"#result == null\")\r\npublic User findById(Long id) {\r\n    return userRepository.findById(id);\r\n}\r\n```\r\n\r\nThe caching was correctly working with Redisson version 3.17.1 \r\nAfter upgrading to redisson 3.23.1 I have such exception on serialization of entity, (when trying to add User into cache, by invoking method findById): \r\n\r\ncom.esotericsoftware.kryo.KryoException: A StackOverflow occurred. The most likely cause is that your data has a circular reference resulting in infinite recursion. Try enabling references with Kryo.setReferences(true). If your data structure is really more than 1320 levels deep then try increasing your Java stack size.\r\nSerialization trace:\r\naddresses (com.test.User)\r\nuser (com.test.Address)\r\naddresses (com.test.User)\r\nuser (com.test.Address)\r\naddresses (com.test.User)\r\n...\r\n\r\nIs there any known workaround?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5389/comments",
    "author": "ArekSzyszkowski",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-10-27T13:02:36Z",
        "body": "Did you try to set suggested Kryo.setReferences(true). ?"
      }
    ]
  },
  {
    "number": 5388,
    "title": "PingConnectionHandler ERROR",
    "created_at": "2023-10-21T07:08:08Z",
    "closed_at": "2024-07-24T16:31:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5388",
    "body": "[] [eventId-42827b565f0d4d80b4f42f868aa75195] [PingConnectionHandler.java,97,org.redisson.client.handler.PingConnectionHandler,lambda$sendPing$1] [Unable to send PING command over channel: [id: 0x36c756fa, L:/10.7.74.157:36688 - R:r-wz9go0wmxu58bvyauh.redis.rds.aliyuncs.com/xxxxxx:6379]] ## ' org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://xxxxxx:6379]\r\n\tat org.redisson.client.RedisConnection.lambda$async$0(RedisConnection.java:244)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747)\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n\r\n\r\n<dependency>\r\n  <groupId>org.redisson</groupId>\r\n   <artifactId>redisson</artifactId>\r\n    <version>3.17.6</version>\r\n</dependency>\r\n\r\nconfig:\r\nString address;\r\nString password;\r\nint database;\r\nint pingConnectionInterval = 30000;",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5388/comments",
    "author": "ykrenz",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-07-24T16:31:25Z",
        "body": "Upgrade to 3.26.1+ version"
      }
    ]
  },
  {
    "number": 5383,
    "title": "Kyroexception version upgrade 3.17.7 to 3.23.5",
    "created_at": "2023-10-19T11:02:12Z",
    "closed_at": "2023-10-20T11:22:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5383",
    "body": "Hi , I'm facing the one issue , I updated the pom from 3.17.7 to 3.23.5 and since then I'm getting below error , can anyone help. Also we dont want to clear our redis instance existing data\r\n\r\nError :\r\nonfigure.logging.ConditionEvaluationReportLogger\",\"written_at\":\"2023-10-19T10:22:31.662Z\",\"thread\":\"main\",\"type\":\"log\"}\r\n2023-10-19T15:52:31.69+0530 [APP/PROC/WEB/0] OUT {\"msg\":\"Application run failed\",\"level\":\"ERROR\",\"written_ts\":\"1697710951696641305\",\"logger\":\"org.springframework.boot.SpringApplication\",\"written_at\":\"2023-10-19T10:22:31.694Z\",\"thread\":\"main\",\"type\":\"log\",\"stacktrace\":[\"org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'redisTemplate' defined in class path resource [org/redisson/spring/starter/RedissonAutoConfiguration.class]: Unsatisfied dependency expressed through method 'redisTemplate' parameter 0: Error creating bean with name 'redissonConnectionFactory' defined in class path resource [org/redisson/spring/starter/RedissonAutoConfiguration.class]: Unsatisfied dependency expressed through method 'redissonConnectionFactory' parameter 0: Error creating bean with name 'redisson' defined in class path resource [org/redisson/spring/starter/RedissonAutoConfiguration.class]: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redisson' threw exception with message: com/esotericsoftware/kryo/serializers/DefaultSerializers$UUIDSerializer\",\"\\tat org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:801)\",\"\\tat org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:545)\",\"\\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1332)\",\"\\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1162)\",\"\\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:560)\",\"\\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)\",\"\\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:325)\",\"\\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)\",\"\\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:323)\",\"\\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)\",\"\\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)\",\"\\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)\",\"\\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)\",\"\\tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)\",\"\\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:737)\",\"\\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:439)\",\"\\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:315)\",\"\\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1309)\",\"\\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1298)\",\"\\tat com.sap.dvh.Application.main(Application.java:21)\",\"\\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\",\"\\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\",\"\\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\",\"\\tat java.base/java.lang.reflect.Method.invoke(Unknown Source)\",\r\n\r\nCode :\r\n\r\n@configuration\r\npublic class RedisConfig {\r\n\r\nprivate static final Logger logger = LoggerFactory.getLogger(RedisConfig.class);\r\n\r\n@Autowired\r\nprivate VcapUtils vcapUtils;\r\n\r\n@bean\r\npublic Config config() {\r\nConfig config = new Config();\r\n// logger.info(\"AMRIT : {}\", vcapUtils.getRedisURI());\r\nconfig.useSingleServer().setAddress(vcapUtils.getRedisURI());\r\nconfig.setCodec(new SerializationCodec());\r\nreturn config;\r\n}\r\n\r\n@bean(name = \"SpringCM\")\r\npublic CacheManager cacheManager(Config config) {\r\nCacheManager cacheManager = Caching.getCachingProvider().getCacheManager();\r\ncacheManager.createCache(\"rateLimit\", RedissonConfiguration.fromConfig(config));\r\nreturn cacheManager;\r\n}\r\n\r\n@bean\r\npublic ProxyManager proxyManager(CacheManager cacheManager) {\r\nreturn new JCacheProxyManager<>(cacheManager.getCache(\"rateLimit\"));\r\n}\r\n}\r\nPlease not when I'm using 3.17.7 the code is working fine but when I'm updating my pom to 3.23.5 it isn't working.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5383/comments",
    "author": "amrit9326",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-10-20T11:22:08Z",
        "body": "Kryo5Codec has been used as default codec since 3.19.0. You need to specify either deprecated MarshallingCodec or migrate your data to Kryo5Codec."
      }
    ]
  },
  {
    "number": 5373,
    "title": "Version 3.15.2 Waiting on object monitor when concurrently call RMapCache.get(Object key)",
    "created_at": "2023-10-17T05:19:07Z",
    "closed_at": "2023-10-25T12:03:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5373",
    "body": "The jstack info is:\r\n\"qtp1314740929-352\" #352 prio=5 os_prio=0 tid=0x00007faa8c024000 nid=0x1a4 in Object.wait() [0x00007fa9da0e1000]\r\n   java.lang.Thread.State: WAITING (on object monitor)\r\n        at java.lang.Object.wait(Native Method)\r\n        at java.lang.Object.wait(Object.java:502)\r\n        at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:253)\r\n        - locked <0x00000000f4e91788> (a io.netty.util.concurrent.ImmediateEventExecutor$ImmediatePromise)\r\n        at org.redisson.misc.RedissonPromise.await(RedissonPromise.java:110)\r\n        at org.redisson.misc.RedissonPromise.await(RedissonPromise.java:35)\r\n        at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:112)\r\n        at org.redisson.RedissonObject.get(RedissonObject.java:81)\r\n        at org.redisson.RedissonMap.get(RedissonMap.java:639)\r\n        at com.zte.xrexplore.edgeagent.helper.AlgorithmNodeCacheHelper.getNodeList(AlgorithmNodeCacheHelper.java:38)\r\n        at com.zte.xrexplore.edgeagent.service.AlgorithmRegService.selectRegNode(AlgorithmRegService.java:91)\r\n        at com.zte.xrexplore.edgeagent.service.impl.PlainModuleServiceImpl.reg(PlainModuleServiceImpl.java:249)\r\n        at com.zte.xrexplore.edgeagent.controller.PlainModuleController.reg(PlainModuleController.java:132)\r\n        at com.zte.xrexplore.edgeagent.controller.PlainModuleController$$FastClassBySpringCGLIB$$1add120b.invoke(<generated>)\r\n        at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n        at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:793)\r\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n        at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\r\n        at org.springframework.validation.beanvalidation.MethodValidationInterceptor.invoke(MethodValidationInterceptor.java:119)\r\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n        at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\r\n        at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:708)\r\n        at com.zte.xrexplore.edgeagent.controller.PlainModuleController$$EnhancerBySpringCGLIB$$945c2d1b.reg(<generated>)\r\n        at sun.reflect.GeneratedMethodAccessor245.invoke(Unknown Source)\r\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n        at java.lang.reflect.Method.invoke(Method.java:498)\r\n        at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\r\n        at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\r\n        at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\r\n        at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)\r\n        at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)\r\n        at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n        at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1043)\r\n        at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\r\n        at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n        at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\r\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:517)\r\n        at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:584)\r\n        at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:799)\r\n        at org.eclipse.jetty.servlet.ServletHandler$ChainEnd.doFilter(ServletHandler.java:1656)\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5373/comments",
    "author": "heroPeak",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-10-17T07:53:36Z",
        "body": "try 3.17.6 version"
      }
    ]
  },
  {
    "number": 5360,
    "title": "Question - Implement optimistic locking ",
    "created_at": "2023-10-11T07:58:42Z",
    "closed_at": "2023-12-15T09:29:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5360",
    "body": "Hi @mrniko , could you help me understand following question? I am little confused.\r\n\r\nWe are using Redisson (open source) v3.17.7 and in the process of migrating to the latest version. For Redis, we are using GCP MemoryStore 6.x in standard tier (no cluster). We have a use case in which we execute following steps\r\n1. Save data to a keyspace `ks1`\r\n2. Read data from another keyspace `ks2`\r\n3. Update the data read in step-2\r\n4. Save it back with the same key (which was used in step-2)\r\n\r\nWe have to guarantee atomicity of above steps. Is there any API in redisson which uses `WATCH` command? Or should we use a distributed lock to achieve the atomicity?\r\n\r\nThank you.\r\n\r\nBest,\r\nNN",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5360/comments",
    "author": "nnanda2016",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-12-15T09:29:07Z",
        "body": "It's better to use the distributed lock."
      }
    ]
  },
  {
    "number": 5359,
    "title": "how can I use tcl encryption in SingleServerConfig? ",
    "created_at": "2023-10-10T15:02:31Z",
    "closed_at": "2024-11-01T17:41:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5359",
    "body": "hi.\r\nim using GCP memorystore redis, and would like to use an instance which has AUTH string and TLS Certificate Authority (in transit encryption).\r\n\r\ni managed to connect to the redis server from the cli using:\r\nredis-cli -h 10.XXX.XXX.211 -p 6378 -a XXXX --tls --cacert <path_to_creds.pem>\r\n\r\nI would like to understand which properties in the SingleServerConfig I should populate for:\r\n1. --tls\r\n2. path_to_creds.pem\r\n\r\nso in the end my RedisClient creation will be something like:\r\n\r\n\r\n```\r\nSingleServerConfig singleServerConfig = redisConf.useSingleServer().setAddress(redisAddress);\r\nsingleServerConfig.setPassword(redisPassword);\r\nsingleServerConfig.setSslEnableEndpointIdentification(true);  //?\r\nsingleServerConfig.setCertsFile(\"path_to_creds.pem\");  //?      \r\nreturn new Redisson(redisConf);\r\n\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5359/comments",
    "author": "bensagi",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-11-01T17:41:25Z",
        "body": "you need to define `sslKeystore` setting"
      }
    ]
  },
  {
    "number": 5356,
    "title": "Can using JsonJacksonCodec be exploited by the CVE-2023-42809 vulnerability",
    "created_at": "2023-10-10T03:50:39Z",
    "closed_at": "2023-10-10T04:59:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5356",
    "body": null,
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5356/comments",
    "author": "myceciliababy",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-10-10T04:59:07Z",
        "body": "this issue is related to Kryo5 codec only."
      }
    ]
  },
  {
    "number": 5340,
    "title": "Remote Services Catastropically start to fail after decoding error",
    "created_at": "2023-09-28T17:02:54Z",
    "closed_at": "2023-10-30T07:45:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5340",
    "body": "We've been trying to upgrade to 3.21.3, but keep having the same issue.\r\n\r\nRemote Services will work for a few minutes, and then we get a decoder error, with an unregistered class, mostly in Kryo5, and then all Remote Services on that server stop working.  So far we have been unable to figure out call is actually throwing the error, or what class is unable to be decoded.\r\n\r\nThis only happens when the servers are under load.\r\n\r\nBefore this time, other RMIs are working correctly.  After this error, all RMIs for the server start throwing a \"No Response after [[timeout]]ms\" error\r\n\r\nThe errors that we are getting:\r\nERROR|2023-09-28 15:28:00,571|redisson-netty-2-20|org.redisson.client.handler.ErrorsLoggingHandler|Exception occured. Channel: [id: 0x0ecc6df6, L:/10.99.46.186:49930 - R:10.99.41.139/10.99.41.139:6379]\r\n! io.netty.handler.codec.DecoderException: com.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: 121\r\n! at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)\r\n! at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n! at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n! at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n! at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n! at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n! at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\r\n! at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\r\n! at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\r\n! at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n! at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n! at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n! at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n!  [1 skipped]\r\n! Caused by: com.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: 121\r\n! at com.esotericsoftware.kryo.util.DefaultClassResolver.readClass(DefaultClassResolver.java:159)\r\n! at com.esotericsoftware.kryo.Kryo.readClass(Kryo.java:758)\r\n! at com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:869)\r\n! at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510) [7 skipped]\r\n! at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n! at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n! at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n! at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n! ... 17 common frames omitted\r\n\r\nERROR|2023-09-28 15:28:00,571|redisson-netty-2-20|org.redisson.remote.SyncRemoteProxy|Can't get response from {remote_response}:86c6c518-ed2a-460a-83b3-853610142cd5:redisson_rs\r\n! com.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: 121\r\n! at com.esotericsoftware.kryo.util.DefaultClassResolver.readClass(DefaultClassResolver.java:159)\r\n! at com.esotericsoftware.kryo.Kryo.readClass(Kryo.java:758)\r\n! at com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:869)\r\n! at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510) [7 skipped]\r\n! at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n! at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n! at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n! at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n! at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n! at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n! at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\r\n! at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\r\n! at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\r\n! at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n! at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n! at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n! at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n!  [1 skipped]\r\n\r\nERROR|2023-09-28 15:28:00,571|redisson-netty-2-20|org.redisson.client.handler.CommandDecoder|Unable to decode data. channel: [id: 0x0ecc6df6, L:/10.99.46.186:49930 - R:10.99.41.139/10.99.41.139:6379], reply: ReplayingDecoderByteBuf(ridx=2774, widx=2774), command: (BLPOP), promise: java.util.concurrent.CompletableFuture@65750e8b[Not completed, 1 dependents], params: [{remote_response}:86c6c518-ed2a-460a-83b3-853610142cd5:redisson_rs, 60]\r\n! com.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: 121\r\n! at com.esotericsoftware.kryo.util.DefaultClassResolver.readClass(DefaultClassResolver.java:159)\r\n! at com.esotericsoftware.kryo.Kryo.readClass(Kryo.java:758)\r\n! at com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:869)\r\n! at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510) [7 skipped]\r\n! at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n! at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n! at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n! at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n! at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n! at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n! at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\r\n! at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\r\n! at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\r\n! at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n! at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n! at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n! at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n!  [1 skipped]",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5340/comments",
    "author": "bhoover10001",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-10-29T06:10:39Z",
        "body": "What version did you upgrade from?"
      },
      {
        "user": "bhoover10001",
        "created_at": "2023-10-29T13:37:15Z",
        "body": "We were moving from 3.19.0 to 3.21.3 and trying to use Kryo5Codec to replace FSTCodec. "
      },
      {
        "user": "mrniko",
        "created_at": "2023-10-30T07:09:58Z",
        "body": "Kryo5Codec isn't compatible with FSTCodec. You need to migrate the data or clear database."
      }
    ]
  },
  {
    "number": 5333,
    "title": "an RedisNodeNotFoundException was encountered when using redisson",
    "created_at": "2023-09-26T08:15:54Z",
    "closed_at": "2023-10-13T05:47:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5333",
    "body": "\r\n#server version\r\nredis server : 5.0.14\r\n#redisson client version\r\n3.13.6\r\n#describ\r\n    private volatile Map<String, RedissonClient> redissonClientMap = null;\r\n\r\nbefore our app link redis sentinel nodes,now our app will change link redis cluster nodes,implementation method is our app has a map to store two RedissonClient\r\none redisson client link redis sentinel nodes,another redisson client link redis cluster nodes, the map switcher is a key to routing a RedissonClient\r\nbut when we change key route to redis cluster nodes,After after a few minutes,app sometimes will print log \r\n\r\n\tNode for slot: 1712 hasn't been discovered yet. Check cluster slots coverage using CLUSTER NODES command. Increase value of retryAttempts and/or retryInterval settings.org.redisson.client.RedisNodeNotFoundException: Node for slot: 1712 hasn't been discovered yet. Check cluster slots coverage using CLUSTER NODES command. Increase value of retryAttempts and/or retryInterval settings.\r\n\tat org.redisson.connection.MasterSlaveConnectionManager.createNodeNotFoundFuture(MasterSlaveConnectionManager.java:579)\r\n\tat org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:563)\r\n\tat org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:644)\r\n\tat org.redisson.command.RedisExecutor.execute(RedisExecutor.java:116)\r\n\tat org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:244)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:668)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:743)\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:471)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\n\r\nguided by logs,when we invoke CLUSTER NODES command, the redis cluster nodes status is health\r\n\r\ntip:sometimes the app will print the following warning level logs\r\n[2023-09-12 22:47:33.978][INFO][698][redisson-netty-5-14] traceLogId:[null] dstTraceId:[] TxId:[] SpanId:[] call [org.redisson.cluster.ClusterConnectionManager][checkSlotsMigration] 294 slots removed from\r\n\r\n\r\n\r\nhow to solve this RedisNodeNotFoundException,because it affects normal business logic,thanks help me\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5333/comments",
    "author": "repeatthink123yuchao",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-09-26T08:19:42Z",
        "body": "incorrect slots added,slots removed messages in Redis Cluster mode fixed in 3.23.4 version. Can you try it?"
      },
      {
        "user": "repeatthink123yuchao",
        "created_at": "2023-09-26T08:35:29Z",
        "body": "> incorrect slots added,slots removed messages in Redis Cluster mode fixed in 3.23.4 version. Can you try it?\r\n\r\nwe increased the redisson version number from 3.11.1 to 3.13.6, but the problem(removed/added/RedisNodeNotFoundException) still exists,\r\nand the problem(removed/added) does not affect normal business logic,but the RedisNodeNotFoundException is fatal,the RedisNodeNotFoundException affects normal business logic and intolerable\r\ncan you help me see how to solve this RedisNodeNotFoundException?\r\n\r\n\r\n\r\n\r\n#slave\r\n011fd2e3aae7e69fc636bd1744642ed14bf0a1a7 132.18.54.81:36421@46421 slave 9831b60c5422cc961b05cb5d7bcd0cc7a1b7db4e 0 1693492105000 28 connected\r\nc0419f9492793b3c74aa4b1eb083ff34278b5a6f 132.18.54.80:36421@46421 slave f3db2e899fd14bfd2feae35e9191fbee478691df 0 1693492106255 29 connected\r\nd577fe7c71839dccd8bb315dfedd1724632111fe 132.18.54.79:36421@46421 slave b08aebda64e150fb181ff219d42ac487b8f7d7d6 0 1693492108258 30 connected\r\n5b3f227a49333b7e801a5af9436557ae764e7920 132.18.54.78:36421@46421 slave b8448e2164cb778dc345570a75380ee185b11afa 0 1693492104000 31 connected\r\n955cc718b66cdee9c8b954e57ef4509c6547b8c4 132.18.54.72:36421@46421 slave 9bfa406d12fbe4c0e62b5fc2f89a73ff0d19b5d4 0 1693492102000 33 connected\r\nba3b09daae54d1ebe566df5ca3a81f223782a302 132.18.54.103:36421@46421 slave 1d00caa09fbd95d4ad41641e6bb3245e4914c51e 0 1693492103000 34 connected\r\n5fa0c68c0026523f00c0ccbc133608adfdb636ce 132.18.54.102:36421@46421 slave ccddafeae47a5bd158186cbb200a1b987b495583 0 1693492109058 35 connected\r\n55b1dc3b3df8c5d59f7c8ad98fcad1d3f9405027 132.18.54.101:36421@46421 slave 3f0b3ba5f1c788f128c6acc0a0cd571d4369e00c 0 1693492103000 36 connected\r\n2e02ed575914c7f73b7c84a51a1bd26d9ec2c91b 132.18.54.81:36420@46420 slave 1e1120e053191601c89fd13df61e3b4e2d134736 0 1693492099000 37 connected\r\nc69eac6ebaa7ff5fd507e78a99e727622dfc8ab3 132.18.54.80:36420@46420 slave 4e148762f55cebbf868d7470d08a8d5a40ae6c5f 0 1693492109058 38 connected\r\n0d16b771126d4ae678d4fd7e3ddaa731633894b5 132.18.54.79:36420@46420 slave 8f3b44a94478da8b13c2f6af5f29531188b89128 0 1693492102000 39 connected\r\nd74232d907bcc9fed8358f5aec3ad235ddce0d70 132.18.54.78:36420@46420 slave 2ba474e9dff15d0eadc321f176d9b00c4be003db 0 1693492112264 40 connected\r\ne818ec452949eea5d9bf555dac71d419060bc106 132.18.54.72:36420@46420 slave 4232dcc072f4d85fbbd1bb3c9db4a7adc8d94418 0 1693492104000 42 connected\r\ne202c2c6b70941929f64af0817415c361aff81a3 132.18.54.103:36420@46420 slave 3032dc89587eb306f483d48830b26234daefde0d 0 1693492109259 43 connected\r\n1b6fb1c857c2ea338c43dafa66eae2524286d6e2 132.18.54.102:36420@46420 slave 0047baedc6bfe230e6349a53e5fab107df4d5539 0 1693492101247 44 connected\r\n9c7bd034a843b2dbadb9a444d3f173b570d6f247 132.18.54.101:36420@46420 slave 523e0488ddcb9458fc9973d813d2221f554ff0ab 0 1693492101047 45 connected\r\naf217275cad115c62eacfdc7f83895e1ef84c94d 132.18.54.81:36419@46419 slave 191ba25cd354b2569fa8e2f66a6c46b111e51472 0 1693492106000 46 connected\r\nb391f09b3060559c4788df01e1748525159905bb 132.18.54.73:36419@46419 slave 83272084566a40203df40f211cd3ab4cbd8dbaff 0 1693492104000 47 connected\r\n0415bf16cf7d1c68fdcc0809e53cee6a52490fcf 132.18.54.101:36419@46419 myself,slave 64ee11fa98839f32835b4c353c7b19b5d52f4273 0 1693492105000 48 connected\r\n668e91b0faea4bbec903c2e38331c65d67d5792c 132.18.54.78:36419@46419 slave 00ad2de54a96130ddfc3e00cd8a2b36b9ae54a47 0 1693492103000 50 connected\r\ne16f19c158fcece008187abad13f1007ea5c713f 132.18.54.102:36419@46419 slave 7c7bbaec4ec51da66454c049e782181d3ea027a6 0 1693492106000 51 connected\r\n02ad5435c83076fa6f32d39ae3517d84bbb49814 132.18.54.80:36419@46419 slave df25fb86078cd9bd3b10e2bfd16a22d3b0068766 0 1693492103000 52 connected\r\nabaa6870de92564ef8559fa21bb09586caa61e83 132.18.54.103:36419@46419 slave be76a5ad93584314d29f1ef3df38c1d2f214cb5e 0 1693492108057 53 connected\r\n12f5809cbe0cdc6f9a20f8b79421e69650b01c65 132.18.54.79:36419@46419 slave 4295acbd0ec852e4d15f0a7a333613769fd8c616 0 1693492109000 54 connected\r\n589f646ac44fd61e36af58cde5bf15190e353a2c 132.18.54.72:36419@46419 slave 8805ecc5cc2eed1d3d116054d7225601e8cf52b5 0 1693492108000  connected\r\nded38affee582fe80208547a08c3656777eb621d 132.18.54.73:36421@46421 slave a60bd125a894c2293b97c8533c27ca265dc04fde 0 1693492104251 8 connected\r\n5644e2eac432138794416b812cdee1a83ca5659b 132.18.54.73:36420@46420 slave fade84654be507439b00fee41e96a565c3115dc7 0 1693492106000 25 connected\r\n#master\r\nccddafeae47a5bd158186cbb200a1b987b495583 132.18.54.101:36424@46424 master - 0 1693492101000 1 connected 0-606\r\n1d00caa09fbd95d4ad41641e6bb3245e4914c51e 132.18.54.102:36424@46424 master - 0 1693492108000 2 connected 607-1213\r\n9bfa406d12fbe4c0e62b5fc2f89a73ff0d19b5d4 132.18.54.103:36424@46424 master - 0 1693492106000 3 connected 1214-1819\r\n83272084566a40203df40f211cd3ab4cbd8dbaff 132.18.54.72:36424@46424 master - 0 1693492109000 4 connected 1820-2426\r\nb8448e2164cb778dc345570a75380ee185b11afa 132.18.54.73:36424@46424 master - 0 1693492107000 5 connected 2427-3033\r\nb08aebda64e150fb181ff219d42ac487b8f7d7d6 132.18.54.78:36424@46424 master - 0 1693492098000 6 connected 3034-3640\r\nf3db2e899fd14bfd2feae35e9191fbee478691df 132.18.54.79:36424@46424 master - 0 1693492109000 7 connected 3641-4247\r\na60bd125a894c2293b97c8533c27ca265dc04fde 132.18.54.80:36424@46424 master - 0 1693492107000 8 connected 4248-4854\r\n523e0488ddcb9458fc9973d813d2221f554ff0ab 132.18.54.81:36424@46424 master - 0 1693492106000 9 connected 4855-5460\r\n0047baedc6bfe230e6349a53e5fab107df4d5539 132.18.54.101:36423@46423 master - 0 1693492107000 10 connected 5461-6067\r\n3032dc89587eb306f483d48830b26234daefde0d 132.18.54.102:36423@46423 master - 0 1693492105000 11 connected 6068-6674\r\n4232dcc072f4d85fbbd1bb3c9db4a7adc8d94418 132.18.54.103:36423@46423 master - 0 1693492111000 12 connected 6675-7281\r\n2ba474e9dff15d0eadc321f176d9b00c4be003db 132.18.54.72:36423@46423 master - 0 1693492107000 13 connected 7282-7888\r\n8f3b44a94478da8b13c2f6af5f29531188b89128 132.18.54.73:36423@46423 master - 0 1693492111061 14 connected 7889-8494\r\n4e148762f55cebbf868d7470d08a8d5a40ae6c5f 132.18.54.78:36423@46423 master - 0 1693492099000 15 connected 8495-9101\r\n9831b60c5422cc961b05cb5d7bcd0cc7a1b7db4e 132.18.54.79:36423@46423 master - 0 1693492110260 16 connected 9102-9708\r\n64ee11fa98839f32835b4c353c7b19b5d52f4273 132.18.54.80:36423@46423 master - 0 1693492111262 17 connected 9709-10315\r\n7c7bbaec4ec51da66454c049e782181d3ea027a6 132.18.54.81:36423@46423 master - 0 1693492110000 18 connected 10316-10922\r\nbe76a5ad93584314d29f1ef3df38c1d2f214cb5e 132.18.54.101:36422@46422 master - 0 1693492104000 19 connected 10923-11528\r\n00ad2de54a96130ddfc3e00cd8a2b36b9ae54a47 132.18.54.102:36422@46422 master - 0 1693492107000 20 connected 11529-12135\r\n4295acbd0ec852e4d15f0a7a333613769fd8c616 132.18.54.103:36422@46422 master - 0 1693492103000 21 connected 12136-12742\r\ndf25fb86078cd9bd3b10e2bfd16a22d3b0068766 132.18.54.72:36422@46422 master - 0 1693492102000 22 connected 12743-13349\r\n8805ecc5cc2eed1d3d116054d7225601e8cf52b5 132.18.54.73:36422@46422 master - 0 1693492106000 23 connected 13350-13956\r\n1e1120e053191601c89fd13df61e3b4e2d134736 132.18.54.78:36422@46422 master - 0 1693492111061 24 connected 13957-14563\r\nfade84654be507439b00fee41e96a565c3115dc7 132.18.54.79:36422@46422 master - 0 1693492107000 25 connected 14564-15169\r\n191ba25cd354b2569fa8e2f66a6c46b111e51472 132.18.54.80:36422@46422 master - 0 1693492111061 26 connected 15170-15776\r\n3f0b3ba5f1c788f128c6acc0a0cd571d4369e00c 132.18.54.81:36422@46422 master - 0 1693492105253 27 connected 15777-16383\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2023-09-26T13:22:44Z",
        "body": "RedisNodeNotFoundException may arise if node was removed due to rare issue in topology handling. It was fixed in 3.23.4."
      },
      {
        "user": "repeatthink123yuchao",
        "created_at": "2023-09-27T01:18:22Z",
        "body": "> RedisNodeNotFoundException may arise if node was removed due to rare issue in topology handling. It was fixed in 3.23.4.\r\n\r\nI'll try it first and get back to you with the test results later. \r\n\r\nthank you "
      },
      {
        "user": "repeatthink123yuchao",
        "created_at": "2023-10-13T04:10:52Z",
        "body": "> RedisNodeNotFoundException may arise if node was removed due to rare issue in topology handling. It was fixed in 3.23.4.\r\n\r\nThank you very much, this problem is solved"
      }
    ]
  },
  {
    "number": 5332,
    "title": "how to remove subscriptionConnection configuration",
    "created_at": "2023-09-26T08:13:47Z",
    "closed_at": "2023-09-26T13:24:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5332",
    "body": "I only use Redisson for the purpose of storing session data. \r\nThe Redisson configuration includes the subscriptionConnectionPoolSize setting by default. \r\nIs there a way to remove this setting? \r\nAlso, I am curious if there will be any issues with storing or retrieving session data if this setting is removed.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5332/comments",
    "author": "unasd",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-09-26T13:24:49Z",
        "body": "set subscriptionConnectionMinimumIdleSize = 0"
      },
      {
        "user": "unasd",
        "created_at": "2023-10-11T01:45:55Z",
        "body": "thank you\r\nI configured it as you suggested and noticed that redis connections decreased.\r\nHowever, an error occurs during initialization. Can I ignore it?\r\n\r\nThe settings and error message are as follows.\r\n\r\nsettings\r\n```yaml\r\nsingleServerConfig:\r\n  idleConnectionTimeout: 10000\r\n  connectTimeout: 10000\r\n  timeout: 3000\r\n  retryAttempts: 3\r\n  retryInterval: 1500\r\n  subscriptionsPerConnection: 0\r\n  clientName: \"client\"\r\n  address: \"rediss://redis.cache.windows.net:6380\"\r\n  password: \"xxxx\r\n  subscriptionConnectionMinimumIdleSize: 0\r\n  subscriptionConnectionPoolSize: 0\r\n  connectionMinimumIdleSize: 1\r\n  connectionPoolSize: 10\r\n  database: 0\r\n  dnsMonitoringInterval: 5000\r\ncodec: !<org.redisson.codec.SerializationCodec> {}\r\n```\r\n\r\nerror message\r\n```java\r\n[2023-10-11 09:34:11:701][DEBUG][org.redisson.command.RedisExecutor:sendCommand:616] acquired connection for command (PUBLISH) and params [[100, 108, 101, 110, 99, 58, 100, 103, 119, 50, ...], [-84, -19, 0, 5, 115, 114, 0, 17, 106, 97, ...]] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node redis.cache.windows.net/10.10.10.10:6380... RedisConnection@842035855 [redisClient=[addr=rediss://redis.cache.windows.net:6380], channel=[id: 0x4e55af9d, L:/10.10.10.10:47354 - R:redis.cache.windows.net/10.10.10.10:6380], currentCommand=null, usage=1]\r\n[2023-10-11 09:34:11:705][DEBUG][org.redisson.command.RedisExecutor:releaseConnection:651] connection released for command (PUBLISH) and params [[100, 108, 101, 110, 99, 58, 100, 103, 119, 50, ...], [-84, -19, 0, 5, 115, 114, 0, 17, 106, 97, ...]] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@842035855 [redisClient=[addr=rediss://redis.cache.windows.net:6380], channel=[id: 0x4e55af9d, L:/10.10.10.10:47354 - R:redis.cache.windows.net/10.10.10.10:6380], currentCommand=CommandData [promise=java.util.concurrent.CompletableFuture@1615c3e0[Completed normally], command=(PUBLISH), params=[[100, 108, 101, 110, 99, 58, 100, 103, 119, 50, ...], [-84, -19, 0, 5, 115, 114, 0, 17, 106, 97, ...]], codec=org.redisson.client.codec.StringCodec], usage=0]\r\n[2023-10-11 09:34:12:774][ERROR][org.springframework.data.redis.listener.RedisMessageListenerContainer:handleSubscriptionException:656] SubscriptionTask aborted with exception:\r\norg.redisson.client.RedisTimeoutException: Unable to acquire connection for subscription after 3 attempts. Increase 'subscriptionsPerConnection' and/or 'subscriptionConnectionPoolSize' parameters.\r\n\tat org.redisson.pubsub.PublishSubscribeService.trySubscribe(PublishSubscribeService.java:349) ~[redisson-3.23.4.jar:3.23.4]\r\n\tat org.redisson.pubsub.PublishSubscribeService.lambda$connect$21(PublishSubscribeService.java:486) ~[redisson-3.23.4.jar:3.23.4]\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:669) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:744) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:469) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat java.lang.Thread.run(Thread.java:750) [?:1.8.0_372]\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2023-10-12T13:19:38Z",
        "body": "you need to remove RedisMessageListenerContainer"
      }
    ]
  },
  {
    "number": 5309,
    "title": "Find cause of NotSerializableException: java.util.ArrayList$SubList ",
    "created_at": "2023-09-14T12:53:18Z",
    "closed_at": "2023-09-26T13:51:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5309",
    "body": "I'm trying to find the cause of a NotSerializable Exception, but the app only logs redisson stack. \r\nI already check and my code doesn't have any sublist, so I was wondering how can I find the origin of the problem? \r\n\r\nThis is the log:\r\n```\r\njava.io.NotSerializableException: java.util.ArrayList$SubList\r\n            org.redisson.command.CommandAsyncService.encodeMapValue(CommandAsyncService.java:669)\r\n                              org.redisson.RedissonObject.encodeMapValue(RedissonObject.java:351)\r\n                                     org.redisson.RedissonMap.encodeMapKeys(RedissonMap.java:1051)\r\n                              org.redisson.RedissonMap.putAllOperationAsync(RedissonMap.java:775)\r\n                                       org.redisson.RedissonMap.putAllAsync(RedissonMap.java:716)\r\n                                            org.redisson.RedissonMap.putAll(RedissonMap.java:669)\r\n                               org.redisson.tomcat.RedissonSession.save(RedissonSession.java:428)\r\n                org.redisson.tomcat.RedissonSessionManager.store(RedissonSessionManager.java:419)\r\n                                     org.redisson.tomcat.UpdateValve.invoke(UpdateValve.java:74)\r\n           org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n                    org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)\r\n                    org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)\r\n        org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:698)\r\n                org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n                      org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:364)\r\n                       org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:624)\r\n                org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n          org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:831)\r\n               org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1650)\r\n                 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n         org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\r\n        org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\r\n              org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n                                                            java.lang.Thread.run(Thread.java:748)\r\n\r\ncaused by java.io.NotSerializableException: java.util.ArrayList$SubList\r\n                             java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)\r\n                       java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1548)\r\n                          java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1509)\r\n                      java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432)\r\n                             java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178)\r\n                              java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)\r\n                                         java.util.HashMap.internalWriteEntries(HashMap.java:1793)\r\n                                                  java.util.HashMap.writeObject(HashMap.java:1363)\r\n                                sun.reflect.GeneratedMethodAccessor239.invoke(Unknown Source)\r\n           sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n                                                 java.lang.reflect.Method.invoke(Method.java:498)\r\n                          java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:1155)\r\n                          java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1496)\r\n                      java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432)\r\n                             java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178)\r\n                              java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)\r\n                             java.util.LinkedHashMap.internalWriteEntries(LinkedHashMap.java:333)\r\n                                                  java.util.HashMap.writeObject(HashMap.java:1363)\r\n                                sun.reflect.GeneratedMethodAccessor239.invoke(Unknown Source)\r\n           sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n                                                 java.lang.reflect.Method.invoke(Method.java:498)\r\n                          java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:1155)\r\n                          java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1496)\r\n                      java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432)\r\n                             java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178)\r\n                       java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1548)\r\n                       java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:441)\r\n                          java.util.Collections$SynchronizedMap.writeObject(Collections.java:2693)\r\n                                sun.reflect.GeneratedMethodAccessor355.invoke(Unknown Source)\r\n           sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n                                                 java.lang.reflect.Method.invoke(Method.java:498)\r\n                          java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:1155)\r\n                          java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1496)\r\n                      java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432)\r\n                             java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178)\r\n                              java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)\r\n                      org.redisson.codec.SerializationCodec$2.encode(SerializationCodec.java:78)\r\n            org.redisson.command.CommandAsyncService.encodeMapValue(CommandAsyncService.java:667)\r\n                              org.redisson.RedissonObject.encodeMapValue(RedissonObject.java:351)\r\n                                     org.redisson.RedissonMap.encodeMapKeys(RedissonMap.java:1051)\r\n                              org.redisson.RedissonMap.putAllOperationAsync(RedissonMap.java:775)\r\n                                       org.redisson.RedissonMap.putAllAsync(RedissonMap.java:716)\r\n                                            org.redisson.RedissonMap.putAll(RedissonMap.java:669)\r\n                               org.redisson.tomcat.RedissonSession.save(RedissonSession.java:428)\r\n                org.redisson.tomcat.RedissonSessionManager.store(RedissonSessionManager.java:419)\r\n                                     org.redisson.tomcat.UpdateValve.invoke(UpdateValve.java:74)\r\n           org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n                    org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)\r\n                    org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)\r\n        org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:698)\r\n                org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n                      org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:364)\r\n                       org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:624)\r\n                org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n          org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:831)\r\n               org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1650)\r\n                 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n         org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\r\n        org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\r\n              org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n                                                            java.lang.Thread.run(Thread.java:748)\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5309/comments",
    "author": "marcelocastrillo",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-09-15T07:08:13Z",
        "body": "You are using object returned by ArrayList.subList() method. Try to use a different codec."
      }
    ]
  },
  {
    "number": 5302,
    "title": "ERR unknown command 'READONLY'.",
    "created_at": "2023-09-12T07:20:50Z",
    "closed_at": "2023-09-13T07:28:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5302",
    "body": "Hi,\r\nwe are facing this issue while using cluster mode (i.e. \r\n\tredissonConfig.useClusterServers().addNodeAddress(\"redis://host:port\"))\r\n)\r\nERROR||||: [o.redisson.connection.balancer.LoadBalancerManager] Unable to unfreeze entry: [freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:51:queue:0, freeConnectionsAmount=0, freeConnectionsCounter=value:65:queue:0, freezeReason=SYSTEM, client=[addr=redis://1\r\nnodeType=MASTER, firstFail=0]\r\njava.util.concurrent.CompletionException: org.redisson.client.RedisConnectionException: Unable to connect to Redis server: \r\n\tat java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)\r\n\tat java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)\r\n\tat java.base/java.util.concurrent.CompletableFuture$BiRelay.tryFire(CompletableFuture.java:1498)\r\n\tat java.base/java.util.concurrent.CompletableFuture$CoCompletion.tryFire(CompletableFuture.java:1219)\r\n\tat java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)\r\n\tat java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)\r\n\tat org.redisson.connection.pool.ConnectionPool.lambda$createConnection$0(ConnectionPool.java:133)\r\n\tat java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863)\r\n\tat java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841)\r\n\tat java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)\r\n\tat java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)\r\n\tat org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:294)\r\n\tat org.redisson.connection.pool.ConnectionPool.lambda$createConnection$6(ConnectionPool.java:253)\r\n\tat java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863)\r\n\tat java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841)\r\n\tat java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)\r\n\tat java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)\r\n\tat org.redisson.client.RedisClient$2$1.run(RedisClient.java:305)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.runTask(AbstractEventExecutor.java:174)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:167)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:470)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:569)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:833)\r\nCaused by: org.redisson.client.RedisConnectionException: Unable to connect to Redis server: \r\n\tat org.redisson.connection.pool.ConnectionPool.lambda$createConnection$0(ConnectionPool.java:132)\r\n\tat java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863)\r\n\tat java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841)\r\n\tat java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)\r\n\tat java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)\r\n\tat org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:294)\r\n\tat org.redisson.connection.pool.ConnectionPool.lambda$createConnection$6(ConnectionPool.java:253)\r\n\tat java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863)\r\n\tat java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841)\r\n\tat java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)\r\n\tat java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)\r\n\tat org.redisson.client.RedisClient$1$1.run(RedisClient.java:248)\r\n\t... 8 common frames omitted",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5302/comments",
    "author": "teegen25",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-09-13T07:28:25Z",
        "body": "Check your Redis version. Since only 3.0.0+ Redis is supported"
      }
    ]
  },
  {
    "number": 5298,
    "title": "How to successfully use Live Objects ?",
    "created_at": "2023-09-08T21:31:58Z",
    "closed_at": "2023-09-13T08:13:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5298",
    "body": "I'm having difficulty with two different parts of the Live Objects feature of Redisson:\r\n\r\n1. Storing a nested `Map<String, String>` as a field of an '@REntity`\r\n2. Using a condition to `find()` instances that I know are stored.\r\n\r\nHere's my live object class (I'm using Lombok, hence the @Getter, etc annotations):\r\n```java\r\n@RequiredArgsConstructor\r\n@NoArgsConstructor(access = PROTECTED)\r\n@REntity(codec = StringCodec.class)\r\npublic class Manifest {\r\n\r\n\t@RId(generator = UUIDGenerator.class)\r\n\t@Getter\r\n\tprivate String id;\r\n\r\n\t@RIndex\r\n\t@Getter\r\n\tprivate String jobId;\r\n\r\n\t@RIndex\r\n\t@Getter\r\n\tprivate String rootFolder;\r\n\r\n\t@RCascade(ALL)  // Not sure this is needed, it doesn't seem to make any difference\r\n\tprivate Map<String, String> entries = new HashMap<>();\r\n\r\n\r\n\tpublic void add(String path, String hash) {\r\n\t\tentries.put(path, hash);\r\n\t}\r\n\r\n\t@Transient\r\n\tpublic int getSize() {\r\n\t\treturn entries.size();\r\n\t}\r\n\r\n}\r\n```\r\n\r\nI'm using this code to initially create and store the live object:\r\n```java\r\n\tRLiveObjectService liveObjects = redisson.getLiveObjectService();\r\n\tvar manifest = new Manifest(jobID, rootPath);\r\n\tmanifest = liveObjects.persist(manifest);\r\n\tliveObjects.asLiveObject(manifest).expire(Duration.ofMinutes(60));\r\n```\r\n\r\nElsewhere I use this code to get the object by ID and add data to its `entries` map:\r\n```java\r\n\tManifest manifest = liveObjects.get(Manifest.class, id);\r\n\tmanifest.add(path, hash);\r\n```\r\n\r\nSomewhere else, I use this code to find the object:\r\n```java\r\n\tpublic static Condition jobIDEquals(String jobID) {\r\n\t\treturn Conditions.eq(\"jobId\", jobID);\r\n\t}\r\n\r\n\tCollection<Manifest> manifests = liveObjects.find(Manifest.class, jobIDEquals(jobID));\r\n```\r\n\r\nWith the code above, the two problems are:\r\n1. The `manifests` collection is empty, even though I can inspect my Redis server (using RedisInsight) and see the hashes stored there with matching `jobId` values.\r\n2. If I load one of the objects directly by its `id`, the `entries` Map is always empty, _even after_ having added values to it. I see in RedisInsight that the value of `entries` is `org.redisson.RedissonReference@7623beea`, but there is no other key in Redis that corresponds to that reference.\r\n\r\nWhat am I doing wrong?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5298/comments",
    "author": "eric-creekside",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-09-09T04:47:34Z",
        "body": "You need to define getters and constructors explicitly"
      },
      {
        "user": "eric-creekside",
        "created_at": "2023-09-10T21:52:06Z",
        "body": "That solved some of the problems, thanks. I strongly suggest you make this clear in the documentation and examples that Live Objects can not use getters/setters/constructors that are generated by byte-code tools. Lombok is very popular and commonly used. It could save other users a lot of time knowing to avoid using it in their `@REntity` objects."
      },
      {
        "user": "eric-creekside",
        "created_at": "2023-09-10T21:59:48Z",
        "body": "As I tested more, I was still seeing the situation where values I had added to my nested `entries` `Map<>` were not getting persisted, so when a later process loaded the objects with `find()`, `entries` was empty. I discovered that my `Manifest.add()` method had to use the getter to reference `entities`. Specifically, this code did *not* work:\r\n```java\r\n\tpublic void add(String path, String hash) {\r\n\t\tentries.put(path, hash);\r\n\t}\r\n```\r\nbut this code does work:\r\n```java\r\n\tpublic void add(String path, String hash) {\r\n\t\tgetEntries().put(path, hash);\r\n\t}\r\n```\r\n\r\nI think this is another opportunity to improve the documentation and examples by making it clear that collection fields of the live object have to be de-referenced from the proxy in order to have their contents persisted.\r\n\r\nIf possible, it would be good to also detect that situation at runtime and log a warning."
      },
      {
        "user": "mrniko",
        "created_at": "2023-09-13T08:13:57Z",
        "body": "Follow statement added to the documentation: `Getters/setters/constructors can't be generated by byte-code tools like Lombok. Additional methods should use getters and not fields. `"
      }
    ]
  },
  {
    "number": 5297,
    "title": "Encountered unregistered class ID",
    "created_at": "2023-09-08T20:38:18Z",
    "closed_at": "2023-09-09T04:42:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5297",
    "body": "Hi!\r\n\r\nI'm having the follow error whenever a message is published to Redis. Anything whatsoever, including just strings. I cannot figure out where it's coming from. I am registering the listener as follow:\r\n\r\n```java\r\nthis.redissonClient.getPatternTopic(\"*\").addListenerAsync(String.class, new RedisListener(server));\r\n```\r\n\r\n```\r\n[20:35:07 ERROR] [org.redisson.client.handler.CommandPubSubDecoder]: Unable to decode data. channel: [id: 0x34040095, L:/172.18.0.4:60388 - R:15.204.174.230/15.204.174.230:8001], reply: ReplayingDecoderByteBuf(ridx=43, widx=43)\r\ncom.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: 91\r\n        at com.esotericsoftware.kryo.util.DefaultClassResolver.readClass(DefaultClassResolver.java:159) ~[?:?]\r\n        at com.esotericsoftware.kryo.Kryo.readClass(Kryo.java:758) ~[?:?]\r\n        at com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:869) ~[?:?]\r\n        at org.redisson.codec.Kryo5Codec$4.decode(Kryo5Codec.java:144) ~[?:?]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:394) ~[?:?]\r\n        at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:442) ~[?:?]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:403) ~[?:?]\r\n        at org.redisson.client.handler.CommandPubSubDecoder.decodeCommand(CommandPubSubDecoder.java:88) ~[?:?]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:144) ~[?:?]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:94) ~[?:?]\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:529) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at java.lang.Thread.run(Thread.java:887) [?:?]\r\n[20:35:07 ERROR] [org.redisson.client.handler.ErrorsLoggingHandler]: Exception occured. Channel: [id: 0x34040095, L:/172.18.0.4:60388 - R:15.204.174.230/15.204.174.230:8001]\r\nio.netty.handler.codec.DecoderException: com.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: 91\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at java.lang.Thread.run(Thread.java:887) [?:?]\r\nCaused by: com.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: 91\r\n        at com.esotericsoftware.kryo.util.DefaultClassResolver.readClass(DefaultClassResolver.java:159) ~[?:?]\r\n        at com.esotericsoftware.kryo.Kryo.readClass(Kryo.java:758) ~[?:?]\r\n        at com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:869) ~[?:?]\r\n        at org.redisson.codec.Kryo5Codec$4.decode(Kryo5Codec.java:144) ~[?:?]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:394) ~[?:?]\r\n        at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:442) ~[?:?]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:403) ~[?:?]\r\n        at org.redisson.client.handler.CommandPubSubDecoder.decodeCommand(CommandPubSubDecoder.java:88) ~[?:?]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:144) ~[?:?]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:94) ~[?:?]\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:529) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[server.jar:3.2.0-SNAPSHOT (git-19abb909-b265)]\r\n        ... 17 more\r\n\r\n```\r\n\r\nAnyone know where the issue is coming from and how I can fix it?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5297/comments",
    "author": "Loudbooks",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-09-09T04:42:08Z",
        "body": "You need to override org.redisson.codec.Kryo5Codec#createKryo() method and register missed classes.\r\n\r\nthrough \r\n```java\r\nkryo.addDefaultSerializer(MyClass.class, new JavaSerializer());\r\n```"
      },
      {
        "user": "phial3",
        "created_at": "2023-09-18T08:10:50Z",
        "body": "> You need to override org.redisson.codec.Kryo5Codec#createKryo() method and register missed classes.\r\n> \r\n> through\r\n> \r\n> ```java\r\n> kryo.addDefaultSerializer(MyClass.class, new JavaSerializer());\r\n> ```\r\n\r\n\r\n\r\n> You need to override org.redisson.codec.Kryo5Codec#createKryo() method and register missed classes.\r\n> \r\n> through\r\n> \r\n> ```java\r\n> kryo.addDefaultSerializer(MyClass.class, new JavaSerializer());\r\n> ```\r\n\r\nwhat should i do \r\n"
      }
    ]
  },
  {
    "number": 5289,
    "title": "redission使用increment的时候报错，类型错误",
    "created_at": "2023-09-04T06:14:48Z",
    "closed_at": "2023-09-04T07:15:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5289",
    "body": "` public static Long increment(String key, long val) {\r\n        return redisTemplate.opsForValue().increment(key, val);\r\n    }`\r\n    我已经使用了StringRedisTemplate 序列化类是正确的，但是仍然报错\r\n    ramework.dao.InvalidDataAccessApiUsageException: ERR value is not an integer or out of range.\r\n    command: (INCRBY), promise: java.util.concurrent.CompletableFuture@24c4bac6[Not completed, 1 dependents], params: [[65, 74, 46, 67, 65, 80, 84, 67, 72, 65, ...], 1]\r\n    \r\n    key是一个String value是Long 排查不出其他问题",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5289/comments",
    "author": "kevinh458",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-09-04T07:15:09Z",
        "body": "This issue arise if non-integer value was stored before by the same key."
      }
    ]
  },
  {
    "number": 5288,
    "title": "RedisTimeoutException: Unable to acquire connection and Redisson is shutdown",
    "created_at": "2023-08-30T21:56:32Z",
    "closed_at": "2023-09-09T04:49:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5288",
    "body": "Recently we encountered this problem online, and the addition of retryTimes does not work, can you share the reason, the following are some of the error logs.\r\n\r\n1. \r\n`java.util.concurrent.CompletionException: org.redisson.client.RedisTimeoutException: Unable to acquire connection! java.util.concurrent.CompletableFuture@3d511574[Completed exceptionally]Increase connection pool size. Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=1, freeConnectionsCounter=value:0:queue:18798, freezeReason=null, client=[addr=redis://r-rj95styb5q4i0hc1rp.redis.rds.aliyuncs.com:6379], nodeType=MASTER, firstFail=0]]], command: null, params: null after 2 retry attempts\r\n        at org.redisson.RedissonBaseLock.lambda$evalWriteAsync$0(RedissonBaseLock.java:226)\r\n        at java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:836)\r\n        at java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:811)\r\n        at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)\r\n        at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)\r\n        at org.redisson.command.CommandBatchService.lambda$executeAsync$7(CommandBatchService.java:284)\r\n        at java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:774)\r\n        at java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:750)\r\n        at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)\r\n        at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)\r\n        at org.redisson.command.RedisCommonBatchExecutor.handleResult(RedisCommonBatchExecutor.java:166)\r\n        at org.redisson.command.RedisExecutor.checkAttemptPromise(RedisExecutor.java:524)\r\n        at org.redisson.command.RedisExecutor.lambda$execute$4(RedisExecutor.java:176)\r\n        at java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:774)\r\n        at java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:750)\r\n        at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)\r\n        at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)\r\n        at org.redisson.command.RedisExecutor$1.run(RedisExecutor.java:256)\r\n        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715)\r\n        at io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34)\r\n        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703)\r\n        at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790)\r\n        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.lang.Thread.run(Thread.java:750)\r\nCaused by: org.redisson.client.RedisTimeoutException: Unable to acquire connection! java.util.concurrent.CompletableFuture@3d511574[Completed exceptionally]Increase connection pool size. Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=1, freeConnectionsCounter=value:0:queue:18798, freezeReason=null, client=[addr=redis://xxx.xxx.xxx.xxx:6379], nodeType=MASTER, firstFail=0]]], command: null, params: null after 2 retry attempts\r\n        at org.redisson.command.RedisExecutor$1.run(RedisExecutor.java:241)\r\n        ... 7 common frames omitted`\r\n\r\n\r\n2.\r\n`java.util.concurrent.CompletionException: org.redisson.RedissonShutdownException: Redisson is shutdown\r\n        at org.redisson.RedissonBaseLock.lambda$evalWriteAsync$0(RedissonBaseLock.java:226)\r\n        at java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:836)\r\n        at java.util.concurrent.CompletableFuture.uniHandleStage(CompletableFuture.java:848)\r\n        at java.util.concurrent.CompletableFuture.handle(CompletableFuture.java:2168)\r\n        at org.redisson.misc.CompletableFutureWrapper.handle(CompletableFutureWrapper.java:208)\r\n        at org.redisson.RedissonBaseLock.evalWriteAsync(RedissonBaseLock.java:224)\r\n        at org.redisson.RedissonBaseLock.renewExpirationAsync(RedissonBaseLock.java:179)\r\n        at org.redisson.RedissonBaseLock$1.run(RedissonBaseLock.java:140)\r\n        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715)\r\n        at io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34)\r\n        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703)\r\n        at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790)\r\n        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.lang.Thread.run(Thread.java:750)\r\nCaused by: org.redisson.RedissonShutdownException: Redisson is shutdown\r\n        at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:118)\r\n        at org.redisson.command.CommandBatchService.executeAsync(CommandBatchService.java:345)\r\n        at org.redisson.RedissonBaseLock.evalWriteAsync(RedissonBaseLock.java:223)\r\n        ... 9 common frames omitted`\r\n\r\n3\r\n`2023-08-26 13:34:24 [schedule-pool-5] ERROR o.s.s.s.TaskUtils$LoggingErrorHandler - Unexpected error occurred in scheduled task\r\norg.redisson.client.RedisException: java.lang.InterruptedException\r\n        at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:113)\r\n        at org.redisson.RedissonKeys$2.iterator(RedissonKeys.java:152)\r\n        at org.redisson.iterator.BaseIterator.hasNext(BaseIterator.java:55)\r\n        at org.redisson.misc.CompositeIterator.hasNext(CompositeIterator.java:38)\r\n        at cn.hutool.core.collection.ListUtil.list(ListUtil.java:106)\r\n        at cn.hutool.core.collection.ListUtil.toList(ListUtil.java:220)\r\n        at cn.hutool.core.collection.IterUtil.toList(IterUtil.java:519)\r\n        at cn.hutool.core.collection.IterUtil.toList(IterUtil.java:506)\r\n        at com.xxx.components.tool.utils.redis.RedisUtils.keys(RedisUtils.java:395)\r\n        at xxxxx \r\n        at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n        at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:783)\r\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n        at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:753)\r\n        at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:89)\r\n\r\n\r\n        at org.springframework.scheduling.support.ScheduledMethodRunnable.run(ScheduledMethodRunnable.java:84)\r\n        at org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54)\r\n        at org.springframework.scheduling.concurrent.ReschedulingRunnable.run(ReschedulingRunnable.java:95)\r\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\r\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\r\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n        at java.lang.Thread.run(Thread.java:750)\r\nCaused by: java.lang.InterruptedException: null\r\n        at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:347)\r\n        at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1908)\r\n        at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:109)\r\n        ... 44 common frames omitted\r\n2023-08-26 13:34:24 [schedule-pool-5] ERROR c.a.components.tool.utils.Threads - null\r\njava.util.concurrent.CancellationException: null\r\n        at java.util.concurrent.FutureTask.report(FutureTask.java:121)\r\n        at java.util.concurrent.FutureTask.get(FutureTask.java:192)\r\n        at com.xxx.components.tool.utils.Threads.printException(Threads.java:59)\r\n        at com.xxx.components.tool.config.ThreadPoolConfig$1.afterExecute(ThreadPoolConfig.java:51)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1157)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n        at java.lang.Thread.run(Thread.java:750)`\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5288/comments",
    "author": "Taylo0or",
    "comments": [
      {
        "user": "Taylo0or",
        "created_at": "2023-08-30T22:29:01Z",
        "body": "Redisson Version:  3.17.7\r\n"
      },
      {
        "user": "Taylo0or",
        "created_at": "2023-08-30T22:44:32Z",
        "body": "@mrniko please help me [苦涩]\r\n\r\n\r\n\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2023-09-09T04:49:23Z",
        "body": "> Increase connection pool size\r\n\r\nTry to do it"
      }
    ]
  },
  {
    "number": 5285,
    "title": "RSorted Map comparator not working correctly",
    "created_at": "2023-08-30T07:29:11Z",
    "closed_at": "2023-10-04T17:44:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5285",
    "body": "Trying to create a sorted map with a custom comparator for duplicate detection. For some reason  comparator is set, however duplicates are getting added to the sorted set.  \r\n\r\npublic class RedissonMessagingMgrTest {\r\n\r\n    private static MessagingMgr mgr = null;\r\n\r\n    @BeforeAll\r\n    public static void setUp() {\r\n       try {\r\n          mgr = new RedissonMessagingMgr(\"127.0.0.1\",6379,\"nishi\");\r\n       }\r\n       catch (Exception exception) {\r\n          exception.printStackTrace();\r\n       }\r\n    }\r\n\r\n    @Test\r\n    public void  testPublishNoDupQueue100() {\r\n        String queueName = \"NoDupQueue100\";\r\n        int msgCount=1;\r\n        boolean isPublished = false;\r\n        String str = \"This is my string as bytes\";\r\n        \r\n        mgr.createNoDupQueue(queueName, new TestMsgComparator());\r\n        byte[] bytes = null;\r\n        int i=0;\r\n        for ( i=0;i<msgCount;i++) {\r\n            str =  str + i;\r\n            bytes = str.getBytes();\r\n            TestMsg msg = new TestMsg(i,bytes, System.currentTimeMillis() );\r\n            isPublished = mgr.publishNoDupQueue(queueName,msg);\r\n        }\r\n        isPublished = mgr.publishNoDupQueue(queueName,new TestMsg(0,bytes, System.currentTimeMillis()));  \r\n        assertFalse(isPublished,\"No Duplicates Allowed\");\r\n    }\r\n\r\n}\r\n   \r\nMy Comparator class is as below:-\r\n\r\nimport java.util.Comparator;\r\n\r\npublic class TestMsgComparator implements Comparator<TestMsg> {\r\n    \r\n    @Override\r\n    public int compare(TestMsg a, TestMsg b)\r\n    {\r\n        return a.number  - b.number;\r\n    }\r\n}\r\n\r\nThe sorted set will contain objects of TestMsg\r\n\r\npublic class TestMsg implements PubSubMessage,  Serializable {\r\n    private byte[] data;\r\n    public int number;\r\n    private long timestamp;\r\n\r\n    public TestMsg(int number, byte[] data, long ts) {\r\n        this.number = number;\r\n        this.data = data;\r\n        this.timestamp = ts;\r\n    }\r\n\r\n    public long getNumber() {\r\n        return number;\r\n    }\r\n\r\n    public byte[] getData() {\r\n        return data;\r\n    }\r\n\r\n    public long getSortedScore() {\r\n        return timestamp;\r\n    } \r\n}\r\n\r\npublic class RedissonMessagingMgr implements MessagingMgr {\r\n\r\n   private static Logger log = LoggerFactory.getLogger(RedissonMessagingMgr.class);\r\n   private RedissonClient client = null;\r\n\r\n   public RedissonMessagingMgr(String host, int port, String password) throws \r\n   ConnectException {\r\n      log.info(\"[IN] RedissonMessagingMgr Constructor\");\r\n      Config config = new Config();\r\n      StringBuilder messagingAddress = new StringBuilder(\"redis://\");\r\n      messagingAddress.append(host).append(\":\").append(Integer.toString(port));\r\n      config.useSingleServer().setAddress(messagingAddress.toString());\r\n      config.useSingleServer().setPassword(password);\r\n      config.setNettyThreads(0);\r\n      \r\n      log.info(\"[OUT] RedissonCache Constructor\");\r\n   }\r\n}\r\n\r\npublic boolean createNoDupQueue(String name,Comparator comp ) {\r\n      boolean returnValue = false;\r\n      //RScoredSortedSet<PubSubMessage> sortedset = client.getScoredSortedSet(name);\r\n      RSortedSet<PubSubMessage> sortedset = client.getSortedSet(name);\r\n      \r\n      System.out.println(\"Comparator:\"+sortedset.comparator().getClass().getName());\r\n\r\n      try {\r\n         boolean set = sortedset.trySetComparator(comp);\r\n         System.out.println(\"Comparator:\"+sortedset.comparator().getClass().getName());\r\n\r\n      }\r\n      catch(RedisException exception) {\r\n         // ignoring the exception and invoking trySetComparator multiple time will raise this \r\n         // exception.\r\n         exception.printStackTrace();\r\n      }\r\n      if (sortedset != null)  {\r\n         returnValue = true;\r\n      }\r\n      return returnValue;\r\n   }\r\n\r\npublic boolean publishNoDupQueue(String queueName,PubSubMessage message) {\r\n      RScoredSortedSet<PubSubMessage> noDupQueue = client.getScoredSortedSet(queueName);\r\n      return noDupQueue.add(message.getSortedScore(),message);\r\n   }\r\n}",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5285/comments",
    "author": "nkant17",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-08-30T11:24:42Z",
        "body": "Unable to reproduce.\r\n\r\n```java\r\n    public static class TestMsg {\r\n\r\n        int number;\r\n\r\n        String str;\r\n\r\n        public TestMsg(int number, String str) {\r\n            this.number = number;\r\n            this.str = str;\r\n        }\r\n\r\n        public int getNumber() {\r\n            return number;\r\n        }\r\n\r\n        public String getStr() {\r\n            return str;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"TestMsg{\" +\r\n                    \"number=\" + number +\r\n                    \", str='\" + str + '\\'' +\r\n                    '}';\r\n        }\r\n    }\r\n\r\n    public static class TestMsgComparator implements Comparator<TestMsg> {\r\n\r\n        @Override\r\n        public int compare(TestMsg a, TestMsg b)\r\n        {\r\n            return a.number  - b.number;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void test12() {\r\n        RSortedSet<TestMsg> set = redisson.getSortedSet(\"set\");\r\n\r\n        set.trySetComparator(new TestMsgComparator());\r\n        set.add(new TestMsg(1, \"1\"));\r\n        set.add(new TestMsg(1, \"2\"));\r\n        set.add(new TestMsg(3, \"3\"));\r\n        set.add(new TestMsg(4, \"4\"));\r\n\r\n        assertThat(set).containsExactly(new TestMsg(1, \"1\"), new TestMsg(3, \"3\"), new TestMsg(4, \"4\"));\r\n    }\r\n```"
      },
      {
        "user": "nkant17",
        "created_at": "2023-10-04T17:44:53Z",
        "body": "Working now"
      }
    ]
  },
  {
    "number": 5281,
    "title": "Parameter 0 of constructor in com.barns.redis.*required a bean of type 'org.redisson.Redisson' that could not be found.",
    "created_at": "2023-08-26T09:32:38Z",
    "closed_at": "2023-09-27T14:01:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5281",
    "body": "SpringBoot version:2.5.14\r\nredisson version:3.17.6\r\nredisson-spring-data-27 version:3.17.6",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5281/comments",
    "author": "Boone1997",
    "comments": [
      {
        "user": "Boone1997",
        "created_at": "2023-08-26T09:34:17Z",
        "body": "```\r\n\r\n***************************\r\nAPPLICATION FAILED TO START\r\n***************************\r\n\r\nDescription:\r\n\r\nParameter 0 of constructor in com.barns.redis.OrderDelayTask required a bean of type 'org.redisson.Redisson' that could not be found.\r\n\r\n\r\nAction:\r\n\r\nConsider defining a bean of type 'org.redisson.Redisson' in your configuration.\r\n```"
      },
      {
        "user": "wynn5a",
        "created_at": "2023-09-01T06:25:46Z",
        "body": "Hello, consider adding the following dependency to your project and try again.\r\n```\r\norg.redisson:redisson-spring-boot-starter:3.17.6\r\n```"
      }
    ]
  },
  {
    "number": 5280,
    "title": "Class not found exception with FSTCodec",
    "created_at": "2023-08-25T23:35:12Z",
    "closed_at": "2023-08-26T07:33:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5280",
    "body": "I am using redisson client with FST Codec in my liferay 6.2 Application\r\nonly for control panel applications whenever are tried to be loaded, the following exception is being observed\r\n\r\n16:25:06,752 ERROR [DispatcherPortlet:559] Could not complete request\r\norg.redisson.client.RedisException: Unexpected exception while processing command\r\n\tat org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:276)\r\n\tat org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:115)\r\n\tat org.redisson.RedissonObject.get(RedissonObject.java:82)\r\n\tat org.redisson.RedissonMap.readAllMap(RedissonMap.java:863)\r\n\tat org.redisson.tomcat.RedissonSession.getAttribute(RedissonSession.java:132)\r\n\tat com.liferay.redis.redisson.integration.tomcat.LiferayRedissonSessionManager$SerializableRedissonSession.getAttribute(LiferayRedissonSessionManager.java:185)\r\n\tat org.apache.catalina.session.StandardSessionFacade.getAttribute(StandardSessionFacade.java:108)\r\n\tat com.liferay.portal.servlet.SharedSessionWrapper.getAttribute(SharedSessionWrapper.java:56)\r\n\tat com.liferay.portal.util.PortalImpl.isSecure(PortalImpl.java:6612)\r\n\tat com.liferay.portal.util.PortalUtil.isSecure(PortalUtil.java:1850)\r\n\tat com.liferay.portlet.PortletURLImpl.<init>(PortletURLImpl.java:106)\r\n\tat com.liferay.portlet.PortletURLImpl.<init>(PortletURLImpl.java:150)\r\n\tat com.liferay.portlet.PortletURLFactoryImpl.create(PortletURLFactoryImpl.java:43)\r\n\tat com.liferay.portlet.PortletURLFactoryUtil.create(PortletURLFactoryUtil.java:41)\r\n\tat com.liferay.portlet.PortletResponseImpl.doCreateLiferayPortletURL(PortletResponseImpl.java:627)\r\n\tat com.liferay.portlet.PortletResponseImpl$LiferayPortletURLPrivilegedAction.run(PortletResponseImpl.java:724)\r\n\tat com.liferay.portlet.PortletResponseImpl$LiferayPortletURLPrivilegedAction.run(PortletResponseImpl.java:1)\r\n\tat com.liferay.portal.security.lang.DoPrivilegedUtil$NoPACL.wrap(DoPrivilegedUtil.java:64)\r\n\tat com.liferay.portal.security.lang.DoPrivilegedUtil.wrap(DoPrivilegedUtil.java:26)\r\n\tat com.liferay.portlet.PortletResponseImpl.createLiferayPortletURL(PortletResponseImpl.java:269)\r\n\tat com.liferay.portlet.PortletResponseImpl.createLiferayPortletURL(PortletResponseImpl.java:261)\r\n\tat com.liferay.portlet.PortletResponseImpl.createLiferayPortletURL(PortletResponseImpl.java:283)\r\n\tat com.liferay.portlet.PortletResponseImpl.createActionURL(PortletResponseImpl.java:232)\r\n\tat com.liferay.portlet.PortletResponseImpl.createActionURL(PortletResponseImpl.java:227)\r\n\tat com.diginsite.product.admin.portal.restrictedUsers.ViewHandler.showDefaultPage(ViewHandler.java:73)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.springframework.web.bind.annotation.support.HandlerMethodInvoker.invokeHandlerMethod(HandlerMethodInvoker.java:176)\r\n\tat org.springframework.web.portlet.mvc.annotation.AnnotationMethodHandlerAdapter.invokeHandlerMethod(AnnotationMethodHandlerAdapter.java:362)\r\n\tat org.springframework.web.portlet.mvc.annotation.AnnotationMethodHandlerAdapter.doHandle(AnnotationMethodHandlerAdapter.java:349)\r\n\tat org.springframework.web.portlet.mvc.annotation.AnnotationMethodHandlerAdapter.handleRender(AnnotationMethodHandlerAdapter.java:291)\r\n\tat org.springframework.web.portlet.DispatcherPortlet.doRenderService(DispatcherPortlet.java:734)\r\n\tat org.springframework.web.portlet.FrameworkPortlet.processRequest(FrameworkPortlet.java:522)\r\n\tat org.springframework.web.portlet.FrameworkPortlet.doDispatch(FrameworkPortlet.java:470)\r\n\tat javax.portlet.GenericPortlet.render(GenericPortlet.java:262)\r\n\tat com.liferay.portlet.FilterChainImpl.doFilter(FilterChainImpl.java:103)\r\n\tat com.liferay.portlet.ScriptDataPortletFilter.doFilter(ScriptDataPortletFilter.java:55)\r\n\tat com.liferay.portlet.FilterChainImpl.doFilter(FilterChainImpl.java:100)\r\n\tat com.liferay.redis.redisson.integration.tomcat.filter.RequestContextPortletFilter.doProcessFilter(RequestContextPortletFilter.java:94)\r\n\tat com.liferay.redis.redisson.integration.tomcat.filter.RequestContextPortletFilter.doInTemplate(RequestContextPortletFilter.java:81)\r\n\tat com.liferay.redis.redisson.integration.tomcat.filter.RequestContextPortletFilter.doFilter(RequestContextPortletFilter.java:48)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat com.liferay.portal.kernel.bean.ClassLoaderBeanHandler.invoke(ClassLoaderBeanHandler.java:67)\r\n\tat com.sun.proxy.$Proxy693.doFilter(Unknown Source)\r\n\tat com.liferay.portlet.FilterChainImpl.doFilter(FilterChainImpl.java:100)\r\n\tat com.liferay.portal.kernel.portlet.PortletFilterUtil.doFilter(PortletFilterUtil.java:64)\r\n\tat com.liferay.portal.kernel.servlet.PortletServlet.service(PortletServlet.java:112)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:725)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:291)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:116)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilter.doFilter(InvokerFilter.java:117)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:721)\r\n\tat org.apache.catalina.core.ApplicationDispatcher.doInclude(ApplicationDispatcher.java:584)\r\n\tat org.apache.catalina.core.ApplicationDispatcher.include(ApplicationDispatcher.java:523)\r\n\tat com.liferay.portlet.InvokerPortletImpl.invoke(InvokerPortletImpl.java:583)\r\n\tat com.liferay.portlet.InvokerPortletImpl.invokeRender(InvokerPortletImpl.java:656)\r\n\tat com.liferay.portlet.InvokerPortletImpl.render(InvokerPortletImpl.java:362)\r\n\tat org.apache.jsp.html.portal.render_005fportlet_jsp._jspService(render_005fportlet_jsp.java:1581)\r\n\tat org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:725)\r\n\tat org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:431)\r\n\tat org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:396)\r\n\tat org.apache.jasper.servlet.JspServlet.service(JspServlet.java:340)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:725)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:291)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:116)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilter.doFilter(InvokerFilter.java:117)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:721)\r\n\tat org.apache.catalina.core.ApplicationDispatcher.doInclude(ApplicationDispatcher.java:584)\r\n\tat org.apache.catalina.core.ApplicationDispatcher.include(ApplicationDispatcher.java:523)\r\n\tat com.liferay.portal.servlet.DirectServletPathRegisterDispatcher.include(DirectServletPathRegisterDispatcher.java:55)\r\n\tat com.liferay.portal.servlet.ClassLoaderRequestDispatcherWrapper.doDispatch(ClassLoaderRequestDispatcherWrapper.java:78)\r\n\tat com.liferay.portal.servlet.ClassLoaderRequestDispatcherWrapper.include(ClassLoaderRequestDispatcherWrapper.java:53)\r\n\tat com.liferay.portal.servlet.TransferHeadersHelperImpl$TransferHeadersRequestDispatcher.include(TransferHeadersHelperImpl.java:161)\r\n\tat com.liferay.portlet.PortletContainerImpl._doRender(PortletContainerImpl.java:640)\r\n\tat com.liferay.portlet.PortletContainerImpl.render(PortletContainerImpl.java:136)\r\n\tat com.liferay.portlet.SecurityPortletContainerWrapper.render(SecurityPortletContainerWrapper.java:141)\r\n\tat com.liferay.portlet.RestrictPortletContainerWrapper.render(RestrictPortletContainerWrapper.java:126)\r\n\tat com.liferay.portal.kernel.portlet.PortletContainerUtil.render(PortletContainerUtil.java:156)\r\n\tat com.liferay.portal.layoutconfiguration.util.velocity.TemplateProcessor.processMax(TemplateProcessor.java:173)\r\n\tat com.liferay.portal.layoutconfiguration.util.velocity.TemplateProcessor.processMax(TemplateProcessor.java:184)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.apache.velocity.util.introspection.UberspectImpl$VelMethodImpl.doInvoke(UberspectImpl.java:389)\r\n\tat org.apache.velocity.util.introspection.UberspectImpl$VelMethodImpl.invoke(UberspectImpl.java:378)\r\n\tat org.apache.velocity.runtime.parser.node.ASTMethod.execute(ASTMethod.java:270)\r\n\tat org.apache.velocity.runtime.parser.node.ASTReference.execute(ASTReference.java:262)\r\n\tat org.apache.velocity.runtime.parser.node.ASTReference.render(ASTReference.java:342)\r\n\tat org.apache.velocity.runtime.parser.node.SimpleNode.render(SimpleNode.java:336)\r\n\tat org.apache.velocity.Template.merge(Template.java:328)\r\n\tat org.apache.velocity.Template.merge(Template.java:235)\r\n\tat com.liferay.portal.velocity.VelocityTemplate.processTemplate(VelocityTemplate.java:112)\r\n\tat com.liferay.portal.template.AbstractTemplate.processTemplate(AbstractTemplate.java:108)\r\n\tat com.liferay.portal.layoutconfiguration.util.RuntimePageImpl.doProcessTemplate(RuntimePageImpl.java:375)\r\n\tat com.liferay.portal.layoutconfiguration.util.RuntimePageImpl.doDispatch(RuntimePageImpl.java:284)\r\n\tat com.liferay.portal.layoutconfiguration.util.RuntimePageImpl.getProcessedTemplate(RuntimePageImpl.java:96)\r\n\tat com.liferay.portal.layoutconfiguration.util.RuntimePageUtil.getProcessedTemplate(RuntimePageUtil.java:38)\r\n\tat org.apache.jsp.html.portal.layout.view.control_005fpanel_jsp._jspService(control_005fpanel_jsp.java:1283)\r\n\tat org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:725)\r\n\tat org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:431)\r\n\tat org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:396)\r\n\tat org.apache.jasper.servlet.JspServlet.service(JspServlet.java:340)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:725)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:291)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:116)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilter.doFilter(InvokerFilter.java:117)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:721)\r\n\tat org.apache.catalina.core.ApplicationDispatcher.doInclude(ApplicationDispatcher.java:584)\r\n\tat org.apache.catalina.core.ApplicationDispatcher.include(ApplicationDispatcher.java:523)\r\n\tat com.liferay.portal.servlet.TransferHeadersHelperImpl$TransferHeadersRequestDispatcher.include(TransferHeadersHelperImpl.java:161)\r\n\tat com.liferay.portal.action.LayoutAction.includeLayoutContent(LayoutAction.java:290)\r\n\tat com.liferay.portal.action.LayoutAction.processLayout(LayoutAction.java:401)\r\n\tat com.liferay.portal.action.LayoutAction.execute(LayoutAction.java:187)\r\n\tat org.apache.struts.action.RequestProcessor.processActionPerform(RequestProcessor.java:431)\r\n\tat org.apache.struts.action.RequestProcessor.process(RequestProcessor.java:236)\r\n\tat com.liferay.portal.struts.PortalRequestProcessor.process(PortalRequestProcessor.java:169)\r\n\tat org.apache.struts.action.ActionServlet.process(ActionServlet.java:1196)\r\n\tat org.apache.struts.action.ActionServlet.doGet(ActionServlet.java:414)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:618)\r\n\tat com.liferay.portal.servlet.MainServlet.callParentService(MainServlet.java:590)\r\n\tat com.liferay.portal.servlet.MainServlet.service(MainServlet.java:567)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:725)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:291)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:116)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.processFilter(BaseFilter.java:169)\r\n\tat com.liferay.portal.servlet.filters.uploadservletrequest.UploadServletRequestFilter.processFilter(UploadServletRequestFilter.java:93)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.doFilter(BaseFilter.java:59)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.processDoFilter(InvokerFilterChain.java:204)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:109)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.processFilter(BaseFilter.java:169)\r\n\tat com.liferay.portal.servlet.filters.secure.SecureFilter.processFilter(SecureFilter.java:312)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.doFilter(BaseFilter.java:59)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.processDoFilter(InvokerFilterChain.java:204)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:109)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilter.doFilter(InvokerFilter.java:117)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:721)\r\n\tat org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:466)\r\n\tat org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:391)\r\n\tat org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:318)\r\n\tat com.liferay.portal.servlet.FriendlyURLServlet.service(FriendlyURLServlet.java:153)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:725)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:291)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:116)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.processFilter(BaseFilter.java:169)\r\n\tat com.liferay.portal.servlet.filters.uploadservletrequest.UploadServletRequestFilter.processFilter(UploadServletRequestFilter.java:93)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.doFilter(BaseFilter.java:59)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.processDoFilter(InvokerFilterChain.java:204)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:109)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.processFilter(BaseFilter.java:169)\r\n\tat com.liferay.portal.servlet.filters.strip.StripFilter.processFilter(StripFilter.java:361)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.doFilter(BaseFilter.java:59)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.processDoFilter(InvokerFilterChain.java:204)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:109)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.processFilter(BaseFilter.java:169)\r\n\tat com.liferay.portal.servlet.filters.gzip.GZipFilter.processFilter(GZipFilter.java:123)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.doFilter(BaseFilter.java:59)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.processDoFilter(InvokerFilterChain.java:204)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:109)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.processFilter(BaseFilter.java:169)\r\n\tat com.liferay.portal.servlet.filters.secure.SecureFilter.processFilter(SecureFilter.java:312)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.doFilter(BaseFilter.java:59)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.processDoFilter(InvokerFilterChain.java:204)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:109)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.processFilter(BaseFilter.java:169)\r\n\tat com.liferay.portal.servlet.filters.i18n.I18nFilter.processFilter(I18nFilter.java:372)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.doFilter(BaseFilter.java:59)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.processDoFilter(InvokerFilterChain.java:204)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:109)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.processFilter(BaseFilter.java:169)\r\n\tat com.liferay.portal.servlet.filters.etag.ETagFilter.processFilter(ETagFilter.java:86)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.doFilter(BaseFilter.java:59)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.processDoFilter(InvokerFilterChain.java:204)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:109)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.processFilter(BaseFilter.java:169)\r\n\tat com.liferay.portal.servlet.filters.autologin.AutoLoginFilter.processFilter(AutoLoginFilter.java:270)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.doFilter(BaseFilter.java:59)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.processDoFilter(InvokerFilterChain.java:204)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:109)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.processDirectCallFilter(InvokerFilterChain.java:185)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:96)\r\n\tat org.tuckey.web.filters.urlrewrite.UrlRewriteFilter.doFilter(UrlRewriteFilter.java:738)\r\n\tat com.liferay.portal.servlet.filters.urlrewrite.UrlRewriteFilter.processFilter(UrlRewriteFilter.java:57)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.doFilter(BaseFilter.java:59)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.processDoFilter(InvokerFilterChain.java:204)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:109)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.processDirectCallFilter(InvokerFilterChain.java:165)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:96)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.processDirectCallFilter(InvokerFilterChain.java:165)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:96)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.processDirectCallFilter(InvokerFilterChain.java:185)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain.doFilter(InvokerFilterChain.java:96)\r\n\tat com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilter.doFilter(InvokerFilter.java:117)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat com.diginsite.product.admin.portal.iam.filter.IDManagerCredentialsVerificationFilter.doFilter(IDManagerCredentialsVerificationFilter.java:76)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat com.intuit.portal.servlet.filters.mfa.v2.AdminMFAFilter.doFilter(AdminMFAFilter.java:42)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat com.intuit.portal.servlet.filters.DirectLinkFilter.doFilter(DirectLinkFilter.java:70)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat com.intuit.portal.servlet.filters.OrganizationCheckFilter.doFilter(OrganizationCheckFilter.java:101)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat com.intuit.portal.servlet.filters.RequestContextFilter.doFilter(RequestContextFilter.java:64)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.processFilter(BaseFilter.java:169)\r\n\tat com.intuit.portal.servlet.filters.SecureHostFilter.processFilter(SecureHostFilter.java:81)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.doFilter(BaseFilter.java:59)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.processFilter(BaseFilter.java:169)\r\n\tat com.intuit.portal.servlet.filters.RequestWrapperFilter.processFilter(RequestWrapperFilter.java:58)\r\n\tat com.liferay.portal.kernel.servlet.BaseFilter.doFilter(BaseFilter.java:59)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\r\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:219)\r\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106)\r\n\tat org.redisson.tomcat.UpdateValve.invoke(UpdateValve.java:62)\r\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:501)\r\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:142)\r\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79)\r\n\tat org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:610)\r\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88)\r\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:516)\r\n\tat org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1086)\r\n\tat org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:659)\r\n\tat org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:147)\r\n\tat org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:279)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.io.IOException: java.lang.RuntimeException: class not found CLASSNAME:com.diginsite.product.admin.portal.users.shared.rpc.SetupResult loader:com.liferay.portal.kernel.util.AggregateClassLoader@3ca7743a\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247)\r\n\tat org.redisson.codec.FstCodec$1.decode(FstCodec.java:250)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:383)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:427)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:392)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\t... 1 more\r\nCaused by: java.lang.RuntimeException: class not found CLASSNAME:com.diginsite.product.admin.portal.users.shared.rpc.SetupResult loader:com.liferay.portal.kernel.util.AggregateClassLoader@3ca7743a\r\n\tat org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:235)\r\n\tat org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:190)\r\n\tat org.nustaq.serialization.FSTClazzNameRegistry.decodeClass(FSTClazzNameRegistry.java:173)\r\n\tat org.nustaq.serialization.coders.FSTStreamDecoder.readClass(FSTStreamDecoder.java:478)\r\n\tat org.nustaq.serialization.FSTObjectInput.readClass(FSTObjectInput.java:939)\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:347)\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331)\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311)\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245)\r\n\t... 26 more\r\nCaused by: java.lang.ClassNotFoundException: Unable to load class com.diginsite.product.admin.portal.users.shared.rpc.SetupResult\r\n\tat com.liferay.portal.kernel.util.AggregateClassLoader._loadClass(AggregateClassLoader.java:311)\r\n\tat com.liferay.portal.kernel.util.AggregateClassLoader.loadClass(AggregateClassLoader.java:248)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\r\n\tat java.lang.Class.forName0(Native Method)\r\n\tat java.lang.Class.forName(Class.java:348)\r\n\tat org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:197)\r\n\t... 34 more\r\nCaused by: java.lang.ClassNotFoundException: com.diginsite.product.admin.portal.users.shared.rpc.SetupResult\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:382)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\r\n\tat sun.reflect.GeneratedMethodAccessor273.invoke(Unknown Source)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat com.liferay.portal.kernel.util.AggregateClassLoader._loadClass(AggregateClassLoader.java:307)\r\n\t\r\n\t\r\n\tAnyone familiar with such error and any solution?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5280/comments",
    "author": "vk185160",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-08-26T03:37:55Z",
        "body": "did you try to set `useThreadClassLoader` = false ?"
      },
      {
        "user": "vk185160",
        "created_at": "2023-08-26T05:16:10Z",
        "body": "> did you try to set `useThreadClassLoader` = false ?\r\n\r\nYes I tried to set this flag as false still seeing the same error\r\n\r\nOne thing I want to mention is I am using custom codec extended FstCodec offered by redisson\r\n\r\n```\r\nimport com.liferay.portal.kernel.util.AggregateClassLoader;\r\nimport com.liferay.portal.kernel.util.PortalClassLoaderUtil;\r\n\r\nimport org.nustaq.serialization.FSTConfiguration;\r\n\r\nimport org.redisson.codec.FstCodec;\r\n\r\npublic class LiferayFstCodec extends FstCodec {\r\n\r\n    public LiferayFstCodec() {\r\n        super(PortalClassLoaderUtil.getClassLoader());\r\n    }\r\n\r\n    public LiferayFstCodec(ClassLoader classLoader) {\r\n        super(_getAggregateClassLoader(classLoader));\r\n    }\r\n\r\n    public LiferayFstCodec(ClassLoader classLoader, LiferayFstCodec codec) {\r\n        super(_getAggregateClassLoader(classLoader), codec);\r\n    }\r\n\r\n    public LiferayFstCodec(FSTConfiguration fstConfiguration) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    public LiferayFstCodec(\r\n            FSTConfiguration fstConfiguration, boolean useCache) {\r\n\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    private static ClassLoader _getAggregateClassLoader(\r\n            ClassLoader classLoader) {\r\n\r\n        AggregateClassLoader aggregateClassLoader = new AggregateClassLoader(\r\n                PortalClassLoaderUtil.getClassLoader());\r\n\r\n        aggregateClassLoader.addClassLoader(classLoader);\r\n\r\n        return aggregateClassLoader;\r\n    }\r\n\r\n}\r\n\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2023-08-26T07:33:32Z",
        "body": "It's an issue with classloader in your application server. Make sure that you use them properly in Liferay. Sorry, can't help here."
      },
      {
        "user": "mrniko",
        "created_at": "2023-08-26T07:34:45Z",
        "body": "I doubt that it may help, but also consider other codecs like Kryo5Codec."
      },
      {
        "user": "vk185160",
        "created_at": "2023-08-26T17:01:22Z",
        "body": "> It's an issue with classloader in your application server. Make sure that you use them properly in Liferay. Sorry, can't help here.\r\n\r\nI even tried with codecs offered by Redisson none of them worked here. please see if there is anything you can do"
      }
    ]
  },
  {
    "number": 5275,
    "title": "NullPointerException with Redisson on Struts Based App",
    "created_at": "2023-08-22T19:03:04Z",
    "closed_at": "2023-08-28T13:21:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5275",
    "body": "I am in the process of migrating a legacy struts 1 (upgrading or changing struts isn't an option unfortunately) based application from WebLogic to OpenShift. Part of this migration includes moving away from Coherence (tightly coupled with WebLogic) to another session management option, such as Redisson. However, I am seeing some issues with what appears like some interaction between struts and Redisson for some of the pages in the app.\r\n```\r\njavax.servlet.ServletException: BeanUtils.populate\r\n\tat org.apache.struts.util.RequestUtils.populate(RequestUtils.java:475) ~[struts-core-1.3.10.jar:1.3.10]\r\n\tat org.apache.struts.chain.commands.servlet.PopulateActionForm.populate(PopulateActionForm.java:50) ~[struts-core-1.3.10.jar:1.3.10]\r\n\tat org.apache.struts.chain.commands.AbstractPopulateActionForm.execute(AbstractPopulateActionForm.java:60) ~[struts-core-1.3.10.jar:1.3.10]\r\n\tat org.apache.struts.chain.commands.ActionCommandBase.execute(ActionCommandBase.java:51) ~[struts-core-1.3.10.jar:1.3.10]\r\n\tat org.apache.commons.chain.impl.ChainBase.execute(ChainBase.java:191) ~[commons-chain-1.2.jar:1.2]\r\n\tat org.apache.commons.chain.generic.LookupCommand.execute(LookupCommand.java:305) ~[commons-chain-1.2.jar:1.2]\r\n\tat org.apache.commons.chain.impl.ChainBase.execute(ChainBase.java:191) [commons-chain-1.2.jar:1.2]\r\n\tat org.apache.struts.chain.ComposableRequestProcessor.process(ComposableRequestProcessor.java:283) [struts-core-1.3.10.jar:1.3.10]\r\n\tat org.apache.struts.action.ActionServlet.process(ActionServlet.java:1913) [struts-core-1.3.10.jar:1.3.10]\r\n\tat org.apache.struts.action.ActionServlet.doPost(ActionServlet.java:462) [struts-core-1.3.10.jar:1.3.10]\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:555) [servlet-api.jar:4.0.FR]\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:623) [servlet-api.jar:4.0.FR]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:209) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:153) [catalina.jar:9.0.78]\r\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51) [tomcat-websocket.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:178) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:153) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:178) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:153) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:178) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:153) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:178) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:153) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:178) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:153) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:178) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:153) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:178) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:153) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:178) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:153) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:178) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:153) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:178) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:153) [catalina.jar:9.0.78]\r\n\tat org.apache.logging.log4j.web.Log4jServletFilter.doFilter(Log4jServletFilter.java:71) [log4j-web-2.20.0.jar:2.20.0]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:178) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:153) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90) [catalina.jar:9.0.78]\r\n\tat org.redisson.tomcat.UsageValve.invoke(UsageValve.java:71) [redisson-tomcat-9-3.23.1.jar:3.23.1]\r\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:481) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:130) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:673) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [catalina.jar:9.0.78]\r\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [catalina.jar:9.0.78]\r\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:390) [tomcat-coyote.jar:9.0.78]\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63) [tomcat-coyote.jar:9.0.78]\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:926) [tomcat-coyote.jar:9.0.78]\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1791) [tomcat-coyote.jar:9.0.78]\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52) [tomcat-coyote.jar:9.0.78]\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) [tomcat-util.jar:9.0.78]\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) [tomcat-util.jar:9.0.78]\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-util.jar:9.0.78]\r\n\tat java.lang.Thread.run(Thread.java:750) [?:1.8.0_322]\r\nCaused by: java.lang.NullPointerException\r\n\tat org.apache.commons.beanutils.BeanUtilsBean.setProperty(BeanUtilsBean.java:983) ~[commons-beanutils-1.9.4.jar:1.9.4]\r\n\tat org.apache.commons.beanutils.BeanUtilsBean.populate(BeanUtilsBean.java:823) ~[commons-beanutils-1.9.4.jar:1.9.4]\r\n\tat org.apache.commons.beanutils.BeanUtils.populate(BeanUtils.java:431) ~[commons-beanutils-1.9.4.jar:1.9.4]\r\n\tat org.apache.struts.util.RequestUtils.populate(RequestUtils.java:473) ~[struts-core-1.3.10.jar:1.3.10]\r\n````\r\n\r\nThe issue always appears as a NullPointerException (normally in commons-beanutils) from a `BeanUtils.populate()` call in struts. However, if I disable Redisson then the page works fine. I can see the `org.redisson.tomcat.UsageValve` in the stack trace. The NullPointerException happens before it even gets to my action class for the page. The only way I have gotten the page to work with Redisson running is to change the struts action path scope to request. \r\n```\r\n<!-- Originally session, testing with request scope -->\r\n<action path=\"/tab/example\"\r\n      type=\"com.example.actions.ExampleAction\"\r\n      name=\"exampleForm\"\r\n      scope=\"request\"\r\n      validate=\"false\">\r\n      <forward name=\"success\" path=\"/WEB-INF/pages/example/exampleTab.jsp\"/>\r\n</action>\r\n```\r\nHowever, changing this kind of defeats the purpose of using session management. This will cause users to have to relogin between requests/redirects. Has anyone had similar issues with struts and Redisson? Any possible solutions I could try?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5275/comments",
    "author": "caseytrumble",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-08-23T06:10:08Z",
        "body": "Did you try to set readMode = MEMORY?"
      },
      {
        "user": "caseytrumble",
        "created_at": "2023-08-23T15:32:19Z",
        "body": "I did play around with some of the RedissonSessionManager properties including setting readMode=MEMORY. It did seem to help with some pages, but others still have the same error. These are the properties I currently am using:\r\n```\r\n<Manager className=\"org.redisson.tomcat.RedissonSessionManager\"\r\n             configPath=\"${catalina.base}/conf/redisson.conf\"\r\n             keyPrefix=\"my-app-key\"\r\n             readMode=\"MEMORY\"\r\n             updateMode=\"DEFAULT\"\r\n             broadcastSessionUpdates=\"true\" />\r\n```"
      },
      {
        "user": "caseytrumble",
        "created_at": "2023-08-23T19:15:39Z",
        "body": "I think I should explain further on my last comment. I found that using the readMode=MEMORY property does work if creating a fresh session. I see a catalina/tomcat log that looks similar to this:\r\n`org.redisson.tomcat.RedissonSessionManager.findSession Session 780E700CDBB0070B5A46BC7F92C47DCC can't be found`\r\n\r\nIf that shows, then the app behaves as it should. If that log doesn't show, I am assuming the session can be found and attempts to restore it, I get the same original error. Almost like the session is not properly restored? Not exactly sure why I am seeing inconsistent behavior when I set readMode=MEMORY."
      },
      {
        "user": "mrniko",
        "created_at": "2023-08-24T10:49:47Z",
        "body": "you can turn on Redisson logs for both apps to check what is the cause of this error. "
      },
      {
        "user": "mrniko",
        "created_at": "2023-08-24T10:50:50Z",
        "body": "did you try to set Redisson setting readMode = MASTER ?"
      },
      {
        "user": "caseytrumble",
        "created_at": "2023-08-28T19:14:50Z",
        "body": "Setting readMode to master did not resolve the issue either.\r\n\r\nI ended up creating custom versions of `DynaActionForm` and `DynaProperty` from `commons-beanutils` that struts uses to deserialize the session objects/beans from Redisson. For some reason struts it not able to determine the data types from the session (or it ignores it) and this was leading to the `NullPointerException` in `RequestUtils.populate`. My custom version determines the class type on the fly and sets the type attribute if it is null. This seems to resolve my issue.\r\n\r\nLooks like more of an issue with the `commons-beanutils` library than struts or Redisson."
      }
    ]
  },
  {
    "number": 5270,
    "title": "Why bloomfilter max size is Integer.MAX_VALUE*2",
    "created_at": "2023-08-22T01:48:03Z",
    "closed_at": "2024-05-10T08:32:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5270",
    "body": "I want to use bloomfilter  and my expectedInsertions size is 800_000_000, and call this method tryInit() error, the error info is \r\n\"\"\" Bloom filter size can't be greater than \" + getMaxSize() + \". But calculated size is  \"\"\"\r\nWhy the maxSize is  Integer.MAX_VALUE*2\r\nIf my expectedInsertions is to big, fo example, 1B, how can I use the bloomfilter  ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5270/comments",
    "author": "safetys123",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-08-22T09:08:06Z",
        "body": "since redis object can't store more than 512Mb of data"
      },
      {
        "user": "safetys123",
        "created_at": "2023-09-02T16:16:28Z",
        "body": "If I have 1B or 10B datas, how can I use the  redis bloomfilter ? For example, I want to save id  1~999,999,999, Can you give me  some advice ?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-10T08:32:32Z",
        "body": "you can use ClusteredBloomFilter included in PRO version. It can handle even 1000B+ entries"
      }
    ]
  },
  {
    "number": 5267,
    "title": "Empty initialisation sequence error when using JNDI with RedissonClient connection",
    "created_at": "2023-08-20T04:31:47Z",
    "closed_at": "2024-07-30T08:18:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5267",
    "body": "### RedisConfig.java\r\n```java\r\n@Configuration\r\n@EnableRedisRepositories(enableKeyspaceEvents = RedisKeyValueAdapter.EnableKeyspaceEvents.ON_STARTUP)\r\npublic class RedisConfig {\r\n...\r\n    private static final String REDISSON_HOST_PREFIX = \"rediss://\";\r\n    private final ObjectMapper objectMapper;\r\n    \r\n    @Value(\"${redis.host}\")\r\n    private String redisHost;\r\n    \r\n    @Value(\"${redis.port}\")\r\n    private Integer redisPort;\r\n    \r\n    @Value(\"${redis.database}\")\r\n    private int redisSessionDatabase;\r\n   \r\n    @Value(\"${redis.password}\")\r\n    private String redisPassword;\r\n\r\n    @Bean\r\n    public RedisConnectionFactory redisConnectionFactory() {\r\n        LettuceConnectionFactory connectionFactory =\r\n                new LettuceConnectionFactory(redisStandaloneConfiguration(), lettuceClientConfiguration());\r\n        connectionFactory.setDatabase(this.redisSessionDatabase);\r\n        \r\n        return connectionFactory;\r\n    }\r\n\r\n    @Bean\r\n    RedisStandaloneConfiguration redisStandaloneConfiguration() {\r\n        RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration();\r\n        redisStandaloneConfiguration.setHostName(this.redisHost);\r\n        redisStandaloneConfiguration.setPort(this.redisPort);\r\n        redisStandaloneConfiguration.setPassword(this.redisPassword);\r\n        \r\n        return redisStandaloneConfiguration;\r\n    }\r\n\r\n    @Bean\r\n    LettuceClientConfiguration lettuceClientConfiguration() {\r\n        return LettuceClientConfiguration\r\n                .builder()\r\n                .useSsl()\r\n                .build();\r\n    }\r\n\r\n    @Bean\r\n    public RedissonClient redissonClient() {\r\n        Config config = new Config();\r\n        config.useSingleServer()\r\n                .setAddress(REDISSON_HOST_PREFIX + this.redisHost + \":\" + this.redisPort)\r\n                .setPassword(this.redisPassword)\r\n                .setSslEnableEndpointIdentification(true);\r\n                \r\n        return Redisson.create(config);\r\n    }\r\n\r\n    @Bean\r\n    public RedisTemplate<String, Object> redisTemplate() {\r\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\r\n        redisTemplate.setConnectionFactory(redisConnectionFactory());\r\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\r\n\r\n        Jackson2JsonRedisSerializer<String> stringJackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(String.class);\r\n        stringJackson2JsonRedisSerializer.setObjectMapper(objectMapper);\r\n        redisTemplate.setValueSerializer(stringJackson2JsonRedisSerializer);\r\n\r\n        return redisTemplate;\r\n    }\r\n    ...\r\n}\r\n```\r\n\r\nThe only thing I added to the existing config was the RedissonClient.\r\n\r\n\r\n### Error\r\n```java\r\nCaused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'javax.sql.DataSource' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Qualifier(value=\"securityDataSource\")}\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1799)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1394)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1309)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:887)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:791)\r\n\t... 188 common frames omitted\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### DataSourceConfig\r\n```java\r\n@Slf4j\r\n@Configuration\r\n@RequiredArgsConstructor\r\npublic class DataSourceConfig {\r\n   // ... Other definitions\r\n\r\n\r\n    @Bean\r\n    public DataSource securityDataSource() {\r\n        return getDataSource();\r\n    }\r\n\r\n    private DataSource getDataSource() {\r\n        JndiObjectFactoryBean jndi = new JndiObjectFactoryBean();\r\n        jndi.setProxyInterface(DataSource.class);\r\n        jndi.setJndiName(JndiResource.JNDI_NAME);\r\n        jndi.setResourceRef(true);\r\n        try {\r\n            jndi.afterPropertiesSet();\r\n            return (DataSource) jndi.getObject();\r\n        } catch (NamingException ne) {\r\n            log.error(JndiResource.JNDI_NAME, ne);\r\n            return null;\r\n        }\r\n    }\r\n    \r\n    // ... Other definitions\r\n}\r\n```\r\n\r\n\r\nWhat's weird is that instead of injecting the DataSource with JNDI from there, I injected it using HikariCP as shown below, and it works fine.\r\n\r\n\r\n```java\r\n@Slf4j\r\n@Configuration\r\n@RequiredArgsConstructor\r\npublic class DataSourceConfig {\r\n   // ... \r\n   \r\n    public DataSource securityDataSource() {\r\n        return getDataSource();\r\n    }\r\n    \r\n    private DataSource getDataSource() {\r\n        HikariConfig config = new HikariConfig();\r\n        config.setDriverClassName(Driver.class.getName());\r\n        config.setJdbcUrl(\"url\");\r\n        config.setUsername(\"username\");\r\n        config.setPassword(\"password\");\r\n        config.setMaximumPoolSize(size);\r\n\r\n        return new HikariDataSource(config);\r\n    }\r\n}\r\n```\r\n\r\n\r\nWe identified the cause.\r\n\r\nThe root of the problem was in the injection of the ObjectMapper in the RedisConfig. The ServletConfig had an ObjectMapper defined, and the PublicAuthInterceptor contained a PrincipalRepository that required DB access, which caused an error because it tried to access the securityDataSource before it was created.\r\n\r\n### ServletConfig.java\r\n```java\r\n@Configuration\r\n@RequiredArgsConstructor\r\npublic class ServletConfig implements WebMvcConfigurer {\r\n    //  ... Other definitions\r\n\r\n   \r\n    private final PublicAuthInterceptor publicAuthInterceptor;\r\n\r\n    @Bean\r\n    public ObjectMapper objectMapper() {\r\n      // ... objectMapper settings\r\n    }\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n### PublicAuthInterceptor.java\r\n```java\r\n@Slf4j\r\n@Component\r\n@RequiredArgsConstructor\r\npublic class PublicAuthInterceptor implements HandlerInterceptor {\r\n\r\n private final PrincipalRepository principalRepository;\r\n    // ...\r\n\r\n    @Override\r\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {\r\n        // principalRepository use codes\r\n    }\r\n    \r\n    // ...\r\n}\r\n```\r\n\r\nBut there are two things I don't understand.\r\n\r\n1. both HikariCP and JNDI methods work fine, except for the RedissClient Bean.\r\n2. if I add only the RedissClient Bean, it doesn't work with JNDI's method (it works if I leave out the ObjectMapper Bean)\r\n\r\n```java\r\n    @Bean\r\n    public RedissonClient redissonClient() {\r\n        Config config = new Config();\r\n        config.useSingleServer()\r\n                .setAddress(REDISSON_HOST_PREFIX + this.redisHost + \":\" + this.redisPort)\r\n                .setPassword(this.redisPassword)\r\n                .setSslEnableEndpointIdentification(true);\r\n                \r\n        return Redisson.create(config);\r\n    }\r\n```\r\n\r\nI was wondering if you could answer my question?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5267/comments",
    "author": "dkswnkk",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-10-25T12:10:17Z",
        "body": "I don't see where you are adding Redisson in JNDI"
      }
    ]
  },
  {
    "number": 5259,
    "title": "What is the recommended value of retryAttempts parameter?",
    "created_at": "2023-08-18T04:03:41Z",
    "closed_at": "2023-08-21T08:09:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5259",
    "body": "@mrniko We are using redisson with AWS Elasticache. Due to some patch activity done internally we faced an issue and got a recommendation from your end to increase the retryAttempts parameter. Can you let us know what is the recommended value for the same?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5259/comments",
    "author": "jainyash",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-08-21T08:09:31Z",
        "body": "that depends on use case. "
      }
    ]
  },
  {
    "number": 5250,
    "title": "does `MapWriter` acquire distributed lock?",
    "created_at": "2023-08-13T15:07:36Z",
    "closed_at": "2023-08-15T05:57:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5250",
    "body": "I'm trying to understand if `MapWriter` acquires a distributed lock when the `write()` method is called. \r\n\r\nI've got a microservice with N instances and my write behind cache should support both `Db.create()` and `Db.update()` operations.\r\n\r\nMy (non-scientific) tests are non conclusive.\r\n\r\nWhen I run multiple instances, sometimes it seems that Redisson _is_ acquire a distributed lock to prevent other `write()` methods for running, and then if the `write()` method that acquired is taking too long, will call it from another instance.\r\n\r\nBut in other tests it seems that two different instances can access the `write()` method concurrently.\r\n\r\nSo is there any distributed locking happening here?\r\n\r\n**Edit:** after some further testing it seems that the `write()` method does not acquire any distributed locks and is therefore single-threaded only in the context of 1 instance. \r\n\r\nWhat are my options here in case two instances are racing to create the same object? Write through is not an option since it’s going to result in too many separate DB calls.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5250/comments",
    "author": "SHxKM",
    "comments": [
      {
        "user": "SHxKM",
        "created_at": "2023-08-13T15:53:21Z",
        "body": "It seems like it may be possible to do leader election (so only 1 instance runs `write()`) here with overriding `WriteBehindService`? however the API doesn't expose a `MapOptions` ctor that allows overriding it."
      },
      {
        "user": "SHxKM",
        "created_at": "2023-08-13T16:41:41Z",
        "body": "I guess, in other words, I that the map sent to the write() method was itself a shared object somewhere in Redis."
      },
      {
        "user": "SHxKM",
        "created_at": "2023-08-13T23:47:01Z",
        "body": "@mrniko would holding `RMap<String, RBucket<MyObj>>` instead of `RMap<String, MyObj>` make any difference here?"
      },
      {
        "user": "mrniko",
        "created_at": "2023-08-14T03:52:57Z",
        "body": "@SHxKM \r\n\r\nNo, you can acquire redisson lock right in the org.redisson.api.map.MapWriterAsync#write() method."
      },
      {
        "user": "SHxKM",
        "created_at": "2023-08-14T09:03:50Z",
        "body": "@mrniko Thanks, that still does not guarantee though that the `write()` acquiring the lock second, will not see that a certain object is not in `NOT_IN_DB` (and therefore it needs to create it), after the first lock-acquirer has already created it and changed its status to `IN_DB`. `map` is not backed by the real map it's just a snapshot/diff at a certain time so we're gonna have to look at an alternative method. Any ideas? A queue maybe?"
      },
      {
        "user": "mrniko",
        "created_at": "2023-08-15T05:57:12Z",
        "body": "if you use the same Redisson lock sharing the same name then it should work."
      }
    ]
  },
  {
    "number": 5248,
    "title": "Does redisson-3.23.2 support redis-7.0.23 ?",
    "created_at": "2023-08-13T06:40:32Z",
    "closed_at": "2023-08-15T05:57:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5248",
    "body": "Factory method 'redisson' threw exception with message: Unable to connect to Redis server: 192.168.102.130/192.168.102.130:6379",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5248/comments",
    "author": "chenyudaima",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-08-13T10:35:39Z",
        "body": "Yes, it does. You need to check the network."
      }
    ]
  },
  {
    "number": 5242,
    "title": "How do I get a value from RTimeSeries<V,L> when I added using RTimeSeries<V> object. ",
    "created_at": "2023-08-10T15:12:49Z",
    "closed_at": "2023-08-10T15:35:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5242",
    "body": "I tried to update my redisson version but stuck at this.\r\nFacing this error\r\norg.redisson.client.RedisException: ERR Error running script @user_script:1: user_script:1: bad argument #2 to 'unpack' (data string too short). \r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5242/comments",
    "author": "swapnil2001-master",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-08-10T15:33:10Z",
        "body": "RTimeSeries format has been changed since 3.18.0 version"
      },
      {
        "user": "swapnil2001-master",
        "created_at": "2023-08-10T15:52:10Z",
        "body": "So I cannot get the previous data using this version"
      },
      {
        "user": "mrniko",
        "created_at": "2023-08-20T05:11:39Z",
        "body": "I can suggest you to store data using `org.redisson.api.RTimeSeries#entryRange(long, long)` into elsewhere and then using a new version store it back using `org.redisson.api.RTimeSeries#add(long, V)` method."
      }
    ]
  },
  {
    "number": 5233,
    "title": "Getting startup error when trying out TomcatSessionManager",
    "created_at": "2023-08-08T08:51:48Z",
    "closed_at": "2023-08-15T05:57:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5233",
    "body": "Caused by: java.lang.LinkageError: loader constraint violation:\r\nwhen resolving method \"io.reactivex.Flowable.fromPublisher(Lorg/reactivestreams/Publisher;)Lio/reactivex/Flowable;\"\r\nthe class loader (instance of org/apache/catalina/loader/ParallelWebappClassLoader) of the current class,\r\norg/springframework/core/ReactiveAdapterRegistry$RxJava2Registrar, and the class loader (instance of java/net/URLClassLoader)\r\nfor the method's defining class, io/reactivex/Flowable, have different Class objects for the type org/reactivestreams/Publisher used in the signature\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5233/comments",
    "author": "manaspandey45",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-08-15T05:57:59Z",
        "body": "You need to check your classpath. It may have different versions of the same library."
      }
    ]
  },
  {
    "number": 5220,
    "title": "Why is it that when I use RedissonMultiLock, when a redis machine breaks down, the lock cannot be used all the time, and I need to reconnect the broken machine before I can continue to use it",
    "created_at": "2023-08-01T12:09:03Z",
    "closed_at": "2023-08-07T07:07:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5220",
    "body": "This is my java code\r\n\r\njava\r\nconfig\r\n@Value(\"${redisson.single.address1}\")\r\n    private String address1;\r\n    @Value(\"${redisson.single.address2}\")\r\n    private String address2;\r\n    @Value(\"${redisson.single.address3}\")\r\n    private String address3;\r\n\r\n\r\n    @Bean(\"redissonClient1\")\r\n    public RedissonClient redissonClient1() {\r\n        Config config = new Config();\r\n        config.useSingleServer()\r\n                .setDatabase(0)\r\n                .setAddress(address1)\r\n                .setTimeout(3000);\r\n        return Redisson.create(config);\r\n    }\r\n    @Bean(\"redissonClient2\")\r\n    public RedissonClient redissonClient2() {\r\n        Config config = new Config();\r\n        config.useSingleServer()\r\n                .setDatabase(0)\r\n                .setAddress(address2)\r\n                .setTimeout(3000);\r\n        return Redisson.create(config);\r\n    }\r\n    @Bean(\"redissonClient3\")\r\n    public RedissonClient redissonClient3() {\r\n        Config config = new Config();\r\n        config.useSingleServer()\r\n                .setDatabase(0)\r\n                .setAddress(address3)\r\n                .setTimeout(3000);\r\n        return Redisson.create(config);\r\n    }\r\n\r\n    @Bean\r\n    public RedissonMultiLock redissonMultiLock(){\r\n        Config config = new Config();\r\n        config.useClusterServers().addNodeAddress(address1,address2,address3);\r\n        return new RedissonMultiLock(\r\n                redissonClient1().getLock(\"redissonLock\"),\r\n                redissonClient2().getLock(\"redissonLock\"),\r\n                redissonClient3().getLock(\"redissonLock\"));\r\n    }\r\n\r\nservice\r\n@Autowired\r\n    private RedissonMultiLock redissonMultiLock;\r\n\r\n    public String buyRedissonMultiLock() {\r\n        String message = \"\";\r\n        redissonMultiLock.lock();\r\n        try {\r\n             log.info(\"redissonLock be in use\")\r\n             message=\"redissonLock be in use\";\r\n            Thread.sleep(30000);\r\n        } finally {\r\n            redissonMultiLock.unlock();\r\n        }\r\n        return message;\r\n    }\r\n\r\nIf one of the redis is down, it will cause that the lock cannot be used all the time. The machine that is down needs to restart to use the lock normally, otherwise it will always be blocked",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5220/comments",
    "author": "HFFZZZ",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-08-07T07:07:54Z",
        "body": "That's expected since all locks should be acquired to mark RedissonMultiLock as aquired."
      },
      {
        "user": "HFFZZZ",
        "created_at": "2023-08-10T10:06:27Z",
        "body": "@mrniko Thank you. I thought the redisson distributed lock was fault tolerant\r\n\r\n "
      },
      {
        "user": "mrniko",
        "created_at": "2023-08-10T12:16:55Z",
        "body": "@HFFZZZ \r\n\r\nIt is. If multilock is used then all locks it's based on should be acquired."
      }
    ]
  },
  {
    "number": 5210,
    "title": "keepAlive and tcpNoDelay",
    "created_at": "2023-07-31T11:18:44Z",
    "closed_at": "2024-11-07T12:16:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5210",
    "body": "Hi,\r\nI am not sure of recommended values for keepAlive and tcpNoDelay. Please suggest the same.\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5210/comments",
    "author": "purti-rajpal",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-11-07T12:16:14Z",
        "body": "`true` for both settings"
      }
    ]
  },
  {
    "number": 5188,
    "title": "ReadWriteLock readLock and RLock Same Name Lock Issue",
    "created_at": "2023-07-20T07:09:07Z",
    "closed_at": "2023-07-20T07:21:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5188",
    "body": "```\r\n RLock rlock = redissonClient.getLock(\"rlock\");\r\n        RReadWriteLock rwlock = redissonClient.getReadWriteLock(\"rlock\");\r\n        rlock.lock();\r\n        try {\r\n            RLock readLock = rwlock.readLock();\r\n            readLock.lock();\r\n            try {\r\n                //.....\r\n            } finally {\r\n                readLock.unlock();\r\n            }\r\n        } finally {\r\n            rlock.unlock();\r\n        }\r\n```\r\n- Why does using readLock.unlock() cause rlock and readLock to unlock?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5188/comments",
    "author": "leotianc",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-07-20T07:21:04Z",
        "body": "This is incorrect usage. Two different objects can't share the same name."
      }
    ]
  },
  {
    "number": 5174,
    "title": "sharded pub sub message order",
    "created_at": "2023-07-17T10:43:23Z",
    "closed_at": "2023-07-27T10:35:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5174",
    "body": "if we call RShardedTopic.publishAsync in a single thread with the same channel, is there no guarantee on the message ordering since messages are published using connection pool internally? does isKeepPubSubOrder works?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5174/comments",
    "author": "adamsau",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-07-27T10:34:47Z",
        "body": "> if we call RShardedTopic.publishAsync in a single thread with the same channel, is there no guarantee on the message ordering since messages are published using connection pool internally?\r\n\r\nIt doesn't depend on channel. I didn't check this case. Messages order is maintained on Redis side.\r\n\r\n> does isKeepPubSubOrder works?\r\n\r\nonly for messages receiving."
      }
    ]
  },
  {
    "number": 5171,
    "title": "Connection and ConnectionPool",
    "created_at": "2023-07-15T05:46:59Z",
    "closed_at": "2023-07-15T06:28:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5171",
    "body": "\r\nHello, I would like to inquire about redisson's network connection and connection pool problem:\r\n\r\n1. I found that redisson would initiate a lot of web links, about two dozen. Why isn't there a single network link designed to be reusable?\r\n\r\n2. I see the code about link pool from SingleServerConfig file. Does it manage these network connections?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5171/comments",
    "author": "moa-oma",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-07-15T06:28:40Z",
        "body": "> Why isn't there a single network link designed to be reusable?\r\n\r\nYou can set by setting pool size to 1.\r\n\r\n> Does it manage these network connections?\r\n\r\nNetwork connections are managed by connection pool service."
      }
    ]
  },
  {
    "number": 5167,
    "title": "bucket.addListener增加的过期监听器，在key过期后不会被清理",
    "created_at": "2023-07-13T02:45:20Z",
    "closed_at": "2024-06-06T07:05:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5167",
    "body": "会导致，再创建这个key的时候，之前的监听器也会生效\r\n难道我还要再存储一个listenerId，每次触发后清理？",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5167/comments",
    "author": "TimeChi",
    "comments": [
      {
        "user": "TimeChi",
        "created_at": "2023-07-13T06:46:55Z",
        "body": "除了在addListener的时候可以获取listenerId\r\n我如何获取和某一个key相关的listenerId呢"
      },
      {
        "user": "mrniko",
        "created_at": "2023-07-17T05:46:06Z",
        "body": "@TimeChi \r\n\r\nYou need to remove them manually.\r\n\r\n@moa-oma \r\n\r\nCan you share the code to reproduce? Listeners work for recreated objects. "
      }
    ]
  },
  {
    "number": 5165,
    "title": "Is there a multiset implementation",
    "created_at": "2023-07-11T14:27:00Z",
    "closed_at": "2023-07-27T05:37:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5165",
    "body": "redisson libray has types listmultimap, setmultimap, maps, and sets.  Is there an implementation for a multiset that is avaiable?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5165/comments",
    "author": "seffieschwartz",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-07-12T04:50:00Z",
        "body": "There is no implementation of multiset"
      }
    ]
  },
  {
    "number": 5156,
    "title": "Command execution timeout for command: (AUTH), params: (password masked) - Redisson client",
    "created_at": "2023-07-06T02:34:38Z",
    "closed_at": "2023-07-10T06:42:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5156",
    "body": "If you use Redisson to access the Redis cluster, one of the SALVE nodes in the cluster goes down, and Redison keeps trying to reconnect, prompting the above error message\r\n\r\nRedis version\r\nredis_version:6.2.6\r\nRedisson version\r\nRedisson 3.22.1\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5156/comments",
    "author": "leo-li1990",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-07-06T03:54:41Z",
        "body": "Unable to reproduce. Please share log output with `trace` logging level for `org.redisson` package"
      }
    ]
  },
  {
    "number": 5155,
    "title": "How to convert kryo5 object to string in redis function?",
    "created_at": "2023-07-05T17:01:32Z",
    "closed_at": "2023-07-12T05:16:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5155",
    "body": "I have a redis function that takes a list of arguments and executes HGET. The problem that I have is that the first argument is a time to live. This argument gets encoded by Kryo5 and sent to the redis function as an argument. I am not sure how to convert it in my redis function from the encoded string to an integer. \r\n\r\n\r\n```\r\nObject[] args = new Object[3];\r\nargs[0] = 123456;\r\nargs[1] = \"some key\";\r\nargs[2] = \"the key value\";\r\nredisson.call(FunctionMode.WRITE, \"test\", FunctionResult.Value, List.of(\"map\"), args);\r\n\r\n...\r\n\r\nlocal function do_something(keys, args)\r\n    redis.log(redis.LOG_WARNING, args[1]) -- this is not an integer. This is an encoded kryo5 representation of the integer. \r\nend\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5155/comments",
    "author": "tmdonalds",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-07-06T05:12:32Z",
        "body": "You need to use org.redisson.client.codec.ByteArrayCodec#INSTANCE instead and encode each param manually to byte array."
      },
      {
        "user": "tmdonalds",
        "created_at": "2023-07-06T11:04:32Z",
        "body": "Thank you @mrniko . Just to be clear there is no way to convert the Kryo5 object in redis to an integer? In order to do what I am trying to do, I would have to convert the object into a byte array and then decode it back into a string?"
      },
      {
        "user": "mrniko",
        "created_at": "2023-07-10T06:37:54Z",
        "body": "> Just to be clear there is no way to convert the Kryo5 object in redis to an integer? \r\n\r\nYou can do it only on Java side"
      }
    ]
  },
  {
    "number": 5140,
    "title": "spring boot集成redisson3.22.1后，项目启动正常，几分钟之后netty的DnsNameResolver不停地重复打印warn日志，似乎进入了死循环",
    "created_at": "2023-06-29T06:05:47Z",
    "closed_at": "2023-06-29T09:07:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5140",
    "body": "2023-06-29 14:04:59,823 [redisson-netty-2-2] WARN  i.n.r.d.DnsNameResolver [DnsNameResolver.java:1196] [] [id: 0x45ffe1bb, L:/0:0:0:0:0:0:0:0:0] Unexpected exception: \r\nio.netty.handler.codec.DecoderException: java.lang.IndexOutOfBoundsException: readerIndex(0) + length(2) exceeds writerIndex(0): PooledUnsafeDirectByteBuf(ridx: 0, widx: 0, cap: 4096)\r\n\tat io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:98)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)\r\n\tat io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe.read(AbstractNioMessageChannel.java:93)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:682)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:617)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:534)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.lang.IndexOutOfBoundsException: readerIndex(0) + length(2) exceeds writerIndex(0): PooledUnsafeDirectByteBuf(ridx: 0, widx: 0, cap: 4096)\r\n\tat io.netty.buffer.AbstractByteBuf.checkReadableBytes0(AbstractByteBuf.java:1428)\r\n\tat io.netty.buffer.AbstractByteBuf.readShort(AbstractByteBuf.java:742)\r\n\tat io.netty.buffer.AbstractByteBuf.readUnsignedShort(AbstractByteBuf.java:758)\r\n\tat io.netty.handler.codec.dns.DatagramDnsResponseDecoder.newResponse(DatagramDnsResponseDecoder.java:80)\r\n\tat io.netty.handler.codec.dns.DatagramDnsResponseDecoder.decode(DatagramDnsResponseDecoder.java:57)\r\n\tat io.netty.handler.codec.dns.DatagramDnsResponseDecoder.decode(DatagramDnsResponseDecoder.java:33)\r\n\tat io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:88)\r\n\t... 16 common frames omitted",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5140/comments",
    "author": "qybgh",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-06-29T06:25:44Z",
        "body": "Please report this issue to netty project."
      }
    ]
  },
  {
    "number": 5124,
    "title": "ConcurrentModificationException while writing into the RMapCache",
    "created_at": "2023-06-23T15:43:47Z",
    "closed_at": "2023-06-26T11:02:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5124",
    "body": "Hi, \r\n\r\nGetting ConcurrentModificationException while writing into the RmapCache  with concurrent users. Below is the stack errors. \r\n\r\nCould you please suggest to overcome this issue?\r\n\r\n```\r\nCaused by: java.lang.IllegalArgumentException: java.io.IOException: java.util.ConcurrentModificationException\r\n\tat org.redisson.command.CommandAsyncService.encodeMapValue(CommandAsyncService.java:669) ~[redisson-3.21.3.jar:3.21.3]\r\n\tat org.redisson.RedissonObject.encodeMapValue(RedissonObject.java:350) ~[redisson-3.21.3.jar:3.21.3]\r\n\tat org.redisson.RedissonMapCache.fastPutOperationAsync(RedissonMapCache.java:1022) ~[redisson-3.21.3.jar:3.21.3]\r\n\tat org.redisson.RedissonMapCache.fastPutAsync(RedissonMapCache.java:914) ~[redisson-3.21.3.jar:3.21.3]\r\n\tat org.redisson.RedissonMapCache.fastPut(RedissonMapCache.java:888) ~[redisson-3.21.3.jar:3.21.3]\r\n\tat org.redisson.spring.cache.RedissonCache.put(RedissonCache.java:124) ~[redisson-3.21.3.jar:3.21.3]\r\n```\r\n\t\r\n\r\n\r\n```\r\nCaused by: java.io.IOException: java.util.ConcurrentModificationException\r\n\tat org.redisson.codec.MarshallingCodec.lambda$new$1(MarshallingCodec.java:172) ~[redisson-3.21.3.jar:3.21.3]\r\n\tat org.redisson.command.CommandAsyncService.encodeMapValue(CommandAsyncService.java:667) ~[redisson-3.21.3.jar:3.21.3]\r\n\tat org.redisson.RedissonObject.encodeMapValue(RedissonObject.java:350) ~[redisson-3.21.3.jar:3.21.3]\r\n\tat org.redisson.RedissonMapCache.fastPutOperationAsync(RedissonMapCache.java:1022) ~[redisson-3.21.3.jar:3.21.3]\r\n\tat org.redisson.RedissonMapCache.fastPutAsync(RedissonMapCache.java:914) ~[redisson-3.21.3.jar:3.21.3]\r\n\tat org.redisson.RedissonMapCache.fastPut(RedissonMapCache.java:888) ~[redisson-3.21.3.jar:3.21.3]\r\n\tat org.redisson.spring.cache.RedissonCache.put(RedissonCache.java:124) ~[redisson-3.21.3.jar:3.21.3]\r\n```\r\n\t\r\nRedis version\r\nAWS Elasticache 7.0.7\r\n\r\nRedisson version\r\n3.21.3\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5124/comments",
    "author": "amarendrar",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-06-23T16:17:01Z",
        "body": "Can you share full stacktrace?"
      },
      {
        "user": "mrniko",
        "created_at": "2023-06-24T06:17:06Z",
        "body": "Unable to reproduce it. Below is the test.\r\n\r\n```java\r\n        ExecutorService e = Executors.newFixedThreadPool(16);\r\n        RMapCache<String, Object> mapCache = redisson.getMapCache(\"test\");\r\n\r\n        for (int i = 0; i < 100000; i++) {\r\n            int j = i;\r\n            e.submit(() -> {\r\n                mapCache.fastPut(\"\" + j, j);\r\n            });\r\n        }\r\n\r\n        e.shutdown();\r\n        assertThat(e.awaitTermination(100, TimeUnit.SECONDS)).isTrue();\r\n        assertThat(mapCache.size()).isEqualTo(100000);\r\n```"
      }
    ]
  },
  {
    "number": 5119,
    "title": "Codec Issue when upgrading from version 3.18.1 to 3.19.0",
    "created_at": "2023-06-21T21:47:21Z",
    "closed_at": "2023-06-29T05:51:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5119",
    "body": "When upgrading the version of the dependency we noticed that the default codec was changed in version 3.19.0 from MarshallingCodec  to Kyro5Codec. Now we are seeing errors in regards to:\r\n `Caused by: java.lang.ClassCastException: class java.lang.Float cannot be cast to class java.lang.String (java.lang.Float and java.lang.String are in module java.base of loader 'bootstrap')`\r\n\r\nWe have manually set the codec to MarshallingCodec  but this is not optimal as MarshallingCodec  is deprecated. Is there any advice anyone can give?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5119/comments",
    "author": "ArvinEsmailzadeh",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-06-28T13:18:14Z",
        "body": "The only way is to copy data from old object to a new one with a new codec."
      },
      {
        "user": "andreas-ajaib",
        "created_at": "2024-10-09T16:06:07Z",
        "body": "Hi @mrniko I am having similar issue after upgrading to the current version. Will object expiration via TTL solve the issue?"
      }
    ]
  },
  {
    "number": 5112,
    "title": "Retrieving parent live object by nested indexed field?",
    "created_at": "2023-06-16T10:52:15Z",
    "closed_at": "2023-06-16T19:28:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5112",
    "body": "Example:\r\n\r\n```\r\n@REntity\r\npublic class ParentObj {\r\n    @RId\r\n    Long id;\r\n\r\n    @RCascade(RCascadeType.ALL)\r\n    List<NestedObj> nestedObjs;\r\n}\r\n\r\n....\r\n\r\n@REntity\r\npublic class NestedObj {\r\n    @RId\r\n    Long nestedId;\r\n\r\n    @RIndex\r\n    Long nestedIndex;\r\n}\r\n```\r\n\r\nIs there any out-of-the-box way of finding the ParentObj(s) by an indexed field of a nested object? Something like along the lines of\r\n\r\n`rloService.find(ParentObj.class, Conditions.eq(\"nestedIndex\", 5L))`\r\n\r\nWere it not a list, you could chain the find()'s and find your parent object, but that does not seem possible if the field in question is a data structure of any type, unless I am missing something. \r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5112/comments",
    "author": "AndriusKli",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-06-16T12:53:41Z",
        "body": "Currently no. You could store parentId in NestedObj"
      }
    ]
  },
  {
    "number": 5087,
    "title": "Difference between sentinel and replicated mode",
    "created_at": "2023-06-06T09:09:26Z",
    "closed_at": "2023-07-27T10:36:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5087",
    "body": "Hi @mrniko ,\r\nI wanted to understand the difference between redisson sentinel mode and redisson replicated mode.\r\n\r\nAs per my understanding, \r\n1. both the modes support automatic switch to new masters in failover.\r\n2. In sentinel mode, redisson uses sentinels to query the new master whereas in replicated mode, redisson queries the nodes directly to find the new master. Upon discovery of new master, it switches over to new master.\r\n3. In both sentinel and replicated mode, there can be a single master and multiple replicas. \r\n\r\nIs there any benefit of using sentinel mode in redisson over replicated mode ?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5087/comments",
    "author": "kapilgarg1996",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-07-27T10:36:26Z",
        "body": "replicated mode is implemented by Redis vendor, whereas sentinel is available out of box."
      }
    ]
  },
  {
    "number": 5085,
    "title": "Getting RedissonShutdownException: Redisson is shutdown",
    "created_at": "2023-06-05T14:58:09Z",
    "closed_at": "2023-07-04T07:57:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5085",
    "body": "We do use Redisson for session management using redis since few days we are seeing the following error. we are not able to find the root cause for the same \r\n\r\nSEVERE: Can't read session object by id: F94D3971D29D306C915273E9A728D36F.ap-main-qal1-wug02-alpha-jxvz\r\norg.redisson.RedissonShutdownException: Redisson is shutdown\r\n        at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:117)\r\n        at org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:529)\r\n        at org.redisson.command.CommandAsyncService.readAsync(CommandAsyncService.java:292)\r\n        at org.redisson.RedissonMap.getAllOperationAsync(RedissonMap.java:635)\r\n        at org.redisson.RedissonMap.getAllAsync(RedissonMap.java:609)\r\n        at org.redisson.RedissonMap.getAll(RedissonMap.java:580)\r\n        at org.redisson.tomcat.RedissonSessionManager.findSession(RedissonSessionManager.java:177)\r\n        at org.redisson.tomcat.RedissonSessionManager.findSession(RedissonSessionManager.java:168)\r\n        at org.apache.catalina.connector.Request.doGetSession(Request.java:2850)\r\n        at org.apache.catalina.connector.Request.getSession(Request.java:2249)\r\n        at org.apache.catalina.valves.AbstractAccessLogValve$SessionAttributeElement.addElement(AbstractAccessLogValve.java:1421)\r\n        at org.apache.catalina.valves.AbstractAccessLogValve.log(AbstractAccessLogValve.java:639)\r\n        at org.apache.catalina.core.AccessLogAdapter.log(AccessLogAdapter.java:51)\r\n        at org.apache.catalina.core.ContainerBase.logAccess(ContainerBase.java:1043)\r\n        at org.apache.catalina.core.ContainerBase.logAccess(ContainerBase.java:1050)\r\n        at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:564)\r\n        at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1086)\r\n        at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:659)\r\n        at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223)\r\n        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1558)\r\n        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1515)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n        at java.lang.Thread.run(Thread.java:748)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5085/comments",
    "author": "vk185160",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-06-05T15:31:06Z",
        "body": "make sure that Redisson is not in shutdown state."
      }
    ]
  },
  {
    "number": 5069,
    "title": "Redisson is shutdown",
    "created_at": "2023-05-29T09:01:12Z",
    "closed_at": "2023-06-15T10:04:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5069",
    "body": "version : 3.12.0\r\napplication restart \r\n\r\norg.redisson.RedissonShutdownException: Redisson is shutdown\r\n\tat org.redisson.command.RedisExecutor.execute(RedisExecutor.java:110)\r\n\tat org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:609)\r\n\tat org.redisson.command.CommandAsyncService.writeAsync(CommandAsyncService.java:594)\r\n\tat org.redisson.RedissonLock.isHeldByThread(RedissonLock.java:522)\r\n\tat org.redisson.RedissonLock.isHeldByCurrentThread(RedissonLock.java:517)\r\n\tat com.jumstc.fdc.common.util.RedissonUtil.unlock(RedissonUtil.java:56)\r\n\tat com.jumstc.fdc.controller.bills.WithdrawalRecordController.asyncApplyWithdrawal$original$eLMkLitb(WithdrawalRecordController.java:749)\r\n\tat com.jumstc.fdc.controller.bills.WithdrawalRecordController.asyncApplyWithdrawal$original$eLMkLitb$accessor$Dkq7KY8f(WithdrawalRecordController.java)\r\n\tat com.jumstc.fdc.controller.bills.WithdrawalRecordController$auxiliary$MilnQojK.call(Unknown Source)\r\n\tat org.apache.skywalking.apm.agent.core.plugin.interceptor.enhance.InstMethodsInter.intercept(InstMethodsInter.java:86)\r\n\tat com.jumstc.fdc.controller.bills.WithdrawalRecordController.asyncApplyWithdrawal(WithdrawalRecordController.java)\r\n\tat com.jumstc.fdc.controller.bills.WithdrawalRecordController$$FastClassBySpringCGLIB$$bdc0462c.invoke(<generated>)\r\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749)\r\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n\tat org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88)\r\n\tat com.jumstc.fdc.aspect.LoggerHandler.logAround(LoggerHandler.java:73)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5069/comments",
    "author": "dognsiwei",
    "comments": [
      {
        "user": "dognsiwei",
        "created_at": "2023-05-29T09:21:00Z",
        "body": "How to solve this problem"
      },
      {
        "user": "mrniko",
        "created_at": "2023-06-05T07:25:44Z",
        "body": "how to reproduce it?"
      },
      {
        "user": "mrniko",
        "created_at": "2023-06-05T15:31:42Z",
        "body": "make sure that Redisson is not in shutdown state"
      }
    ]
  },
  {
    "number": 5061,
    "title": "Getting IllegalMonitorStateException for RMapCache Read",
    "created_at": "2023-05-24T10:47:09Z",
    "closed_at": "2023-07-03T05:36:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5061",
    "body": "Hi, \r\nGetting IllegalMonitorStateException while reading the RmapCache from Redis. There is no locks created from application and looks internally redisson uses the locks while reading the keys from Redis. \r\n\r\nCould you please suggest how to overcome this errors if there is a multiple concurrent users tries to read the keys. Is there any configuration need to be added to handle multiple reads from redisson?\r\n\r\nRedisson Verison : 3.17.6\r\n\r\nStackTrace Error:\r\n```\r\nCaused by: java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: <> thread-id: <> org.redisson.RedissonBaseLock.lambda$unlockAsync$2(RedissonBaseLock.java:323)\r\njava.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:836)\r\njava.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:811) \r\njava.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488) \r\njava.util.concurrent.CompletableFuture.complete(CompletableFuture.java:1975)\r\norg.redisson.command.CommandBatchService.lambda$executeAsync$7(CommandBatchService.java:322)\r\njava.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:774)\r\njava.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:750)\r\njava.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)\r\njava.util.concurrent.CompletableFuture.complete(CompletableFuture.java:1975)\r\norg.redisson.command.RedisCommonBatchExecutor.handleResult(RedisCommonBatchExecutor.java:163)\r\norg.redisson.command.RedisExecutor.checkAttemptPromise(RedisExecutor.java:524)\r\norg.redisson.command.RedisExecutor.lambda$execute$4(RedisExecutor.java:176)\r\njava.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:774)\r\njava.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:750)\r\njava.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)\r\njava.util.concurrent.CompletableFuture.complete(CompletableFuture.java:1975)\r\norg.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:318)^\r\norg.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:210)\r\norg.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\norg.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\nio.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\\r\r\nio.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\nio.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\nio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)\r\nio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\nio.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\r\nio.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1373)\r\nio.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1236)\r\nio.netty.handler.ssl.SslHandler.decode(SslHandler.java:1285)\r\nio.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\r\nio.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:449)\r\nio.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\nio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)\r\nio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\nio.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\r\nio.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\nio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)\r\nio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\nio.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\nio.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\nio.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)\r\nio.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)\r\nio.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)\r\nio.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)\r\nio.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\nio.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\nio.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n```\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5061/comments",
    "author": "amarendrar",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-05-24T10:56:05Z",
        "body": "you need to make sure that the lock wasn't expired if you use lease parameter."
      },
      {
        "user": "amarendrar",
        "created_at": "2023-05-24T11:17:51Z",
        "body": "I didn't use any lease parameter for the locks. I am using the default values from Redisson Client. is there any default values needs to increase to resolve the Lock issue."
      },
      {
        "user": "mrniko",
        "created_at": "2023-05-24T11:21:42Z",
        "body": "Can you share the full code?"
      },
      {
        "user": "amarendrar",
        "created_at": "2023-05-24T11:43:17Z",
        "body": "Below is the sample code for Redisson Client.\r\n\r\n```\r\npublic class RedisClient {\r\n\r\n    //@Value(\"${redisServer}\")\r\n    String redisServer =\"redisserver\";\r\n\r\n\r\n\r\n  public RedissonClient redissonClient(){\r\n     try {\r\n         this.redisServer = redisServer;\r\n         Config config = new Config();\r\n         config.setCodec(new MarshallingCodec())\r\n                 .useClusterServers()\r\n                 .addNodeAddress(\"rediss://\" + this.redisServer)\r\n                 .setUsername(\"username\")\r\n                 .setPassword(\"password\");\r\n         RedissonClient client = Redisson.create(config);\r\n         return client;\r\n     } catch(Exception e) {\r\n         e.printStackTrace();\r\n     }\r\n     return null;\r\n\r\n }\r\n\r\n\r\n  RMapCache cache = redissonClient.getMapCache(cacheName);\r\n   CacheConfig cacheConfig = new CacheConfig();\r\n   cacheConfig.setTTL(<TTL_TIme>);\r\n  RedissonCache redissonCache = new RedissonCache(cacheConfig,cache, false);\r\n  RedissonCacheMetrics.monitor(<Meter Registry>, redissonCache, Tags.of(\"RedisCacheMetrics\", cacheName));\r\n   //Get and put data from redissonCache\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2023-05-24T12:03:43Z",
        "body": "Sorry, I don't see any lock usage"
      },
      {
        "user": "amarendrar",
        "created_at": "2023-05-24T12:15:29Z",
        "body": "yes. I am not using locks and it is simple Redisson client connects to aws ElastiCache. In performance tests, I can see the IllegalMonitorStateException and stacktrace points to Redisson locks.  Is Redisson uses locks while reading/writing the data into Redis? "
      },
      {
        "user": "amarendrar",
        "created_at": "2023-05-24T13:26:24Z",
        "body": "I found one more error while writing into redis. it is again failed at lock with error \"None of slaves were synced\"\r\n\r\n Is there an issue at Redis or need to handle at Redisson to release the lock?\r\n\r\n```\r\nCaused by: org.redisson.client.RedisException: Unexpected exception while processing command\r\n\tat org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:276) \r\n\tat org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:115) \r\n\tat org.redisson.RedissonObject.get(RedissonObject.java:82) \r\n\tat org.redisson.RedissonLock.tryAcquire(RedissonLock.java:144) \r\n\tat org.redisson.RedissonLock.lock(RedissonLock.java:96) \r\n\tat org.redisson.RedissonLock.lock(RedissonLock.java:68) \r\n\tat org.redisson.RedissonMap.computeIfAbsent(RedissonMap.java:388) \r\n\r\nCaused by: java.lang.IllegalStateException: None of slaves were synced\r\n\tat org.redisson.RedissonBaseLock.lambda$evalWriteAsync$0(RedissonBaseLock.java:225) \r\n\tat java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:836) \r\n\tat java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:811) \r\n\tat java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488) \r\n\tat java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:1975) \r\n\tat org.redisson.command.CommandBatchService.lambda$executeAsync$7(CommandBatchService.java:322) \r\n\tat java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:774) \r\n\tat java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:750) \r\n\tat java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488) \r\n\tat java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:1975) \r\n\tat org.redisson.command.RedisCommonBatchExecutor.handleResult(RedisCommonBatchExecutor.java:163) \r\n\tat org.redisson.command.RedisExecutor.checkAttemptPromise(RedisExecutor.java:524) \r\n\tat org.redisson.command.RedisExecutor.lambda$execute$4(RedisExecutor.java:176) \r\n\tat java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:774) \r\n\tat java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:750) \r\n\tat java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488) \r\n\tat java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:1975) \r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:318) \r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:210) \r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137) \r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113) \r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510) \r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) \r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279) \r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444) \r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) \r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412) \r\n\tat io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1373) \r\n\tat io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1236) \r\n\tat io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1285) \r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510) \r\n\tat io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:449) \r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279) \r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444) \r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) \r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412) \r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) \r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440) \r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) \r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) \r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) \r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788) \r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724) \r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650) \r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562) \r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997) \r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) \r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) \r\n\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2023-05-24T15:23:36Z",
        "body": "> Is Redisson uses locks while reading/writing the data into Redis?\r\n\r\nNo, it doesn't.\r\n\r\n> I found one more error while writing into redis. it is again failed at lock with error \"None of slaves were synced\"\r\n\r\nYou need to update to the latest version.\r\n"
      }
    ]
  },
  {
    "number": 5059,
    "title": "Not able to connect to AWS Memory DB",
    "created_at": "2023-05-23T14:14:54Z",
    "closed_at": "2023-05-26T09:59:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5059",
    "body": "I am able to connect to memory db cluster using below command, trying to replicate the same via redission client but not able to connect please suggest the way forward.\r\n`redis-cli -c --user anand --askpass -h clustercfg.testcluster.amazonaws.com --tls --insecure`\r\n```\r\n\r\nConfig config = new Config();\r\n    config\r\n    .useClusterServers()\r\n    .addNodeAddress(\"redis://clustercfg.testcluster.amazonaws.com:6379\")\r\n    .setSslProtocols(new String[]{\"TLSv1.3\", \"TLSv1.2\", \"TLSv1.1, TLSv1\"})\r\n    .setSslProvider(SslProvider.valueOf(\"JDK\"))\r\n    .setSslEnableEndpointIdentification(true)\r\n    .setUsername(\"ANAND\")\r\n    .setPassword(\"pwd\");\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5059/comments",
    "author": "anand0761",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-05-23T14:29:10Z",
        "body": "Please share the log"
      },
      {
        "user": "anand0761",
        "created_at": "2023-05-24T02:40:23Z",
        "body": "```\r\n[INFO ] 2023-05-23 20:41:27.203 [restartedMain] AutowiredAnnotationBeanPostProcessor AutowiredAnnotationBeanPostProcessor.lambda$buildAutowiringMetadata$2(AutowiredAnnotationBeanPostProcessor.java:502) -- -- - Autowired annotation should only be used on methods with parameters: public java.util.Map com.riskanalysisservice.serviceimpl.ExternalConfigurationRequestServiceImpl.fetchAllExternalRequestConfiguration()\r\n[INFO ] 2023-05-23 20:41:27.257 [restartedMain] Version Version.logVersion(Version.java:41) -- -- - Redisson 3.21.1\r\n[ERROR] 2023-05-23 20:41:27.289 [restartedMain] DnsServerAddressStreamProviders DnsServerAddressStreamProviders.<clinit>(DnsServerAddressStreamProviders.java:73) -- -- - Unable to load io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider, fallback to system defaults. This may result in incorrect DNS resolutions on MacOS.\r\njava.lang.reflect.InvocationTargetException: null\r\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[?:1.8.0_342]\r\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[?:1.8.0_342]\r\n    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[?:1.8.0_342]\r\n    at java.lang.reflect.Constructor.newInstance(Constructor.java:423) ~[?:1.8.0_342]\r\n    at io.netty.resolver.dns.DnsServerAddressStreamProviders.<clinit>(DnsServerAddressStreamProviders.java:64) ~[netty-resolver-dns-4.1.74.Final.jar:4.1.74.Final]\r\n    at org.redisson.connection.ServiceManager.<init>(ServiceManager.java:172) ~[redisson-3.21.1.jar:3.21.1]\r\n    at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:184) ~[redisson-3.21.1.jar:3.21.1]\r\n    at org.redisson.Redisson.<init>(Redisson.java:69) ~[redisson-3.21.1.jar:3.21.1]\r\n    at org.redisson.Redisson.create(Redisson.java:114) ~[redisson-3.21.1.jar:3.21.1]\r\n    at com.riskanalysisservice.config.RedissonConfig.initializeRedis(RedissonConfig.java:42) ~[main/:?]\r\n    at com.riskanalysisservice.config.RedissonConfig$$EnhancerBySpringCGLIB$$70da613a.CGLIB$initializeRedis$0(<generated>) ~[main/:?]\r\n    at com.riskanalysisservice.config.RedissonConfig$$EnhancerBySpringCGLIB$$70da613a$$FastClassBySpringCGLIB$$22b90c24.invoke(<generated>) ~[main/:?]\r\n    at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.3.16.jar:5.3.16]\r\n    at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331) ~[spring-context-5.3.16.jar:5.3.16]\r\n    at com.riskanalysisservice.config.RedissonConfig$$EnhancerBySpringCGLIB$$70da613a.initializeRedis(<generated>) ~[main/:?]\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_342]\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_342]\r\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_342]\r\n    at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_342]\r\n    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:486) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1352) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1195) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:582) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1389) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1309) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:656) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1389) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1309) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:656) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1389) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1309) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:656) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) [spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) [spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) [spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:953) [spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918) [spring-context-5.3.16.jar:5.3.16]\r\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) [spring-context-5.3.16.jar:5.3.16]\r\n    at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:740) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:415) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:303) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1312) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301) [spring-boot-2.6.4.jar:2.6.4]\r\n    at com.riskanalysisservice.RiskAnalysisServiceApplication.main(RiskAnalysisServiceApplication.java:64) [main/:?]\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_342]\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_342]\r\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_342]\r\n    at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_342]\r\n    at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) [spring-boot-devtools-2.6.4.jar:2.6.4]\r\nCaused by: java.lang.UnsatisfiedLinkError: failed to load the required native library\r\n    at io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.ensureAvailability(MacOSDnsServerAddressStreamProvider.java:110) ~[netty-resolver-dns-classes-macos-4.1.74.Final.jar:4.1.74.Final]\r\n    at io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.<init>(MacOSDnsServerAddressStreamProvider.java:120) ~[netty-resolver-dns-classes-macos-4.1.74.Final.jar:4.1.74.Final]\r\n    ... 87 more\r\nCaused by: java.lang.UnsatisfiedLinkError: could not load a native library: netty_resolver_dns_native_macos_x86_64\r\n    at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:224) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n    at io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.loadNativeLibrary(MacOSDnsServerAddressStreamProvider.java:92) ~[netty-resolver-dns-classes-macos-4.1.74.Final.jar:4.1.74.Final]\r\n    at io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.<clinit>(MacOSDnsServerAddressStreamProvider.java:77) ~[netty-resolver-dns-classes-macos-4.1.74.Final.jar:4.1.74.Final]\r\n    at java.lang.Class.forName0(Native Method) ~[?:1.8.0_342]\r\n    at java.lang.Class.forName(Class.java:348) ~[?:1.8.0_342]\r\n    at io.netty.resolver.dns.DnsServerAddressStreamProviders$1.run(DnsServerAddressStreamProviders.java:50) ~[netty-resolver-dns-4.1.74.Final.jar:4.1.74.Final]\r\n    at java.security.AccessController.doPrivileged(Native Method) ~[?:1.8.0_342]\r\n    at io.netty.resolver.dns.DnsServerAddressStreamProviders.<clinit>(DnsServerAddressStreamProviders.java:46) ~[netty-resolver-dns-4.1.74.Final.jar:4.1.74.Final]\r\n    ... 82 more\r\n    Suppressed: java.lang.UnsatisfiedLinkError: could not load a native library: netty_resolver_dns_native_macos\r\n        at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:224) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n        at io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.loadNativeLibrary(MacOSDnsServerAddressStreamProvider.java:95) ~[netty-resolver-dns-classes-macos-4.1.74.Final.jar:4.1.74.Final]\r\n        at io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.<clinit>(MacOSDnsServerAddressStreamProvider.java:77) ~[netty-resolver-dns-classes-macos-4.1.74.Final.jar:4.1.74.Final]\r\n        at java.lang.Class.forName0(Native Method) ~[?:1.8.0_342]\r\n        at java.lang.Class.forName(Class.java:348) ~[?:1.8.0_342]\r\n        at io.netty.resolver.dns.DnsServerAddressStreamProviders$1.run(DnsServerAddressStreamProviders.java:50) ~[netty-resolver-dns-4.1.74.Final.jar:4.1.74.Final]\r\n        at java.security.AccessController.doPrivileged(Native Method) ~[?:1.8.0_342]\r\n        at io.netty.resolver.dns.DnsServerAddressStreamProviders.<clinit>(DnsServerAddressStreamProviders.java:46) ~[netty-resolver-dns-4.1.74.Final.jar:4.1.74.Final]\r\n        at org.redisson.connection.ServiceManager.<init>(ServiceManager.java:172) ~[redisson-3.21.1.jar:3.21.1]\r\n        at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:184) ~[redisson-3.21.1.jar:3.21.1]\r\n        at org.redisson.Redisson.<init>(Redisson.java:69) ~[redisson-3.21.1.jar:3.21.1]\r\n        at org.redisson.Redisson.create(Redisson.java:114) ~[redisson-3.21.1.jar:3.21.1]\r\n        at com.riskanalysisservice.config.RedissonConfig.initializeRedis(RedissonConfig.java:42) ~[main/:?]\r\n        at com.riskanalysisservice.config.RedissonConfig$$EnhancerBySpringCGLIB$$70da613a.CGLIB$initializeRedis$0(<generated>) ~[main/:?]\r\n        at com.riskanalysisservice.config.RedissonConfig$$EnhancerBySpringCGLIB$$70da613a$$FastClassBySpringCGLIB$$22b90c24.invoke(<generated>) ~[main/:?]\r\n        at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.3.16.jar:5.3.16]\r\n        at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331) ~[spring-context-5.3.16.jar:5.3.16]\r\n        at com.riskanalysisservice.config.RedissonConfig$$EnhancerBySpringCGLIB$$70da613a.initializeRedis(<generated>) ~[main/:?]\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_342]\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_342]\r\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_342]\r\n        at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_342]\r\n        at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:486) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1352) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1195) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:582) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1389) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1309) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:656) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1389) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1309) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:656) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1389) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1309) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:656) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) [spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) [spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) [spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:953) [spring-beans-5.3.16.jar:5.3.16]\r\n        at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918) [spring-context-5.3.16.jar:5.3.16]\r\n        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) [spring-context-5.3.16.jar:5.3.16]\r\n        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) [spring-boot-2.6.4.jar:2.6.4]\r\n        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:740) [spring-boot-2.6.4.jar:2.6.4]\r\n        at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:415) [spring-boot-2.6.4.jar:2.6.4]\r\n        at org.springframework.boot.SpringApplication.run(SpringApplication.java:303) [spring-boot-2.6.4.jar:2.6.4]\r\n        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1312) [spring-boot-2.6.4.jar:2.6.4]\r\n        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301) [spring-boot-2.6.4.jar:2.6.4]\r\n        at com.riskanalysisservice.RiskAnalysisServiceApplication.main(RiskAnalysisServiceApplication.java:64) [main/:?]\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_342]\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_342]\r\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_342]\r\n        at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_342]\r\n        at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) [spring-boot-devtools-2.6.4.jar:2.6.4]\r\n    Caused by: java.io.FileNotFoundException: META-INF/native/libnetty_resolver_dns_native_macos.jnilib\r\n        at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:166) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n        ... 89 more\r\n        Suppressed: java.lang.UnsatisfiedLinkError: no netty_resolver_dns_native_macos in java.library.path\r\n            at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1860) ~[?:1.8.0_342]\r\n            at java.lang.Runtime.loadLibrary0(Runtime.java:871) ~[?:1.8.0_342]\r\n            at java.lang.System.loadLibrary(System.java:1124) ~[?:1.8.0_342]\r\n            at io.netty.util.internal.NativeLibraryUtil.loadLibrary(NativeLibraryUtil.java:38) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n            at io.netty.util.internal.NativeLibraryLoader.loadLibrary(NativeLibraryLoader.java:376) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n            at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:146) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n            at io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.loadNativeLibrary(MacOSDnsServerAddressStreamProvider.java:95) ~[netty-resolver-dns-classes-macos-4.1.74.Final.jar:4.1.74.Final]\r\n            at io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.<clinit>(MacOSDnsServerAddressStreamProvider.java:77) ~[netty-resolver-dns-classes-macos-4.1.74.Final.jar:4.1.74.Final]\r\n            at java.lang.Class.forName0(Native Method) ~[?:1.8.0_342]\r\n            at java.lang.Class.forName(Class.java:348) ~[?:1.8.0_342]\r\n            at io.netty.resolver.dns.DnsServerAddressStreamProviders$1.run(DnsServerAddressStreamProviders.java:50) ~[netty-resolver-dns-4.1.74.Final.jar:4.1.74.Final]\r\n            at java.security.AccessController.doPrivileged(Native Method) ~[?:1.8.0_342]\r\n            at io.netty.resolver.dns.DnsServerAddressStreamProviders.<clinit>(DnsServerAddressStreamProviders.java:46) ~[netty-resolver-dns-4.1.74.Final.jar:4.1.74.Final]\r\n            at org.redisson.connection.ServiceManager.<init>(ServiceManager.java:172) ~[redisson-3.21.1.jar:3.21.1]\r\n            at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:184) ~[redisson-3.21.1.jar:3.21.1]\r\n            at org.redisson.Redisson.<init>(Redisson.java:69) ~[redisson-3.21.1.jar:3.21.1]\r\n            at org.redisson.Redisson.create(Redisson.java:114) ~[redisson-3.21.1.jar:3.21.1]\r\n            at com.riskanalysisservice.config.RedissonConfig.initializeRedis(RedissonConfig.java:42) ~[main/:?]\r\n            at com.riskanalysisservice.config.RedissonConfig$$EnhancerBySpringCGLIB$$70da613a.CGLIB$initializeRedis$0(<generated>) ~[main/:?]\r\n            at com.riskanalysisservice.config.RedissonConfig$$EnhancerBySpringCGLIB$$70da613a$$FastClassBySpringCGLIB$$22b90c24.invoke(<generated>) ~[main/:?]\r\n            at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.3.16.jar:5.3.16]\r\n            at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331) ~[spring-context-5.3.16.jar:5.3.16]\r\n            at com.riskanalysisservice.config.RedissonConfig$$EnhancerBySpringCGLIB$$70da613a.initializeRedis(<generated>) ~[main/:?]\r\n            at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_342]\r\n            at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_342]\r\n            at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_342]\r\n            at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_342]\r\n            at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:486) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1352) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1195) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:582) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1389) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1309) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:656) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.16.jar:5.3.16]\r\n            at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.16.jar:5.3.16]\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2023-05-24T05:55:43Z",
        "body": "You need to add `io.netty:netty-resolver-dns-native-macos:4.1.74.Final:osx-x86_64` or `io.netty:netty-resolver-dns-native-macos:4.1.74.Final:osx-aarch_64` dependency."
      },
      {
        "user": "anand0761",
        "created_at": "2023-05-24T06:25:26Z",
        "body": "@mrniko even after adding the dependency we are still getting the same error."
      },
      {
        "user": "anand0761",
        "created_at": "2023-05-24T06:45:21Z",
        "body": "```\r\n[INFO ] 2023-05-24 12:11:15.402 [restartedMain] Version Version.logVersion(Version.java:41) -- -- - Redisson 3.21.1\r\n[WARN ] 2023-05-24 12:11:18.929 [restartedMain] ClusterConnectionManager ClusterConnectionManager.connect(ClusterConnectionManager.java:150) -- -- - Command execution timeout for command: (AUTH), params: (password masked), Redis client: [addr=redis://clustercfg.testcluster.amazonaws.com:6379]\r\n[ERROR] 2023-05-24 12:11:18.971 [restartedMain] RedissonConfig RedissonConfig.initializeRedis(RedissonConfig.java:45) -- -- - Exception occurred while initializing redis :::: \r\norg.redisson.client.RedisConnectionException: Can't connect to servers!\r\n    at org.redisson.cluster.ClusterConnectionManager.connect(ClusterConnectionManager.java:157) ~[redisson-3.21.1.jar:3.21.1]\r\n    at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:209) ~[redisson-3.21.1.jar:3.21.1]\r\n    at org.redisson.Redisson.<init>(Redisson.java:69) ~[redisson-3.21.1.jar:3.21.1]\r\n    at org.redisson.Redisson.create(Redisson.java:114) ~[redisson-3.21.1.jar:3.21.1]\r\n    at com.riskanalysisservice.config.RedissonConfig.initializeRedis(RedissonConfig.java:42) ~[main/:?]\r\n    at com.riskanalysisservice.config.RedissonConfig$$EnhancerBySpringCGLIB$$e94a4eb6.CGLIB$initializeRedis$0(<generated>) ~[main/:?]\r\n    at com.riskanalysisservice.config.RedissonConfig$$EnhancerBySpringCGLIB$$e94a4eb6$$FastClassBySpringCGLIB$$575e73ab.invoke(<generated>) ~[main/:?]\r\n    at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.3.16.jar:5.3.16]\r\n    at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331) ~[spring-context-5.3.16.jar:5.3.16]\r\n    at com.riskanalysisservice.config.RedissonConfig$$EnhancerBySpringCGLIB$$e94a4eb6.initializeRedis(<generated>) ~[main/:?]\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_342]\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_342]\r\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_342]\r\n    at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_342]\r\n    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:486) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1352) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1195) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:582) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1389) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1309) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:656) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1389) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1309) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:656) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1389) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1309) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:656) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) [spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) [spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) [spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:953) [spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918) [spring-context-5.3.16.jar:5.3.16]\r\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) [spring-context-5.3.16.jar:5.3.16]\r\n    at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:740) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:415) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:303) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1312) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301) [spring-boot-2.6.4.jar:2.6.4]\r\n    at com.riskanalysisservice.RiskAnalysisServiceApplication.main(RiskAnalysisServiceApplication.java:64) [main/:?]\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_342]\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_342]\r\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_342]\r\n    at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_342]\r\n    at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) [spring-boot-devtools-2.6.4.jar:2.6.4]\r\nCaused by: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (AUTH), params: (password masked), Redis client: [addr=redis://clustercfg.testcluster.amazonaws.com:6379]\r\n    at org.redisson.client.RedisConnection.lambda$async$0(RedisConnection.java:256) ~[redisson-3.21.1.jar:3.21.1]\r\n    at io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n    at io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n    at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n    at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n    at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n    at java.lang.Thread.run(Thread.java:750) ~[?:1.8.0_342]\r\n[WARN ] 2023-05-24 12:11:18.999 [restartedMain] AnnotationConfigServletWebServerApplicationContext AbstractApplicationContext.refresh(AbstractApplicationContext.java:591) -- -- - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'externalConfigurationController': Unsatisfied dependency expressed through field 'externalConfigurationRequestService'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'externalConfigurationRequestServiceImpl': Unsatisfied dependency expressed through field 'externalConfigurationRepository'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'externalConfigurationRequestRepository': Unsatisfied dependency expressed through field 'redissonClient'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'org.redisson.api.RedissonClient' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}\r\n[INFO ] 2023-05-24 12:11:19.036 [restartedMain] ConditionEvaluationReportLoggingListener ConditionEvaluationReportLoggingListener.logMessage(ConditionEvaluationReportLoggingListener.java:136) -- -- -\r\n\r\n \r\n\r\nError starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.\r\n[INFO ] 2023-05-24 12:11:19.064 [restartedMain] Version Version.logVersion(Version.java:41) -- -- - Redisson 3.21.1\r\n[WARN ] 2023-05-24 12:11:22.234 [restartedMain] ClusterConnectionManager ClusterConnectionManager.connect(ClusterConnectionManager.java:150) -- -- - Command execution timeout for command: (AUTH), params: (password masked), Redis client: [addr=redis://clustercfg.testcluster.amazonaws.com:6379]\r\n[ERROR] 2023-05-24 12:11:22.286 [restartedMain] RedissonConfig RedissonConfig.initializeRedis(RedissonConfig.java:45) -- -- - Exception occurred while initializing redis :::: \r\norg.redisson.client.RedisConnectionException: Can't connect to servers!\r\n    at org.redisson.cluster.ClusterConnectionManager.connect(ClusterConnectionManager.java:157) ~[redisson-3.21.1.jar:3.21.1]\r\n    at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:209) ~[redisson-3.21.1.jar:3.21.1]\r\n    at org.redisson.Redisson.<init>(Redisson.java:69) ~[redisson-3.21.1.jar:3.21.1]\r\n    at org.redisson.Redisson.create(Redisson.java:114) ~[redisson-3.21.1.jar:3.21.1]\r\n    at com.riskanalysisservice.config.RedissonConfig.initializeRedis(RedissonConfig.java:42) ~[main/:?]\r\n    at com.riskanalysisservice.config.RedissonConfig$$EnhancerBySpringCGLIB$$e94a4eb6.CGLIB$initializeRedis$0(<generated>) ~[main/:?]\r\n    at com.riskanalysisservice.config.RedissonConfig$$EnhancerBySpringCGLIB$$e94a4eb6$$FastClassBySpringCGLIB$$575e73ab.invoke(<generated>) ~[main/:?]\r\n    at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.3.16.jar:5.3.16]\r\n    at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331) ~[spring-context-5.3.16.jar:5.3.16]\r\n    at com.riskanalysisservice.config.RedissonConfig$$EnhancerBySpringCGLIB$$e94a4eb6.initializeRedis(<generated>) ~[main/:?]\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_342]\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_342]\r\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_342]\r\n    at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_342]\r\n    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:638) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1352) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1195) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:582) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.16.jar:5.3.16]\r\n    at org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer.lambda$getUserConfigurationResults$0(NoSuchBeanDefinitionFailureAnalyzer.java:169) ~[spring-boot-autoconfigure-2.6.4.jar:2.6.4]\r\n    at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) [?:1.8.0_342]\r\n    at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) [?:1.8.0_342]\r\n    at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482) [?:1.8.0_342]\r\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472) [?:1.8.0_342]\r\n    at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) [?:1.8.0_342]\r\n    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) [?:1.8.0_342]\r\n    at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:566) [?:1.8.0_342]\r\n    at org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer.getUserConfigurationResults(NoSuchBeanDefinitionFailureAnalyzer.java:170) [spring-boot-autoconfigure-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer.analyze(NoSuchBeanDefinitionFailureAnalyzer.java:91) [spring-boot-autoconfigure-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer.analyze(NoSuchBeanDefinitionFailureAnalyzer.java:67) [spring-boot-autoconfigure-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.diagnostics.analyzer.AbstractInjectionFailureAnalyzer.analyze(AbstractInjectionFailureAnalyzer.java:40) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.diagnostics.AbstractFailureAnalyzer.analyze(AbstractFailureAnalyzer.java:34) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.diagnostics.FailureAnalyzers.analyze(FailureAnalyzers.java:118) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.diagnostics.FailureAnalyzers.reportException(FailureAnalyzers.java:111) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.SpringApplication.reportFailure(SpringApplication.java:820) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.SpringApplication.handleRunFailure(SpringApplication.java:794) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:313) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1312) [spring-boot-2.6.4.jar:2.6.4]\r\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301) [spring-boot-2.6.4.jar:2.6.4]\r\n    at com.riskanalysisservice.RiskAnalysisServiceApplication.main(RiskAnalysisServiceApplication.java:64) [main/:?]\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_342]\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_342]\r\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_342]\r\n    at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_342]\r\n    at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) [spring-boot-devtools-2.6.4.jar:2.6.4]\r\nCaused by: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (AUTH), params: (password masked), Redis client: [addr=redis://clustercfg.testcluster.amazonaws.com:6379]\r\n    at org.redisson.client.RedisConnection.lambda$async$0(RedisConnection.java:256) ~[redisson-3.21.1.jar:3.21.1]\r\n    at io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n    at io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n    at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n    at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n    at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n    at java.lang.Thread.run(Thread.java:750) ~[?:1.8.0_342]\r\n[ERROR] 2023-05-24 12:11:22.309 [restartedMain] LoggingFailureAnalysisReporter LoggingFailureAnalysisReporter.report(LoggingFailureAnalysisReporter.java:40) --\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2023-05-24T06:48:22Z",
        "body": "> Caused by: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (AUTH\r\n\r\nCan you check the network?"
      },
      {
        "user": "anand0761",
        "created_at": "2023-05-24T13:20:42Z",
        "body": "@mrniko we are able to connect through redis-cli. I dont think so it is network issue.\r\nthis is the command we are using \r\nredis-cli -c --user anand --askpass -h clustercfg.testcluster.amazonaws.com --tls --insecure\r\n\r\ncan you please suggest how to pass these two parameter --tls --insecure on redission?\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2023-05-24T15:26:51Z",
        "body": "did you try to set `setSslEnableEndpointIdentification(false)` ?"
      },
      {
        "user": "anand0761",
        "created_at": "2023-05-24T15:55:44Z",
        "body": "Yes I tried this option"
      },
      {
        "user": "mrniko",
        "created_at": "2023-05-24T16:13:52Z",
        "body": "Can you set `trace` logging level for `io.netty.handler.ssl` package and share output?"
      },
      {
        "user": "anand0761",
        "created_at": "2023-05-25T10:12:10Z",
        "body": "```\r\n2023-05-25 14:26:05,356 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.358 [restartedMain] InternalLoggerFactory InternalLoggerFactory.useSlf4JLoggerFactory(InternalLoggerFactory.java:63) -- -- - Using SLF4J as the default logging framework\r\n\r\n2023-05-25 14:26:05,358 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,359 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,361 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,363 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,365 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,366 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,375 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.376 [restartedMain] InternalThreadLocalMap InternalThreadLocalMap.<clinit>(InternalThreadLocalMap.java:86) -- -- - -Dio.netty.threadLocalMap.stringBuilder.initialSize: 1024\r\n\r\n[DEBUG] 2023-05-25 14:26:05.377 [restartedMain] InternalThreadLocalMap InternalThreadLocalMap.<clinit>(InternalThreadLocalMap.java:89) -- -- - -Dio.netty.threadLocalMap.stringBuilder.maxSize: 4096\r\n\r\n2023-05-25 14:26:05,378 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class org.redisson.Version\r\n\r\n[INFO ] 2023-05-25 14:26:05.379 [restartedMain] Version Version.logVersion(Version.java:41) -- -- - Redisson 3.21.1\r\n\r\n2023-05-25 14:26:05,381 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.381 [restartedMain] MultithreadEventLoopGroup MultithreadEventLoopGroup.<clinit>(MultithreadEventLoopGroup.java:44) -- -- - -Dio.netty.eventLoopThreads: 16\r\n\r\n2023-05-25 14:26:05,385 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,386 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,387 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,388 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.388 [restartedMain] PlatformDependent0 PlatformDependent0.explicitNoUnsafeCause0(PlatformDependent0.java:460) -- -- - -Dio.netty.noUnsafe: false\r\n\r\n[DEBUG] 2023-05-25 14:26:05.389 [restartedMain] PlatformDependent0 PlatformDependent0.javaVersion0(PlatformDependent0.java:954) -- -- - Java version: 8\r\n\r\n[DEBUG] 2023-05-25 14:26:05.390 [restartedMain] PlatformDependent0 PlatformDependent0.<clinit>(PlatformDependent0.java:135) -- -- - sun.misc.Unsafe.theUnsafe: available\r\n\r\n[DEBUG] 2023-05-25 14:26:05.391 [restartedMain] PlatformDependent0 PlatformDependent0.<clinit>(PlatformDependent0.java:159) -- -- - sun.misc.Unsafe.copyMemory: available\r\n\r\n[DEBUG] 2023-05-25 14:26:05.391 [restartedMain] PlatformDependent0 PlatformDependent0.<clinit>(PlatformDependent0.java:202) -- -- - java.nio.Buffer.address: available\r\n\r\n[DEBUG] 2023-05-25 14:26:05.392 [restartedMain] PlatformDependent0 PlatformDependent0.<clinit>(PlatformDependent0.java:272) -- -- - direct buffer constructor: available\r\n\r\n[DEBUG] 2023-05-25 14:26:05.393 [restartedMain] PlatformDependent0 PlatformDependent0.<clinit>(PlatformDependent0.java:350) -- -- - java.nio.Bits.unaligned: available, true\r\n\r\n[DEBUG] 2023-05-25 14:26:05.394 [restartedMain] PlatformDependent0 PlatformDependent0.<clinit>(PlatformDependent0.java:424) -- -- - jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable prior to Java9\r\n\r\n[DEBUG] 2023-05-25 14:26:05.394 [restartedMain] PlatformDependent0 PlatformDependent0.<clinit>(PlatformDependent0.java:446) -- -- - java.nio.DirectByteBuffer.<init>(long, int): available\r\n\r\n[DEBUG] 2023-05-25 14:26:05.394 [restartedMain] PlatformDependent PlatformDependent.unsafeUnavailabilityCause0(PlatformDependent.java:1116) -- -- - sun.misc.Unsafe: available\r\n\r\n[DEBUG] 2023-05-25 14:26:05.394 [restartedMain] PlatformDependent PlatformDependent.tmpdir0(PlatformDependent.java:1237) -- -- - -Dio.netty.tmpdir: /var/folders/4s/2fd9g6715hjb408r9zsd8dwhl49sn5/T (java.io.tmpdir)\r\n\r\n[DEBUG] 2023-05-25 14:26:05.394 [restartedMain] PlatformDependent PlatformDependent.bitMode0(PlatformDependent.java:1316) -- -- - -Dio.netty.bitMode: 64 (sun.arch.data.model)\r\n\r\n[DEBUG] 2023-05-25 14:26:05.396 [restartedMain] PlatformDependent PlatformDependent.isOsx0(PlatformDependent.java:1084) -- -- - Platform: MacOS\r\n\r\n[DEBUG] 2023-05-25 14:26:05.397 [restartedMain] PlatformDependent PlatformDependent.<clinit>(PlatformDependent.java:178) -- -- - -Dio.netty.maxDirectMemory: 3817865216 bytes\r\n\r\n[DEBUG] 2023-05-25 14:26:05.397 [restartedMain] PlatformDependent PlatformDependent.<clinit>(PlatformDependent.java:185) -- -- - -Dio.netty.uninitializedArrayAllocationThreshold: -1\r\n\r\n2023-05-25 14:26:05,398 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.398 [restartedMain] CleanerJava6 CleanerJava6.<clinit>(CleanerJava6.java:92) -- -- - java.nio.ByteBuffer.cleaner(): available\r\n\r\n[DEBUG] 2023-05-25 14:26:05.398 [restartedMain] PlatformDependent PlatformDependent.<clinit>(PlatformDependent.java:205) -- -- - -Dio.netty.noPreferDirect: false\r\n\r\n[DEBUG] 2023-05-25 14:26:05.399 [restartedMain] NioEventLoop NioEventLoop.<clinit>(NioEventLoop.java:109) -- -- - -Dio.netty.noKeySetOptimization: false\r\n\r\n[DEBUG] 2023-05-25 14:26:05.399 [restartedMain] NioEventLoop NioEventLoop.<clinit>(NioEventLoop.java:110) -- -- - -Dio.netty.selectorAutoRebuildThreshold: 512\r\n\r\n[DEBUG] 2023-05-25 14:26:05.400 [restartedMain] PlatformDependent PlatformDependent$Mpsc.<clinit>(PlatformDependent.java:967) -- -- - org.jctools-core.MpscChunkedArrayQueue: available\r\n\r\n[TRACE] 2023-05-25 14:26:05.407 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@51d15f4d\r\n\r\n[TRACE] 2023-05-25 14:26:05.408 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@39c0ee07\r\n\r\n[TRACE] 2023-05-25 14:26:05.408 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@6e73fc\r\n\r\n[TRACE] 2023-05-25 14:26:05.408 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@71c3da81\r\n\r\n[TRACE] 2023-05-25 14:26:05.408 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@5bf15f23\r\n\r\n[TRACE] 2023-05-25 14:26:05.408 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@65ff328c\r\n\r\n[TRACE] 2023-05-25 14:26:05.408 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@16fd4c5c\r\n\r\n[TRACE] 2023-05-25 14:26:05.408 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@79058bd0\r\n\r\n[TRACE] 2023-05-25 14:26:05.409 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@28dcdb94\r\n\r\n[TRACE] 2023-05-25 14:26:05.409 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@34abe751\r\n\r\n[TRACE] 2023-05-25 14:26:05.409 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@48c8d234\r\n\r\n[TRACE] 2023-05-25 14:26:05.409 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@1d469bf6\r\n\r\n[TRACE] 2023-05-25 14:26:05.409 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@5388e3b1\r\n\r\n[TRACE] 2023-05-25 14:26:05.409 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@387207fe\r\n\r\n[TRACE] 2023-05-25 14:26:05.409 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@36a53bb6\r\n\r\n[TRACE] 2023-05-25 14:26:05.410 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@1f158fbf\r\n\r\n[TRACE] 2023-05-25 14:26:05.410 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@b147287\r\n\r\n[TRACE] 2023-05-25 14:26:05.410 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@2371d9ec\r\n\r\n[TRACE] 2023-05-25 14:26:05.410 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@3c163ebf\r\n\r\n[TRACE] 2023-05-25 14:26:05.410 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@fcd36f5\r\n\r\n[TRACE] 2023-05-25 14:26:05.410 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@2765fdc1\r\n\r\n[TRACE] 2023-05-25 14:26:05.410 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@af6fe78\r\n\r\n[TRACE] 2023-05-25 14:26:05.411 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@718da5f\r\n\r\n[TRACE] 2023-05-25 14:26:05.411 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@61043ed7\r\n\r\n[TRACE] 2023-05-25 14:26:05.411 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@69874cc3\r\n\r\n[TRACE] 2023-05-25 14:26:05.411 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@543f7ab5\r\n\r\n[TRACE] 2023-05-25 14:26:05.411 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@1534884f\r\n\r\n[TRACE] 2023-05-25 14:26:05.411 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@5586feb8\r\n\r\n[TRACE] 2023-05-25 14:26:05.412 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@634419f\r\n\r\n[TRACE] 2023-05-25 14:26:05.412 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@29f1793e\r\n\r\n[TRACE] 2023-05-25 14:26:05.413 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@1836fabf\r\n\r\n[TRACE] 2023-05-25 14:26:05.413 [restartedMain] NioEventLoop NioEventLoop.openSelector(NioEventLoop.java:263) -- -- - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@7a27a43f\r\n\r\n2023-05-25 14:26:05,418 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,419 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,420 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.421 [restartedMain] NativeLibraryLoader NativeLibraryLoader.<clinit>(NativeLibraryLoader.java:78) -- -- - -Dio.netty.native.workdir: /var/folders/4s/2fd9g6715hjb408r9zsd8dwhl49sn5/T (io.netty.tmpdir)\r\n\r\n[DEBUG] 2023-05-25 14:26:05.421 [restartedMain] NativeLibraryLoader NativeLibraryLoader.<clinit>(NativeLibraryLoader.java:83) -- -- - -Dio.netty.native.deleteLibAfterLoading: true\r\n\r\n[DEBUG] 2023-05-25 14:26:05.422 [restartedMain] NativeLibraryLoader NativeLibraryLoader.<clinit>(NativeLibraryLoader.java:87) -- -- - -Dio.netty.native.tryPatchShadedId: true\r\n\r\n[DEBUG] 2023-05-25 14:26:05.422 [restartedMain] NativeLibraryLoader NativeLibraryLoader.<clinit>(NativeLibraryLoader.java:91) -- -- - -Dio.netty.native.detectNativeLibraryDuplicates: true\r\n\r\n[DEBUG] 2023-05-25 14:26:05.641 [restartedMain] NativeLibraryLoader NativeLibraryLoader.loadLibrary(NativeLibraryLoader.java:369) -- -- - Successfully loaded the library /var/folders/4s/2fd9g6715hjb408r9zsd8dwhl49sn5/T/libnetty_resolver_dns_native_macos_x86_648407638271252344728.dylib\r\n\r\n[DEBUG] 2023-05-25 14:26:05.644 [restartedMain] DnsServerAddressStreamProviders DnsServerAddressStreamProviders.<clinit>(DnsServerAddressStreamProviders.java:65) -- -- - io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider: available\r\n\r\n2023-05-25 14:26:05,646 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,650 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,655 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.655 [restartedMain] NetUtil NetUtil.<clinit>(NetUtil.java:135) -- -- - -Djava.net.preferIPv4Stack: false\r\n\r\n[DEBUG] 2023-05-25 14:26:05.656 [restartedMain] NetUtil NetUtil.<clinit>(NetUtil.java:136) -- -- - -Djava.net.preferIPv6Addresses: false\r\n\r\n2023-05-25 14:26:05,656 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.658 [restartedMain] NetUtilInitializations NetUtilInitializations.determineLoopback(NetUtilInitializations.java:129) -- -- - Loopback interface: lo0 (lo0, 0:0:0:0:0:0:0:1%lo0)\r\n\r\n[DEBUG] 2023-05-25 14:26:05.658 [restartedMain] NetUtil NetUtil$1.run(NetUtil.java:187) -- -- - Failed to get SOMAXCONN from sysctl and file /proc/sys/net/core/somaxconn. Default: 128\r\n\r\n2023-05-25 14:26:05,660 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,670 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.672 [restartedMain] DefaultHostsFileEntriesResolver DefaultHostsFileEntriesResolver.<clinit>(DefaultHostsFileEntriesResolver.java:53) -- -- - -Dio.netty.hostsFileRefreshInterval: 0\r\n\r\n2023-05-25 14:26:05,673 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,678 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class org.redisson.connection.MasterSlaveConnectionManager\r\n\r\n2023-05-25 14:26:05,679 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,680 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,681 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.681 [restartedMain] ResourceLeakDetector ResourceLeakDetector.<clinit>(ResourceLeakDetector.java:129) -- -- - -Dio.netty.leakDetection.level: simple\r\n\r\n[DEBUG] 2023-05-25 14:26:05.681 [restartedMain] ResourceLeakDetector ResourceLeakDetector.<clinit>(ResourceLeakDetector.java:130) -- -- - -Dio.netty.leakDetection.targetRecords: 4\r\n\r\n[DEBUG] 2023-05-25 14:26:05.685 [restartedMain] ResourceLeakDetectorFactory ResourceLeakDetectorFactory$DefaultResourceLeakDetectorFactory.newResourceLeakDetector(ResourceLeakDetectorFactory.java:196) -- -- - Loaded default ResourceLeakDetector: io.netty.util.ResourceLeakDetector@36e1427d\r\n\r\n2023-05-25 14:26:05,691 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class org.redisson.connection.IdleConnectionWatcher\r\n\r\n2023-05-25 14:26:05,697 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class org.redisson.pubsub.PublishSubscribeService\r\n\r\n2023-05-25 14:26:05,699 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class org.redisson.cluster.ClusterConnectionManager\r\n\r\n2023-05-25 14:26:05,717 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,719 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,720 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class org.redisson.client.handler.PingConnectionHandler\r\n\r\n2023-05-25 14:26:05,720 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class org.redisson.client.handler.ConnectionWatchdog\r\n\r\n2023-05-25 14:26:05,722 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class org.redisson.client.handler.ConnectionWatchdog\r\n\r\n2023-05-25 14:26:05,729 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,729 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,736 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.737 [restartedMain] DefaultChannelId DefaultChannelId.<clinit>(DefaultChannelId.java:79) -- -- - -Dio.netty.processId: 10396 (auto-detected)\r\n\r\n2023-05-25 14:26:05,738 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.742 [restartedMain] DefaultChannelId DefaultChannelId.<clinit>(DefaultChannelId.java:101) -- -- - -Dio.netty.machineId: bc:d0:74:ff:fe:36:03:cc (auto-detected)\r\n\r\n2023-05-25 14:26:05,745 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,748 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,752 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,754 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,758 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,761 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,765 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.766 [restartedMain] PooledByteBufAllocator PooledByteBufAllocator.<clinit>(PooledByteBufAllocator.java:155) -- -- - -Dio.netty.allocator.numHeapArenas: 16\r\n\r\n[DEBUG] 2023-05-25 14:26:05.768 [restartedMain] PooledByteBufAllocator PooledByteBufAllocator.<clinit>(PooledByteBufAllocator.java:156) -- -- - -Dio.netty.allocator.numDirectArenas: 16\r\n\r\n[DEBUG] 2023-05-25 14:26:05.768 [restartedMain] PooledByteBufAllocator PooledByteBufAllocator.<clinit>(PooledByteBufAllocator.java:158) -- -- - -Dio.netty.allocator.pageSize: 8192\r\n\r\n[DEBUG] 2023-05-25 14:26:05.768 [restartedMain] PooledByteBufAllocator PooledByteBufAllocator.<clinit>(PooledByteBufAllocator.java:163) -- -- - -Dio.netty.allocator.maxOrder: 11\r\n\r\n[DEBUG] 2023-05-25 14:26:05.768 [restartedMain] PooledByteBufAllocator PooledByteBufAllocator.<clinit>(PooledByteBufAllocator.java:167) -- -- - -Dio.netty.allocator.chunkSize: 16777216\r\n\r\n[DEBUG] 2023-05-25 14:26:05.769 [restartedMain] PooledByteBufAllocator PooledByteBufAllocator.<clinit>(PooledByteBufAllocator.java:168) -- -- - -Dio.netty.allocator.smallCacheSize: 256\r\n\r\n[DEBUG] 2023-05-25 14:26:05.769 [restartedMain] PooledByteBufAllocator PooledByteBufAllocator.<clinit>(PooledByteBufAllocator.java:169) -- -- - -Dio.netty.allocator.normalCacheSize: 64\r\n\r\n[DEBUG] 2023-05-25 14:26:05.769 [restartedMain] PooledByteBufAllocator PooledByteBufAllocator.<clinit>(PooledByteBufAllocator.java:170) -- -- - -Dio.netty.allocator.maxCachedBufferCapacity: 32768\r\n\r\n[DEBUG] 2023-05-25 14:26:05.769 [restartedMain] PooledByteBufAllocator PooledByteBufAllocator.<clinit>(PooledByteBufAllocator.java:171) -- -- - -Dio.netty.allocator.cacheTrimInterval: 8192\r\n\r\n[DEBUG] 2023-05-25 14:26:05.769 [restartedMain] PooledByteBufAllocator PooledByteBufAllocator.<clinit>(PooledByteBufAllocator.java:172) -- -- - -Dio.netty.allocator.cacheTrimIntervalMillis: 0\r\n\r\n[DEBUG] 2023-05-25 14:26:05.769 [restartedMain] PooledByteBufAllocator PooledByteBufAllocator.<clinit>(PooledByteBufAllocator.java:173) -- -- - -Dio.netty.allocator.useCacheForAllThreads: true\r\n\r\n[DEBUG] 2023-05-25 14:26:05.769 [restartedMain] PooledByteBufAllocator PooledByteBufAllocator.<clinit>(PooledByteBufAllocator.java:174) -- -- - -Dio.netty.allocator.maxCachedByteBuffersPerChunk: 1023\r\n\r\n2023-05-25 14:26:05,773 restartedMain TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.779 [restartedMain] ByteBufUtil ByteBufUtil.<clinit>(ByteBufUtil.java:87) -- -- - -Dio.netty.allocator.type: pooled\r\n\r\n[DEBUG] 2023-05-25 14:26:05.780 [restartedMain] ByteBufUtil ByteBufUtil.<clinit>(ByteBufUtil.java:96) -- -- - -Dio.netty.threadLocalDirectBufferSize: 0\r\n\r\n[DEBUG] 2023-05-25 14:26:05.780 [restartedMain] ByteBufUtil ByteBufUtil.<clinit>(ByteBufUtil.java:99) -- -- - -Dio.netty.maxThreadLocalCharBufferSize: 16384\r\n\r\n2023-05-25 14:26:05,817 redisson-netty-2-2 TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,822 redisson-netty-2-2 TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.824 [redisson-netty-2-2] ResourceLeakDetectorFactory ResourceLeakDetectorFactory$DefaultResourceLeakDetectorFactory.newResourceLeakDetector(ResourceLeakDetectorFactory.java:196) -- -- - Loaded default ResourceLeakDetector: io.netty.util.ResourceLeakDetector@4c1f144f\r\n\r\n[DEBUG] 2023-05-25 14:26:05.836 [redisson-netty-2-2] DnsQueryContext DnsQueryContext.query(DnsQueryContext.java:117) -- -- - [id: 0x3f178b27] WRITE: UDP, [28421: /172.20.10.1:53], DefaultDnsQuestion(clustercfg.test.amazonaws.com. IN A)\r\n\r\n2023-05-25 14:26:05,836 redisson-netty-2-2 TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:05,842 redisson-netty-2-2 TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.842 [redisson-netty-2-2] Recycler Recycler.<clinit>(Recycler.java:85) -- -- - -Dio.netty.recycler.maxCapacityPerThread: 4096\r\n\r\n[DEBUG] 2023-05-25 14:26:05.843 [redisson-netty-2-2] Recycler Recycler.<clinit>(Recycler.java:86) -- -- - -Dio.netty.recycler.ratio: 8\r\n\r\n[DEBUG] 2023-05-25 14:26:05.843 [redisson-netty-2-2] Recycler Recycler.<clinit>(Recycler.java:87) -- -- - -Dio.netty.recycler.chunkSize: 32\r\n\r\n[DEBUG] 2023-05-25 14:26:05.843 [redisson-netty-2-2] Recycler Recycler.<clinit>(Recycler.java:88) -- -- - -Dio.netty.recycler.blocking: false\r\n\r\n2023-05-25 14:26:05,847 redisson-netty-2-2 TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n[DEBUG] 2023-05-25 14:26:05.847 [redisson-netty-2-2] AbstractByteBuf AbstractByteBuf.<clinit>(AbstractByteBuf.java:63) -- -- - -Dio.netty.buffer.checkAccessible: true\r\n\r\n[DEBUG] 2023-05-25 14:26:05.847 [redisson-netty-2-2] AbstractByteBuf AbstractByteBuf.<clinit>(AbstractByteBuf.java:64) -- -- - -Dio.netty.buffer.checkBounds: true\r\n\r\n[DEBUG] 2023-05-25 14:26:05.847 [redisson-netty-2-2] ResourceLeakDetectorFactory ResourceLeakDetectorFactory$DefaultResourceLeakDetectorFactory.newResourceLeakDetector(ResourceLeakDetectorFactory.java:196) -- -- - Loaded default ResourceLeakDetector: io.netty.util.ResourceLeakDetector@1ff9b8c\r\n\r\n[DEBUG] 2023-05-25 14:26:06.122 [redisson-netty-2-2] DnsNameResolver DnsNameResolver$DnsResponseHandler.channelRead(DnsNameResolver.java:1302) -- -- - [id: 0x3f178b27] RECEIVED: UDP [28421: /172.20.10.1:53], DatagramDnsResponse(from: /172.20.10.1:53, to: /0:0:0:0:0:0:0:0:51850, 28421, QUERY(0), NoError(0), RD RA)\r\n\r\nDefaultDnsQuestion(clustercfg.test.amazonaws.com. IN A)\r\n\r\nDefaultDnsRawRecord(clustercfg.test.memorydb.ap-south-1.amazonaws.com. 20 IN A 4B)\r\n\r\nDefaultDnsRawRecord(OPT flags:0 udp:4096 0B)\r\n\r\n2023-05-25 14:26:06,124 redisson-netty-2-2 TRACE Log4jLoggerFactory.getContext() found anchor class io.netty.util.internal.logging.Slf4JLoggerFactory\r\n\r\n2023-05-25 14:26:06,136 redisson-netty-2-3 TRACE Log4jLoggerFactory.getContext() found anchor class org.redisson.client.handler.CommandEncoder\r\n\r\n2023-05-25 14:26:06,147 redisson-netty-2-3 TRACE Log4jLoggerFactory.getContext() found anchor class org.redisson.client.handler.CommandDecoder\r\n\r\n2023-05-25 14:26:06,147 redisson-netty-2-3 TRACE Log4jLoggerFactory.getContext() found anchor class org.redisson.client.handler.ErrorsLoggingHandler\r\n\r\n2023-05-25 14:26:06,154 redisson-netty-2-3 TRACE Log4jLoggerFactory.getContext() found anchor class org.redisson.client.RedisConnection\r\n\r\n[DEBUG] 2023-05-25 14:26:06.155 [redisson-netty-2-3] RedisConnection RedisConnection.<init>(RedisConnection.java:76) -- -- - Connection created [addr=redis://clustercfg.test..amazonaws.com:6379]\r\n\r\n[TRACE] 2023-05-25 14:26:06.258 [redisson-netty-2-3] CommandEncoder CommandEncoder.encode(CommandEncoder.java:108) -- -- - channel: [id: 0x589b63ae, L:/10.50.32.5:54921 - R:clustercfg.test.amazonaws.com/10.248.11.174:6379] message: *3\r\n\r\n$4\r\n\r\nAUTH(password masked)\r\n\r\n[TRACE] 2023-05-25 14:26:06.261 [redisson-netty-2-3] CommandEncoder CommandEncoder.encode(CommandEncoder.java:108) -- -- - channel: [id: 0x589b63ae, L:/10.50.32.5:54921 - R:clustercfg.test.amazonaws.com/10.248.11.174:6379] message: *1\r\n\r\n$4\r\n\r\nPING\r\n\r\n \r\n\r\n[WARN ] 2023-05-25 14:26:09.365 [restartedMain] ClusterConnectionManager ClusterConnectionManager.connect(ClusterConnectionManager.java:150) -- -- - Command execution timeout for command: (AUTH), params: (password masked), Redis client: [addr=redis://clustercfg.test:6379]\r\n\r\n[TRACE] 2023-05-25 14:26:09.375 [redisson-netty-2-3] CommandEncoder CommandEncoder.encode(CommandEncoder.java:108) -- -- - channel: [id: 0x589b63ae, L:/10.50.32.5:54921 ! R:clustercfg.test.amazonaws.com/10.248.11.174:6379] message: *1\r\n\r\n$4\r\n\r\nQUIT\r\n\r\n \r\n\r\n[DEBUG] 2023-05-25 14:26:09.395 [redisson-netty-2-2] PoolThreadCache PoolThreadCache.free(PoolThreadCache.java:224) -- -- - Freed 2 thread-local buffer(s) from thread: redisson-netty-2-2\r\n\r\n[DEBUG] 2023-05-25 14:26:09.397 [redisson-netty-2-3] PoolThreadCache PoolThreadCache.free(PoolThreadCache.java:224) -- -- - Freed 3 thread-local buffer(s) from thread: redisson-netty-2-3\r\n\r\n[ERROR] 2023-05-25 14:26:09.415 [restartedMain] RedissonConfig RedissonConfig.initializeRedis(RedissonConfig.java:42) -- -- - Exception occurred while initialising redis :: \r\n\r\norg.redisson.client.RedisConnectionException: Can't connect to servers!\r\n\r\nat org.redisson.cluster.ClusterConnectionManager.connect(ClusterConnectionManager.java:157) ~[redisson-3.21.1.jar:3.21.1]\r\n\r\nat org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:209) ~[redisson-3.21.1.jar:3.21.1]\r\n\r\nat org.redisson.Redisson.<init>(Redisson.java:69) ~[redisson-3.21.1.jar:3.21.1]\r\n\r\nat org.redisson.Redisson.create(Redisson.java:114) ~[redisson-3.21.1.jar:3.21.1]\r\n\r\nat org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331) ~[spring-context-5.3.16.jar:5.3.16]\r\n\r\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_342]\r\n\r\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_342]\r\n\r\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_342]\r\n\r\nat java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_342]\r\n\r\nat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:486) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1352) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1195) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:582) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1389) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1309) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:656) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1389) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1309) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:656) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1389) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1309) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:656) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) [spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) [spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) [spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:953) [spring-beans-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918) [spring-context-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) [spring-context-5.3.16.jar:5.3.16]\r\n\r\nat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) [spring-boot-2.6.4.jar:2.6.4]\r\n\r\nat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:740) [spring-boot-2.6.4.jar:2.6.4]\r\n\r\nat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:415) [spring-boot-2.6.4.jar:2.6.4]\r\n\r\nat org.springframework.boot.SpringApplication.run(SpringApplication.java:303) [spring-boot-2.6.4.jar:2.6.4]\r\n\r\nat org.springframework.boot.SpringApplication.run(SpringApplication.java:1312) [spring-boot-2.6.4.jar:2.6.4]\r\n\r\nat org.springframework.boot.SpringApplication.run(SpringApplication.java:1301) [spring-boot-2.6.4.jar:2.6.4]\r\n\r\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_342]\r\n\r\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_342]\r\n\r\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_342]\r\n\r\nat java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_342]\r\n\r\nat org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) [spring-boot-devtools-2.6.4.jar:2.6.4]\r\n\r\nCaused by: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (AUTH), params: (password masked), Redis client: [addr=redis://clustercfg.test.amazonaws.com:6379]\r\n\r\nat org.redisson.client.RedisConnection.lambda$async$0(RedisConnection.java:256) ~[redisson-3.21.1.jar:3.21.1]\r\n\r\nat io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n\r\nat io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n\r\nat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n\r\nat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n\r\nat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n\r\nat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.74.Final.jar:4.1.74.Final]\r\n\r\nat java.lang.Thread.run(Thread.java:750) ~[?:1.8.0_342]\r\n\r\n[TRACE] 2023-05-25 14:26:09.441 [restartedMain] KafkaListenerAnnotationBeanPostProcessor LogAccessor.trace(LogAccessor.java:334) -- -- - No @KafkaListener annotations found on bean type: class org.springframework.beans.factory.support.NullBean\r\n\r\n[TRACE] 2023-05-25 14:26:09.444 [restartedMain] ScheduledAnnotationBeanPostProcessor ScheduledAnnotationBeanPostProcessor.postProcessAfterInitialization(ScheduledAnnotationBeanPostProcessor.java:374) -- -- - No @Scheduled annotations found on bean class: class org.springframework.beans.factory.support.NullBean\r\n\r\n[TRACE] 2023-05-25 14:26:09.444 [restartedMain] DefaultListableBeanFactory AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:544) -- -- - Finished creating instance of bean 'redisBean'\r\n\r\n[WARN ] 2023-05-25 14:26:09.452 [restartedMain] AnnotationConfigServletWebServerApplicationContext AbstractApplicationContext.refresh(AbstractApplicationContext.java:591) -- -- - Exception encountered during context initialization - cancelling refresh attempt:org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'org.redisson.api.RedissonClient' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}\r\n\r\n[TRACE] 2023-05-25 14:26:09.453 [restartedMain] DefaultListableBeanFactory DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:509) -- -- - Destroying singletons in org.springframework.boot.autoconfigure.web.ServerProperties,webServerFactoryCustomizerBeanPostProcessor,errorPageRegistrarBeanPostProcessor,org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration$DispatcherServletConfiguration,dispatcherServlet,spring.mvc-org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties,org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration$DispatcherServletRegistrationConfiguration,dispatcherServletRegistration,org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,taskExecutorBuilder,spring.task.execution-org.springframework.boot.autoconfigure.task.TaskExecutionProperties,org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,defaultValidator,methodValidationPostProcessor,org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguratioorg.springframework.boot.autoconfigure.jackson.JacksonProperties,org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperBuilderConfiguration,jacksonObjectMapperBuilder,org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$ParameterNamesModuleConfiguration,parameterNamesModule,org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperConfiguration,org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,jsonComponentModule,org.springdoc.core.SpringDocConfigProperties,org.springdoc.core.SpringDocConfiguration$SpringDocSpringDataWebPropertiesProvider,springDataWebPropertiesProvider,org.springdoc.core.SpringDocConfiguration$WebConversionServiceConfiguration,webConversionServiceProvider,org.springdoc.core.SpringDocConfiguration$OpenApiResourceAdvice,org.springdoc.core.SpringDocConfiguration,localSpringDocParameterNameDiscoverer,additionalModelsConverter,propertyCustomizingConverter,fileSupportConverter,responseSupportConverter,schemaPropertyDeprecatingConverter,polymorphicModelConverter,openAPIBuilder,modelConverterRegistrar,operationBuilder,propertyResolverUtils,requestBodyBuilder,securityParser,genericReturnTypeParser,parameterBuilder,springDocProviders,org.springdoc.core.SwaggerUiConfigParameters,org.springdoc.core.SwaggerUiConfigProperties,org.springdoc.core.SwaggerUiOAuthProperties,org.springdoc.webmvc.core.SpringDocWebMvcConfiguration$SpringDocWebMvcActuatorConfiguration,org.springdoc.webmvc.core.SpringDocWebMvcConfiguration$SpringDocWebMvcRouterConfiguration,routerFunctionProvider,org.springdoc.webmvc.core.SpringDocWebMvcConfiguration,openApiResource,requestBuilder,springWebProvider,responseBuilder,org.springdoc.webmvc.ui.SwaggerConfig,swaggerWelcome,swaggerConfigResource,indexPageTransformer,swaggerWebMvcConfigurer,org.springframework.boot.actuate.autoconfigure.audit.AuditEventsEndpointAutoConfiguration,org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,applicationAvailability,org.springframework.boot.actuate.autoconfigure.availability.AvailabilityHealthContributorAutoConfiguration,org.springframework.boot.actuate.autoconfigure.beans.BeansEndpointAutoConfiguration,beansEndpoint,org.springframework.boot.actuate.autoconfigure.cache.CachesEndpointAutoConfiguration,cachesEndpoint,cachesEndpointWebExtension,org.springframework.boot.actuate.autoconfigure.web.servlet.ServletManagementContextAutoConfiguration,servletWebChildContextFactory,managementServletContext,org.springframework.boot.actuate.autoconfigure.health.HealthEndpointConfiguration,healthStatusAggregator,healthHttpCodeStatusMapper,healthEndpointGroups,healthContributorRegistry,healthEndpoint,healthEndpointGroupsBeanPostProcessor,org.springframework.boot.actuate.autoconfigure.health.ReactiveHealthEndpointConfiguration,reactiveHealthContributorRegistry,org.springframework.boot.actuate.autoconfigure.health.HealthEndpointWebExtensionConfiguration$MvcAdditionalHealthEndpointPathsConfiguration,healthEndpointWebMvcHandlerMapping,org.springframework.boot.actuate.autoconfigure.health.HealthEndpointWebExtensionConfiguration,healthEndpointWebExtension,org.springframework.boot.actuate.autoconfigure.health.HealthEndpointAutoConfiguration,management.endpoint.health-org.springframework.boot.actuate.autoconfigure.health.HealthEndpointProperties,org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,spring.info-org.springframework.boot.autoconfigure.info.ProjectInfoProperties,org.springframework.boot.actuate.autoconfigure.info.InfoContributorAutoConfiguration,management.info-org.springframework.boot.actuate.autoconfigure.info.InfoContributorProperties,org.springframework.boot.actuate.autoconfigure.info.InfoEndpointAutoConfiguration,infoEndpoint,org.springframework.boot.actuate.autoconfigure.condition.ConditionsReportEndpointAutoConfiguration,conditionsReportEndpoint,org.springframework.boot.actuate.autoconfigure.context.properties.ConfigurationPropertiesReportEndpointAutoConfiguration,configurationPropertiesReportEndpoint,configurationPropertiesReportEndpointWebExtension,management.endpoint.configprops-org.springframework.boot.actuate.autoconfigure.context.properties.ConfigurationPropertiesReportEndpointProperties,org.springframework.boot.actuate.autoconfigure.endpoint.EndpointAutoConfiguration,endpointOperationParameterMapper,endpointCachingOperationInvokerAdvisor,org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,mbeanExporter,objectNamingStrategy,mbeanServer,org.springframework.boot.actuate.autoconfigure.endpoint.jmx.JmxEndpointAutoConfiguration,jmxAnnotationEndpointDiscoverer,endpointObjectNameFactory,jmxMBeanExporter,jmxIncludeExcludePropertyEndpointFilter,eagerlyInitializeJmxEndpointExporter,management.endpoints.jmx-org.springframework.boot.actuate.autoconfigure.endpoint.jmx.JmxEndpointProperties,org.springframework.boot.actuate.autoconfigure.endpoint.web.WebEndpointAutoConfiguration$WebEndpointServletConfiguration,servletEndpointDiscoverer,org.springframework.boot.actuate.autoagement.endpoints.web-org.springframework.boot.actuate.autoconfigure.endpoint.web.WebEndpointProperties,org.springframework.boot.actuate.autoconfigure.env.EnvironmentEndpointAutoConfiguration,environmentEndpoint,environmentEndpointWebExtension,management.endpoint.env-org.springframework.boot.actuate.autoconfigure.env.EnvironmentEndpointProperties,org.springframework.boot.actuate.autoconfigure.system.DiskSpaceHealthContributorAutoConfiguration,diskSpaceHealthIndicator,management.health.diskspace-org.springframework.boot.actuate.autoconfigure.system.DiskSpaceHealthIndicatorProperties,org.springframework.boot.actuate.autoconfigure.health.HealthContributorAutoConfiguration,pingHealthContributor,org.springframework.boot.actuate.autoconfigure.logging.LogFileWebEndpointAutoConfiguration,management.endpoint.logfile-org.springframework.boot.actuate.autoconfigure.logging.LogFileWebEndpointProperties,org.springframework.boot.actuate.autoconfigure.logging.LoggersEndpointAutoConfiguration,loggersEndpoint,org.springframework.boot.actuate.autoconfigure.management.HeapDumpWebEndpointAutoConfiguration,heapDumpWebEndpoint,org.springframework.boot.actuate.autoconfigure.management.ThreadDumpEndpointAutoConfiguration,dumpEndpoint,org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration,micrometerClock,meterRegistryPostProcessor,propertiesMeterFilter,management.metrics-org.springframework.boot.actuate.autoconfigure.metrics.MetricsProperties,org.springframework.boot.actuate.autoconfigure.metrics.export.prometheus.PrometheusMetricsExportAutoConfiguration$PrometheusScrapeEndpointConfiguration,prometheusEndpoint,org.springframework.boot.actuate.autoconfigure.metrics.export.prometheus.PrometheusMetricsExportAutoConfiguration,prometheusConfig,prometheusMeterRegistry,collectorRegistry,management.metrics.export.prometheus-org.springframework.boot.actuate.autoconfigure.metrics.export.prometheus.PrometheusProperties,org.springframework.boot.actuate.autoconfigure.metrics.CompositeMeterRegistryAutoConfiguration,org.springframework.boot.actuate.autoconfigure.metrics.JvmMetricsAutoConfiguration,jvmGcMetrics,jvmHeapPressureMetrics,jvmMemoryMetrics,jvmThreadMetrics,classLoaderMetrics,org.springframework.boot.actuate.autoconfigure.metrics.KafkaMetricsAutoConfiguration$KafkaStreamsMetricsConfiguration,kafkaStreamsMetrics,org.springframework.boot.actuate.autoconfigure.metrics.KafkaMetricsAutoConfiguration,kafkaProducerMetrics,kafkaConsumerMetrics,org.springframework.boot.actuate.autoconfigure.metrics.Log4J2MetricsAutoConfiguration,log4j2Metrics,org.springframework.boot.actuate.autoconfigure.metrics.MetricsEndpointAutoConfiguration,metricsEndpoint,org.springframework.boot.actuate.autoconfigure.metrics.SystemMetricsAutoConfiguration,uptimeMetrics,processorMetrics,fileDescriptorMetrics,diskSpaceMetrics,org.springframework.boot.actuate.autoconfigure.metrics.integration.IntegrationMetricsAutoConfiguration,org.springframework.boot.actuate.autoconfigure.metrics.startup.StartupTimeMetricsListenerAutoConfiguration,startupTimeMetrics,org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,taskScheduler,scheduledBeanLazyInitializationExcludeFilter,taskSchedulerBuilder,spring.task.scheduling-org.springframework.boot.autoconfigure.task.TaskSchedulingProperties,org.springframework.boot.actuate.autoconfigure.metrics.task.TaskExecutorMetricsAutoConfiguration,org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,gsonBuilder,gson,standardGsonBuilderCustomizer,spring.gson-org.springframework.boot.autoconfigure.gson.GsonProperties,org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration$StringHttpMessageConverterConfiguration,stringHttpMessageConverter,org.springframework.boot.autoconfigure.http.JacksonHttpMessageConvertersConfiguration$MappingJackson2HttpMessageConverterConfiguration,mappingJackson2HttpMessageConverter,org.springframework.boot.autoconfigure.http.JacksonHttpMessageConvertersConfiguration,org.springframework.boot.autoconfigure.http.GsonHttpMessageConvertersConfiguration,org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,messageConverters,org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,restTemplateBuilderConfigurer,restTemplateBuilder,org.springframework.boot.actuate.autoconfigure.metrics.web.client.RestTemplateMetricsConfiguration,restTemplateExchangeTagsProvider,metricsRestTemplateCustomizer,org.springframework.boot.actuate.autoconfigure.metrics.web.client.HttpClientMetricsAutoConfiguration,metricsHttpClientUriTagFilter,org.springframework.boot.actuate.autoconfigure.metrics.web.servlet.WebMvcMetricsAutoConfiguration,webMvcTagsProvider,webMvcMetricsFilter,metricsHttpServerUriTagFilter,metricsWebMvcConfigurer,org.springframework.boot.actuate.autoconfigure.scheduling.ScheduledTasksEndpointAutoConfiguration,scheduledTasksEndpoint,org.springframework.boot.actuate.autoconfigure.trace.http.HttpTraceAutoConfiguration$ServletTraceFilterConfiguration,httpTraceFilter,org.springframework.boot.actuate.autoconfigure.trace.http.HttpTraceAutoConfiguration,httpExchangeTracer,management.trace.http-org.springframework.boot.actuate.autoconfigure.trace.http.HttpTraceProperties,org.springframework.boot.actuate.autoconfigure.trace.http.HttpTraceEndpointAutoConfiguration,httpTraceEndpoint,org.springframework.boot.actuate.autoconfigure.web.mappings.MappingsEndpointAutoConfiguration$ServletWebConfiguration$SpringMvcConfiguration,dispatcherServletMappingDescriptionProvider,org.springframework.boot.actuate.autoconfigure.web.mappings.MappingsEndpointAutoConfiguration$ServletWebConfiguration,servletMappingDescriptionProvider,filterMappingDescriptionProvider,org.springframework.boot.actuate.autoconfigure.web.mappings.MappingsEndpointAutoConfiguration,mappingsEndpoint,org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,springApplicationAdminRegistrar,org.springframework.boot.autoconfigure.aop.AopAutoConfiguration$ClassProxyingConfiguration,forceAutoProxyCreatorToUseClassProxying,org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,lifecycleProcessor,spring.lifecycle-org.springframework.boot.autoconfigure.context.LifecycleProperties,org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,persistenceExceptionTranslationPostProcessor,org.springframework.boot.autoconfigure.kafka.KafkaAnnotationDrivenConfiguration,kafkaListenerContainerFactoryConfigurer,org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,kafkaTemplate,kafkaProducerListener,kafkaProducerFactory,kafkaAdmin,spring.kafka-org.springframework.boot.autoconfigure.kafka.KafkaProperties,org.springframework.boot.autoconfigure.netty.NettyAutoConfiguration,spring.netty-org.springframework.boot.autoconfigure.netty.NettyProperties,org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration,spring.sql.init-org.springframework.boot.autoconfigure.sql.init.SqlInitializationProperties,org.springframework.boot.sql.init.dependency.DatabaseInitializationDependencyConfigurer$DependsOnDatabaseInitializationPostProcessor,org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,platformTransactionManagerCustomizers,spring.transaction-org.springframework.boot.autoconfigure.transaction.TransactionProperties,org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration$UndertowWebServerFactoryCustomizerConfiguration,undertowWebServerFactoryCustomizer,org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,characterEncodingFilter,localeCharsetMappingsCustomizer,org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,multipartConfigElement,multipartResolver,spring.servlet.multipart-org.springframework.boot.autoconfigure.web.servlet.MultipartProperties,org.springframework.boot.devtools.autoconfigure.LocalDevToolsAutoConfiguration$RestartConfiguration,restartingClassPathChangedEventListener,classPathFileSystemWatcher,classPathRestartStrategy,fileSystemWatcherFactory,conditionEvaluationDeltaLoggingListener,org.springframework.boot.devtools.autoconfigure.LocalDevToolsAutoConfiguration$LiveReloadConfiguration,liveReloadServer,optionalLiveReloadServer,liveReloadServerEventListener,org.springframework.boot.devtools.autoconfigure.LocalDevToolsAutoConfiguration,spring.devtools-org.springframework.boot.devtools.autoconfigure.DevToolsProperties,org.springframework.boot.actuate.autoconfigure.endpoint.web.ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration,servletEndpointRegistrar,org.springfraorg.springframework.boot.actuate.autoconfigure.endpoint.web.CorsEndpointProperties,org.springframework.boot.actuate.autoconfigure.web.server.ManagementContextAutoConfiguration$SameManagementContextConfiguration$EnableSameManagementContextConfiguration,org.springframework.boot.actuate.autoconfigure.web.server.ManagementContextAutoConfiguration$SameManagementContextConfiguration,org.springframework.boot.actuate.autoconfigure.web.server.ManagementContextAutoConfiguration,management.server-org.springframework.boot.actuate.autoconfigure.web.server.ManagementServerProperties,org.springframework.aop.config.internalAutoProxyCreator]; root of factory hierarchy\r\n\r\n[TRACE] 2023-05-25 14:26:09.454 [restartedMain] DisposableBeanAdapter DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:202) -- -- - Invoking destroy() on bean with name 'characterEncodingFilter'\r\n\r\n[TRACE] 2023-05-25 14:26:09.454 [restartedMain] DisposableBeanAdapter DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:202) -- -- - Invoking destroy() on bean with name 'httpTraceFilter'\r\n\r\n[TRACE] 2023-05-25 14:26:09.455 [restartedMain] DisposableBeanAdapter DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:202) -- -- - Invoking destroy() on bean with name 'formContentFilter'\r\n\r\n[TRACE] 2023-05-25 14:26:09.455 [restartedMain] DisposableBeanAdapter DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:202) -- -- - Invoking destroy() on bean with name 'requestContextFilter'\r\n\r\n[TRACE] 2023-05-25 14:26:09.456 [restartedMain] DefaultListableBeanFactory DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:577) -- -- - Retrieved dependent beans for bean 'prometheusMeterRegistry': [webMvcMetricsFilter]\r\n\r\n[TRACE] 2023-05-25 14:26:09.456 [restartedMain] DisposableBeanAdapter DisposableBeanAdapter.invokeCustomDestroyMethod(DisposableBeanAdapter.java:299) -- -- - Invoking custom destroy method 'close' on bean with name 'prometheusMeterRegistry'\r\n\r\n[TRACE] 2023-05-25 14:26:09.456 [restartedMain] DisposableBeanAdapter DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:228) -- -- - Invoking close() on bean with name 'log4j2Metrics'\r\n\r\n[TRACE] 2023-05-25 14:26:09.470 [restartedMain] DisposableBeanAdapter DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:228) -- -- - Invoking close() on bean with name 'jvmHeapPressureMetrics'\r\n\r\n[TRACE] 2023-05-25 14:26:09.471 [restartedMain] DisposableBeanAdapter DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:228) -- -- - Invoking close() on bean with name 'jvmGcMetrics'\r\n\r\n[TRACE] 2023-05-25 14:26:09.471 [restartedMain] DisposableBeanAdapter DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:202) -- -- - Invoking destroy() on bean with name 'org.springframework.context.annotation.internalScheduledAnnotationProcessor'\r\n\r\n[TRACE] 2023-05-25 14:26:09.472 [restartedMain] DefaultListableBeanFactory DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:577) -- -- - Retrieved dependent beans for bean 'org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory': [org.springframework.context.annotation.internalConfigurationAnnotationProcessor]\r\n\r\n[DEBUG] 2023-05-25 14:26:09.492 [restartedMain] Restarter DeferredLog.logTo(DeferredLog.java:252) -- -- - Creating new Restarter for thread Thread[main,5,main]\r\n\r\n[DEBUG] 2023-05-25 14:26:09.493 [restartedMain] Restarter DeferredLog.logTo(DeferredLog.java:252) -- -- - Immediately restarting application\r\n\r\n[DEBUG] 2023-05-25 14:26:09.528 [restartedMain] ConditionEvaluationReportLoggingListener ConditionEvaluationReportLoggingListener.logAutoConfigurationReport(ConditionEvaluationReportLoggingListener.java:126) -- -- -\r\n```"
      },
      {
        "user": "anand0761",
        "created_at": "2023-05-25T10:14:05Z",
        "body": "```\r\nConfig config = new Config();\r\nconfig.useClusterServers()\r\n.addNodeAddress(\"redis://clustercfg.test.amazonaws.com:6379\")\r\n.setUsername(\"user-name\")\r\n.setPassword(\"1234\")\r\n.setSslEnableEndpointIdentification(false);\r\n\r\nreturn Redisson.create(config);\r\n```\r\n\r\n@mrniko Please find above logs and code"
      },
      {
        "user": "mrniko",
        "created_at": "2023-05-25T12:37:52Z",
        "body": "The problem might be in `--insecure` option. Unfortunately, I don't know how redis-cli implements it"
      },
      {
        "user": "anand0761",
        "created_at": "2023-05-26T09:59:59Z",
        "body": "@mrniko We are able to establish the connect now using below code, the only changes we did is changed the address string from `redis` to `rediss`\r\n\r\n```\r\n            config.useSingleServer()\r\n                    .setAddress(\"rediss://clustercfg.test.amazonaws.com:6379\")\r\n                    .setUsername(\"uname\")\r\n                    .setPassword(\"pwd\");\r\n```"
      }
    ]
  },
  {
    "number": 5037,
    "title": "StacklessClosedChannelException: null",
    "created_at": "2023-05-15T03:03:41Z",
    "closed_at": "2023-06-29T05:58:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5037",
    "body": "redisson version:3.20.0\r\ndemo code:\r\n\r\n```\r\n@Scheduled(fixedRate = 10*1000)\r\n    public void test() {\r\n        RLock lock = RedisConfigManager.getRedisson().getLock(\"redissonbugtest\");\r\n        try {\r\n            lock.lock(1, TimeUnit.MINUTES);\r\n            System.out.println(new Date().toString());\r\n            Thread.sleep(1500);\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(e);\r\n        }catch (Exception e) {\r\n            logger.error(\"lock:unlock {} failed.\", \"redissonbugtest\", e);\r\n        }finally {\r\n            lock.unlock();\r\n        }\r\n    } \r\n```\r\n\r\n```\r\npublic class RedisConfigManager {\r\n    private static Redisson redisson;\r\n    public static Redisson getRedisson(){\r\n        if (redisson==null){\r\n            synchronized (RedisConfigManager.class){\r\n                if (redisson==null){\r\n                    Config config = new Config();\r\n                    BaseConfig baseConfig;\r\n                    baseConfig = config.setCodec(JsonJacksonCodec.INSTANCE)\r\n                            .useClusterServers().addNodeAddress(\r\n                        \"redis://172.21.75.153:6379\",\r\n                        \"redis://172.21.75.154:6379\",\r\n                        \"redis://172.21.75.155:6379\",\r\n                        \"redis://172.21.75.156:6379\",\r\n                        \"redis://172.21.75.157:6379\",\r\n                        \"redis://172.21.75.158:6379\"\r\n                            )\r\n                            .setMasterConnectionPoolSize(64) //主节点连接池大小,默认为64\r\n                            .setMasterConnectionMinimumIdleSize(24) //主节点最小空闲连接数,默认24\r\n                            .setSlaveConnectionPoolSize(64) //从节点连接池大小,默认为64\r\n                            .setSlaveConnectionMinimumIdleSize(24) //从节点最小空闲连接数,默认24\r\n                            .setSubscriptionConnectionPoolSize(50) //发布和订阅连接池大小,默认50\r\n                            .setSubscriptionConnectionMinimumIdleSize(1) //发布和订阅连接的最小空闲连接数,默认为1\r\n                            .setReadMode(ReadMode.SLAVE)//读取操作的负载均衡模式\r\n                            .setScanInterval(2000);//对主节点变化节点状态扫描的时间间隔,单位毫秒\r\n\r\n        String password = \"xxx\";\r\n            baseConfig.setPassword(password);\r\n                    baseConfig.setTimeout(3000)//命令等待超时,单位毫秒\r\n                            .setRetryAttempts(3)//命令失败重试次数\r\n                            .setRetryInterval(1000)//命令重试发送时间间隔,单位毫秒\r\n                            //**此项务必设置.为解决redisson bug(timeout问题)的关键*****\r\n                            .setPingConnectionInterval(1000);\r\n                    //得到redisson对象\r\n                    redisson = (Redisson) Redisson.create(config);\r\n                }\r\n            }\r\n        }\r\n        return redisson;\r\n    }\r\n}\r\n```\r\nerrorlog:\r\n\r\n```\r\n2023-05-13 13:38:49.126 ERROR 516 --- [   scheduling-1] com.example.demo.redissonbug.Schedule    : lock:unlock redissonbugtest failed.\r\norg.redisson.client.WriteRedisConnectionException: Unable to write command into connection! Increase connection pool size. Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=23, freeConnectionsCounter=value:63:queue:0, freezeReason=null, client=[addr=redis://172.21.75.155:6379], nodeType=MASTER, firstFail=1683949780778]]], connection: RedisConnection@724415973 [redisClient=[addr=redis://172.21.75.155:6379], channel=[id: 0x66dc9cb0, L:/172.21.21.20:5694 ! R:172.21.75.155/172.21.75.155:6379], currentCommand=null, usage=1], command: (INFO REPLICATION), params: [] after 3 retry attempts\r\n\tat org.redisson.command.RedisExecutor.checkWriteFuture(RedisExecutor.java:342) ~[redisson-3.20.0.jar:3.20.0]\r\n\tat org.redisson.command.RedisExecutor.lambda$execute$3(RedisExecutor.java:186) ~[redisson-3.20.0.jar:3.20.0]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1021) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:882) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute$$$capture(AbstractEventExecutor.java:164) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]\r\n\tat java.lang.Thread.run(Thread.java:750) ~[na:1.8.0_361]\r\nCaused by: io.netty.channel.StacklessClosedChannelException: null\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]\r\n\r\n2023-05-13 13:38:52.422 ERROR 516 --- [   scheduling-1] o.s.s.s.TaskUtils$LoggingErrorHandler    : Unexpected error occurred in scheduled task\r\n\r\norg.redisson.client.RedisException: Unexpected exception while processing command\r\n\tat org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:283) ~[redisson-3.20.0.jar:3.20.0]\r\n\tat org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:118) ~[redisson-3.20.0.jar:3.20.0]\r\n\tat org.redisson.RedissonObject.get(RedissonObject.java:83) ~[redisson-3.20.0.jar:3.20.0]\r\n\tat org.redisson.RedissonBaseLock.unlock(RedissonBaseLock.java:347) ~[redisson-3.20.0.jar:3.20.0]\r\n\tat com.example.demo.redissonbug.Schedule.test(Schedule.java:39) ~[classes/:na]\r\n\tat sun.reflect.GeneratedMethodAccessor29.invoke(Unknown Source) ~[na:na]\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_361]\r\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_361]\r\n\tat org.springframework.scheduling.support.ScheduledMethodRunnable.run(ScheduledMethodRunnable.java:84) ~[spring-context-5.2.15.RELEASE.jar:5.2.15.RELEASE]\r\n\tat org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54) ~[spring-context-5.2.15.RELEASE.jar:5.2.15.RELEASE]\r\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [na:1.8.0_361]\r\n\tat java.util.concurrent.FutureTask.runAndReset$$$capture(FutureTask.java:308) [na:1.8.0_361]\r\n\tat java.util.concurrent.FutureTask.runAndReset(FutureTask.java) [na:1.8.0_361]\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180) [na:1.8.0_361]\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294) [na:1.8.0_361]\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_361]\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_361]\r\n\tat java.lang.Thread.run(Thread.java:750) [na:1.8.0_361]\r\n\r\n```\r\n\r\nThe above is sample code, which means the same as the code I ran online.\r\nThis issue is not easy to reproduce and needs to be continuously run for a while before it can be reproduced. Once a problem occurs, the connection cannot be automatically restored unless the app is restarted.\r\n\r\nThere are a lot of people asking this question, you guys ask to increase the number of connections or set the retry interval, but I have a lot of connections and the retry interval is low.PingConnectionInterval is low too.\r\n\r\nPlease help me see how to solve the problem",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5037/comments",
    "author": "MeloFocus",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-05-15T13:15:47Z",
        "body": "Unable to reproduce.\r\n\r\nAccording to your code this issue arise with lock object usage only. Did you check the network?\r\n\r\nCan you set `trace` logging level for `org.redisson` package and share the log output with reproduced issue?"
      }
    ]
  },
  {
    "number": 5036,
    "title": "Is there a way to delete `BinaryStream` in a batch operation?",
    "created_at": "2023-05-14T13:39:24Z",
    "closed_at": "2023-05-14T13:52:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5036",
    "body": "I'm trying to do something like this:\r\n```\r\nfinal RBatchRx batch = rxClient.createBatch();\r\nfinal var deleteMapOp = batch.getMap(\"map1\").delete().ignoreElement();\r\nfinal var deleteStreamOp = batch.getBinaryStream(\"blob1\").delete().ignoreElement();\r\n...\r\n```\r\nBut it looks like `RBatchRx` is missing `getBinaryStream()` method (or anything similar).\r\nIs it not implemented or is there another way to do that?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5036/comments",
    "author": "sergiy-sc",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-05-14T13:52:09Z",
        "body": "RBinaryStream interface doesn't contain reactive compatible methods. You can use `RBucket<byte[]>` instead."
      }
    ]
  },
  {
    "number": 5032,
    "title": "Difference in storing data with RMapCache",
    "created_at": "2023-05-11T17:23:10Z",
    "closed_at": "2023-06-29T05:57:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5032",
    "body": "Currently using the free version of Redisson 3.15.4.\r\nMy config is as follows:\r\n\r\n```\r\nConfig config = new Config();\r\nconfig.setCodec(new JsonJacksonCodec(jackson2ObjectMapperBuilder.build()));\r\nconfig.useSingleServer().setAddress(\"rediss://host:port\").setPassword(pwd);\r\n```\r\n\r\nI am using RLocalCacheMap and RMapCache for a different caches. \r\nI wanted to store the data as Json but I wanted to remove the reference to the package as \"@class\" field and so I used the TypedJsonJacksonCodec. \r\nThis works perfectly fine while using with RLocalCacheMap and I am able to see the redis data as json key and value.\r\n\r\nHowever when I use the same with RMapCache, I see additional hexadecimal data added in front of the data in the value. This then isn't read properly as per the type and I get an exception while reading or writing this data.\r\n\r\n```\r\nCaused by: java.lang.IllegalArgumentException: Cannot deserialize Class com.example.demo.CacheConfig$1 (of type local/anonymous) as a Bean\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.isPotentialBeanType(BeanDeserializerFactory.java:883)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:137)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:414)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:349)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)\r\n```\r\n\r\nExample of data in Redis for RMapCache:\r\n`\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x19\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"2023-05-11T22:30:18.961\"`\r\n\r\nIn the above case, even though its just a string, the hex data is appended at the start.\r\n\r\nIs this expected for RMapCache and how to overcome this and get the data without the Hex values.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5032/comments",
    "author": "dalaiRama06",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-05-11T17:25:08Z",
        "body": "RMapCache stores extra data to track idle timeout of entry."
      },
      {
        "user": "dalaiRama06",
        "created_at": "2023-05-11T17:27:11Z",
        "body": "Does this mean I will not be able to use it along with the TypedJsonJacksonCodec(CustomKey.class, CustomValue.class) or do I need to add some changes to make it work?"
      },
      {
        "user": "mrniko",
        "created_at": "2023-05-18T07:40:29Z",
        "body": "Can you share the code to reproduce the issue?"
      },
      {
        "user": "dalaiRama06",
        "created_at": "2023-05-25T06:10:53Z",
        "body": "`\r\n@Bean(name = CUSTOM_CACHE_KEY)\r\npublic RMapCache<CustomKey, CustomeValue> getCustomCache() {\r\n    return redisson.getMapCache(KEY_NAME, new TypedJsonJacksonCodec(CustomKey.class, CustomValue.class));\r\n}\r\n`\r\n    \r\nThis is the current code I am using. Do I also need to some options along with these"
      },
      {
        "user": "mrniko",
        "created_at": "2023-06-29T05:57:57Z",
        "body": "Unable to reproduce the issue with the code below\r\n\r\n```java\r\n        RMapCache<Test1, Test2> mapCache = redisson.getMapCache(\"test\", new TypedJsonJacksonCodec(Test1.class, Test2.class));\r\n        Test2 t2 = new Test2();\r\n        t2.setVal(\"t2\");\r\n        Test1 t1 = new Test1();\r\n        t1.setValue(\"t1\");\r\n        mapCache.put(t1, t2);\r\n        Test2 t = mapCache.get(t1);\r\n        assertThat(t.getVal()).isEqualTo(\"t2\");\r\n```"
      }
    ]
  },
  {
    "number": 5028,
    "title": "We are using the redis version 3.17.4 and we are getting the below error, could you please check this?",
    "created_at": "2023-05-11T08:14:36Z",
    "closed_at": "2023-05-12T06:32:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5028",
    "body": "I am getting this below error randomly while trying to fetch with a string key. (Sample String Key: C3V23748167269J)\r\n\r\nCaused by: com.fasterxml.jackson.core.JsonParseException: Illegal character ((CTRL-CHAR, code 3)): only regular white space (\\r, \\n, \\t) is allowed between tokens\r\n at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 2]\r\n        at com.fasterxml.jackson.core.JsonParser._constructError(JsonParser.java:2391) ~[jackson-core-2.13.3.jar:2.13.3]\r\n        at com.fasterxml.jackson.core.base.ParserMinimalBase._reportError(ParserMinimalBase.java:735) ~[jackson-core-2.13.3.jar:2.13.3]\r\n        at com.fasterxml.jackson.core.base.ParserMinimalBase._throwInvalidSpace(ParserMinimalBase.java:713) ~[jackson-core-2.13.3.jar:2.13.3]\r\n        at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._skipWSOrEnd(UTF8StreamJsonParser.java:3057) ~[jackson-core-2.13.3.jar:2.13.3]\r\n        at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextToken(UTF8StreamJsonParser.java:756) ~[jackson-core-2.13.3.jar:2.13.3]\r\n        at com.fasterxml.jackson.databind.ObjectMapper._initForReading(ObjectMapper.java:4129) ~[jackson-databind-2.9.5.jar:2.9.5]\r\n        at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3988) ~[jackson-databind-2.9.5.jar:2.9.5]\r\n        at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3058) ~[jackson-databind-2.9.5.jar:2.9.5]\r\n        at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:99) ~[redisson-3.17.4.jar:3.17.4]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:383) ~[redisson-3.17.4.jar:3.17.4]\r\n        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198) ~[redisson-3.17.4.jar:3.17.4]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137) ~[redisson-3.17.4.jar:3.17.4]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113) ~[redisson-3.17.4.jar:3.17.4]\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:529) ~[netty-codec-4.1.86.Final.jar:4.1.86.Final]\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.86.Final.jar:4.1.86.Final]\r\n        ... 17 more\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5028/comments",
    "author": "nivitha16",
    "comments": [
      {
        "user": "nivitha16",
        "created_at": "2023-05-12T03:04:27Z",
        "body": " @mrniko can you check this issue?"
      },
      {
        "user": "mrniko",
        "created_at": "2023-05-12T06:32:37Z",
        "body": "Sorry, I can't reproduce it locally. It can be caused by trying to read data encoded with a different codec"
      },
      {
        "user": "qwqeq",
        "created_at": "2023-09-21T09:27:41Z",
        "body": "We used RedissonBlockingQueue in our project. This error occurred when we updated the production environment. However, we tried to reproduce this problem locally, but it never occurred. So can you guys try to analyze the possible causes of the problem?"
      }
    ]
  },
  {
    "number": 5013,
    "title": "Redisson Pro initializing without key for unit tests",
    "created_at": "2023-05-03T17:28:05Z",
    "closed_at": "2023-05-03T17:30:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5013",
    "body": "We are intending to use the Redisson Pro license for running sharded elastic cache cluster. For unit tests and other dev environment we prefer avoiding the pro version redissonclient instance which requires a key. Is there a way to construct a redisson client with the pro license for this purpose? \r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5013/comments",
    "author": "formanojhr",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-05-03T17:30:41Z",
        "body": "Please contact sales@redisson.pro"
      }
    ]
  },
  {
    "number": 5009,
    "title": "RedissonLocalCachedMap.clear sometimes doesn't clear immediately",
    "created_at": "2023-05-02T18:58:10Z",
    "closed_at": "2023-05-11T12:53:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5009",
    "body": "I'm facing a problem where I clear redis but somehow it is not empty when I access it shortly after:\r\n\r\n```\r\nRedissonLocalCachedMap redis;\r\nredis.clear();\r\nredis.clearLocalCache();\r\nList result = redis.get(\"key\"); // result is usually empty but sometimes not empty\r\n```\r\nDoes calling `.clear()` guarantee that subsequent call to `.get()` will return empty result?\r\nIf so, then what could be the cause of this issue?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5009/comments",
    "author": "saeidN",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-05-03T05:52:18Z",
        "body": "after `clearLocalCache` local cache should be cleared on all instances.\r\n\r\nUnable to reproduce.\r\n\r\n```java\r\n        RLocalCachedMap<String, String> localCachedMap = redisson.getLocalCachedMap(\"udi-test\",\r\n                LocalCachedMapOptions.defaults());\r\n        for (int i = 0; i < 100; i++) {\r\n            localCachedMap.put(\"1\", \"2\");\r\n            localCachedMap.clear();\r\n            localCachedMap.clearLocalCache();\r\n            String v = localCachedMap.get(\"1\");\r\n            assertThat(v).isNull();\r\n        }\r\n```"
      },
      {
        "user": "saeidN",
        "created_at": "2023-05-03T13:07:15Z",
        "body": "Thanks @mrniko \r\nYes it's difficult to reproduce it locally. In our case it only occurs when multiple servers make calls to redis at same time.\r\nQuestion: What will happen if one server calls `.clear()` and another server calls `.put(\"1\", \"2\")` at same time. Is there some sort of locking to prevent them from running at same time. Or is the behavior undefined in this case?"
      },
      {
        "user": "mrniko",
        "created_at": "2023-05-11T12:53:25Z",
        "body": "> What will happen if one server calls .clear() and another server calls .put(\"1\", \"2\") at same time.\r\n\r\nIn this case of course you can get data inserted right after put method call since they aren't synchronized. You can try to use RLock object to do it. "
      }
    ]
  },
  {
    "number": 4996,
    "title": "Even after updating the version to 3.19.3 we are still getting the below error, could you please check this? Thanks. ",
    "created_at": "2023-04-27T08:20:54Z",
    "closed_at": "2023-05-02T07:24:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4996",
    "body": "ERROR org.redisson.connection.DNSMonitor - Unable to resolve Redis URL\r\nio.netty.resolver.dns.DnsResolveContext$SearchDomainUnknownHostException: Failed to resolve 'Redis-URL' and search domain query for configured domains failed as well: [us-west-2.compute.internal]\r\nat io.netty.resolver.dns.DnsResolveContext.finishResolve(DnsResolveContext.java:1069)\r\nat io.netty.resolver.dns.DnsResolveContext.tryToFinishResolve(DnsResolveContext.java:1022)\r\nat io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:418)\r\nat io.netty.resolver.dns.DnsResolveContext.access$600(DnsResolveContext.java:66)\r\nat io.netty.resolver.dns.DnsResolveContext$2.operationComplete(DnsResolveContext.java:489)\r\nat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:590)\r\nat io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:583)\r\nat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:559)\r\nat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:492)\r\nat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:636)\r\nat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:629)\r\nat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:118)\r\nat io.netty.resolver.dns.DnsQueryContext.tryFailure(DnsQueryContext.java:256)\r\nat io.netty.resolver.dns.DnsQueryContext$4.run(DnsQueryContext.java:208)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4996/comments",
    "author": "sakethbalijepalli",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-04-27T08:51:59Z",
        "body": "Try to define SequentialDnsAddressResolverFactory with concurrencyLevel = 4\r\n\r\nYaml config example:\r\n\r\n```yaml\r\nsingleServerConfig:\r\n  address: \"redis://127.0.0.1:6311\"\r\naddressResolverGroupFactory: !<org.redisson.connection.SequentialDnsAddressResolverFactory> 4\r\n```"
      },
      {
        "user": "sakethbalijepalli",
        "created_at": "2023-04-27T09:15:35Z",
        "body": ".setAddressResolverGroupFactory(new SequentialDnsAddressResolverFactory(4) \r\nSo this? "
      },
      {
        "user": "mrniko",
        "created_at": "2023-04-27T09:18:16Z",
        "body": "yes"
      },
      {
        "user": "sakethbalijepalli",
        "created_at": "2023-04-27T10:18:47Z",
        "body": "Thanks. Will try and let you know. "
      },
      {
        "user": "sakethbalijepalli",
        "created_at": "2023-04-28T05:58:03Z",
        "body": "Even after adding the setter we are still getting the same issue. @mrniko "
      },
      {
        "user": "sakethbalijepalli",
        "created_at": "2023-04-28T05:59:53Z",
        "body": "@Bean(name = \"redissonClient\", destroyMethod = \"shutdown\")\npublic RedissonClient redisClient() {\nConfig config = new Config();\nconfig.setNettyThreads(64).setAddressResolverGroupFactory(new SequentialDnsAddressResolverFactory(4))\n.useSingleServer().setAddress(env.getProperty(\"redis.url\"))\n.setRetryAttempts(1).setConnectionPoolSize(64).setKeepAlive(true).setPingConnectionInterval(45000);\nreturn Redisson.create(config);\n}\n\nThis is the bean config we have. "
      },
      {
        "user": "mrniko",
        "created_at": "2023-04-28T06:41:32Z",
        "body": "try SequentialDnsAddressResolverFactory with concurrencyLevel 1 or 2"
      },
      {
        "user": "mrniko",
        "created_at": "2023-04-28T07:39:57Z",
        "body": "Also check if us-west-2.compute.internal is really can be resolved"
      },
      {
        "user": "sakethbalijepalli",
        "created_at": "2023-04-28T07:43:40Z",
        "body": "Sure. "
      }
    ]
  },
  {
    "number": 4988,
    "title": "RedisBusyException when running load tests",
    "created_at": "2023-04-25T00:21:31Z",
    "closed_at": "2023-05-02T07:27:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4988",
    "body": "```\r\n`\r\nWARN  [2023-04-25 00:10:45,507] org.redisson.client.RedisBusyException: BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.. channel: [id: 0x99c796a7, L:/10.240.0.18:34142 - R:10.240.0.74/10.240.0.74:6379] data: CommandData [promise=java.util.concurrent.CompletableFuture@51438d95[Not completed, 1 dependents], command=(EVAL), params=[local currentTime = tonumber(table.remove(ARGV, 1)); local ttl = table.remove(ARGV, 1); local ttlNumber = tonumber(ttl); local maxSize = tonumber(redis.call('hget', KEYS[8], 'max-size'));local mode = redis.call('hget', KEYS[8], 'mode'); for i, value in ipairs(ARGV) do if i % 2 == 0 then local key = ARGV[i-1];local v = redis.call('hget', KEYS[1], key);local exists = false;if v ~= false then    local t, val = struct.unpack('dLc0', v);    local expireDate = 92233720368547758;    local expireDateScore = redis.call('zscore', KEYS[2], key);    if expireDateScore ~= false then        expireDate = tonumber(expireDateScore)    end;    if t ~= 0 then        local expireIdle = redis.call('zscore', KEYS[3], key);        if expireIdle ~= false then            expireDate = math.min(expireDate, tonumber(expireIdle))        end;    end;    if expireDate > tonumber(currentTime) then        exists = true;    end;end;if ttlNumber > 0 then     redis.call('zadd', KEYS[2], ttl, key); else     redis.call('zr..., 8, mht_collector, redisson__timeout__set:{mht_collector}, redisson__idle__set:{mht_collector}, redisson_map_cache_created:{mht_collector}, redisson_map_cache_updated:{mht_collector}, redisson__map_cache__last_access__set:{mht_collector}, redisson_map_cache_removed:{mht_collector}, {mht_collector}:redisson_options, ...], codec=org.redisson.codec.SerializationCodec]`\r\n```\r\n\r\nWe seem to get these RedisBusyExceptions at some point whenever we run load tests. On elastic cache side of things we have enough memory and CPU. So we are not bottlenecked by those. Our only doubt is network bandwidth. Any idea for what reasons this exception gets thrown?  \r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4988/comments",
    "author": "formanojhr",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-05-02T07:27:25Z",
        "body": "You need to run redis slowlog command to realize which script is running too slow."
      },
      {
        "user": "formanojhr",
        "created_at": "2023-05-02T19:19:10Z",
        "body": "thanks @mrniko  that is exactly what we did. Might be good to add to your general documentation"
      }
    ]
  },
  {
    "number": 4980,
    "title": "RlocalcacheMap Behaviour",
    "created_at": "2023-04-21T09:21:31Z",
    "closed_at": "2023-07-04T08:48:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4980",
    "body": "Hi, \r\nCould you please explain more on the LocalCachedMapOptions.StoreMode options(LOCALCACHE_REDIS,LOCALCACHE),\r\n\r\nI have tried using these two options with multiple instance of JVMs(different pods). LOCALCACHE_REDIS mode is working for read, write, delete options from  multiple Jvms but with LOCALCACHE  write/read from multiple JVMs is not working.  \r\n\r\nCould please also confirm that LOCALCACHE_REDIS always read from Redis or it look first in local JVM before fetching from Redis \r\n\r\nBelow is code which I trying to write from one JVM and read from another JVM.\r\n\r\n`   \r\n private LocalCachedMapOptions options = LocalCachedMapOptions.defaults()\r\n            .cacheProvider(LocalCachedMapOptions.CacheProvider.REDISSON)\r\n            .evictionPolicy(LocalCachedMapOptions.EvictionPolicy.SOFT)\r\n            .reconnectionStrategy(LocalCachedMapOptions.ReconnectionStrategy.LOAD)\r\n            .syncStrategy(LocalCachedMapOptions.SyncStrategy.INVALIDATE)\r\n            .storeMode(LocalCachedMapOptions.StoreMode.LOCALCACHE_REDIS);\r\n            `\r\n\r\n\r\n    public String getLocalData(String key) {\r\n\r\n        RLocalCachedMap localCachedMap =  redisson.getLocalCachedMap(\"Test-Appcache\",options);\r\n\r\n        localCachedMap.get(key);\r\n\r\n        return (String) localCachedMap.get(key);\r\n\r\n\r\n    }\r\n\r\n    public String writeLocalData(String key) {\r\n\r\n        RLocalCachedMap localCachedMap =  redisson.getLocalCachedMap(\"Test-Appcache\",options);\r\n\r\n        localCachedMap.put(key,key+\"-value\");\r\n\r\n        return (String) localCachedMap.get(key);\r\n\r\n    }\r\n\r\n    public void deleteLocalData(String key) {\r\n\r\n        RLocalCachedMap localCachedMap =  redisson.getLocalCachedMap(\"Test-Appcache\",options);\r\n\r\n        localCachedMap.remove(key);\r\n\r\n\r\n\r\n    }\r\n            `",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4980/comments",
    "author": "amarendrar",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-07-04T08:48:25Z",
        "body": "LOCALCACHE mode doesn't store data in Redis."
      }
    ]
  },
  {
    "number": 4975,
    "title": "Why does Redisson's lock not support cross-thread addition and unlocking?",
    "created_at": "2023-04-20T06:20:41Z",
    "closed_at": "2023-04-20T07:29:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4975",
    "body": "Among Redisson's various distributed locks, why not support the case of A thread locking and B thread unlocking, and what are the considerations?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4975/comments",
    "author": "livelyRyan",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-04-20T07:29:13Z",
        "body": "Java lock implementation doesn't allow this. However you can RLock.unlockAsync(threadId) for this case. ThreadId here is the id of the thread owner. Also you can use RSemaphore or RPermitExpirableSemaphore objects with a single permit."
      }
    ]
  },
  {
    "number": 4957,
    "title": "Is RBlockingDeque.take() exactly-once delivery?",
    "created_at": "2023-04-12T14:11:59Z",
    "closed_at": "2023-04-13T05:09:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4957",
    "body": "Sorry for bothering you but I just can't seem to find any documentation on this.\r\n\r\nI have a three-node Redis cluster and about 20 independent services, all pulling from the same queue.  It appears that, occasionally, multiple of these services pull the exact same message at virtually the exact same time, using the .take() routine. There are multiple providers as well, but I've pretty much confirmed that the messages are not being deposited twice to the queue.  \r\n\r\nI just want to verify whether this is something that can happen or not.\r\n\r\nIf it is, are there any tips (aside from moving away from the queue system and into streams) on how to stop it or is the queue system more of an at-least-once system?\r\n\r\nThanks for your time.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4957/comments",
    "author": "marclallen",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-04-13T05:09:01Z",
        "body": "> I just want to verify whether this is something that can happen or not.\r\n\r\nThat's not possible. take() is exactly-once delivery method"
      }
    ]
  },
  {
    "number": 4946,
    "title": "ClassCastException in RedissonConnection.",
    "created_at": "2023-04-05T13:40:11Z",
    "closed_at": "2023-04-15T08:12:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4946",
    "body": "I use Redisson with Spring boot application.\r\n```java\r\n    @Bean\r\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {\r\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\r\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\r\n        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());\r\n        redisTemplate.setHashKeySerializer(new StringRedisSerializer());\r\n        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());\r\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\r\n        redisTemplate.setEnableTransactionSupport(true);\r\n        return redisTemplate;\r\n    }\r\n```\r\n\r\nWhen I call this method\r\n```java\r\npublic long increment(String combinedKey, long delta) {\r\n    redisTemplate.getConnectionFactory().getConnection().incrBy(combinedKey.getBytes(), delta);\r\n}\r\n```\r\n\r\nRedissonConnection throw exception sometimes.\r\n```\r\njava.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Long (java.lang.String and java.lang.Long are in module java.base of loader 'bootstrap')\r\n\tat org.redisson.spring.data.connection.RedissonConnection.incrBy(RedissonConnection.java:583)\r\n```\r\n\r\nMaybe the problem is happening with this code.\r\n```java\r\n    public Long incrBy(byte[] key, long value) {\r\n        return (Long)this.write(key, StringCodec.INSTANCE, RedisCommands.INCRBY, key, value);\r\n    }\r\n```\r\n\r\nIf I already set a cache, these exception does not occur. \r\nExceptions are occurring **intermittently(not always)**. \r\nI expect that sequence with delta value is set based on 0 in normal case, so it should be able to be cast normally.\r\nWhat is the problem?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4946/comments",
    "author": "ReasonH",
    "comments": [
      {
        "user": "ReasonH",
        "created_at": "2023-04-05T13:47:42Z",
        "body": "Additional commnet.\r\nAlthough RedissonConnection made an exception, it was confirmed that the value was set normally in the cache.\r\nIt's just that an exception occurs in the process of type casting the result value."
      },
      {
        "user": "mrniko",
        "created_at": "2023-04-06T09:09:51Z",
        "body": "Which Redisson version?"
      },
      {
        "user": "ReasonH",
        "created_at": "2023-04-06T09:24:18Z",
        "body": "Current, I use 3.17.5"
      },
      {
        "user": "mrniko",
        "created_at": "2023-04-06T09:36:12Z",
        "body": "You need to update to 3.19.2 or higher\r\n\r\n> Fixed - command replies don't match if exception is thrown in CommandEncoder"
      },
      {
        "user": "ReasonH",
        "created_at": "2023-04-06T10:25:26Z",
        "body": "Ok, I'll test with fixed version. Thanks a lot!"
      },
      {
        "user": "ReasonH",
        "created_at": "2023-04-10T05:55:30Z",
        "body": "I have update 3.20.1. I'm using spring-boot 2.7.1\r\nHere is my pom.xml. I exclude redisson-spring-data-30, and add redisson-spring-data-27 (for compitability with spring-boot)\r\n```\r\n        <dependency>\r\n            <groupId>org.redisson</groupId>\r\n            <artifactId>redisson-spring-boot-starter</artifactId>\r\n            <version>${redisson.version}</version>\r\n            <exclusions>\r\n                <exclusion>\r\n                    <groupId>org.redisson</groupId>\r\n                    <artifactId>redisson-spring-data-30</artifactId>\r\n                </exclusion>\r\n            </exclusions>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.redisson</groupId>\r\n            <artifactId>redisson-spring-data-27</artifactId>\r\n            <version>${redisson.version}</version>\r\n        </dependency>\r\n```\r\n\r\nAlso, I fixed my code to use RedissonAtomicLong instead of redissonConnection.\r\nBut I still face this classCastException.\r\n\r\n```\r\njava.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Long (java.lang.String and java.lang.Long are in module java.base of loader 'bootstrap')\r\n\tat java.base/java.util.stream.Collectors.lambda$summarizingLong$72(Unknown Source)\r\n\tat java.base/java.util.stream.ReduceOps$3ReducingSink.accept(Unknown Source)\r\n\tat java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source)\r\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source)\r\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)\r\n\tat java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source)\r\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source)\r\n\tat java.base/java.util.stream.ReferencePipeline.collect(Unknown Source)\r\n\tat org.redisson.spring.data.connection.RedissonClusterConnection.del(RedissonClusterConnection.java:505)\r\n\tat org.springframework.data.redis.cache.DefaultRedisCacheWriter.lambda$remove$3(DefaultRedisCacheWriter.java:195)\r\n\tat org.springframework.data.redis.cache.DefaultRedisCacheWriter.execute(DefaultRedisCacheWriter.java:308)\r\n\tat org.springframework.data.redis.cache.DefaultRedisCacheWriter.remove(DefaultRedisCacheWriter.java:195)\r\n\tat org.springframework.data.redis.cache.RedisCache.evict(RedisCache.java:200)\r\n\tat org.springframework.cache.transaction.TransactionAwareCacheDecorator$2.afterCommit(TransactionAwareCacheDecorator.java:121)\r\n```\r\n\r\nThe exception rising only when Spring cahceManager evict cache. (after commit by transactionAware() option)\r\nI current use redisson with CacheManager in some case."
      },
      {
        "user": "mrniko",
        "created_at": "2023-04-10T06:01:35Z",
        "body": "Can you share the code to reproduce it?"
      },
      {
        "user": "ReasonH",
        "created_at": "2023-04-10T08:01:07Z",
        "body": "Here is my code sample.\r\n\r\n### Case1\r\nFirst. It didn't use `@Transactional`, just delete cache using by redisTemplate.\r\n\r\n#### Caller\r\n```java\r\n@Service\r\n@RequiredArgsConstructor\r\nclass ServiceImpl implements Service {\r\n\r\n    private final RedisValueCacheRepository<Boolean> repository;\r\n\r\n    @Override\r\n    public void remove(AdminRequest request) {\r\n        repository.remove(request.getKey());\r\n    }\r\n}\r\n```\r\n#### Callee\r\n```java\r\n@Slf4j\r\n@RequiredArgsConstructor\r\n@Repository\r\npublic class RedisValueCacheRepository<V> {\r\n\r\n    private final RedisTemplate<String, V> redisTemplate;\r\n    public void remove(String cacheName) {\r\n        redisTemplate.delete(cacheName);\r\n    }\r\n}\r\n```\r\n\r\nSometimes, I got exception such as\r\n```\r\njava.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Long (java.lang.String and java.lang.Long are in module java.base of loader 'bootstrap')\r\n\tat java.base/java.util.stream.Collectors.lambda$summarizingLong$72(Unknown Source)\r\n\tat java.base/java.util.stream.ReduceOps$3ReducingSink.accept(Unknown Source)\r\n\tat java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source)\r\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source)\r\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)\r\n\tat java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source)\r\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source)\r\n\tat java.base/java.util.stream.ReferencePipeline.collect(Unknown Source)\r\n\tat org.redisson.spring.data.connection.RedissonClusterConnection.del(RedissonClusterConnection.java:505)\r\n\tat org.springframework.data.redis.core.RedisTemplate.lambda$delete$3(RedisTemplate.java:723)\r\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:224)\r\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:191)\r\n\tat org.springframework.data.redis.core.RedisTemplate.delete(RedisTemplate.java:723)\r\n```\r\n\r\n### Case2\r\nThe caller is @Transactional, also I use both redisTemplate and Spring cache abstraction (@CacheEvict) together.\r\n\r\nFirst, the @Transactional method call method for clearing cache.\r\n```java\r\n@Transactional\r\npublic void txService(AdminRequest request) {\r\n        // other transaction process\r\n        cacheService.foo(request.getKey(), request.getSubKeys());\r\n        // etc...\r\n}\r\n```\r\n\r\nnext the `claerCache` method call cache deletion process internally.\r\n```java\r\n@Service\r\n@RequiredArgsConstructor\r\nclass CacheService {\r\n    private final TemplateCache<String> templateCache;\r\n    private final AbstractionCache abstractionCache;\r\n\r\n    public void clearCache(String key, String[] subKey) {    \r\n        abstractionCache.evict(key);\r\n        templateCache.deleteMulti(key, subKey);\r\n    }\r\n}\r\n```\r\n```java\r\n@Service\r\nclass AbstractionCache {\r\n    @Override\r\n    @CacheEvict(cacheNames = TEMP_CACHE_NAME, key = \"#key\")\r\n    public void evict(String key) {\r\n    }\r\n}\r\n```\r\n```java\r\n@Service\r\nclass TemplateCache<V> {\r\n    private final RedisTemplate<String, V> redisTemplate;\r\n\r\n    public void deleteHashValues(String key, String[] subKeys) {\r\n        if (keys.length == 0) {\r\n            return;\r\n        }\r\n        HashOperations<String, String, V> hashOps = redisTemplate.opsForHash();\r\n        hashOps.delete(key, subKeys);\r\n    }\r\n}\r\n```\r\n\r\nThe case 2 throw exception. (hardly)\r\n```\r\njava.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Long (java.lang.String and java.lang.Long are in module java.base of loader 'bootstrap')\r\n\tat java.base/java.util.stream.Collectors.lambda$summarizingLong$72(Unknown Source)\r\n\tat java.base/java.util.stream.ReduceOps$3ReducingSink.accept(Unknown Source)\r\n\tat java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source)\r\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source)\r\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)\r\n\tat java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source)\r\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source)\r\n\tat java.base/java.util.stream.ReferencePipeline.collect(Unknown Source)\r\n\tat org.redisson.spring.data.connection.RedissonClusterConnection.del(RedissonClusterConnection.java:505)\r\n\tat org.springframework.data.redis.cache.DefaultRedisCacheWriter.lambda$remove$3(DefaultRedisCacheWriter.java:195)\r\n\tat org.springframework.data.redis.cache.DefaultRedisCacheWriter.execute(DefaultRedisCacheWriter.java:308)\r\n\tat org.springframework.data.redis.cache.DefaultRedisCacheWriter.remove(DefaultRedisCacheWriter.java:195)\r\n\tat org.springframework.data.redis.cache.RedisCache.evict(RedisCache.java:200)\r\n\tat org.springframework.cache.transaction.TransactionAwareCacheDecorator$2.afterCommit(TransactionAwareCacheDecorator.java:121)\r\n\tat org.springframework.transaction.support.TransactionSynchronizationUtils.invokeAfterCommit(TransactionSynchronizationUtils.java:135)\r\n\tat org.springframework.transaction.support.TransactionSynchronizationUtils.triggerAfterCommit(TransactionSynchronizationUtils.java:123)\r\n\tat org.springframework.transaction.support.AbstractPlatformTransactionManager.triggerAfterCommit(AbstractPlatformTransactionManager.java:936)\r\n\tat org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:782)\r\n\tat org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:711)\r\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:654)\r\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:407)\r\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119)\r\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\r\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:708)\r\n```\r\n\r\nIt's my RedisCacheConfig class\r\n\r\n```java\r\n@Configuration\r\n@EnableCaching\r\npublic class RedisCacheConfig {\r\n\r\n    @Value(\"${spring.redis.cluster.nodes}\")\r\n    private List<String> clusterNodes;\r\n\r\n    @Bean\r\n    public RedissonClient redissonClient() {\r\n        int clusterSize = clusterNodes.size();\r\n        Config config = new Config();\r\n        config.setNettyThreads(64);\r\n        config\r\n                .useClusterServers()\r\n                .setKeepAlive(true)\r\n                .addNodeAddress(clusterNodes.toArray(new String[clusterSize]))\r\n                .setReadMode(ReadMode.MASTER_SLAVE);\r\n        return Redisson.create(config);\r\n    }\r\n\r\n    @Bean\r\n    public RedissonConnectionFactory redisConnectionFactory(RedissonClient redissonClient) {\r\n        return new RedissonConnectionFactory(redissonClient);\r\n    }\r\n\r\n    @Bean\r\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {\r\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\r\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\r\n        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());\r\n        redisTemplate.setHashKeySerializer(new StringRedisSerializer());\r\n        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());\r\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\r\n        redisTemplate.setEnableTransactionSupport(true); // transaction support\r\n        return redisTemplate;\r\n    }\r\n\r\n    @Bean\r\n    public CacheManager redisCacheManager(RedissonConnectionFactory redisConnectionFactory) {\r\n        return RedisCacheManager.builder(redisConnectionFactory)\r\n                .cacheDefaults(redisCacheConfig())\r\n                .withInitialCacheConfigurations(cacheKeyMap())\r\n                .transactionAware() // transaction support\r\n                .build();\r\n    }\r\n\r\n    private RedisCacheConfiguration redisCacheConfig() {\r\n        GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer();\r\n        RedisSerializationContext.SerializationPair<Object> pair = RedisSerializationContext.SerializationPair.fromSerializer(jsonRedisSerializer);\r\n\r\n        return RedisCacheConfiguration.defaultCacheConfig().serializeValuesWith(pair).disableCachingNullValues();\r\n    }\r\n    // omitted below\r\n}\r\n```"
      },
      {
        "user": "ReasonH",
        "created_at": "2023-04-10T08:29:08Z",
        "body": "I got same exception very occasionally when I use RedissonAtomicLong.\r\n\r\n```java\r\n@Slf4j\r\n@RequiredArgsConstructor\r\n@Repository\r\npublic class CacheService {\r\n    private final RedisTemplate<String, String> redisTemplate;\r\n    private final RedissonClient redissonClient;\r\n\r\n    @Transactional\r\n    public long increment(String key, String value) {\r\n        // omitted (JPA transaction, etc ...)\r\n        ValueOperations<String, String> valueOps = redisTemplate.opsForValue();\r\n        valueOps.set(key, value);\r\n        return redissonClient.getAtomicLong(cacheName).incrementAndGet();\r\n    }\r\n```\r\n\r\nIn this case, I needed the return of redis INCR command.\r\nHowever, if I use increment method of ValueOperations, then the return always null (because it's not executed until commit)\r\nThus, I used RedissonAtomicLong.\r\n\r\nsometimes, It also make classCastException...\r\n```\r\njava.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Long (java.lang.String and java.lang.Long are in module java.base of loader 'bootstrap')\r\n\tat org.redisson.RedissonAtomicLong.incrementAndGet(RedissonAtomicLong.java:132)\r\n```\r\n\r\nIs there a problem with the way I use RedissonClient, or the connection pooling setup?\r\nIf I remove both transactionAware() and EnableTransactionSupport(true), and change to valueops of RedisTemplate until RedissonAtomicLong, which all works normally."
      },
      {
        "user": "mrniko",
        "created_at": "2023-04-12T10:26:53Z",
        "body": "Unable to reproduce. Can you set `TRACE` logging level for `org.redisson` package and share the output?"
      },
      {
        "user": "ReasonH",
        "created_at": "2023-04-15T08:12:14Z",
        "body": "Unfortunately, the we can't test this because of the schedule, so the we concluded turning off the the transaction support option temporarily.\r\n\r\nIf I go through this problem again, I will re-open the issue. Thanks for the help"
      },
      {
        "user": "mrniko",
        "created_at": "2023-04-17T07:19:06Z",
        "body": "Unable to reproduce. Below is the test.\r\n\r\n```java\r\n@SpringJUnitConfig\r\n@SpringBootTest(\r\n        classes = RedissonApplication.class,\r\n        properties = {\r\n            \"spring.redis.redisson.file=classpath:redisson.yaml\",\r\n            \"spring.redis.timeout=10000\"\r\n        })\r\npublic class RedissonAutoConfigurationTest {\r\n\r\n    @Autowired\r\n    CacheService cacheService;\r\n    @Autowired\r\n    CacheService2 cacheService2;\r\n    @Autowired\r\n    private RedissonClient redisson;\r\n\r\n    @Test\r\n    public void testApp() {\r\n        redisson.getKeys().flushall();\r\n\r\n        for (int i = 1; i < 10; i++) {\r\n            cacheService.put(\"k100\"+i, \"v\");\r\n            cacheService2.clearCache(\"k1002\" + i, new String[] {\"k2\" + i, \"k3\" + i});\r\n        }\r\n    }\r\n    \r\n}\r\n\r\n@Service\r\npublic class CacheService {\r\n\r\n    @Autowired\r\n    private RedisTemplate<String, Object> redisTemplate;\r\n\r\n    @Transactional\r\n    public void put(String key, String value) {\r\n        ValueOperations<String, Object> valueOps = redisTemplate.opsForValue();\r\n        valueOps.set(key, value);\r\n    }\r\n\r\n}\r\n\r\n@Service\r\npublic class CacheService2 {\r\n\r\n    @Autowired\r\n    private RedisTemplate<String, Object> redisTemplate;\r\n\r\n    @Autowired\r\n    private CacheService3 cacheService3;\r\n\r\n    public void clearCache(String key, String[] subKey) {\r\n        cacheService3.evict(key);\r\n        redisTemplate.opsForHash().delete(key, subKey);\r\n    }\r\n\r\n}\r\n\r\n@Service\r\npublic class CacheService3 {\r\n\r\n    @Autowired\r\n    private RedisTemplate<String, Object> redisTemplate;\r\n\r\n    @Autowired\r\n    private RedissonClient redissonClient;\r\n\r\n    @CacheEvict(cacheNames = \"test\", key = \"#key\")\r\n    public void evict(String key) {\r\n        System.out.println(\"evicted \" + key);\r\n    }\r\n\r\n}\r\n\r\n@SpringBootApplication\r\n@Configuration\r\n@EnableTransactionManagement\r\n@EnableCaching\r\npublic class RedissonApplication {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(RedissonApplication.class, args);\r\n    }\r\n\r\n    @Bean\r\n    public RedissonTransactionManager transactionManager(RedissonClient redisson) {\r\n        return new RedissonTransactionManager(redisson);\r\n    }\r\n\r\n    @Bean\r\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {\r\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\r\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\r\n        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());\r\n        redisTemplate.setHashKeySerializer(new StringRedisSerializer());\r\n        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());\r\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\r\n        redisTemplate.setEnableTransactionSupport(true); // transaction support\r\n        return redisTemplate;\r\n    }\r\n\r\n    private RedisCacheConfiguration redisCacheConfig() {\r\n        GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer();\r\n        RedisSerializationContext.SerializationPair<Object> pair = RedisSerializationContext.SerializationPair.fromSerializer(jsonRedisSerializer);\r\n\r\n        return RedisCacheConfiguration.defaultCacheConfig().serializeValuesWith(pair).disableCachingNullValues();\r\n    }\r\n\r\n    @Bean\r\n    public CacheManager redisCacheManager(RedissonConnectionFactory redisConnectionFactory) {\r\n        return RedisCacheManager.builder(redisConnectionFactory)\r\n                .cacheDefaults(redisCacheConfig())\r\n                .transactionAware() // transaction support\r\n                .build();\r\n    }\r\n\r\n}\r\n"
      }
    ]
  },
  {
    "number": 4937,
    "title": "Should the default-update-timestamps-region be cleared/deleted when evictAllRegions is called on the Hibernate Cache",
    "created_at": "2023-03-28T17:33:35Z",
    "closed_at": "2023-03-31T06:18:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4937",
    "body": "Hi,\r\n\r\nI have a Spring application that is using Hibernate with Redisson backed L2 Cache. The application is running in Kubernetes, and in particular it's possible for the duration of a rollout that there are mixed versions of cached Entities; the new version of the application being deployed replaces each \"old\" pod in turn.\r\n\r\nTo avoid \"deserialization\" issues when reading Entities from the cache, I have experimented with using a region prefix (`hibernate.cache.region_prefix`) that uses a \"dynamic\" value that is generated at build time of the application. As such, when a new deployment begins, that new deployment starts with fresh cache/entity regions as they now have a different prefix to the \"old\" pods/app instances.\r\n\r\nHowever, in this rollout process, the \"old\" regions need to be cleaned up in order to avoid a leak in Redis. The simplest approach I've tried is to call `evictAllRegions` on the Hibernate Cache to clear up all the cache regions on application shutdown. I realise that remaining \"old\" instances would keep repopulating the cache until the last pod shuts down.\r\n\r\nIn this process, `evictAllRegions` appears to be clearing everything _except_ the `default-update-timestamps-region` which, in my case is called `<prefix>.default-update-timestamps-region` in Redis.\r\n\r\nMy question is, should I expect `evictAllRegions` to also clear/delete out the `default-update-timestamps-region` entry in Redis?\r\n\r\nThanks for any help you may be able to provide.\r\n\r\nCheers,\r\nAlex",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4937/comments",
    "author": "alewis001",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-03-31T06:18:16Z",
        "body": "you can look at org.hibernate.Cache#evictAllRegions() implemetation. It doesn't clear timestamps region.\r\n\r\nYou can clear like this sessionFactory.getCache().getTimestampsCache().clear();"
      },
      {
        "user": "alewis001",
        "created_at": "2023-03-31T09:01:12Z",
        "body": "Thank you @mrniko. I did start to make my way through the code as I was trying to see whether the logic for what gets cleared and when, is determined by HIbernate or by Redisson but didn't get as far as working out that the timestamp cache needed to be explicitly cleared via `getTimestampsCache().clear()`. Thanks for your help."
      },
      {
        "user": "alewis001",
        "created_at": "2023-03-31T09:46:46Z",
        "body": "@mrniko Apologies if I'm missing something but there isn't a `getTimestampsCache` method on `org.hibernate.Cache`, which is the class returned by `org.hibernate.SessionFactory`. That method does exist on `org.hibernate.cache.spi.CacheImplementor` which appears to be on the SPI interface between Hibernate and Redisson. \r\n\r\nI've tried going through the Hibernate/Redisson code but I can't find a way to access the TimestampsCache as an Application. Am I missing something? \r\n\r\nIf this is now more of a question for Hibernate rather than Redisson, then no problem I can go there instead but, thank you for your help regardless."
      },
      {
        "user": "mrniko",
        "created_at": "2023-03-31T10:08:25Z",
        "body": "@alewis001 \r\n\r\n> Apologies if I'm missing something but there isn't a getTimestampsCache method on org.hibernate.Cache, which is the class returned by org.hibernate.SessionFactory. That method does exist on org.hibernate.cache.spi.CacheImplementor which appears to be on the SPI interface between Hibernate and Redisson.\r\n\r\nI thought you use Hibernate 5.3 version and higher. Can you upgrade Hibernate?"
      },
      {
        "user": "alewis001",
        "created_at": "2023-03-31T10:22:36Z",
        "body": "I'm using Hibernate 5.6.9 (`hibernate-core-5.6.9.Final.jar`). "
      },
      {
        "user": "mrniko",
        "created_at": "2023-03-31T10:41:06Z",
        "body": "can you get SessionFactoryImplementor and then call getCache()?"
      },
      {
        "user": "alewis001",
        "created_at": "2023-03-31T10:45:05Z",
        "body": "There doesn't appear to be a way to access `SessionFactoryImplementor` or, at least, not on Hibermate's public api. `SessionFactoryImplementor` is part of the SPI API (`org.hibernate.engine.spi`) and so it isn't on the public API exposed to clients."
      },
      {
        "user": "alewis001",
        "created_at": "2023-03-31T10:49:45Z",
        "body": "I had originally thought that evicting the Query region, either directly via `Cache#evictDefaultQueryRegion` or via `evictAllRegions` would have evicted both the query region itself and the associated timestamp region but that doesn't appear to happen. "
      },
      {
        "user": "alewis001",
        "created_at": "2023-03-31T10:58:18Z",
        "body": "I can see in `org.hibernate.cache.internal.QueryResultsCacheImpl` that calling `clear` (there's a default implementation on the interface it implements which calls `getRegion().clear()`) which ends up clearing the main region but it does nothing with the Timestamps Cache that `QueryResultsCacheImpl` also has a reference to.\r\n\r\nThis might be a question for Hibernate as Redisson is doing all the necessary things according to the SPI. I don't want to take up too much of your time. "
      }
    ]
  },
  {
    "number": 4933,
    "title": "Redisson hibernate not reading codec data from config yaml",
    "created_at": "2023-03-24T05:46:19Z",
    "closed_at": "2023-06-29T06:00:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4933",
    "body": "We are trying to use redisson hibernate with the following gradle dependency:\r\n'org.redisson:redisson-hibernate-53:3.16.8'\r\n\r\nand below redisson config file:\r\n{\r\n  \"clusterServersConfig\": {\r\n    \"idleConnectionTimeout\": 10000,\r\n    \"connectTimeout\": 240000,\r\n    \"timeout\": 180000,\r\n    \"retryAttempts\": 3,\r\n    \"retryInterval\": 1500,\r\n    \"failedSlaveReconnectionInterval\": 3000,\r\n    \"failedSlaveCheckInterval\": 60000,\r\n    \"subscriptionsPerConnection\": 5,\r\n    \"clientName\": \"test\",\r\n    \"subscriptionConnectionMinimumIdleSize\": 1,\r\n    \"subscriptionConnectionPoolSize\": 250,\r\n    \"slaveConnectionMinimumIdleSize\": 24,\r\n    \"slaveConnectionPoolSize\": 512,\r\n    \"masterConnectionMinimumIdleSize\": 24,\r\n    \"masterConnectionPoolSize\": 512,\r\n    \"readMode\": \"SLAVE\",\r\n    \"subscriptionMode\": \"SLAVE\",\r\n     \"scanInterval\": 1000,\r\n    \"pingConnectionInterval\": 30000\r\n  },\r\n  \"threads\": 16,\r\n  \"nettyThreads\": 32,\r\n    \"codec\": !<org.redisson.codec.Kryo5Codec> {}\r\n  \"transportMode\": \"NIO\"\r\n}\r\n\r\nWe are getting below error and application fails to start:\r\n\r\ncom.fasterxml.jackson.databind.exc.InvalidTypeIdException: Missing type id when trying to resolve subtype of [simple type, class org.redisson.client.codec.Codec]: missing type id property 'class' (for POJO property 'codec')\r\n\r\nNot sure why is it not reading codec from config file. Please help.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4933/comments",
    "author": "purti-rajpal",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-03-27T10:14:59Z",
        "body": "Can you share the full stacktrace?"
      },
      {
        "user": "Maktoublwx",
        "created_at": "2025-01-14T04:03:03Z",
        "body": "I have the same problem, have you solved it"
      }
    ]
  },
  {
    "number": 4928,
    "title": "not support auto retry",
    "created_at": "2023-03-21T16:45:29Z",
    "closed_at": "2023-06-29T05:59:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4928",
    "body": "the consumer won't auto consume the message after detele the stream/group and recreate   stream/group",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4928/comments",
    "author": "jonny77",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-06-29T05:59:34Z",
        "body": "Unable to reproduce."
      }
    ]
  },
  {
    "number": 4927,
    "title": "CROSSSLOT Keys in request don't hash to the same slot",
    "created_at": "2023-03-21T13:46:44Z",
    "closed_at": "2023-03-23T08:31:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4927",
    "body": "Hi, I'm receiving an error that says 'CROSSSLOT Keys in request don't hash to the same slot' and I'm not sure why. Here's my Radisson configuration:\r\n\r\n            Config config = new Config();\r\n            config.setNettyThreads(128);\r\n            ClusterServersConfig clusterConfig = config.useClusterServers();\r\n            clusterConfig.setTimeout(5000);\r\n            clusterConfig.setSlaveConnectionPoolSize(128);\r\n            clusterConfig.setMasterConnectionPoolSize(128);\r\n            clusterConfig.addNodeAddress(memoryDBParams.getAddress());\r\n\r\nAnd here's the operation that's causing the issue:\r\n\r\n          RTransaction transaction = client.createTransaction(TransactionOptions.defaults());\r\n          transaction.getMap(mapName).delete();\r\n          transaction.getMap(mapName).putAll(map);\r\n          transaction.commit();\r\n\r\n\r\n\r\nRadisson version:  3.17.5\r\nRedis: Memory db in aws (cluster mode )\r\n\r\n     \r\n Can you help me figure out what might be causing this error?\r\n\r\n\r\nexception:\r\n\r\nat net.bull.javamelody.MonitoringFilter.doFilter(MonitoringFilter.java:239)\r\n        at net.bull.javamelody.MonitoringFilter.doFilter(MonitoringFilter.java:215)\r\n        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n        at filters.CorsFilter.doFilter(CorsFilter.java:64)\r\n        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n        at filters.ErrorHandleFilter.doFilter(ErrorHandleFilter.java:94)\r\n        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n        at org.apache.catalina.filters.SetCharacterEncodingFilter.doFilter(SetCharacterEncodingFilter.java:109)\r\n        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n        at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:177)\r\n        at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n        at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\r\n        at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)\r\n        at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n        at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:687)\r\n        at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n        at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360)\r\n        at org.apache.coyote.ajp.AjpProcessor.service(AjpProcessor.java:433)\r\n        at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n        at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:891)\r\n        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1784)\r\n        at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n        at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\r\n        at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\r\n        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n        at java.lang.Thread.run(Thread.java:748)\r\nCaused by: org.redisson.client.RedisException: CROSSSLOT Keys in request don't    CROSSSLOT Keys in request don't hash to the same slot. channel: [id: 0x7e3d7560, L:/10.1.40.10:55246 - R:10.1.12.15/10.1.12.15:6379] command: (EXEC), promise: java.util.concurrent.CompletableFuture@353f8e03[Not completed], params: []\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:370)\r\n        at org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:271)\r\n        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:210)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n        at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1518)\r\n        at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1267)\r\n        at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1314)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:449)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n        \r\n   \r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4927/comments",
    "author": "yarivMobitti",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-03-23T08:31:24Z",
        "body": "Transactions aren't compatible with Redis cluster setup"
      },
      {
        "user": "yarivMobitti",
        "created_at": "2023-04-20T08:19:51Z",
        "body": "Could you please explain the correct way to do it with cluster mode? How can I run more than one operation atomically? In this case, I need to delete and putAll. Is there an available function in Redisson that simply replaces the value of a key? (in this case my map)"
      },
      {
        "user": "mrniko",
        "created_at": "2023-04-20T12:16:03Z",
        "body": "@yarivMobitti \r\n\r\nI have just tested your case. Unable to reproduce the issue using the code below in cluster mode.\r\n\r\n```java\r\n        RTransaction transaction = redisson.createTransaction(TransactionOptions.defaults());\r\n        transaction.getMap(\"test1\").delete();\r\n        Map<String, String> map = new HashMap<>();\r\n        map.put(\"1\", \"1\");\r\n        map.put(\"2\", \"2\");\r\n        transaction.getMap(\"test1\").putAll(map);\r\n        transaction.commit();\r\n```\r\n\r\n"
      },
      {
        "user": "yarivMobitti",
        "created_at": "2023-04-20T14:43:39Z",
        "body": "@mrniko \r\nI can guess that it also depends on the data already stored in Redis and the available slots, among other factors. I can provide more information and the exact scenario for how to reproduce it if needed.\r\n\r\nI am not too worried about the transaction because, as you mentioned before, it is not supported with cluster mode. (However, it could be possible to use it as long as the data is kept in the same slot, which I am not sure how to force with Redisson).\r\n\r\nAnyway, the reason I am using the transaction is to ensure that the delete and put operations are performed atomically. This is because it is possible that someone may try to read data in the time between the delete and putAll operations.\r\n\r\nPerhaps there is another way to achieve this without the transaction. For example, is it possible to use a lock for the specific key, which would prevent all read operations on that key entry?\r\n   \r\n\r\n"
      },
      {
        "user": "supportMobitti",
        "created_at": "2023-05-04T11:34:57Z",
        "body": "@mrniko hi\r\nany comment about this topic ?\r\nthanks "
      },
      {
        "user": "mrniko",
        "created_at": "2023-05-24T06:49:26Z",
        "body": "Hi @supportMobitti\r\n\r\nCan you share the code to reproduce the issue?"
      },
      {
        "user": "supportMobitti",
        "created_at": "2023-11-20T10:59:24Z",
        "body": "Hi, back to this issue\r\n\r\ni guess im not doing anything special, you can see the code and more details below:\r\nRedis version: 6.2 (memory db on aws), 1 shards, 2 nodes\r\nRedisson version: 3.17.5\r\n\r\n\r\n Config config = new Config();\r\n\t\tClusterServersConfig clusterConfig = config.useClusterServers();\r\nclusterConfig.setTimeout(5000);\r\nclusterConfig.setSlaveConnectionPoolSize(128);\r\n\t\tclusterConfig.setMasterConnectionPoolSize(128);\r\n\t\tclusterConfig.addNodeAddress(\"myAddress\");\r\n\t\tclient = Redisson.create(config);\r\n\t\tSet<Object> mySet = new HashSet<>();\r\n\t\tmySet.add(1);\r\n\t\tmySet.add(2);\r\n\t\tmySet.add(3);\r\n\t\tRTransaction transaction = client.createTransaction(TransactionOptions.defaults());\r\n\t\ttransaction.getSet(\"mySetName\").delete();\r\n\t\ttransaction.getSet(\"mySetName\").addAll(mySet);\r\n\t\ttransaction.commit();"
      },
      {
        "user": "mrniko",
        "created_at": "2025-01-16T13:02:03Z",
        "body": "@supportMobitti \n\nThanks for the code. It works fine with the latest version."
      }
    ]
  },
  {
    "number": 4916,
    "title": "Getting java.lang.ClassNotFoundException: org.apache.catalina.session.ManagerBase upon adding Redisson jars",
    "created_at": "2023-03-10T21:34:57Z",
    "closed_at": "2023-03-23T08:54:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4916",
    "body": "Hi,\r\n\r\nI have an existing Java(using openj9 version 1.8.0_222) application which runs on Apache Tomcat 8.\r\nI am trying to add Redisson jar to replicate the Tomcat Session in Redis.\r\n\r\n1. I have downloaded the redisson-all-3.20.0.jar and redisson-tomcat-8-3.20.0.jar and put them in Tomcat's lib folder.\r\n2. I have updated the Tomcat's context.xml file to include the RedissonSessionManager, as below:\r\n<Manager className=\"org.redisson.tomcat.RedissonSessionManager\"\r\n    \t\t\tconfigPath=\"${catalina.base}/conf/redisson.yml\" \r\n    \t\t\treadMode=\"REDIS\" updateMode=\"DEFAULT\" broadcastSessionEvents=\"true\"\r\n    \t\t\tkeyPrefix=\"\" />\r\n3. I have also made the redisson.yml file with redis config information and put it in the Tomcat's catalina base's conf folder.\r\n\r\nI built the project and on starting the Tomcat server, it is giving me error on ManagerBase class not found, as below:\r\nCaused by: java.lang.NoClassDefFoundError: org.apache.catalina.session.ManagerBase\r\n\tat java.lang.ClassLoader.defineClassImpl(Native Method)\r\n\tat java.lang.ClassLoader.defineClassInternal(ClassLoader.java:389)\r\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:358)\r\n\tat java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\r\n\tat java.net.URLClassLoader.defineClass(URLClassLoader.java:682)\r\n\tat java.net.URLClassLoader.access$400(URLClassLoader.java:89)\r\n\tat java.net.URLClassLoader$ClassFinder.run(URLClassLoader.java:1086)\r\n\tat java.security.AccessController.doPrivileged(AccessController.java:770)\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:589)\r\n\tat java.lang.ClassLoader.loadClassHelper(ClassLoader.java:944)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:889)\r\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)\r\n\tat java.lang.ClassLoader.loadClassHelper(ClassLoader.java:933)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:889)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:872)\r\n\tat org.apache.tomcat.util.digester.ObjectCreateRule.begin(ObjectCreateRule.java:116)\r\n\tat org.apache.tomcat.util.digester.Digester.startElement(Digester.java:1203)\r\n\tat com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:509)\r\n\tat com.sun.org.apache.xerces.internal.parsers.AbstractXMLDocumentParser.emptyElement(AbstractXMLDocumentParser.java:182)\r\n\tat com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanStartElement(XMLDocumentFragmentScannerImpl.java:1339)\r\n\tat com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2784)\r\n\tat com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:602)\r\n\tat com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:505)\r\n\tat com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:842)\r\n\tat com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:771)\r\n\tat com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141)\r\n\tat com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1213)\r\n\tat com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:643)\r\n\tat org.apache.tomcat.util.digester.Digester.parse(Digester.java:1476)\r\n\tat org.apache.catalina.startup.ContextConfig.processContextConfig(ContextConfig.java:537)\r\n\tat org.apache.catalina.startup.ContextConfig.contextConfig(ContextConfig.java:475)\r\n\tat org.apache.catalina.startup.ContextConfig.init(ContextConfig.java:738)\r\n\tat org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:310)\r\n\tat org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:94)\r\n\tat org.apache.catalina.util.LifecycleBase.setStateInternal(LifecycleBase.java:395)\r\n\tat org.apache.catalina.util.LifecycleBase.init(LifecycleBase.java:108)\r\n\r\nI have made the changes as per the readme files, as described above, but not sure what else could be the reason for the above issue.\r\nCan you please take a look at it?\r\n\r\nThanks, ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4916/comments",
    "author": "cverma",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-03-23T08:54:37Z",
        "body": "Unable to reproduce it"
      }
    ]
  },
  {
    "number": 4914,
    "title": "Can there be an option to have Redisson only use daemon threads?",
    "created_at": "2023-03-09T03:21:51Z",
    "closed_at": "2023-06-29T06:03:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4914",
    "body": "Right now Redisson uses some non-daemon threads, and apps must call `client.shutdown()` before main completes, otherwise the process won't actually terminate. Would it be possible to have a config option to relax that requirement and have Redisson only use daemon threads instead? I understand that means that the app won't have a chance to complete any work that the background threads are doing, but that is ok for our use case. The use case is that we have a library that uses Redisson to connect to Redis and clients of the library always forget to `close()` on the java client we give them, or it is created deep inside some object heirarchy or through dependency injection and it isn't straightforward to call `close()` before `main` returns, and as a result apps hangs on shutdown.\r\n\r\nOur library either only reads data from Redis, or writes data that we are ok losing if the app were to shutdown before it gets flushed. I am assuming that abrupt shutdown won't leave Redis itself in a bad state (right now there are cases our user's apps are shutdown with SIGTERM and therefore `shutdown()` isn't called and we haven't seen any issues with redis as a result). If we can have this option to turn on a mode where Redisson only use daemon threads it will make its usage much more straightforward.\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4914/comments",
    "author": "chaimmintz",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-06-29T06:03:50Z",
        "body": "I think this can be configured with proper thread pools."
      },
      {
        "user": "chaimmintz",
        "created_at": "2023-06-29T11:38:19Z",
        "body": "How does one configure the thread pools to use for redisson?"
      },
      {
        "user": "tucu00",
        "created_at": "2023-08-18T14:47:44Z",
        "body": "I'm running into the same problem even after configuring the client to use an Executor that uses daemon threads.\r\n\r\n` Config   config.setExecutor(Executors.newFixedThreadPool(threads, new DefaultThreadFactory(\"redissonx\", true)));`\r\n\r\nEven after this the client is stopping the JVM to end because of the 'redisson-timer' thread which is not a daemon thread.\r\n\r\nI couldn't find a way to configure the timer so it uses a daemon thread.\r\n\r\nAny suggestion?\r\n\r\nThanks"
      }
    ]
  },
  {
    "number": 4911,
    "title": "Getting this Exception in AWS java.lang.NoSuchMethodError: io.netty.buffer.ByteBuf.isContiguous()Z",
    "created_at": "2023-03-08T04:39:02Z",
    "closed_at": "2023-03-08T05:35:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4911",
    "body": "We are trying to upgrade redisson version from 3.10.0 to 3.19.1\r\nElasticcache engine version as 5.0.6\r\nNetty version : 4.1.88.Final (Latest Stable)\r\nGetting below error in the logs. Please help me whats the issue here ?\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4911/comments",
    "author": "sathishkumars-nd",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-03-08T05:35:52Z",
        "body": "Make sure you did it properly and there are no two different netty versions in classpath."
      }
    ]
  },
  {
    "number": 4910,
    "title": "Retry a different replica if one is unavailable",
    "created_at": "2023-03-07T14:05:29Z",
    "closed_at": "2023-03-23T08:53:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4910",
    "body": "I was wondering if it is possible to make retry attempts perform a round robin between different replicas if one of them is unavailable.\r\n\r\nI'm using AWS ElastiCache (no cluster mode), 1 master with 3 replicas. Our configuration uses replicated mode, and when setting it up we're adding 2 node addresses: one for the primary endpoint, and one for the reader endpoing `addNodeAddress(\"master.REDACTED.cache.amazonaws.com:6379\", \"replica.REDACTED.cache.amazonaws.com:6379\")`.\r\n\r\nA couple of days ago, we performed migration of the cluster, upgrading the engine version in our live production environment. We expected some connection issues when fetching data from the cluster, but assumed that because the client is configured with retry attempts, that in case a replica was unavailable, it would try a different one. This did not work, and quite a lot of operations fails for us.\r\n\r\n1. How should the replicated server configuration look like? Is it correct to use the primary and reader endpoints listed in the AWS ElastiCache dashboard? Or are we supposed to list all 4 nodes direct addresses instead? The documentation isn't clear on that\r\n2. Is it possible to make retry attempts try a different replica for such cases? Sort of round robin between them in case of failure until all attempts are exhausted",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4910/comments",
    "author": "ofir-popowski",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-03-23T08:53:20Z",
        "body": "You need to specify all slave nodes in replicated configuration. Don't use \"replica.REDACTED.cache.amazonaws.com\" hostname. since it resolved only a single slave IP address"
      }
    ]
  },
  {
    "number": 4905,
    "title": "Redis4 cluster, redisson RQueue poll  jedis lpush data , Occasional data loss",
    "created_at": "2023-03-03T08:33:47Z",
    "closed_at": "2023-03-23T10:01:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4905",
    "body": "<dependency>\r\n                <groupId>org.redisson</groupId>\r\n                <artifactId>redisson-spring-boot-starter</artifactId>\r\n                <version>3.16.1</version>\r\n</dependency>\r\n\r\n<dependency>\r\n            <groupId>redis.clients</groupId>\r\n            <artifactId>jedis</artifactId>\r\n            <version>3.2.0</version>\r\n</dependency>",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4905/comments",
    "author": "ljq-dmr",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-03-03T08:36:12Z",
        "body": "Redisson 3.16.1 has a connection leak issue. Please update to the latest version"
      }
    ]
  },
  {
    "number": 4898,
    "title": "The reason  for linux nofiles leak",
    "created_at": "2023-03-01T03:12:50Z",
    "closed_at": "2023-03-27T10:32:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4898",
    "body": "I have a project that use old redission version 3.5.0，In the project i used redis sentinel mode, when i added redis slave node，the count of nofile increment and never reduced. There are a lot of anon pipe and eventpoll file descriptors.\r\nI tested a lot of redission versions and find the minimum fix version is 3.5.5, but i read the changelog and can not find relevant code. Can anyone tell me the reason ？ I want to find relevant code.\r\n\r\nproject dependencies:\r\nSpring-boot: 1.5.9\r\nredisson: 3.5.0\r\nOS: CentOS Linux release 7.9.2009\r\n\r\nP.S.\r\nwhen the nofile count incremented , there a lot of warning log:\r\no.r.c.SentinelConnectionManager          : Skipped slave up …… for master …… differs from current redis ……",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4898/comments",
    "author": "tubei",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-03-27T10:32:11Z",
        "body": "Sorry, can't help here"
      }
    ]
  },
  {
    "number": 4892,
    "title": "Getting RedisException: unexpected exception while processing command with ClassNotFoundException",
    "created_at": "2023-02-22T14:10:01Z",
    "closed_at": "2023-03-03T11:46:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4892",
    "body": "I'm using Redisson as client for AWS redis in a clustered mode. Many applications are deployed in clustered mode.\r\nRandomly getting classnotfound exception for some classes in another applications logs.\r\n\r\nRedisson : 3.18\r\n______________________________________________________________\r\nError: \r\nOrg.redisson.client.RedisException : unexpected exception while processing command\r\nOrg.springframework.core.serializer.support.SerializationFailedException : failed to deserialize object using custom deserializer. Object of type : null\r\nReason : Java.lang.ClassNotFoundException: com.xyz.MyClassImpl ( this class is seriazable already)\r\nAt org.redisson.command.commandAsyncService.convertException(CommandAsyncService.java:350)\r\n...\r\n...\r\nCaused by: Org.springframework.core.serializer.support.SerializationFailedException : failed to deserialize object using custom deserializer. Object of type : null\r\nAt io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n______________________________________________________________\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4892/comments",
    "author": "NehaChoudhary5",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-02-23T10:56:17Z",
        "body": "Can you share full stacktrace?"
      }
    ]
  },
  {
    "number": 4890,
    "title": "Switching from Redis 4 to 6, will Redisson have compatibility issues?",
    "created_at": "2023-02-22T13:23:12Z",
    "closed_at": "2023-02-23T07:23:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4890",
    "body": "Hi team, \r\n\r\nWe are going to upgrade Redis 4 to Redis 6. I would like to ask team if there will be compatibility issues between Redission and Redis 6 after upgrading 4 to 6. Or do you know of any known Redission incompatibilities due to Redis 6 upgrades?\r\nAccording to redission documentation, Redission supports Redis 4 and 6. Does this mean that we don't need to modify any client code? \r\n\r\nMany thanks for your support!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4890/comments",
    "author": "yunbozhang-msft",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-02-23T07:23:49Z",
        "body": "Hi,\r\n\r\nRedisson is fully compatible with 3.x up to 7.0.x version. No code modification is needed."
      },
      {
        "user": "yunbozhang-msft",
        "created_at": "2023-02-28T05:22:03Z",
        "body": "Thank you!"
      }
    ]
  },
  {
    "number": 4876,
    "title": "What is the most appropriate way to unlock the redisson?",
    "created_at": "2023-02-20T03:20:45Z",
    "closed_at": "2023-02-20T11:03:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4876",
    "body": "```\r\nsample A:\r\n            if ( lock.isHeldByCurrentThread()) {\r\n                lock.unlock();\r\n            }\r\n\r\nsample B:\r\n            if ( lock.isLocked() && lock.isHeldByCurrentThread()) {\r\n                lock.unlock();\r\n            }\r\n```\r\n\r\nwhich？ A or B?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4876/comments",
    "author": "cxyxd",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-02-20T11:03:14Z",
        "body": "Just a single line: `lock.unlock();`"
      },
      {
        "user": "cxyxd",
        "created_at": "2023-02-21T04:41:42Z",
        "body": " i think , \r\nJust a single line: lock.unlock();will meet some error,just like following example：\r\n\r\n\r\n```\r\n\r\n\r\npackage com.alibaba.demo;\r\n\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.LinkedBlockingQueue;\r\nimport java.util.concurrent.ThreadFactory;\r\nimport java.util.concurrent.ThreadPoolExecutor;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.junit.jupiter.api.BeforeAll;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.redisson.Redisson;\r\nimport org.redisson.api.RLock;\r\nimport org.redisson.api.RedissonClient;\r\nimport org.redisson.config.Config;\r\n\r\n/**\r\n * @program: parent_pro\r\n * @description:\r\n * @author: 渭水\r\n * @create: 2023/02/21\r\n */\r\n@Slf4j\r\npublic class RedissonTest {\r\n    static RedissonClient redissonClient;\r\n\r\n    static String lockName = \"myOrder_\" + System.currentTimeMillis();\r\n\r\n    /**\r\n     * 毫秒\r\n     */\r\n    static int firstLockLeastTime = 3000;\r\n\r\n    static private ExecutorService poolExecutor;\r\n\r\n    @Test\r\n    public void testIsLocked() throws InterruptedException {\r\n\r\n        poolExecutor.execute(RedissonTest::testRedisson);\r\n        Thread.sleep(firstLockLeastTime+50);\r\n\r\n        RLock lock2 = redissonClient.getLock(lockName);\r\n        try {\r\n            boolean result = lock2.tryLock(0, firstLockLeastTime, TimeUnit.MILLISECONDS);\r\n            log.info(\"lock:{} result:{} lock.isLocked():{} lock.isHeldByCurrentThread():{}\",\r\n                lock2,result,lock2.isLocked(),lock2.isHeldByCurrentThread());\r\n            Thread.sleep(firstLockLeastTime+1000);\r\n        }\r\n        finally {\r\n            log.info(\"finally lock:{} lock.isLocked():{} lock.isHeldByCurrentThread():{}\",\r\n                lock2,lock2.isLocked(),lock2.isHeldByCurrentThread());\r\n            if (lock2.isLocked() ){\r\n                lock2.unlock();\r\n            }\r\n        }\r\n        stopPoolAndRedisClient();\r\n    }\r\n\r\n    @BeforeAll\r\n    public static void beforeTest() {\r\n        Config config = new Config();\r\n        config.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");\r\n        redissonClient = Redisson.create(config);\r\n\r\n        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()\r\n            .setNameFormat(\"demo-pool-%d\").build();\r\n        poolExecutor = new ThreadPoolExecutor(3, 5,\r\n            5, TimeUnit.MILLISECONDS,\r\n            new LinkedBlockingQueue<>(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());\r\n\r\n    }\r\n\r\n    private static void stopPoolAndRedisClient()  {\r\n        redissonClient.shutdown();\r\n        poolExecutor.shutdown();\r\n    }\r\n\r\n    public static void testRedisson(){\r\n        RLock lock2 = redissonClient.getLock(lockName);\r\n        try {\r\n            boolean result = lock2.tryLock(0, firstLockLeastTime,TimeUnit.MILLISECONDS);\r\n            log.info(\" testRedisson lock:{} result:{} lock.isLocked():{} lock.isHeldByCurrentThread():{}\",\r\n                lock2,result,lock2.isLocked(),lock2.isHeldByCurrentThread());\r\n            Thread.sleep(firstLockLeastTime+1500);\r\n        }catch (Exception e){\r\n\r\n        } finally {\r\n            log.info(\"testRedisson finally lock:{} lock.isLocked():{} lock.isHeldByCurrentThread():{}\",\r\n                lock2,lock2.isLocked(),lock2.isHeldByCurrentThread());\r\n            if (lock2.isLocked() ){\r\n                lock2.unlock();\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```\r\nyou will get  attempt to unlock lock, not locked by current thread by node id:xx\r\n\r\nmaybe should use lock.isHeldByCurrentThread()\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2023-02-21T05:31:25Z",
        "body": "It's because of Thread.sleep(firstLockLeastTime+1000);"
      },
      {
        "user": "cxyxd",
        "created_at": "2023-02-22T09:18:56Z",
        "body": "@mrniko \r\n> Thread.sleep(firstLockLeastTime+1000) just simulate normal logic\r\n> \r\n> Even though my lock's least time is 10 second , but at some point my logic need 12 second when i try to unlock it ,the lock may be hold by another thread!so i believe isHeldByCurrentThread is best practice\r\n\r\n"
      }
    ]
  },
  {
    "number": 4869,
    "title": "Exception when I try to unlock an expired lock",
    "created_at": "2023-02-15T10:18:55Z",
    "closed_at": "2023-02-20T10:49:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4869",
    "body": "Hello,\r\n\r\nI'm using redisson 3.19.2 and I have this situation:\r\n\r\n```\r\nRLock lock = redissonClient.getLock(\"key\");\r\n        try{\r\n            lock.lock(10, TimeUnit.MINUTES);\r\n            //some execution that in some cases takes more than 10 minutes. The lock  can be released during this execution\r\n        }finally {\r\n            lock.unlock();\r\n        }\r\n```\r\nWhen the execution reaches the line lock.unlock(); it throws a java.lang.IllegalMonitorStateException because the lock is not locked anymore.\r\n\r\nSo, I put a conditional before the unlock call to avoid this Exception:\r\n\r\n```\r\nif(lock.isLocked()){ //or lock.isHeldByCurrentThread()\r\n  lock.unlock();\r\n}\r\n```\r\nBut now I'm facing problems with a rule in code analysis because the quality framework requires a call to lock.unlock(); without any conditionals.\r\n\r\nIs there any other way to try to unlock a lock expired by time without throws a IllegalMonitorStateException?\r\n\r\nOr should I increase the lock lease time in this situation?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4869/comments",
    "author": "witanrodrigues",
    "comments": [
      {
        "user": "cxyxd",
        "created_at": "2023-02-20T03:17:20Z",
        "body": "hi, i believe you should try to discuss this issue with the manager of the code analysis tool\r\n\r\nbecause，for redisson, you really should check the lock status before you  call unlock it!"
      },
      {
        "user": "mrniko",
        "created_at": "2023-02-20T10:49:09Z",
        "body": "> Or should I increase the lock lease time in this situation?\r\n\r\nI would recommend to increase lease time in this case."
      }
    ]
  },
  {
    "number": 4868,
    "title": "How should the password be encrypted in the redisson.yml",
    "created_at": "2023-02-15T08:55:01Z",
    "closed_at": "2023-02-20T10:49:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4868",
    "body": "How should the password be encrypted in the redisson.yml\r\nLike using jasypt to encrypt, but it doesn't work\r\n`          password: ENC(bupn8NNqnG8WVA8DyeBw11G6doJQoPd3sEt/UYtGzqSeh1AGFSArenBF7oCaDddl)\r\n`",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4868/comments",
    "author": "honghao12",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-02-20T10:49:48Z",
        "body": "passwords aren't encrypted"
      }
    ]
  },
  {
    "number": 4862,
    "title": "Serialization issue with redisson-spring-data hash value",
    "created_at": "2023-02-09T16:48:35Z",
    "closed_at": "2023-02-13T05:19:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4862",
    "body": "I'm trying to use redisson with spring data integration with @Cacheable annotations approach. \r\nBut when I save there data I see unprintable (Invalid UTF-32) symbols in the value: `p��A�`\r\nI have the next configuration.\r\nCache manager:\r\n```\r\n@Bean\r\npublic CacheManager customersCacheManager(RedissonClient redissonClient) {\r\n        Map<String, CacheConfig> config = new HashMap<>();\r\n        config.put(\"customers\", new CacheConfig(300 * 1000, 300 * 1000));\r\n        Codec codec = new TypedJsonJacksonCodec(String.class, Customer.class);\r\n        return new RedissonSpringCacheManager(redissonClient, config, codec);\r\n}\r\n```\r\nCached api: \r\n```\r\n@Cacheable(value = \"customers\", cacheManager = \"customersCacheManager\")\r\npublic CustomerPackagesStatusResponse getCustomerByName(@NonNull String customerName) {\r\n           return new Customer(customerName, 40);\r\n}\r\n```\r\nAs a result I see hash entity in redis with `customers` key, and inside key: `Ben` and a value `p��A�\u0002{\"name\": `\r\n\r\nThe problem is when I use `redisson` client to iterate over customers:\r\n```\r\nCodec codec = new TypedJsonJacksonCodec(String.class, Customer.class);\r\nRMap<Object, Object> map = redisson.getMap(\"customers\", codec);\r\nSet<Object> keySet = map.keySet();\r\nlog.info(\"keys: {}\", keySet);\r\n```\r\n I get the deserialization error:\r\n```\r\no.r.client.handler.CommandDecoder --- Unable to decode data. channel: [id: 0x19159e2b, L:/127.0.0.1:50289 - R:localhost/127.0.0.1:6379], reply: ReplayingDecoderByteBuf(ridx=4623, widx=4623), command: (HSCAN), promise: java.util.concurrent.CompletableFuture@3fbc351e[Not completed, 1 dependents], params: [comaMultiTypeContents, 0, COUNT, 10]\r\njava.io.CharConversionException: Invalid UTF-32 character 0x70989441 (above 0x0010ffff) at char #1, byte #7)\r\n```\r\n\r\nIf I write value with the obtained RMap object it stores it as a json sting without any unprintable symbols and I can fetch it.\r\n\r\nBy the way: why redisson uses `HSCAN` operation instead of `HGETALL` on map.keySet() operation?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4862/comments",
    "author": "serjsamoshkin",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-02-13T04:58:04Z",
        "body": "Let me check that.\r\n\r\nHGETALL is used in readAllMap method."
      },
      {
        "user": "mrniko",
        "created_at": "2023-02-13T05:19:46Z",
        "body": "Here is the correct way of iteration:\r\n\r\n```java\r\n        CacheManager cm = context.getBean(CacheManager.class);\r\n        Cache tm = cm.getCache(\"customers\");\r\n        RMap<Object, Object> map = (RMap<Object, Object>) tm.getNativeCache();\r\n        Set<Object> keySet = map.keySet();\r\n        for (Object o : keySet) {\r\n            System.out.println(\"key: \" + o);\r\n\r\n        }\r\n```"
      }
    ]
  },
  {
    "number": 4858,
    "title": "Why not support stack pushing？",
    "created_at": "2023-02-09T06:47:16Z",
    "closed_at": "2023-02-13T08:42:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4858",
    "body": "for example:\r\nredisTemplate.opsForList().leftPush(key, value);\r\nredisTemplate.opsForList().leftPop(key);\r\n\r\nIs it not encapsulated or not supported in Redirection？",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4858/comments",
    "author": "viveyeS",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-02-09T06:53:54Z",
        "body": "These commands are implemented. Can you share the code to reproduce the issue? And what the issue is?"
      }
    ]
  },
  {
    "number": 4857,
    "title": "How to upgrade Redisson client in an application using LZ4Codec",
    "created_at": "2023-02-08T23:28:59Z",
    "closed_at": "2023-02-09T06:03:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4857",
    "body": "The current Redisson client version in our application is 3.18.1. After upgrading the client version to 3.19.3, deserialization failure happened when reading the data that was saved by version 3.18.1. We use the Redisson client extension for Quarkus. We use LZ4Codec to read and write data. The configuration is \"quarkus.redisson.codec=org.redisson.codec.LZ4Codec\".\r\n\r\nThe value that is saved to Redis is a string like this:\r\n\"1675896840000:{2126=42448.0, 2127=103265.0, 2128=168.0, 2129=230.0};1675896840000:{2128=0.0667, 2129=0.0833, 2126=7.2167, 2127=90.0667}\"\r\n\r\nThe error message when reading the data is \"java.lang.ClassCastException: class java.lang.Float cannot be cast to class java.lang.String\". \r\n\r\nWe suspect that this breakage is caused by the change of the default codec to Kryo5Codec, as it's mentioned in the documentation that the LZ4 codec uses Kryo5codec for serialization. \r\n\r\nWe would like our data to be interpreted correctly when we upgrade to a newer library version. Please suggest what options are available to us.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4857/comments",
    "author": "sara-han",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-02-09T06:03:19Z",
        "body": "You need to extend LZ4Codec and specify old MarshallingCodec in constructor."
      }
    ]
  },
  {
    "number": 4856,
    "title": "Redisson does it have multi az awareness",
    "created_at": "2023-02-08T20:14:23Z",
    "closed_at": "2023-02-13T08:42:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4856",
    "body": "We have two hot deployments in two separate az s in aws west. We failover our whole deployment from az1 to az2 when needed. Since elastic cache costs for az to az transfer(from our services running in ec2 which read/write to redis using redisson), is there a best practice or does redisson have az awareness(it knows to connect to the same side az)? This is to avoid data transfer costs when failing over.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4856/comments",
    "author": "formanojhr",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-02-09T10:23:46Z",
        "body": "You can have Redisson instance per deployment and switch between them."
      }
    ]
  },
  {
    "number": 4852,
    "title": "Unable to write command into connection!",
    "created_at": "2023-02-08T07:27:39Z",
    "closed_at": "2023-02-13T08:45:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4852",
    "body": "Hi，\r\nI have a question about `Unable to write command into connection!`(IP addresses hidden)\r\n\r\n\r\n```\r\norg.springframework.data.redis.RedisConnectionFailureException: Unable to write command into connection! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@1668644662 [redisClient=[addr=redis://x.x.x.x:x], channel=[id: 0xcefb2389, L:/x.x.x.x:58914 ! R:/x.x.x.x:x], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@7d50c4d0(failure: java.util.concurrent.CancellationException)], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]], command: (GET), params: [[111, 114, 103, 95, 112, 97, 114, 97, 109, 101, ...]] after 3 retry attempts; nested exception is org.redisson.client.WriteRedisConnectionException: Unable to write command into connection! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@1668644662 [redisClient=[addr=redis://x.x.x.x:x], channel=[id: 0xcefb2389, L:/x.x.x.x:58914 ! R:/x.x.x.x:x], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@7d50c4d0(failure: java.util.concurrent.CancellationException)], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]], command: (GET), params: [[111, 114, 103, 95, 112, 97, 114, 97, 109, 101, ...]] after 3 retry attempts\r\n\tat org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:40)\r\n\tat org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:35)\r\n\tat org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:44)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.transform(RedissonConnection.java:197)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.syncFuture(RedissonConnection.java:192)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.sync(RedissonConnection.java:358)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.read(RedissonConnection.java:739)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.get(RedissonConnection.java:473)\r\n\tat org.springframework.data.redis.connection.DefaultStringRedisConnection.get(DefaultStringRedisConnection.java:398)\r\n\tat org.springframework.data.redis.core.DefaultValueOperations$1.inRedis(DefaultValueOperations.java:57)\r\n\tat org.springframework.data.redis.core.AbstractOperations$ValueDeserializingRedisCallback.doInRedis(AbstractOperations.java:60)\r\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:228)\r\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:188)\r\n\tat org.springframework.data.redis.core.AbstractOperations.execute(AbstractOperations.java:96)\r\n\tat org.springframework.data.redis.core.DefaultValueOperations.get(DefaultValueOperations.java:53)\r\n\tat com.ichoice.hsp.cache.utils.RedisUtil.getStr(RedisUtil.java:47)\r\n\tat com.ichoice.hsp.payment.serviceimpl.SelfServiceImpl.hospitalUnpaidInfo(SelfServiceImpl.java:501)\r\n\tat com.ichoice.hsp.payment.serviceimpl.SelfServiceImpl$$FastClassBySpringCGLIB$$4f12c82e.invoke(<generated>)\r\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:366)\r\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:118)\r\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n\tat com.ichoice.hsp.payment.serviceimpl.SelfServiceImpl$$EnhancerBySpringCGLIB$$5f129e72.hospitalUnpaidInfo(<generated>)\r\n\tat com.ichoice.hsp.payment.controller.SelfServiceController.hospitalUnpaidInfo$original$PnIefFRm(SelfServiceController.java:115)\r\n\tat com.ichoice.hsp.payment.controller.SelfServiceController.hospitalUnpaidInfo$original$PnIefFRm$accessor$8DKa58kB(SelfServiceController.java)\r\n\tat com.ichoice.hsp.payment.controller.SelfServiceController$auxiliary$2bTYP5Lq.call(Unknown Source)\r\n\tat org.apache.skywalking.apm.agent.core.plugin.interceptor.enhance.InstMethodsInter.intercept(InstMethodsInter.java:86)\r\n\tat com.ichoice.hsp.payment.controller.SelfServiceController.hospitalUnpaidInfo(SelfServiceController.java)\r\n\tat com.ichoice.hsp.payment.controller.SelfServiceController$$FastClassBySpringCGLIB$$8fa799b5.invoke(<generated>)\r\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n\tat org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88)\r\n\tat com.ichoice.hsp.payment.annotation.FeishuMessageAspect.doAround(FeishuMessageAspect.java:50)\r\n\tat sun.reflect.GeneratedMethodAccessor4164.invoke(Unknown Source)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644)\r\n\tat org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633)\r\n\tat org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)\r\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\r\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n\tat org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)\r\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\r\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n\tat org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88)\r\n\tat com.ichoice.hsp.common.log.aop.LogstashAop.around(LogstashAop.java:93)\r\n\tat sun.reflect.GeneratedMethodAccessor361.invoke(Unknown Source)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644)\r\n\tat org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633)\r\n\tat org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)\r\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n\tat org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)\r\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n\tat com.ichoice.hsp.payment.controller.SelfServiceController$$EnhancerBySpringCGLIB$$962cb93e.hospitalUnpaidInfo(<generated>)\r\n\tat sun.reflect.GeneratedMethodAccessor4592.invoke(Unknown Source)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\r\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)\r\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)\r\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\r\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n\tat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:665)\r\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:750)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat com.ichoice.hsp.common.trace.filter.TraceFilter.doFilterInternal(TraceFilter.java:44)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:124)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:109)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat com.ichoice.hsp.common.api.request.filter.RequestDetailFilter.doFilter(RequestDetailFilter.java:73)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)\r\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\r\n\tat org.apache.catalina.core.StandardHostValve.invoke$original$GHoSjVbi(StandardHostValve.java:139)\r\n\tat org.apache.catalina.core.StandardHostValve.invoke$original$GHoSjVbi$accessor$d7Eb6dAN(StandardHostValve.java)\r\n\tat org.apache.catalina.core.StandardHostValve$auxiliary$YeivbgS7.call(Unknown Source)\r\n\tat org.apache.skywalking.apm.agent.core.plugin.interceptor.enhance.InstMethodsInter.intercept(InstMethodsInter.java:86)\r\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java)\r\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)\r\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\r\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373)\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594)\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: org.redisson.client.WriteRedisConnectionException: Unable to write command into connection! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@1668644662 [redisClient=[addr=redis://x.x.x.x:x], channel=[id: 0xcefb2389, L:/x.x.x.x:58914 ! R:/x.x.x.x:x], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@7d50c4d0(failure: java.util.concurrent.CancellationException)], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]], command: (GET), params: [[111, 114, 103, 95, 112, 97, 114, 97, 109, 101, ...]] after 3 retry attempts\r\n\tat org.redisson.command.RedisExecutor.checkWriteFuture(RedisExecutor.java:271)\r\n\tat org.redisson.command.RedisExecutor.access$100(RedisExecutor.java:58)\r\n\tat org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:156)\r\n\tat org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:153)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)\r\n\tat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)\r\n\tat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)\r\n\tat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:993)\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:865)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764)\r\n\tat io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1104)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\t... 1 common frames omitted\r\nCaused by: java.nio.channels.ClosedChannelException: null\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.newClosedChannelException(AbstractChannel.java:957)\r\n\t... 12 common frames omitted\r\n```\r\n\r\n\r\n**Redisson configuration**\r\n```\r\nsingleServerConfig:\r\n  idleConnectionTimeout: 10000\r\n  connectTimeout: 10000\r\n  timeout: 3000\r\n  retryAttempts: 3\r\n  retryInterval: 1500\r\n  password: xx-xx-xx-xx\r\n  subscriptionsPerConnection: 50\r\n  clientName: null\r\n  address: \"redis://x.x.x.x:x\"\r\n  subscriptionConnectionMinimumIdleSize: 1\r\n  subscriptionConnectionPoolSize: 1000\r\n  connectionMinimumIdleSize: 64\r\n  connectionPoolSize: 64\r\n  database: 0\r\n  dnsMonitoringInterval: 5000\r\n  #连接间隔 心跳\r\n  pingConnectionInterval: 1000\r\nthreads: 0\r\nnettyThreads: 0\r\ncodec: !<org.redisson.codec.JsonJacksonCodec> {}\r\ntransportMode: NIO\r\n```\r\n\r\n\r\n**Redis version**\r\n`6.2.7`\r\n\r\n**Redisson version**\r\n`3.14.1`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4852/comments",
    "author": "xiahuhu1",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-02-08T08:19:30Z",
        "body": "Caused by: java.nio.channels.ClosedChannelException: null\r\n"
      }
    ]
  },
  {
    "number": 4849,
    "title": "Redisson Tomcat Session manager slow recovery on connecting to Redis when failover happen",
    "created_at": "2023-02-07T14:19:16Z",
    "closed_at": "2023-02-13T08:47:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4849",
    "body": "## Slow recovery on connecting to Redis when failover happens \r\n### Scenario:\r\n- Failover on AWS MemoryDB (only 2 node MASTER+SLAVE) ~ took around 8 seconds\r\n- Our app getting RedisResponseTimeoutException\r\n- The app keep failing after whole minute even though the failover only 8 seconds\r\n\r\n### Question\r\n- Why it took so long for the app to recover when the failover is quite fast?\r\n- Is there a configuration to make the recovery time/check faster?\r\n\r\n### What we used:\r\n- Redisson tomcat session manager version 3.17.7 (first time we used) -> 3.19.1 (upgraded but still persist)\r\n- AWS Memory DB\r\n- We only use Redis for the tomcat session at this app\r\n- config that might be affecting this:\r\n```\r\n    \"failedSlaveReconnectionInterval\": 3000,\r\n    \"failedSlaveCheckInterval\": 60000,\r\n    \"readMode\": \"SLAVE\",\r\n    \"subscriptionMode\": \"SLAVE\",\r\n```\r\n\r\n### Typical Exception we got:\r\n```\r\n{\"time\": \"2023-01-16 15:07:50,499\", \"level\": \"ERROR\", \"message\": \"Unable to execute (CLUSTER NODES)org.redisson.client.RedisTimeoutException: Command execution timeout for command: (CLUSTER NODES), Redis client: [addr=some-ip-here]\"}\r\n\r\n{\"@timestamp\":\"2023-01-16T15:08:04.926Z\",\"thread_name\":\"http-nio-8080-exec-10\",\"level\":\"ERROR\",\"stack_trace\":\"o.r.c.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured after 3 retry attempts, is non-idempotent command: false Check connection with Redis node: some-ip-here for TCP packet drops.  Try to increase nettyThreads and/or timeout settings. Command: (HMSET), params: [some-params-here\"}\r\n\r\n{\"@timestamp\":\"2023-01-16T15:08:04.938Z\",\"@version\":\"1\",\"message\":\"RedisResponseTimeoutException occurred when processing request: [GET] /alive/json\\nRedis server response timeout (3000 ms) occured after 3 retry attempts, is non-idempotent command: false Check connection with Redis node: some-ip-here for TCP packet drops.  Try to increase nettyThreads and/or timeout settings. Command: (HMSET)\"}\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4849/comments",
    "author": "ls-rein-martha",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-02-13T08:47:55Z",
        "body": "you can adjust `scanInterval` and `retryAttempts` settings to survive failover."
      }
    ]
  },
  {
    "number": 4841,
    "title": "RedisTimeoutException: Unable to acquire connection! java.util.concurrent.CompletableFuture",
    "created_at": "2023-02-06T03:58:12Z",
    "closed_at": "2023-02-06T07:07:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4841",
    "body": "# Error message\r\n```\r\norg.redisson.client.RedisTimeoutException: Unable to acquire connection! java.util.concurrent.CompletableFuture@274f4fc8[Completed exceptionally: java.util.concurrent.CancellationException]Increase connection pool size. Node source: NodeSource [slot=6574, addr=redis://10.30.16.84:11100, redisClient=null, redirect=MOVED, entry=null], command: (GET), params: [bfs:exp:152220230202150633545] after 3 retry attempts\r\n\tat org.redisson.command.RedisExecutor$1.run(RedisExecutor.java:241)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715)\r\n\tat io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790)\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:844)\r\n```\r\n\r\n# Actual behavior\r\n\r\n- When we try to expand the redis cluster (change from 3 masters and 3 slaves to 4 masters and 4 slaves), the above error query exceptions will appear several times during the expansion process of the get command\r\n\r\n# Expected behavior\r\n\r\n- Query succeeded during capacity expansion\r\n\r\n# Pro config\r\n\r\n- Config\r\n```\r\nclusterServersConfig:\r\n  idleConnectionTimeout: 10000\r\n  connectTimeout: 10000\r\n  timeout: 3000\r\n  retryAttempts: 3\r\n  retryInterval: 1500\r\n  failedSlaveReconnectionInterval: 3000\r\n  failedSlaveCheckInterval: 60000\r\n  password: drG3rhu5==12x\r\n  subscriptionsPerConnection: 5\r\n  clientName: test\r\n  loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> { }\r\n  subscriptionConnectionMinimumIdleSize: 1\r\n  subscriptionConnectionPoolSize: 50\r\n  slaveConnectionMinimumIdleSize: 24\r\n  slaveConnectionPoolSize: 64\r\n  masterConnectionMinimumIdleSize: 24\r\n  masterConnectionPoolSize: 64\r\n  readMode: \"MASTER\"\r\n  subscriptionMode: \"SLAVE\"\r\n  nodeAddresses:\r\n    - \"redis://redis-node1-svc-11100.insure.ts.lan:11100\"\r\n    - \"redis://redis-node2-svc-11100.insure.ts.lan:11100\"\r\n    - \"redis://redis-node3-svc-11100.insure.ts.lan:11100\"\r\n    - \"redis://redis-node4-svc-11100.insure.ts.lan:11100\"\r\n    - \"redis://redis-node5-svc-11100.insure.ts.lan:11100\"\r\n    - \"redis://redis-node6-svc-11100.insure.ts.lan:11100\"\r\n  scanInterval: 10000\r\n  pingConnectionInterval: 0\r\n  keepAlive: false\r\n  tcpNoDelay: false\r\n``` \r\n\r\n- Version\r\n```\r\n       <dependency>\r\n            <groupId>org.redisson</groupId>\r\n            <artifactId>redisson-spring-boot-starter</artifactId>\r\n            <version>3.17.7</version>\r\n            <exclusions>\r\n                <exclusion>\r\n                    <groupId>org.redisson</groupId>\r\n                    <artifactId>redisson-spring-data-27</artifactId>\r\n                </exclusion>\r\n            </exclusions>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.redisson</groupId>\r\n            <artifactId>redisson-spring-data-18</artifactId>\r\n            <version>3.17.7</version>\r\n        </dependency>\r\n```\r\n\r\nCan you give me some advice, thank you very much",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4841/comments",
    "author": "GHQiuJun",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-02-06T07:07:34Z",
        "body": "Increase retryAttempts setting to survive failover process."
      }
    ]
  },
  {
    "number": 4832,
    "title": "How to work around `RPriorityBlockingQueue#contains` behaving differently from `BlockingQueue#contains`?",
    "created_at": "2023-02-01T14:43:42Z",
    "closed_at": "2023-03-27T05:47:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4832",
    "body": "### Problem Statement \r\n\r\nI'm using Redisson's `RPriorityBlockingQueue` to replace an existing Java-standard  `BlockingQueue` (a `PriorityBlockingQueue` to be exact). I found the following difference in behaviour :  Java's  `PriorityBlockingQueue#contains` relies on the `equals` method of the queued objects, whereas `RPriorityBlockingQueue#contains` relies on the `compareTo` method of the queued objects. This is creating problems. \r\n\r\n* Is this behaviour by design? \r\n* How can I work around this to get the following effects?\r\n    1. Queue checks if it `contains` something using `equals`\r\n    2. Queue uses `compareTo` to sort objects when `poll`ed \r\n\r\nSee code below for a working example of the problem. \r\n\r\n```java\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Objects;\r\n\r\nimport org.redisson.Redisson;\r\nimport org.redisson.api.RPriorityBlockingQueue;\r\nimport org.redisson.api.RedissonClient;\r\n\r\npublic class RedissonExperiment {\r\n\r\n    public static void main(final String[] args) {\r\n        final RedissonClient redisson = Redisson.create();\r\n\r\n        final RPriorityBlockingQueue<Entry> queue = redisson.getPriorityBlockingQueue(\"testQueue\");\r\n        queue.offer(new Entry(\"a\", 2));\r\n        queue.offer(new Entry(\"b\", 1));\r\n        queue.offer(new Entry(\"c\", 0));\r\n\r\n        // Must use `equals` to check `contains`\r\n        System.out.println(queue.contains(new Entry(\"a\", 200))); // Expected: `true`. Actual: `false`.\r\n        System.out.println(queue.contains(new Entry(\"d\", 0))); // Expected: `false`. Actual: `true`.\r\n\r\n        // Must print c, b, a using `compareTo`\r\n        while (queue.peek() != null) {\r\n            final Entry item = queue.poll();\r\n            System.out.println(\"item: \" + item);\r\n        }\r\n\r\n        System.out.println(\"Done\");\r\n        redisson.shutdown();\r\n\r\n    }\r\n\r\n}\r\n\r\nclass Entry implements Comparable<Entry>, Serializable {\r\n\r\n    private final String key;\r\n\r\n    private final Integer value;\r\n\r\n    public Entry(final String key, final Integer value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(final Entry o) {\r\n        return value.compareTo(o.value);\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(final Object o) {\r\n        if (this == o) {return true;}\r\n        if (o == null || getClass() != o.getClass()) {return false;}\r\n        final Entry entry = (Entry) o;\r\n        return key.equals(entry.key);\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return Objects.hash(key);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Entry{\" + \"key='\" + key + '\\'' + \", value=\" + value + '}';\r\n    }\r\n}\r\n``` ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4832/comments",
    "author": "egmanoj",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-03-27T05:47:32Z",
        "body": "> Is this behaviour by design?\r\n\r\nYes. RPriorityBlockingQueue#contains relies on the `compare` method to not iterate over all elements.\r\n\r\n> Queue checks if it contains something using equals\r\n\r\nYou can use RPriorityBlockingQueue#readAll() method and then call contains on result List.\r\n\r\n> Queue uses compareTo to sort objects when polled\r\n\r\nI'm afraid there is no workaround for this.\r\n"
      }
    ]
  },
  {
    "number": 4829,
    "title": "Redisson Cluster Master-Slave Switchover Issue",
    "created_at": "2023-01-31T15:10:13Z",
    "closed_at": "2023-02-01T06:18:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4829",
    "body": "******************************************************************************************************************************************************************************************\r\nExpected Scenario, Everthings works fine\r\n    Sentinels\r\n    vm-16 (Master)\r\n    vm-17\r\n    vm-18\r\nApp_instance_1 in vm15 -> Redission client is connected to vm-16\r\nApp_instance_2 in vm14 -> Redission client is connected to vm-16\r\n\r\nExpected Behaviour\r\n    After the redis master switch over the client connections are refreshed correctly\r\n\r\n******************************************************************************************************************************************************************************************\r\n\r\nCurrent Scenario, A swithover is triggered as vm-16 is rebooted\r\n    Sentinels\r\n    vm-16 \r\n    vm-17 (Master)\r\n    vm-18\r\nApp_instance_1 in vm15 -> Redission client is still connected to vm-16\r\nApp_instance_2 in vm14 -> Redission client is connected to vm-17\r\nCalls from App_instance_2 is succuessful where as calls from App_instance_1 is failing as write is not allowed. The switchover in the redission client was visible only in App_instance_2\r\n\r\nCurrent Behaviour\r\n    Only in one instance the refresh was visible and not in the other instance. Only when App_instance_1 was restarted it started to work as it got connected to the right master.\r\n\r\nRedisson version - 3.16.2\r\n******************************************************************************************************************************************************************************************",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4829/comments",
    "author": "sray3546",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-02-01T06:18:38Z",
        "body": "3.16.1, 3.16.2 has connection leak problem. You need to update version"
      }
    ]
  },
  {
    "number": 4800,
    "title": "Dealing with JSon and not needing an object",
    "created_at": "2023-01-18T04:46:50Z",
    "closed_at": "2023-01-18T06:49:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4800",
    "body": "It looks like to handle a JsonBucket you have to type it to a Java Object. I don't need to type the value in the bucket to a Java Object. I still want to use all the JSON commands from Redis:\r\n\r\nJSON.ARRAPPEND\r\nJSON.ARRINDEX\r\nJSON.ARRINSERT\r\nJSON.ARRLEN\r\nJSON.ARRPOP\r\nJSON.ARRTRIM\r\nJSON.CLEAR\r\nJSON.GET\r\nJSON.NUMINCRBY\r\nJSON.OBJLEN\r\nJSON.OBJKEYS\r\nJSON.SET\r\nJSON.STRAPPEND\r\nJSON.STRLEN\r\nJSON.TOGGLE\r\nJSON.TYPE\r\n\r\nIf I need to get the value out of the bucket I would get the JSON String and not serialize it to a Java Object. Is this possible in Redisson? \r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4800/comments",
    "author": "jdtommy",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-01-18T05:29:30Z",
        "body": "You can get Json in String format using StringCodec.\r\n\r\n```java\r\n        RJsonBucket<String> b = redisson.getJsonBucket(\"test\", StringCodec.INSTANCE);\r\n```"
      },
      {
        "user": "jdtommy",
        "created_at": "2023-01-18T06:03:00Z",
        "body": "Hmm.. When I use that codec and try the incrementAndGet I get an error:\r\n\r\n```Jan 17, 2023 10:57:01 PM org.redisson.client.handler.ErrorsLoggingHandler exceptionCaught\r\nSEVERE: Exception occured. Channel: [id: 0xf50a47d3, L:/139.126.119.4:62185 - R:master.redis-dev-uswest2.c8hq6t.usw2.cache.amazonaws.com/100.99.60.59:6379]\r\nio.netty.handler.codec.DecoderException: java.lang.NumberFormatException: For input string: \"[7]\"\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\r\n\tat io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1373)\r\n\tat io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1236)\r\n\tat io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1285)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:529)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:468)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.lang.NumberFormatException: For input string: \"[7]\"\r\n\tat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\r\n\tat java.lang.Integer.parseInt(Integer.java:580)\r\n\tat java.lang.Integer.parseInt(Integer.java:615)\r\n\tat org.redisson.client.protocol.convertor.NumberConvertor.convert(NumberConvertor.java:42)\r\n\tat org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:456)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:392)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:205)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:144)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:120)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:529)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\t... 26 more\r\n\r\nException in thread \"main\" org.redisson.client.RedisException: Unexpected exception while processing command\r\n\tat org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:276)\r\n\tat org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:115)\r\n\tat org.redisson.RedissonObject.get(RedissonObject.java:83)\r\n\tat org.redisson.RedissonJsonBucket.incrementAndGet(RedissonJsonBucket.java:706)\r\n\tat MainKt.main(Main.kt:38)\r\nCaused by: java.lang.NumberFormatException: For input string: \"[7]\"\r\n\tat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\r\n\tat java.lang.Integer.parseInt(Integer.java:580)\r\n\tat java.lang.Integer.parseInt(Integer.java:615)\r\n\tat org.redisson.client.protocol.convertor.NumberConvertor.convert(NumberConvertor.java:42)\r\n\tat org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:456)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:392)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:205)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:144)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:120)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:529)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\r\n\tat io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1373)\r\n\tat io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1236)\r\n\tat io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1285)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:529)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:468)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n```\r\n**Kotlin Code:**\r\n```var client: RedissonClient? = null\r\n    try {\r\n        val redissonConfig = Config()\r\n        val replicatedConfig = redissonConfig.useReplicatedServers()\r\n        replicatedConfig.connectTimeout = 20000\r\n\r\n        replicatedConfig.addNodeAddress(\"rediss://master:6379\")\r\n        replicatedConfig.addNodeAddress(\"rediss://replica:6380\")\r\n\r\n        client = Redisson.create(redissonConfig)\r\n\r\n        val result = client.getRedisNodes(RedisNodes.MASTER_SLAVE).pingAll()\r\n\r\n        println(\"result = $result\")\r\n\r\n        val key = \"jarad_json_test\"\r\n\r\n        client.keys.delete(key)\r\n\r\n        val jsonBucket = client.getJsonBucket(key, StringCodec.INSTANCE)\r\n        jsonBucket.set(\"$\", \"{\\\"value\\\": 5}\")\r\n\r\n        val newValue = jsonBucket.incrementAndGet(\"$.value\", 2)\r\n\r\n        println(\"newValue = $newValue\")\r\n        println(\"jsonBucketType = ${jsonBucket.type}\")\r\n        println(\"jsonBucket = ${jsonBucket.get()}\")\r\n    } finally {\r\n        client?.shutdown()\r\n    }\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2023-01-18T06:49:20Z",
        "body": "Here is the working way.\r\n```java\r\nInteger newValue = jsonBucket.incrementAndGet(\"value\", 2);\r\n```\r\n$ prefix returns array in result."
      }
    ]
  },
  {
    "number": 4795,
    "title": "What is the correct way to use redissonClient.getKeys().getKeys() with a namemapper that wants to ignore some keys?",
    "created_at": "2023-01-15T02:35:39Z",
    "closed_at": "2023-03-27T10:54:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4795",
    "body": "In 3.18.1 it looks like RKeys started using a namemapper. We have a namemapper that adds a prefix during `map` and removes that prefix during `unmap`. However now since RKeys now uses the namemapper to `unmap` the keys it sees in redis, our namemapper is getting `unmap` called for all keys, including keys that aren't in scope for this namemapper (don't have this prefix). What is the best way to handle this?\r\n\r\nWe are using the namemapper to logically split the redis instance into different environments (dev, prod) so when we call getKeys().getKeys() ideally we only get the keys in the current environment. Previously we were getting all keys, so we checked manually in the return of getKeys() that it was part of this environment, but now that namemapper `unmap` gets it, i don't see a way for us to tell redisson to ignore this key. (Our namemapper threw a RuntimeException in `unmap` when this happens and now that starts getting hit and throwing - and throwing an exception will cause getKeys().getKeys() to propagate that exception up instead of ignoring the key)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4795/comments",
    "author": "chaimmintz",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-01-16T06:19:03Z",
        "body": "> Previously we were getting all keys, so we checked manually in the return of getKeys() that it was part of this environment\r\n\r\nCan you check it in `org.redisson.api.NameMapper#unmap()` method?"
      },
      {
        "user": "chaimmintz",
        "created_at": "2023-01-16T12:23:50Z",
        "body": "what should unmap do if the given key doesn't have the right prefix?"
      },
      {
        "user": "mrniko",
        "created_at": "2023-01-16T14:05:53Z",
        "body": "just return it unchanged."
      },
      {
        "user": "chaimmintz",
        "created_at": "2023-01-16T15:41:08Z",
        "body": "But then getAllKeys will return it as is unchanged, but it isn't a correct key for my caller to ever actually be able to retrieve because if it tries to retrieve it it will add back in the real prefix and never be able to get it. I feel like we need a way for the namemapper to return \"not my key, ignore it\" so getAllKeys ignores it. Also happens for the internal keys that redisson creates with curly brackets around the name, for locks and internal stuff.\r\n\r\nI can have our namemapper return some constant value like NOT_OUR_KEY and then have our caller check for that value and ignore it, but it feels a little hokey."
      },
      {
        "user": "mrniko",
        "created_at": "2023-01-17T04:49:07Z",
        "body": "In nameMapper methods you need to detect if prefix is needed or not either key has it or not."
      }
    ]
  },
  {
    "number": 4789,
    "title": "org.redisson.config.SingleServerConfig class has no public constructor",
    "created_at": "2023-01-12T06:05:23Z",
    "closed_at": "2024-06-06T07:16:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4789",
    "body": "org.redisson.config.SingleServerConfig class has no public constructor\r\nCan't extends\r\nCan add it？",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4789/comments",
    "author": "zengyf01",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-06-06T07:16:58Z",
        "body": "SingleServerConfig isn't suitable for extension."
      }
    ]
  },
  {
    "number": 4786,
    "title": "Question about RMapCache and containsKey",
    "created_at": "2023-01-10T21:57:40Z",
    "closed_at": "2023-01-11T06:34:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4786",
    "body": "I am trying to figure out how redisson takes a custom object and makes that into a key.  In my code I have implemented hashCode and equals method but when my subclass is saved as a key and then the parent class is used to try and access it, containsKey returns false even though both equals and hashcode are implemented and equal each other.  \r\n\r\nIve tried using custom writeObject and readObject but that didn't work either.\r\n\r\nWhen coming from caffeine we just had to implement a comparator and that worked but I'm not sure if I can do something similar for this.\r\n\r\nExample class:\r\n```\r\npublic class BytesKey extends ... implements Comparable<BytesKey>, Serializable {\r\nprotected int hashCode;\r\npublic BytesKey(byte[] bytes) {\r\n    super(bytes);\r\n    this.hashCode = super.hashCode();\r\n  }\r\n\r\n@Override\r\n  public int hashCode() {\r\n    return hashCode;\r\n  }\r\n@Override\r\n  public boolean equals(Object o) {\r\n    int test = o.hashCode();\r\n    return this.hashCode == o.hashCode();\r\n  }\r\n\r\n  private void writeObject(ObjectOutputStream oos) throws Exception\r\n  {\r\n    oos.writeObject(bytes);\r\n    oos.writeObject(hashCode);\r\n  }\r\n\r\n  private void readObject(ObjectInputStream ois) throws Exception\r\n  {\r\n    // performing default deserialization of Account object\r\n    bytes = (byte[]) ois.readObject();\r\n    hashCode = (int) ois.readObject();\r\n  }\r\n}\r\n```\r\n\r\nSubclass\r\n```\r\nprivate static class InternedBytesKey extends BytesKey implements Serializable {\r\nInternedBytesKey(byte[] bytes) {\r\n      super(bytes);\r\n    }\r\n...\r\n}\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4786/comments",
    "author": "rrourke",
    "comments": [
      {
        "user": "rrourke",
        "created_at": "2023-01-10T22:03:45Z",
        "body": "Just to follow up, I'm trying to figure out how Redisson determines how to convert an object into a key?"
      },
      {
        "user": "mrniko",
        "created_at": "2023-01-11T06:24:07Z",
        "body": "Redis uses serialized state to check object uniqueness instead of `hashCode()`/`equals()` methods."
      }
    ]
  },
  {
    "number": 4785,
    "title": "how to avoid getting ClassCastException while reading values from RList<String>",
    "created_at": "2023-01-10T10:02:33Z",
    "closed_at": "2023-01-19T08:27:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4785",
    "body": "We are using RList<String> to store some UUIDs. Every once in a while (once a month or so) the state of the RList seems to get corrupted and when we try to access the String values from the list we get ClassCastExceptions that tell us that you can't cast a java.lang.Float to a java.lang.String.\r\n\r\nWe're now wondering what may be the source of this problem, because we are sure that we don't put Float values into the list ourselves. This is the code in question, it gets the List from the Redis server and checks if a given UUID is contained in that list:\r\n\r\n`\r\n\tpublic boolean runningRequestExists(Agency agency, Client client, Company company, ResultContent resultContent, String customerId) {\r\n\r\n\t\tif (!isEnabled)\r\n\t\t\treturn false;\r\n\r\n\t\tString uid = getUid(agency, client, company, resultContent, customerId, false);\r\n\r\n\t\tRedissonClient rc = getClient();\r\n\t\tif (rc == null) {\r\n\t\t\tlog.error(\"could not check running request, because client was null.\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tRList<String> list = redisson.getList(SET_IDENTIFIER);\r\n\t\tif (list == null) {\r\n\t\t\tlog.error(\"could not check running request, because list was null.\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// if we can't determine the status (because an exception will throw below) then\r\n\t\t// we assume there is no request running.\r\n\t\tboolean retValue = false;\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// for reasons unknown so far, we observed that in rare cases a ClassCastException might\r\n\t\t\t// be thrown here. If that happens we \"ignore\" the whole check and assume there\r\n\t\t\t// is no request running.\r\n\t\t\tretValue = list.stream().filter(i -> Optional.ofNullable(i).isPresent() && i.startsWith(uid) ).findAny().isPresent();\r\n\t\t} catch (Throwable t) {\r\n\t\t\tlog.catching(t);\r\n\t\t}\r\n\t\t\r\n\t\treturn retValue;\r\n\t}\r\n`\r\n\r\nThe UUIDs themselves are a simple String concatenation of several ENUM sub-identifiers (so definitely nothing that could be mistaken for a Float):\r\n\r\n`\r\n\tprivate String getUid(Agency agency, Client client, Company company, ResultContent resultContent, String customerId, boolean includeRandomUUID) {\r\n\t\treturn agency.getDbEnumname() + \":\" + client.getDbEnumname() + \":\" + company.getCompanyName() + \":\" + resultContent.getDbEnumname() + \":\" + customerId\r\n\t\t\t\t+ (includeRandomUUID ? \":\" + UUID.randomUUID() : \"\");\r\n\t}\r\n`\r\n\r\nAnd the exception is thrown almost at the end where \"retValue = list.stream(...)\" is evaluated. When that expression gets to the findAny() the exception is thrown:\r\n\r\n`\r\nCaused by: java.lang.ClassCastException: class java.lang.Float cannot be cast to class java.lang.String (java.lang.Float and java.lang.String are in module java.base of loader 'bootstrap')\r\n\tat java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:178)\r\n\tat java.base/java.util.AbstractList$RandomAccessSpliterator.tryAdvance(AbstractList.java:706)\r\n\tat java.base/java.util.stream.ReferencePipeline.forEachWithCancel(ReferencePipeline.java:129)\r\n\tat java.base/java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:527)\r\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:513)\r\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\r\n\tat java.base/java.util.stream.FindOps$FindOp.evaluateSequential(FindOps.java:150)\r\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n\tat java.base/java.util.stream.ReferencePipeline.findAny(ReferencePipeline.java:652)\r\n\tat de.otto.cccs.craproxy.util.ElasticacheHelper.runningRequestExists(ElasticacheHelper.java:243)\r\n`\r\n\r\nWe would appreciate any suggestions as to what might cause this and how to mitigate it.\r\n\r\nIs it for example possible that this might be related to the Codec used to serialize the instances? Right now, as you can see, we don't explicitly set a specific Codec. Is that something we should try? If so, what codec would be a good choice?\r\n\r\nThanks in advance for any help!\r\n\r\nbest regards\r\nMario Köhler",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4785/comments",
    "author": "mariokoehler",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-01-19T08:27:25Z",
        "body": "> Caused by: java.lang.ClassCastException: class java.lang.Float cannot be cast to class java.lang.String\r\n\r\nTry to use the default codec or StringCodec."
      }
    ]
  },
  {
    "number": 4784,
    "title": "there is exception that Cannot assign requested address:  connect: ip/ip:0 after redisson upgrade from 3.16.8 to 3.19.1 when springboot startup",
    "created_at": "2023-01-10T03:21:55Z",
    "closed_at": "2023-02-13T08:51:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4784",
    "body": "I upgrade redissson-spring-boot-starter from  3.16.8 to 3.19.1。but there is exception that Cannot assign requested address:  connect: ip/ip:0。I saw 3.16.8  and 3.19.1 source code，I find there is same exception in 3.16.8 that is not throw it。so wanna ask：\r\nWhat does port 0 do and how do I configure it？\r\nand can I ignore it？\r\nthank you for your help",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4784/comments",
    "author": "jiushiweisuo",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-02-13T08:51:18Z",
        "body": "It's related to netty library update."
      }
    ]
  },
  {
    "number": 4783,
    "title": "getAndDelete is not support?",
    "created_at": "2023-01-10T03:20:58Z",
    "closed_at": "2023-01-10T06:13:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4783",
    "body": "getAndDelete is not support?\r\n\r\nI use getAndDelete \r\n\r\n`Caused by: java.lang.StackOverflowError: null\r\n\tat org.springframework.data.redis.connection.DefaultedRedisConnection.getDel(DefaultedRedisConnection.java:292)\r\n\tat org.springframework.data.redis.connection.DefaultedRedisConnection.getDel(DefaultedRedisConnection.java:292)\r\n\tat org.springframework.data.redis.connection.DefaultedRedisConnection.getDel(DefaultedRedisConnection.java:292)\r\n\tat org.springframework.data.redis.connection.DefaultedRedisConnection.getDel(DefaultedRedisConnection.java:292)\r\n\tat org.springframework.data.redis.connection.DefaultedRedisConnection.getDel(DefaultedRedisConnection.java:292)\r\n\tat org.springframework.data.redis.connection.DefaultedRedisConnection.getDel(DefaultedRedisConnection.java:292)\r\n\tat org.springframework.data.redis.connection.DefaultedRedisConnection.getDel(DefaultedRedisConnection.java:292)`\r\n\r\n**Redis version**\r\n6.2.1\r\n**Redisson version**\r\n3.17.4\r\n** springboot version**\r\n2.6.10\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4783/comments",
    "author": "kevinsir",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-01-10T06:13:47Z",
        "body": "Fixed in 3.18.0 version"
      }
    ]
  },
  {
    "number": 4780,
    "title": "Kryo5Codec with redisson-3.19.1 clarification",
    "created_at": "2023-01-07T18:55:46Z",
    "closed_at": "2023-01-08T05:20:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4780",
    "body": "Release notes read:\r\n```\r\nBreaking change - Kryo5Codec uses own serializators to serialize UUID, URI and Pattern objects\r\n```\r\nCould you clarify what this means and implies?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4780/comments",
    "author": "mzhafez",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-01-08T05:20:26Z",
        "body": "It means that if you serialized object which has UUID, URI or Pattern with previous version. You won't be able to decode them with new version. Since serialization method has changed for these object."
      },
      {
        "user": "neets-anita",
        "created_at": "2023-03-23T10:15:19Z",
        "body": "Are there any migration steps for this breaking change?"
      }
    ]
  },
  {
    "number": 4771,
    "title": "How to reset a schedulable task?",
    "created_at": "2023-01-03T10:00:23Z",
    "closed_at": "2023-03-27T10:53:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4771",
    "body": "Hi,\r\n\r\nI would like to know the proper way to reset a scheduled task ? Right now, I'm doing the following thing:\r\n\r\n```java\r\n// First creation of the task\r\nexecutor.schedule(MY_ID, new CallableTask(), duration);\r\n\r\n// Subsequent call to re-create the task\r\nexecutor.cancelTask(MY_ID);\r\nexecutor.schedule(MY_ID, new CallableTask(), duration);\r\n```\r\n\r\nI enforce the usage of an identifier, since I want to fix it to properly store it into a dedicated database.\r\n\r\nI'm currently experiencing a weird issue. The previous pseudocode does work 3 times, but my task is never called back again on the fourth reset... Do you have any idea?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4771/comments",
    "author": "jaudiger",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-03-27T10:53:03Z",
        "body": "Unable to reproduce. Below is the test.\r\n\r\n```java\r\n        RScheduledExecutorService executor = redisson.getExecutorService(\"test\");\r\n        for (int i = 0; i < 10; i++) {\r\n            executor.schedule(\"1234\", new CallableRedissonTask(1L), Duration.ofSeconds(1));\r\n            executor.cancelTask(\"1234\");\r\n            executor.schedule(\"1234\", new CallableRedissonTask(1L), Duration.ofSeconds(1));\r\n            Thread.sleep(1500L);\r\n            assertThat(redisson.getAtomicLong(\"counter\").getAndDelete()).isEqualTo(1L);\r\n        }\r\n```"
      }
    ]
  },
  {
    "number": 4768,
    "title": "Classfile version 61 (Java17) change intended?",
    "created_at": "2022-12-29T15:48:50Z",
    "closed_at": "2023-01-06T07:28:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4768",
    "body": "Is it an intended or accidental change to publish redisson compiled with java17 target and thus break everyone not yet lucky enough to be on 17?\r\nIf so, wouldn't a change like this be good to be documented as incompatible in the release notes?\r\n\r\nAlso i was expecting such a drastic thing to be a major, rather than a minor change (in terms of SemVer).",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4768/comments",
    "author": "uweschaefer",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-12-30T05:34:28Z",
        "body": "Can you point on that class? All classes of 3.19.0 version compiled with java 8 target. Checked it with javap\r\n\r\n```\r\npublic class org.redisson.Redisson implements org.redisson.api.RedissonClient\r\n  minor version: 0\r\n  major version: 52\r\n```\r\n"
      },
      {
        "user": "uweschaefer",
        "created_at": "2023-01-09T17:54:44Z",
        "body": "my bad. I rechecked all classes from 3.18,19.0 and 19.1... Don't know what i saw... :blush: "
      }
    ]
  },
  {
    "number": 4767,
    "title": "upgrade to 3.19.0 and Kryo5Codec compatible doubt",
    "created_at": "2022-12-29T06:23:05Z",
    "closed_at": "2022-12-29T06:33:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4767",
    "body": "i see the change log and find the breaking change,  default codec changed to Kryo5Codec.\r\n\r\nI want to confirm the new Kryo5Codec compatible with the old data that may serialized by the other methods\r\n\r\nif i want to upgrade to the latest version, is there anything need to consideration\r\n\r\nthank you",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4767/comments",
    "author": "yinyansheng",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-12-29T06:33:15Z",
        "body": "data serialized with Kryo5Codec isn't compatible with data serialized with MarshallingCodec"
      }
    ]
  },
  {
    "number": 4761,
    "title": " com.fasterxml.jackson.databind.JsonMappingException: writerIndex(2147481119) + minWritableBytes(7835) exceeds maxCapacity(2147483647)",
    "created_at": "2022-12-26T05:04:39Z",
    "closed_at": "2023-03-27T10:54:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4761",
    "body": "Redisson 3.9.1\r\n\r\nThis is call we are doing:\r\nredisClient.get.getMap[NodeId, PartitionChainPropagationDataRto](partitionChainIdKey, CodecCache.getOrCreate(classOf[PartitionChainPropagationDataRto], codecName, isComposite = true, innerCodec)).fastPutAsync(CONTENT, x._2)\r\n\r\nAnd it results in following error, could you please help to fix this issue\r\n\r\nFacing this error while writing to RMap object via fast\r\n`2022-12-26 02:03:48,527 ERROR org.apache.spark.executor.Executor: Exception in task 0.3 in stage 0.0 (TID 3)\r\njava.lang.IllegalArgumentException: com.fasterxml.jackson.databind.JsonMappingException: writerIndex(2147481119) + minWritableBytes(7835) exceeds maxCapacity(2147483647): PooledUnsafeDirectByteBuf(ridx: 0, widx: 2147481119, cap: 2147483647) (through reference chain: com.mycomosi.eaa.common.infrastructure.redis.v2_2.PartitionChainPropagationDataRto[\"nodeInstancesPerId\"]->java.util.HashMap[\"c0bed7b9-89d3-11ec-845c-a738f260b99e\"])\r\n        at org.redisson.RedissonObject.encodeMapValue(RedissonObject.java:282) ~[topology-cache-management.jar:3.5.1-SNAPSHOT]\r\n        at org.redisson.RedissonMap.fastPutOperationAsync(RedissonMap.java:1025) ~[topology-cache-management.jar:3.5.1-SNAPSHOT]\r\n        at org.redisson.RedissonMap.fastPutAsync(RedissonMap.java:1010) ~[topology-cache-management.jar:3.5.1-SNAPSHOT]\r\n        at com.mycomosi.eaa.common.infrastructure.chain.RedisSimpleChainStore$$anonfun$addPartitionChains$1.apply(RedisSimpleChainStore.scala:320) ~[topology-cache-management.jar:3.5.1-SNAPSHOT]\r\n        at com.mycomosi.eaa.common.infrastructure.chain.RedisSimpleChainStore$$anonfun$addPartitionChains$1.apply(RedisSimpleChainStore.scala:299) ~[topology-cache-management.jar:3.5.1-SNAPSHOT]\r\n        at scala.collection.immutable.HashMap$HashMap1.foreach(HashMap.scala:221) ~[scala-library-2.11.8.jar:na]\r\n        at scala.collection.immutable.HashMap$HashTrieMap.foreach(HashMap.scala:428) ~[scala-library-2.11.8.jar:na]\r\n        at scala.collection.immutable.HashMap$HashTrieMap.foreach(HashMap.scala:428) ~[scala-library-2.11.8.jar:na]\r\n        at com.mycomosi.eaa.common.infrastructure.chain.RedisSimpleChainStore.addPartitionChains(RedisSimpleChainStore.scala:299) ~[topology-cache-management.jar:3.5.1-SNAPSHOT]\r\n        at com.mycomosi.eaa.common.infrastructure.chain.RedisSafeChainStoreWrapper.com$mycomosi$eaa$common$infrastructure$chain$RedisSafeChainStoreWrapper$$super$addPartitionChains(RedisSafeChainStoreWrapper.scala:38) ~[topology-cache-management.jar:3.5.1-SNAPSHOT]\r\n        at com.mycomosi.eaa.common.infrastructure.chain.RedisSafeChainStoreWrapper$$anonfun$addPartitionChains$1.apply(RedisSafeChainStoreWrapper.scala:38) ~[topology-cache-management.jar:3.5.1-SNAPSHOT]\r\n        at com.mycomosi.eaa.common.infrastructure.chain.RedisSafeChainStoreWrapper$$anonfun$addPartitionChains$1.apply(RedisSafeChainStoreWrapper.scala:38) ~[topology-cache-management.jar:3.5.1-SNAPSHOT]\r\n        at scala.Function2$$anonfun$tupled$1.apply(Function2.scala:48) ~[scala-library-2.11.8.jar:na]\r\n        at scala.Function2$$anonfun$tupled$1.apply(Function2.scala:47) ~[scala-library-2.11.8.jar:na]\r\n        at com.mycomosi.eaa.common.application.fwk.Retry$$anonfun$safeCall$1.apply(Retry.scala:25) ~[topology-cache-management.jar:3.5.1-SNAPSHOT]\r\n        at scala.concurrent.impl.Future$PromiseCompletingRunnable.liftedTree1$1(Future.scala:24) ~[scala-library-2.11.8.jar:na]\r\n        at scala.concurrent.impl.Future$PromiseCompletingRunnable.run(Future.scala:24) ~[scala-library-2.11.8.jar:na]\r\n        at scala.concurrent.impl.ExecutionContextImpl$AdaptedForkJoinTask.exec(ExecutionContextImpl.scala:121) ~[scala-library-2.11.8.jar:na]\r\n        at scala.concurrent.forkjoin.ForkJoinTask.doExec(ForkJoinTask.java:260) ~[scala-library-2.11.8.jar:na]\r\n        at scala.concurrent.forkjoin.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1339) ~[scala-library-2.11.8.jar:na]\r\n        at scala.concurrent.forkjoin.ForkJoinPool.runWorker(ForkJoinPool.java:1979) ~[scala-library-2.11.8.jar:na]\r\n        at scala.concurrent.forkjoin.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:107) ~[scala-library-2.11.8.jar:na]`\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4761/comments",
    "author": "chandaku",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-12-26T05:29:30Z",
        "body": "It might be a codec specific issue. Can you share the code to reproduce the issue?"
      },
      {
        "user": "chandaku",
        "created_at": "2022-12-26T07:58:24Z",
        "body": "This is how code is invoking, with scala, x._2 is object of more than 2GB and this breaks there.\r\n\r\n```\r\nval codec = new org.redisson.codec.LZ4Codec(new org.redisson.codec.SmileJacksonCodec())\r\nredisClient.get.getMap[String, Object](partitionChainIdKey, codec).fastPutAsync(CONTENT, x._2)\r\n\r\n```"
      },
      {
        "user": "chandaku",
        "created_at": "2022-12-26T16:49:54Z",
        "body": "@mrniko do you have any inputs"
      },
      {
        "user": "mrniko",
        "created_at": "2023-03-27T10:54:11Z",
        "body": "> object of more than 2GB\r\n\r\nThis is the cause. Try to use different codec."
      }
    ]
  },
  {
    "number": 4724,
    "title": "Distributed Locks use Thread.id",
    "created_at": "2022-12-07T18:11:48Z",
    "closed_at": "2022-12-23T06:58:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4724",
    "body": "Hi. I'm using Redisson 3.17.7 Java client (with Java 17). \r\nI have N pods of the same service in Kuber and I need to synchronize them on some objects UUID. \r\nI came into situation when few pods are trying to acquire the same lock and they have same thread id (Thread.currentThread().getId()). Such thing happened as each pod is different JVM and thread id is consecutive number (++threadSeqNumber). \r\nAs a result few pods/Services/JVMs acquired the same lock. \r\n\r\nIs there any workaround or fix may be advised? \r\n\r\nI think this must be handled on Redis server side (not lib). When different Redis clients are trying to acquire the same lock with the equal thread id, client ID, must be taken into account, mustn't it?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4724/comments",
    "author": "MykolaPogorilyi",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-12-23T06:58:40Z",
        "body": "If thread id and client ID are equal the lock owner is considered the same.\r\n\r\n> few pods are trying to acquire the same lock\r\n\r\nYou can try to use Redisson client per pod. Each Redisson client has unique client ID."
      }
    ]
  },
  {
    "number": 4712,
    "title": "which are Redis Compatible of Redisson versions?",
    "created_at": "2022-12-01T13:58:04Z",
    "closed_at": "2022-12-02T06:14:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4712",
    "body": "I'd like to know if last version is compatible with redis 4, it's no clear for me on documentation, I didn't find it.\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4712/comments",
    "author": "rgarbin",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-12-02T06:14:45Z",
        "body": "Compatible with all versions starting from 3.0"
      }
    ]
  },
  {
    "number": 4703,
    "title": "How to set the Query cache?",
    "created_at": "2022-11-28T08:51:24Z",
    "closed_at": "2022-12-12T06:01:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4703",
    "body": "\r\n\r\nI'm working on a Java Spring project. This project uses redisson-hibernate-53 cache and I'm able to cache entities by using this annotation @Cache; however, I'm not sure how to set queries to be cached knowing that I use Spring JpaRepository and I write my queries as follows:\r\n\r\n```\r\n @QueryHints(value = {@QueryHint(name = \"org.hibernate.cacheable\", value = \"true\")\r\n                    , @QueryHint(name = \"org.hibernate.cacheRegion\", value = \"FindByJobRole\")   })\r\n List<Employee> findByJobRole(String jobRole);\r\n```\r\n\r\nI added this property :\r\n\r\n`spring.jpa.properties.hibernate.cache.use_query_cache=true`\r\n\r\nBut I think I'm missing some other configuration. Any help is appreciated!\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4703/comments",
    "author": "AseelAbushhadeh",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-12-12T06:01:24Z",
        "body": "It's better to refer to Spring JpaRepository documentation for this issue."
      }
    ]
  },
  {
    "number": 4685,
    "title": "restart application, unable to connect redis server ",
    "created_at": "2022-11-18T09:20:25Z",
    "closed_at": "2022-11-24T05:37:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4685",
    "body": "Redisson version : 3.18.0 \r\nSpring boot version : 2.5.10 \r\nLaptop: M1 Pro\r\nJava version : 8 \r\nredis provider: aliyun  Mater-slave  connect proxy address \r\n\r\n`  @Bean(destroyMethod = \"shutdown\")\r\n    public RedissonClient getRedisson() throws InterruptedException {\r\n        Config config = new Config();\r\n\r\n        config.useSingleServer().setAddress(\"redis://\"+redisProperties.getHost() + \":\"+redisProperties.getPort());\r\n        config.useSingleServer().setConnectTimeout(1000)\r\n                .setConnectionMinimumIdleSize(1)\r\n                .setConnectionPoolSize(1)\r\n                .setIdleConnectionTimeout(10000)\r\n                .setRetryAttempts(3)\r\n                .setRetryInterval(1500)\r\n                .setTimeout(3000);\r\n        config.useSingleServer().setDatabase(redisProperties.getDatabase());\r\n        config.useSingleServer().setPassword(redisProperties.getPassword());\r\n      config.useSingleServer().setDnsMonitoringInterval(-1);\r\n        return Redisson.create(config);\r\n    }`\r\n\r\nfor the reason , i cover up the redis address and ip below. \r\nI'm make sure the address and password is correct.\r\n\r\nstart the project local, the first time is correct like \r\n\r\n`[2022-11-18 17:08:20.565] [INFO] [redisson-netty-4-5] [] o.r.c.pool.MasterConnectionPool 162 - 1 connections initialized for r-xxx.aliyuncs.com/xx:6379\r\n\r\n[2022-11-18 17:08:20.578] [INFO] [redisson-netty-4-6] [] o.r.c.p.MasterPubSubConnectionPool 162 - 1 connections initialized for r-xxx.aliyuncs.com/xx:6379`\r\n\r\nwhen i restart the application, sometimes show the error like \r\n\r\n> Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'getRedisson' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to connect to Redis server: xxx/xxx:6379\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653)\r\n\t... 19 common frames omitted\r\nCaused by: org.redisson.client.RedisConnectionException: Unable to connect to Redis server: xxx/xx:6379\r\n\tat org.redisson.connection.pool.ConnectionPool.lambda$createConnection$0(ConnectionPool.java:154)\r\n\tat java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:760)\r\n\tat java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:736)\r\n\tat java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:474)\r\n\tat java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1977)\r\n\tat org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:318)\r\n\tat org.redisson.connection.pool.ConnectionPool.lambda$createConnection$6(ConnectionPool.java:277)\r\n\tat java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:760)\r\n\tat java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:736)\r\n\tat java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:474)\r\n\tat java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1977)\r\n\tat org.redisson.client.RedisClient$1$2.run(RedisClient.java:250)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute$$$capture(AbstractEventExecutor.java:164)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:503)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.util.concurrent.CompletionException: io.netty.channel.ConnectTimeoutException: connection timed out: xxx/xx:6379\r\n\tat java.util.concurrent.CompletableFuture.encodeRelay(CompletableFuture.java:326)\r\n\tat java.util.concurrent.CompletableFuture.completeRelay(CompletableFuture.java:338)\r\n\tat java.util.concurrent.CompletableFuture.uniRelay(CompletableFuture.java:911)\r\n\tat java.util.concurrent.CompletableFuture$UniRelay.tryFire(CompletableFuture.java:899)\r\n\t... 11 common frames omitted\r\nCaused by: io.netty.channel.ConnectTimeoutException: connection timed out: xxx/xxx:6379\r\n\tat io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:261)\r\n\tat io.netty.util.concurrent.PromiseTask.runTask(PromiseTask.java:98)\r\n\tat io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:170)\r\n\t... 8 common frames omitted\r\n\r\ni turn on the netty log  some log like \r\n\r\n\r\n\r\n>[2022-11-18 17:09:15.307] [DEBUG] [main] [] i.n.u.i.l.InternalLoggerFactory 63 - Using SLF4J as the default logging framework\r\n[2022-11-18 17:09:15.318] [DEBUG] [main] [] io.netty.util.NetUtil 135 - -Djava.net.preferIPv4Stack: false\r\n[2022-11-18 17:09:15.318] [DEBUG] [main] [] io.netty.util.NetUtil 136 - -Djava.net.preferIPv6Addresses: false\r\n[2022-11-18 17:09:15.320] [DEBUG] [main] [] io.netty.util.NetUtilInitializations 129 - Loopback interface: lo0 (lo0, 0:0:0:0:0:0:0:1%lo0)\r\n[2022-11-18 17:09:15.322] [DEBUG] [main] [] i.n.util.internal.PlatformDependent0 460 - -Dio.netty.noUnsafe: false\r\n[2022-11-18 17:09:15.322] [DEBUG] [main] [] i.n.util.internal.PlatformDependent0 954 - Java version: 8\r\n[2022-11-18 17:09:15.323] [DEBUG] [main] [] i.n.util.internal.PlatformDependent0 135 - sun.misc.Unsafe.theUnsafe: available\r\n[2022-11-18 17:09:15.324] [DEBUG] [main] [] i.n.util.internal.PlatformDependent0 159 - sun.misc.Unsafe.copyMemory: available\r\n[2022-11-18 17:09:15.325] [DEBUG] [main] [] i.n.util.internal.PlatformDependent0 202 - java.nio.Buffer.address: available\r\n[2022-11-18 17:09:15.327] [DEBUG] [main] [] i.n.util.internal.PlatformDependent0 272 - direct buffer constructor: available\r\n[2022-11-18 17:09:15.328] [DEBUG] [main] [] i.n.util.internal.PlatformDependent0 350 - java.nio.Bits.unaligned: available, true\r\n[2022-11-18 17:09:15.328] [DEBUG] [main] [] i.n.util.internal.PlatformDependent0 424 - jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable prior to Java9\r\n[2022-11-18 17:09:15.328] [DEBUG] [main] [] i.n.util.internal.PlatformDependent0 446 - java.nio.DirectByteBuffer.<init>(long, int): available\r\n[2022-11-18 17:09:15.328] [DEBUG] [main] [] i.n.util.internal.PlatformDependent 1116 - sun.misc.Unsafe: available\r\n[2022-11-18 17:09:15.329] [DEBUG] [main] [] i.n.util.internal.PlatformDependent 1237 - -Dio.netty.tmpdir: /var/folders/vc/_2p03gkx20n29tqx0l97dp140000gn/T (java.io.tmpdir)\r\n[2022-11-18 17:09:15.329] [DEBUG] [main] [] i.n.util.internal.PlatformDependent 1316 - -Dio.netty.bitMode: 64 (sun.arch.data.model)\r\n[2022-11-18 17:09:15.330] [DEBUG] [main] [] i.n.util.internal.PlatformDependent 1084 - Platform: MacOS\r\n[2022-11-18 17:09:15.331] [DEBUG] [main] [] i.n.util.internal.PlatformDependent 178 - -Dio.netty.maxDirectMemory: 7635730432 bytes\r\n[2022-11-18 17:09:15.333] [DEBUG] [main] [] i.n.util.internal.PlatformDependent 185 - -Dio.netty.uninitializedArrayAllocationThreshold: -1\r\n[2022-11-18 17:09:15.334] [DEBUG] [main] [] io.netty.util.internal.CleanerJava6 92 - java.nio.ByteBuffer.cleaner(): available\r\n[2022-11-18 17:09:15.334] [DEBUG] [main] [] i.n.util.internal.PlatformDependent 205 - -Dio.netty.noPreferDirect: false\r\n[2022-11-18 17:09:15.335] [DEBUG] [main] [] io.netty.util.NetUtil 187 - Failed to get SOMAXCONN from sysctl and file /proc/sys/net/core/somaxconn. Default: 128\r\n[2022-11-18 17:09:15.344] [DEBUG] [main] [] i.n.u.i.InternalThreadLocalMap 86 - -Dio.netty.threadLocalMap.stringBuilder.initialSize: 1024\r\n[2022-11-18 17:09:15.344] [DEBUG] [main] [] i.n.u.i.InternalThreadLocalMap 89 - -Dio.netty.threadLocalMap.stringBuilder.maxSize: 4096\r\n[2022-11-18 17:09:15.350] [DEBUG] [main] [] i.n.r.DefaultHostsFileEntriesResolver 53 - -Dio.netty.hostsFileRefreshInterval: 0\r\n[2022-11-18 17:09:15.354] [DEBUG] [main] [] i.n.u.internal.NativeLibraryLoader 78 - -Dio.netty.native.workdir: /var/folders/vc/_2p03gkx20n29tqx0l97dp140000gn/T (io.netty.tmpdir)\r\n[2022-11-18 17:09:15.354] [DEBUG] [main] [] i.n.u.internal.NativeLibraryLoader 83 - -Dio.netty.native.deleteLibAfterLoading: true\r\n[2022-11-18 17:09:15.354] [DEBUG] [main] [] i.n.u.internal.NativeLibraryLoader 87 - -Dio.netty.native.tryPatchShadedId: true\r\n[2022-11-18 17:09:15.354] [DEBUG] [main] [] i.n.u.internal.NativeLibraryLoader 91 - -Dio.netty.native.detectNativeLibraryDuplicates: true\r\n[2022-11-18 17:09:15.363] [DEBUG] [main] [] i.n.u.internal.NativeLibraryLoader 369 - Successfully loaded the library /var/folders/vc/_2p03gkx20n29tqx0l97dp140000gn/T/libnetty_resolver_dns_native_macos_x86_643182802181767469727.dylib\r\n[2022-11-18 17:09:15.368] [DEBUG] [main] [] i.n.r.d.DnsServerAddressStreamProviders 65 - io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider: available\r\n[2022-11-18 17:09:15.381] [DEBUG] [main] [] i.n.u.internal.NativeLibraryLoader 369 - Successfully loaded the library /var/folders/vc/_2p03gkx20n29tqx0l97dp140000gn/T/libnetty_transport_native_kqueue_x86_64868312100536843593.dylib\r\n[2022-11-18 17:09:15.423] [DEBUG] [main] [] io.netty.util.ResourceLeakDetector 129 - -Dio.netty.leakDetection.level: simple\r\n[2022-11-18 17:09:15.424] [DEBUG] [main] [] io.netty.util.ResourceLeakDetector 130 - -Dio.netty.leakDetection.targetRecords: 4\r\n[2022-11-18 17:09:15.428] [DEBUG] [main] [] i.n.util.ResourceLeakDetectorFactory 196 - Loaded default ResourceLeakDetector: io.netty.util.ResourceLeakDetector@673a9db4\r\n[2022-11-18 17:09:15.431] [DEBUG] [main] [] i.n.util.internal.PlatformDependent 967 - org.jctools-core.MpscChunkedArrayQueue: available\r\n[2022-11-18 17:09:18.213] [INFO] [main] [] c.a.a.spring.ArthasConfiguration 70 - Arthas agent start success.\r\n[2022-11-18 17:09:18.476] [DEBUG] [main] [] i.n.buffer.PooledByteBufAllocator 155 - -Dio.netty.allocator.numHeapArenas: 20\r\n[2022-11-18 17:09:18.478] [DEBUG] [main] [] i.n.buffer.PooledByteBufAllocator 156 - -Dio.netty.allocator.numDirectArenas: 20\r\n[2022-11-18 17:09:18.478] [DEBUG] [main] [] i.n.buffer.PooledByteBufAllocator 158 - -Dio.netty.allocator.pageSize: 8192\r\n[2022-11-18 17:09:18.478] [DEBUG] [main] [] i.n.buffer.PooledByteBufAllocator 163 - -Dio.netty.allocator.maxOrder: 11\r\n[2022-11-18 17:09:18.478] [DEBUG] [main] [] i.n.buffer.PooledByteBufAllocator 167 - -Dio.netty.allocator.chunkSize: 16777216\r\n[2022-11-18 17:09:18.478] [DEBUG] [main] [] i.n.buffer.PooledByteBufAllocator 168 - -Dio.netty.allocator.smallCacheSize: 256\r\n[2022-11-18 17:09:18.479] [DEBUG] [main] [] i.n.buffer.PooledByteBufAllocator 169 - -Dio.netty.allocator.normalCacheSize: 64\r\n[2022-11-18 17:09:18.479] [DEBUG] [main] [] i.n.buffer.PooledByteBufAllocator 170 - -Dio.netty.allocator.maxCachedBufferCapacity: 32768\r\n[2022-11-18 17:09:18.479] [DEBUG] [main] [] i.n.buffer.PooledByteBufAllocator 171 - -Dio.netty.allocator.cacheTrimInterval: 8192\r\n[2022-11-18 17:09:18.479] [DEBUG] [main] [] i.n.buffer.PooledByteBufAllocator 172 - -Dio.netty.allocator.cacheTrimIntervalMillis: 0\r\n[2022-11-18 17:09:18.479] [DEBUG] [main] [] i.n.buffer.PooledByteBufAllocator 173 - -Dio.netty.allocator.useCacheForAllThreads: true\r\n[2022-11-18 17:09:18.479] [DEBUG] [main] [] i.n.buffer.PooledByteBufAllocator 174 - -Dio.netty.allocator.maxCachedByteBuffersPerChunk: 1023\r\n[2022-11-18 17:09:18.487] [DEBUG] [main] [] io.netty.buffer.ByteBufUtil 87 - -Dio.netty.allocator.type: pooled\r\n[2022-11-18 17:09:18.488] [DEBUG] [main] [] io.netty.buffer.ByteBufUtil 96 - -Dio.netty.threadLocalDirectBufferSize: 0\r\n[2022-11-18 17:09:18.488] [DEBUG] [main] [] io.netty.buffer.ByteBufUtil 99 - -Dio.netty.maxThreadLocalCharBufferSize: 16384\r\n[2022-11-18 17:09:18.490] [DEBUG] [main] [] io.netty.util.Recycler 85 - -Dio.netty.recycler.maxCapacityPerThread: 4096\r\n[2022-11-18 17:09:18.491] [DEBUG] [main] [] io.netty.util.Recycler 86 - -Dio.netty.recycler.ratio: 8\r\n[2022-11-18 17:09:18.491] [DEBUG] [main] [] io.netty.util.Recycler 87 - -Dio.netty.recycler.chunkSize: 32\r\n[2022-11-18 17:09:18.491] [DEBUG] [main] [] io.netty.util.Recycler 88 - -Dio.netty.recycler.blocking: false\r\n[2022-11-18 17:09:18.496] [DEBUG] [main] [] io.netty.buffer.AbstractByteBuf 63 - -Dio.netty.buffer.checkAccessible: true\r\n[2022-11-18 17:09:18.497] [DEBUG] [main] [] io.netty.buffer.AbstractByteBuf 64 - -Dio.netty.buffer.checkBounds: true\r\n[2022-11-18 17:09:18.497] [DEBUG] [main] [] i.n.util.ResourceLeakDetectorFactory 196 - Loaded default ResourceLeakDetector: io.netty.util.ResourceLeakDetector@62a78446\r\n[2022-11-18 17:09:18.544] [INFO] [main] [] org.redisson.Version 41 - Redisson 3.18.0\r\n[2022-11-18 17:09:18.546] [DEBUG] [main] [] i.n.c.MultithreadEventLoopGroup 44 - -Dio.netty.eventLoopThreads: 20\r\n[2022-11-18 17:09:18.548] [DEBUG] [main] [] io.netty.channel.nio.NioEventLoop 109 - -Dio.netty.noKeySetOptimization: false\r\n[2022-11-18 17:09:18.548] [DEBUG] [main] [] io.netty.channel.nio.NioEventLoop 110 - -Dio.netty.selectorAutoRebuildThreshold: 512\r\n[2022-11-18 17:09:18.578] [DEBUG] [main] [] io.netty.channel.DefaultChannelId 79 - -Dio.netty.processId: 6367 (auto-detected)\r\n[2022-11-18 17:09:18.581] [DEBUG] [main] [] io.netty.channel.DefaultChannelId 101 - -Dio.netty.machineId: 98:dd:60:ff:fe:79:5a:cf (auto-detected)\r\n[2022-11-18 17:09:18.613] [DEBUG] [redisson-netty-4-2] [] i.n.util.ResourceLeakDetectorFactory 196 - Loaded default ResourceLeakDetector: io.netty.util.ResourceLeakDetector@7f8cf667\r\n[2022-11-18 17:09:18.621] [DEBUG] [redisson-netty-4-2] [] i.netty.resolver.dns.DnsQueryContext 117 - [id: 0x74d07d13] WRITE: UDP, [41370: /fe80:0:0:0:5655:d5ff:fe5c:a86c%17:53], DefaultDnsQuestion(r-xxxx.aliyuncs.com. IN A)\r\n[2022-11-18 17:09:18.629] [DEBUG] [redisson-netty-4-2] [] i.netty.resolver.dns.DnsQueryContext 117 - [id: 0x74d07d13] WRITE: UDP, [25155: /fe80:0:0:0:5655:d5ff:fe5c:a86c%17:53], DefaultDnsQuestion(r-xxxxaliyuncs.com. IN AAAA)\r\n[2022-11-18 17:09:18.640] [DEBUG] [redisson-netty-4-2] [] i.netty.resolver.dns.DnsNameResolver 1302 - [id: 0x74d07d13] RECEIVED: UDP [41370: /fe80:0:0:0:5655:d5ff:fe5c:a86c%17:53], DatagramDnsResponse(from: /fe80:0:0:0:5655:d5ff:fe5c:a86c%17:53, to: /0:0:0:0:0:0:0:0:57300, 41370, QUERY(0), NoError(0), RD RA)\r\n\tDefaultDnsQuestion(r-xxxxaliyuncs.com. IN A)\r\n\tDefaultDnsRawRecord(r-xxxx.aliyuncs.com. 1 IN A 4B)\r\n[2022-11-18 17:09:18.679] [DEBUG] [redisson-netty-4-2] [] i.netty.resolver.dns.DnsNameResolver 1302 - [id: 0x74d07d13] RECEIVED: UDP [25155: /fe80:0:0:0:5655:d5ff:fe5c:a86c%17:53], DatagramDnsResponse(from: /fe80:0:0:0:5655:d5ff:fe5c:a86c%17:53, to: /0:0:0:0:0:0:0:0:57300, 25155, QUERY(0), NoError(0), RD RA)\r\n\tDefaultDnsQuestion(r-xxxx.aliyuncs.com. IN AAAA)\r\n\tDefaultDnsRawRecord(rds.aliyuncs.com. 547 IN SOA 67B)\r\n\tDefaultDnsRawRecord(OPT flags:0 udp:512 0B)\r\n[2022-11-18 17:09:19.741] [DEBUG] [redisson-netty-4-2] [] io.netty.buffer.PoolThreadCache 224 - Freed 3 thread-local buffer(s) from thread: redisson-netty-4-2\r\n[2022-11-18 17:09:19.779] [WARN] [main] [] o.s.b.w.s.c.AnnotationConfigServletWebServerApplicationContext 591 - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'getRedisson' defined in class path resource [com/config/db/RedisConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'getRedisson' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to connect to Redis server: xxx.aliyuncs.com/xxx:6379\r\n\r\n\r\n\r\nI add netty dependency \r\n>      <dependency>\r\n            <groupId>io.netty</groupId>\r\n            <artifactId>netty-resolver-dns-native-macos</artifactId>\r\n            <scope>runtime</scope>\r\n            <classifier>osx-aarch_64</classifier>\r\n            <version>4.1.74.Final</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>io.netty</groupId>\r\n            <artifactId>netty-all</artifactId>\r\n        </dependency>\r\n\r\n\r\n\r\n\r\n \r\n\r\n@mrniko ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4685/comments",
    "author": "sqsteve",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-11-23T13:39:55Z",
        "body": "try to update to the latest version of netty. I saw they fixed a dns issue arising in macos"
      },
      {
        "user": "sqsteve",
        "created_at": "2022-11-24T03:28:26Z",
        "body": "> try to update to the latest version of netty. I saw they fixed a dns issue arising in macos\r\n\r\nit's not work update version of netty  @mrniko \r\n\r\n       <dependency>\r\n            <groupId>io.netty</groupId>\r\n            <artifactId>netty-resolver-dns-native-macos</artifactId>\r\n            <scope>runtime</scope>\r\n            <classifier>osx-aarch_64</classifier>\r\n            <version>4.1.85.Final</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>io.netty</groupId>\r\n            <artifactId>netty-all</artifactId>\r\n            <version>4.1.85.Final</version>\r\n        </dependency>"
      },
      {
        "user": "mrniko",
        "created_at": "2022-11-24T05:37:47Z",
        "body": "Unable to reproduce issue. Please check your network"
      }
    ]
  },
  {
    "number": 4682,
    "title": "How to set hibernate cache properties?",
    "created_at": "2022-11-17T10:29:52Z",
    "closed_at": "2022-12-12T06:04:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4682",
    "body": "I'm using Hibernate second level cache in a Java spring project and RedissonRegionFactory as a cache provider, in order to set cache properties like ttl I added this line to `application.properties` file:\r\n\r\n`spring.jpa.properties.hibernate.cache.redisson.entity.expiration.time_to_live=10000`\r\n\r\nHowever I have different cache regions and I want to set for each one a special ttl, instead of setting a general one for all caches. How can I customize cache properties individually, and is it possible to do this in java class instead of the `application.properties` file? \r\nAny help is appreciated!\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4682/comments",
    "author": "AseelAbushhadeh",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-12-12T06:04:13Z",
        "body": "Use setting below for entity `my_object`\r\n\r\n`hibernate.cache.redisson.my_object.eviction.max_entries`"
      }
    ]
  },
  {
    "number": 4674,
    "title": "Expire RRateLimiter",
    "created_at": "2022-11-15T08:22:44Z",
    "closed_at": "2022-11-17T07:52:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4674",
    "body": "I want to delete RRateLimiter hash from redis, post rate interval is over. e.g. I set rate interval of 10 sec then hash must be removed post 10 sec.\r\nIs there any built in api for this functinality exists? ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4674/comments",
    "author": "pat246",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-11-17T07:52:56Z",
        "body": "You need to use `expire()` method"
      },
      {
        "user": "pat246",
        "created_at": "2022-11-17T12:41:16Z",
        "body": "Thanks.\r\nActually we are using redisson 3.12.x version, hence I was unable to call `expire()` method. However as workaround I've tried to expire using `RMap`  with expiry value of \"rate interval\" as below\r\n\r\n\r\n`RRateLimiter limiter = redisson.getRateLimiter(name);`\r\n`RMap<Object, Object> keyMap = redisson.getMap(name);`\r\n`keyMap.expire(10, TimeUnit.SECONDS); // 10 sec is rate interval of limitter`"
      }
    ]
  },
  {
    "number": 4670,
    "title": "How to set cache properties for Hibernate scond level cache?",
    "created_at": "2022-11-13T08:38:42Z",
    "closed_at": "2022-12-12T06:04:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4670",
    "body": "I'm working on a Java spring project where I have multiple entities to be cached using `@Cache` annotation, ex:\r\n`@Cache(usage = CacheConcurrencyStrategy.READ_WRITE ,region = \"cache1\")`\r\n\r\nI have set ` spring.jpa.properties.hibernate.cache.region.factory_class` to be RedissonRegionFactory\r\n\r\nAs I'm using Redis cache as Hibernate second Level cache, I want a way to customize the properties of each cache region in a Java class, by properties I mean the TTL and maxEntriesLocalHeap.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4670/comments",
    "author": "AseelAbushhadeh",
    "comments": [
      {
        "user": "OdaybatLFC",
        "created_at": "2022-11-15T08:48:17Z",
        "body": "Hello @AseelAbushhadeh , what I have done in my project is configure each cached entity with my own configuration class. I am also open to hear if there is another way of achieving this."
      },
      {
        "user": "mrniko",
        "created_at": "2022-11-17T07:51:33Z",
        "body": "@OdaybatLFC \r\n\r\nWhy can't you use spring.jpa.properties.hibernate.cache... settings?\r\n\r\n```java\r\nspring.jpa.properties.hibernate.cache.redisson.entity.expiration.time_to_live=\r\nspring.jpa.properties.hibernate.cache.redisson.entity.expiration.max_idle_time=\r\nspring.jpa.properties.hibernate.cache.redisson.collection.expiration.time_to_live=\r\nspring.jpa.properties.hibernate.cache.redisson.collection.expiration.max_idle_time=\r\n```"
      },
      {
        "user": "AseelAbushhadeh",
        "created_at": "2022-11-17T10:37:03Z",
        "body": "thanks for the suggestion, I can use it but this will apply to all caches, I want to customize the properties for each entity cache individually.\r\n\r\n> @OdaybatLFC\r\n> \r\n> Why can't you use spring.jpa.properties.hibernate.cache... settings?\r\n> \r\n> ```java\r\n> spring.jpa.properties.hibernate.cache.redisson.entity.expiration.time_to_live=\r\n> spring.jpa.properties.hibernate.cache.redisson.entity.expiration.max_idle_time=\r\n> spring.jpa.properties.hibernate.cache.redisson.collection.expiration.time_to_live=\r\n> spring.jpa.properties.hibernate.cache.redisson.collection.expiration.max_idle_time=\r\n> ```\r\n\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2022-11-17T11:24:26Z",
        "body": "You can specify region name as well.\r\n```\r\nspring.jpa.properties.hibernate.cache.redisson.my_object.eviction.max_entries=\r\nspring.jpa.properties.hibernate.cache.redisson.my_object.expiration.time_to_live=\r\nspring.jpa.properties.hibernate.cache.redisson.my_object.expiration.max_idle_time=\r\n\r\nspring.jpa.properties.hibernate.cache.redisson.my_collection.expiration.time_to_live=\r\nspring.jpa.properties.hibernate.cache.redisson.my_collection.expiration.max_idle_time=\r\n```"
      },
      {
        "user": "AseelAbushhadeh",
        "created_at": "2022-11-17T12:16:45Z",
        "body": "> You can specify region name as well.\r\n> \r\n> ```\r\n> spring.jpa.properties.hibernate.cache.redisson.my_object.eviction.max_entries=\r\n> spring.jpa.properties.hibernate.cache.redisson.my_object.expiration.time_to_live=\r\n> spring.jpa.properties.hibernate.cache.redisson.my_object.expiration.max_idle_time=\r\n> \r\n> spring.jpa.properties.hibernate.cache.redisson.my_collection.expiration.time_to_live=\r\n> spring.jpa.properties.hibernate.cache.redisson.my_collection.expiration.max_idle_time=\r\n> ```\r\n\r\nThanks it works!! \r\nHoping I can find a way to do that in a java class."
      }
    ]
  },
  {
    "number": 4668,
    "title": "org.redisson.client.WriteRedisConnectionException ",
    "created_at": "2022-11-11T04:57:46Z",
    "closed_at": "2023-03-27T11:16:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4668",
    "body": "v3.12.4\r\n\r\nIntermittently we see `org.redisson.client.WriteRedisConnectionException` in the logs caused by `org.redisson.client.RedisTimeoutException` after 3 retry attempts for `PING` command when actual submitted command is `LPOP` or `RPUSH` (which also says channel closed). \r\n\r\nDoes it mean frequent background `PING` commands interfere with commands submitted application? Currently I gave 5 second interval for background PING command, and didn't change default retry attempts and retry interval. `nettyThreads` is given as 256, idle connections are 10, max connections are 256. Couple of years back nettyThreads and max connections used to be 64, we gradually increased it to 256 over the time when I observed spike in `org.redisson.client.WriteRedisConnectionException`. We also scaled application nodes horizontally as organic traffic is increasing YOY. \r\n\r\nWe are migrating to v3.17.7 soon, will this help reducing these intermittent errors? ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4668/comments",
    "author": "rgampa",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-03-27T11:16:18Z",
        "body": "PING handling has been improved since 3.15.0 version."
      }
    ]
  },
  {
    "number": 4667,
    "title": "Regarding definition of nettyThreads",
    "created_at": "2022-11-11T04:35:33Z",
    "closed_at": "2023-03-27T13:09:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4667",
    "body": "`nettyThreads` is defined as _Threads amount shared between all internal redis clients used by Redisson._\r\n\r\nFor e.g. my application connects to 3 different Redis clusters (2 sentinel based clusters, 1 multi-master cluster), all of them are initialized with different connections pool sizes and nettyThreads size. Should I keep  `nettyThreads` same across the redis clients here? ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4667/comments",
    "author": "rgampa",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-03-27T13:09:55Z",
        "body": "You can define shared EventLoopGroup through `eventLoopGroup` setting to use a single netty threads pool."
      },
      {
        "user": "rgampa",
        "created_at": "2023-03-27T17:02:30Z",
        "body": "Thanks for the tip."
      }
    ]
  },
  {
    "number": 4644,
    "title": "Unable to write command into connection! ",
    "created_at": "2022-11-01T09:00:28Z",
    "closed_at": "2022-11-28T06:02:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4644",
    "body": "Hello, when I used the API RBatch provided by Redison (version: 3.15.6) to add data to Redis, Redison prompted the following error:\r\nUnable to write command into connection!  Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=23, freeConnectionsCounter=value:63:queue:0, freezeReason=null, client=[addr=redis://], nodeType=MASTER, firstFail=0]]], connection:  RedisConnection@186126  [redisClient=[addr=redis://], channel=[id: 0xffb, ], currentCommand=null], command: null, params: null after 3 retry attempts\"\r\nI used a timed task. I called this method once an hour to add 4000 pieces of data to Redis. After testing for a week, this error occurred six times in total. I hope someone can help me answer this question. What should I do?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4644/comments",
    "author": "white-balls",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-11-28T06:02:50Z",
        "body": "Try to increase nettyThreads amount."
      },
      {
        "user": "white-balls",
        "created_at": "2022-11-28T08:41:17Z",
        "body": "> Try to increase nettyThreads amount.\r\nOK, thank you for your reply"
      }
    ]
  },
  {
    "number": 4636,
    "title": "In the cluster mode is \"masterConnectionPoolSize\" per master node? ",
    "created_at": "2022-10-28T00:04:03Z",
    "closed_at": "2022-10-28T07:07:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4636",
    "body": "In the cluster (multi-master) mode is \"masterConnectionPoolSize\" per master node? ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4636/comments",
    "author": "rgampa",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-10-28T07:07:28Z",
        "body": "yes."
      }
    ]
  },
  {
    "number": 4635,
    "title": "Scala Application is Getting in to Threadlocked, when calling redis get Key By Pattern ",
    "created_at": "2022-10-27T16:58:27Z",
    "closed_at": "2022-12-12T11:35:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4635",
    "body": "**Redisson version 3.9.1**, scala 2.11.8\r\n\r\nI have a code which is calling **redis get Key By Pattern** and on production environment it is getting stuck badely. The code is scala and spark. following are some sample thread traces\r\n\r\nSTATE of both below thread is WAITING which means by definition A thread that is waiting indefinitely for another thread to perform a particular action is in this state\r\n\r\n```\r\nsun.misc.Unsafe.park(Native Method)\r\njava.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\r\njava.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)\r\njava.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)\r\njava.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)\r\njava.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)\r\norg.redisson.command.CommandAsyncService.get(CommandAsyncService.java:182)\r\norg.redisson.RedissonKeys$2.iterator(RedissonKeys.java:127)\r\norg.redisson.RedissonKeys$2.iterator(RedissonKeys.java:123)\r\norg.redisson.BaseIterator.hasNext(BaseIterator.java:54)\r\norg.redisson.misc.CompositeIterator.hasNext(CompositeIterator.java:39)\r\nscala.collection.convert.Wrappers$JIteratorWrapper.hasNext(Wrappers.scala:42)\r\nscala.collection.Iterator$class.foreach(Iterator.scala:893)\r\nscala.collection.AbstractIterator.foreach(Iterator.scala:1336)\r\nscala.collection.IterableLike$class.foreach(IterableLike.scala:72)\r\nscala.collection.AbstractIterable.foreach(Iterable.scala:54)\r\nscala.collection.TraversableLike$class.filterImpl(TraversableLike.scala:247)\r\nscala.collection.TraversableLike$class.filterNot(TraversableLike.scala:267)\r\nscala.collection.AbstractTraversable.filterNot(Traversable.scala:104)\r\n```\r\n\r\n```\r\njava.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\r\njava.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)\r\njava.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)\r\njava.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)\r\njava.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)\r\norg.redisson.command.CommandAsyncService.get(CommandAsyncService.java:182)\r\norg.redisson.RedissonKeys$2.iterator(RedissonKeys.java:127)\r\norg.redisson.RedissonKeys$2.iterator(RedissonKeys.java:123)\r\norg.redisson.BaseIterator.hasNext(BaseIterator.java:54)\r\norg.redisson.misc.CompositeIterator.hasNext(CompositeIterator.java:39)\r\nscala.collection.convert.Wrappers$JIteratorWrapper.hasNext(Wrappers.scala:42)\r\nscala.collection.Iterator$class.foreach(Iterator.scala:893)\r\nscala.collection.AbstractIterator.foreach(Iterator.scala:1336)\r\nscala.collection.IterableLike$class.foreach(IterableLike.scala:72)\r\nscala.collection.AbstractIterable.foreach(Iterable.scala:54)\r\nscala.collection.TraversableLike$class.filterImpl(TraversableLike.scala:247)\r\nscala.collection.TraversableLike$class.filterNot(TraversableLike.scala:267)\r\nscala.collection.AbstractTraversable.filterNot(Traversable.scala:104)\r\ncom.mycomosi.eaa.common.infrastructure.topology.store.TopologyStoreEntityService$$anonfun$getTopologyInstanceIdsExcludingVersion$1$$anonfun$apply$7.apply(TopologyStoreEntityService.scala:73)\r\ncom.mycomosi.eaa.common.infrastructure.topology.store.TopologyStoreEntityService$$anonfun$getTopologyInstanceIdsExcludingVersion$1$$anonfun$apply$7.apply(TopologyStoreEntityService.scala:70)\r\n```\r\n\r\nThis is invoked from a Retry object which keep retrying for results for a given timeout on Await.result invocation in scala. Also when I run the query directly on redis master node, it get's results in 2-3 seconds but from redission library this is not getting completed even in 90 minutes. \r\n\r\nAlso when I restart my application number of times even then these threads are not resolving and getting un-lock and I am observing thread-dump as shown above. \r\n\r\nAnother observation have is that following configuration is also not coming effective:\r\n\r\n`{\"sentinelServersConfig\":{\"idleConnectionTimeout\":10000,\"pingTimeout\":1000,\"connectTimeout\":1200000,\"timeout\":1200000,\"retryAttempts\":60,\"retryInterval\":1500,\"subscriptionsPerConnection\":5,\"sslEnableEndpointIdentification\":true,\"sslProvider\":\"JDK\",\"pingConnectionInterval\":0,\"keepAlive\":false,\"tcpNoDelay\":false,\"loadBalancer\":{\"class\":\"org.redisson.connection.balancer.RoundRobinLoadBalancer\"},\"slaveConnectionMinimumIdleSize\":8,\"slaveConnectionPoolSize\":8,\"failedSlaveReconnectionInterval\":3000,\"failedSlaveCheckInterval\":60000,\"masterConnectionMinimumIdleSize\":8,\"masterConnectionPoolSize\":8,\"readMode\":\"MASTER\",\"subscriptionMode\":\"MASTER\",\"subscriptionConnectionMinimumIdleSize\":1,\"subscriptionConnectionPoolSize\":5,\"dnsMonitoringInterval\":5000,\"sentinelAddresses\":[\"redis://eaa-platform-redis-app-sentinel-0:26379\",\"redis://eaa-platform-redis-app-sentinel-1:26379\",\"redis://eaa-platform-redis-app-sentinel-2:26379\"],\"masterName\":\"mymaster\",\"database\":8,\"scanInterval\":1000,\"slaveSubscriptionConnectionPoolSize\":5,\"slaveSubscriptionConnectionMinimumIdleSize\":1},\"threads\":2,\"nettyThreads\":32,\"codec\":{\"class\":\"org.redisson.codec.SmileJacksonCodec\"},\"referenceCodecProvider\":{\"class\":\"org.redisson.codec.DefaultReferenceCodecProvider\"},\"referenceEnabled\":true,\"transportMode\":\"NIO\",\"lockWatchdogTimeout\":30000,\"keepPubSubOrder\":true,\"useScriptCache\":false,\"addressResolverGroupFactory\":{\"class\":\"org.redisson.connection.DnsAddressResolverGroupFactory\"},\"useLinuxNativeEpoll\":false}`\r\n\r\nReally appreciate for any guidance on this as I am new to Redis and Redission world both.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4635/comments",
    "author": "chandaku",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-10-28T07:34:50Z",
        "body": "Can you try 3.11.4 (it has fix for 'threads blocked waiting on CountDownLatch') or the latest version which is better?"
      },
      {
        "user": "chandaku",
        "created_at": "2022-10-28T13:24:30Z",
        "body": "I could make this perform better by calling getKeysByPattern(String pattern, int count); with sufficient high count number than default count number which is 10. There is huge amount of redis keys which our code is searching on pattern and when batch size is 10 it simply run as many requests to process all keys in redis and take huge time to block thread. To minimize this to number of request should be fetch with sufficient good count number."
      },
      {
        "user": "chandaku",
        "created_at": "2022-10-28T13:25:29Z",
        "body": "@mrniko thanks for your input we will plan update to this version soon."
      }
    ]
  },
  {
    "number": 4617,
    "title": "How to verify that expiration is occurring?",
    "created_at": "2022-10-19T23:56:38Z",
    "closed_at": "2023-03-27T11:05:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4617",
    "body": "I have expiration configured for 10,000 milliseconds by a property in hibernate.cfg.xml, eg. `<property name=\"hibernate.cache.redisson.veryShortTerm.expiration.time_to_live\">10000</property>`\r\n\r\nHow can I verify (with redis-cli) that expiration is happening? On what schedule does the \"scheduled cleanup\" occur and is that configurable (is that max_idle_time?)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4617/comments",
    "author": "contentfree",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-03-27T11:05:10Z",
        "body": "You can do it by monitoring size of Map objects stored in Redis."
      }
    ]
  },
  {
    "number": 4616,
    "title": "When configuring cache region expirations for Hibernate, do we include the region prefix?",
    "created_at": "2022-10-19T23:54:56Z",
    "closed_at": "2025-02-17T10:23:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4616",
    "body": "In my hibernate.cfg.xml I have `<property name=\"hibernate.cache.region_prefix\">my-prefix</property>`\r\n\r\nNow, when I want to configure expirations, do I do this:\r\n`<property name=\"hibernate.cache.redisson.myRegion.expiration.time_to_live\">10000</property>`\r\nor this:\r\n`<property name=\"hibernate.cache.redisson.my-prefix.myRegion.expiration.time_to_live\">10000</property>`\r\n\r\n(Also, is it fine for the name to have a hyphen in it?)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4616/comments",
    "author": "contentfree",
    "comments": [
      {
        "user": "seakider",
        "created_at": "2025-02-17T10:00:44Z",
        "body": "If using a prefix such as\n`<property name=“hibernate.cache.region_prefix”>my-prefix</property>`\n\n\nConfigure the expiration time like this\n`<property name=“hibernate.cache.redisson.my-prefix.myRegion.expiration.time_to_live”>10000</property>`\n\n> Is it okay to include hyphens in the name?\n\nYes."
      }
    ]
  },
  {
    "number": 4606,
    "title": "Does Redisson client auto-recovers in case of master failover in Redis cluster mode",
    "created_at": "2022-10-17T21:57:29Z",
    "closed_at": "2022-10-18T08:58:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4606",
    "body": "Using latest Redisson 3.17.x and Redis 7.x versions. \r\n\r\nEarlier we were using Redis sentinel mode where Redisson supports in case of failovers. Now we are migrating to Redis cluster mode with multiple masters, so does Redission auto recovers in case of master failover by Redis cluster bus or manual failover by Redis DBA? ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4606/comments",
    "author": "rgampa",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-10-18T08:58:29Z",
        "body": "Yes"
      },
      {
        "user": "rgampa",
        "created_at": "2022-10-18T16:10:56Z",
        "body": "Thanks @mrniko for prompt reply."
      }
    ]
  },
  {
    "number": 4585,
    "title": "Redisson Client creating more connections to Redis (Elastic cache cluster) than expected",
    "created_at": "2022-10-07T05:29:34Z",
    "closed_at": "2022-10-07T06:16:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4585",
    "body": "We are using Redisson client(**3.11.5 version**) for distributed lock use-case.\r\nWe are using 8 primary and 8 replica in AWS Elastic cache.\r\nRedisson is a singleton object in our Java application instance.\r\n\r\nWe are noticing Redisson client creating more than max connections configured.  Noticed that 24K+ active connections were created from single application instance\r\nMax master connections configured was 1000.\r\n\r\n{code}\r\n\r\n@Bean\r\npublic Redisson clusterServerRedisson() {\r\n        final StringBuilder serverAddress = new StringBuilder()\r\n                .append(\"rediss://\")\r\n                .append(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_HOST))\r\n                .append(\":\")\r\n                .append(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_PORT, Integer.class));\r\n        final String redisPassword = this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_PASSWORD);\r\n\r\n        final Config config = new Config();\r\n\r\n        final ClusterServersConfig clusterServersConfig = config.useClusterServers();\r\n        clusterServersConfig.addNodeAddress(serverAddress.toString());\r\n        if (StringUtils.isNotBlank(redisPassword)) {\r\n            clusterServersConfig.setPassword(redisPassword);\r\n        }\r\n        // Redis cluster scan interval in milliseconds.\r\n        clusterServersConfig.setScanInterval(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CLUSTER_SCAN_INTERVAL_TIMEOUTMILLIS, int.class));\r\n\r\n        // Redis 'master' node maximum connection pool size\r\n        clusterServersConfig.setMasterConnectionPoolSize(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_MAX_POOL_SIZE, int.class));\r\n\r\n        // Redis 'master' node minimum idle connection amount for each master node\r\n        clusterServersConfig.setMasterConnectionMinimumIdleSize(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_MIN_IDLE_SIZE, int.class));\r\n\r\n        // Timeout in milliseconds during connecting to any Redis server.\r\n        clusterServersConfig.setConnectTimeout(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_TIMEOUTMILLIS, int.class));\r\n\r\n        // Operation timeout - counter starts once command has been sent to the redis server\r\n        // Redis server response timeout in milliseconds. Starts to countdown when Redis command was succesfully sent.\r\n        clusterServersConfig.setTimeout(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_OP_TIMEOUTMILLIS, int.class));\r\n\r\n        clusterServersConfig.\r\n        // For connection failures outside of the (jedis) pool\r\n        clusterServersConfig.setRetryAttempts(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_MAX_RETRY_COUNT, int.class));\r\n        clusterServersConfig.setRetryInterval(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_RETRY_DELAYMILLIS, int.class));\r\n\r\n        // Since we use redis primarily as a messaging conduit (PubSub), we tune the following items\r\n        clusterServersConfig.setSubscriptionsPerConnection(\r\n                this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_SUBSCRIPTION_PER_CONNECTION_SIZE, int.class));\r\n        clusterServersConfig.setSubscriptionConnectionPoolSize(\r\n                this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_SUBSCRIPTION_CONNECTION_MAX_POOL_SIZE, int.class));\r\n\r\n        clusterServersConfig.setClientName(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_NAME, String.class));\r\n\r\n        return (Redisson)Redisson.create(config);\r\n    }\r\n\r\n{code}\r\n## Redisson Client for Redis\r\nredis.redisson.cluster.scan.interval.timeoutMillis=30000\r\nredis.redisson.connection.name=MY-APP-REDISSON-POOL\r\nredis.redisson.connection.max.pool.size=1000\r\nredis.redisson.connection.max.retry.count=10\r\nredis.redisson.connection.min.idle.size=100\r\nredis.redisson.connection.retry.delayMillis=1500\r\nredis.redisson.connection.timeoutMillis=60000\r\nredis.redisson.idle.connection.timeoutMillis=10000\r\nredis.redisson.lock.timeoutMillis=10000\r\nredis.redisson.op.timeoutMillis=30000\r\nredis.redisson.subscription.connection.max.pool.size=50\r\nredis.redisson.subscription.per.connection.size=10\r\n\r\n\r\npublic class RedisLock implements DistributableLock {\r\n\r\n    private final RedisConfigManager redisConfigManager;\r\n    private final Redisson redisson;\r\n\r\n    public RedisLock(final Redisson redisson) {\r\n        this.redisson = this.redisConfigManager.getRedisson();\r\n    }\r\n\r\n    @Override\r\n    public void acquireLock(final Object object) {\r\n        getLockInstance(object).lock(this.redisConfigManager.getLockTimeoutInMillis(), TimeUnit.MILLISECONDS);\r\n    }\r\n\r\n    @Override\r\n    public void releaseLock(final Object object) {\r\n        getLockInstance(object).unlock();\r\n    }\r\n\r\n    @Override\r\n    public boolean tryWriteLock(final Object object) {\r\n        return getReadWriteLockInstance(object).writeLock().tryLock();\r\n    }\r\n\r\n    @Override\r\n    public void acquireReadLock(final Object object) {\r\n        getReadWriteLockInstance(object).readLock().lock();\r\n    }\r\n\r\n    @Override\r\n    public void releaseReadLock(final Object object) {\r\n        getReadWriteLockInstance(object).readLock().unlock();\r\n    }\r\n\r\n    @Override\r\n    public void acquireWriteLock(final Object object) {\r\n        getReadWriteLockInstance(object).writeLock().lock(this.redisConfigManager.getLockTimeoutInMillis(), TimeUnit.MILLISECONDS);\r\n    }\r\n\r\n    @Override\r\n    public void releaseWriteLock(final Object object) {\r\n         getReadWriteLockInstance(object).writeLock().unlock();\r\n    }\r\n\r\n    private RLock getLockInstance(final Object object) {\r\n        Assert.notNull(object, \"Cannot lock or unlock a null object\");\r\n\r\n        final RLock rLock = this.redisson.getLock(Integer.toString(object.hashCode()));\r\n        if (rLock == null) {\r\n            throw new IllegalStateException(\"Cannot get lock instance.\");\r\n        }\r\n        return rLock;\r\n    }\r\n\r\n    private RReadWriteLock getReadWriteLockInstance(final Object object) {\r\n        Assert.notNull(object, \"Cannot lock or unlock a null object\");\r\n\r\n        final RReadWriteLock rwLock = this.redisson.getReadWriteLock(Integer.toString(object.hashCode()));\r\n        if (rwLock == null) {\r\n            throw new IllegalStateException(\"Cannot get read write lock instance.\");\r\n        }\r\n        return rwLock;\r\n    }\r\n\r\n}\r\n\r\n\r\nAny help would be highly appreciable. Thanks in advance.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4585/comments",
    "author": "samanthjain",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-10-07T06:16:24Z",
        "body": "Multiple problems with connections were resolved since 3.11.5. Especially in versions 3.12.2, 3.13.3, 3.14.1... You need to update to the latest version."
      },
      {
        "user": "samanthjain",
        "created_at": "2022-10-07T20:38:28Z",
        "body": "> Multiple problems with connections were resolved since 3.11.5. Especially in versions 3.12.2, 3.13.3, 3.14.1... You need to update to the latest version.\r\n\r\nThank you. Realy, Appreciate your quick response. we will try with newer version 3.17.7."
      }
    ]
  },
  {
    "number": 4575,
    "title": "Possibility of key conflict when using JndiRedissonFactory for Tomcat Sessions",
    "created_at": "2022-10-01T15:01:45Z",
    "closed_at": "2022-10-03T04:53:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4575",
    "body": "When storing tomcat session, the key is:\r\n\r\n`String name = keyPrefix + separator + \"redisson:tomcat_session:\" + sessionId;`\r\n\r\nUsing global context.xml means a keyPrefix cannot be added automatically based on context name.\r\n\r\nWill it be possible a session id in one context say /a overwrites a session id in another context say /b?\r\n\r\nIf yes, should the key generation be amended to following instead?\r\n\r\n`String name = keyPrefix + separator + \"redisson:tomcat_session:\" + sessionId + \":\" + getContext().getName();`\r\n\r\nThanks.\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4575/comments",
    "author": "kokhoor",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-10-03T04:53:48Z",
        "body": "> Will it be possible a session id in one context say /a overwrites a session id in another context say /b?\r\n\r\nI don't think so since session id is 128 bits by default and generated by Secure Random generator"
      }
    ]
  },
  {
    "number": 4572,
    "title": "remote_response not deleted if RScheduledExecutorService restarted in other jvm?",
    "created_at": "2022-09-29T10:14:57Z",
    "closed_at": "2022-09-30T06:39:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4572",
    "body": "```\r\n@Bean(destroyMethod = \"\")\r\n    public RScheduledExecutorService rScheduledExecutorService(RedissonClient redissonClient,ConfigurableListableBeanFactory  context) {}\r\n```\r\n```\r\n@Resource\r\nprivate RScheduledExecutorService rScheduledExecutorService;\r\n\r\n@Test\r\nvoid testSchedule() {\r\n    rScheduledExecutorService.schedule(new TestRunnableTask(\"223\"), 10, TimeUnit.SECONDS);\r\n    try {\r\n        Thread.sleep(30000l);\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n    }\r\n}\r\n```\r\nthis test case works fine, later I can only see one key \"{myExecutor:org.redisson.executor.RemoteExecutorService}:retry-interval\" in redis.\r\n\r\nbut if this test case is split into two step.\r\nfirst\r\n```\r\n@Test\r\nvoid testSchedule() {\r\n    rScheduledExecutorService.schedule(new TestRunnableTask(\"223\"), 10, TimeUnit.SECONDS);\r\n}\r\n```\r\nthen shutdown and run a new test like\r\n```\r\n@Test\r\nvoid testSchedule() {\r\n    try {\r\n        Thread.sleep(30000l);\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n    }\r\n}\r\n```\r\nthe task get executed as I wish, but the key \"{remote_response}:242a062c-02ad-42e9-be43-371384556b7d\" stays in redis, the response is not removed.  I see there is a ttl on this key,  but is this safe?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4572/comments",
    "author": "yizhixiaotaozi",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-09-30T06:39:06Z",
        "body": "It's safe. Since response has timeout for consumption."
      }
    ]
  },
  {
    "number": 4570,
    "title": "How to safely add field to an object which is already used ? ",
    "created_at": "2022-09-28T13:14:08Z",
    "closed_at": "2022-09-30T07:20:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4570",
    "body": "for example,I have an object name Foo with tow fields\r\n`class Foo {`\r\n`private int id;`\r\n`private String name;`\r\n`}`\r\n\r\nand store in `RSet<Foo>`.\r\n\r\nLater I have to add a field to the Foo as follow\r\n`class Foo {`\r\n`private int id;`\r\n`private String name;`\r\n`private int age;`\r\n`}`\r\n\r\nthen I found that I can not remove Foo instance from `RSet` even though the instance is get from `RSet`,because there are many older instances without age field.\r\n\r\nSo I confuse that How to add field to an object and the new object can still compatible with values in redisson?  Thanks a lot.\r\n\r\nredisson version: 3.16.8\r\ncodec: `org.redisson.codec.MarshallingCodec`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4570/comments",
    "author": "zengbotang",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-09-30T07:20:10Z",
        "body": "RSet (as well as Redis Set object) uses serialized state to check object uniqueness"
      }
    ]
  },
  {
    "number": 4569,
    "title": "Can I Ignore expired message with RDelayedQueue?",
    "created_at": "2022-09-28T10:50:59Z",
    "closed_at": "2024-11-07T12:37:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4569",
    "body": "I use RDelayedQueue to process delayed message，but i found that even if message had expired, I can also received them.\r\ne.g.\r\noffer a message with 10 seconds delay,  i start consumer server after 15 seconds, consumer also received that message.\r\ncan I avoid this situation? or i should ignore expired message by myself.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4569/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-11-07T12:36:31Z",
        "body": "No, since they just delayed and not expired"
      }
    ]
  },
  {
    "number": 4562,
    "title": "Is it safe to use Map as long life?",
    "created_at": "2022-09-26T10:00:38Z",
    "closed_at": "2022-09-27T05:04:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4562",
    "body": "```kotlin\r\n# long life\r\nclass A {\r\n   val map = redissonClient.getMapCache<String, String>(\"test\")\r\n   fun f(): String = map[\"test\"]\r\n}\r\n\r\n# short life\r\nclass A {\r\n   fun f(): String {\r\n     val map = redissonClient.getMapCache<String, String>(\"test\")\r\n     return map[\"test\"]\r\n   }\r\n}\r\n```\r\nCan i use map as long life?\r\nWhat should i do?\r\nThank you.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4562/comments",
    "author": "laststem",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-09-27T05:04:37Z",
        "body": "Yes you can hold a reference to the map as long as you need."
      }
    ]
  },
  {
    "number": 4557,
    "title": "How to Perform HealthCheck for RedissonClient",
    "created_at": "2022-09-23T10:22:11Z",
    "closed_at": "2022-09-23T10:40:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4557",
    "body": "\r\nCan you please provide way to implement healthcheck with RedissonClient",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4557/comments",
    "author": "ankitaCogno",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-09-23T10:40:04Z",
        "body": "You can use `org.redisson.api.RedissonClient.getRedisNodes().pingAll()` method"
      }
    ]
  },
  {
    "number": 4552,
    "title": "Receiving REntity already exists on liveobject persist intermittently",
    "created_at": "2022-09-21T12:22:38Z",
    "closed_at": "2023-04-12T10:31:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4552",
    "body": "Our system uses RLiveObjects to store individual tasks which are annotated with 1 @RId and 2 @RIndex. When invoking persist on many tasks under load, we intermittently receive an IllegalArgumentException with the text \"This REntity already exists.\" We have proven that the ID we are attempting to persist has not been added previously, as we performed a get() just prior to persisting with the same id.\r\nAfter the exception, if we perform a get(), we receive back a task with the same id but the remainder of the task data null, indicating that the ID was hashed in but not the other indexes or the rest of the class.\r\n\r\nIs this a known issue ?  We are using <redisson.spring.data.version>3.17.3</redisson.spring.data.version>.\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4552/comments",
    "author": "jkotelly1",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-04-12T10:31:25Z",
        "body": "Try to use lock to avoid parallel id creation between `get` and `persist` methods invocations"
      }
    ]
  },
  {
    "number": 4534,
    "title": "Redisson connecting to Redis Instance via hostname",
    "created_at": "2022-09-08T20:29:35Z",
    "closed_at": "2022-09-12T10:33:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4534",
    "body": "Does Redisson support connecting to a redis server via hostname or is it strictly limited to using static IP addresses?\r\n\r\nI am attempting to use the hostname to connect but it seems like Reddisson is having difficulty resolving the hostname.\r\nI can ping the server from the same machine perfectly fine with the hostname, yet Redisson cannot resolve the hostname.\r\n\r\nThe server and my machine are on the same network.\r\n\r\nException message:\r\nException in thread \"main\" org.redisson.client.RedisConnectionException: java.netUnknownHostException: Failed to resolve '[hostname]' after 6 queries",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4534/comments",
    "author": "DavidDev21",
    "comments": [
      {
        "user": "a25017012",
        "created_at": "2022-09-09T02:29:53Z",
        "body": "Which version is used"
      },
      {
        "user": "MXinH",
        "created_at": "2022-09-09T09:54:41Z",
        "body": "版本3.17.0"
      },
      {
        "user": "mrniko",
        "created_at": "2022-09-12T10:33:27Z",
        "body": "Sure it supports hostnames. You need to check your dns resolver"
      }
    ]
  },
  {
    "number": 4529,
    "title": "org.redisson.client.RedisException: ERR invalid command. channel ...command: (CLIENT REPLY), promise: RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@33fe3a52(incomplete)], params: [OFF]",
    "created_at": "2022-09-06T11:06:39Z",
    "closed_at": "2022-09-12T10:38:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4529",
    "body": "Hello there,\r\n\r\nI use these command to a redis 4.0 cluster, and then got the error above. Let me know if it can be fix. thanks~\r\n\r\nBatchOptions options = BatchOptions.defaults().skipResult();\r\noptions.retryAttempts(3);\r\noptions.retryInterval(100,TimeUnit.MILLISECONDS);\r\nRBatch batch = client.createBatch(options);\r\n\r\nbatch.getMap(redisKey, new ByteArrayCodec()).putAllAsync(doing_value, 500);\r\nbatch.getMap(redisKey, new ByteArrayCodec()).expireAsync(expireSeconds, TimeUnit.SECONDS);\r\n\r\nbatch.execute();\r\n\r\nredisson version: 3.16.3\r\n\r\nerror message detail:\r\n\r\n[ERROR 2022-09-06 17:12:13 (org.apache.spark.internal.Logging$class:91)] Exception in task 2.2 in stage 27.0 (TID 2424)\r\norg.redisson.client.RedisException: ERR invalid command. channel: [id: 0xe717009a, L:/172.22.54.73:55880 - R:10.241.25.47/10.241.25.47:6379] command: (CLIENT REPLY), promise: RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@33fe3a52(incomplete)], params: [OFF]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:370)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:271)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:210)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:138)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)\r\n\tat io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4529/comments",
    "author": "fishfl",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-09-12T10:38:17Z",
        "body": "Unable to reproduce it with Redis 4.0.14"
      }
    ]
  },
  {
    "number": 4528,
    "title": "What if number of RedissonLocalCachedMap > subscriptionConnectionPoolSize?",
    "created_at": "2022-09-06T09:54:37Z",
    "closed_at": "2022-09-30T07:43:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4528",
    "body": "Any problem if number of RLocalCachedMap > subscriptionConnectionPoolSize?\r\nMy application has 2000 RLocalCachedMap but subscriptionConnectionPoolSize is 50 by default. \r\nIs it ok?\r\nThis is my config\r\n`config.useSentinelServers()\r\n            .....\r\n                .setSubscriptionsPerConnection(100)\r\n                .setSlaveConnectionPoolSize(1000)\r\n                .setMasterConnectionPoolSize(1000);`\r\nAny advice on the configuration? \r\nThanks",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4528/comments",
    "author": "lehuuthanh5",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-09-30T07:43:05Z",
        "body": "You can just increase `subscriptionsPerConnection` in that case."
      }
    ]
  },
  {
    "number": 4525,
    "title": "Is RDelayedQueue can be P2P mode?",
    "created_at": "2022-09-05T10:50:40Z",
    "closed_at": "2022-09-05T12:42:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4525",
    "body": "if I have 1 node to publish msg, but I have 3 nodes to subscribe, can I always keep only one node receive msg?\r\n\r\nOR RDelayedQueue always keep all subscribed nodes receive msg, then I should use distribution lock to avoid more than one time?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4525/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-09-05T12:42:15Z",
        "body": "All queues are always p2p."
      }
    ]
  },
  {
    "number": 4512,
    "title": "Experiencing interrupted exceptions while trying to do getAll() on RMapCache with size 500",
    "created_at": "2022-08-24T21:53:22Z",
    "closed_at": "2022-08-25T06:51:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4512",
    "body": "Hi, \r\ncurrently I have like 0.3M records in RMapCache and I need to get all these entries for some processing. I tried to use get(key), it works sometime and fails intermittently with Interrupted Exception. So, tried to list all keys for 0.3M and doing getAll(list<keys>).\r\nI'm partitioning my 0.3M list into sublists of size 500 and trying to do getAll() but I'ms till getting interrupted exceptions continuosly.\r\n\r\nI don't have any other job trying to access the same cache but it is till failing.\r\n\r\nI also see loading of entries into RMapCache was successful and I see all the entries in the cache but when I do get(key)/getAll(list<keys>), it is failing intermittently.\r\n\r\n\r\n```\r\norg.redisson.client.RedisException: java.lang.InterruptedException\r\n\tat org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:113)\r\n\tat org.redisson.RedissonObject.get(RedissonObject.java:82)\r\n\tat org.redisson.RedissonMap.getAll(RedissonMap.java:571)\r\n\tat com.oracle.pic.xray.cache.testCache.lambda$getAll$2(testCache.java:111)\r\n\tat java.lang.Iterable.forEach(Iterable.java:75)\r\n\tat com.oracle.pic.xray.cache.testCache.getAll(testCache.java:108)\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4512/comments",
    "author": "GNeeraja5",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-08-25T06:51:45Z",
        "body": "It seems that threads invoking Redisson are got interrupted. You need to check app server threads management."
      }
    ]
  },
  {
    "number": 4503,
    "title": "Optimal way to iterate lists",
    "created_at": "2022-08-20T02:57:30Z",
    "closed_at": "2022-08-23T06:51:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4503",
    "body": "I am looking for an optimal way to iterate long lists, one that will have the least IO footprint. I ended up doing a size(), then chunk the list into sublist() and readAll(). Have I missed a  simpler api or this is the way to go? Thanks!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4503/comments",
    "author": "mathieufortin01",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-08-23T06:51:16Z",
        "body": "It's the most optimal way."
      }
    ]
  },
  {
    "number": 4490,
    "title": "Redisson Spring Cache not getting cache info",
    "created_at": "2022-08-16T20:11:22Z",
    "closed_at": "2022-08-18T08:59:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4490",
    "body": "I have configured my Redisson instance:\r\n```\r\n@Bean\r\nRedissonClient redisson() {\r\n        Config config = new Config();\r\n        config.useSingleServer()\r\n              .setAddress(\"redis://127.0.0.1:6379\");\r\n        return Redisson.create(config);\r\n\r\nRedissonClient redisson = Redisson.create(config);\r\n```\r\nI have also configured the cacheManager\r\n```\r\n @Bean\r\n    CacheManager cacheManager(RedissonClient redissonClient) {\r\n        Map<String, CacheConfig> config = new HashMap<>();\r\n\r\n        // create \"testMap\" spring cache with ttl = 24 minutes and maxIdleTime = 12 minutes\r\n        config.put(\"testMap\", new CacheConfig(24*60*1000, 12*60*1000));\r\n        return new RedissonSpringCacheManager(redissonClient, config);\r\n    }\r\n```\r\n\r\nI then in the service layer have a method that puts in keys. `redison.getMapCache(\"test\").put(\"1\",1)`\r\n\r\nWhen I try to get the value of the key doing `redison.getMapCache(\"test\").get(\"1\")`, the value 1 is returned.\r\n\r\nHOWVER, I then have a SEPARATE method that tries to gets the keys and when i do `redison.getMapCache(\"test\").get(\"1\")`, i get returned null.\r\n\r\nWhat is the issue?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4490/comments",
    "author": "splurring",
    "comments": [
      {
        "user": "JavaLionLi",
        "created_at": "2022-08-17T02:32:21Z",
        "body": "没遇见过 一切正常"
      }
    ]
  },
  {
    "number": 4482,
    "title": "retry not working when Lua script attempted to execute a command ",
    "created_at": "2022-08-11T11:08:03Z",
    "closed_at": "2022-08-18T09:01:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4482",
    "body": "some time getting following exception in log when perform manual failover. will retry work in this case?\r\n```\r\norg.redisson.client.RedisException: ERR Error running script (call to f_c120d5c92fb6e155437575ff8931f09bf72e4148): @user_script:1: @user_script: 1: Lua script attempted to execute a command while the cluster is down. channel: [id: 0xd7747050, L:/172.17.0.8:52830 - R:100.67.68.6/100.67.68.6:7002] command: (EVAL), params: [redis.replicate_commands();local connection, qpm, qps, min, sec, logcon;connection =  tonumber(redis..., 0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:345)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:177)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:829)\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4482/comments",
    "author": "kamalbctg",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-08-11T14:09:51Z",
        "body": "I think failover executed incorrectly since topology reports to early that Redis node with IP 100.67.68.6 joined and could be used for commands execution."
      },
      {
        "user": "kamalbctg",
        "created_at": "2022-08-11T18:22:49Z",
        "body": "Thank you for reply, Does retry work in this scenario?"
      },
      {
        "user": "mrniko",
        "created_at": "2022-08-18T09:01:56Z",
        "body": "No, since Lau engine reports an error"
      }
    ]
  },
  {
    "number": 4480,
    "title": "执行脚本返回字符类型始终为空",
    "created_at": "2022-08-10T14:32:15Z",
    "closed_at": "2022-08-18T09:02:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4480",
    "body": "redisson 版本：2.15.2\r\n\r\n```java\r\nprivate static final String luaScript = \"local key = KEYS[1]; return '1';\"\r\nString result = client.getScript().eval(RScript.Mode.READ_WRITE, luaScript, RScript.ReturnType.STATUS, Lists.<Object>newArrayList(key), \"123\", 1);\r\n```\r\n这样执行报错\r\n\r\n ```java\r\nPooledUnsafeDirectByteBuf(ridx: 0, widx: 34, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 2, cap: 256)]\r\njava.lang.IllegalArgumentException: minimumReadableBytes: -1 (expected: >= 0)\r\n\r\n```\r\n\r\n```java\r\nprivate static final String luaScript = \"local key = KEYS[1]; return 1;\"\r\n```\r\n返回int型就成功",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4480/comments",
    "author": "swit1983",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-08-11T04:45:31Z",
        "body": "2.x.x version isn't supported. Please try the latest one."
      }
    ]
  },
  {
    "number": 4475,
    "title": "Redis URL issue, not able to resolve correct URI -  hostname can't be null error",
    "created_at": "2022-08-09T16:58:38Z",
    "closed_at": "2022-08-18T09:04:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4475",
    "body": "Hi Team,\r\n\r\nWe are facing issue while setting address for redis.\r\n\r\nconfig.useSingleServer().setAddress(redis://192.168.8.8:8787);\r\n\r\nWe are getting following values for the above address url :\r\n\r\n[2022-08-09 02:04:44,367] INFO  [RedissonUtil.java,185] addressCreator : 192.168.8.8:8787\r\n[2022-08-09 02:04:44,368] INFO  [RedissonUtil.java,188] redisConnectionUrl : redis://192.168.8.8:8787\r\n[2022-08-09 02:04:44,377] INFO  [RedissonUtil.java,191] redisConnectionUrl address : //redis://192.168.8.8:8787\r\n[2022-08-09 02:04:44,385] INFO  [RedissonUtil.java,192] config.useSingleServer().getAddress().getHost() : redis\r\n[2022-08-09 02:04:44,385] INFO  [RedissonUtil.java,193] config.useSingleServer().getAddress().getPort() : -1\r\n[2022-08-09 02:04:44,386] INFO  [RedissonUtil.java,194] config.useSingleServer().getAddress().getPath() : //192.168.8.8:8787\r\n[2022-08-09 02:04:44,388] INFO  [RedissonUtil.java,195] config.useSingleServer().getAddress().getScheme() : null\r\n[2022-08-09 02:04:44,389] INFO  [RedissonUtil.java,196] config.useSingleServer().getAddress().getAuthority() : redis:\r\n[2022-08-09 02:04:44,389] INFO  [RedissonUtil.java,197] config.useSingleServer().getAddress().getSchemeSpecificPart() : //redis://192.168.8.8:8787\r\n[2022-08-09 02:04:44,392] INFO  [RedissonUtil.java,198] config.useSingleServer().getAddress().toString() : //[redis://192.168.8.8:8787](redis://54.251.163.28:8992)\r\n\r\nCaused by: java.lang.IllegalArgumentException: hostname can't be null\r\n\tat java.net.InetSocketAddress.checkHost(InetSocketAddress.java:149)\r\n\tat java.net.InetSocketAddress.<init>(InetSocketAddress.java:216)\r\n\tat org.redisson.client.RedisClient.<init>(RedisClient.java:93)\r\n\tat org.redisson.connection.MasterSlaveConnectionManager.createClient(MasterSlaveConnectionManager.java:310)\r\n\tat org.redisson.connection.MasterSlaveConnectionManager.createClient(MasterSlaveConnectionManager.java:298)\r\n\tat org.redisson.connection.SingleEntry.setupMasterEntry(SingleEntry.java:47)\r\n\tat org.redisson.connection.MasterSlaveConnectionManager.initEntry(MasterSlaveConnectionManager.java:247)\r\n\tat org.redisson.connection.MasterSlaveConnectionManager.init(MasterSlaveConnectionManager.java:229)\r\n\tat org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:155)\r\n\tat org.redisson.connection.SingleConnectionManager.<init>(SingleConnectionManager.java:43)\r\n\tat org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:166)\r\n\tat org.redisson.Redisson.<init>(Redisson.java:103)\r\n\r\nOn the same server for other application, same code and same url is working fine without any error.\r\n\r\nif i changed the url to only IP and port then it is working fine.\r\ne.g. config.useSingleServer().setAddress(192.168.8.8:8787);\r\n\r\ncould you please help to get the RCA of this issue asap.\r\n\r\nThanks,\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4475/comments",
    "author": "ankits114",
    "comments": [
      {
        "user": "ankits114",
        "created_at": "2022-08-10T04:06:11Z",
        "body": "Any update team ?"
      },
      {
        "user": "mrniko",
        "created_at": "2022-08-18T09:04:46Z",
        "body": "Unable to reproduce with the latest version"
      }
    ]
  },
  {
    "number": 4469,
    "title": "【Quarkus】 ERROR [org.red.cli.han.CommandDecoder] (redisson-netty-2-3) Unable to decode data，java.io.IOException: Unsupported protocol version 91",
    "created_at": "2022-08-06T04:18:44Z",
    "closed_at": "2022-08-23T07:00:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4469",
    "body": "> quarkus: 2.11.1.Final\r\nredission: org.redisson:redisson-quarkus-20:3.17.5\r\nos: windows10\r\njava: jdk17\r\ngradle:7.4.2\r\n\r\nexample\r\n```\r\n@Inject RedissonClient redisson;\r\n\r\nredisson.getBucket(name).get()\r\n```\r\n\r\nerror\r\n```\r\n2022-08-06 12:16:48,730 INFO  [org.red.Version] (vert.x-eventloop-thread-0) Redisson 3.17.5\r\n2022-08-06 12:16:48,756 WARN  [io.net.res.dns.DefaultDnsServerAddressStreamProvider] (vert.x-eventloop-thread-0) Default DNS servers: [/8.8.8.8:53, /8.8.4.4:53] (Google Public DNS as a fallback)\r\n2022-08-06 12:16:48,823 INFO  [org.red.con.poo.MasterPubSubConnectionPool] (redisson-netty-2-7) 1 connections initialized for 127.0.0.1/127.0.0.1:6379\r\n2022-08-06 12:16:48,843 INFO  [org.red.con.poo.MasterConnectionPool] (redisson-netty-2-19) 24 connections initialized for 127.0.0.1/127.0.0.1:6379\r\n2022-08-06 12:16:48,875 ERROR [org.red.cli.han.CommandDecoder] (redisson-netty-2-2) Unable to decode data. channel: [id: 0xc67421d2, L:/127.0.0.1:52171 - R:127.0.0.1/127.0.0.1:6379], reply: ReplayingDecoderByteBuf(ridx=15, widx=15), command: (GET), promise: java.util.concurrent.CompletableFuture@33092a10[Not completed, 1 dependents], params: [156151516156161]: java.io.IOException: Unsupported protocol version 91\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.start(RiverUnmarshaller.java:1375)\r\n\tat org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:145)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:383)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:833)\r\n\r\n2022-08-06 12:16:48,877 ERROR [org.red.cli.han.ErrorsLoggingHandler] (redisson-netty-2-2) Exception occured. Channel: [id: 0xc67421d2, L:/127.0.0.1:52171 - R:127.0.0.1/127.0.0.1:6379]: io.netty.handler.codec.DecoderException: java.io.IOException: Unsupported protocol version 91\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:833)\r\nCaused by: java.io.IOException: Unsupported protocol version 91\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.start(RiverUnmarshaller.java:1375)\r\n\tat org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:145)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:383)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\t... 17 more\r\n\r\n2022-08-06 12:16:48,880 ERROR [io.qua.ver.htt.run.QuarkusErrorHandler] (vert.x-eventloop-thread-0) HTTP Request to /verify failed, error id: a88b8cdf-3e5b-4bc1-9e5a-01650398d839-1: org.redisson.client.RedisException: Unexpected exception while processing command\r\n\tat org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:276)\r\n\tat org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:115)\r\n\tat org.redisson.RedissonObject.get(RedissonObject.java:82)\r\n\tat org.redisson.RedissonBucket.get(RedissonBucket.java:135)\r\n\tat com.seepine.lottery.draw.prize.util.RedisUtil.get(RedisUtil.java:13)\r\n\tat com.seepine.lottery.draw.prize.util.RedisUtil_Subclass.get$$superforward1(Unknown Source)\r\n\tat com.seepine.lottery.draw.prize.util.RedisUtil_Subclass$$function$$1.apply(Unknown Source)\r\n\tat io.quarkus.arc.impl.AroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:53)\r\n\tat io.quarkus.arc.runtime.devconsole.InvocationInterceptor.proceed(InvocationInterceptor.java:62)\r\n\tat io.quarkus.arc.runtime.devconsole.InvocationInterceptor.monitor(InvocationInterceptor.java:51)\r\n\tat io.quarkus.arc.runtime.devconsole.InvocationInterceptor_Bean.intercept(Unknown Source)\r\n\tat io.quarkus.arc.impl.InterceptorInvocation.invoke(InterceptorInvocation.java:41)\r\n\tat io.quarkus.arc.impl.AroundInvokeInvocationContext.perform(AroundInvokeInvocationContext.java:40)\r\n\tat io.quarkus.arc.impl.InvocationContexts.performAroundInvoke(InvocationContexts.java:32)\r\n\tat com.seepine.lottery.draw.prize.util.RedisUtil_Subclass.get(Unknown Source)\r\n\tat com.seepine.lottery.draw.prize.util.RedisUtil_ClientProxy.get(Unknown Source)\r\n\tat com.seepine.lottery.draw.prize.provider.TestJWTCallerPrincipalFactory.parse(TestJWTCallerPrincipalFactory.java:32)\r\n\tat com.seepine.lottery.draw.prize.provider.TestJWTCallerPrincipalFactory_Subclass.parse$$superforward1(Unknown Source)\r\n\tat com.seepine.lottery.draw.prize.provider.TestJWTCallerPrincipalFactory_Subclass$$function$$1.apply(Unknown Source)\r\n\tat io.quarkus.arc.impl.AroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:53)\r\n\tat io.quarkus.arc.runtime.devconsole.InvocationInterceptor.proceed(InvocationInterceptor.java:62)\r\n\tat io.quarkus.arc.runtime.devconsole.InvocationInterceptor.monitor(InvocationInterceptor.java:51)\r\n\tat io.quarkus.arc.runtime.devconsole.InvocationInterceptor_Bean.intercept(Unknown Source)\r\n\tat io.quarkus.arc.impl.InterceptorInvocation.invoke(InterceptorInvocation.java:41)\r\n\tat io.quarkus.arc.impl.AroundInvokeInvocationContext.perform(AroundInvokeInvocationContext.java:40)\r\n\tat io.quarkus.arc.impl.InvocationContexts.performAroundInvoke(InvocationContexts.java:32)\r\n\tat com.seepine.lottery.draw.prize.provider.TestJWTCallerPrincipalFactory_Subclass.parse(Unknown Source)\r\n\tat com.seepine.lottery.draw.prize.provider.TestJWTCallerPrincipalFactory_ClientProxy.parse(Unknown Source)\r\n\tat io.smallrye.jwt.auth.principal.DefaultJWTParser.parse(DefaultJWTParser.java:64)\r\n\tat io.smallrye.jwt.auth.principal.DefaultJWTParser_Subclass.parse$$superforward1(Unknown Source)\r\n\tat io.smallrye.jwt.auth.principal.DefaultJWTParser_Subclass$$function$$6.apply(Unknown Source)\r\n\tat io.quarkus.arc.impl.AroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:53)\r\n\tat io.quarkus.arc.runtime.devconsole.InvocationInterceptor.proceed(InvocationInterceptor.java:62)\r\n\tat io.quarkus.arc.runtime.devconsole.InvocationInterceptor.monitor(InvocationInterceptor.java:51)\r\n\tat io.quarkus.arc.runtime.devconsole.InvocationInterceptor_Bean.intercept(Unknown Source)\r\n\tat io.quarkus.arc.impl.InterceptorInvocation.invoke(InterceptorInvocation.java:41)\r\n\tat io.quarkus.arc.impl.AroundInvokeInvocationContext.perform(AroundInvokeInvocationContext.java:40)\r\n\tat io.quarkus.arc.impl.InvocationContexts.performAroundInvoke(InvocationContexts.java:32)\r\n\tat io.smallrye.jwt.auth.principal.DefaultJWTParser_Subclass.parse(Unknown Source)\r\n\tat io.smallrye.jwt.auth.principal.DefaultJWTParser_ClientProxy.parse(Unknown Source)\r\n\tat io.quarkus.smallrye.jwt.runtime.auth.MpJwtValidator.createSecurityIdentity(MpJwtValidator.java:76)\r\n\tat io.quarkus.smallrye.jwt.runtime.auth.MpJwtValidator$1.accept(MpJwtValidator.java:62)\r\n\tat io.quarkus.smallrye.jwt.runtime.auth.MpJwtValidator$1.accept(MpJwtValidator.java:58)\r\n\tat io.smallrye.context.impl.wrappers.SlowContextualConsumer.accept(SlowContextualConsumer.java:21)\r\n\tat io.smallrye.mutiny.operators.uni.builders.UniCreateWithEmitter.subscribe(UniCreateWithEmitter.java:22)\r\n\tat io.smallrye.mutiny.operators.AbstractUni.subscribe(AbstractUni.java:36)\r\n\tat io.smallrye.mutiny.operators.uni.UniMemoizeOp.subscribe(UniMemoizeOp.java:84)\r\n\tat io.smallrye.mutiny.operators.AbstractUni.subscribe(AbstractUni.java:36)\r\n\tat io.smallrye.mutiny.groups.UniSubscribe.withSubscriber(UniSubscribe.java:52)\r\n\tat io.quarkus.vertx.http.runtime.security.HttpSecurityRecorder$2.handle(HttpSecurityRecorder.java:113)\r\n\tat io.quarkus.vertx.http.runtime.security.HttpSecurityRecorder$2.handle(HttpSecurityRecorder.java:60)\r\n\tat io.vertx.ext.web.impl.RouteState.handleContext(RouteState.java:1284)\r\n\tat io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:173)\r\n\tat io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:140)\r\n\tat io.quarkus.vertx.http.runtime.devmode.VertxHttpHotReplacementSetup$5.handle(VertxHttpHotReplacementSetup.java:196)\r\n\tat io.quarkus.vertx.http.runtime.devmode.VertxHttpHotReplacementSetup$5.handle(VertxHttpHotReplacementSetup.java:185)\r\n\tat io.vertx.core.impl.future.FutureImpl$3.onSuccess(FutureImpl.java:141)\r\n\tat io.vertx.core.impl.future.FutureBase.lambda$emitSuccess$0(FutureBase.java:54)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.runTask(AbstractEventExecutor.java:174)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:167)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:470)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:503)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:833)\r\nCaused by: java.io.IOException: Unsupported protocol version 91\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.start(RiverUnmarshaller.java:1375)\r\n\tat org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:145)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:383)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n\t... 4 more\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4469/comments",
    "author": "seepine",
    "comments": [
      {
        "user": "seepine",
        "created_at": "2022-08-06T04:19:37Z",
        "body": "or it is not support jdk17 ?"
      },
      {
        "user": "mrniko",
        "created_at": "2022-08-06T09:56:41Z",
        "body": "Try to update jboss-marshalling codec lib to 2.1.0.Final version or use Kryo5Codec instead"
      },
      {
        "user": "smilesum",
        "created_at": "2023-04-14T03:03:21Z",
        "body": "like this? @mrniko \r\n```\r\nimport org.redisson.codec.Kryo5Codec;\r\n\r\nRSet<String> keys = redissonClient.getSet(\"test-kley\", new Kryo5Codec());\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2023-04-14T04:27:26Z",
        "body": "@smilesum \r\n\r\nYou can set it through Redisson Config object to make it global."
      }
    ]
  },
  {
    "number": 4467,
    "title": "How work the lock management using reactor library",
    "created_at": "2022-08-05T14:23:54Z",
    "closed_at": "2022-08-23T07:03:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4467",
    "body": "I try to use redisson lock on a spring/reactor stack. \r\nFollowing the doc, I tried the following code: \r\n``` java\r\nreturn MonoLog.info(\"try to get the lock\")\r\n            .then(lock.tryLock(10, 15, TimeUnit.SECONDS))\r\n            .flatMap(isLocked -> {\r\n                if (isLocked) {\r\n                    return MonoLog.info(\"starting treatment\")\r\n                        .then(Mono.delay(Duration.ofSeconds(10)))\r\n                        .then(MonoLog.info(\"end of treatment\"));\r\n                } else {\r\n                    return Mono.error(new CanNotAcquireLockForCustomerOrder(event.getMetadata().getCustomerOrderId()));\r\n                }\r\n            })\r\n            .doFinally(signal ->\r\n                Mono.fromRunnable(() -> log.info(\"unlock the lock\"))\r\n                    .then(lock.forceUnlock())\r\n                    .subscribe()\r\n            )\r\n            .then()\r\n```\r\n\r\nBut I see that the lock is ignored and two treatments can be run in parallel. \r\nIt seem that the lock works when two different thread ask for it, but if the same thread ask the lock two time it has no effect.\r\n\r\nTo fix this issue, I replaced the code `lock.tryLock(10, 15, TimeUnit.SECONDS)` by `lock.tryLock(10, 15, TimeUnit.SECONDS, new Random().nextLong())` and now that's work. \r\n\r\nI don't really understand this behavior since reactive stack reuse threads. Can you help me to understand this issue, and fine a better solution. \r\n\r\nThanks.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4467/comments",
    "author": "deblockt",
    "comments": [
      {
        "user": "zhuangzibin",
        "created_at": "2022-08-10T06:46:10Z",
        "body": "@deblockt hello.I think the same threadId make this unlock.Maybe u LockName is constant.\r\nI try to write it like this, but it's not necessarily right.It's been running for half a year, no problem for now.\r\nBut I think redisson should be used the contextView of webflux.\r\n```\r\n@Slf4j\r\n@Component\r\n@RequiredArgsConstructor\r\npublic class RedissonUtil {\r\n\r\n    private final RedissonReactiveClient redissonReactiveClient;\r\n\r\n    public <T> Mono<T> autoLock(RedissonLockEnum redissonLock, String value, Supplier<Mono<T>> supplier) {\r\n        RLockReactive lock = redissonReactiveClient.getLock(String.format(redissonLock.getValue(), value));\r\n        var threadId = ThreadLocalRandom.current().nextLong();\r\n        return lock.tryLock(threadId)\r\n            .filter(Boolean.TRUE::equals)\r\n            .switchIfEmpty(Mono.error(new RespException(\"Do not resubmit\", CodeEnum.CLIENT_REQUEST_REPEAT)))\r\n            .flatMap(res -> supplier.get())\r\n            .doFinally(signalType -> lock.unlock(threadId).subscribe());\r\n    }\r\n}\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2022-08-23T07:03:21Z",
        "body": "@zhuangzibin \r\n\r\nYou need to handle that manually. I would like to avoid webflux dependency."
      }
    ]
  },
  {
    "number": 4466,
    "title": "Is it possible for only some of the commands in a batch to execute?",
    "created_at": "2022-08-04T23:04:25Z",
    "closed_at": "2022-08-18T09:10:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4466",
    "body": "If I am doing a batch with Execution Mode : REDIS_WRITE_ATOMIC,\r\nIs it possible for my batch to fail halfway, and have only made half the changes for example? Or if it fails in the middle will all of the changes be undone?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4466/comments",
    "author": "kombuch",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-08-18T09:10:51Z",
        "body": "> Is it possible for my batch to fail halfway, and have only made half the changes for example? Or if it fails in the middle will all of the changes be undone?\r\n\r\nNo, it's not supported by Redis batch."
      }
    ]
  },
  {
    "number": 4464,
    "title": "New error with v3.17.4 and how to do read only",
    "created_at": "2022-08-04T11:34:56Z",
    "closed_at": "2022-08-09T11:25:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4464",
    "body": "After upgrading to 3.17.4 I have a new error in my logs not previously seen:\r\n\r\n```\r\norg.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0x25059142, L:/127.0.0.1:62151 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@6568c9ba[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, geofencingZonesCache_10, redisson__timeout__set:{geofencingZonesCache_10}, redisson__idle__set:{geofencingZonesCache_10}, redisson_map_cache_expired:{geofencingZonesCache_10}, redisson__map_cache__last_access__set:{geofencingZonesCache_10}, redisson__execute_task_once_latch:{geofencingZonesCache_10}, 1659612415403, 100, ...]\\n\\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:370)\\n\\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\\n\\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\\n\\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\\n\\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\\n\\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\\n\\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\\n\\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\\n\\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\\n\\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\\n\\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\\n\\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\\n\\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\\n\\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\\n\\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\\n\\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\\n\\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\\n\\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\\n\\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\\n\\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\\n\\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\\n\\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\\n\\tat java.base/java.lang.Thread.run(Thread.java:832)\r\n```\r\n\r\nWe use google memorystore with redis, and read replicas. For performance reasons we have 2 kubernetes deployments, one which writes to the main endpoint, and the other reading from the read replica endpoint.\r\n\r\nThe error above is from the deployment which is only supposed to read, not do any writing.\r\n\r\nIt's starting to occur to me that I maybe should configure these deployments differently with regards to redisson? Right now they use the same config using single server just pointing to different endpoints.\r\n\r\nWhy am I only getting this error with upgrade to 3.17.4, and can you point me towards the proper way to configure this setup?\r\n\r\nThanks in advance!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4464/comments",
    "author": "testower",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-08-05T06:05:03Z",
        "body": "Can you share logs with `trace` logging level for `org.redisson` package?"
      },
      {
        "user": "testower",
        "created_at": "2022-08-05T08:13:14Z",
        "body": "Definitely! Didn't know how much to collect but here's a sample:\r\n\r\n```\r\n2022-08-05 10:10:17.609 DEBUG 66618 --- [oundedElastic-1] org.redisson.command.RedisExecutor       : acquired connection for command (INFO) and params [server] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node localhost/127.0.0.1:6379... RedisConnection@1528679632 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xcebf8a96, L:/127.0.0.1:51210 - R:localhost/127.0.0.1:6379], currentCommand=null, usage=1]\r\n2022-08-05 10:10:17.613 TRACE 66618 --- [isson-netty-2-3] o.r.client.handler.CommandEncoder        : channel: [id: 0xcebf8a96, L:/127.0.0.1:51210 - R:localhost/127.0.0.1:6379] message: *2\r\n$4\r\nINFO\r\n$6\r\nserver\r\n\r\n2022-08-05 10:10:17.656 TRACE 66618 --- [isson-netty-2-3] o.r.client.handler.CommandDecoder        : reply: $602\r\n# Server\r\nredis_version:6.2.7\r\nredis_git_sha1:00000000\r\nredis_git_dirty:0\r\nredis_build_id:1a1bb2d023fdc368\r\nredis_mode:standalone\r\nos:Linux 5.10.90+ x86_64\r\narch_bits:64\r\nmonotonic_clock:POSIX clock_gettime\r\nmultiplexing_api:epoll\r\natomicvar_api:c11-builtin\r\ngcc_version:6.3.0\r\nprocess_id:1\r\nprocess_supervised:no\r\nrun_id:9dd4ba4e35bd822cc367557101d7555373f7c621\r\ntcp_port:6379\r\nserver_time_usec:1659687017854042\r\nuptime_in_seconds:5455343\r\nuptime_in_days:63\r\nhz:10\r\nconfigured_hz:10\r\nlru_clock:15519849\r\nexecutable:/data/redis-server\r\nconfig_file:/usr/local/etc/redis/redis.conf\r\nio_threads_active:0\r\n\r\n, channel: [id: 0xcebf8a96, L:/127.0.0.1:51210 - R:localhost/127.0.0.1:6379], command: CommandData [promise=java.util.concurrent.CompletableFuture@269a3b25[Not completed, 1 dependents], command=(INFO), params=[server], codec=org.redisson.client.codec.StringCodec]\r\n2022-08-05 10:10:17.659 DEBUG 66618 --- [isson-netty-2-3] org.redisson.command.RedisExecutor       : connection released for command (INFO) and params [server] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@1528679632 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xcebf8a96, L:/127.0.0.1:51210 - R:localhost/127.0.0.1:6379], currentCommand=CommandData [promise=java.util.concurrent.CompletableFuture@269a3b25[Completed normally], command=(INFO), params=[server], codec=org.redisson.client.codec.StringCodec], usage=0]\r\n2022-08-05 10:10:18.397 DEBUG 66618 --- [sson-netty-2-22] org.redisson.connection.DNSMonitor       : Request sent to resolve ip address for master host: localhost\r\n2022-08-05 10:10:18.399 DEBUG 66618 --- [sson-netty-2-21] org.redisson.connection.DNSMonitor       : Resolved ip: localhost/127.0.0.1 for master host: localhost\r\n2022-08-05 10:10:18.557 DEBUG 66618 --- [sson-netty-2-23] org.redisson.command.RedisExecutor       : acquired connection for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, vehicleCache_10, redisson__timeout__set:{vehicleCache_10}, redisson__idle__set:{vehicleCache_10}, redisson_map_cache_expired:{vehicleCache_10}, redisson__map_cache__last_access__set:{vehicleCache_10}, redisson__execute_task_once_latch:{vehicleCache_10}, 1659687018556, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node localhost/127.0.0.1:6379... RedisConnection@1450590547 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x7aec8c3a, L:/127.0.0.1:51211 - R:localhost/127.0.0.1:6379], currentCommand=null, usage=1]\r\n2022-08-05 10:10:18.559 TRACE 66618 --- [isson-netty-2-4] o.r.client.handler.CommandEncoder        : channel: [id: 0x7aec8c3a, L:/127.0.0.1:51211 - R:localhost/127.0.0.1:6379] message: *13\r\n$4\r\nEVAL\r\n$1824\r\nif redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[3]); local expiredKeys1 = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys1) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys1, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[3], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[2], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('hdel', KEYS[1], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); end; local expiredKeys2 = redis.call('zrangebyscore', KEYS[3], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys2) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys2, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[3], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[2], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('hdel', KEYS[1], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); end; return #expiredKeys1 + #expiredKeys2;\r\n$1\r\n6\r\n$15\r\nvehicleCache_10\r\n$40\r\nredisson__timeout__set:{vehicleCache_10}\r\n$37\r\nredisson__idle__set:{vehicleCache_10}\r\n$44\r\nredisson_map_cache_expired:{vehicleCache_10}\r\n$55\r\nredisson__map_cache__last_access__set:{vehicleCache_10}\r\n$51\r\nredisson__execute_task_once_latch:{vehicleCache_10}\r\n$13\r\n1659687018556\r\n$3\r\n100\r\n$1\r\n5\r\n$1\r\n1\r\n\r\n2022-08-05 10:10:18.596 DEBUG 66618 --- [sson-netty-2-24] org.redisson.command.RedisExecutor       : acquired connection for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, stationCache_10, redisson__timeout__set:{stationCache_10}, redisson__idle__set:{stationCache_10}, redisson_map_cache_expired:{stationCache_10}, redisson__map_cache__last_access__set:{stationCache_10}, redisson__execute_task_once_latch:{stationCache_10}, 1659687018596, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node localhost/127.0.0.1:6379... RedisConnection@1365164103 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x356942fa, L:/127.0.0.1:51213 - R:localhost/127.0.0.1:6379], currentCommand=null, usage=1]\r\n2022-08-05 10:10:18.598 TRACE 66618 --- [isson-netty-2-9] o.r.client.handler.CommandEncoder        : channel: [id: 0x356942fa, L:/127.0.0.1:51213 - R:localhost/127.0.0.1:6379] message: *13\r\n$4\r\nEVAL\r\n$1824\r\nif redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[3]); local expiredKeys1 = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys1) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys1, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[3], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[2], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('hdel', KEYS[1], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); end; local expiredKeys2 = redis.call('zrangebyscore', KEYS[3], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys2) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys2, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[3], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[2], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('hdel', KEYS[1], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); end; return #expiredKeys1 + #expiredKeys2;\r\n$1\r\n6\r\n$15\r\nstationCache_10\r\n$40\r\nredisson__timeout__set:{stationCache_10}\r\n$37\r\nredisson__idle__set:{stationCache_10}\r\n$44\r\nredisson_map_cache_expired:{stationCache_10}\r\n$55\r\nredisson__map_cache__last_access__set:{stationCache_10}\r\n$51\r\nredisson__execute_task_once_latch:{stationCache_10}\r\n$13\r\n1659687018596\r\n$3\r\n100\r\n$1\r\n5\r\n$1\r\n1\r\n\r\n2022-08-05 10:10:18.610 TRACE 66618 --- [isson-netty-2-4] o.r.client.handler.CommandDecoder        : reply: -ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.\r\n, channel: [id: 0x7aec8c3a, L:/127.0.0.1:51211 - R:localhost/127.0.0.1:6379], command: CommandData [promise=java.util.concurrent.CompletableFuture@7581a742[Not completed, 1 dependents], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, vehicleCache_10, redisson__timeout__set:{vehicleCache_10}, redisson__idle__set:{vehicleCache_10}, redisson_map_cache_expired:{vehicleCache_10}, redisson__map_cache__last_access__set:{vehicleCache_10}, redisson__execute_task_once_latch:{vehicleCache_10}, 1659687018556, 100, ...], codec=org.redisson.client.codec.LongCodec]\r\n2022-08-05 10:10:18.610 DEBUG 66618 --- [sson-netty-2-25] org.redisson.command.RedisExecutor       : acquired connection for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, geofencingZonesCache_10, redisson__timeout__set:{geofencingZonesCache_10}, redisson__idle__set:{geofencingZonesCache_10}, redisson_map_cache_expired:{geofencingZonesCache_10}, redisson__map_cache__last_access__set:{geofencingZonesCache_10}, redisson__execute_task_once_latch:{geofencingZonesCache_10}, 1659687018610, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node localhost/127.0.0.1:6379... RedisConnection@921931119 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x1413ca1e, L:/127.0.0.1:51214 - R:localhost/127.0.0.1:6379], currentCommand=null, usage=1]\r\n2022-08-05 10:10:18.611 DEBUG 66618 --- [isson-netty-2-4] org.redisson.command.RedisExecutor       : connection released for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, vehicleCache_10, redisson__timeout__set:{vehicleCache_10}, redisson__idle__set:{vehicleCache_10}, redisson_map_cache_expired:{vehicleCache_10}, redisson__map_cache__last_access__set:{vehicleCache_10}, redisson__execute_task_once_latch:{vehicleCache_10}, 1659687018556, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@1450590547 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x7aec8c3a, L:/127.0.0.1:51211 - R:localhost/127.0.0.1:6379], currentCommand=CommandData [promise=java.util.concurrent.CompletableFuture@7581a742[Completed exceptionally: org.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0x7aec8c3a, L:/127.0.0.1:51211 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@7581a742[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, vehicleCache_10, redisson__timeout__set:{vehicleCache_10}, redisson__idle__set:{vehicleCache_10}, redisson_map_cache_expired:{vehicleCache_10}, redisson__map_cache__last_access__set:{vehicleCache_10}, redisson__execute_task_once_latch:{vehicleCache_10}, 1659687018556, 100, ...]], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, vehicleCache_10, redisson__timeout__set:{vehicleCache_10}, redisson__idle__set:{vehicleCache_10}, redisson_map_cache_expired:{vehicleCache_10}, redisson__map_cache__last_access__set:{vehicleCache_10}, redisson__execute_task_once_latch:{vehicleCache_10}, 1659687018556, 100, ...], codec=org.redisson.client.codec.LongCodec], usage=0]\r\n2022-08-05 10:10:18.614 ERROR 66618 --- [isson-netty-2-4] o.r.eviction.MapCacheEvictionTask        : Unable to evict elements for 'vehicleCache_10'\r\n\r\norg.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0x7aec8c3a, L:/127.0.0.1:51211 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@7581a742[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, vehicleCache_10, redisson__timeout__set:{vehicleCache_10}, redisson__idle__set:{vehicleCache_10}, redisson_map_cache_expired:{vehicleCache_10}, redisson__map_cache__last_access__set:{vehicleCache_10}, redisson__execute_task_once_latch:{vehicleCache_10}, 1659687018556, 100, ...]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:370)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:832)\r\n\r\n2022-08-05 10:10:18.616 TRACE 66618 --- [sson-netty-2-10] o.r.client.handler.CommandEncoder        : channel: [id: 0x1413ca1e, L:/127.0.0.1:51214 - R:localhost/127.0.0.1:6379] message: *13\r\n$4\r\nEVAL\r\n$1824\r\nif redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[3]); local expiredKeys1 = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys1) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys1, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[3], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[2], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('hdel', KEYS[1], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); end; local expiredKeys2 = redis.call('zrangebyscore', KEYS[3], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys2) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys2, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[3], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[2], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('hdel', KEYS[1], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); end; return #expiredKeys1 + #expiredKeys2;\r\n$1\r\n6\r\n$23\r\ngeofencingZonesCache_10\r\n$48\r\nredisson__timeout__set:{geofencingZonesCache_10}\r\n$45\r\nredisson__idle__set:{geofencingZonesCache_10}\r\n$52\r\nredisson_map_cache_expired:{geofencingZonesCache_10}\r\n$63\r\nredisson__map_cache__last_access__set:{geofencingZonesCache_10}\r\n$59\r\nredisson__execute_task_once_latch:{geofencingZonesCache_10}\r\n$13\r\n1659687018610\r\n$3\r\n100\r\n$1\r\n5\r\n$1\r\n1\r\n\r\n2022-08-05 10:10:18.664 TRACE 66618 --- [isson-netty-2-9] o.r.client.handler.CommandDecoder        : reply: -ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.\r\n, channel: [id: 0x356942fa, L:/127.0.0.1:51213 - R:localhost/127.0.0.1:6379], command: CommandData [promise=java.util.concurrent.CompletableFuture@345d85af[Not completed, 1 dependents], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, stationCache_10, redisson__timeout__set:{stationCache_10}, redisson__idle__set:{stationCache_10}, redisson_map_cache_expired:{stationCache_10}, redisson__map_cache__last_access__set:{stationCache_10}, redisson__execute_task_once_latch:{stationCache_10}, 1659687018596, 100, ...], codec=org.redisson.client.codec.LongCodec]\r\n2022-08-05 10:10:18.664 DEBUG 66618 --- [isson-netty-2-9] org.redisson.command.RedisExecutor       : connection released for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, stationCache_10, redisson__timeout__set:{stationCache_10}, redisson__idle__set:{stationCache_10}, redisson_map_cache_expired:{stationCache_10}, redisson__map_cache__last_access__set:{stationCache_10}, redisson__execute_task_once_latch:{stationCache_10}, 1659687018596, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@1365164103 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x356942fa, L:/127.0.0.1:51213 - R:localhost/127.0.0.1:6379], currentCommand=CommandData [promise=java.util.concurrent.CompletableFuture@345d85af[Completed exceptionally: org.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0x356942fa, L:/127.0.0.1:51213 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@345d85af[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, stationCache_10, redisson__timeout__set:{stationCache_10}, redisson__idle__set:{stationCache_10}, redisson_map_cache_expired:{stationCache_10}, redisson__map_cache__last_access__set:{stationCache_10}, redisson__execute_task_once_latch:{stationCache_10}, 1659687018596, 100, ...]], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, stationCache_10, redisson__timeout__set:{stationCache_10}, redisson__idle__set:{stationCache_10}, redisson_map_cache_expired:{stationCache_10}, redisson__map_cache__last_access__set:{stationCache_10}, redisson__execute_task_once_latch:{stationCache_10}, 1659687018596, 100, ...], codec=org.redisson.client.codec.LongCodec], usage=0]\r\n2022-08-05 10:10:18.664 ERROR 66618 --- [isson-netty-2-9] o.r.eviction.MapCacheEvictionTask        : Unable to evict elements for 'stationCache_10'\r\n\r\norg.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0x356942fa, L:/127.0.0.1:51213 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@345d85af[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, stationCache_10, redisson__timeout__set:{stationCache_10}, redisson__idle__set:{stationCache_10}, redisson_map_cache_expired:{stationCache_10}, redisson__map_cache__last_access__set:{stationCache_10}, redisson__execute_task_once_latch:{stationCache_10}, 1659687018596, 100, ...]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:370)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:832)\r\n\r\n2022-08-05 10:10:18.685 TRACE 66618 --- [sson-netty-2-10] o.r.client.handler.CommandDecoder        : reply: -ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.\r\n, channel: [id: 0x1413ca1e, L:/127.0.0.1:51214 - R:localhost/127.0.0.1:6379], command: CommandData [promise=java.util.concurrent.CompletableFuture@518171e5[Not completed, 1 dependents], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, geofencingZonesCache_10, redisson__timeout__set:{geofencingZonesCache_10}, redisson__idle__set:{geofencingZonesCache_10}, redisson_map_cache_expired:{geofencingZonesCache_10}, redisson__map_cache__last_access__set:{geofencingZonesCache_10}, redisson__execute_task_once_latch:{geofencingZonesCache_10}, 1659687018610, 100, ...], codec=org.redisson.client.codec.LongCodec]\r\n2022-08-05 10:10:18.685 DEBUG 66618 --- [sson-netty-2-10] org.redisson.command.RedisExecutor       : connection released for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, geofencingZonesCache_10, redisson__timeout__set:{geofencingZonesCache_10}, redisson__idle__set:{geofencingZonesCache_10}, redisson_map_cache_expired:{geofencingZonesCache_10}, redisson__map_cache__last_access__set:{geofencingZonesCache_10}, redisson__execute_task_once_latch:{geofencingZonesCache_10}, 1659687018610, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@921931119 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x1413ca1e, L:/127.0.0.1:51214 - R:localhost/127.0.0.1:6379], currentCommand=CommandData [promise=java.util.concurrent.CompletableFuture@518171e5[Completed exceptionally: org.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0x1413ca1e, L:/127.0.0.1:51214 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@518171e5[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, geofencingZonesCache_10, redisson__timeout__set:{geofencingZonesCache_10}, redisson__idle__set:{geofencingZonesCache_10}, redisson_map_cache_expired:{geofencingZonesCache_10}, redisson__map_cache__last_access__set:{geofencingZonesCache_10}, redisson__execute_task_once_latch:{geofencingZonesCache_10}, 1659687018610, 100, ...]], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, geofencingZonesCache_10, redisson__timeout__set:{geofencingZonesCache_10}, redisson__idle__set:{geofencingZonesCache_10}, redisson_map_cache_expired:{geofencingZonesCache_10}, redisson__map_cache__last_access__set:{geofencingZonesCache_10}, redisson__execute_task_once_latch:{geofencingZonesCache_10}, 1659687018610, 100, ...], codec=org.redisson.client.codec.LongCodec], usage=0]\r\n2022-08-05 10:10:18.685 ERROR 66618 --- [sson-netty-2-10] o.r.eviction.MapCacheEvictionTask        : Unable to evict elements for 'geofencingZonesCache_10'\r\n\r\norg.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0x1413ca1e, L:/127.0.0.1:51214 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@518171e5[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, geofencingZonesCache_10, redisson__timeout__set:{geofencingZonesCache_10}, redisson__idle__set:{geofencingZonesCache_10}, redisson_map_cache_expired:{geofencingZonesCache_10}, redisson__map_cache__last_access__set:{geofencingZonesCache_10}, redisson__execute_task_once_latch:{geofencingZonesCache_10}, 1659687018610, 100, ...]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:370)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:832)\r\n\r\n2022-08-05 10:10:20.591 DEBUG 66618 --- [sson-netty-2-26] org.redisson.command.RedisExecutor       : acquired connection for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, gbfsFeedCache_10, redisson__timeout__set:{gbfsFeedCache_10}, redisson__idle__set:{gbfsFeedCache_10}, redisson_map_cache_expired:{gbfsFeedCache_10}, redisson__map_cache__last_access__set:{gbfsFeedCache_10}, redisson__execute_task_once_latch:{gbfsFeedCache_10}, 1659687020590, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node localhost/127.0.0.1:6379... RedisConnection@2088412754 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x77202081, L:/127.0.0.1:51215 - R:localhost/127.0.0.1:6379], currentCommand=null, usage=1]\r\n2022-08-05 10:10:20.592 TRACE 66618 --- [sson-netty-2-13] o.r.client.handler.CommandEncoder        : channel: [id: 0x77202081, L:/127.0.0.1:51215 - R:localhost/127.0.0.1:6379] message: *13\r\n$4\r\nEVAL\r\n$1824\r\nif redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[3]); local expiredKeys1 = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys1) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys1, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[3], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[2], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('hdel', KEYS[1], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); end; local expiredKeys2 = redis.call('zrangebyscore', KEYS[3], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys2) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys2, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[3], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[2], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('hdel', KEYS[1], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); end; return #expiredKeys1 + #expiredKeys2;\r\n$1\r\n6\r\n$16\r\ngbfsFeedCache_10\r\n$41\r\nredisson__timeout__set:{gbfsFeedCache_10}\r\n$38\r\nredisson__idle__set:{gbfsFeedCache_10}\r\n$45\r\nredisson_map_cache_expired:{gbfsFeedCache_10}\r\n$56\r\nredisson__map_cache__last_access__set:{gbfsFeedCache_10}\r\n$52\r\nredisson__execute_task_once_latch:{gbfsFeedCache_10}\r\n$13\r\n1659687020590\r\n$3\r\n100\r\n$1\r\n5\r\n$1\r\n1\r\n\r\n2022-08-05 10:10:20.639 TRACE 66618 --- [sson-netty-2-13] o.r.client.handler.CommandDecoder        : reply: -ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.\r\n, channel: [id: 0x77202081, L:/127.0.0.1:51215 - R:localhost/127.0.0.1:6379], command: CommandData [promise=java.util.concurrent.CompletableFuture@7b10c49e[Not completed, 1 dependents], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, gbfsFeedCache_10, redisson__timeout__set:{gbfsFeedCache_10}, redisson__idle__set:{gbfsFeedCache_10}, redisson_map_cache_expired:{gbfsFeedCache_10}, redisson__map_cache__last_access__set:{gbfsFeedCache_10}, redisson__execute_task_once_latch:{gbfsFeedCache_10}, 1659687020590, 100, ...], codec=org.redisson.client.codec.LongCodec]\r\n2022-08-05 10:10:20.639 DEBUG 66618 --- [sson-netty-2-13] org.redisson.command.RedisExecutor       : connection released for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, gbfsFeedCache_10, redisson__timeout__set:{gbfsFeedCache_10}, redisson__idle__set:{gbfsFeedCache_10}, redisson_map_cache_expired:{gbfsFeedCache_10}, redisson__map_cache__last_access__set:{gbfsFeedCache_10}, redisson__execute_task_once_latch:{gbfsFeedCache_10}, 1659687020590, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@2088412754 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x77202081, L:/127.0.0.1:51215 - R:localhost/127.0.0.1:6379], currentCommand=CommandData [promise=java.util.concurrent.CompletableFuture@7b10c49e[Completed exceptionally: org.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0x77202081, L:/127.0.0.1:51215 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@7b10c49e[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, gbfsFeedCache_10, redisson__timeout__set:{gbfsFeedCache_10}, redisson__idle__set:{gbfsFeedCache_10}, redisson_map_cache_expired:{gbfsFeedCache_10}, redisson__map_cache__last_access__set:{gbfsFeedCache_10}, redisson__execute_task_once_latch:{gbfsFeedCache_10}, 1659687020590, 100, ...]], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, gbfsFeedCache_10, redisson__timeout__set:{gbfsFeedCache_10}, redisson__idle__set:{gbfsFeedCache_10}, redisson_map_cache_expired:{gbfsFeedCache_10}, redisson__map_cache__last_access__set:{gbfsFeedCache_10}, redisson__execute_task_once_latch:{gbfsFeedCache_10}, 1659687020590, 100, ...], codec=org.redisson.client.codec.LongCodec], usage=0]\r\n2022-08-05 10:10:20.639 ERROR 66618 --- [sson-netty-2-13] o.r.eviction.MapCacheEvictionTask        : Unable to evict elements for 'gbfsFeedCache_10'\r\n\r\norg.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0x77202081, L:/127.0.0.1:51215 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@7b10c49e[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, gbfsFeedCache_10, redisson__timeout__set:{gbfsFeedCache_10}, redisson__idle__set:{gbfsFeedCache_10}, redisson_map_cache_expired:{gbfsFeedCache_10}, redisson__map_cache__last_access__set:{gbfsFeedCache_10}, redisson__execute_task_once_latch:{gbfsFeedCache_10}, 1659687020590, 100, ...]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:370)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:832)\r\n\r\n2022-08-05 10:10:20.924 DEBUG 66618 --- [sson-netty-2-27] org.redisson.command.RedisExecutor       : acquired connection for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, validationReportCache_10, redisson__timeout__set:{validationReportCache_10}, redisson__idle__set:{validationReportCache_10}, redisson_map_cache_expired:{validationReportCache_10}, redisson__map_cache__last_access__set:{validationReportCache_10}, redisson__execute_task_once_latch:{validationReportCache_10}, 1659687020924, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node localhost/127.0.0.1:6379... RedisConnection@610058181 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x3a7bd3f8, L:/127.0.0.1:51216 - R:localhost/127.0.0.1:6379], currentCommand=null, usage=1]\r\n2022-08-05 10:10:20.925 TRACE 66618 --- [sson-netty-2-14] o.r.client.handler.CommandEncoder        : channel: [id: 0x3a7bd3f8, L:/127.0.0.1:51216 - R:localhost/127.0.0.1:6379] message: *13\r\n$4\r\nEVAL\r\n$1824\r\nif redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[3]); local expiredKeys1 = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys1) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys1, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[3], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[2], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('hdel', KEYS[1], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); end; local expiredKeys2 = redis.call('zrangebyscore', KEYS[3], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys2) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys2, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[3], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[2], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('hdel', KEYS[1], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); end; return #expiredKeys1 + #expiredKeys2;\r\n$1\r\n6\r\n$24\r\nvalidationReportCache_10\r\n$49\r\nredisson__timeout__set:{validationReportCache_10}\r\n$46\r\nredisson__idle__set:{validationReportCache_10}\r\n$53\r\nredisson_map_cache_expired:{validationReportCache_10}\r\n$64\r\nredisson__map_cache__last_access__set:{validationReportCache_10}\r\n$60\r\nredisson__execute_task_once_latch:{validationReportCache_10}\r\n$13\r\n1659687020924\r\n$3\r\n100\r\n$1\r\n5\r\n$1\r\n1\r\n\r\n2022-08-05 10:10:20.980 TRACE 66618 --- [sson-netty-2-14] o.r.client.handler.CommandDecoder        : reply: -ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.\r\n, channel: [id: 0x3a7bd3f8, L:/127.0.0.1:51216 - R:localhost/127.0.0.1:6379], command: CommandData [promise=java.util.concurrent.CompletableFuture@3d50665f[Not completed, 1 dependents], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, validationReportCache_10, redisson__timeout__set:{validationReportCache_10}, redisson__idle__set:{validationReportCache_10}, redisson_map_cache_expired:{validationReportCache_10}, redisson__map_cache__last_access__set:{validationReportCache_10}, redisson__execute_task_once_latch:{validationReportCache_10}, 1659687020924, 100, ...], codec=org.redisson.client.codec.LongCodec]\r\n2022-08-05 10:10:20.981 DEBUG 66618 --- [sson-netty-2-14] org.redisson.command.RedisExecutor       : connection released for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, validationReportCache_10, redisson__timeout__set:{validationReportCache_10}, redisson__idle__set:{validationReportCache_10}, redisson_map_cache_expired:{validationReportCache_10}, redisson__map_cache__last_access__set:{validationReportCache_10}, redisson__execute_task_once_latch:{validationReportCache_10}, 1659687020924, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@610058181 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x3a7bd3f8, L:/127.0.0.1:51216 - R:localhost/127.0.0.1:6379], currentCommand=CommandData [promise=java.util.concurrent.CompletableFuture@3d50665f[Completed exceptionally: org.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0x3a7bd3f8, L:/127.0.0.1:51216 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@3d50665f[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, validationReportCache_10, redisson__timeout__set:{validationReportCache_10}, redisson__idle__set:{validationReportCache_10}, redisson_map_cache_expired:{validationReportCache_10}, redisson__map_cache__last_access__set:{validationReportCache_10}, redisson__execute_task_once_latch:{validationReportCache_10}, 1659687020924, 100, ...]], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, validationReportCache_10, redisson__timeout__set:{validationReportCache_10}, redisson__idle__set:{validationReportCache_10}, redisson_map_cache_expired:{validationReportCache_10}, redisson__map_cache__last_access__set:{validationReportCache_10}, redisson__execute_task_once_latch:{validationReportCache_10}, 1659687020924, 100, ...], codec=org.redisson.client.codec.LongCodec], usage=0]\r\n2022-08-05 10:10:20.981 ERROR 66618 --- [sson-netty-2-14] o.r.eviction.MapCacheEvictionTask        : Unable to evict elements for 'validationReportCache_10'\r\n\r\norg.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0x3a7bd3f8, L:/127.0.0.1:51216 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@3d50665f[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, validationReportCache_10, redisson__timeout__set:{validationReportCache_10}, redisson__idle__set:{validationReportCache_10}, redisson_map_cache_expired:{validationReportCache_10}, redisson__map_cache__last_access__set:{validationReportCache_10}, redisson__execute_task_once_latch:{validationReportCache_10}, 1659687020924, 100, ...]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:370)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:832)\r\n\r\n2022-08-05 10:10:23.400 DEBUG 66618 --- [sson-netty-2-28] org.redisson.connection.DNSMonitor       : Request sent to resolve ip address for master host: localhost\r\n2022-08-05 10:10:23.401 DEBUG 66618 --- [sson-netty-2-21] org.redisson.connection.DNSMonitor       : Resolved ip: localhost/127.0.0.1 for master host: localhost\r\n2022-08-05 10:10:23.615 DEBUG 66618 --- [sson-netty-2-29] org.redisson.command.RedisExecutor       : acquired connection for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, vehicleCache_10, redisson__timeout__set:{vehicleCache_10}, redisson__idle__set:{vehicleCache_10}, redisson_map_cache_expired:{vehicleCache_10}, redisson__map_cache__last_access__set:{vehicleCache_10}, redisson__execute_task_once_latch:{vehicleCache_10}, 1659687023615, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node localhost/127.0.0.1:6379... RedisConnection@670172570 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xc3725620, L:/127.0.0.1:51217 - R:localhost/127.0.0.1:6379], currentCommand=null, usage=1]\r\n2022-08-05 10:10:23.616 TRACE 66618 --- [sson-netty-2-16] o.r.client.handler.CommandEncoder        : channel: [id: 0xc3725620, L:/127.0.0.1:51217 - R:localhost/127.0.0.1:6379] message: *13\r\n$4\r\nEVAL\r\n$1824\r\nif redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[3]); local expiredKeys1 = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys1) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys1, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[3], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[2], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('hdel', KEYS[1], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); end; local expiredKeys2 = redis.call('zrangebyscore', KEYS[3], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys2) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys2, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[3], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[2], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('hdel', KEYS[1], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); end; return #expiredKeys1 + #expiredKeys2;\r\n$1\r\n6\r\n$15\r\nvehicleCache_10\r\n$40\r\nredisson__timeout__set:{vehicleCache_10}\r\n$37\r\nredisson__idle__set:{vehicleCache_10}\r\n$44\r\nredisson_map_cache_expired:{vehicleCache_10}\r\n$55\r\nredisson__map_cache__last_access__set:{vehicleCache_10}\r\n$51\r\nredisson__execute_task_once_latch:{vehicleCache_10}\r\n$13\r\n1659687023615\r\n$3\r\n100\r\n$1\r\n5\r\n$1\r\n1\r\n\r\n2022-08-05 10:10:23.666 DEBUG 66618 --- [sson-netty-2-30] org.redisson.command.RedisExecutor       : acquired connection for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, stationCache_10, redisson__timeout__set:{stationCache_10}, redisson__idle__set:{stationCache_10}, redisson_map_cache_expired:{stationCache_10}, redisson__map_cache__last_access__set:{stationCache_10}, redisson__execute_task_once_latch:{stationCache_10}, 1659687023666, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node localhost/127.0.0.1:6379... RedisConnection@577814324 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x047d3016, L:/127.0.0.1:51218 - R:localhost/127.0.0.1:6379], currentCommand=null, usage=1]\r\n2022-08-05 10:10:23.667 TRACE 66618 --- [sson-netty-2-16] o.r.client.handler.CommandDecoder        : reply: -ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.\r\n, channel: [id: 0xc3725620, L:/127.0.0.1:51217 - R:localhost/127.0.0.1:6379], command: CommandData [promise=java.util.concurrent.CompletableFuture@64e57768[Not completed, 1 dependents], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, vehicleCache_10, redisson__timeout__set:{vehicleCache_10}, redisson__idle__set:{vehicleCache_10}, redisson_map_cache_expired:{vehicleCache_10}, redisson__map_cache__last_access__set:{vehicleCache_10}, redisson__execute_task_once_latch:{vehicleCache_10}, 1659687023615, 100, ...], codec=org.redisson.client.codec.LongCodec]\r\n2022-08-05 10:10:23.667 TRACE 66618 --- [sson-netty-2-18] o.r.client.handler.CommandEncoder        : channel: [id: 0x047d3016, L:/127.0.0.1:51218 - R:localhost/127.0.0.1:6379] message: *13\r\n$4\r\nEVAL\r\n$1824\r\nif redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[3]); local expiredKeys1 = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys1) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys1, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[3], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[2], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('hdel', KEYS[1], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); end; local expiredKeys2 = redis.call('zrangebyscore', KEYS[3], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys2) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys2, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[3], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[2], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('hdel', KEYS[1], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); end; return #expiredKeys1 + #expiredKeys2;\r\n$1\r\n6\r\n$15\r\nstationCache_10\r\n$40\r\nredisson__timeout__set:{stationCache_10}\r\n$37\r\nredisson__idle__set:{stationCache_10}\r\n$44\r\nredisson_map_cache_expired:{stationCache_10}\r\n$55\r\nredisson__map_cache__last_access__set:{stationCache_10}\r\n$51\r\nredisson__execute_task_once_latch:{stationCache_10}\r\n$13\r\n1659687023666\r\n$3\r\n100\r\n$1\r\n5\r\n$1\r\n1\r\n\r\n2022-08-05 10:10:23.667 DEBUG 66618 --- [sson-netty-2-16] org.redisson.command.RedisExecutor       : connection released for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, vehicleCache_10, redisson__timeout__set:{vehicleCache_10}, redisson__idle__set:{vehicleCache_10}, redisson_map_cache_expired:{vehicleCache_10}, redisson__map_cache__last_access__set:{vehicleCache_10}, redisson__execute_task_once_latch:{vehicleCache_10}, 1659687023615, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@670172570 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xc3725620, L:/127.0.0.1:51217 - R:localhost/127.0.0.1:6379], currentCommand=CommandData [promise=java.util.concurrent.CompletableFuture@64e57768[Completed exceptionally: org.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0xc3725620, L:/127.0.0.1:51217 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@64e57768[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, vehicleCache_10, redisson__timeout__set:{vehicleCache_10}, redisson__idle__set:{vehicleCache_10}, redisson_map_cache_expired:{vehicleCache_10}, redisson__map_cache__last_access__set:{vehicleCache_10}, redisson__execute_task_once_latch:{vehicleCache_10}, 1659687023615, 100, ...]], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, vehicleCache_10, redisson__timeout__set:{vehicleCache_10}, redisson__idle__set:{vehicleCache_10}, redisson_map_cache_expired:{vehicleCache_10}, redisson__map_cache__last_access__set:{vehicleCache_10}, redisson__execute_task_once_latch:{vehicleCache_10}, 1659687023615, 100, ...], codec=org.redisson.client.codec.LongCodec], usage=0]\r\n2022-08-05 10:10:23.668 ERROR 66618 --- [sson-netty-2-16] o.r.eviction.MapCacheEvictionTask        : Unable to evict elements for 'vehicleCache_10'\r\n\r\norg.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0xc3725620, L:/127.0.0.1:51217 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@64e57768[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, vehicleCache_10, redisson__timeout__set:{vehicleCache_10}, redisson__idle__set:{vehicleCache_10}, redisson_map_cache_expired:{vehicleCache_10}, redisson__map_cache__last_access__set:{vehicleCache_10}, redisson__execute_task_once_latch:{vehicleCache_10}, 1659687023615, 100, ...]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:370)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:832)\r\n\r\n2022-08-05 10:10:23.695 DEBUG 66618 --- [sson-netty-2-31] org.redisson.command.RedisExecutor       : acquired connection for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, geofencingZonesCache_10, redisson__timeout__set:{geofencingZonesCache_10}, redisson__idle__set:{geofencingZonesCache_10}, redisson_map_cache_expired:{geofencingZonesCache_10}, redisson__map_cache__last_access__set:{geofencingZonesCache_10}, redisson__execute_task_once_latch:{geofencingZonesCache_10}, 1659687023695, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node localhost/127.0.0.1:6379... RedisConnection@230769686 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x85834375, L:/127.0.0.1:51219 - R:localhost/127.0.0.1:6379], currentCommand=null, usage=1]\r\n2022-08-05 10:10:23.696 TRACE 66618 --- [sson-netty-2-20] o.r.client.handler.CommandEncoder        : channel: [id: 0x85834375, L:/127.0.0.1:51219 - R:localhost/127.0.0.1:6379] message: *13\r\n$4\r\nEVAL\r\n$1824\r\nif redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[3]); local expiredKeys1 = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys1) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys1, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[3], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('zrem', KEYS[2], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); redis.call('hdel', KEYS[1], unpack(expiredKeys1, i, math.min(i+4999, table.getn(expiredKeys1)))); end; local expiredKeys2 = redis.call('zrangebyscore', KEYS[3], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys2) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;for i=1, #expiredKeys2, 5000 do redis.call('zrem', KEYS[5], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[3], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('zrem', KEYS[2], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); redis.call('hdel', KEYS[1], unpack(expiredKeys2, i, math.min(i+4999, table.getn(expiredKeys2)))); end; return #expiredKeys1 + #expiredKeys2;\r\n$1\r\n6\r\n$23\r\ngeofencingZonesCache_10\r\n$48\r\nredisson__timeout__set:{geofencingZonesCache_10}\r\n$45\r\nredisson__idle__set:{geofencingZonesCache_10}\r\n$52\r\nredisson_map_cache_expired:{geofencingZonesCache_10}\r\n$63\r\nredisson__map_cache__last_access__set:{geofencingZonesCache_10}\r\n$59\r\nredisson__execute_task_once_latch:{geofencingZonesCache_10}\r\n$13\r\n1659687023695\r\n$3\r\n100\r\n$1\r\n5\r\n$1\r\n1\r\n\r\n2022-08-05 10:10:23.712 TRACE 66618 --- [sson-netty-2-18] o.r.client.handler.CommandDecoder        : reply: -ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.\r\n, channel: [id: 0x047d3016, L:/127.0.0.1:51218 - R:localhost/127.0.0.1:6379], command: CommandData [promise=java.util.concurrent.CompletableFuture@195f2eb[Not completed, 1 dependents], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, stationCache_10, redisson__timeout__set:{stationCache_10}, redisson__idle__set:{stationCache_10}, redisson_map_cache_expired:{stationCache_10}, redisson__map_cache__last_access__set:{stationCache_10}, redisson__execute_task_once_latch:{stationCache_10}, 1659687023666, 100, ...], codec=org.redisson.client.codec.LongCodec]\r\n2022-08-05 10:10:23.712 DEBUG 66618 --- [sson-netty-2-18] org.redisson.command.RedisExecutor       : connection released for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, stationCache_10, redisson__timeout__set:{stationCache_10}, redisson__idle__set:{stationCache_10}, redisson_map_cache_expired:{stationCache_10}, redisson__map_cache__last_access__set:{stationCache_10}, redisson__execute_task_once_latch:{stationCache_10}, 1659687023666, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@577814324 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x047d3016, L:/127.0.0.1:51218 - R:localhost/127.0.0.1:6379], currentCommand=CommandData [promise=java.util.concurrent.CompletableFuture@195f2eb[Completed exceptionally: org.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0x047d3016, L:/127.0.0.1:51218 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@195f2eb[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, stationCache_10, redisson__timeout__set:{stationCache_10}, redisson__idle__set:{stationCache_10}, redisson_map_cache_expired:{stationCache_10}, redisson__map_cache__last_access__set:{stationCache_10}, redisson__execute_task_once_latch:{stationCache_10}, 1659687023666, 100, ...]], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, stationCache_10, redisson__timeout__set:{stationCache_10}, redisson__idle__set:{stationCache_10}, redisson_map_cache_expired:{stationCache_10}, redisson__map_cache__last_access__set:{stationCache_10}, redisson__execute_task_once_latch:{stationCache_10}, 1659687023666, 100, ...], codec=org.redisson.client.codec.LongCodec], usage=0]\r\n2022-08-05 10:10:23.712 ERROR 66618 --- [sson-netty-2-18] o.r.eviction.MapCacheEvictionTask        : Unable to evict elements for 'stationCache_10'\r\n\r\norg.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0x047d3016, L:/127.0.0.1:51218 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@195f2eb[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, stationCache_10, redisson__timeout__set:{stationCache_10}, redisson__idle__set:{stationCache_10}, redisson_map_cache_expired:{stationCache_10}, redisson__map_cache__last_access__set:{stationCache_10}, redisson__execute_task_once_latch:{stationCache_10}, 1659687023666, 100, ...]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:370)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:832)\r\n\r\n2022-08-05 10:10:23.743 TRACE 66618 --- [sson-netty-2-20] o.r.client.handler.CommandDecoder        : reply: -ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.\r\n, channel: [id: 0x85834375, L:/127.0.0.1:51219 - R:localhost/127.0.0.1:6379], command: CommandData [promise=java.util.concurrent.CompletableFuture@1665b6f5[Not completed, 1 dependents], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, geofencingZonesCache_10, redisson__timeout__set:{geofencingZonesCache_10}, redisson__idle__set:{geofencingZonesCache_10}, redisson_map_cache_expired:{geofencingZonesCache_10}, redisson__map_cache__last_access__set:{geofencingZonesCache_10}, redisson__execute_task_once_latch:{geofencingZonesCache_10}, 1659687023695, 100, ...], codec=org.redisson.client.codec.LongCodec]\r\n2022-08-05 10:10:23.743 DEBUG 66618 --- [sson-netty-2-20] org.redisson.command.RedisExecutor       : connection released for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, geofencingZonesCache_10, redisson__timeout__set:{geofencingZonesCache_10}, redisson__idle__set:{geofencingZonesCache_10}, redisson_map_cache_expired:{geofencingZonesCache_10}, redisson__map_cache__last_access__set:{geofencingZonesCache_10}, redisson__execute_task_once_latch:{geofencingZonesCache_10}, 1659687023695, 100, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@230769686 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x85834375, L:/127.0.0.1:51219 - R:localhost/127.0.0.1:6379], currentCommand=CommandData [promise=java.util.concurrent.CompletableFuture@1665b6f5[Completed exceptionally: org.redisson.client.RedisException: ERR Error running script (call to f_134cd359e18d2acd4e083ed8eba74aca3024e815): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0x85834375, L:/127.0.0.1:51219 - R:localhost/127.0.0.1:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@1665b6f5[Not completed, 1 dependents], params: [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, geofencingZonesCache_10, redisson__timeout__set:{geofencingZonesCache_10}, redisson__idle__set:{geofencingZonesCache_10}, redisson_map_cache_expired:{geofencingZonesCache_10}, redisson__map_cache__last_access__set:{geofencingZonesCache_10}, redisson__execute_task_once_latch:{geofencingZonesCache_10}, 1659687023695, 100, ...]], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, geofencingZonesCache_10, redisson__timeout__set:{geofencingZonesCache_10}, redisson__idle__set:{geofencingZonesCache_10}, redisson_map_cache_expired:{geofencingZonesCache_10}, redisson__map_cache__last_access__set:{geofencingZonesCache_10}, redisson__execute_task_once_latch:{geofencingZonesCache_10}, 1659687023695, 100, ...], codec=org.redisson.client.codec.LongCodec], usage=0]\r\n2022-08-05 10:10:23.744 ERROR 66618 --- [sson-netty-2-20] o.r.eviction.MapCacheEvictionTask        : Unable to evict elements for 'geofencingZonesCache_10'\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2022-08-05T10:58:18Z",
        "body": "Is it a Redis cluster?"
      },
      {
        "user": "testower",
        "created_at": "2022-08-05T11:00:07Z",
        "body": "No this is running in Google Cloud Memorystore which does not support clustering."
      },
      {
        "user": "testower",
        "created_at": "2022-08-05T11:09:26Z",
        "body": "So it seems that a client which is connected to the read replica endpoint is trying to evict cache entries. Given that I'm using a single server redisson config, it could be that this is intentional (i.e. any redisson client should be able to issue eviction commands), and that I should be configuring redisson differently to avoid this, but I'm still curious as to why the error only surfaces with 3.17.4."
      },
      {
        "user": "testower",
        "created_at": "2022-08-05T12:29:02Z",
        "body": "Is the MasterSlaveServerConfiguration the appropriate one to use in this scenario?"
      },
      {
        "user": "testower",
        "created_at": "2022-08-09T11:25:20Z",
        "body": "I have now rolled out MasterSlaveServerConfiguration with the newest version of redisson and I am now no longer seeing this error, so closing this issue 👍 "
      }
    ]
  },
  {
    "number": 4463,
    "title": "org.redisson.client.RedisTimeoutException: Command execution timeout for command: (AUTH)",
    "created_at": "2022-08-04T09:10:47Z",
    "closed_at": "2022-08-05T06:05:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4463",
    "body": "偶发启动报错，错误信息\r\n```java\r\n2022-08-04 17:00:54.345  INFO 5732 --- [           main] com.test.config.RedissonConfig           : ===> 加载集群模式的redisson ...\r\n2022-08-04 17:00:54.534  INFO 5732 --- [           main] org.redisson.Version                     : Redisson 3.17.3\r\n2022-08-04 17:00:55.239  INFO 5732 --- [           main] o.r.cluster.ClusterConnectionManager     : Redis cluster nodes configuration got from **.*.**.**/**.*.**.**:6379:\r\nd148f0c1b019ecd8b15bf207d3ef188737111708 **.*.**.**:6381@16381 slave 2a3da9cbc3360a6be187477e12d38601c8f7f825 0 1659603638070 30 connected\r\n99497eadb64dee7e6328a0ed0cb948094f5aa1e9 **.*.**.**:6383@16383 slave f564ccc551dd3378658fef692f766b18d624a369 0 1659603640079 28 connected\r\n2a3da9cbc3360a6be187477e12d38601c8f7f825 **.*.**.**:6384@16384 master - 0 1659603639000 30 connected 5461-10922\r\nac94323e413fb99e7ee8a8dcb8fc075300d505e6 **.*.**.**:6380@16380 master - 0 1659603639075 25 connected 10923-16383\r\nb24b326be748f470e1871ba09135396362cf110e **.*.**.**:6379@16379 myself,slave ac94323e413fb99e7ee8a8dcb8fc075300d505e6 0 1659603640000 24 connected\r\nf564ccc551dd3378658fef692f766b18d624a369 **.*.**.**:6382@16382 master - 0 1659603641088 28 connected 0-5460\r\n\r\n2022-08-04 17:00:55.810  INFO 5732 --- [isson-netty-2-1] o.r.c.pool.MasterPubSubConnectionPool    : 1 connections initialized for **.*.**.**/**.*.**.**:6384\r\n2022-08-04 17:00:55.811  INFO 5732 --- [isson-netty-2-6] o.r.c.pool.MasterPubSubConnectionPool    : 1 connections initialized for **.*.**.**/**.*.**.**:6380\r\n2022-08-04 17:00:55.816  INFO 5732 --- [isson-netty-2-2] o.r.c.pool.MasterPubSubConnectionPool    : 1 connections initialized for **.*.**.**/**.*.**.**:6382\r\n2022-08-04 17:00:59.032  INFO 5732 --- [isson-netty-2-8] o.r.c.pool.MasterConnectionPool          : 32 connections initialized for **.*.**.**/**.*.**.**:6380\r\n2022-08-04 17:00:59.041  INFO 5732 --- [isson-netty-2-3] o.r.c.pool.MasterConnectionPool          : 32 connections initialized for **.*.**.**/**.*.**.**:6384\r\n2022-08-04 17:00:59.055  INFO 5732 --- [isson-netty-2-1] o.r.c.pool.MasterConnectionPool          : 32 connections initialized for **.*.**.**/**.*.**.**:6382\r\n2022-08-04 17:00:59.366  INFO 5732 --- [isson-netty-2-1] o.r.c.pool.PubSubConnectionPool          : 1 connections initialized for **.*.**.**/**.*.**.**:6379\r\n2022-08-04 17:00:59.366  INFO 5732 --- [isson-netty-2-6] o.r.c.pool.PubSubConnectionPool          : 1 connections initialized for **.*.**.**/**.*.**.**:6381\r\n2022-08-04 17:00:59.428  INFO 5732 --- [isson-netty-2-2] o.r.c.pool.PubSubConnectionPool          : 1 connections initialized for **.*.**.**/**.*.**.**:6383\r\n2022-08-04 17:01:02.575  INFO 5732 --- [isson-netty-2-2] o.r.cluster.ClusterConnectionManager     : slaves: [redis://**.*.**.**:6381] added for slot ranges: [[5461-10922]]\r\n2022-08-04 17:01:02.575  INFO 5732 --- [isson-netty-2-2] o.r.cluster.ClusterConnectionManager     : master: redis://**.*.**.**:6384 added for slot ranges: [[5461-10922]]\r\n2022-08-04 17:01:02.575  INFO 5732 --- [isson-netty-2-2] o.r.connection.pool.SlaveConnectionPool  : 32 connections initialized for **.*.**.**/**.*.**.**:6381\r\n2022-08-04 17:01:02.629  INFO 5732 --- [isson-netty-2-7] o.r.cluster.ClusterConnectionManager     : slaves: [redis://**.*.**.**:6383] added for slot ranges: [[0-5460]]\r\n2022-08-04 17:01:02.629  INFO 5732 --- [isson-netty-2-7] o.r.cluster.ClusterConnectionManager     : master: redis://**.*.**.**:6382 added for slot ranges: [[0-5460]]\r\n2022-08-04 17:01:02.629  INFO 5732 --- [isson-netty-2-7] o.r.connection.pool.SlaveConnectionPool  : 32 connections initialized for **.*.**.**/**.*.**.**:6383\r\n2022-08-04 17:01:04.236 ERROR 5732 --- [isson-netty-2-3] o.r.cluster.ClusterConnectionManager     : unable to add slave for: redis://**.*.**.**:6380 slot ranges: [[10923-16383]]\r\n\r\njava.util.concurrent.CompletionException: org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 24 of 32 were initialized. Redis server: **.*.**.**/**.*.**.**:6379\r\n\tat java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:292) ~[na:1.8.0_301]\r\n\tat java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:308) ~[na:1.8.0_301]\r\n\tat java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:661) ~[na:1.8.0_301]\r\n\tat java.util.concurrent.CompletableFuture$UniAccept.tryFire$$$capture(CompletableFuture.java:646) ~[na:1.8.0_301]\r\n\tat java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java) ~[na:1.8.0_301]\r\n\tat java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488) ~[na:1.8.0_301]\r\n\tat java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990) ~[na:1.8.0_301]\r\n\tat org.redisson.connection.pool.ConnectionPool.lambda$createConnection$1(ConnectionPool.java:151) ~[redisson-3.17.3.jar:3.17.3]\r\n\tat java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:774) ~[na:1.8.0_301]\r\n\tat java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:750) [na:1.8.0_301]\r\n\tat java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488) ~[na:1.8.0_301]\r\n\tat java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990) ~[na:1.8.0_301]\r\n\tat org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:307) ~[redisson-3.17.3.jar:3.17.3]\r\n\tat org.redisson.connection.pool.ConnectionPool.lambda$createConnection$6(ConnectionPool.java:273) ~[redisson-3.17.3.jar:3.17.3]\r\n\tat java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:774) ~[na:1.8.0_301]\r\n\tat java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:750) [na:1.8.0_301]\r\n\tat java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488) ~[na:1.8.0_301]\r\n\tat java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990) ~[na:1.8.0_301]\r\n\tat org.redisson.client.RedisClient$1$1.run(RedisClient.java:226) ~[redisson-3.17.3.jar:3.17.3]\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute$$$capture(AbstractEventExecutor.java:164) ~[netty-common-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java) ~[netty-common-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.45.Final.jar:4.1.45.Final]\r\n\tat java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_301]\r\nCaused by: org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 24 of 32 were initialized. Redis server: **.*.**.**/**.*.**.**:6379\r\n\tat org.redisson.connection.pool.ConnectionPool.lambda$createConnection$1(ConnectionPool.java:150) ~[redisson-3.17.3.jar:3.17.3]\r\n\t... 19 common frames omitted\r\nCaused by: java.util.concurrent.CompletionException: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (AUTH), params: (password masked), Redis client: [addr=redis://**.*.**.**:6379]\r\n\tat java.util.concurrent.CompletableFuture.encodeRelay(CompletableFuture.java:326) ~[na:1.8.0_301]\r\n\tat java.util.concurrent.CompletableFuture.completeRelay(CompletableFuture.java:338) ~[na:1.8.0_301]\r\n\tat java.util.concurrent.CompletableFuture.uniRelay(CompletableFuture.java:925) ~[na:1.8.0_301]\r\n\tat java.util.concurrent.CompletableFuture$UniRelay.tryFire(CompletableFuture.java:913) ~[na:1.8.0_301]\r\n\t... 11 common frames omitted\r\nCaused by: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (AUTH), params: (password masked), Redis client: [addr=redis://**.*.**.**:6379]\r\n\tat org.redisson.client.RedisConnection.lambda$async$0(RedisConnection.java:244) ~[redisson-3.17.3.jar:3.17.3]\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672) ~[netty-common-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747) ~[netty-common-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472) ~[netty-common-4.1.45.Final.jar:4.1.45.Final]\r\n\t... 2 common frames omitted\r\n```\r\n配置\r\n```java\r\n @Bean(destroyMethod = \"shutdown\")\r\n    @ConditionalOnProperty(name = \"redis.model\", havingValue = \"cluster\", matchIfMissing = false)\r\n    public RedissonClient redisson() {\r\n        log.info(\"===> 加载集群模式的redisson ...\");\r\n        String[] nodes = redisProperties.getCluster().getNodes().stream()\r\n                .map(node -> REDIS_PROTOCOL_PREFIX + node).toArray(String[]::new);\r\n\r\n        Config config = new Config();\r\n        ClusterServersConfig clusterServersConfig = config\r\n                .setCodec(JsonJacksonCodec.INSTANCE)\r\n                .setThreads(redissonProperties.getThreads())\r\n                .setNettyThreads(redissonProperties.getNettyThreads())\r\n                .useClusterServers();\r\n        clusterServersConfig\r\n                .setPassword(redisProperties.getPassword())//设置密码\r\n                .setPingConnectionInterval(redissonProperties.getPingConnectionInterval()) // ping连接间隔\r\n                .setScanInterval(redissonProperties.getScanInterval()) // 主节点变化扫描间隔时间\r\n                .setRetryInterval(redissonProperties.getRetryInterval()) // 命令重试发送时间间隔\r\n                .setTimeout(redissonProperties.getTimeout()) // 命令等待超时\r\n                .setSubscriptionConnectionPoolSize(redissonProperties.getSubscriptionConnectionPoolSize()) // 从节点发布和订阅连接池大小\r\n                .setSubscriptionConnectionMinimumIdleSize(redissonProperties.getSubscriptionConnectionMinimumIdleSize()) // 从节点发布和订阅连接的最小空闲连接数\r\n                .setSlaveConnectionPoolSize(redissonProperties.getSlaveConnectionPoolSize()) // 从节点连接池大小\r\n                .setSlaveConnectionMinimumIdleSize(redissonProperties.getSlaveConnectionMinimumIdleSize()) //从节点最小空闲连接数\r\n                .setMasterConnectionPoolSize(redissonProperties.getMasterConnectionPoolSize()) // 主节点连接池大小\r\n                .setMasterConnectionMinimumIdleSize(redissonProperties.getMasterConnectionMinimumIdleSize()); // 主节点最小空闲连接数\r\n//        if (!SpringUtil.getBean(RedisKeyConcatComponent.class).isProdOrUat()) {\r\n//            clusterServersConfig.setNameMapper(new CustomNameMapper());\r\n//        }\r\n        clusterServersConfig\r\n                .addNodeAddress(nodes)\r\n                .setConnectTimeout(redissonProperties.getConnectTimeout())\r\n                .setPassword(redisProperties.getPassword());\r\n        return Redisson.create(config);\r\n    }\r\n\r\n    /**\r\n     * 集群模式下优先加载RedissonConfig ,加载lettuceConfig集群下redis key过期监听会失败\r\n     */\r\n    @Bean\r\n    @Order(Ordered.LOWEST_PRECEDENCE - 3)\r\n    public RedissonConnectionFactory redissonConnectionFactory(RedissonClient redisson) {\r\n        return new RedissonConnectionFactory(redisson);\r\n    }\r\n\r\n    @Bean\r\n    public RedisMessageListenerContainer redisMessageListenerContainer(RedisConnectionFactory redisConnectionFactory) {\r\n        RedisMessageListenerContainer container = new RedisMessageListenerContainer();\r\n        container.setConnectionFactory(redisConnectionFactory);\r\n        return container;\r\n    }\r\n```\r\n\r\n```java\r\n@Data\r\n@ConfigurationProperties(prefix = \"redisson.cluster\")\r\npublic class RedissonProperties {\r\n\r\n    /**\r\n     * ping连接间隔\r\n     */\r\n    private Integer pingConnectionInterval = 30000;\r\n    /**\r\n     * 从节点最小空闲连接数\r\n     * 多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时读取反映速度。\r\n     */\r\n    private Integer slaveConnectionMinimumIdleSize = 24;\r\n\r\n    /**\r\n     * 从节点连接池大小\r\n     * 多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）连接的连接池最大容量。连接池的连接数量自动弹性伸缩。\r\n     */\r\n    private Integer slaveConnectionPoolSize = 64;\r\n\r\n    /**\r\n     * 主节点最小空闲连接数\r\n     * 多从节点的环境里，每个 主节点的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时写入反应速度。\r\n     */\r\n    private Integer masterConnectionMinimumIdleSize = 24;\r\n\r\n    /**\r\n     * 主节点连接池大小\r\n     * 主节点的连接池最大容量。连接池的连接数量自动弹性伸缩。\r\n     */\r\n    private Integer masterConnectionPoolSize = 64;\r\n\r\n    /**\r\n     * 从节点发布和订阅连接的最小空闲连接数\r\n     * 多从节点的环境里，每个 从服务节点里用于发布和订阅连接的最小保持连接数（长连接）。Redisson内部经常通过发布和订阅来实现许多功能。长期保持一定数量的发布订阅连接是必须的。\r\n     */\r\n    private Integer subscriptionConnectionMinimumIdleSize = 1;\r\n\r\n    /**\r\n     * 从节点发布和订阅连接池大小\r\n     * 多从节点的环境里，每个 从服务节点里用于发布和订阅连接的连接池最大容量。连接池的连接数量自动弹性伸缩。\r\n     */\r\n    private Integer subscriptionConnectionPoolSize = 50;\r\n\r\n    /**\r\n     * 主节点变化扫描间隔时间\r\n     * 对主节点变化节点状态扫描的时间间隔。单位是毫秒。\r\n     *\r\n     */\r\n    private Integer scanInterval = 5000;\r\n\r\n    /**\r\n     * Netty线程池数量\r\n     * 这个线程池数量是在一个Redisson实例内，被其创建的所有分布式数据类型和服务，以及底层客户端所一同共享的线程池里保存的线程数量。\r\n     */\r\n    private Integer nettyThreads = 32;\r\n\r\n    /**\r\n     * 命令重试发送时间间隔，单位：毫秒\r\n     * 在某个节点执行相同或不同命令时，连续 失败 failedAttempts（执行失败最大次数） 时，该节点将被从可用节点列表里清除，直到 reconnectionTimeout（重新连接时间间隔） 超时以后再次尝试。\r\n     */\r\n    private Integer retryInterval = 1500;\r\n    private int retryAttempts = 3;\r\n\r\n    /**\r\n     * 命令等待超时，单位：毫秒\r\n     * 等待节点回复命令的时间。该时间从命令发送成功时开始计时。\r\n     */\r\n    private Integer timeout = 3000;\r\n\r\n    /**\r\n     * 线程池数量\r\n     * 这个线程池数量被所有RTopic对象监听器，RRemoteService调用者和RExecutorService任务共同共享。\r\n     */\r\n    private Integer threads = 16;\r\n\r\n    private int failedSlaveReconnectionInterval = 3000;\r\n\r\n    private int failedSlaveCheckInterval = 180000;\r\n\r\n    private ReadMode readMode = ReadMode.SLAVE;\r\n    private SubscriptionMode subscriptionMode = SubscriptionMode.MASTER;\r\n    private long dnsMonitoringInterval = 5000;\r\n    private int connectTimeout = 10000;\r\n    private int idleConnectionTimeout = 10000;\r\n}\r\n```\r\n\r\n```yaml\r\nredis:\r\n  model: cluster\r\nredisson:\r\n  cluster:\r\n    pingConnectionInterval: 30000\r\n    slaveConnectionMinimumIdleSize: 32\r\n    slaveConnectionPoolSize: 64\r\n    masterConnectionMinimumIdleSize: 32\r\n    masterConnectionPoolSize: 64\r\n    subscriptionConnectionMinimumIdleSize: 1\r\n    subscriptionConnectionPoolSize: 8\r\n    scanInterval: 5000\r\n    nettyThreads: 8\r\n    retryInterval: 1500\r\n    timeout: 5000\r\n    connectionTimeout: 10000\r\n    threads: 4\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4463/comments",
    "author": "qq502361472",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-08-05T06:05:42Z",
        "body": "It's a connection issue. Try to reduce size of connection pool."
      },
      {
        "user": "qq502361472",
        "created_at": "2022-08-05T06:50:51Z",
        "body": "我减小了连接数，配置主从分别都是2，还是偶尔会出现AUTH命令超时的问题"
      },
      {
        "user": "CRIOCM",
        "created_at": "2022-08-10T10:07:04Z",
        "body": "@qq502361472 你是macos吗？把连接池改小就好了是吗？"
      },
      {
        "user": "qq502361472",
        "created_at": "2022-08-11T05:35:24Z",
        "body": "> @qq502361472 你是macos吗？把连接池改小就好了是吗？\r\n\r\n没好，我不是mac，我是windows和linux都有问题"
      },
      {
        "user": "qq502361472",
        "created_at": "2022-08-12T03:59:53Z",
        "body": "你有微信吗，我们加一下微信13120535479\r\n\r\n\r\n\r\n发自我的iPhone\r\n\r\n\r\n------------------ Original ------------------\r\nFrom: XJH233 ***@***.***&gt;\r\nDate: Wed,Aug 10,2022 6:07 PM\r\nTo: redisson/redisson ***@***.***&gt;\r\nCc: HuJian ***@***.***&gt;, Mention ***@***.***&gt;\r\nSubject: Re: [redisson/redisson] org.redisson.client.RedisTimeoutException: Command execution timeout for command: (AUTH) (Issue #4463)\r\n\r\n\r\n\r\n\r\n\r\n \r\n@qq502361472 你是macos吗？把连接池改小就好了是吗？\r\n \r\n—\r\nReply to this email directly, view it on GitHub, or unsubscribe.\r\nYou are receiving this because you were mentioned.Message ID: ***@***.***&gt;"
      },
      {
        "user": "brianzrk",
        "created_at": "2022-10-26T02:00:55Z",
        "body": "problem can be resolved by reduce the minimumIdle value\r\n`clusterServersConfig:\r\n  idleConnectionTimeout: 10000\r\n  connectTimeout: 10000\r\n  timeout: 10000\r\n  retryAttempts: 3\r\n  retryInterval: 1500\r\n  masterConnectionMinimumIdleSize: 5\r\n  masterConnectionPoolSize: 64\r\n  slaveConnectionMinimumIdleSize: 5\r\n  slaveConnectionPoolSize: 64`"
      }
    ]
  },
  {
    "number": 4462,
    "title": "Releasing a semaphore when JVM crashes. ",
    "created_at": "2022-08-01T20:35:39Z",
    "closed_at": "2024-06-06T07:13:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4462",
    "body": "Hi. \r\n\r\nI want to use Redisson Semaphore. Sometimes my processes get stopped or killed before semaphore gets released and this locks up the semaphore. I cannot restart my service and acquire such semaphore again. Locks have a watchdog (configurable via setLockWatchdogTimeoutthat ) that will release a lock if process crashes or stops. Is there a reason same or similar watchdog mechanism is not available for semaphores? Can it be added? It is not clear to me how to use semaphores without such automatic release in case of a crash. \r\n\r\nThank you",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4462/comments",
    "author": "borisdainson",
    "comments": [
      {
        "user": "November22",
        "created_at": "2022-08-02T08:36:55Z",
        "body": "I have the same problem"
      },
      {
        "user": "FanHuaRan",
        "created_at": "2022-08-23T12:26:19Z",
        "body": "\r\nI have the same problem ! "
      },
      {
        "user": "Piotr-Gorski-Ringier",
        "created_at": "2023-07-06T13:35:41Z",
        "body": "you can use getPermitExpirableSemaphore. This way your semaphore will be released some time  after a crash. \r\navailablePermits will return a wrong number but you will be able to acquire and release a new semaphore. "
      }
    ]
  },
  {
    "number": 4454,
    "title": "how to fetch value by  existing key",
    "created_at": "2022-07-29T07:53:34Z",
    "closed_at": "2022-07-29T08:35:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4454",
    "body": "like the function redisTemplate.opsForValue().get(key);\r\nim using redisson on my redis cluster. i can get keys by using RKeys keys = redissonClient.getKeys(); but how can i get the values according to the keys.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4454/comments",
    "author": "altholin",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-07-29T08:35:39Z",
        "body": "you need to use RBucket object for this propose. redissonClient.getBucket(key);"
      }
    ]
  },
  {
    "number": 4450,
    "title": "How to read all values of a large map as fast as possible?",
    "created_at": "2022-07-29T01:03:24Z",
    "closed_at": "2022-08-03T20:21:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4450",
    "body": "I am trying to read all the values from a map with ~400,000 entires of 900bytes encoded objects each, as fast as possible. Currently reading values from a map of 100,000 objects takes 3 seconds, while 200,000 takes 10. the scaling is worse than linear.\r\n\r\n```\r\nRBatch batch = this.redissonClient.createBatch(BatchOptions.defaults()\r\n                                                                   .executionMode(BatchOptions.ExecutionMode.IN_MEMORY_ATOMIC);\r\n\r\nRFuture<Collection<Object>> futureCollection = batch.getMap(\"KEY\").readAllValuesAsync();\r\n\r\nbatch.execute();\r\n\r\nCollection<Object> collection = null;\r\n        try {\r\n            collection = futureCollection.get();\r\n        } catch (InterruptedException | ExecutionException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n```\r\n\r\nthis is the config I'm using:\r\n\r\nconfig.useSingleServer()\r\n              .setAddress(REDIS_SERVER_ADDRESS)\r\n              .setConnectionPoolSize(128)\r\n              .setTimeout(20000);\r\n        config.setNettyThreads(128);\r\n        config.setCodec(new FstCodec());",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4450/comments",
    "author": "kombuch",
    "comments": [
      {
        "user": "lehuuthanh5",
        "created_at": "2022-08-02T10:24:41Z",
        "body": "Hi, I think you have the best way to read data from Redis.\r\nIf you want to speed up your application, I think you can try RedissonLocalCacheMap for availability of data."
      }
    ]
  },
  {
    "number": 4434,
    "title": "使用阿里云Redis集群的代理模式，同时使用Redsson做分布式锁时异常",
    "created_at": "2022-07-21T04:42:24Z",
    "closed_at": "2022-07-21T08:33:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4434",
    "body": "前提\r\n阿里云Redis集群的代理模式，同时使用Redsson做分布式锁\r\n\r\n1.使用Redsson 1.14.0版本，使用lock方法能正常使用\r\n\r\n2.升级到Redsson 1.14.1，使用lock方法出现以下异常\r\norg.redisson.client.RedisException: ERR unknown command 'WAIT'. channel: [id: 0x7f74e48b, L:/172.16.74.253:62435 - R:/47.104.121.48:6379] command: (WAIT), params: [1, 1000]\r\n\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:343)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:247)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:189)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:508)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\r\n问题\r\n是在1.14.1改了lock方法的实现方式吗？看发出来的记录又没有相关说明",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4434/comments",
    "author": "somta",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-07-21T08:33:12Z",
        "body": "Redisson uses WAIT command for slaves sync of lock state. Try to upgrade Redis to 3.0+"
      },
      {
        "user": "somta",
        "created_at": "2022-07-21T08:39:56Z",
        "body": "I am using aliyun Redis 5.0, but there is still a problem"
      },
      {
        "user": "mrniko",
        "created_at": "2022-07-21T11:03:34Z",
        "body": "Seems it doesn't support WAIT command"
      },
      {
        "user": "somta",
        "created_at": "2022-07-21T11:51:08Z",
        "body": "Redsson 1.14.0 version is supported, but Redsson 1.14.1 and later versions have exceptions"
      },
      {
        "user": "mrniko",
        "created_at": "2022-07-21T11:57:49Z",
        "body": "there is no such version"
      },
      {
        "user": "somta",
        "created_at": "2022-07-22T10:25:00Z",
        "body": "> Redsson 1.14.0 version is supported, but Redsson 1.14.1 and later versions have exceptions\r\n\r\nSorry, I provided the wrong version, Redsson 3.14.0 version is supported, but Redsson 3.14.1 and later versions have exceptions"
      }
    ]
  },
  {
    "number": 4423,
    "title": "Why doesn't Redisson use my serializers in jackson codec",
    "created_at": "2022-07-15T23:21:17Z",
    "closed_at": "2022-08-25T07:09:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4423",
    "body": "Hi, I'm trying to implement a serializer/deserializer for a custom object but Redisson does not use it. Here is my code:\r\n\r\nJUserSerializer:\r\n```java\r\npublic class JUserSerializer extends StdSerializer<JUser> {\r\n    public JUserSerializer() {\r\n        super(JUser.class);\r\n    }\r\n\r\n    @Override\r\n    public void serialize(JUser value, JsonGenerator gen, SerializerProvider provider) throws IOException {\r\n        System.out.println(\"serialize\");\r\n        gen.writeStartObject();\r\n        gen.writeNumberField(\"id\", value.getId());\r\n        gen.writeStringField(\"lang\", value.getLocale().getLanguage());\r\n        gen.writeEndObject();\r\n    }\r\n}\r\n```\r\nJUserDeserializer:\r\n```java\r\npublic class JUserDeserializer extends StdDeserializer<JUser> {\r\n    public JUserDeserializer() {\r\n        super(JUser.class);\r\n    }\r\n\r\n    @Override\r\n    public JUser deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JacksonException {\r\n        System.out.println(\"deserialize\");\r\n        JUser user = new JUser();\r\n        user.setId(p.getValueAsLong());\r\n        user.setLocale(new Locale(p.getValueAsString()));\r\n        return user;\r\n    }\r\n}\r\n```\r\n\r\nRedisStorageConfig:\r\n```java\r\n        SimpleModule module = new SimpleModule(\"JolssyModule\", new Version(1, 0, 0, \"alpha\", \"fr.customentity.jolssy\", \"jolssy\"));\r\n        module.addSerializer(JUser.class, new JUserSerializer());\r\n        module.addDeserializer(JUser.class, new JUserDeserializer());\r\n        ObjectMapper mapper = new ObjectMapper();\r\n        mapper.registerModule(module);\r\n        this.jsonJacksonCodec = new JsonJacksonCodec(mapper);\r\n```\r\n\r\nWhen trying to use the codec:\r\n```java\r\nRBucket<JUser> bucket = redisStorageConfig.getClient().getBucket(\"user:\" + id, this.redisStorageConfig.getJsonJacksonCodec());\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4423/comments",
    "author": "CustomEntity",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-08-25T07:09:39Z",
        "body": "Try to override init and initTypeInclusion methods in JsonJacksonCodec."
      }
    ]
  },
  {
    "number": 4422,
    "title": "Incompatible version",
    "created_at": "2022-07-15T09:59:15Z",
    "closed_at": "2022-08-05T06:41:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4422",
    "body": "**Our project is using redisson.yaml to  set the config**.we use **redisson-3.11.2.jar** and **redisson-spring-boot-starter-3.11.2.jar** **current**.\r\nWe are going to upgrade the redisson version to 3.15.6. However ,when we upgrade the version,the follwing questions are encountered.\r\n**First**: redisson-spring-boot-starter-3.15.6 version at the RedissonAutoConfiguration.class (the following is the source code), the Config.fromYaml will always  encounter errors ，so it will go to  Config.fromJSON. But we are using redisson.yaml to set the config,\r\nredisson-spring-boot-starter-3.15.6 version cannot compatible with our previous configuration\r\n        if (redissonProperties.getConfig() != null) {\r\n            try {\r\n                **config = Config.fromYAML(redissonProperties.getConfig());**\r\n            } catch (IOException e) {\r\n                try {\r\n                    config = **Config.fromJSON**(redissonProperties.getConfig());\r\n                } catch (IOException e1) {\r\n                    throw new IllegalArgumentException(\"Can't parse config\", e1);\r\n                }\r\n            }\r\n        } else if (redissonProperties.getFile() != null) {\r\n            try {\r\n                InputStream is = getConfigStream();\r\n                config = Config.fromYAML(is);\r\n            } catch (IOException e) {\r\n                // trying next format\r\n                try {\r\n                    InputStream is = getConfigStream();\r\n                    config = Config.fromJSON(is);\r\n                } catch (IOException e1) {\r\n                    throw new IllegalArgumentException(\"Can't parse config\", e1);\r\n                }\r\n            }\r\nSecond:  the following are our configuration and the configuration is userd on multiple production environments . in redisson-3.11.2.jar, the BaseConfig.class has the propertity of pingTimeout. But ,in redisson-3.15.6,the pingtimeout attribute has been deleted.\r\nsingleServerConfig:\r\n    address: \"redis://127.0.0.1:6379\"\r\n    **pingTimeout:3000**\r\n    password: null\r\n    clientName: null\r\n    idleConnectionTimeout: 10000\r\n    connectTimeout: 10000\r\n    timeout: 3000\r\n    retryAttempts: 3\r\n    retryInterval: 1500\r\n    subscriptionsPerConnection: 5\r\n    subscriptionConnectionMinimumIdleSize: 1\r\n    subscriptionConnectionPoolSize: 50\r\n    connectionMinimumIdleSize: 32\r\n    connectionPoolSize: 64\r\n    dnsMonitoringInterval: 5000\r\ncodec: !<org.redisson.client.codec.StringCodec> {}\r\n\r\n**All these make it difficult for us to upgrade.if we upgrade the version,multiple unknown production environments will be affected.But we have to upgrade the version to use the redisson versions that have fixed some bugs. So I want to know  what can solve our problem.**",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4422/comments",
    "author": "ljbonbon",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-08-05T06:41:11Z",
        "body": "`pingTimeout` setting was deprecated in 3.10.0 and then removed in 3.12.4. \r\n\r\nThe only solution is to patch org.redisson.config.ConfigSupport#createMapper method and add\r\n```java\r\nmapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\r\n```"
      }
    ]
  },
  {
    "number": 4411,
    "title": "Best Practices around Redis Cluster Configuration",
    "created_at": "2022-07-12T09:13:08Z",
    "closed_at": "2022-09-30T07:17:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4411",
    "body": "Hi @mrniko \r\n\r\nWe are using AWS Elasticache redis server in cluster mode with 3 shards and each shard having 1 primary and 1 replica (6 nodes in total).\r\nAs part of redisson client configuration, we have defined the nodesList containing the 3 master servers' endpoint.\r\n\r\nCan you please suggest for the best practices around this. Should we include all the nodes as part of configuration(i.e both primary and replica nodes). I am asking this because we faced an issue when the elasticache cluster went to failover and it could not come out of failover as the redisson client was making a lot of connections and was not allowing primary to step down.\r\n\r\nWe are suspecting that since elasticache cluster went to failover and primary was stepping down (or getting decomissioned), redisson client kept on creating TCP connections with primary only and that caused a further delay in completing the failover.\r\nPlease suggest if we should go ahead to define all the nodes as part of redisson client configuration",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4411/comments",
    "author": "jainyash88",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-07-12T11:47:46Z",
        "body": "Even a single cluster node is enough to specify in configuration. \r\nCan you share logs with `trace` logging level for `org.redisson` package to get more info about the issue?"
      },
      {
        "user": "jainyash88",
        "created_at": "2022-07-13T09:48:25Z",
        "body": "Thanks @mrniko for the response. I do not have the trace logs when the issue occured. The issue occured when AWS Elasticache cluster went in to failover and it remained in the failover state for a long time. Will collect the trace logs if we can reproduce the issue again. However if we specify just one or two nodes and if those nodes are down (while the cluster is still up), does that affect the client connectivity?"
      },
      {
        "user": "mrniko",
        "created_at": "2022-09-30T07:17:28Z",
        "body": "> However if we specify just one or two nodes and if those nodes are down (while the cluster is still up), does that affect the client connectivity?\r\n\r\nNo"
      }
    ]
  },
  {
    "number": 4410,
    "title": "3.11.2 Caused by: io.netty.channel.StacklessClosedChannelException: null",
    "created_at": "2022-07-12T03:08:58Z",
    "closed_at": "2022-08-05T07:23:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4410",
    "body": "**redisson version: 3.11.2**\r\n**redisson config:**\r\nsingleServerConfig:\r\naddress: \"redis://127.0.0.1:6379\"\r\npassword: null\r\nclientName: null\r\ndatabase: 0\r\nidleConnectionTimeout: 10000\r\npingTimeout: 1000\r\nconnectTimeout: 10000\r\ntimeout: 3000\r\nretryAttempts: 3\r\nretryInterval: 1500\r\nreconnectionTimeout: 3000\r\nfailedAttempts: 3\r\nsubscriptionsPerConnection: 5\r\nsubscriptionConnectionMinimumIdleSize: 1\r\nsubscriptionConnectionPoolSize: 50\r\nconnectionMinimumIdleSize: 32\r\nconnectionPoolSize: 3000\r\ndnsMonitoringInterval: 5000\r\nthreads: 80\r\nnettyThreads: 60\r\n\r\n**when we used redisson to addlock,the following errors were encountered**\r\n2022-07-11 08:28:32,952 i-C38365BB ERROR [90831.c2c445d.275.9688] [rc] io.iec.edp.caf.commons.exception.handler.ExceptionLogger [https-jsse-nio-5200-exec-5] Unable to send command! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=28, freeConnectionsCounter=value:2996:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@583039672 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xaa884b89, L:/127.0.0.1:58094 ! R:127.0.0.1/127.0.0.1:6379], currentCommand=null], command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, 10000-barc-manager-0f3ac37a-0449-40eb-87e4-3e8576929c7c, 20000, 1d447097-835a-47f3-b4d7-d0d4b79a46ad:275] after 3 retry attempts\r\norg.redisson.client.WriteRedisConnectionException: Unable to send command! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=28, freeConnectionsCounter=value:2996:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@583039672 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xaa884b89, L:/127.0.0.1:58094 ! R:127.0.0.1/127.0.0.1:6379], currentCommand=null], command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, 10000-barc-manager-0f3ac37a-0449-40eb-87e4-3e8576929c7c, 20000, 1d447097-835a-47f3-b4d7-d0d4b79a46ad:275] after 3 retry attempts\r\nat org.redisson.command.CommandAsyncService.checkWriteFuture(CommandAsyncService.java:884)\r\nat org.redisson.command.CommandAsyncService.access$000(CommandAsyncService.java:98)\r\nat org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:803)\r\nat org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:800)\r\nat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\nat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\nat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\nat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\nat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609)\r\nat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\r\nat io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1017)\r\nat io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:878)\r\nat io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367)\r\nat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717)\r\nat io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764)\r\nat io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071)\r\nat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\r\nat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469)\r\nat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\r\nat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\nat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\nat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\nat java.lang.Thread.run(Thread.java:748)\r\nCaused by: io.netty.channel.StacklessClosedChannelException: null\r\nat io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source)\r\n\r\n\r\n**The network is ok. When I use redis-cli to set a value, it is ok.**\r\n**But when I use redisson api,such as**\r\n**RLock redLock = getClient(this.redissonConfig).getLock(\"10000-barc-manager-0f3ac37a-0449-40eb-87e4-3e8576929c7c\");\r\n redLock.lock(100, TimeUnit.SECONDS);**\r\nit doest not work and **the following errors are encountered.**\r\n\r\n2022-07-11 08:28:32,952 i-C38365BB ERROR [90831.c2c445d.275.9688] [rc] io.iec.edp.caf.commons.exception.handler.ExceptionLogger [https-jsse-nio-5200-exec-5] Unable to send command! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=28, freeConnectionsCounter=value:2996:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@583039672 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xaa884b89, L:/127.0.0.1:58094 ! R:127.0.0.1/127.0.0.1:6379], currentCommand=null], command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, 10000-barc-manager-0f3ac37a-0449-40eb-87e4-3e8576929c7c, 20000, 1d447097-835a-47f3-b4d7-d0d4b79a46ad:275] after 3 retry attempts\r\norg.redisson.client.WriteRedisConnectionException: Unable to send command! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=28, freeConnectionsCounter=value:2996:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@583039672 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xaa884b89, L:/127.0.0.1:58094 ! R:127.0.0.1/127.0.0.1:6379], currentCommand=null], command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, 10000-barc-manager-0f3ac37a-0449-40eb-87e4-3e8576929c7c, 20000, 1d447097-835a-47f3-b4d7-d0d4b79a46ad:275] after 3 retry attempts\r\nat org.redisson.command.CommandAsyncService.checkWriteFuture(CommandAsyncService.java:884)\r\nat org.redisson.command.CommandAsyncService.access$000(CommandAsyncService.java:98)\r\nat org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:803)\r\nat org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:800)\r\nat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\nat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\nat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\nat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\nat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609)\r\nat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\r\nat io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1017)\r\nat io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:878)\r\nat io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367)\r\nat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717)\r\nat io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764)\r\nat io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071)\r\nat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\r\nat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469)\r\nat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\r\nat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\nat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\nat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\nat java.lang.Thread.run(Thread.java:748)\r\nCaused by: io.netty.channel.StacklessClosedChannelException: null\r\nat io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4410/comments",
    "author": "ljbonbon",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-07-13T05:44:06Z",
        "body": "Try to set connectionPoolSize = 64"
      },
      {
        "user": "ljbonbon",
        "created_at": "2022-07-15T02:42:09Z",
        "body": "> Try to set connectionPoolSize = 64\r\n\r\n**when I set connectionPoolSize = 64, the following  errors are sometimes encountered .**\r\n\r\norg.springframework.dao.InvalidDataAccessApiUsageException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:48:queue:0, freeConnectionsAmount=31, freeConnectionsCounter=value:2999:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@101990895 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xc39821d7, L:/127.0.0.1:56072 - R:127.0.0.1/127.0.0.1:6379], currentCommand=null], command: (HGETALL), params: [[99, 97, 102, 45, 115, 101, 115, 115, 105, 111, ...]] after 3 retry attempts; nested exception is org.redisson.client.RedisTimeoutException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:48:queue:0, freeConnectionsAmount=31, freeConnectionsCounter=value:2999:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@101990895 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xc39821d7, L:/127.0.0.1:56072 - R:127.0.0.1/127.0.0.1:6379], currentCommand=null], command: (HGETALL), params: [[99, 97, 102, 45, 115, 101, 115, 115, 105, 111, ...]] after 3 retry attempts\r\n\tat org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:48)\r\n\tat org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:35)\r\n\tat org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:44)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.transform(RedissonConnection.java:234)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.syncFuture(RedissonConnection.java:229)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.sync(RedissonConnection.java:459)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.read(RedissonConnection.java:840)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.hGetAll(RedissonConnection.java:1537)\r\n\tat org.springframework.data.redis.core.DefaultHashOperations.lambda$entries$13(DefaultHashOperations.java:245)\r\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:228)\r\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:188)\r\n\tat org.springframework.data.redis.core.AbstractOperations.execute(AbstractOperations.java:96)\r\n\tat org.springframework.data.redis.core.DefaultHashOperations.entries(DefaultHashOperations.java:245)\r\n\tat org.springframework.data.redis.core.DefaultBoundHashOperations.entries(DefaultBoundHashOperations.java:183)\r\n\tat org.springframework.session.data.redis.RedisIndexedSessionRepository.getSession(RedisIndexedSessionRepository.java:440)\r\n\tat org.springframework.session.data.redis.RedisIndexedSessionRepository.findById(RedisIndexedSessionRepository.java:412)\r\n\tat org.springframework.session.data.redis.RedisIndexedSessionRepository.findById(RedisIndexedSessionRepository.java:249)\r\n\tat org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.getRequestedSession(SessionRepositoryFilter.java:351)\r\n\tat org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.getRequestedSessionId(SessionRepositoryFilter.java:333)\r\n\tat org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.commitSession(SessionRepositoryFilter.java:227)\r\n\tat org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.access$100(SessionRepositoryFilter.java:192)\r\n\tat org.springframework.session.web.http.SessionRepositoryFilter.doFilterInternal(SessionRepositoryFilter.java:144)\r\n\tat org.springframework.session.web.http.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:82)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:109)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:197)\r\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)\r\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:357)\r\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:382)\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:893)\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1726)\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: org.redisson.client.RedisTimeoutException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:48:queue:0, freeConnectionsAmount=31, freeConnectionsCounter=value:2999:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@101990895 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xc39821d7, L:/127.0.0.1:56072 - R:127.0.0.1/127.0.0.1:6379], currentCommand=null], command: (HGETALL), params: [[99, 97, 102, 45, 115, 101, 115, 115, 105, 111, ...]] after 3 retry attempts\r\n\tat org.redisson.command.CommandAsyncService$6.run(CommandAsyncService.java:715)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:669)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:744)\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:469)\r\n\t... 1 common frames omitted\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2022-07-18T12:56:45Z",
        "body": "then try connectionPoolSize = 128, 256 ..."
      },
      {
        "user": "ljbonbon",
        "created_at": "2022-07-19T01:29:40Z",
        "body": "> then try connectionPoolSize = 128, 256 ...\r\n\r\nCan you tell me the relationship between the io.netty.channel.StacklessClosedChannelException: null and the connectionPoolSize.In my opinion, to solve these errors is to constantly adjust parameters.I don't quite understand the relationship between them."
      },
      {
        "user": "mrniko",
        "created_at": "2022-07-19T05:59:59Z",
        "body": "Your vendor might have a connections amount limitation"
      },
      {
        "user": "ljbonbon",
        "created_at": "2022-07-21T01:21:12Z",
        "body": "> Your vendor might have a connections amount limitation\r\n\r\n**I don't quite understand the meaning of your vendor might have a connections amount limitation.Can you explain why the following errors occur when freeconnectionsamount=31 and freeConnectionsCounter=value:2999.It seems that there is still an idle connection through freeconnectionsamount=31. Why do Redisson still prompt to try to increase'nettythreads'and/or connection pool size settings.**\r\n\r\nCaused by: org.redisson.client.RedisTimeoutException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:48:queue:0, **freeConnectionsAmount=31, freeConnectionsCounter=value:2999**:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@101990895 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xc39821d7, L:/127.0.0.1:56072 - R:127.0.0.1/127.0.0.1:6379], currentCommand=null], command: (HGETALL), params: [[99, 97, 102, 45, 115, 101, 115, 115, 105, 111, ...]] after 3 retry attempts\r\nat org.redisson.command.CommandAsyncService$6.run(CommandAsyncService.java:715)\r\nat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:669)\r\nat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:744)\r\nat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:469)\r\n... 1 common frames omitted"
      },
      {
        "user": "mrniko",
        "created_at": "2022-07-21T08:24:15Z",
        "body": "Sorry, unable to reproduce the issue. If it's occurs with HGETALL command only then try to increase retry interval. "
      },
      {
        "user": "ljbonbon",
        "created_at": "2022-07-22T08:59:41Z",
        "body": "> Sorry, unable to reproduce the issue. If it's occurs with HGETALL command only then try to increase retry interval.\r\n\r\nI understand that it is difficult to reproduce this problem.Can you help me  understand why **unable to send command ！Try to increase'nettythreads'and/or connection pool size settings** when **freeconnectionsamount=31 and freeconnectionscounter=value:2999!**  "
      },
      {
        "user": "mrniko",
        "created_at": "2022-07-22T09:06:10Z",
        "body": "unable to send command error may arise if data hasn't been sent due to broken connection or other network issues."
      }
    ]
  },
  {
    "number": 4408,
    "title": "SlaveConnectionPool no available",
    "created_at": "2022-07-11T10:52:16Z",
    "closed_at": "2022-07-11T11:05:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4408",
    "body": "we use redisson version 3.16.2\r\n\r\norg.springframework.data.redis.RedisConnectionFailureException: SlaveConnectionPool no available Redis entries. Master entry host: ip:port Disconnected hosts: [ip:port] Hosts disconnected due to errors during `failedSlaveCheckInterval`: [ip:port]; nested exception is org.redisson.client.RedisConnectionException: SlaveConnectionPool no available Redis entries. Master entry host: ip:port Disconnected hosts: [ip:port] Hosts disconnected due to errors during `failedSlaveCheckInterval`: [ip:port]\r\n        at org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:40)\r\n        at org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:35)\r\n        at org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:37)\r\n        at org.redisson.spring.data.connection.RedissonConnection.transform(RedissonConnection.java:230)\r\n        at org.redisson.spring.data.connection.RedissonConnection.syncFuture(RedissonConnection.java:225)\r\n        at org.redisson.spring.data.connection.RedissonConnection.sync(RedissonConnection.java:386)\r\n        at org.redisson.spring.data.connection.RedissonConnection.read(RedissonConnection.java:760)\r\n        at org.redisson.spring.data.connection.RedissonConnection.get(RedissonConnection.java:501)\r\n        at org.springframework.data.redis.connection.DefaultStringRedisConnection.get(DefaultStringRedisConnection.java:296)\r\n        at org.springframework.data.redis.core.DefaultValueOperations$1.inRedis(DefaultValueOperations.java:46)\r\n        at org.springframework.data.redis.core.AbstractOperations$ValueDeserializingRedisCallback.doInRedis(AbstractOperations.java:57)\r\n        at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:207)\r\n        at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:169)\r\n        at org.springframework.data.redis.core.AbstractOperations.execute(AbstractOperations.java:91)\r\n        at org.springframework.data.redis.core.DefaultValueOperations.get(DefaultValueOperations.java:43)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4408/comments",
    "author": "x-ultimate",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-07-11T11:05:45Z",
        "body": "Fixed in 3.17.0+"
      }
    ]
  },
  {
    "number": 4407,
    "title": "3.11.2-io.netty.channel.StacklessClosedChannelException: null",
    "created_at": "2022-07-11T09:45:08Z",
    "closed_at": "2022-07-11T11:06:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4407",
    "body": "**redisson version**:  3.11.2\r\n**redisson config**:\r\nsingleServerConfig:\r\n    address: \"redis://127.0.0.1:6379\"\r\n    password: null\r\n    clientName: null\r\n    database: 0 \r\n    idleConnectionTimeout: 10000\r\n    pingTimeout: 1000\r\n    connectTimeout: 10000\r\n    timeout: 3000\r\n    retryAttempts: 3\r\n    retryInterval: 1500\r\n    reconnectionTimeout: 3000\r\n    failedAttempts: 3\r\n    subscriptionsPerConnection: 5\r\n    subscriptionConnectionMinimumIdleSize: 1\r\n    subscriptionConnectionPoolSize: 50\r\n    connectionMinimumIdleSize: 32\r\n    connectionPoolSize: 3000\r\n    dnsMonitoringInterval: 5000\r\nthreads: 80\r\nnettyThreads: 60\r\n\r\n**when we used redisson to addlock,the  following errors were encountered**\r\n2022-07-11 08:28:32,952 i-C38365BB ERROR [90831.c2c445d.275.9688] [rc] io.iec.edp.caf.commons.exception.handler.ExceptionLogger [https-jsse-nio-5200-exec-5] Unable to send command! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=28, freeConnectionsCounter=value:2996:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@583039672 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xaa884b89, L:/127.0.0.1:58094 ! R:127.0.0.1/127.0.0.1:6379], currentCommand=null], command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, 10000-barc-manager-0f3ac37a-0449-40eb-87e4-3e8576929c7c, 20000, 1d447097-835a-47f3-b4d7-d0d4b79a46ad:275] after 3 retry attempts\r\norg.redisson.client.WriteRedisConnectionException: Unable to send command! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=28, freeConnectionsCounter=value:2996:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@583039672 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xaa884b89, L:/127.0.0.1:58094 ! R:127.0.0.1/127.0.0.1:6379], currentCommand=null], command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, 10000-barc-manager-0f3ac37a-0449-40eb-87e4-3e8576929c7c, 20000, 1d447097-835a-47f3-b4d7-d0d4b79a46ad:275] after 3 retry attempts\r\n\tat org.redisson.command.CommandAsyncService.checkWriteFuture(CommandAsyncService.java:884)\r\n\tat org.redisson.command.CommandAsyncService.access$000(CommandAsyncService.java:98)\r\n\tat org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:803)\r\n\tat org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:800)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n\tat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n\tat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609)\r\n\tat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1017)\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:878)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764)\r\n\tat io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: io.netty.channel.StacklessClosedChannelException: null\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4407/comments",
    "author": "ljbonbon",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-07-11T11:06:54Z",
        "body": "`Caused by: io.netty.channel.StacklessClosedChannelException.` You need to check a network."
      },
      {
        "user": "ljbonbon",
        "created_at": "2022-07-12T03:06:22Z",
        "body": "**The network is ok. When I use redis-cli to set a value, it is ok.**\r\nBut when I use redisson api,such as \r\n   **RLock redLock = getClient(this.redissonConfig).getLock(\"10000-barc-manager-0f3ac37a-0449-40eb-87e4-3e8576929c7c\");\r\n   redLock.lock(100, TimeUnit.SECONDS);**\r\nit doest not work and **the following errors are encountered.**\r\n\r\n2022-07-11 08:28:32,952 i-C38365BB ERROR [90831.c2c445d.275.9688] [rc] io.iec.edp.caf.commons.exception.handler.ExceptionLogger [https-jsse-nio-5200-exec-5] Unable to send command! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=28, freeConnectionsCounter=value:2996:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@583039672 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xaa884b89, L:/127.0.0.1:58094 ! R:127.0.0.1/127.0.0.1:6379], currentCommand=null], command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, 10000-barc-manager-0f3ac37a-0449-40eb-87e4-3e8576929c7c, 20000, 1d447097-835a-47f3-b4d7-d0d4b79a46ad:275] after 3 retry attempts\r\norg.redisson.client.WriteRedisConnectionException: Unable to send command! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=28, freeConnectionsCounter=value:2996:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@583039672 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xaa884b89, L:/127.0.0.1:58094 ! R:127.0.0.1/127.0.0.1:6379], currentCommand=null], command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, 10000-barc-manager-0f3ac37a-0449-40eb-87e4-3e8576929c7c, 20000, 1d447097-835a-47f3-b4d7-d0d4b79a46ad:275] after 3 retry attempts\r\nat org.redisson.command.CommandAsyncService.checkWriteFuture(CommandAsyncService.java:884)\r\nat org.redisson.command.CommandAsyncService.access$000(CommandAsyncService.java:98)\r\nat org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:803)\r\nat org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:800)\r\nat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\nat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\nat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\nat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\nat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609)\r\nat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\r\nat io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1017)\r\nat io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:878)\r\nat io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367)\r\nat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717)\r\nat io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764)\r\nat io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071)\r\nat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\r\nat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469)\r\nat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\r\nat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\nat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\nat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\nat java.lang.Thread.run(Thread.java:748)\r\nCaused by: io.netty.channel.StacklessClosedChannelException: null\r\nat io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source)"
      }
    ]
  },
  {
    "number": 4406,
    "title": "io.netty.channel.StacklessClosedChannelException: null",
    "created_at": "2022-07-11T09:24:24Z",
    "closed_at": "2022-07-11T09:32:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4406",
    "body": " **redisson version**:  3.11.2\r\n **redisson config:**\r\nsingleServerConfig:\r\n    address: \"redis://127.0.0.1:6379\"\r\n    password: null\r\n    # redis节点里显示的客户端名称\r\n    clientName: null\r\n    # 数据库编号\r\n    database: 0 #选择使用哪个数据库0~15\r\n    # 连接空闲超时，单位：毫秒,默认为10000\r\n    idleConnectionTimeout: 10000\r\n    pingTimeout: 1000\r\n    # 连接超时，单位：毫秒,默认为10000\r\n    connectTimeout: 10000\r\n    # 命令等待超时，单位：毫秒,默认为3000\r\n    timeout: 3000\r\n    # 命令失败重试次数,默认为3\r\n    retryAttempts: 3\r\n    # 命令重试发送时间间隔，单位：毫秒\r\n    retryInterval: 1500\r\n    # 重新连接时间间隔，单位：毫秒\r\n    reconnectionTimeout: 3000\r\n    # 执行失败最大次数\r\n    failedAttempts: 3\r\n    # 单个连接最大订阅数量\r\n    subscriptionsPerConnection: 5\r\n    # 发布和订阅连接的最小空闲连接数,默认为1\r\n    subscriptionConnectionMinimumIdleSize: 1\r\n    # 发布和订阅连接池大小，默认为50\r\n    subscriptionConnectionPoolSize: 50\r\n    # 最小空闲连接数，默认为32\r\n    connectionMinimumIdleSize: 32\r\n    # 连接池大小，默认为64\r\n    connectionPoolSize: 3000\r\n    # DNS监测时间间隔，单位：毫秒,默认值为5000\r\n    dnsMonitoringInterval: 5000\r\nthreads: 80\r\nnettyThreads: 60\r\n\r\n**when we use redisson to addlock ,The following errors were encountered.**\r\n2022-07-11 08:28:32,952 i-C38365BB ERROR [90831.c2c445d.275.9688] [rc] io.iec.edp.caf.commons.exception.handler.ExceptionLogger [https-jsse-nio-5200-exec-5] Unable to send command! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=28, freeConnectionsCounter=value:2996:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@583039672 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xaa884b89, L:/127.0.0.1:58094 ! R:127.0.0.1/127.0.0.1:6379], currentCommand=null], command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, 10000-barc-manager-0f3ac37a-0449-40eb-87e4-3e8576929c7c, 20000, 1d447097-835a-47f3-b4d7-d0d4b79a46ad:275] after 3 retry attempts\r\norg.redisson.client.WriteRedisConnectionException: Unable to send command! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=28, freeConnectionsCounter=value:2996:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@583039672 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xaa884b89, L:/127.0.0.1:58094 ! R:127.0.0.1/127.0.0.1:6379], currentCommand=null], command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, 10000-barc-manager-0f3ac37a-0449-40eb-87e4-3e8576929c7c, 20000, 1d447097-835a-47f3-b4d7-d0d4b79a46ad:275] after 3 retry attempts\r\n\tat org.redisson.command.CommandAsyncService.checkWriteFuture(CommandAsyncService.java:884)\r\n\tat org.redisson.command.CommandAsyncService.access$000(CommandAsyncService.java:98)\r\n\tat org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:803)\r\n\tat org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:800)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n\tat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n\tat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609)\r\n\tat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1017)\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:878)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764)\r\n\tat io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: io.netty.channel.StacklessClosedChannelException: null\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source)\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4406/comments",
    "author": "ljbonbon",
    "comments": [
      {
        "user": "ZhouYu2567",
        "created_at": "2022-11-17T13:45:55Z",
        "body": "增大redis连接池数量试试看。"
      }
    ]
  },
  {
    "number": 4404,
    "title": "Questions about AWS MemoryDB compatibility",
    "created_at": "2022-07-11T02:28:06Z",
    "closed_at": "2022-07-11T04:50:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4404",
    "body": "Hi team. I'm thinking about using AWS MemoryDB with Redisson. AWS says MemoryDB is compatible with Redis. But before adopting it, I would like to ask to Redisson team first.\r\n\r\n- Have you ever tested the use of AWS MemoryDB with Redisson before?\r\n- Is there some known issue on AWS MemoryDB with Redisson?\r\n- Even if redisson team haven't tested it before, is there anything team can expect/suggest to be careful about?\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4404/comments",
    "author": "bigsky-033",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-07-11T04:50:06Z",
        "body": "Redisson is compatible with MemoryDB. Let me know if you have any issues with it."
      }
    ]
  },
  {
    "number": 4394,
    "title": "Configuration of RedissonClient for AWS Environment ",
    "created_at": "2022-07-04T13:50:40Z",
    "closed_at": "2022-07-06T08:01:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4394",
    "body": "**Redisson implementation is not working when deployed to AWS Environment**\r\n\r\nI have built a POC With Spring boot application to implement Sliding expiration of a cache in Redis using redisson client. It is working fine in my Local Env. but now my challenge is when I tried to apply the configuration to our existing code and deployed it to AWS Env. it is not giving the cached values.\r\n**Is there anything I forgot to specify? config? annotations?**\r\nI have used below configurations for Redisson\r\n\r\n@Bean(name = \"sessionCacheManager\")\r\npublic CacheManager cacheManager(RedissonClient redissonClient) throws IOException \r\n  {\r\n    Map <String, CacheConfig> config = new HashMap <>();\r\n    CacheConfig configItem = new CacheConfig(0,  Long.parseLong(maxIdleTime));\r\n\r\n    config.put(\"sso_client\",configItem);\r\n    return new RedissonSpringCacheManager(redissonClient, config);\r\n}\r\n\r\n\r\n @Bean(destroyMethod = \"shutdown\")\r\npublic RedissonClient redissonClient() throws IOException {\r\n    Config config = new Config();        \r\n    config.setNettyThreads(Integer.parseInt(nettyTrade)).setThreads(64).useReplicatedServers()\r\n            .setScanInterval(2000)        \r\n            .addNodeAddress(address)\r\n            .setConnectTimeout(Integer.parseInt(connectTimeout))\r\n            .setTimeout(Integer.parseInt(timeout))\r\n            .setRetryAttempts(Integer.parseInt(retryAttempts))\r\n            .setRetryInterval(Integer.parseInt(retryInterval));\r\n    redisson = Redisson.create(config);\r\n    logger.debug(\"RedissonClient Bean has been created\");\r\n    return redisson;\r\n}\r\n\r\n**and this is how I get and update the cache**\r\n\r\n@Autowired\r\nprivate CacheManager sessionCacheManager;\r\n\r\n @Cacheable( key = \"#clientAccessKey\",  unless = \"#result == null\")\r\npublic String getSSOSessionKey(String clientAccessKey)\r\n{\r\n    logger.debug(\"Inside getSSOSessionKey()\" + clientAccessKey);\r\n\r\n    org.springframework.cache.support.SimpleValueWrapper value = (org.springframework.cache.support.SimpleValueWrapper) sessionCacheManager.getCache(\"sso_client\").get(clientAccessKey);\r\n\r\n    if(value!=null && (value.get() instanceof String))\r\n    {\r\n        logger.debug(\"session active\" + value.get());\r\n        return (String)value.get();\r\n    }\r\n    logger.debug(\"session is out for ClientAccessKey\" + clientAccessKey);\r\n\r\n    return null;\r\n}\r\n\r\n @CachePut(key = \"#clientAccessKey\", condition = \"#result != null\")\r\npublic String updateClientRequestMapping(String clientAccessKey, String sessionKey)\r\n{\r\n    logger.debug(\"Inside updateClientRequestMapping()\");\r\n    return sessionKey;\r\n}\r\n\r\n @CacheEvict(key = \"#clientAccessKey\", condition = \"#result != null\")\r\npublic String removeClientRequestMapping(String clientAccessKey)\r\n{\r\n    logger.debug(\"Evict removeClientRequestMapping: \" + clientAccessKey);\r\n    return clientAccessKey;\r\n}\r\n\r\n**This is the log I got from splunk**\r\n\r\n2022-07-02 22:38:27 DEBUG o.r.c.ReplicatedConnectionManager - Current master myr1xfltu6ld0ybp.cxsbjl.ng.0001.use1.cache.amazonaws.com/10.4.14.237:6379 unchanged 2022-07-02 22:38:27 DEBUG org.redisson.command.RedisExecutor - acquired connection for command (GET) and params [[115, 101, 115, 115, 105, 111, 110, 83, 105, 109, ...]] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node kyrld0ybp.cbjl.ng.0001.use1.cache.amazonaws.com/10.4.14.237:6379... RedisConnection@599724954 [redisClient=[addr=redis://kyrld0ybp.cbjl.ng.0001.use1.cache.amazonaws.com:6379], channel=[id: 0x0610f655, L:/10.4.11.206:35298 - R:kyrld0ybp.cbjl.ng.0001.use1.cache.amazonaws.com/10.4.14.237:6379], currentCommand=null, usage=1] 2022-07-02 22:38:27 DEBUG org.redisson.command.RedisExecutor - **connection released for command (GET) and params [[115, 101, 115, 115, 105, 111, 110, 83, 105, 109, ...]] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@599724954 [redisClient=[addr=redis://kyrld0ybp.cbjl.ng.0001.use1.cache.amazonaws.com:6379]**, channel=[id: 0x0610f655, L:/10.4.11.206:35298 - R:kyrld0ybp.cbjl.ng.0001.use1.cache.amazonaws.com/10.4.14.237:6379], currentCommand=CommandData [promise=java.util.concurrent.CompletableFuture@2121da78[Completed normally], command=(GET), params=[[115, 101, 115, 115, 105, 111, 110, 83, 105, 109, ...]], codec=org.redisson.client.codec.ByteArrayCodec], usage=0] 2022-07-02 22:38:27 DEBUG org.redisson.command.RedisExecutor - acquired connection for command (GET) and params [[115, 101, 115, 115, 105, 111, 110, 83, 105, 109, ...]] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node kyrld0ybp.cbjl.ng.0001.use1.cache.amazonaws.com/10.4.14.237:6379... RedisConnection@632704404 [redisClient=[addr=redis://kyrld0ybp.cbjl.ng.0001.use1.cache.amazonaws.com:6379], channel=[id: 0x67d414b2, L:/10.4.11.206:35300 - R:kyrld0ybp.cbjl.ng.0001.use1.cache.amazonaws.com/10.4.14.237:6379], currentCommand=null, usage=1] 2022-07-02 22:38:27 DEBUG org.redisson.command.RedisExecutor - connection released for command (GET) and params [[115, 101, 115, 115, 105, 111, 110, 83, 105, 109, ...]] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@632704404 [redisClient=[addr=redis://kyrld0ybp.cbjl.ng.0001.use1.cache.amazonaws.com:6379], channel=[id: 0x67d414b2, L:/10.4.11.206:35300 - R:kyrld0ybp.cbjl.ng.0001.use1.cache.amazonaws.com/10.4.14.237:6379], currentCommand=CommandData [promise=java.util.concurrent.CompletableFuture@6c2d2f7d[Completed normally], command=(GET), params=[[115, 101, 115, 115, 105, 111, 110, 83, 105, 109, ...]], codec=org.redisson.client.codec.ByteArrayCodec], usage=0]\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4394/comments",
    "author": "zelalemagmasse",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-07-06T08:00:58Z",
        "body": "Make sure that you're connected to the same Redis setup"
      }
    ]
  },
  {
    "number": 4390,
    "title": "Handle exception when Redis is down",
    "created_at": "2022-07-04T08:26:09Z",
    "closed_at": "2023-10-17T08:33:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4390",
    "body": "I'm using Redisson with the JCache implementation and it's working great.\r\n\r\nBut I need to manage the scenario if Redis is down, and if the connection fails I would like to get the data from another source.\r\nWhen turning off Redis and fetching data via JCache, exceptions are thrown several times:\r\n`org.redisson.client.RedisResponseTimeoutException`, `org.redisson.client.RedisTimeoutException`, and `org.redisson.client.WriteRedisConnectionException`.\r\n\r\nI've tried using try/catch in the `get` method call of `javax.cache.Cache`, but I still can't handle the exception and the application crashes.\r\n\r\nI would like to know what is the best practice to handle Redis unavailability exceptions at runtime with Redisson using JCache?\r\n\r\nHere are the exceptions thrown with Redis down:\r\n\r\n```\r\nCaused by: org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured after 3 retry attempts, is non-idempotent command: false. Increase nettyThreads and/or timeout settings. Try to define pingConnectionInterval setting. Command: (EVAL), params: [if redis.call('hexists', KEYS[1], ARGV[2]) == 0 then return 0;end;local expireDateScore = redis.call..., 2, CACHE, jcache_timeout_set:{CACHE}, 1656922068654, PooledUnsafeDirectByteBuf(ridx: 0, widx: 40, cap: 256)], channel: [id: 0x5afe813f, L:/127.0.0.1:52382 - R:localhost/127.0.0.1:6379]\r\n\tat org.redisson.command.RedisExecutor.lambda$scheduleResponseTimeout$5(RedisExecutor.java:342)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715)\r\n\tat io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790)\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\t... 1 more\r\n```\r\n\r\n```\r\nERROR [org.redisson.client.handler.PingConnectionHandler] (redisson-timer-4-1) Unable to send PING command over channel: [id: 0x66577cba, L:/127.0.0.1:50646 - R:localhost/127.0.0.1:6379]: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://localhost:6379]\r\n\tat org.redisson.client.RedisConnection.lambda$async$0(RedisConnection.java:244)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715)\r\n\tat io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790)\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n```\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4390/comments",
    "author": "diltheyaislan",
    "comments": [
      {
        "user": "adamsau",
        "created_at": "2023-06-19T15:14:45Z",
        "body": "any answers?"
      },
      {
        "user": "mrniko",
        "created_at": "2023-10-17T08:33:04Z",
        "body": "You need to catch CacheException.\r\n\r\n```java\r\n        try {\r\n            cache.get(myKey);\r\n        } catch (CacheException e) {\r\n            ...\r\n        }\r\n```"
      }
    ]
  },
  {
    "number": 4389,
    "title": "ERR command eval not support for your account",
    "created_at": "2022-06-30T09:57:24Z",
    "closed_at": "2022-06-30T10:21:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4389",
    "body": "<!--\r\nHow to solve this exception\r\n-->\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4389/comments",
    "author": "xautzh",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-06-30T10:21:15Z",
        "body": "It seems is not supported by your Redis vendor"
      }
    ]
  },
  {
    "number": 4382,
    "title": "Expiration time does not take effect",
    "created_at": "2022-06-28T07:07:06Z",
    "closed_at": "2022-08-25T07:12:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4382",
    "body": "When the transition time is set for atomlong, the inexplicable time becomes -1. Looking at the source code incr will not modify the time. The local multi-threaded test does not find it. After the project is sent to the development environment and runs for a period of time, the time will be set to -1. Submitting with Rbatch didn't work either\r\neg:\r\n        RAtomicLong atomicLong = redissonClient.getAtomicLong(commonKey);\r\n        if (atomicLong.isExists()) {\r\n            atomicLong.incrementAndGet();\r\n        } else {\r\n          // Multiple threads may enter this step at the same time\r\n            RBatch batch = redissonClient.createBatch();\r\n            RAtomicLongAsync longAsync = batch.getAtomicLong(commonKey);\r\n            longAsync.incrementAndGetAsync();\r\n            longAsync.expireAsync(Duration.ofMinutes(1));\r\n            batch.execute();\r\n        }\r\nhow to solve this problem",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4382/comments",
    "author": "muchengyang",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-06-28T12:21:23Z",
        "body": "TTL isn't cleared after incrementation"
      }
    ]
  },
  {
    "number": 4376,
    "title": "Redisson brings whole RMap in in-memory while retrieving data",
    "created_at": "2022-06-22T03:00:19Z",
    "closed_at": "2022-06-22T06:40:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4376",
    "body": "Hi Team,\r\nI was integrating my application to use Redis Server and used Redisson as a client to interact with Redis.\r\nThe data size that I have in Redis for a particular map is around 80K entries where each entry is around 20kb. \r\n\r\nI tried fetching the data by creating an RMap and fetching the key out of the Redis Cache and what I noticed is, redisson brings whole 80k entries in in-memory and then fetches out the key required.\r\n\r\nI don't want Redisson to get all the entries first and get only the key from the Redis server. Is there a way I can achieve this? \r\n\r\nCan I only have the instance of my RMap in my application and fetch the entry directly from Redis Server instead of performing this find operations in my applications in-memory?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4376/comments",
    "author": "Pragya001",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-06-22T04:47:47Z",
        "body": "> I tried fetching the data by creating an RMap and fetching the key out of the Redis Cache and what I noticed is, redisson brings whole 80k entries in in-memory and then fetches out the key required.\r\n\r\nPlease share code to reproduce it.\r\n\r\n> Can I only have the instance of my RMap in my application and fetch the entry directly from Redis Server instead of performing this find operations in my applications in-memory?\r\n\r\nRedisson doesn't fetch whole memory until you invoke method like readAllMap()"
      },
      {
        "user": "Pragya001",
        "created_at": "2022-06-22T05:16:17Z",
        "body": "Following is the way I am reading the data from cache:\r\n\r\n`\r\npublic class MyCache {\r\n\r\n    private static final String CACHE_NAME = \"myCache\";\r\n\r\n    private final RMap<String, ProductStandards> tqcProductStandardsMap;\r\n\r\n    public MyCache(@Autowired RedissonClient redissonClient) {\r\n\r\n        MapOptions<String, ProductStandards> commentSubscriptionOptions = MapOptions.<String, ProductStandards>defaults()\r\n                .writeMode(WRITE_THROUGH);\r\n\r\n        tqcProductStandardsMap = redissonClient.getMap(CACHE_NAME, commentSubscriptionOptions);\r\n    }\r\n\r\n    public Map<String, ProductStandards> getCache() {\r\n        return tqcProductStandardsMap.readAllMap();\r\n    }\r\n\r\n    public void putCache(String key, ProductStandards productStandards) {\r\n        tqcProductStandardsMap.put(key, productStandards);\r\n        log.info(\"Entry updated for key {}\", key);\r\n    }\r\n\r\n    @Synchronized\r\n    public void clearCache() {\r\n        log.info(\"Clearing cache\");\r\n        tqcProductStandardsMap.clear();\r\n        log.info(\"Cache cleared\");\r\n    }\r\n\r\n    public ProductStandards getCacheByKey(String tqcProductStandardsKey) {\r\n        return tqcProductStandardsMap.get(tqcProductStandardsKey);\r\n    }\r\n\r\n}\r\n`\r\n\r\n\r\nFollowing are the configurations are done to setup Redisson:\r\n\r\n`\r\n@Configuration\r\npublic class RedisConfigurations {\r\n\r\n    @Autowired\r\n    private Configurations configurations;\r\n\r\n    private static final String LOCAL = \"local\";\r\n    private static final String CLUSTER = \"cluster\";\r\n\r\n    @Bean\r\n    public RedissonConnectionFactory redissonConnectionFactory(RedissonClient redissonClient) {\r\n        return new RedissonConnectionFactory(redissonClient);\r\n    }\r\n\r\n    @Bean(destroyMethod = \"shutdown\")\r\n    public RedissonClient redissonClient(Config config) {\r\n        return Redisson.create(config);\r\n    }\r\n\r\n    @Bean\r\n    public CacheManager cacheManager(RedissonClient redissonClient) {\r\n\r\n        Map<String, CacheConfig> cacheConfig = new HashMap<>();\r\n\r\n        cacheConfig.put(MY_CACHE.getName(), new org.redisson.spring.cache.CacheConfig(0L, 0L));\r\n\r\n        return new RedissonSpringCacheManager(redissonClient, cacheConfig);\r\n    }\r\n\r\n    @Bean\r\n    public Config redissonConfig() {\r\n        var config = new Config();\r\n\r\n        if (LOCAL.equals(configurations.getRedis().getConnectionMode())) {\r\n            var singleServerConfig = config.useSingleServer();\r\n            singleServerConfig.setAddress(configurations.getRedis().getHost())\r\n                    .setTimeout(configurations.getRedis().getTimeout())\r\n                    .setConnectTimeout(configurations.getRedis().getConnectTimeout())\r\n                    .setPingConnectionInterval(configurations.getRedis().getPingConnectionInterval())\r\n                    .setKeepAlive(configurations.getRedis().isKeepAlive());\r\n            Optional.ofNullable(configurations.getRedis().getPassword()).ifPresent(singleServerConfig::setPassword);\r\n        } else if (CLUSTER.equals(configurations.getRedis().getConnectionMode())) {\r\n            config.useClusterServers()\r\n                    .addNodeAddress(configurations.getRedis().getHost())\r\n                    .setPassword(configurations.getRedis().getPassword())\r\n                    .setTimeout(configurations.getRedis().getTimeout())\r\n                    .setConnectTimeout(configurations.getRedis().getConnectTimeout())\r\n                    .setPingConnectionInterval(configurations.getRedis().getPingConnectionInterval())\r\n                    .setKeepAlive(configurations.getRedis().isKeepAlive());\r\n        }\r\n        config.setUseThreadClassLoader(false);\r\n        return config;\r\n    }\r\n}\r\n`"
      },
      {
        "user": "Pragya001",
        "created_at": "2022-06-22T06:01:25Z",
        "body": "I see that redissonClient.getMap() doesn't hold references but the whole map of data inside the application. Is there any configuration changes I should do to not hold complete data?"
      },
      {
        "user": "mrniko",
        "created_at": "2022-06-22T06:40:42Z",
        "body": "```java\r\npublic Map<String, ProductStandards> getCache() {\r\n    return tqcProductStandardsMap.readAllMap();\r\n}\r\n```\r\n\r\nHow I expected. You use  readAllMap() method. Method should return tqcProductStandardsMap instead."
      }
    ]
  },
  {
    "number": 4367,
    "title": "Netty threads in waiting state during fastPut of RLocalCachedMap",
    "created_at": "2022-06-14T21:22:35Z",
    "closed_at": "2024-12-25T07:19:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4367",
    "body": "We use Redisson 3.17.0 and redis version 6.0.8. We have three threads in the same host which do fastPut() on a RLocalCachedMap. The throughput is around 500 for each thread. Some of the threads go into WAITING state during fastPut() as seen from thread dump below.\r\n\r\n```\r\nstackTrace:\r\njava.lang.Thread.State: WAITING (parking)\r\nat sun.misc.Unsafe.park(Native Method)\r\n- parking to wait for <0x00000006515fa310> (a java.util.concurrent.CompletableFuture$Signaller)\r\nat java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\r\nat java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1707)\r\nat java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3323)\r\nat java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1742)\r\nat java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1908)\r\nat org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:114)\r\nat org.redisson.RedissonObject.get(RedissonObject.java:82)\r\nat org.redisson.RedissonMap.fastPut(RedissonMap.java:1285)\r\nat com.oracle.pic.controltower.cache.DeviceServiceCache.putDeviceDo(DeviceServiceCache.java:248)\r\n```\r\n\r\nredisson config is as below:\r\n scanInterval: 1000\r\n  masterConnectionPoolSize: 128\r\n  masterConnectionMinimumIdleSize: 128\r\n  sslEnableEndpointIdentification: false\r\n  idleConnectionTimeout: 30000\r\n  connectTimeout: 10000\r\n  timeout: 3000\r\n  retryAttempts: 1\r\n  retryInterval: 300\r\n  readMode: \"MASTER\"\r\n  pingConnectionInterval: 0\r\n  keepAlive: true\r\n\r\n  tcpNoDelay: true\r\n  dnsMonitoringInterval: 5000\r\n  threads: 16\r\n  nettyThreads: 128\r\n\r\nAre the threads in waiting state for response from redis server? We do not see any slowlogs or RedisTimeout exceptions for this too. Could you please help?\r\n\r\nWill attach the trace logs for redisson package",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4367/comments",
    "author": "spathros",
    "comments": [
      {
        "user": "spathros",
        "created_at": "2022-06-14T21:30:23Z",
        "body": "We don't have the trace logs for when one of the threads goes into waiting state"
      },
      {
        "user": "mrniko",
        "created_at": "2022-06-15T04:21:20Z",
        "body": "How do you create RLocalCachedMap object?"
      },
      {
        "user": "spathros",
        "created_at": "2022-06-15T04:29:58Z",
        "body": "We inject this object as a singleton\r\nredissonClient.getLocalCachedMap(Cache.deviceUuidToDeviceCache.name(), options)\r\nand options is\r\nLocalCachedMapOptions<String, DeviceDo> options = LocalCachedMapOptions.defaults().loader(this.mapLoader).cacheSize(500000).evictionPolicy(EvictionPolicy.LRU);\r\n        "
      },
      {
        "user": "mrniko",
        "created_at": "2022-06-15T05:12:28Z",
        "body": "Unable to reproduce. Below is my test.\r\n\r\n```java\r\n    public void test1() throws InterruptedException {\r\n        ExecutorService e = Executors.newFixedThreadPool(3);\r\n\r\n        LocalCachedMapOptions<String, String> options = LocalCachedMapOptions.<String, String>defaults()\r\n                .loader(new MapLoader<String, String>() {\r\n                    @Override\r\n                    public String load(String key) {\r\n                        return \"value \" + key;\r\n                    }\r\n\r\n                    @Override\r\n                    public Iterable<String> loadAllKeys() {\r\n                        return Collections.emptyList();\r\n                    }\r\n                }).cacheSize(500000).evictionPolicy(EvictionPolicy.LRU);\r\n\r\n        RLocalCachedMap<String, String> cachedMap = redisson.getLocalCachedMap(\"myMap11\", options);\r\n\r\n        for (int i = 0; i < 500*3*100; i++) {\r\n            int j = i;\r\n            e.submit(() -> {\r\n                cachedMap.fastPut(\"\" + j, \"\" + j);\r\n            });\r\n        }\r\n\r\n        e.shutdown();\r\n        assertThat(e.awaitTermination(100, TimeUnit.SECONDS)).isTrue();\r\n    }\r\n```"
      }
    ]
  },
  {
    "number": 4365,
    "title": "Retry Attempt with Schedule",
    "created_at": "2022-06-14T09:33:53Z",
    "closed_at": "2022-06-30T09:54:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4365",
    "body": "Hi,\r\n\r\nI'm using the Redisson to schedule tasks using the schedule method. What i would like to know is the expected behavior when an exception is thrown during the task execution.\r\n\r\nI expected that after the exception was thrown, the task would be rescheduled again taking into account the values in retryInterval and retryAttempts.\r\n\r\nThe example is quite simple. A task is schedule to run every 10 minutes. The task only throws an exception.\r\n\r\n`RScheduledFuture<?> future = RExecutor.schedule(new TestTask(), CronSchedule.of(\"0 */10 * * * *\"));`\r\n\r\n```\r\npublic class TestTask implements Runnable, Serializable {\r\n\r\n    @RInject\r\n    private RedissonClient redissonClient;\r\n\r\n    public TestTask() {\r\n    }\r\n\r\n    @SneakyThrows\r\n    @Override\r\n    public void run() {\r\n        throw new ApiFailureException(\"test\");\r\n    }\r\n\r\n}\r\n```\r\nIf the retryInterval is 1min and the retryAttempts 3, I was expecting that, after the task starts, an exception was thrown and then the task was rescheduled for a minute later (3 times).\r\n\r\nIs this the expected behavior?\r\n\r\nThanks\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4365/comments",
    "author": "ruiFreixoProgrow",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-06-30T09:54:49Z",
        "body": "No, tasks which thrown exception should be rescheduled manually."
      }
    ]
  },
  {
    "number": 4358,
    "title": "Redis server response timeout while trying to readAllKeySet from RMapCache",
    "created_at": "2022-06-12T01:34:48Z",
    "closed_at": "2022-06-30T09:48:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4358",
    "body": "We use redisson 3.17.0 and redis version 6. We have redis cluster set up. We have a RMapCache that has about 600k entries in it. We have a use case to read all keys into memory from this cache. However, the readAllLKeySet() fails with\r\n\r\norg.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured after 1 retry attempts. Increase nettyThreads and/or timeout settings. Try to define pingConnectionInterval setting. Command: (EVAL), params: [local s = redis.call('hgetall', KEYS[1]); local maxSize = tonumber(redis.call('hget', KEYS[5], 'max-..., 5, sotuDeviceCache, redisson__timeout__set:{sotuDeviceCache}, redisson__idle__set:{sotuDeviceCache}, redisson__map_cache__last_access__set:{sotuDeviceCache}, {sotuDeviceCache}:redisson_options, 1654927476566], channel: [id: 0x392893e0, L:/10.5.120.153:42932 - R:10.5.130.41/10.5.130.41:6379]\r\n\r\nOur redis cluster config is as below\r\n\r\nscanInterval: 1000\r\n  masterConnectionPoolSize: 128\r\n  masterConnectionMinimumIdleSize: 128\r\n  sslEnableEndpointIdentification: false\r\n  idleConnectionTimeout: 30000\r\n  connectTimeout: 10000\r\n  timeout: 3000\r\n  retryAttempts: 1\r\n  retryInterval: 300\r\n  readMode: \"MASTER\"\r\n  pingConnectionInterval: 60000\r\n  keepAlive: true\r\n\r\n\r\nWhat is the recommended approach to read all keys from a cache which has many entries, without hitting a timeout?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4358/comments",
    "author": "spathros",
    "comments": [
      {
        "user": "spathros",
        "created_at": "2022-06-13T04:18:44Z",
        "body": "Tried increasing timeout to 60000 , now the error we see is\r\n\r\norg.redisson.client.RedisException: ERR Error running script (call to f_90fcfdb05f5b74bd69bd486619d1a8beeb29bf1b): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.. channel: [id: 0xbf7856fa, L:/10.5.120.4:43012 - R:10.5.120.168/10.5.120.168:6379] command: (EVAL), promise: java.util.concurrent.CompletableFuture@3b140f41[Not completed, 1 dependents], params: [local s = redis.call('hgetall', KEYS[1]); local maxSize = tonumber(redis.call('hget', KEYS[5], 'max-..., 5, sotuDeviceCache, redisson__timeout__set:{sotuDeviceCache}, redisson__idle__set:{sotuDeviceCache}, redisson__map_cache__last_access__set:{sotuDeviceCache}, {sotuDeviceCache}:redisson_options, 1655093416087]"
      },
      {
        "user": "mrniko",
        "created_at": "2022-06-13T05:47:30Z",
        "body": "can you share logs with `trace` logging level for `org.redisson` package?"
      }
    ]
  },
  {
    "number": 4355,
    "title": "Getting RedisResponseTimeoutException on application restart",
    "created_at": "2022-06-10T07:30:51Z",
    "closed_at": "2022-06-30T09:47:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4355",
    "body": "Hi all,\r\n\r\nI'm currently using a very simple redisson config:\r\n`\r\nsingleServerConfig:\r\n  address: \"redis://localhost:6379\"\r\n`\r\n\r\nMy application put an object to redisson map. I'm not sure if the object size is 'too big', but this is what I can see when i run the 'DEBUG OBJECT' command in redis-cli:\r\n\r\n`\r\n1) \"myRegistry\"\r\n127.0.0.1:6379> DEBUG OBJECT myRegistry\r\nValue at:0xffffae3d9f80 refcount:1 encoding:hashtable serializedlength:9311 lru:10678472 lru_seconds_idle:36\r\n` \r\n\r\nWhen I restart the application, it is stuck for a while, before crashing with this exception:\r\n\r\n`\r\nCaused by: org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (8000 ms) occured after 3 retry attempts, is non-idempotent command: false. Increase nettyThreads and/or timeout settings. Try to define pingConnectionInterval setting. Command: (HSCAN), params: [myRegistry, 0, COUNT, 10], channel: [id: 0x193a3b4d, L:/127.0.0.1:52606 - R:localhost/127.0.0.1:6379]\r\n\tat org.redisson.command.RedisExecutor.lambda$scheduleResponseTimeout$5(RedisExecutor.java:342)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715)\r\n\tat io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790)\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\t... 1 common frames omitted\r\n`\r\n\r\nI've tried increasing nettyThreads to 128, and increasing timeout to 8000, without any success.  If I delete the key 'myRegistry', then I can start the application again.  Is there something obvious that I've missed ? Is it due to the object size ? I'm using redisson 3.17.1.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4355/comments",
    "author": "alexwibowo",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-06-30T09:47:48Z",
        "body": "Check the network"
      }
    ]
  },
  {
    "number": 4354,
    "title": "Migrated slave client connections on the master node upon corresponding slave failure are not released after the slave node recovered",
    "created_at": "2022-06-10T03:52:43Z",
    "closed_at": "2023-03-23T02:41:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4354",
    "body": "Hi Redisson Community,\r\n\r\nWhile testing the client connection amount that redisson client establish, I notice three behaviors that I don't have an answer about. Might be a connection leak, but I don't know if there is any reason. Hope anyone could share some hint about the reason behind the scene.\r\n\r\n\r\n#### Redisson client version\r\nv3.17.3\r\n\r\n#### Code I use for the behavior below\r\n```\r\n//Only using the initialization, no any query is performed\r\n\r\npublic class RedissonTest {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        File redissonConfigYaml = new File(\"<path>/redisson.yaml\");\r\n        Config redissonConfig = Config.fromYAML(redissonConfigYaml);\r\n\r\n        if (Epoll.isAvailable()) {\r\n            redissonConfig.setTransportMode(TransportMode.EPOLL);\r\n        }\r\n\r\n        RedissonClient redissonClient = Redisson.create(redissonConfig);\r\n    }\r\n}\r\n```\r\n\r\n#### Redisson configuration I use\r\n```\r\nclusterServersConfig:\r\n  idleConnectionTimeout: 10000\r\n  connectTimeout: 10000\r\n  timeout: 3000\r\n  retryAttempts: 3\r\n  retryInterval: 1500\r\n  password: null\r\n  subscriptionsPerConnection: 5\r\n  clientName: Test\r\n  loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}\r\n  subscriptionConnectionMinimumIdleSize: 0\r\n  subscriptionConnectionPoolSize: 0\r\n  slaveConnectionMinimumIdleSize: 2\r\n  slaveConnectionPoolSize: 2\r\n  masterConnectionMinimumIdleSize: 2\r\n  masterConnectionPoolSize: 2\r\n  readMode: \"MASTER_SLAVE\"\r\n  subscriptionMode: \"SLAVE\"\r\n  nodeAddresses:\r\n    - \"redis://redis.master1:6359\"\r\n    - \"redis://redis.master2:6359\"\r\n    - \"redis://redis.master3:6359\"\r\n  scanInterval: 5000\r\n  pingConnectionInterval: 30000\r\n  keepAlive: false\r\n  tcpNoDelay: false\r\nthreads: 2\r\nnettyThreads: 32\r\ncodec: !<org.redisson.codec.FstCodec> {}\r\n\r\ntransportMode: \"NIO\"\r\n```\r\n\r\n#### 1\\. Extra client connection in master nodes\r\n\r\nWhen I initialize the redisson client, I ran the `client list` command to list all the client connections with name \"Test\" (defined in the configuration above). And I expect 2 connections to each master node, and 2 connections to each slave node. But instead, I saw **3 connections to each master node**, and 2 connections to each slave node.\r\n\r\nBelow are the 3 client connections I captured in different time. And I noticed one of the connection is doing cmd \"cluster\" sometime.\r\n```\r\nid=190 addr=localhost:1852 laddr=redis.master1:6359 fd=20 name=Test age=12 idle=12 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 obl=0 oll=0 omem=0 tot-mem=20504 events=r cmd=cluster user=default redir=-1\r\nid=191 addr=localhost:1854 laddr=redis.master1:6359 fd=21 name=Test age=12 idle=12 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 obl=0 oll=0 omem=0 tot-mem=20496 events=r cmd=ping user=default redir=-1\r\nid=192 addr=localhost:1855 laddr=redis.master1:6359 fd=22 name=Test age=12 idle=12 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 obl=0 oll=0 omem=0 tot-mem=20496 events=r cmd=ping user=default redir=-1\r\n```\r\n\r\n```\r\nid=190 addr=localhost:1852 laddr=redis.master1:6359 fd=20 name=Test age=36 idle=6 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 obl=0 oll=0 omem=0 tot-mem=20496 events=r cmd=ping user=default redir=-1\r\nid=191 addr=localhost:1854 laddr=redis.master1:6359 fd=21 name=Test age=36 idle=6 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 obl=0 oll=0 omem=0 tot-mem=20496 events=r cmd=ping user=default redir=-1\r\nid=192 addr=localhost:1855 laddr=redis.master1:6359 fd=22 name=Test age=36 idle=6 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 obl=0 oll=0 omem=0 tot-mem=20496 events=r cmd=ping user=default redir=-1\r\n```\r\n\r\n```\r\nid=190 addr=localhost:1852 laddr=redis.master1:6359 fd=20 name=Test age=126 idle=5 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 obl=0 oll=0 omem=0 tot-mem=20496 events=r cmd=ping user=default redir=-1\r\nid=191 addr=localhost:1854 laddr=redis.master1:6359 fd=21 name=Test age=126 idle=5 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 obl=0 oll=0 omem=0 tot-mem=20496 events=r cmd=ping user=default redir=-1\r\nid=192 addr=localhost:1855 laddr=redis.master1:6359 fd=22 name=Test age=126 idle=5 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 obl=0 oll=0 omem=0 tot-mem=20496 events=r cmd=ping user=default redir=-1\r\n```\r\n\r\nI am guessing that the extra connection is remained for resolving the topology, but I am not 100% sure. So may I ask what is the purpose of the extra connection on master node? \r\n\r\nIf there is a purpose for the extra connection, is this extra connection not limited by the pool size from the configuration (I set both connection pool size minimum and limit to 2)?\r\n\r\n\r\n#### 2\\. Upon slave node failure, the connections are migrated to master. But never released from the master node even the slave is recovered from failure.\r\n\r\nAfter the initialization, I got 3 client connections for each master and 2 client connections for each slave. \r\n\r\nBelow is result of the script that I ran to count the client connection with name \"Test\" on each node.\r\n```\r\nTest has 3 client connection in redis.master1\r\nTest has 3 client connection in redis.master2\r\nTest has 3 client connection in redis.master3\r\nTest has 2 client connection in redis.slave1\r\nTest has 2 client connection in redis.slave2\r\nTest has 2 client connection in redis.slave3\r\n```\r\n\r\nThen I stopped one of the slave node \"redis.slave1\" (I am using docker container, so I ran 'docker stop' which should equivalent to SIGTERM --> grace period --> SIGKILL ). Then I notice the 2 client connections on the stopped slave are migrated to the corresponding master. \r\n\r\n(The master&slave relation of my local setup is like: redis.master1&redis.slave3, redis.master2&redis.slave1, redis.master3&redis.slave2)\r\n```\r\nTest has 3 client connection in redis.master1\r\nTest has 5 client connection in redis.master2\r\nTest has 3 client connection in redis.master3\r\nCould not connect to Redis at redis.slave1: Connection refused\r\nTest has 0 client connection in redis.slave1\r\nTest has 2 client connection in redis.slave2\r\nTest has 2 client connection in redis.slave3\r\n```\r\n\r\nThen I restart the \"redis.slave1\", the 2 client connections are reconnected. But after waiting about 20mins, the 2 extra connections that migrated to its master are never released.\r\n```\r\nTest has 3 client connection in redis.master1\r\nTest has 5 client connection in redis.master2\r\nTest has 3 client connection in redis.master3\r\nTest has 2 client connection in redis.slave1\r\nTest has 2 client connection in redis.slave2\r\nTest has 2 client connection in redis.slave3\r\n```\r\n\r\nAnd here is the redisson log when during the stop and restart of the \"redis.slave1\"\r\n\r\n```\r\n[redisson-netty-2-5] INFO org.redisson.connection.MasterSlaveEntry - master redis.master2/redis.master2:6359 used as slave\r\n[redisson-netty-2-5] WARN org.redisson.cluster.ClusterConnectionManager - slave: redis://redis.slave1:6360 has down for slot ranges: [[5461-10922]]\r\n[redisson-netty-2-28] INFO org.redisson.connection.pool.SlaveConnectionPool - 2 connections initialized for redis.master2/redis.master2:6359\r\n[redisson-netty-2-8] INFO org.redisson.cluster.ClusterConnectionManager - slave: redis://redis.slave1:6360 is up for slot ranges: [[5461-10922]]\r\n[redisson-netty-2-21] INFO org.redisson.connection.pool.SlaveConnectionPool - 2 connections initialized for redis.slave1/redis.slave1:6360\r\n```\r\n\r\nWhen I test the situation when \"master node is down\", I notice the slave become master and take over the connections. And as soon as the master back alive, and fix the role by failover, the extra connections on the slave node are released. This is the expected behavior.\r\n\r\nBut the behavior is different when \"slave node is down\" , why the connections that been taken over by master are not released once the slave node is back alive? And this is causing the redisson client hold the connections more than the defined pool size of configuration.\r\n\r\nThanks for your time and patience.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4354/comments",
    "author": "RunzhongHuang",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-06-10T04:58:37Z",
        "body": "Hi,\r\n\r\n> I am guessing that the extra connection is remained for resolving the topology, but I am not 100% sure. So may I ask what is the purpose of the extra connection on master node?\r\n\r\nIt's used for topology scanning.\r\n\r\n> But the behavior is different when \"slave node is down\" , why the connections that been taken over by master are not released once the slave node is back alive?\r\n\r\nBecause when there are no alive slaves for master node it's used as slave with additional connections."
      },
      {
        "user": "RunzhongHuang",
        "created_at": "2022-06-10T05:10:44Z",
        "body": "Thank you for the quick response @mrniko ! \nI understand the master is also using these additional connection while slave is not alive. But after the slave is back alive, why these additional connection remains in master node not getting released? And the total connections are more than the configured master connection pool size?"
      },
      {
        "user": "mrniko",
        "created_at": "2022-06-10T05:49:28Z",
        "body": "Because readMode: \"MASTER_SLAVE\". Specify readMode: MASTER."
      },
      {
        "user": "RunzhongHuang",
        "created_at": "2022-06-10T17:14:38Z",
        "body": "Hi @mrniko \r\n\r\nI tried both \"MASTER_SLAVE\" and \"MASTER\", the behavior is same. After the slave is back, the addition connection on master node is not released.\r\n\r\n### Result:\r\nAfter initializing the redisson client.\r\n```\r\nTest has 3 client connection in redis.master1\r\nTest has 3 client connection in redis.master2\r\nTest has 3 client connection in redis.master3\r\nTest has 2 client connection in redis.slave1\r\nTest has 2 client connection in redis.slave2\r\nTest has 2 client connection in redis.slave3\r\n```\r\nAfter stopping one of the redis slave node.\r\n```\r\nTest has 3 client connection in redis.master1\r\nTest has 5 client connection in redis.master2\r\nTest has 3 client connection in redis.master3\r\nCould not connect to Redis at redis.slave1: Connection refused\r\nTest has 0 client connection in redis.slave1\r\nTest has 2 client connection in redis.slave2\r\nTest has 2 client connection in redis.slave3\r\n```\r\nAfter restarting that slave node.\r\n```\r\nTest has 3 client connection in redis.master1\r\nTest has 5 client connection in redis.master2\r\nTest has 3 client connection in redis.master3\r\nTest has 2 client connection in redis.slave1\r\nTest has 2 client connection in redis.slave2\r\nTest has 2 client connection in redis.slave3\r\n```\r\n\r\nI am not sure if this behavior is designed. If yes, could you tell me the purpose of it? Because I am starting to considering the production environment, and this might leave 3 or 4 digits number of additional connection on the master node.\r\n\r\n```\r\nCurrent behavior of the master nodes client connection count:  3 -> - (slave down) -> 5 -> - (slave back alive) -> 5 -> 5 ... \r\n(What I assume the behavior): 3 -> - (slave down) -> 5 -> - (slave back alive) -> 3 ...\r\n```\r\n\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2023-03-23T08:04:25Z",
        "body": "@RunzhongHuang \r\n\r\nWhat was the issue?"
      },
      {
        "user": "RunzhongHuang",
        "created_at": "2023-03-23T18:58:36Z",
        "body": "@mrniko Still not sure what was actually happening. And even with this observation, there weren't impact of the performance in our current product. So I shifted the priority and move on to other stuffs. Saw this was still opened, so I was thinking to close it for now and drill down to this issue later time with more knowledge of the behavior between Redisson client and Redis server."
      }
    ]
  },
  {
    "number": 4350,
    "title": "Inserting 10 million records in Redis",
    "created_at": "2022-06-07T15:26:24Z",
    "closed_at": "2022-06-09T09:11:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4350",
    "body": "I am trying to insert around 10 million records in Redis using Redisson. \r\n\r\n```\r\n    public void addInventory(final List<ItemInventory> itemInventory) {\r\n        RBatch batch = redissonClient.createBatch(BatchOptions.defaults().responseTimeout(150, TimeUnit.SECONDS).skipResult());\r\n        RMapAsync<String, ItemInventory> map = batch.getMap(\"REDIS_INVENTORY_MAP\");\r\n        try {\r\n            itemInventory.forEach(t -> map.fastPutAsync(t.getKey(), t));\r\n            batch.execute().getResponses();\r\n        } catch (Exception e) {\r\n            LOGGER.error(() -> MessageUtils.errorMessage(\"INVENTORY_LOADING\",\r\n                    String.format(\"addInventory failed: %s\", e.getMessage()), e, false));\r\n        }\r\n    }\r\n```\r\nThis process takes lots of time and even throws OutOfMemory at times. Need guidance on the best way to do it. If I can initiate something like pipe `cat data.txt | redis-cli --pipe`",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4350/comments",
    "author": "shivangmittal01",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-06-09T09:10:48Z",
        "body": "Making a single batch for 10M insertions consuming a lot of memory and causes OOM. Try to split it into 10 batches for 1M"
      },
      {
        "user": "shivangmittal01",
        "created_at": "2022-06-09T09:51:46Z",
        "body": "Thanks @mrniko "
      }
    ]
  },
  {
    "number": 4343,
    "title": "Latency Spike after Redisson Upgrade ",
    "created_at": "2022-06-05T05:24:54Z",
    "closed_at": "2022-06-30T09:55:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4343",
    "body": "Hi,\r\nOur service is using RLock now with redisson-3.13.6 with expected behavior. Recently, we upgraded our Redisson version to use redisson-3.16.2, and couple issues happened afterward (No other code changes, just version upgrade):\r\n1. Although our acquireLock has 50ms waiting time, but somehow it wait up to ~1000ms before return after upgrading version. \r\n2. We noticed latency increase(~20ms -> ~75ms) when doing fastPut to RCachedMap after upgrading version.\r\n\r\nOur Redission client config is as below:\r\n```\r\n            Config config = new Config();\r\n            \r\n            config.setNettyThreads(128)\r\n                  .useClusterServers()\r\n                  .addNodeAddress(String.format(\"rediss://%s:%s\", CONTACT_POOL_EC_ADDRESS, CONTACT_POOL_EC_PORT))\r\n                  .setTimeout(8000)\r\n                  .setRetryInterval(50)\r\n                  .setMasterConnectionPoolSize(256)\r\n                  .setMasterConnectionMinimumIdleSize(16)\r\n                  .setSlaveConnectionPoolSize(256)\r\n                  .setSlaveConnectionMinimumIdleSize(16)\r\n                  .setKeepAlive(true)\r\n                  .setPingConnectionInterval(10000)\r\n                  .setUsername( \"default\");\r\n\r\n            config.setLockWatchdogTimeout(200);\r\n\r\n           return Redisson.create(config);\r\n```\r\n\r\nMore context about our usage:\r\nOur service has a scheduled job to use RExectutorService to send job to worker. Multiple host will register worker to consume the job, but each worker will leverage RLock to limit only 1 active job running. In each job running, it will read/write data into Redis RCachedMap. \r\n\r\n\r\nCan you help here? Is there anything else we should do before upgrading the version?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4343/comments",
    "author": "gengli24",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-06-06T09:46:25Z",
        "body": "3.16.2 had some issues like connection leak. Please update to the latest version - 3.17.3"
      },
      {
        "user": "gengli24",
        "created_at": "2022-06-06T16:23:02Z",
        "body": "Thanks @mrniko .\r\n\r\nI do have couple follow-up questions:\r\n1. I am not sure that connection leak is the major cause of this. The latency spike actually is consistent after upgrade for almost all operations. \r\n2. For some reason, our current version 3.13.6 is behaving as expected, so I am thinking whether it's because some incorrect configuration/usage that is incompatible with newer versions. Anything you can think of?"
      },
      {
        "user": "mrniko",
        "created_at": "2022-06-07T05:48:25Z",
        "body": "> Although our acquireLock has 50ms waiting time, but somehow it wait up to ~1000ms before return after upgrading version.\r\n\r\nIt's caused by sync lag between master and slaves during lock acquisition.\r\n\r\n> For some reason, our current version 3.13.6 is behaving as expected, so I am thinking whether it's because some incorrect configuration/usage that is incompatible with newer versions. Anything you can think of?\r\n\r\nConfiguration usage hasn't changed. "
      }
    ]
  },
  {
    "number": 4339,
    "title": "Publish only to certain clients",
    "created_at": "2022-06-02T13:32:57Z",
    "closed_at": "2022-09-30T07:44:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4339",
    "body": "My application uses publish/subscribe with a many-to-many relationship, which means the sender can be a listener on the same channel. What this is for: I have two application instances and when some things are updated in one application, it needs to notify the second Redis client to do the same. Now I have a crutch with this. Is there a way to solve this with the library or the Redis commands themselves?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4339/comments",
    "author": "Rostyslav26",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-06-10T11:08:41Z",
        "body": "Why can't you use RTopic?"
      },
      {
        "user": "Rostyslav26",
        "created_at": "2022-06-12T11:39:02Z",
        "body": "unless the topic is published to all clients?"
      },
      {
        "user": "mrniko",
        "created_at": "2022-06-13T11:04:43Z",
        "body": "You could use topic per clients pair"
      },
      {
        "user": "Rostyslav26",
        "created_at": "2022-06-13T13:09:33Z",
        "body": "how to do it?"
      },
      {
        "user": "mrniko",
        "created_at": "2022-06-13T14:31:09Z",
        "body": "RTopic topic = getTopic(\"client1client2\")"
      }
    ]
  },
  {
    "number": 4333,
    "title": "io.netty.handler.codec.DecoderException: java.lang.IllegalStateException: Can't decode replay",
    "created_at": "2022-06-01T18:01:23Z",
    "closed_at": "2022-08-25T07:14:41Z",
    "labels": [
      "question",
      "GCP"
    ],
    "url": "https://github.com/redisson/redisson/issues/4333",
    "body": "I am getting the following error when I am trying to connect to Memorystore Redis on GCP. This works fine locally but not on Google Cloud. I have double-checked the IP and It's correct. VPC is set up correctly as well. This was working before with Jedis Library.\r\n\r\norg.redisson.Version : Redisson 3.17.2\r\n\r\nConfig Code\r\n```\r\n    public RedissonClient redissonClient(@Value(\"${redis.host}\") String host, @Value(\"${redis.port}\") String port) {\r\n\r\n        if (!StringUtils.hasText(host) || !StringUtils.hasText(port)) {\r\n            throw new RuntimeException(\"missing cache configuration\");\r\n        }\r\n\r\n        log.info(\"Connecting Broker to Redis at: \" + host);\r\n\r\n        Config config = new Config();\r\n        config.useSingleServer().setAddress(\"redis://\" + host + \":\" + port);\r\n        return Redisson.create(config);\r\n    }\r\n}\r\n```\r\n\r\n\r\n```\r\nio.netty.handler.codec.DecoderException: java.lang.IllegalStateException: Can't decode replay: \u0015\u0003\u0001\u0002\u0002F\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:398) ~[redisson-3.17.2.jar!/:3.17.2]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198) ~[redisson-3.17.2.jar!/:3.17.2]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137) ~[redisson-3.17.2.jar!/:3.17.2]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113) ~[redisson-3.17.2.jar!/:3.17.2]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510) ~[netty-codec-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279) ~[netty-codec-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[netty-transport-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722) ~[netty-transport-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658) ~[netty-transport-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584) ~[netty-transport-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496) ~[netty-transport-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) ~[netty-common-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.74.Final.jar!/:4.1.74.Final]\r\n\tat java.base/java.lang.Thread.run(Unknown Source) ~[na:na] \r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4333/comments",
    "author": "ritwickgupta",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-06-02T04:41:56Z",
        "body": "The problem is in data encoding. Try to clean data stored with a different codec or use the same codec with Redisson."
      },
      {
        "user": "ritwickgupta",
        "created_at": "2022-06-02T12:17:34Z",
        "body": "I am getting this at app bootup. Memorystore has no data stored and I am not setting the codec anywhere explicitly. I am just using default.\r\n\r\nCould it be possible that the Memorystore Redis instance is using a different codec?"
      },
      {
        "user": "mrniko",
        "created_at": "2022-06-03T03:40:27Z",
        "body": "I don't think so. Can you set `trace` logging level for `org.redisson` and share output from application start?"
      },
      {
        "user": "kaviarasupgk",
        "created_at": "2023-01-03T13:28:53Z",
        "body": "I am also getting the same issue. Could you please share the solution for this and that would be helpful\r\n"
      },
      {
        "user": "priyankgosalia",
        "created_at": "2023-05-02T11:35:24Z",
        "body": "We're getting the same error while connecting to Redis on GCP. Was there ever a solution to this issue? Any leads would be helpful."
      }
    ]
  },
  {
    "number": 4310,
    "title": "support for alicloud ApsaraDB for Redis",
    "created_at": "2022-05-23T06:59:21Z",
    "closed_at": "2022-05-23T07:11:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4310",
    "body": "Is alicloud's 'ApsaraDB for Redis' supported in redission client?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4310/comments",
    "author": "kanteshkm",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-05-23T07:11:37Z",
        "body": "It's supported if it's compatible with Redis."
      }
    ]
  },
  {
    "number": 4288,
    "title": "Redisson scheduled job not firing at the expected time",
    "created_at": "2022-05-11T15:43:47Z",
    "closed_at": "2023-04-12T10:31:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4288",
    "body": "### **Background:**\r\nRedisson version: 3.16.1\r\nFramework: Spring Boot\r\nRedis instance type: Azure Cache for Redis\r\nRedis version: 4.1.14\r\n\r\nTimers are used to add timeouts for tasks to complete\r\n\r\n### Issue\r\nI am using the schedule API of redisson to schedule timers. Intermittently we have had issues where timers are not firing at the expected time. For example we schedule 3 timers, one 2 seconds, one 8 seconds and one 60 seconds. \r\n2 of the timers might fire as expected but the third will be delayed by anything up to 1 hour. Usually the delay is between 30-60 seconds. When the issue starts happening for one timer all subsequent timers will be delayed. The timers do eventually fire but with a delay. The only workaround is to restart the application.\r\n\r\nIs this a known issue or has anyone come across this issue before?\r\n\r\n**Timer scheduled** \r\n` scheduleService\r\n                                    .schedule(jobSchedulerTimeOutHandler, timeoutMs, TimeUnit.MILLISECONDS);`\r\n\r\n**Timeout handler**\r\n` @Override\r\n    public void run() {\r\n        info(log, \"Time is out for schedulingCorrelation: {}, correlation: {}\", schedulingCorrelation, correlation);       \r\n    }`\r\n\r\n### Redis configuration \r\n      idleConnectionTimeout: 10000\r\n      connectTimeout: 15000\r\n      timeout: 3000\r\n      retryAttempts: 3\r\n      retryInterval: 1500\r\n      failedSlaveReconnectionInterval: 3000\r\n      failedSlaveCheckInterval: 60000\r\n      password: ${REDIS_AZURE_PASSWORD}\r\n      subscriptionsPerConnection: 5\r\n      clientName: null\r\n      pingConnectionInterval: 3000\r\n      tcpNoDelay: true\r\n      subscriptionConnectionMinimumIdleSize: 1\r\n      subscriptionConnectionPoolSize: 50\r\n      slaveConnectionMinimumIdleSize: 24\r\n      slaveConnectionPoolSize: 64\r\n      masterConnectionMinimumIdleSize: 24\r\n      masterConnectionPoolSize: 64\r\n      readMode: \"MASTER\"\r\n      subscriptionMode: \"MASTER\"\r\n      nodeAddresses:\r\n        - \"rediss://${REDIS_AZURE_HOSTNAME}:{{ .Values.redis.azure.sslPort }}\"\r\n    threads: 16\r\n    nettyThreads: 32\r\n    codec: !<org.redisson.codec.FstCodec> {}\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4288/comments",
    "author": "juveneur",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-05-12T06:18:10Z",
        "body": "Can you share code to reproduce it?"
      },
      {
        "user": "juveneur",
        "created_at": "2022-05-12T09:11:15Z",
        "body": "> Can you share code to reproduce it?\r\n\r\nThanks for getting back on this. The problem it is not reproducible but we have seen it on at least 2 different environments now and the only way to recover has been to restart the application.  \r\n\r\n### Environment\r\nSpring boot applications running in a Kubernetes environment on azure. We use Azure Cache for Redis and Redisson for timers. Each engagement could schedule up to 5-10 timers. We could have up to 50k engagements per hour so anywhere from 200k to 500k timer scheduled per hour. This would be the high end. On the 2 environments that experienced this issue the rate was much lower (somewhere in the region of 1k engagements per hour) \r\n\r\n### What we know\r\n\r\n- Issue is intermittent and not reproducible\r\n- Once the issue happens it continues to happen for ever timer after i.e. we see delays in timers firing but in each case they do eventually fire\r\n- Only way to recover is to restart the application \r\n\r\n### Code\r\n`@Service\r\npublic class RedissonSchedulerService implements ScheduleService {\r\n\r\n    private RScheduledExecutorService executorService;\r\n\r\n    public RedissonSchedulerService(RedissonClient redissonClient,\r\n                                    BeanFactory beanFactory,\r\n                                    ApplicationProperties properties) {\r\n\r\n        executorService = createService(redissonClient, beanFactory, properties);\r\n    }\r\n\r\n    private RScheduledExecutorService createService(RedissonClient redissonClient, BeanFactory beanFactory, ApplicationProperties properties) {\r\n        RScheduledExecutorService scheduledExecutorService = redissonClient.getExecutorService(properties.getRedis().getExecutorServiceName());\r\n        WorkerOptions workerOptions = WorkerOptions.defaults().workers(properties.getRedis().getCountOfExecutorWorkers()).beanFactory(beanFactory);\r\n        scheduledExecutorService.registerWorkers(workerOptions);\r\n        return scheduledExecutorService;\r\n    }\r\n\r\n    @Override\r\n    public RScheduledFuture<?> schedule(Runnable runnable, long time, TimeUnit timeUnit) {\r\n        return executorService.schedule(runnable, time, timeUnit);\r\n    }\r\n\r\n    @Override\r\n    public RScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long time, TimeUnit timeUnit) {\r\n        return executorService.scheduleWithFixedDelay(runnable, time, time, timeUnit);\r\n    }\r\n\r\n    @Override\r\n    public boolean cancelTask(String taskId) {\r\n        return executorService.cancelTask(taskId);\r\n    }\r\n}`\r\n\r\n**properties.getRedis().getCountOfExecutorWorkers() = 5 workers**\r\n\r\n**JobScheduleTimerCommandHandler**\r\n` scheduleService\r\n                                    .schedule(jobSchedulerTimeOutHandler, timeoutMs, TimeUnit.MILLISECONDS);`\r\n\r\n**JobSchedulerTimeOutHandler**\r\n\r\n` @Override\r\n    public void run() {\r\n        info(log, \"Time is out for schedulingCorrelation: {}, correlation: {}\", schedulingCorrelation, correlation);\r\n    }`\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2022-06-01T08:08:48Z",
        "body": "What is the task duration? Do you see any errors in logs?"
      },
      {
        "user": "juveneur",
        "created_at": "2022-06-01T15:11:37Z",
        "body": "Usually the task timers are between 10-60 seconds. I see no errors in the logs i just see the task timers are fired much later. I have seen cases where a 10 second timer could fire 1 hour later. "
      },
      {
        "user": "mrniko",
        "created_at": "2022-06-30T10:46:49Z",
        "body": "Make sure that clocks are synced across all nodes"
      },
      {
        "user": "mrniko",
        "created_at": "2022-07-04T07:10:02Z",
        "body": "@juveneur \r\n\r\nAlso try to increase workers"
      },
      {
        "user": "mrniko",
        "created_at": "2023-04-12T10:32:40Z",
        "body": "3.16.1 had a connection leak issue. Try to upgrade version"
      }
    ]
  },
  {
    "number": 4284,
    "title": "What difference from `readAllEntrySet` and `getAll` in `RMap`",
    "created_at": "2022-05-10T12:57:00Z",
    "closed_at": "2022-05-10T13:15:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4284",
    "body": "Hi~ Community:\r\n    When I want to use `hmget` command in redis, I found `rMap.getAll(\"\")`, it returns all fields, so what difference from `readAllEntrySet` and `getAll` in `RMap`?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4284/comments",
    "author": "xdshent",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-05-10T13:01:52Z",
        "body": "`getAll` methods allows to load map by specified keys. Whereas `readAllEntrySet` loads all map entries."
      },
      {
        "user": "xdshent",
        "created_at": "2022-05-10T13:14:57Z",
        "body": "> `getAll` methods allows to load map by specified keys. Whereas `readAllEntrySet` loads all map entries.\r\n\r\nthx! @mrniko "
      }
    ]
  },
  {
    "number": 4281,
    "title": "Redis is changed to access with password, and trylock takes more time",
    "created_at": "2022-05-10T09:47:28Z",
    "closed_at": "2022-05-12T06:58:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4281",
    "body": "Redis used to access without password, and then upgraded to access with password. It was found that trylock took more than one second。\r\nredisson version is 3.16.0\r\nThe configuration is as follows：\r\n`config.useClusterServers()\r\n                    .setPassword(password)\r\n                    .setScanInterval(2000)\r\n                    .addNodeAddress(xxxxx);\r\n            return Redisson.create(config);`\r\nso, I tried to reduce the reission version to 3.11.6, and the time consumption decreased significantly\r\nI don't know what caused this. Is it the wrong way to use the new version?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4281/comments",
    "author": "XTUxiongda",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-05-10T10:02:24Z",
        "body": "It was caused by introduction of WAIT command to sync with slaves. It seems that sync takes much time in your case."
      },
      {
        "user": "XTUxiongda",
        "created_at": "2022-05-10T10:24:28Z",
        "body": "> It was caused by introduction of WAIT command to sync with slaves. It seems that sync takes much time in your case.\r\nIs there any way to solve it? I found this problem after version 3.14.1. Or can I only use the old version, and the new version all has this problem?\r\n"
      },
      {
        "user": "XTUxiongda",
        "created_at": "2022-05-10T10:27:39Z",
        "body": "And My waittime input parameter is 0\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2022-05-10T12:59:24Z",
        "body": "Could you set `TRACE` logging level for `org.redisson` package and share output?"
      },
      {
        "user": "XTUxiongda",
        "created_at": "2022-05-10T13:34:54Z",
        "body": "[basic-porter-tadata-xxx.xx.xx.xx-0000] 2022-05-10 21:30:16.221 TRACE 20100 [redisson-netty-2-4] [CommandEncoder.java:112] channel: [id: 0x5eda2625, L:/xxx.xx.xx.xx:58206 - R:xxx.xx.xx.xx/xxx.xx.xx.xx:7002] message: *2\r\n$7\r\nCLUSTER\r\n$5\r\nNODES\r\n\r\n[basic-porter-tadata-xxx.xx.xx.xx-0000] 2022-05-10 21:30:16.235 TRACE 20100 [redisson-netty-2-4] [CommandDecoder.java:113] reply: $775\r\na45ecb9201e0bf48665ed7e5a9846cbe6d753165 xxx.xx.xx.xx:7006@17006 slave f5d943dbd5806937e204ee35ea5f6aa65e46a6ca 0 1652189413455 6 connected\r\nf5d943dbd5806937e204ee35ea5f6aa65e46a6ca xxx.xx.xx.xx:7003@17003 master - 0 1652189414000 3 connected 10923-16383\r\n40e866c9d83596f7d50ff09ee92370f580c9add9 xxx.xx.xx.xx:7001@17001 master - 0 1652189415465 1 connected 0-5460\r\nf226329e04bda39971a532552f18a32bb2c1b7a8 xxx.xx.xx.xx:7005@17005 slave ced813a2fd0db10432dbc999befd3709ac2234a2 0 1652189414460 5 connected\r\neccdd6be867c3fc36a27f2c1cc105c98c2d08879 xxx.xx.xx.xx:7004@17004 slave 40e866c9d83596f7d50ff09ee92370f580c9add9 0 1652189414000 1 connected\r\nced813a2fd0db10432dbc999befd3709ac2234a2 xxx.xx.xx.xx:7002@17002 myself,master - 0 1652189413000 2 connected 5461-10922\r\n\r\n, channel: [id: 0x5eda2625, L:/xxx.xx.xx.xx:58206 - R:xxx.xx.xx.xx/xxx.xx.xx.xx:7002], command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@44c15e70(incomplete)], command=(CLUSTER NODES), params=[], codec=null]\r\n[basic-porter-tadata-xxx.xx.xx.xx-0000] 2022-05-10 21:30:16.236 DEBUG 20100 [redisson-netty-2-4] [ClusterConnectionManager.java:466] cluster nodes state got from xxx.xx.xx.xx/xxx.xx.xx.xx:7002:\r\na45ecb9201e0bf48665ed7e5a9846cbe6d753165 xxx.xx.xx.xx:7006@17006 slave f5d943dbd5806937e204ee35ea5f6aa65e46a6ca 0 1652189413455 6 connected\r\nf5d943dbd5806937e204ee35ea5f6aa65e46a6ca xxx.xx.xx.xx:7003@17003 master - 0 1652189414000 3 connected 10923-16383\r\n40e866c9d83596f7d50ff09ee92370f580c9add9 xxx.xx.xx.xx:7001@17001 master - 0 1652189415465 1 connected 0-5460\r\nf226329e04bda39971a532552f18a32bb2c1b7a8 xxx.xx.xx.xx:7005@17005 slave ced813a2fd0db10432dbc999befd3709ac2234a2 0 1652189414460 5 connected\r\neccdd6be867c3fc36a27f2c1cc105c98c2d08879 xxx.xx.xx.xx:7004@17004 slave 40e866c9d83596f7d50ff09ee92370f580c9add9 0 1652189414000 1 connected\r\nced813a2fd0db10432dbc999befd3709ac2234a2 xxx.xx.xx.xx:7002@17002 myself,master - 0 1652189413000 2 connected 5461-10922\r\n\r\n[basic-porter-tadata-xxx.xx.xx.xx-0000] 2022-05-10 21:30:17.313 DEBUG 20100 [http-nio-8080-exec-3] [ClusterConnectionManager.java:751] slot 2875 for sync_tadata_lock\r\n[basic-porter-tadata-xxx.xx.xx.xx-0000] 2022-05-10 21:30:17.314 DEBUG 20100 [http-nio-8080-exec-3] [ClusterConnectionManager.java:751] slot 2875 for sync_tadata_lock\r\n[basic-porter-tadata-xxx.xx.xx.xx-0000] 2022-05-10 21:30:17.314 TRACE 20100 [redisson-netty-2-5] [CommandEncoder.java:112] channel: [id: 0x1dd4250d, L:/xxx.xx.xx.xx:58207 - R:xxx.xx.xx.xx/xxx.xx.xx.xx:7001] message: *6\r\n$4\r\nEVAL\r\n$339\r\nif (redis.call('exists', KEYS[1]) == 0) then redis.call('hincrby', KEYS[1], ARGV[2], 1); redis.call('pexpire', KEYS[1], ARGV[1]); return nil; end; if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then redis.call('hincrby', KEYS[1], ARGV[2], 1); redis.call('pexpire', KEYS[1], ARGV[1]); return nil; end; return redis.call('pttl', KEYS[1]);\r\n$1\r\n1\r\n$16\r\nsync_tadata_lock\r\n$6\r\n600000\r\n$40\r\n8f9cbb23-40dd-4457-a13a-6f8041461ba5:194\r\n\r\n[basic-porter-tadata-xxx.xx.xx.xx-0000] 2022-05-10 21:30:17.315 TRACE 20100 [redisson-netty-2-5] [CommandEncoder.java:112] channel: [id: 0x1dd4250d, L:/xxx.xx.xx.xx:58207 - R:xxx.xx.xx.xx/xxx.xx.xx.xx:7001] message: *6\r\n$4\r\nEVAL\r\n$339\r\nif (redis.call('exists', KEYS[1]) == 0) then redis.call('hincrby', KEYS[1], ARGV[2], 1); redis.call('pexpire', KEYS[1], ARGV[1]); return nil; end; if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then redis.call('hincrby', KEYS[1], ARGV[2], 1); redis.call('pexpire', KEYS[1], ARGV[1]); return nil; end; return redis.call('pttl', KEYS[1]);\r\n$1\r\n1\r\n$16\r\nsync_tadata_lock\r\n$6\r\n600000\r\n$40\r\n8f9cbb23-40dd-4457-a13a-6f8041461ba5:194\r\n*3\r\n$4\r\nWAIT\r\n$1\r\n1\r\n$4\r\n1000\r\n\r\n[basic-porter-tadata-xxx.xx.xx.xx-0000] 2022-05-10 21:30:17.332 TRACE 20100 [redisson-netty-2-5] [CommandDecoder.java:113] reply: $-1\r\n, channel: [id: 0x1dd4250d, L:/xxx.xx.xx.xx:58207 - R:xxx.xx.xx.xx/xxx.xx.xx.xx:7001], command: CommandsData [commands=[CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@5dfb7633(incomplete)], command=(EVAL), params=[if (redis.call('exists', KEYS[1]) == 0) then redis.call('hincrby', KEYS[1], ARGV[2], 1); redis.call(..., 1, sync_tadata_lock, 600000, 8f9cbb23-40dd-4457-a13a-6f8041461ba5:194], codec=org.redisson.client.codec.LongCodec], CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@ee60138(incomplete)], command=(WAIT), params=[1, 1000], codec=org.redisson.client.codec.StringCodec]]]\r\n[basic-porter-tadata-xxx.xx.xx.xx-0000] 2022-05-10 21:30:18.255 TRACE 20100 [redisson-netty-2-4] [CommandEncoder.java:112] channel: [id: 0x5eda2625, L:/xxx.xx.xx.xx:58206 - R:xxx.xx.xx.xx/xxx.xx.xx.xx:7002] message: *2\r\n$7\r\nCLUSTER\r\n$5\r\nNODES\r\n\r\n[basic-porter-tadata-xxx.xx.xx.xx-0000] 2022-05-10 21:30:18.271 TRACE 20100 [redisson-netty-2-4] [CommandDecoder.java:113] reply: $775\r\na45ecb9201e0bf48665ed7e5a9846cbe6d753165 xxx.xx.xx.xx:7006@17006 slave f5d943dbd5806937e204ee35ea5f6aa65e46a6ca 0 1652189416468 6 connected\r\nf5d943dbd5806937e204ee35ea5f6aa65e46a6ca xxx.xx.xx.xx:7003@17003 master - 0 1652189414000 3 connected 10923-16383\r\n40e866c9d83596f7d50ff09ee92370f580c9add9 xxx.xx.xx.xx:7001@17001 master - 0 1652189415465 1 connected 0-5460\r\nf226329e04bda39971a532552f18a32bb2c1b7a8 xxx.xx.xx.xx:7005@17005 slave ced813a2fd0db10432dbc999befd3709ac2234a2 0 1652189416000 5 connected\r\neccdd6be867c3fc36a27f2c1cc105c98c2d08879 xxx.xx.xx.xx:7004@17004 slave 40e866c9d83596f7d50ff09ee92370f580c9add9 0 1652189417471 1 connected\r\nced813a2fd0db10432dbc999befd3709ac2234a2 xxx.xx.xx.xx:7002@17002 myself,master - 0 1652189415000 2 connected 5461-10922\r\n\r\n, channel: [id: 0x5eda2625, L:/xxx.xx.xx.xx:58206 - R:xxx.xx.xx.xx/xxx.xx.xx.xx:7002], command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@3c593bb7(incomplete)], command=(CLUSTER NODES), params=[], codec=null]\r\n[basic-porter-tadata-xxx.xx.xx.xx-0000] 2022-05-10 21:30:18.272 DEBUG 20100 [redisson-netty-2-4] [ClusterConnectionManager.java:466] cluster nodes state got from xxx.xx.xx.xx/xxx.xx.xx.xx:7002:\r\na45ecb9201e0bf48665ed7e5a9846cbe6d753165 xxx.xx.xx.xx:7006@17006 slave f5d943dbd5806937e204ee35ea5f6aa65e46a6ca 0 1652189416468 6 connected\r\nf5d943dbd5806937e204ee35ea5f6aa65e46a6ca xxx.xx.xx.xx:7003@17003 master - 0 1652189414000 3 connected 10923-16383\r\n40e866c9d83596f7d50ff09ee92370f580c9add9 xxx.xx.xx.xx:7001@17001 master - 0 1652189415465 1 connected 0-5460\r\nf226329e04bda39971a532552f18a32bb2c1b7a8 xxx.xx.xx.xx:7005@17005 slave ced813a2fd0db10432dbc999befd3709ac2234a2 0 1652189416000 5 connected\r\neccdd6be867c3fc36a27f2c1cc105c98c2d08879 xxx.xx.xx.xx:7004@17004 slave 40e866c9d83596f7d50ff09ee92370f580c9add9 0 1652189417471 1 connected\r\nced813a2fd0db10432dbc999befd3709ac2234a2 xxx.xx.xx.xx:7002@17002 myself,master - 0 1652189415000 2 connected 5461-10922\r\n\r\n[basic-porter-tadata-xxx.xx.xx.xx-0000] 2022-05-10 21:30:18.826 TRACE 20100 [redisson-netty-2-5] [CommandDecoder.java:113] reply: :0\r\n, channel: [id: 0x1dd4250d, L:/xxx.xx.xx.xx:58207 - R:xxx.xx.xx.xx/xxx.xx.xx.xx:7001], command: CommandsData [commands=[CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@5dfb7633(success)], command=(EVAL), params=[if (redis.call('exists', KEYS[1]) == 0) then redis.call('hincrby', KEYS[1], ARGV[2], 1); redis.call(..., 1, sync_tadata_lock, 600000, 8f9cbb23-40dd-4457-a13a-6f8041461ba5:194], codec=org.redisson.client.codec.LongCodec], CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@ee60138(incomplete)], command=(WAIT), params=[1, 1000], codec=org.redisson.client.codec.StringCodec]]]\r\n[basic-porter-tadata-xxx.xx.xx.xx-0000] 2022-05-10 21:30:18.827 DEBUG 20100 [redisson-netty-2-5] [RedisExecutor.java:522] connection released for command null and params null from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=24, freeConnectionsCounter=value:64:queue:0, freezeReason=null, client=[addr=redis://xxx.xx.xx.xx:7001], nodeType=MASTER, firstFail=0]]] using connection RedisConnection@1915911582 [redisClient=[addr=redis://xxx.xx.xx.xx:7001], channel=[id: 0x1dd4250d, L:/xxx.xx.xx.xx:58207 - R:xxx.xx.xx.xx/xxx.xx.xx.xx:7001], currentCommand=null]\r\n\r\n"
      },
      {
        "user": "XTUxiongda",
        "created_at": "2022-05-12T01:13:05Z",
        "body": "@mrniko can you help me on this queston? thank you very much. i really want to know the reason."
      },
      {
        "user": "mrniko",
        "created_at": "2022-05-12T06:13:29Z",
        "body": "I reproduce your case only if masterauth is not set for slave nodes."
      },
      {
        "user": "XTUxiongda",
        "created_at": "2022-05-12T06:49:45Z",
        "body": "> I reproduce your case only if masterauth is not set for slave nodes.\r\n\r\nthank you very much !  That's why. "
      }
    ]
  },
  {
    "number": 4258,
    "title": "redisson-tomcat-9-3.16.1, redisson-all-3.16.1  vs redisson-all-3.7.5, redisson-tomcat-8-3.7.5",
    "created_at": "2022-04-22T04:32:50Z",
    "closed_at": "2022-04-23T08:34:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4258",
    "body": "after  upgrade the latest redisson jar in tomcat lib folder, the tomcat session values stored in redis database, but the format is different.\r\nI could see the stored value using redis cli, but I unable to fetch the new format values from java application.\r\n\r\nRMap<String, Object> session =redisson.getMap(\"redisson:tomcat_session:AF5179B4D06780A504B8406AB0F905F8\", redisSerializationCodec)\r\n\r\n### old format :\r\n\r\n127.0.0.1:6379> hgetall redisson:tomcat_session:05341D84D5470264E9C8129CBB6A3758\r\n 1) \"\\xac\\xed\\x00\\x05t\\x00\\x0ebusinessStream\"\r\n 2) \"\\xac\\xed\\x00\\x05t\\x00\\x03CIE\"\r\n 3) \"\\xac\\xed\\x00\\x05t\\x00\\rsession:isNew\"\r\n 4) \"\\xac\\xed\\x00\\x05sr\\x00\\x11java.lang.Boolean\\xcd r\\x80\\xd5\\x9c\\xfa\\xee\\x02\\x00\\x01Z\\x00\\x05valuexp\\x00\"\r\n 5) \"\\xac\\xed\\x00\\x05t\\x00\\x04user\"\r\n 6) \"\\xac\\xed\\x00\\x05sr\\x00'ucles.ccms.nativejava.pojos.user.CAUser\\x0b\\x9b\\xc7a\\x8d\\xaa\\xb0-\\x02\\x00\\aI\\x00\\x15sessionTimeoutSecondsL\\x00\\x0ebusinessStreamt\\x00\\x12Ljava/lang/String;L\\x00\\ncreditorNoq\\x00~\\x00\\x01L\\x00\\x05namest\\x00,Lucles/ccms/nativejava/pojos/user/UserNames;L\\x00\\tpermitSett\\x00.Lucles/ccms/nativejava/pojos/user/CAPermitSet;L\\x00\\x10subordinateNamest\\x00\\x13Ljava/util/HashSet;L\\x00\\x06userIdq\\x00~\\x00\\x01xp\\x00\\x00\\x03\\x84t\\x00\\x03CIEpsr\\x00*ucles.ccms.nativejava.pojos.user.UserNamesp\\x18\\xbb\\x80\\xf0\\xe6L\\xc3\\x02\\x00\\x02L\\x00\\ruserLoginNameq\\x00~\\x00\\x01L\\x00\\buserNameq\\x00~\\x00\\x01xpt\\x00\\x0ecieAmAuthors01t\\x00\\rcieAmAuthors1sr\\x00,ucles.ccms.nativejava.pojos.user.CAPermitSet\\xf3\\xa6\\xde\\xa1&u'\\xd3\\x02\\x00\\x03Z\\x00\\x0bisSuperUserL\\x00\\x10effectivePermitst\\x00\\x15Ljava/util/ArrayList;L\\x00\\x0bsourceRolesq\\x00~\\x00\\x04xp\\x00sr\\x00\\x13java.util.ArrayListx\\x81\\xd2\\x1d\\x99\\xc7a\\x9d\\x03\\x00\\x01I\\x00\\x04sizexp\\x00\\x00\\x00\\rw\\x04\\x00\\x00\\x00\\rsr\\x00)ucles.ccms.nativejava.pojos.user.CAPermitl&\\x0f\\r\\\\\\xbd\\xc5K\\x02\\x00\\x03L\\x00\\x0cachievableIdq\\x00~\\x00\\x01L\\x00\\x0bpermitLevelt\\x000Lucles/ccms/nativejava/pojos/user/CAPermitLevel;L\\x00\\npermitNamet\\x00/Lucles/ccms/nativejava/pojos/user/CAPermitName;xpp~r\\x00.ucles.ccms.nativejava.pojos.user.CAPermitLevel\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xr\\x00\\x0ejava.lang.Enum\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xpt\\x00\\x04READ~r\\x00-ucles.ccms.nativejava.pojos.user.CAPermitName\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xq\\x00~\\x00\\x15t\\x00\\x19LIBRARY_MANAGEMENT_SCREENsq\\x00~\\x00\\x10pq\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x0bTASK_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40~q\\x00~\\x00\\x14t\\x00\\x05WRITE~q\\x00~\\x00\\x18t\\x00\\x0eREPORTS_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00 ~q\\x00~\\x00\\x18t\\x00\\x12ADVANCED_AUTHORINGsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00 ~q\\x00~\\x00\\x18t\\x00\\rSEARCH_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x12ACHIEVABLES_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x0fTAXONOMY_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x19PROJECT_MANAGEMENT_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x18WORKFLOW_TEMPLATE_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\nTCP_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\nTET_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16q\\x00~\\x00\\x19sq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16q\\x00~\\x00\\x1cxsr\\x00\\x11java.util.HashSet\\xbaD\\x85\\x95\\x96\\xb8\\xb74\\x03\\x00\\x00xpw\\x0c\\x00\\x00\\x00\\x10?@\\x00\\x00\\x00\\x00\\x00\\x02~r\\x00(ucles.ccms.nativejava.constants.CcmsRole\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xq\\x00~\\x00\\x15t\\x00\\x1bASSESSMENT_MATERIAL_MANAGER~q\\x00~\\x00Jt\\x00\\x06AUTHORxpt\\x00\\x1011003039800005b7\"\r\n 7) \"\\xac\\xed\\x00\\x05t\\x00\\x18session:lastAccessedTime\"\r\n 8) \"\\xac\\xed\\x00\\x05sr\\x00\\x0ejava.lang.Long;\\x8b\\xe4\\x90\\xcc\\x8f#\\xdf\\x02\\x00\\x01J\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\x01\\x80E\\xbeo\\xd8\"\r\n 9) \"\\xac\\xed\\x00\\x05t\\x00\\x18session:thisAccessedTime\"\r\n10) \"\\xac\\xed\\x00\\x05sr\\x00\\x0ejava.lang.Long;\\x8b\\xe4\\x90\\xcc\\x8f#\\xdf\\x02\\x00\\x01J\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\x01\\x80E\\xbeo\\xd8\"\r\n11) \"\\xac\\xed\\x00\\x05t\\x00\\x0btaxonomyIds\"\r\n12) \"\\xac\\xed\\x00\\x05sr\\x000ucles.ccms.nativejava.pojos.taxonomy.TaxonomySet&\\xc8\\xd0\\x9cv\\x1cL\\x97\\x02\\x00\\x01L\\x00\\x0etaxonomyIdsSett\\x00\\x13Ljava/util/HashSet;xpsr\\x00\\x11java.util.HashSet\\xbaD\\x85\\x95\\x96\\xb8\\xb74\\x03\\x00\\x00xpw\\x0c\\x00\\x00\\x00\\x10?@\\x00\\x00\\x00\\x00\\x00\\x01t\\x00$b74c9642-9960-4b31-81d2-681018c2df7ax\"\r\n13) \"\\xac\\xed\\x00\\x05t\\x00\\x14session:creationTime\"\r\n14) \"\\xac\\xed\\x00\\x05sr\\x00\\x0ejava.lang.Long;\\x8b\\xe4\\x90\\xcc\\x8f#\\xdf\\x02\\x00\\x01J\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\x01\\x80E\\xbehg\"\r\n15) \"\\xac\\xed\\x00\\x05t\\x00\\x1bsession:maxInactiveInterval\"\r\n16) \"\\xac\\xed\\x00\\x05sr\\x00\\x11java.lang.Integer\\x12\\xe2\\xa0\\xa4\\xf7\\x81\\x878\\x02\\x00\\x01I\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\a\\b\"\r\n17) \"\\xac\\xed\\x00\\x05t\\x00\\x06ticket\"\r\n18) \"\\xac\\xed\\x00\\x05t\\x03\\x92DM_TICKET=T0JKIE5VTEwgMAoxMwp2ZXJzaW9uIElOVCBTIDAKMwpmbGFncyBJTlQgUyAwCjEKc2VxdWVuY2VfbnVtIElOVCBTIDAKMTA2NApjcmVhdGVfdGltZSBJTlQgUyAwCjE2NTA0Mzc1NDcKZXhwaXJlX3RpbWUgSU5UIFMgMAoxNjUwNDM4NDQ3CmRvbWFpbiBTVFJJTkcgUyAwCkEgNSB1Y2xlcwp1c2VyX25hbWUgU1RSSU5HIFMgMApBIDEzIGNpZUFtQXV0aG9yczEKcGFzc3dvcmQgU1RSSU5HIFMgMApBIDEyOCBETV9FTkNSX1RFWFRfVjI9QUFBQUVJRzY2NU9nMWp4OHpYUHY2MkRyejk3dkNkUFhRdVF3b2ZDajI5RE1sd1BnbmE0V21qVlh2V2VDQ1RSOHBrZHBsaU1aekdhZFNjaEpFRnoxNUNHUlltbkNBeUdkcTdPNWZvUU5PbUhxUCtTRQpkb2NiYXNlX25hbWUgU1RSSU5HIFMgMApBIDE2IGNhZGV2X3NkY2NtYXAwNDQKaG9zdF9uYW1lIFNUUklORyBTIDAKQSAxMCBzZGNjbWFwMDQ0CnNlcnZlcl9uYW1lIFNUUklORyBTIDAKQSAxNiBjYWRldl9zZGNjbWFwMDQ0CnNpZ25hdHVyZV9sZW4gSU5UIFMgMAoxMzYKc2lnbmF0dXJlIFNUUklORyBTIDAKQSAxMzYgQUFBQUVFV2tuSnBRdHpmYm9URy9RUzkzRThTelVjVEl4NmZoeTZ3VDVrNjZ5Y3ZCRTF0Uk92M3FoL0UyTFVmZmRPRys4YTE5TnNJak1yS2N0UVFyWldwamVqVnNzMTVrZ3dUNjVGenlsejY2blN5Skg1RlNIQXUzWFRwclQ5N1BpQ2NUdXc9PQo=\"\r\n19) \"\\xac\\xed\\x00\\x05t\\x00\\x0fsession:isValid\"\r\n20) \"\\xac\\xed\\x00\\x05sr\\x00\\x11java.lang.Boolean\\xcd r\\x80\\xd5\\x9c\\xfa\\xee\\x02\\x00\\x01Z\\x00\\x05valuexp\\x01\"\r\n127.0.0.1:6379>\r\n\r\n\r\n-------------------------------------------------------------------------------------------------------------\r\n\r\nnew format:\r\n\r\n127.0.0.1:6379> hgetall redisson:tomcat_session:CBE6B4414A1B7219EEA6FD8AC6638C88\r\n 1) \"taxonomyIds\"\r\n 2) \"\\xac\\xed\\x00\\x05sr\\x000ucles.ccms.nativejava.pojos.taxonomy.TaxonomySet&\\xc8\\xd0\\x9cv\\x1cL\\x97\\x02\\x00\\x01L\\x00\\x0etaxonomyIdsSett\\x00\\x13Ljava/util/HashSet;xpsr\\x00\\x11java.util.HashSet\\xbaD\\x85\\x95\\x96\\xb8\\xb74\\x03\\x00\\x00xpw\\x0c\\x00\\x00\\x00\\x10?@\\x00\\x00\\x00\\x00\\x00\\x01t\\x00$b74c9642-9960-4b31-81d2-681018c2df7ax\"\r\n 3) \"session:thisAccessedTime\"\r\n 4) \"\\xac\\xed\\x00\\x05sr\\x00\\x0ejava.lang.Long;\\x8b\\xe4\\x90\\xcc\\x8f#\\xdf\\x02\\x00\\x01J\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\x01\\x80E\\xc7\\r\\xc8\"\r\n 5) \"session:lastAccessedTime\"\r\n 6) \"\\xac\\xed\\x00\\x05sr\\x00\\x0ejava.lang.Long;\\x8b\\xe4\\x90\\xcc\\x8f#\\xdf\\x02\\x00\\x01J\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\x01\\x80E\\xc7\\r\\xc8\"\r\n 7) \"businessStream\"\r\n 8) \"\\xac\\xed\\x00\\x05t\\x00\\x03CIE\"\r\n 9) \"user\"\r\n10) \"\\xac\\xed\\x00\\x05sr\\x00'ucles.ccms.nativejava.pojos.user.CAUser\\x0b\\x9b\\xc7a\\x8d\\xaa\\xb0-\\x02\\x00\\aI\\x00\\x15sessionTimeoutSecondsL\\x00\\x0ebusinessStreamt\\x00\\x12Ljava/lang/String;L\\x00\\ncreditorNoq\\x00~\\x00\\x01L\\x00\\x05namest\\x00,Lucles/ccms/nativejava/pojos/user/UserNames;L\\x00\\tpermitSett\\x00.Lucles/ccms/nativejava/pojos/user/CAPermitSet;L\\x00\\x10subordinateNamest\\x00\\x13Ljava/util/HashSet;L\\x00\\x06userIdq\\x00~\\x00\\x01xp\\x00\\x00\\x03\\x84t\\x00\\x03CIEpsr\\x00*ucles.ccms.nativejava.pojos.user.UserNamesp\\x18\\xbb\\x80\\xf0\\xe6L\\xc3\\x02\\x00\\x02L\\x00\\ruserLoginNameq\\x00~\\x00\\x01L\\x00\\buserNameq\\x00~\\x00\\x01xpt\\x00\\x0ecieAmAuthors01t\\x00\\rcieAmAuthors1sr\\x00,ucles.ccms.nativejava.pojos.user.CAPermitSet\\xf3\\xa6\\xde\\xa1&u'\\xd3\\x02\\x00\\x03Z\\x00\\x0bisSuperUserL\\x00\\x10effectivePermitst\\x00\\x15Ljava/util/ArrayList;L\\x00\\x0bsourceRolesq\\x00~\\x00\\x04xp\\x00sr\\x00\\x13java.util.ArrayListx\\x81\\xd2\\x1d\\x99\\xc7a\\x9d\\x03\\x00\\x01I\\x00\\x04sizexp\\x00\\x00\\x00\\rw\\x04\\x00\\x00\\x00\\rsr\\x00)ucles.ccms.nativejava.pojos.user.CAPermitl&\\x0f\\r\\\\\\xbd\\xc5K\\x02\\x00\\x03L\\x00\\x0cachievableIdq\\x00~\\x00\\x01L\\x00\\x0bpermitLevelt\\x000Lucles/ccms/nativejava/pojos/user/CAPermitLevel;L\\x00\\npermitNamet\\x00/Lucles/ccms/nativejava/pojos/user/CAPermitName;xpp~r\\x00.ucles.ccms.nativejava.pojos.user.CAPermitLevel\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xr\\x00\\x0ejava.lang.Enum\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xpt\\x00\\x04READ~r\\x00-ucles.ccms.nativejava.pojos.user.CAPermitName\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xq\\x00~\\x00\\x15t\\x00\\x19LIBRARY_MANAGEMENT_SCREENsq\\x00~\\x00\\x10pq\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x0bTASK_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40~q\\x00~\\x00\\x14t\\x00\\x05WRITE~q\\x00~\\x00\\x18t\\x00\\x0eREPORTS_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00 ~q\\x00~\\x00\\x18t\\x00\\x12ADVANCED_AUTHORINGsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00 ~q\\x00~\\x00\\x18t\\x00\\rSEARCH_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x12ACHIEVABLES_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x0fTAXONOMY_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x19PROJECT_MANAGEMENT_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x18WORKFLOW_TEMPLATE_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\nTCP_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\nTET_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16q\\x00~\\x00\\x19sq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16q\\x00~\\x00\\x1cxsr\\x00\\x11java.util.HashSet\\xbaD\\x85\\x95\\x96\\xb8\\xb74\\x03\\x00\\x00xpw\\x0c\\x00\\x00\\x00\\x10?@\\x00\\x00\\x00\\x00\\x00\\x02~r\\x00(ucles.ccms.nativejava.constants.CcmsRole\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xq\\x00~\\x00\\x15t\\x00\\x06AUTHOR~q\\x00~\\x00Jt\\x00\\x1bASSESSMENT_MATERIAL_MANAGERxpt\\x00\\x1011003039800005b7\"\r\n11) \"ticket\"\r\n12) \"\\xac\\xed\\x00\\x05t\\x03\\x92DM_TICKET=T0JKIE5VTEwgMAoxMwp2ZXJzaW9uIElOVCBTIDAKMwpmbGFncyBJTlQgUyAwCjEKc2VxdWVuY2VfbnVtIElOVCBTIDAKMTA3MgpjcmVhdGVfdGltZSBJTlQgUyAwCjE2NTA0MzgxMTIKZXhwaXJlX3RpbWUgSU5UIFMgMAoxNjUwNDM5MDEyCmRvbWFpbiBTVFJJTkcgUyAwCkEgNSB1Y2xlcwp1c2VyX25hbWUgU1RSSU5HIFMgMApBIDEzIGNpZUFtQXV0aG9yczEKcGFzc3dvcmQgU1RSSU5HIFMgMApBIDEyOCBETV9FTkNSX1RFWFRfVjI9QUFBQUVBWGhrVlFIYWh4SzNFZ0RDWW14RmtpZWg5b2R2dllYZGEzTFMveUJacFZPSm80Y0JOMWJWTmVtcGMrdmlzNm4rSUtlNzRjeWgwRmVkeTd5aS9sRDJLMGMwOXVhWnRNblFGc3hqclEvdE53Ywpkb2NiYXNlX25hbWUgU1RSSU5HIFMgMApBIDE2IGNhZGV2X3NkY2NtYXAwNDQKaG9zdF9uYW1lIFNUUklORyBTIDAKQSAxMCBzZGNjbWFwMDQ0CnNlcnZlcl9uYW1lIFNUUklORyBTIDAKQSAxNiBjYWRldl9zZGNjbWFwMDQ0CnNpZ25hdHVyZV9sZW4gSU5UIFMgMAoxMzYKc2lnbmF0dXJlIFNUUklORyBTIDAKQSAxMzYgQUFBQUVKODNJRzBBYUlRZytBZ2hSdk9MRmxWWmNWOTl1VzJFTjhxOHY5VXY4TTBETk82TzBOSVhHUG1yTXlNdEhvWXYyYVpuc21CVkl5VGpOOW9JY2U0YTc1by96ZGhCMzZSU0d1ajZoMUh6NDJ2aUY1cktCUGMyQ3hJS2lJT003bG9lQ1E9PQo=\"\r\n127.0.0.1:6379>\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4258/comments",
    "author": "arumuk",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-04-23T08:34:44Z",
        "body": "Default codec has changed since 3.13.0 to MarshallingCodec"
      },
      {
        "user": "mrniko",
        "created_at": "2022-04-23T08:35:45Z",
        "body": "Also I would recommend you to use 3.17.0 version."
      },
      {
        "user": "arumuk",
        "created_at": "2022-04-25T14:58:39Z",
        "body": "Hi Nikitha, thanks for your wuick response. But still my issue not resolved.\r\nIn my local redis server version: redis_version:3.2.100\r\nIn my java application: \r\n<dependency>\r\n<groupId>org.redisson</groupId>\r\n<artifactId>redisson</artifactId>\r\n<version>3.16.1</version>\r\n</dependency>\r\ntomcat:\r\nredisson-all-3.16.1\r\nredisson-tomcat-9-3.16.1\r\n\r\nNow i am using  the marshelling codec,\r\nMarshallingCodec  marshallingCodec = new MarshallingCodec();\r\nRMap<String, Object> session =redisson.getMap(\"redisson:tomcat_session:3646D6C449348EC9E275C3D6313FF477\", marshallingCodec);\r\n\r\nStill  I unable to fetch the user details using hte key, but in redis cli, suing hgetall key, i could see the user details.\r\n\r\nKindly help me in this part."
      },
      {
        "user": "arumuk",
        "created_at": "2022-04-25T15:00:59Z",
        "body": "as you said if I am going to use 3.17,  in my java other part of code not working, need to check in details for that, so as of now i am continue to use 3.16. Could you help me why the decoder is not working. thanks.\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2022-04-27T06:06:56Z",
        "body": "Did you clean redis data base for upgrade to 3.17 version? It's required since codec has changed. MarshallingCodec unable to read data stored by FSTCodec."
      }
    ]
  },
  {
    "number": 4253,
    "title": "redisson-all-3.16.1, redisson-tomcat-9-3.16.1 - unable to get value using redisson:tomcat_session  in java code",
    "created_at": "2022-04-21T09:30:24Z",
    "closed_at": "2022-05-10T13:37:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4253",
    "body": "SerializationCodec redisSerializationCodec = new SerializationCodec();\r\nMap<String, Object> session =redisson.getMap(\"redisson:tomcat_session:83C8CA5C1849307884D3683C540C0CDC\", redisSerializationCodec);\r\n\r\nThe above code works fine in redisson-tomcat-8-3.7.5, redisson-all-3.7.5 version in tomcat lib.\r\n\r\nAfter replacing the latest redisson-tomcat-9-3.16.1, redisson-all-3.16.1, the above code not read the value using the key and throw stream exception.\r\n\r\nconfg:\r\n{\r\n   \"singleServerConfig\":{\r\n      \"idleConnectionTimeout\":10000,\r\n      \"pingTimeout\":1000,\r\n      \"connectTimeout\":10000,\r\n      \"timeout\":3000,\r\n      \"retryAttempts\":3,\r\n      \"retryInterval\":1500,\r\n      \"reconnectionTimeout\":3000,\r\n      \"failedAttempts\":3,\r\n      \"password\":null,\r\n      \"subscriptionsPerConnection\":5,\r\n      \"clientName\":null,\r\n      \"address\": \"redis://127.0.0.1:6379\",\r\n      \"subscriptionConnectionMinimumIdleSize\":1,\r\n      \"subscriptionConnectionPoolSize\":50,\r\n      \"connectionMinimumIdleSize\":32,\r\n      \"connectionPoolSize\":64,\r\n      \"database\":0\r\n   },\r\n  \"threads\":0,\r\n   \"nettyThreads\":0,\r\n   \"codec\":{   \r\n   \"class\":\"org.redisson.codec.SerializationCodec\"   \r\n   }\r\n}\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4253/comments",
    "author": "arumuk",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-04-21T10:43:53Z",
        "body": "Can you share full stacktrace of the exception?"
      },
      {
        "user": "arumuk",
        "created_at": "2022-04-21T11:35:16Z",
        "body": "thanks for your quick reply 👍 \r\n****using old jar, the  data save in redis in below format:**\r\n127.0.0.1:6379> hgetall redisson:tomcat_session:05341D84D5470264E9C8129CBB6A3758\r\n 1) \"\\xac\\xed\\x00\\x05t\\x00\\x0ebusinessStream\"\r\n 2) \"\\xac\\xed\\x00\\x05t\\x00\\x03CIE\"\r\n 3) \"\\xac\\xed\\x00\\x05t\\x00\\rsession:isNew\"\r\n 4) \"\\xac\\xed\\x00\\x05sr\\x00\\x11java.lang.Boolean\\xcd r\\x80\\xd5\\x9c\\xfa\\xee\\x02\\x00\\x01Z\\x00\\x05valuexp\\x00\"\r\n 5) \"\\xac\\xed\\x00\\x05t\\x00\\x04user\"\r\n 6) \"\\xac\\xed\\x00\\x05sr\\x00'ucles.ccms.nativejava.pojos.user.CAUser\\x0b\\x9b\\xc7a\\x8d\\xaa\\xb0-\\x02\\x00\\aI\\x00\\x15sessionTimeoutSecondsL\\x00\\x0ebusinessStreamt\\x00\\x12Ljava/lang/String;L\\x00\\ncreditorNoq\\x00~\\x00\\x01L\\x00\\x05namest\\x00,Lucles/ccms/nativejava/pojos/user/UserNames;L\\x00\\tpermitSett\\x00.Lucles/ccms/nativejava/pojos/user/CAPermitSet;L\\x00\\x10subordinateNamest\\x00\\x13Ljava/util/HashSet;L\\x00\\x06userIdq\\x00~\\x00\\x01xp\\x00\\x00\\x03\\x84t\\x00\\x03CIEpsr\\x00*ucles.ccms.nativejava.pojos.user.UserNamesp\\x18\\xbb\\x80\\xf0\\xe6L\\xc3\\x02\\x00\\x02L\\x00\\ruserLoginNameq\\x00~\\x00\\x01L\\x00\\buserNameq\\x00~\\x00\\x01xpt\\x00\\x0ecieAmAuthors01t\\x00\\rcieAmAuthors1sr\\x00,ucles.ccms.nativejava.pojos.user.CAPermitSet\\xf3\\xa6\\xde\\xa1&u'\\xd3\\x02\\x00\\x03Z\\x00\\x0bisSuperUserL\\x00\\x10effectivePermitst\\x00\\x15Ljava/util/ArrayList;L\\x00\\x0bsourceRolesq\\x00~\\x00\\x04xp\\x00sr\\x00\\x13java.util.ArrayListx\\x81\\xd2\\x1d\\x99\\xc7a\\x9d\\x03\\x00\\x01I\\x00\\x04sizexp\\x00\\x00\\x00\\rw\\x04\\x00\\x00\\x00\\rsr\\x00)ucles.ccms.nativejava.pojos.user.CAPermitl&\\x0f\\r\\\\\\xbd\\xc5K\\x02\\x00\\x03L\\x00\\x0cachievableIdq\\x00~\\x00\\x01L\\x00\\x0bpermitLevelt\\x000Lucles/ccms/nativejava/pojos/user/CAPermitLevel;L\\x00\\npermitNamet\\x00/Lucles/ccms/nativejava/pojos/user/CAPermitName;xpp~r\\x00.ucles.ccms.nativejava.pojos.user.CAPermitLevel\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xr\\x00\\x0ejava.lang.Enum\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xpt\\x00\\x04READ~r\\x00-ucles.ccms.nativejava.pojos.user.CAPermitName\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xq\\x00~\\x00\\x15t\\x00\\x19LIBRARY_MANAGEMENT_SCREENsq\\x00~\\x00\\x10pq\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x0bTASK_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40~q\\x00~\\x00\\x14t\\x00\\x05WRITE~q\\x00~\\x00\\x18t\\x00\\x0eREPORTS_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00 ~q\\x00~\\x00\\x18t\\x00\\x12ADVANCED_AUTHORINGsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00 ~q\\x00~\\x00\\x18t\\x00\\rSEARCH_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x12ACHIEVABLES_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x0fTAXONOMY_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x19PROJECT_MANAGEMENT_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x18WORKFLOW_TEMPLATE_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\nTCP_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\nTET_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16q\\x00~\\x00\\x19sq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16q\\x00~\\x00\\x1cxsr\\x00\\x11java.util.HashSet\\xbaD\\x85\\x95\\x96\\xb8\\xb74\\x03\\x00\\x00xpw\\x0c\\x00\\x00\\x00\\x10?@\\x00\\x00\\x00\\x00\\x00\\x02~r\\x00(ucles.ccms.nativejava.constants.CcmsRole\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xq\\x00~\\x00\\x15t\\x00\\x1bASSESSMENT_MATERIAL_MANAGER~q\\x00~\\x00Jt\\x00\\x06AUTHORxpt\\x00\\x1011003039800005b7\"\r\n 7) \"\\xac\\xed\\x00\\x05t\\x00\\x18session:lastAccessedTime\"\r\n 8) \"\\xac\\xed\\x00\\x05sr\\x00\\x0ejava.lang.Long;\\x8b\\xe4\\x90\\xcc\\x8f#\\xdf\\x02\\x00\\x01J\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\x01\\x80E\\xbeo\\xd8\"\r\n 9) \"\\xac\\xed\\x00\\x05t\\x00\\x18session:thisAccessedTime\"\r\n10) \"\\xac\\xed\\x00\\x05sr\\x00\\x0ejava.lang.Long;\\x8b\\xe4\\x90\\xcc\\x8f#\\xdf\\x02\\x00\\x01J\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\x01\\x80E\\xbeo\\xd8\"\r\n11) \"\\xac\\xed\\x00\\x05t\\x00\\x0btaxonomyIds\"\r\n12) \"\\xac\\xed\\x00\\x05sr\\x000ucles.ccms.nativejava.pojos.taxonomy.TaxonomySet&\\xc8\\xd0\\x9cv\\x1cL\\x97\\x02\\x00\\x01L\\x00\\x0etaxonomyIdsSett\\x00\\x13Ljava/util/HashSet;xpsr\\x00\\x11java.util.HashSet\\xbaD\\x85\\x95\\x96\\xb8\\xb74\\x03\\x00\\x00xpw\\x0c\\x00\\x00\\x00\\x10?@\\x00\\x00\\x00\\x00\\x00\\x01t\\x00$b74c9642-9960-4b31-81d2-681018c2df7ax\"\r\n13) \"\\xac\\xed\\x00\\x05t\\x00\\x14session:creationTime\"\r\n14) \"\\xac\\xed\\x00\\x05sr\\x00\\x0ejava.lang.Long;\\x8b\\xe4\\x90\\xcc\\x8f#\\xdf\\x02\\x00\\x01J\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\x01\\x80E\\xbehg\"\r\n15) \"\\xac\\xed\\x00\\x05t\\x00\\x1bsession:maxInactiveInterval\"\r\n16) \"\\xac\\xed\\x00\\x05sr\\x00\\x11java.lang.Integer\\x12\\xe2\\xa0\\xa4\\xf7\\x81\\x878\\x02\\x00\\x01I\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\a\\b\"\r\n17) \"\\xac\\xed\\x00\\x05t\\x00\\x06ticket\"\r\n18) \"\\xac\\xed\\x00\\x05t\\x03\\x92DM_TICKET=T0JKIE5VTEwgMAoxMwp2ZXJzaW9uIElOVCBTIDAKMwpmbGFncyBJTlQgUyAwCjEKc2VxdWVuY2VfbnVtIElOVCBTIDAKMTA2NApjcmVhdGVfdGltZSBJTlQgUyAwCjE2NTA0Mzc1NDcKZXhwaXJlX3RpbWUgSU5UIFMgMAoxNjUwNDM4NDQ3CmRvbWFpbiBTVFJJTkcgUyAwCkEgNSB1Y2xlcwp1c2VyX25hbWUgU1RSSU5HIFMgMApBIDEzIGNpZUFtQXV0aG9yczEKcGFzc3dvcmQgU1RSSU5HIFMgMApBIDEyOCBETV9FTkNSX1RFWFRfVjI9QUFBQUVJRzY2NU9nMWp4OHpYUHY2MkRyejk3dkNkUFhRdVF3b2ZDajI5RE1sd1BnbmE0V21qVlh2V2VDQ1RSOHBrZHBsaU1aekdhZFNjaEpFRnoxNUNHUlltbkNBeUdkcTdPNWZvUU5PbUhxUCtTRQpkb2NiYXNlX25hbWUgU1RSSU5HIFMgMApBIDE2IGNhZGV2X3NkY2NtYXAwNDQKaG9zdF9uYW1lIFNUUklORyBTIDAKQSAxMCBzZGNjbWFwMDQ0CnNlcnZlcl9uYW1lIFNUUklORyBTIDAKQSAxNiBjYWRldl9zZGNjbWFwMDQ0CnNpZ25hdHVyZV9sZW4gSU5UIFMgMAoxMzYKc2lnbmF0dXJlIFNUUklORyBTIDAKQSAxMzYgQUFBQUVFV2tuSnBRdHpmYm9URy9RUzkzRThTelVjVEl4NmZoeTZ3VDVrNjZ5Y3ZCRTF0Uk92M3FoL0UyTFVmZmRPRys4YTE5TnNJak1yS2N0UVFyWldwamVqVnNzMTVrZ3dUNjVGenlsejY2blN5Skg1RlNIQXUzWFRwclQ5N1BpQ2NUdXc9PQo=\"\r\n19) \"\\xac\\xed\\x00\\x05t\\x00\\x0fsession:isValid\"\r\n20) \"\\xac\\xed\\x00\\x05sr\\x00\\x11java.lang.Boolean\\xcd r\\x80\\xd5\\x9c\\xfa\\xee\\x02\\x00\\x01Z\\x00\\x05valuexp\\x01\"\r\n127.0.0.1:6379>\r\n\r\n\r\nusing new jar, the  same data save in redis in different format:\r\n\r\n127.0.0.1:6379> hgetall redisson:tomcat_session:CBE6B4414A1B7219EEA6FD8AC6638C88\r\n 1) \"taxonomyIds\"\r\n 2) \"\\xac\\xed\\x00\\x05sr\\x000ucles.ccms.nativejava.pojos.taxonomy.TaxonomySet&\\xc8\\xd0\\x9cv\\x1cL\\x97\\x02\\x00\\x01L\\x00\\x0etaxonomyIdsSett\\x00\\x13Ljava/util/HashSet;xpsr\\x00\\x11java.util.HashSet\\xbaD\\x85\\x95\\x96\\xb8\\xb74\\x03\\x00\\x00xpw\\x0c\\x00\\x00\\x00\\x10?@\\x00\\x00\\x00\\x00\\x00\\x01t\\x00$b74c9642-9960-4b31-81d2-681018c2df7ax\"\r\n 3) \"session:thisAccessedTime\"\r\n 4) \"\\xac\\xed\\x00\\x05sr\\x00\\x0ejava.lang.Long;\\x8b\\xe4\\x90\\xcc\\x8f#\\xdf\\x02\\x00\\x01J\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\x01\\x80E\\xc7\\r\\xc8\"\r\n 5) \"session:lastAccessedTime\"\r\n 6) \"\\xac\\xed\\x00\\x05sr\\x00\\x0ejava.lang.Long;\\x8b\\xe4\\x90\\xcc\\x8f#\\xdf\\x02\\x00\\x01J\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\x01\\x80E\\xc7\\r\\xc8\"\r\n 7) \"businessStream\"\r\n 8) \"\\xac\\xed\\x00\\x05t\\x00\\x03CIE\"\r\n 9) \"user\"\r\n10) \"\\xac\\xed\\x00\\x05sr\\x00'ucles.ccms.nativejava.pojos.user.CAUser\\x0b\\x9b\\xc7a\\x8d\\xaa\\xb0-\\x02\\x00\\aI\\x00\\x15sessionTimeoutSecondsL\\x00\\x0ebusinessStreamt\\x00\\x12Ljava/lang/String;L\\x00\\ncreditorNoq\\x00~\\x00\\x01L\\x00\\x05namest\\x00,Lucles/ccms/nativejava/pojos/user/UserNames;L\\x00\\tpermitSett\\x00.Lucles/ccms/nativejava/pojos/user/CAPermitSet;L\\x00\\x10subordinateNamest\\x00\\x13Ljava/util/HashSet;L\\x00\\x06userIdq\\x00~\\x00\\x01xp\\x00\\x00\\x03\\x84t\\x00\\x03CIEpsr\\x00*ucles.ccms.nativejava.pojos.user.UserNamesp\\x18\\xbb\\x80\\xf0\\xe6L\\xc3\\x02\\x00\\x02L\\x00\\ruserLoginNameq\\x00~\\x00\\x01L\\x00\\buserNameq\\x00~\\x00\\x01xpt\\x00\\x0ecieAmAuthors01t\\x00\\rcieAmAuthors1sr\\x00,ucles.ccms.nativejava.pojos.user.CAPermitSet\\xf3\\xa6\\xde\\xa1&u'\\xd3\\x02\\x00\\x03Z\\x00\\x0bisSuperUserL\\x00\\x10effectivePermitst\\x00\\x15Ljava/util/ArrayList;L\\x00\\x0bsourceRolesq\\x00~\\x00\\x04xp\\x00sr\\x00\\x13java.util.ArrayListx\\x81\\xd2\\x1d\\x99\\xc7a\\x9d\\x03\\x00\\x01I\\x00\\x04sizexp\\x00\\x00\\x00\\rw\\x04\\x00\\x00\\x00\\rsr\\x00)ucles.ccms.nativejava.pojos.user.CAPermitl&\\x0f\\r\\\\\\xbd\\xc5K\\x02\\x00\\x03L\\x00\\x0cachievableIdq\\x00~\\x00\\x01L\\x00\\x0bpermitLevelt\\x000Lucles/ccms/nativejava/pojos/user/CAPermitLevel;L\\x00\\npermitNamet\\x00/Lucles/ccms/nativejava/pojos/user/CAPermitName;xpp~r\\x00.ucles.ccms.nativejava.pojos.user.CAPermitLevel\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xr\\x00\\x0ejava.lang.Enum\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xpt\\x00\\x04READ~r\\x00-ucles.ccms.nativejava.pojos.user.CAPermitName\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xq\\x00~\\x00\\x15t\\x00\\x19LIBRARY_MANAGEMENT_SCREENsq\\x00~\\x00\\x10pq\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x0bTASK_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40~q\\x00~\\x00\\x14t\\x00\\x05WRITE~q\\x00~\\x00\\x18t\\x00\\x0eREPORTS_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00 ~q\\x00~\\x00\\x18t\\x00\\x12ADVANCED_AUTHORINGsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00 ~q\\x00~\\x00\\x18t\\x00\\rSEARCH_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x12ACHIEVABLES_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x0fTAXONOMY_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x19PROJECT_MANAGEMENT_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\x18WORKFLOW_TEMPLATE_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\nTCP_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16~q\\x00~\\x00\\x18t\\x00\\nTET_SCREENsq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16q\\x00~\\x00\\x19sq\\x00~\\x00\\x10t\\x00\\x141--g-kkxyinao-b31f40q\\x00~\\x00\\x16q\\x00~\\x00\\x1cxsr\\x00\\x11java.util.HashSet\\xbaD\\x85\\x95\\x96\\xb8\\xb74\\x03\\x00\\x00xpw\\x0c\\x00\\x00\\x00\\x10?@\\x00\\x00\\x00\\x00\\x00\\x02~r\\x00(ucles.ccms.nativejava.constants.CcmsRole\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00xq\\x00~\\x00\\x15t\\x00\\x06AUTHOR~q\\x00~\\x00Jt\\x00\\x1bASSESSMENT_MATERIAL_MANAGERxpt\\x00\\x1011003039800005b7\"\r\n11) \"ticket\"\r\n12) \"\\xac\\xed\\x00\\x05t\\x03\\x92DM_TICKET=T0JKIE5VTEwgMAoxMwp2ZXJzaW9uIElOVCBTIDAKMwpmbGFncyBJTlQgUyAwCjEKc2VxdWVuY2VfbnVtIElOVCBTIDAKMTA3MgpjcmVhdGVfdGltZSBJTlQgUyAwCjE2NTA0MzgxMTIKZXhwaXJlX3RpbWUgSU5UIFMgMAoxNjUwNDM5MDEyCmRvbWFpbiBTVFJJTkcgUyAwCkEgNSB1Y2xlcwp1c2VyX25hbWUgU1RSSU5HIFMgMApBIDEzIGNpZUFtQXV0aG9yczEKcGFzc3dvcmQgU1RSSU5HIFMgMApBIDEyOCBETV9FTkNSX1RFWFRfVjI9QUFBQUVBWGhrVlFIYWh4SzNFZ0RDWW14RmtpZWg5b2R2dllYZGEzTFMveUJacFZPSm80Y0JOMWJWTmVtcGMrdmlzNm4rSUtlNzRjeWgwRmVkeTd5aS9sRDJLMGMwOXVhWnRNblFGc3hqclEvdE53Ywpkb2NiYXNlX25hbWUgU1RSSU5HIFMgMApBIDE2IGNhZGV2X3NkY2NtYXAwNDQKaG9zdF9uYW1lIFNUUklORyBTIDAKQSAxMCBzZGNjbWFwMDQ0CnNlcnZlcl9uYW1lIFNUUklORyBTIDAKQSAxNiBjYWRldl9zZGNjbWFwMDQ0CnNpZ25hdHVyZV9sZW4gSU5UIFMgMAoxMzYKc2lnbmF0dXJlIFNUUklORyBTIDAKQSAxMzYgQUFBQUVKODNJRzBBYUlRZytBZ2hSdk9MRmxWWmNWOTl1VzJFTjhxOHY5VXY4TTBETk82TzBOSVhHUG1yTXlNdEhvWXYyYVpuc21CVkl5VGpOOW9JY2U0YTc1by96ZGhCMzZSU0d1ajZoMUh6NDJ2aUY1cktCUGMyQ3hJS2lJT003bG9lQ1E9PQo=\"\r\n127.0.0.1:6379>\r\n\r\n-------------------------------------------------------------------------------------------------\r\nRMap<String, Object> session =redisson.getMap(\"redisson:tomcat_session:4899CC5C803FE9816ADF64105A895440\", redisSerializationCodec);\r\nif (session.get(\"user\") != null) { }\r\n\r\nif the data is saved as in first format, I got user details.\r\nIf the data is saved in second format , user data unable to fetch, and exception occurs in debug mode,\r\n\r\nNote: The excpetion occurs in debug mode , not all time. now i unable to generate the exception. but there is no outcome\r\n\r\n"
      },
      {
        "user": "arumuk",
        "created_at": "2022-04-21T13:05:13Z",
        "body": "14:03:44.392 [main] ERROR org.redisson.config.Config - JSON configuration is deprecated and will be removed in future!\r\n14:03:44.408 [main] ERROR org.redisson.config.Config - JSON configuration is deprecated and will be removed in future!\r\n14:04:32.238 [redisson-netty-2-2] ERROR org.redisson.client.handler.CommandDecoder - Unable to decode data. channel: [id: 0xdee8d4f3, L:/127.0.0.1:56557 - R:127.0.0.1/127.0.0.1:6379], reply: ReplayingDecoderByteBuf(ridx=35, widx=2805), command: (HSCAN), params: [redisson:tomcat_session:DFDE820966D594986AC74125964FC71E, 0, COUNT, 10]\r\njava.io.StreamCorruptedException: invalid stream header: 7461786F\r\n\tat java.io.ObjectInputStream.readStreamHeader(ObjectInputStream.java:866) ~[?:1.8.0_202]\r\n\tat java.io.ObjectInputStream.<init>(ObjectInputStream.java:358) ~[?:1.8.0_202]\r\n\tat org.redisson.codec.CustomObjectInputStream.<init>(CustomObjectInputStream.java:36) ~[redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:54) ~[redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:366) ~[redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:410) ~[redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:375) ~[redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:410) ~[redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:375) ~[redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:183) [redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122) [redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:107) [redisson-3.16.1.jar:3.16.1]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507) [netty-codec-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) [netty-codec-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) [netty-codec-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) [netty-common-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.66.Final.jar:4.1.66.Final]\r\n\tat java.lang.Thread.run(Thread.java:748) [?:1.8.0_202]\r\n"
      },
      {
        "user": "arumuk",
        "created_at": "2022-04-21T13:24:01Z",
        "body": "> Can you share full stacktrace of the exception?\r\n\r\n14:03:44.392 [main] ERROR org.redisson.config.Config - JSON configuration is deprecated and will be removed in future!\r\n14:03:44.408 [main] ERROR org.redisson.config.Config - JSON configuration is deprecated and will be removed in future!\r\n14:04:32.238 [redisson-netty-2-2] ERROR org.redisson.client.handler.CommandDecoder - Unable to decode data. channel: [id: 0xdee8d4f3, L:/127.0.0.1:56557 - R:127.0.0.1/127.0.0.1:6379], reply: ReplayingDecoderByteBuf(ridx=35, widx=2805), command: (HSCAN), params: [redisson:tomcat_session:DFDE820966D594986AC74125964FC71E, 0, COUNT, 10]\r\njava.io.StreamCorruptedException: invalid stream header: 7461786F\r\n\tat java.io.ObjectInputStream.readStreamHeader(ObjectInputStream.java:866) ~[?:1.8.0_202]\r\n\tat java.io.ObjectInputStream.<init>(ObjectInputStream.java:358) ~[?:1.8.0_202]\r\n\tat org.redisson.codec.CustomObjectInputStream.<init>(CustomObjectInputStream.java:36) ~[redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:54) ~[redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:366) ~[redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:410) ~[redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:375) ~[redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:410) ~[redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:375) ~[redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:183) [redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122) [redisson-3.16.1.jar:3.16.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:107) [redisson-3.16.1.jar:3.16.1]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507) [netty-codec-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) [netty-codec-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) [netty-codec-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) [netty-transport-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) [netty-common-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.66.Final.jar:4.1.66.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.66.Final.jar:4.1.66.Final]\r\n\tat java.lang.Thread.run(Thread.java:748) [?:1.8.0_202]\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2022-05-10T13:36:10Z",
        "body": "Tomcat Session attribute names encoding has changed since 3.10.1 version. They all are stored as plain string. So you can't redisson-tomcat-8-3.7.5 and redisson-tomcat-9-3.16.1 in the same cluster."
      }
    ]
  },
  {
    "number": 4244,
    "title": " command: (EXISTS)  java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Long",
    "created_at": "2022-04-19T08:24:16Z",
    "closed_at": "2022-04-19T09:58:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4244",
    "body": "2022-04-19 00:04:56,518 ERROR [redisson-netty-2-1] org.redisson.client.handler.CommandDecoder: Unable to decode data. channel: [id: 0xd17c82a2, L:/172.xx.xx.xx:37059 - R:172.xx.xx.xx/172.xx.xx.xx:8881], reply: ReplayingDecoderByteBuf(ridx=28, widx=28), command: (EXISTS), params: [QualityItem|xxxx]\r\njava.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Long\r\n\tat org.redisson.client.protocol.convertor.BooleanAmountReplayConvertor.convert(BooleanAmountReplayConvertor.java:27)\r\n\tat org.redisson.client.protocol.convertor.BooleanAmountReplayConvertor.convert(BooleanAmountReplayConvertor.java:23)\r\n\tat org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:432)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:368)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:410)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:375)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:183)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:107)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n2022-04-19 00:04:56,639 ERROR [redisson-netty-2-1] org.redisson.client.handler.ErrorsLoggingHandler: Exception occured. Channel: [id: 0xd17c82a2, L:/172.xx.xx.xx:37059 - R:172.xx.xx.xx/172.xx.xx.xx:8881]\r\nio.netty.handler.codec.DecoderException: java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Long\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Long\r\n\tat org.redisson.client.protocol.convertor.BooleanAmountReplayConvertor.convert(BooleanAmountReplayConvertor.java:27)\r\n\tat org.redisson.client.protocol.convertor.BooleanAmountReplayConvertor.convert(BooleanAmountReplayConvertor.java:23)\r\n\tat org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:432)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:368)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:410)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:375)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:183)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:107)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\t... 17 more",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4244/comments",
    "author": "chengjungao",
    "comments": [
      {
        "user": "chengjungao",
        "created_at": "2022-04-19T08:25:38Z",
        "body": "Redisson Version： 3.16.2\r\nRedis Cluster ：6.2.4"
      },
      {
        "user": "chengjungao",
        "created_at": "2022-04-19T08:40:58Z",
        "body": "I have String Key: xxx , value is Integer ;  but I  get the key  by redisson , got error : java.lang.NumberFormatException: For input string: \"PONG\""
      },
      {
        "user": "chengjungao",
        "created_at": "2022-04-19T08:47:38Z",
        "body": "This is an accidental phenomenon"
      },
      {
        "user": "mrniko",
        "created_at": "2022-04-19T09:57:38Z",
        "body": "@chengjungao \r\n\r\n3.16.4 version has a bug fix - ping command sent for used connection. Please update to the latest version - 3.17.0"
      }
    ]
  },
  {
    "number": 4233,
    "title": "Poor performance of RPriorityBlockingQueue",
    "created_at": "2022-04-14T11:48:13Z",
    "closed_at": "2022-09-05T05:27:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4233",
    "body": "We are using a `RPriorityBlockingQueue` as our core task storage. Tasks are added and pulled by several worker instances simultaneously. Tasks are prioritized, i.e. they have a comparator that determines their order in the queue. The queue will regularly increase to a size around 100000 elements.\r\n\r\nWe noticed that the performance of adding elements is quite poor in general. For instance, adding 50000 elements to the queue takes around 4 minutes, while adding the same number of elements to a `RBlockingQueue` only takes about 5 seconds.\r\n\r\nWe recognize that the underlying Redis data structure is a list, and you have to do a binary search on each insert, which is O(log n). However, 4 minutes for 50000 elements seems _really slow_ even if you have to do a binary search.\r\n\r\nIs such a poor performance expected? Can we improve the performance somehow? Are there better-performing alternatives to a `RPriorityBlockingQueue`?\r\nThis is quite a showstopper for us at the moment, as the queue processing takes far too much time compared with the actual processing of the tasks.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4233/comments",
    "author": "janrieke",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-09-05T05:26:44Z",
        "body": "> Is such a poor performance expected? Can we improve the performance somehow? Are there better-performing alternatives to a RPriorityBlockingQueue?\r\n\r\nThat's expected performance for binary search. I don't see any better alternatives for now."
      },
      {
        "user": "mrniko",
        "created_at": "2022-09-05T05:27:46Z",
        "body": "As option you can try RScoredSortedSet. It also has pollFirst() and pollLast() methods."
      }
    ]
  },
  {
    "number": 4228,
    "title": "version:3.13.6 redisClient.get error Failed to submit a listener notification task. Event loop shut down?",
    "created_at": "2022-04-13T03:50:54Z",
    "closed_at": "2022-04-18T06:31:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4228",
    "body": "redisson (version 3.13.6) \r\n2022-04-13 11:20:37.616 [<10386682678285824><0>] ERROR 7294 {magenta} --- [ol-16-worker-12] i.n.u.c.D.rejectedExecution              : Failed to submit a listener notification task. Event loop shut down?\r\n\r\njava.util.concurrent.RejectedExecutionException: event executor terminated\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor.reject(SingleThreadEventExecutor.java:926) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor.offerTask(SingleThreadEventExecutor.java:353) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor.addTask(SingleThreadEventExecutor.java:346) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor.execute(SingleThreadEventExecutor.java:828) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor.execute(SingleThreadEventExecutor.java:818) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.DefaultPromise.safeExecute(DefaultPromise.java:842) [netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:499) [netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184) [netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.channel.DefaultChannelPromise.addListener(DefaultChannelPromise.java:95) [netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.channel.DefaultChannelPromise.addListener(DefaultChannelPromise.java:30) [netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at org.redisson.command.RedisExecutor.lambda$execute$2(RedisExecutor.java:153) [redisson-3.13.6.jar!/:3.13.6]\r\n        at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187) ~[redisson-3.13.6.jar!/:3.13.6]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) [netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552) [netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) [netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184) [netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181) ~[redisson-3.13.6.jar!/:3.13.6]\r\n        at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:139) [redisson-3.13.6.jar!/:3.13.6]\r\n        at org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:605) ~[redisson-3.13.6.jar!/:3.13.6]\r\n        at org.redisson.command.CommandAsyncService.readAsync(CommandAsyncService.java:368) ~[redisson-3.13.6.jar!/:3.13.6]\r\n        at org.redisson.RedissonBucket.getAsync(RedissonBucket.java:109) ~[redisson-3.13.6.jar!/:3.13.6]\r\n        at org.redisson.RedissonBucket.get(RedissonBucket.java:104) ~[redisson-3.13.6.jar!/:3.13.6]\r\n        at com.vchangyi.boot.redis.client.RedisClient.get(RedisClient.java:109) ~[spring-micro-component-redis-1.0.0-RC2.jar!/:na]\r\n        at com.wuxianji.scrm.analysis.qy.impl.QyRemoteService.getAccessToken(QyRemoteService.java:179) ~[scrm-analysis-service-1.0-SNAPSHOT.jar!/:na]\r\n        at com.wuxianji.scrm.analysis.qy.impl.QyRemoteService.sendRequest(QyRemoteService.java:227) ~[scrm-analysis-service-1.0-SNAPSHOT.jar!/:na]\r\n        at com.wuxianji.scrm.analysis.qy.impl.QyRemoteService.executeNormal(QyRemoteService.java:169) ~[scrm-analysis-service-1.0-SNAPSHOT.jar!/:na]\r\n        at sun.reflect.GeneratedMethodAccessor566.invoke(Unknown Source) ~[na:na]\r\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_202]\r\n        at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_202]\r\n        at org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:282) ~[spring-core-5.2.15.RELEASE.jar!/:5.2.15.RELEASE]\r\n        at org.springframework.cloud.context.scope.GenericScope$LockedScopedProxyFactoryBean.invoke(GenericScope.java:499) ~[spring-cloud-context-2.2.9.RELEASE.jar!/:2.2.9.RELEASE]\r\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.15.RELEASE.jar!/:5.2.15.RELEASE]\r\n        at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:750) ~[spring-aop-5.2.15.RELEASE.jar!/:5.2.15.RELEASE]\r\n        at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:692) ~[spring-aop-5.2.15.RELEASE.jar!/:5.2.15.RELEASE]\r\n        at com.wuxianji.scrm.analysis.qy.impl.QyRemoteService$$EnhancerBySpringCGLIB$$bb9234e2.executeNormal(<generated>) ~[scrm-analysis-service-1.0-SNAPSHOT.jar!/:na]\r\n        at com.wuxianji.scrm.analysis.qy.impl.StatisticsServiceImpl.getUserBehavior(StatisticsServiceImpl.java:38) ~[scrm-analysis-service-1.0-SNAPSHOT.jar!/:na]\r\n        at com.wuxianji.scrm.analysis.shcedule.MembersEveryDayStatisticsTaskJob.getUserBehavior(MembersEveryDayStatisticsTaskJob.java:623) ~[scrm-analysis-service-1.0-SNAPSHOT.jar!/:na]\r\n        at com.wuxianji.scrm.analysis.shcedule.MembersEveryDayStatisticsTaskJob.lambda$getData$4(MembersEveryDayStatisticsTaskJob.java:281) ~[scrm-analysis-service-1.0-SNAPSHOT.jar!/:na]\r\n        at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) ~[na:1.8.0_202]\r\n        at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382) ~[na:1.8.0_202]\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) ~[na:1.8.0_202]\r\n        at java.util.stream.ForEachOps$ForEachTask.compute(ForEachOps.java:291) ~[na:1.8.0_202]\r\n        at java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:731) ~[na:1.8.0_202]\r\n        at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289) ~[na:1.8.0_202]\r\n        at java.util.concurrent.ForkJoinPool.helpComplete(ForkJoinPool.java:1870) ~[na:1.8.0_202]\r\n        at java.util.concurrent.ForkJoinPool.awaitJoin(ForkJoinPool.java:2045) ~[na:1.8.0_202]\r\n        at java.util.concurrent.ForkJoinTask.doInvoke(ForkJoinTask.java:404) ~[na:1.8.0_202]\r\n        at java.util.concurrent.ForkJoinTask.invoke(ForkJoinTask.java:734) ~[na:1.8.0_202]\r\n        at java.util.stream.ForEachOps$ForEachOp.evaluateParallel(ForEachOps.java:160) ~[na:1.8.0_202]\r\n        at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateParallel(ForEachOps.java:174) ~[na:1.8.0_202]\r\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:233) ~[na:1.8.0_202]\r\n        at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) ~[na:1.8.0_202]\r\n        at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:583) ~[na:1.8.0_202]\r\n        at com.wuxianji.scrm.analysis.shcedule.MembersEveryDayStatisticsTaskJob.getData(MembersEveryDayStatisticsTaskJob.java:265) ~[scrm-analysis-service-1.0-SNAPSHOT.jar!/:na]\r\n        at com.wuxianji.scrm.analysis.shcedule.MembersEveryDayStatisticsTaskJob.lambda$null$2(MembersEveryDayStatisticsTaskJob.java:247) ~[scrm-analysis-service-1.0-SNAPSHOT.jar!/:na]\r\n        at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) ~[na:1.8.0_202]\r\n        at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382) ~[na:1.8.0_202]\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) ~[na:1.8.0_202]\r\n        at java.util.stream.ForEachOps$ForEachTask.compute(ForEachOps.java:291) ~[na:1.8.0_202]\r\n        at java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:731) ~[na:1.8.0_202]\r\n        at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289) ~[na:1.8.0_202]\r\n        at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056) ~[na:1.8.0_202]\r\n        at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692) ~[na:1.8.0_202]\r\n        at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157) ~[na:1.8.0_202]",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4228/comments",
    "author": "TA961215",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-04-15T06:31:42Z",
        "body": "Check if you don't shutdown Redisson instance. Can you share test code to reproduce?"
      },
      {
        "user": "afoxsss",
        "created_at": "2023-03-28T08:20:59Z",
        "body": "你好我想问一下这个问题你解决了吗"
      }
    ]
  },
  {
    "number": 4227,
    "title": "RedissonLock.unlock",
    "created_at": "2022-04-12T11:26:53Z",
    "closed_at": "2022-04-14T06:36:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4227",
    "body": "redisson-all-3.16.1 After the version\r\nWe have a lock on the line that has not been released\r\n\r\nerror log\r\njava.lang.IllegalStateException: Sync methods can't be invoked from async/rx/reactive listeners\r\n\tat org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:108)\r\n\tat org.redisson.RedissonObject.get(RedissonObject.java:82)\r\n\tat org.redisson.RedissonLock.unlock(RedissonLock.java:306)\r\n\r\njava.lang.IllegalStateException: Sync methods can't be invoked from async/rx/reactive listeners\r\n\tat org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:108)\r\n\tat org.redisson.RedissonObject.get(RedissonObject.java:82)\r\n\tat org.redisson.RedissonLock.tryAcquire(RedissonLock.java:143)\r\n\tat org.redisson.RedissonLock.lock(RedissonLock.java:97)\r\n\tat org.redisson.RedissonLock.lock(RedissonLock.java:69)\r\n\r\n\r\n3.12.1  version\r\n  @Override\r\n    public <V> V get(RFuture<V> future) {\r\n        try {\r\n            future.await();\r\n        } catch (InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n        if (future.isSuccess()) {\r\n            return future.getNow();\r\n        }\r\n\r\n        throw convertException(future);\r\n    }\r\n    \r\n3.16.1\r\n@Override\r\n    public <V> V get(RFuture<V> future) {\r\n        if (Thread.currentThread().getName().startsWith(\"redisson-netty\")) {\r\n            throw new IllegalStateException(\"Sync methods can't be invoked from async/rx/reactive listeners\");\r\n        }\r\n\r\n        try {\r\n            future.await();\r\n        } catch (InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n            throw new RedisException(e);\r\n        }\r\n        if (future.isSuccess()) {\r\n            return future.getNow();\r\n        }\r\n\r\n        throw convertException(future);\r\n    }\r\n\r\nWhy add this judgment\r\n  if (Thread.currentThread().getName().startsWith(\"redisson-netty\")) {\r\n            throw new IllegalStateException(\"Sync methods can't be invoked from async/rx/reactive listeners\");\r\n        }\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4227/comments",
    "author": "wl980868110",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-04-14T06:36:45Z",
        "body": "Usage of sync methods in async/rx/reactive listeners causes delays in netty threads which in turn cause timeouts in Redis commands handling."
      },
      {
        "user": "wl980868110",
        "created_at": "2022-04-14T06:46:32Z",
        "body": "If the synchronous command is executed for a long time, the asynchronous Netty thread will time out\r\nIf the synchronous command execution time is very short, the asynchronous netty thread is normal"
      },
      {
        "user": "wl980868110",
        "created_at": "2022-04-18T10:35:14Z",
        "body": "If the synchronous command is executed for a long time, the asynchronous Netty thread will time out\r\n If the synchronous command execution time is very short, the asynchronous netty thread is normal\r\n\r\n\r\nI'm sorry, I didn't make myself clear\r\n\r\n\r\n\r\n\r\nIf the synchronous command execution time is very short, it doesn't affect the asynchronous Netty thread and it doesn't need to be determined. Are you doing this to prevent user actions from affecting your Redisson connection thread?\r\n\r\n\r\n\r\n\r\n------------------&nbsp;原始邮件&nbsp;------------------\r\n发件人:                                                                                                                        \"redisson/redisson\"                                                                                    ***@***.***&gt;;\r\n发送时间:&nbsp;2022年4月14日(星期四) 下午2:36\r\n***@***.***&gt;;\r\n***@***.******@***.***&gt;;\r\n主题:&nbsp;Re: [redisson/redisson] RedissonLock.unlock (Issue #4227)\r\n\r\n\r\n\r\n\r\n\r\n \r\nClosed #4227.\r\n \r\n—\r\nReply to this email directly, view it on GitHub, or unsubscribe.\r\nYou are receiving this because you authored the thread.Message ID: ***@***.***&gt;"
      },
      {
        "user": "lengjiaxin",
        "created_at": "2022-09-20T04:34:56Z",
        "body": " \r\nIs there a solution for this problem? Is there a configuration that can release restrictions."
      },
      {
        "user": "wl980868110",
        "created_at": "2022-09-20T05:02:35Z",
        "body": "> Is there a solution for this problem? Is there a configuration that can release restrictions.\r\n\r\nDirect restrictions, no configuration controls\r\n"
      },
      {
        "user": "wl980868110",
        "created_at": "2022-09-20T05:03:48Z",
        "body": "> > Is there a solution for this problem? Is there a configuration that can release restrictions.\r\n> \r\n> Direct restrictions, no configuration controls\r\nYou can take a look at the new edition\r\n\r\n"
      }
    ]
  },
  {
    "number": 4205,
    "title": "Listening to expiration or removal of entries",
    "created_at": "2022-03-28T12:41:29Z",
    "closed_at": "2023-07-03T06:32:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4205",
    "body": "I would like to write a service that has the job of listening for expired/removed entries and persisting\r\nthem in a database. However i couldnt find a good approach because the RMapCache listeners are local.\r\n\r\nIs there maybe a Redisson abstraction for listening to Redis keyspace notifications?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4205/comments",
    "author": "Flo0",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-07-03T06:32:38Z",
        "body": "You can use `org.redisson.api.listener.MapPutListener` or `org.redisson.api.listener.MapRemoveListener` listeners"
      }
    ]
  },
  {
    "number": 4203,
    "title": "Unreachable node not getting removed from quorum of redission",
    "created_at": "2022-03-27T22:55:23Z",
    "closed_at": "2024-11-01T17:45:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4203",
    "body": "Redisson client of version of 3.10.0 is using 3 nodes of non clustered redis setup i.e 1 master and 2 slaves of AWS Elastic Cache using replicatedManager via DNS.\r\n\r\nObservation\r\n1 slave went was restarted off, we observed traffic to flow to 1 slave for more than 15 minutes without traffic flowing to second slave for longer duration. We have provided all 3 IPs using replication config\r\n\r\nPlease can you let us know the criteria for the nodes to be kept in exclusion list, is it just client timeouts after retries or what exactly. \r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4203/comments",
    "author": "saravind-hotstar",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-07-03T06:35:06Z",
        "body": "Can you set `trace` logging level for `org.redisson` package and share log output?"
      }
    ]
  },
  {
    "number": 4198,
    "title": "Can't connect to SSL enabled Redis server",
    "created_at": "2022-03-24T19:37:56Z",
    "closed_at": "2022-03-25T04:20:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4198",
    "body": "I am trying to connect to SSL enabled server and can successfully connect using Jedis, but fail with Redisson. Below test case I am using for both along with redisson-config file. When connecting with Redisson, I am getting exception\r\n\r\n```org.redisson.client.RedisException: ERR unencrypted connection is prohibited. channel: [id: 0x13ab6603, L:/172.21.54.97:35186 - R:rediss-server/10.175.186.86:21234] command: (AUTH), params: (password masked)```\r\n\r\n**Test Case**\r\n```\r\n@Slf4j\r\npublic class RedisTest {\r\n    @Test\r\n    void testRedisson() throws IOException {\r\n        final InputStream resourceAsStream = getClass().getClassLoader().getResourceAsStream(\"redisson-config.yml\");\r\n\r\n        final Config config = Config.fromYAML(resourceAsStream);\r\n        final RedissonClient redissonClient = Redisson.create(config);\r\n        final RBuckets buckets = redissonClient.getBuckets();\r\n        log.info(buckets.toString());\r\n    }\r\n\r\n    @Test\r\n    void testJedis(){\r\n        JedisPoolConfig config = new JedisPoolConfig();\r\n\r\n        JedisPool pool = new JedisPool(config, \"redis-server-name\", 21234,3000, \"password1\", true);\r\n        final Jedis resource = pool.getResource();\r\n        resource.set(\"test019\", \"test\");\r\n        final String test019 = resource.get(\"test019\");\r\n        Assertions.assertEquals(test019, \"test\");\r\n    }\r\n}\r\n```\r\n\r\n**redis-config.yml**\r\n```\r\nsingleServerConfig:\r\n  address: \"redis://redis-server:21234\"\r\n  password: \"password1\"\r\n  sslTruststore: \"file:/usr/local/jdk-11/lib/security/cacerts\"\r\n  sslTruststorePassword: \"changeit\"\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4198/comments",
    "author": "akravets",
    "comments": [
      {
        "user": "ajaysbugatti",
        "created_at": "2022-06-17T06:21:54Z",
        "body": "@akravets  can you please add the solution that you did? i am facing the same problem "
      }
    ]
  },
  {
    "number": 4186,
    "title": "RBlockingDeque java.lang.ClassNotFoundException",
    "created_at": "2022-03-17T01:41:16Z",
    "closed_at": "2022-04-18T06:36:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4186",
    "body": "the java program started with an error message :\r\n\r\n`java.io.IOException: java.lang.ClassNotFoundException: com.test.delay.queue.vo.ExpireOrder\r\n\tat org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:148)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:383)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:427)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:392)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Unknown Source)\r\nCaused by: java.lang.ClassNotFoundException: com.cheche365.partner.service.vo.ExpireOrder\r\n\tat java.base/java.net.URLClassLoader.findClass(Unknown Source)\r\n\tat java.base/java.lang.ClassLoader.loadClass(Unknown Source)\r\n\tat org.springframework.boot.loader.LaunchedURLClassLoader.loadClass(LaunchedURLClassLoader.java:151)\r\n\tat java.base/java.lang.ClassLoader.loadClass(Unknown Source)\r\n\tat java.base/java.lang.Class.forName0(Native Method)\r\n\tat java.base/java.lang.Class.forName(Unknown Source)\r\n\tat org.jboss.marshalling.AbstractClassResolver.loadClass(AbstractClassResolver.java:129)\r\n\tat org.jboss.marshalling.AbstractClassResolver.resolveClass(AbstractClassResolver.java:110)\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadClassDescriptor(RiverUnmarshaller.java:1048)\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1381)\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:298)\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:231)\r\n\tat org.jboss.marshalling.AbstractObjectInput.readObject(AbstractObjectInput.java:41)\r\n\tat org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:146)\r\n\t... 25 common frames omitted`\r\n\r\nthis is my code :\r\n`@Component\r\npublic class ThreadPoolTaskExecutorRunner implements ApplicationRunner {\r\n\r\n    private final ThreadPoolTaskExecutor threadPoolTaskExecutor;\r\n\r\n    public ThreadPoolTaskExecutorRunner(ThreadPoolTaskExecutor threadPoolTaskExecutor) {\r\n        this.threadPoolTaskExecutor = threadPoolTaskExecutor;\r\n    }\r\n\r\n    @Override\r\n    public void run(ApplicationArguments args) throws Exception {\r\n        try {\r\n            log.info(\"ThreadPoolTaskExecutorRunner start\");\r\n            threadPoolTaskExecutor.execute(orderTaskFactory.createExpireOrderTask());\r\n            log.info(\"ThreadPoolTaskExecutorRunner end\");\r\n        } catch (Exception e) {\r\n            log.error(\"ThreadPoolTaskExecutorRunner fail, e : {}\", ExceptionUtils.getStackTrace(e));\r\n        }\r\n    }\r\n}`\r\n\r\n`\r\n@Data\r\n@Builder\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\n@Slf4j\r\npublic class ExpireOrderTask implements Runnable{\r\n\r\n    private IDelayQueueService<ExpireOrder> iDelayQueueService;\r\n\r\n    @Override\r\n    public void run() {\r\n\r\n        while (true){\r\n            try {\r\n                log.info(\"开始处理订单关闭任务\");\r\n                ExpireOrder needCloseExpireOrder = iDelayQueueService.take(ORDER_DELAY_QUEUE);\r\n                log.info(\"开始处理订单关闭任务param : {}\",JSONObject.toJSONString(needCloseExpireOrder));\r\n            } catch (InterruptedException e) {\r\n                log.error(\"关闭订单失败:{}\", ExceptionUtils.getStackTrace(e));\r\n            }\r\n        }\r\n    }\r\n}`\r\n\r\n`@Service\r\npublic class DelayQueueServiceImpl<T> implements IDelayQueueService<T> {\r\n\r\n    private final RedissonClient redissonClient;\r\n\r\n    public DelayQueueServiceImpl(RedissonClient redissonClient) {\r\n        this.redissonClient = redissonClient;\r\n    }\r\n\r\n    @Override\r\n    public void offerSeconds(T data, long time, String queueName) {\r\n        offer(data, time, TimeUnit.SECONDS, queueName);\r\n    }\r\n\r\n    @Override\r\n    public void offer(T data, long time, TimeUnit timeUnit, String queueName) {\r\n        findDelayQueue(queueName).offerAsync(data, time < 0 ? 0 : time, timeUnit);\r\n    }\r\n\r\n    @Override\r\n    public T take(String queueName) throws InterruptedException {\r\n        RBlockingDeque<T> blockingQueue = findBlockingQueue(queueName);\r\n        RDelayedQueue<T> delayQueue = findDelayQueue(blockingQueue);\r\n        return blockingQueue.take();\r\n    }\r\n\r\n    @Override\r\n    public RBlockingDeque<T> findBlockingQueue(String queueName) {\r\n        return redissonClient.getBlockingDeque(queueName);\r\n    }\r\n\r\n    @Override\r\n    public RDelayedQueue<T> findDelayQueue(String queueName) {\r\n        return redissonClient.getDelayedQueue(findBlockingQueue(queueName));\r\n    }\r\n\r\n    @Override\r\n    public RDelayedQueue<T> findDelayQueue(RBlockingDeque<T> blockingQueue) {\r\n        return redissonClient.getDelayedQueue(blockingQueue);\r\n    }\r\n}`\r\n\r\nI changed the package path of ExpireOrder.class , but I did not find the ExpireOrder task with the old path when I queried redis,now the task is blocking , i need help\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4186/comments",
    "author": "xudaqing19940205",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-03-18T09:26:37Z",
        "body": "You can try to supply a proper classloader to MarshallingCodec or set `useThreadClassLoader` setting to false."
      }
    ]
  },
  {
    "number": 4183,
    "title": "lost pubsub connection",
    "created_at": "2022-03-15T16:09:16Z",
    "closed_at": "2022-03-16T10:52:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4183",
    "body": "I use redisson to subscribe message in my project, I found the pubsub connection will lost and message will be not received any more. No any exceptions can be found in log, so I tured log level to DEBUG on org.redisson. Then I found following logs, and I not sure is it normal or not:\r\n\r\non project start\r\n\r\n2022/03/15 15:37:07.368 [ty-2-14] DEBUG ClientConnectionsEntry [-|-|-] - new pubsub connection created: RedisPubSubConnection@1163063656 [redisClient=[addr=redis://myredis-servrer:6379], channel=\r\n[id: 0xdbb90202, L:/10.118.1.218:47226 - R:myredis-servrer/10.118.2.6:6379], currentCommand=null]\r\n\r\n2022/03/15 15:37:07.373 [ty-2-10] INFO  MasterConnectionPool [-|-|-] - 5 connections initialized for myredis-servrer/10.118.2.6:6379\r\n\r\n2022/03/15 15:37:07.376 [ty-2-14] INFO  MasterPubSubConnectionPool [-|-|-] - 1 connections initialized for myredis-servrer/10.118.2.6:6379\r\n\r\n\r\nalmost 4 hours later\r\n\r\n2022/03/15 19:36:55.840 [ty-2-32] DEBUG ClientConnectionsEntry [-|-|-] - new pubsub connection created: RedisPubSubConnection@1656211046 [redisClient=[addr=redis://myredis-servrer:6379], channel=[id: 0xf3a494a2, L:/10.118.1.218:37412 - R:myredis-servrer/10.118.2.6:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@6c702440(incomplete)], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]]\r\n\r\n\r\nand  13 seconds later\r\n\r\n2022/03/15 19:37:09.041 [tty-2-8] DEBUG IdleConnectionWatcher [-|-|-] - Connection [id: 0xdbb90202, L:/10.118.1.218:47226 ! R:myredis-servrer/10.118.2.6:6379] has been closed due to idle timeout. Not used for 13167 ms\r\n\r\n\r\nIt seems the pubsub connection on port 47226 is replaced by an new pubsub connection on port 37412. \r\nBut CLIENT LIST with redis-cli show:\r\n\r\nid=4824 addr=10.118.1.218:37412 laddr=10.118.2.6:6379 fd=19 name= age=12092 idle=22 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 obl=0 oll=0 omem=0 tot-mem=20496 events=r cmd=ping user=default redir=-1 \r\n\r\nflags is N not P.\r\n\r\nThis is my redisson.yaml:\r\n\r\n\r\nsingleServerConfig:\r\n  idleConnectionTimeout: 10000\r\n  connectTimeout: 10000\r\n  timeout: 3000\r\n  retryAttempts: 3\r\n  retryInterval: 1500\r\n  password: null\r\n  clientName: null\r\n  address: \"redis://myredis-server:6379\"\r\n  subscriptionConnectionMinimumIdleSize: 1\r\n  subscriptionConnectionPoolSize: 50\r\n  subscriptionsPerConnection: 5\r\n  connectionMinimumIdleSize: 5\r\n  connectionPoolSize: 64\r\n  database: 0\r\n  dnsMonitoringInterval: 60000\r\n  pingConnectionInterval: 30000\r\n  keepAlive: true\r\nthreads: 16\r\nnettyThreads: 32\r\ncodec: !<org.redisson.codec.FstCodec> {}\r\ntransportMode: \"NIO\"\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4183/comments",
    "author": "gitwang",
    "comments": [
      {
        "user": "avcad",
        "created_at": "2022-03-15T20:13:54Z",
        "body": "You don't mention your version but 3.16.5 has this fix \"Fixed - IdleConnectionWatcher shouldn't close RedisPubSubConnection if it's in subscribed state\"\r\n"
      },
      {
        "user": "gitwang",
        "created_at": "2022-03-16T10:52:22Z",
        "body": "thanks, your comment is helpful! my version is 3.16.1. "
      }
    ]
  },
  {
    "number": 4175,
    "title": "Get values of all keys matching a given pattern",
    "created_at": "2022-03-07T20:30:10Z",
    "closed_at": "2023-05-11T17:19:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4175",
    "body": "Is there a way to retrieve the value of all the keys matching the given pattern?\r\nAlso, can it be generalised to any key type? I'm able to get keys matching the pattern but how can we get all the values at once too?\r\nBelow is code snippet, however here I'm calling get for each key:\r\n```\r\npublic void getRateLimiterKeyValues() {\r\n        String pattern = API_RATE_LIMITER_KEY.concat(\"*\");\r\n        Iterable<String> keys = redisson.getKeys().getKeysByPattern(pattern);\r\n        String[] cache = StreamSupport.stream(keys.spliterator(), false).toArray(String[]::new);\r\n\r\n        for (String key : cache) {\r\n            log.info(\"Key: {} value: {}\", key, redisson.getRateLimiter(key).getConfig().toString());\r\n        }\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4175/comments",
    "author": "lucifercr07",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-05-11T17:19:21Z",
        "body": "You can use RSearch object to search map values."
      }
    ]
  },
  {
    "number": 4173,
    "title": "Redisson requires reflect-config to run",
    "created_at": "2022-03-05T06:35:57Z",
    "closed_at": "2022-03-18T20:00:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4173",
    "body": "I have a `LockFactory` class which provides the `default` and `multilock`. The following code results in a bad request with no logs at all:\r\n\r\n```\r\npublic Uni<Void> test() {\r\n        Lock lock = lockFactory.getLock(\"test Lock\");\r\n        return lock.acquire()\r\n                .invoke(() -> Log.debug(\"\\n\\n\\nLockAcquired : \" + lock + \"\\n\\n\\n\"))\r\n                .eventually(lock::release);\r\n    }\r\n```\r\n\r\n\r\napplication.json\r\n\r\n```\r\nquarkus:\r\n  redisson:\r\n    cluster-servers-config:\r\n      nodeAddresses: ${REDIS_HOSTS}\r\n```\r\n\r\nIn normal mode and in native mode locally, I see redisson logs. However, when I deploy the native build, I don't see a single redisson log. Any ideas what might be happening here?\r\n      ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4173/comments",
    "author": "romilpunetha",
    "comments": [
      {
        "user": "romilpunetha",
        "created_at": "2022-03-05T07:20:19Z",
        "body": "Update: \r\nAdding try-catch. The bean wasn't being created. Was using this config:\r\n\r\n```\r\nquarkus:\r\n  redisson:\r\n    cluster-servers-config:\r\n      node-addresses: ${REDIS_HOSTS}\r\n```\r\n"
      },
      {
        "user": "romilpunetha",
        "created_at": "2022-03-05T09:00:29Z",
        "body": "I added the configs manually using `config.useClusterServers()`.\r\nNow I'm getting `java.lang.NoSuchMethodException: org.redisson.RedissonLock.isLocked()`"
      },
      {
        "user": "romilpunetha",
        "created_at": "2022-03-05T11:25:07Z",
        "body": "I can confirm that it works after adding the following to the `reflect-config.json`.\r\n\r\n```\r\n  {\r\n    \"name\": \"org.redisson.RedissonLock\",\r\n    \"allDeclaredConstructors\": true,\r\n    \"allPublicConstructors\": true,\r\n    \"allDeclaredMethods\": true,\r\n    \"allPublicMethods\": true,\r\n    \"allDeclaredClasses\": true,\r\n    \"allPublicClasses\": true\r\n  }\r\n```\r\n\r\nAny reason why this needs to be added? I can already see the reflection config as part of the package. "
      },
      {
        "user": "mrniko",
        "created_at": "2022-03-17T12:09:33Z",
        "body": "> Now I'm getting java.lang.NoSuchMethodException: org.redisson.RedissonLock.isLocked()\r\n\r\nYou need to use RLock interface instead.\r\n\r\n> Adding try-catch. The bean wasn't being created. \r\n\r\nCan you share the exception log?"
      },
      {
        "user": "romilpunetha",
        "created_at": "2022-03-18T20:00:48Z",
        "body": "I was using the RLock interface. For a multilock, the function throws the above exception.\r\n\r\nI don't have the logs anymore. However, the bean issue was because it was a bit hard to setup configs for redisson in quarkus. Creating a constructor solved the issue. "
      }
    ]
  },
  {
    "number": 4166,
    "title": "Respecting serialVersionUID ",
    "created_at": "2022-02-28T12:19:19Z",
    "closed_at": "2022-03-01T08:36:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4166",
    "body": "I am saving and later retrieving a serialized object using an RBucket. When doing so, the serialVersionUID has no effect - redisson tries to retrieve and de-serialized the object and throws an exception it this fails. Is this done this way deliberately? Is there a way to make redisson respect the serialVersionUID, or do I need to serialize and de-serialize  the object myself?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4166/comments",
    "author": "gishroni",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-03-01T08:35:57Z",
        "body": "> Is this done this way deliberately? Is there a way to make redisson respect the serialVersionUID, or do I need to serialize and de-serialize the object myself?\r\n\r\nNo. It depends on codec you use."
      }
    ]
  },
  {
    "number": 4150,
    "title": "org.redisson.client.RedisNodeNotFoundException: Node: NodeSource [slot=7188, addr=//1.1.1.7:8992, redisClient=null, redirect=MOVED, entry=null] hasn't been discovered yet",
    "created_at": "2022-02-22T05:22:38Z",
    "closed_at": "2022-03-04T08:47:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4150",
    "body": "Hi Team,\r\n\r\nWe are getting below error while using elasticache redis cluster. While update or save values we are getting this error everytime.\r\n\r\nIt is not the case of failover. All nodes are active and i can see slot 7188 is also available.\r\n\r\n**Redisson version - 3.7.5**\r\n\r\norg.redisson.client.RedisNodeNotFoundException: Node: NodeSource [slot=7188, addr=//1.1.1.7:8992, redisClient=null, redirect=MOVED, entry=null] hasn't been discovered yet\r\n\tat org.redisson.connection.MasterSlaveConnectionManager.connectionWriteOp(MasterSlaveConnectionManager.java:550)\r\n\tat org.redisson.command.CommandAsyncService.getConnection(CommandAsyncService.java:644)\r\n\tat org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:499)\r\n\tat org.redisson.command.CommandAsyncService$8.run(CommandAsyncService.java:588)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:670)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:745)\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:473)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n\r\n\r\nCLUSTER NODES\r\n2faa414bf9c563ea5db3c4cecb3c470a5695c437 1.1.1.2:8992@1122 myself,slave f8c6bdc58a17c2aa196d88dcba6ea31297bcb88c 0 1645461237000 12 connected\r\n811513819033d8128e29967fe865e40999c71275 1.1.1.3:8992@1122 slave 9e50425e4db917c8c09f201dfd708b955f9793ba 0 1645461238000 4 connected\r\n4b54e8949673ff50f416ba99c90edee59ab174c9 1.1.1.4:8992@1122 slave 616ccd8f07fc64e275e2f8d730ae2c395d53be69 0 1645461237000 3 connected\r\n616ccd8f07fc64e275e2f8d730ae2c395d53be69 1.1.1.5:8992@1122 master - 0 1645461239704 3 connected 8192-10142 12873-16383\r\n9e50425e4db917c8c09f201dfd708b955f9793ba 1.1.1.6:8992@1122 master - 0 1645461238700 4 connected 3768-6498 10143-12872\r\nf8c6bdc58a17c2aa196d88dcba6ea31297bcb88c 1.1.1.7:8992@1122 master - 0 1645461238000 12 connected 0-3767 6499-8191\r\n\r\n\r\n\r\nCould you please help to look into the issue on priority.\r\n\r\nThanks,\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4150/comments",
    "author": "ankits114",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-02-22T09:43:09Z",
        "body": "Can you provide logs with `trace` logging level for `org.redisson` package? Did you try to recreate the cluster?"
      },
      {
        "user": "ankits114",
        "created_at": "2022-02-22T14:12:07Z",
        "body": "I have set log level as Trace but didn't found any additional log. I am missing anything while setting log level ?\r\nWe have not recreated cluster because we don't have permission to do that directly and issue is reproducible so we want to find the solution for the same.\r\n\r\nCould you please help on this issue.\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2022-02-22T16:42:43Z",
        "body": "> I have set log level as Trace but didn't found any additional log. I am missing anything while setting log level ?\r\n\r\nPlease check your log settings."
      }
    ]
  },
  {
    "number": 4142,
    "title": "Disable Dns caching",
    "created_at": "2022-02-15T11:38:15Z",
    "closed_at": "2022-02-16T10:37:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4142",
    "body": "I would to disable Dns caching, so I use DnsAddressResolverGroup with ttlmin&max=0. Is there any way to set it to Config ?\r\nOr maybe any better ways to disable DNS caching ?\r\nI have the next configuration: \r\n```\r\n    @Bean\r\n    Config redissonReadConfiguration(){\r\n        Config config = new Config();\r\n        DnsAddressResolverGroup group = new DnsAddressResolverGroup(new DnsNameResolverBuilder().ttl(0,0));\r\n        String endpoint = \"redis://\" + getReadEndpoint() + \":\" + getPort();\r\n        config.useSingleServer().setAddress(endpoint)\r\n            .setIdleConnectionTimeout(5000)\r\n            .setConnectionPoolSize(10)\r\n            .setConnectionMinimumIdleSize(0)\r\n            .setPingConnectionInterval(0)\r\n            .setDnsMonitoringInterval(-1);\r\n        return config;\r\n    }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4142/comments",
    "author": "ulinay",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-02-15T13:20:12Z",
        "body": "I'm afraid no."
      }
    ]
  },
  {
    "number": 4136,
    "title": "Exception from redis : MasterConnectionPool no available Redis entries",
    "created_at": "2022-02-14T04:16:38Z",
    "closed_at": "2022-03-18T05:56:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4136",
    "body": "\r\norg.redisson.client.RedisConnectionException: MasterConnectionPool no available Redis entries.  Disconnected hosts: [/10.5.4.3:7100]\r\n\tat org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:195)\r\n\tat org.redisson.connection.pool.MasterConnectionPool.get(MasterConnectionPool.java:31)\r\n\tat org.redisson.connection.MasterSlaveEntry.connectionWriteOp(MasterSlaveEntry.java:392)\r\n\tat org.redisson.connection.MasterSlaveConnectionManager.connectionWriteOp(MasterSlaveConnectionManager.java:675)\r\n\tat org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:489)\r\n\tat org.redisson.command.CommandAsyncService$7.run(CommandAsyncService.java:538)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:680)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:755)\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:483)\r\n\r\nEngine version: 6.x\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4136/comments",
    "author": "sreenivasnarayan",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-02-14T06:13:08Z",
        "body": "Can you share redisson logs with `trace` logging level for `org.redisson` package?"
      }
    ]
  },
  {
    "number": 4123,
    "title": "How the increase of the memory/key usage cause the Redis timeout exception ?",
    "created_at": "2022-02-09T04:17:41Z",
    "closed_at": "2022-02-14T19:24:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4123",
    "body": "Hi community,\r\n\r\nI am using a 3-master and 3-slave redis cluster. The redisson client version is 3.15.1.\r\n\r\nPreviously the memory usages is approx. 20G, and the total keys are approx. 20million. And I didn't encounter a single exception. \r\nRecently the memory usage is increased to 40G, and the total keys are around 40million. Now I start to get following exceptions randomly\r\n\r\nFor example: \r\n```\r\ncom.spcapitaliq.realtime.common.module.commonservice.main.exceptions.RedisException: org.redisson.client.RedisTimeoutException: Unable to acquire connection! Avoid to use blocking commands in Async/JavaRx/Reactive handlers. Try to increase connection pool size. Node source: NodeSource [slot=248, addr=redis://<redis-address>, redisClient=null, redirect=MOVED, entry=null], command: (PEXPIRE), params: [<key>, 0] after 0 retry attempts\r\n```\r\nand \r\n```\r\ncom.spcapitaliq.realtime.common.module.commonservice.main.exceptions.RedisException: java.util.concurrent.CompletionException: org.redisson.client.RedisTimeoutException: Unable to acquire connection! Avoid to use blocking commands in Async/JavaRx/Reactive handlers. Try to increase connection pool size. Node source: NodeSource [slot=14186, addr=redis://<redis-address>, redisClient=null, redirect=MOVED, entry=null], command: (SUNION), params: [key1, key2, key3... keyN] after 0 retry attempts\r\n```\r\n\r\nThere are other exceptions relate to other redis command, but the common part is \"**Unable to acquire connection! Avoid to use blocking commands in Async/JavaRx/Reactive handlers. Try to increase connection pool size**\".\r\n\r\nThe code is same, the only difference that I can see is the increase memory & key usage. Could this be the culprit which causing these issues? And why?\r\n\r\nThanks ahead for your time! ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4123/comments",
    "author": "RunzhongHuang",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-02-09T13:21:25Z",
        "body": "These errors can be cause by bottleneck in network/cpu on Redis/Java side. Which cause more time spending on Redis command execution as a result holding redis connection longer than usual, so you may see situations when connection pool exhausted. Also you can examine Redis slowlog output for slow eval scripts. "
      }
    ]
  },
  {
    "number": 4122,
    "title": "While run task Unable to inject Spring beans",
    "created_at": "2022-02-08T10:55:10Z",
    "closed_at": "2022-02-11T10:53:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4122",
    "body": "My config class：\r\n```java\r\n@Configuration(proxyBeanMethods = false)\r\npublic class DistributedExecutorServiceConfig {\r\n    @Bean(destroyMethod = \"\")\r\n    public RScheduledExecutorService executorService(RedissonClient redissonClient, ConfigurableListableBeanFactory beanFactory) {\r\n        ExecutorOptions defaults = ExecutorOptions.defaults()\r\n                .taskRetryInterval(2, TimeUnit.SECONDS);\r\n        RScheduledExecutorService executorService = redissonClient\r\n                .getExecutorService(\"alarm-task-executor\", defaults);\r\n        WorkerOptions workerOptions = WorkerOptions.defaults().workers(5).beanFactory(beanFactory);\r\n        executorService.registerWorkers(workerOptions);\r\n        if (executorService.isShutdown()) {\r\n            executorService.delete();\r\n            executorService = redissonClient.getExecutorService(\"alarm-task-executor\", defaults);\r\n            executorService.registerWorkers(workerOptions);\r\n        }\r\n        return executorService;\r\n    }\r\n}\r\n```\r\n\r\nmy task class:\r\n```java\r\npublic class AlarmExceptionRequestDistributedJob implements Runnable, Serializable {\r\n    @JsonIgnore\r\n    private final Logger logger = LoggerFactory.getLogger(getClass());\r\n    @JsonIgnore\r\n    private final String datePattern = \"yyyy-MM-dd HH:mm:ss.SSS\";\r\n    @JsonIgnore\r\n    private transient final ThreadLocal<SimpleDateFormat> tlDateFormat = ThreadLocal.withInitial(() -> new SimpleDateFormat(datePattern));\r\n    private static final String esProtectiveLogIndex = Constants.ES_PROTECTIVE_LOG_INDEX;\r\n    private AlarmPolicyDTO alarmPolicyDTO;\r\n    @JsonIgnore\r\n    @Autowired\r\n    private BizProtectedObjectMapper bizProtectedObjectMapper;\r\n    @JsonIgnore\r\n    @Autowired\r\n    private EmailSendService emailSendService;\r\n    @JsonIgnore\r\n    @Autowired\r\n    private AliyunSMService aliyunSMService;\r\n\r\n    /**\r\n     * 不要删除这个空构造函数，在Jackson序列化时要用\r\n     */\r\n    public AlarmExceptionRequestDistributedJob() {\r\n    }\r\n\r\n    public AlarmExceptionRequestDistributedJob(AlarmPolicyDTO alarmPolicyDTO) {\r\n        this.alarmPolicyDTO = alarmPolicyDTO;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        AlarmPolicyDTO alarmPolicy = alarmPolicyDTO;\r\n        BizAlarmPolicy.AlarmType type = alarmPolicy.getType();\r\n        if (!type.equals(BizAlarmPolicy.AlarmType.EXCEPTION_REQUEST)) {\r\n            return;\r\n        }\r\n        Long protectedId = alarmPolicy.getProtectedId();\r\n        //BizProtectedObjectMapper protectedObjectMapper = beanFactory.getBean(BizProtectedObjectMapper.class);\r\n        BizProtectedObject bizProtectedObject = bizProtectedObjectMapper.selectById(protectedId);\r\n        if (bizProtectedObject == null)\r\n            return;\r\n        //omit...\r\n    }\r\n}\r\n```\r\n\r\n**then when task running，throw exception：**\r\n```java\r\n2022-02-08 18:52:57.107 ERROR 7748 [  redisson-3-16] (ssonExecutorRemoteService.java:120) : Can't execute: RemoteServiceRequest [requestId=01a9496cb666c612eac5ceb6de3c1b70e6, methodName=scheduleAtFixedRate, signature=[2954431956196527280, 5708544082777223948], args=[org.redisson.executor.params.ScheduledAtFixedRateParameters@5f589620], options=RemoteInvocationOptions[ackTimeoutInMillis=null, executionTimeoutInMillis=null], date=1644317002124]\r\n \r\njava.lang.reflect.InvocationTargetException: null\r\n\tat sun.reflect.GeneratedMethodAccessor129.invoke(Unknown Source)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.redisson.executor.RedissonExecutorRemoteService.invokeMethod(RedissonExecutorRemoteService.java:106)\r\n\tat org.redisson.RedissonRemoteService.lambda$executeMethod$11(RedissonRemoteService.java:456)\r\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\r\n\tat java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:266)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.lang.IllegalStateException: Unable to initialize codec with ClassLoader parameter\r\n\tat org.redisson.executor.TasksRunnerService.decode(TasksRunnerService.java:324)\r\n\tat org.redisson.executor.TasksRunnerService.executeRunnable(TasksRunnerService.java:342)\r\n\tat org.redisson.executor.TasksRunnerService.scheduleAtFixedRate(TasksRunnerService.java:128)\r\n\t... 12 common frames omitted\r\nCaused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'null': Unsatisfied dependency expressed through field 'bizProtectedObjectMapper'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.cssth.web.biz.dao.mapper.BizProtectedObjectMapper' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@com.fasterxml.jackson.annotation.JsonIgnore(value=true), @org.springframework.beans.factory.annotation.Autowired(required=true)}\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:643)\r\n\tat org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119)\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.processInjection(AutowiredAnnotationBeanPostProcessor.java:430)\r\n\tat org.redisson.executor.SpringTasksInjector.inject(SpringTasksInjector.java:38)\r\n\tat org.redisson.executor.TasksRunnerService.decode(TasksRunnerService.java:319)\r\n\t... 14 common frames omitted\r\nCaused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.cssth.web.biz.dao.mapper.BizProtectedObjectMapper' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@com.fasterxml.jackson.annotation.JsonIgnore(value=true), @org.springframework.beans.factory.annotation.Autowired(required=true)}\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1717)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1273)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1227)\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:640)\r\n\t... 18 common frames omitted\r\n\r\n2022-02-08 18:52:59.206 ERROR 7748 [   redisson-3-2] (ssonExecutorRemoteService.java:120) : Can't execute: RemoteServiceRequest [requestId=01a9496cb666c612eac5ceb6de3c1b70e6, methodName=scheduleAtFixedRate, signature=[2954431956196527280, 5708544082777223948], args=[org.redisson.executor.params.ScheduledAtFixedRateParameters@4b93023a], options=RemoteInvocationOptions[ackTimeoutInMillis=null, executionTimeoutInMillis=null], date=1644317002124]\r\n \r\njava.lang.reflect.InvocationTargetException: null\r\n\tat sun.reflect.GeneratedMethodAccessor129.invoke(Unknown Source)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.redisson.executor.RedissonExecutorRemoteService.invokeMethod(RedissonExecutorRemoteService.java:106)\r\n\tat org.redisson.RedissonRemoteService.lambda$executeMethod$11(RedissonRemoteService.java:456)\r\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\r\n\tat java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:266)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.lang.IllegalStateException: Unable to initialize codec with ClassLoader parameter\r\n\tat org.redisson.executor.TasksRunnerService.decode(TasksRunnerService.java:324)\r\n\tat org.redisson.executor.TasksRunnerService.executeRunnable(TasksRunnerService.java:342)\r\n\tat org.redisson.executor.TasksRunnerService.scheduleAtFixedRate(TasksRunnerService.java:128)\r\n\t... 12 common frames omitted\r\nCaused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'null': Unsatisfied dependency expressed through field 'bizProtectedObjectMapper'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.cssth.web.biz.dao.mapper.BizProtectedObjectMapper' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@com.fasterxml.jackson.annotation.JsonIgnore(value=true), @org.springframework.beans.factory.annotation.Autowired(required=true)}\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:643)\r\n\tat org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119)\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.processInjection(AutowiredAnnotationBeanPostProcessor.java:430)\r\n\tat org.redisson.executor.SpringTasksInjector.inject(SpringTasksInjector.java:38)\r\n\tat org.redisson.executor.TasksRunnerService.decode(TasksRunnerService.java:319)\r\n\t... 14 common frames omitted\r\nCaused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.cssth.web.biz.dao.mapper.BizProtectedObjectMapper' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@com.fasterxml.jackson.annotation.JsonIgnore(value=true), @org.springframework.beans.factory.annotation.Autowired(required=true)}\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1717)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1273)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1227)\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:640)\r\n\t... 18 common frames omitted\r\n\r\n2022-02-08 18:53:01.314 ERROR 7748 [   redisson-3-4] (ssonExecutorRemoteService.java:120) : Can't execute: RemoteServiceRequest [requestId=01a9496cb666c612eac5ceb6de3c1b70e6, methodName=scheduleAtFixedRate, signature=[2954431956196527280, 5708544082777223948], args=[org.redisson.executor.params.ScheduledAtFixedRateParameters@4b9f10ae], options=RemoteInvocationOptions[ackTimeoutInMillis=null, executionTimeoutInMillis=null], date=1644317002124]\r\n \r\njava.lang.reflect.InvocationTargetException: null\r\n\tat sun.reflect.GeneratedMethodAccessor129.invoke(Unknown Source)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.redisson.executor.RedissonExecutorRemoteService.invokeMethod(RedissonExecutorRemoteService.java:106)\r\n\tat org.redisson.RedissonRemoteService.lambda$executeMethod$11(RedissonRemoteService.java:456)\r\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\r\n\tat java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:266)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.lang.IllegalStateException: Unable to initialize codec with ClassLoader parameter\r\n\tat org.redisson.executor.TasksRunnerService.decode(TasksRunnerService.java:324)\r\n\tat org.redisson.executor.TasksRunnerService.executeRunnable(TasksRunnerService.java:342)\r\n\tat org.redisson.executor.TasksRunnerService.scheduleAtFixedRate(TasksRunnerService.java:128)\r\n\t... 12 common frames omitted\r\nCaused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'null': Unsatisfied dependency expressed through field 'bizProtectedObjectMapper'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.cssth.web.biz.dao.mapper.BizProtectedObjectMapper' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@com.fasterxml.jackson.annotation.JsonIgnore(value=true), @org.springframework.beans.factory.annotation.Autowired(required=true)}\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:643)\r\n\tat org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119)\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.processInjection(AutowiredAnnotationBeanPostProcessor.java:430)\r\n\tat org.redisson.executor.SpringTasksInjector.inject(SpringTasksInjector.java:38)\r\n\tat org.redisson.executor.TasksRunnerService.decode(TasksRunnerService.java:319)\r\n\t... 14 common frames omitted\r\n````\r\nExpect your help，thanks！\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4122/comments",
    "author": "cloudgyb",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-02-09T13:23:57Z",
        "body": "> Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'null': Unsatisfied dependency expressed through field 'bizProtectedObjectMapper'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.cssth.web.biz.dao.mapper.BizProtectedObjectMapper' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@com.fasterxml.jackson.annotation.JsonIgnore(value=true), @org.springframework.beans.factory.annotation.Autowired(required=true)}\r\n\r\nI think you need to check your dependencies."
      },
      {
        "user": "CarryWll",
        "created_at": "2022-10-18T12:39:28Z",
        "body": "I want to know how to solve this problem. I have encountered the same problem?"
      },
      {
        "user": "cloudgyb",
        "created_at": "2022-10-19T06:03:44Z",
        "body": "> I want to know how to solve this problem. I have encountered the same problem?\r\n\r\nI still haven't solved it！"
      },
      {
        "user": "CarryWll",
        "created_at": "2022-10-21T09:17:07Z",
        "body": "> > Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'null': Unsatisfied dependency expressed through field 'bizProtectedObjectMapper'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.cssth.web.biz.dao.mapper.BizProtectedObjectMapper' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@com.fasterxml.jackson.annotation.JsonIgnore(value=true), @org.springframework.beans.factory.annotation.Autowired(required=true)}\r\n> \r\n> I think you need to check your dependencies.\r\n\r\nCan you give an example of configuring Spring beans dependencies when run task?"
      }
    ]
  },
  {
    "number": 4108,
    "title": "Redis single for AWS ElastiCache",
    "created_at": "2022-02-07T08:51:52Z",
    "closed_at": "2022-02-07T09:39:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4108",
    "body": "Hi, \r\nIs Redis single compatible with Amazon ElastiCache or only GCP and Azure ?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4108/comments",
    "author": "ulinay",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-02-07T09:39:00Z",
        "body": "Redis single mode allows to specify only one node. You can specify a master node of Amazon ElastiCache, but failover won't work. Use replicated or cluster mode instead."
      }
    ]
  },
  {
    "number": 4065,
    "title": "How to use 'zAdd'?",
    "created_at": "2022-01-10T09:22:53Z",
    "closed_at": "2022-01-11T07:26:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4065",
    "body": "How to use 'RedisZSetCommands.zAdd(byte[] key, double score, byte[] value)'?\r\nnot implemented？",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4065/comments",
    "author": "Jabwin",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-01-10T10:55:47Z",
        "body": "It's implemented in all versions. Starting from Spring Data Redis 2.5.0 it's routed to `zAdd(byte[] key, double score, byte[] value, ZAddArgs args)` method. Which is also implemented."
      },
      {
        "user": "Jabwin",
        "created_at": "2022-01-11T01:25:50Z",
        "body": "Thank you!"
      }
    ]
  },
  {
    "number": 4060,
    "title": "Time to live for cache elements from both Local and Redis in Near Cache",
    "created_at": "2022-01-05T09:03:26Z",
    "closed_at": "2023-07-03T05:54:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4060",
    "body": "How can I evict cache elements based on time to live and idle time from both Local and Redis cache for RLocalCachedMap (near-cache). As of now, is this possible in open source edition (or) do I need to buy Pro license.\r\n\r\nIt would be a great feature if its available in open source edition. \r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4060/comments",
    "author": "mlakshminara",
    "comments": [
      {
        "user": "mlakshminara",
        "created_at": "2022-01-10T05:13:45Z",
        "body": "Is it possible to set Time to live for both Local cache and also for cache elements stored in Redis cluster when RLocalCachedMap is used ? Can anyone let me know how to do this setup ?"
      },
      {
        "user": "mlakshminara",
        "created_at": "2022-02-15T06:44:15Z",
        "body": "Can anyone answer or provide some explanation to this question"
      },
      {
        "user": "mrniko",
        "created_at": "2023-07-03T05:54:18Z",
        "body": "This feature is available only in PRO version"
      }
    ]
  },
  {
    "number": 4058,
    "title": "Cannot connect to redis memory store mode standard on GCP",
    "created_at": "2022-01-04T05:26:20Z",
    "closed_at": "2022-01-27T08:23:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4058",
    "body": "Hi. I create memory store redis mode standard with replicas on GCP. I using single server config to connect to primary endpoint, but error. \r\n\r\n`stack_trace\": \"org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'redissonTest' defined in URL [jar:file:/worker-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/com/ptfmobile/worker/test/RedissonTest.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'getRedissonClient' defined in class path resource [com/ptfmobile/worker/config/RedissonConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'getRedissonClient' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 10.228.174.20/10.228.174.20:6378\\n\\tat org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:800)\\n\\tat org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:229)\\n\\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1372)\\n\\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1222)\\n\\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:582)\\n\\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542)\\n\\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)\\n\\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)\\n\\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)\\n\\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)\\n\\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:944)\\n\\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918)\\n\\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583)\\n\\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754)\\n\\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434)\\n\\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:338)\\n\\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1343)\\n\\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1332)\\n\\tat com.ptfmobile.worker.WorkerApplication.main(WorkerApplication.java:10)\\n\\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\\n\\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\\n\\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\\n\\tat java.lang.reflect.Method.invoke(Method.java:498)\\n\\tat org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49)\\n\\tat org.springframework.boot.loader.Launcher.launch(Launcher.java:108)\\n\\tat org.springframework.boot.loader.Launcher.launch(Launcher.java:58)\\n\\tat org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88)\\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'getRedissonClient' defined in class path resource [com/ptfmobile/worker/config/RedissonConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'getRedissonClient' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 10.228.174.20/10.228.174.20:6378\\n\\tat org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:658)\\n\\tat org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:486)\\n\\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1352)\\n\\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1195)\\n\\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:582)\\n\\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542)\\n\\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)\\n\\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)\\n\\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)\\n\\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)\\n\\tat org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276)\\n\\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380)\\n\\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300)\\n\\tat org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:887)\\n\\tat org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:791)\\n\\t... 26 common frames omitted\\nCaused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'getRedissonClient' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 10.228.174.20/10.228.174.20:6378\\n\\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185)\\n\\tat org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653)\\n\\t... 40 common frames omitted\\nCaused by: org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 10.228.174.20/10.228.174.20:6378\\n\\tat org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:155)\\n\\tat org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)\\n\\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\\n\\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\\n\\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\\n\\tat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\\n\\tat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609)\\n\\tat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\\n\\tat org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96)\\n\\tat org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:310)\\n\\tat org.redisson.connection.pool.ConnectionPool.lambda$createConnection$3(ConnectionPool.java:276)\\n\\tat java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:774)\\n\\tat java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:750)\\n\\tat java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)\\n\\tat java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)\\n\\tat org.redisson.client.RedisClient$1$2.run(RedisClient.java:235)\\n\\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\\n\\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469)\\n\\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\\n\\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\\n\\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\\n\\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\\n\\tat java.lang.Thread.run(Thread.java:748)\\nCaused by: java.util.concurrent.CompletionException: io.netty.channel.ConnectTimeoutException: connection timed out: 10.228.174.20/10.228.174.20:6378\\n\\tat java.util.concurrent.CompletableFuture.encodeRelay(CompletableFuture.java:326)\\n\\tat java.util.concurrent.CompletableFuture.completeRelay(CompletableFuture.java:338)\\n\\tat java.util.concurrent.CompletableFuture.uniRelay(CompletableFuture.java:925)\\n\\tat java.util.concurrent.CompletableFuture$UniRelay.tryFire(CompletableFuture.java:913)\\n\\t... 10 common frames omitted\\nCaused by: io.netty.channel.ConnectTimeoutException: connection timed out: 10.228.174.20/10.228.174.20:6378\\n\\tat io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:261)\\n\\tat io.netty.util.concurrent.PromiseTask.runTask(PromiseTask.java:98)\\n\\tat io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:170)\\n\\t... 7 common frames omitted\\n\"`\r\n\r\n\r\n\r\nAnyone know config to connect to redis, this is myconfig. Thanks!\r\n```\r\n\r\n      singleServerConfig:\r\n        idleConnectionTimeout: 10000\r\n        connectTimeout: 10000\r\n        timeout: 3000\r\n        retryAttempts: 3\r\n        retryInterval: 1500\r\n        password: \"mypassword\"\r\n        subscriptionsPerConnection: 5\r\n        clientName: null\r\n        address: \"redis://10.228.174.20:6378\"\r\n        subscriptionConnectionMinimumIdleSize: 1\r\n        subscriptionConnectionPoolSize: 50\r\n        connectionMinimumIdleSize: 10\r\n        connectionPoolSize: 64\r\n        database: 0\r\n        dnsMonitoringInterval: 5000\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4058/comments",
    "author": "kimnamcham",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-01-04T06:25:41Z",
        "body": "`ConnectTimeoutException: connection timed out: 10.228.174.20/10.228.174.20:6378`. Check the network"
      },
      {
        "user": "kimnamcham",
        "created_at": "2022-01-04T06:30:46Z",
        "body": "> \r\n\r\n\r\n\r\n> `ConnectTimeoutException: connection timed out: 10.228.174.20/10.228.174.20:6378`. Check the network\r\n\r\nI connect from redis-cli in VM instance on GCP still connect OK. I thinks this issues is connect to replica mode of redis memorystore service on GCP"
      },
      {
        "user": "kimnamcham",
        "created_at": "2022-01-04T08:28:34Z",
        "body": "Anyone can resolve this issuse? Thanks!!"
      },
      {
        "user": "mrniko",
        "created_at": "2022-01-04T09:20:09Z",
        "body": "> I thinks this issues is connect to replica mode of redis memorystore service on GCP\r\n\r\nBut you connect to primary node"
      },
      {
        "user": "kimnamcham",
        "created_at": "2022-01-04T09:28:40Z",
        "body": "> > I thinks this issues is connect to replica mode of redis memorystore service on GCP\r\n> \r\n> But you connect to primary node\r\n\r\nHow can get other node ip ? Thanks"
      },
      {
        "user": "kimnamcham",
        "created_at": "2022-01-04T11:57:31Z",
        "body": "Anyone have experience config redisson connect to memory store with mode replicas, please support me ! Thanks"
      },
      {
        "user": "mrniko",
        "created_at": "2022-01-04T15:00:33Z",
        "body": "try to use replicated mode."
      }
    ]
  },
  {
    "number": 4057,
    "title": "Redisson WriteRedisConnectionException timeout",
    "created_at": "2022-01-02T08:27:03Z",
    "closed_at": "2022-01-27T08:31:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4057",
    "body": "```\r\norg.redisson.client.WriteRedisConnectionException: Unable to write command into connection! Increase connection pool size. Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@1343879621 [redisClient=[addr=redis://172.31.142.7:6379], channel=[id: 0x371731e4, L:/10.0.134.241:35464 ! R:172.31.142.7/172.31.142.7:6379], currentCommand=null, usage=0], command: (EVAL), params: [local key = KEYS[1] local obj = ARGV[1] local items = redis.call('lrange', key, 0, -1) for i=1,#item..., 1, testJobUnitsPopKey_83924b22-20cd-4d42-abc6-5c236e8792c9, PooledUnsafeDirectByteBuf(ridx: 0, widx: 38, cap: 256)] after 3 retry attempts\r\n        at org.redisson.command.RedisExecutor.checkWriteFuture(RedisExecutor.java:282) ~[redisson-3.16.7.jar!/:3.16.7]\r\n        at org.redisson.command.RedisExecutor.access$100(RedisExecutor.java:62) ~[redisson-3.16.7.jar!/:3.16.7]\r\n        at org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:165) ~[redisson-3.16.7.jar!/:3.16.7]\r\n        at org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:162) ~[redisson-3.16.7.jar!/:3.16.7]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1021) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:882) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n        at java.lang.Thread.run(Thread.java:748) [?:1.8.0_212]\r\nCaused by: io.netty.channel.StacklessClosedChannelException\r\n        at io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4057/comments",
    "author": "xushaoxiao",
    "comments": [
      {
        "user": "xushaoxiao",
        "created_at": "2022-01-02T08:27:51Z",
        "body": "redisson version has been released from 3.16.2 to 3..16.7"
      },
      {
        "user": "mrniko",
        "created_at": "2022-01-04T06:28:18Z",
        "body": "Try to reduce connection pool size."
      },
      {
        "user": "xushaoxiao",
        "created_at": "2022-01-04T06:55:16Z",
        "body": "```yaml\r\n---\r\nsingleServerConfig:\r\n  idleConnectionTimeout: 60000\r\n  connectTimeout: 1000\r\n  timeout: 30000\r\n  retryAttempts: 5\r\n  retryInterval: 1500\r\n  password: null\r\n  subscriptionsPerConnection: 5\r\n  clientName: testing-framework-redis-client\r\n  address: \"redis://172.31.142.7:6379\"\r\n  subscriptionConnectionMinimumIdleSize: 1\r\n  subscriptionConnectionPoolSize: 50\r\n  connectionMinimumIdleSize: 32\r\n  connectionPoolSize: 64\r\n  database: 0\r\n  dnsMonitoringInterval: 5000\r\n#  pingConnectionInterval: 1000\r\nthreads: 16\r\nnettyThreads: 32\r\ncodec:\r\n  class: org.redisson.codec.JsonJacksonCodec\r\ntransportMode: \"NIO\"\r\n```\r\n\r\nI used default settings @mrniko "
      },
      {
        "user": "dingzuobing",
        "created_at": "2023-02-15T09:56:47Z",
        "body": "The problem is resolved?@xushaoxiao"
      },
      {
        "user": "xiangshaonumber1",
        "created_at": "2023-06-08T02:17:39Z",
        "body": "How did you solve this problem @xushaoxiao , its standalone and I also use the default config\r\n\r\n"
      }
    ]
  },
  {
    "number": 4055,
    "title": "High Memory Consumption with publishAsync",
    "created_at": "2022-01-01T10:20:04Z",
    "closed_at": "2022-01-01T14:21:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4055",
    "body": "Hey! After doing this as just a test of Redisson pubsub\r\n```\r\nConfig config = new Config();\r\nconfig.useSingleServer().setAddress(\"redis://149.56.242.170:6379\").setPassword(\"pepo0804\")\r\n                .setConnectionMinimumIdleSize(1)\r\n                .setConnectionMinimumIdleSize(1)\r\n                .setConnectionPoolSize(2);\r\nconfig.setMinCleanUpDelay(0);\r\nconfig.setThreads(1);\r\nconfig.setNettyThreads(2);\r\nconfig.setTransportMode(TransportMode.NIO);\r\nconfig.setCodec(new StringCodec());\r\nRedissonClient redisson = Redisson.create(config);\r\nThread thread = new Thread(()-> {\r\n            RTopic topic = redisson.getTopic(\"tfq\");\r\n            topic.addListenerAsync(Object.class, (channel, message) ->{\r\n                /*at.getAndIncrement();\r\n                if (at.get() % 1000 == 0) {\r\n                    Bukkit.getLogger().log(Level.INFO,\"Reached: \" + at.get() + \" in \" + (System.currentTimeMillis() - time));\r\n                }*/\r\n            });\r\n        });\r\nthread.start();\r\n\r\nnew Thread(()->{\r\n     RTopic topic = redisson.getTopic(\"tfq\");\r\n     while (true){\r\n     topic.publishAsync(\"fwa\");\r\n     }\r\n}).start();\r\n        \r\n```\r\n\r\nThe thing is, when using the method .publishAsync, memory usage increases too much really fast, but when using .publish, it doesn't\r\nIs this an expected behavior? am I doing something wrong that could be causing that?\r\n\r\nI'm running this with 8GB of ram",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4055/comments",
    "author": "PedroMPagani",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-01-01T14:21:27Z",
        "body": "> The thing is, when using the method .publishAsync, memory usage increases too much really fast, but when using .publish, it doesn't\r\n\r\nIn async mode all commands accumulated in memory and wait for processing/response. In sync mode each call is blocked until response returned by Redis so there are no waiting commands for processing/response. "
      }
    ]
  },
  {
    "number": 4046,
    "title": "Reads only happening from Master Node for Redis Cache in Elastic Cache replicated mode",
    "created_at": "2021-12-23T11:38:40Z",
    "closed_at": "2021-12-26T08:32:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4046",
    "body": "We are using the clustered connection in aws for redis, but the read is always happening from the primary node.\r\n\r\nThe versions we are using:\r\n\r\nRedis engine in aws  : 4.0.10\r\n\r\nClient:\r\n                       <dependency>\r\n\t\t\t\t<groupId>org.redisson</groupId>\r\n\t\t\t\t<artifactId>redisson</artifactId>\r\n\t\t\t\t<version>3.16.6</version>\r\n\t\t\t</dependency>\r\n\r\n\r\nConfig:\r\nURL: aws cluster url\r\nfinal int poolSize = Runtime.getRuntime().availableProcessors() * 2 + 2;\r\n\t\tConfig config = new Config();\r\n\t\tconfig\r\n\t\t\t.useClusterServers()\r\n\t\t\t.setScanInterval(2000)\r\n\t\t\t.addNodeAddress(redisUrl)\r\n\t\t\t.setMasterConnectionPoolSize(poolSize)\r\n\t\t\t.setMasterConnectionMinimumIdleSize(poolSize)\r\n\t\t\t.setSlaveConnectionPoolSize(poolSize)\r\n\t\t\t.setSlaveConnectionMinimumIdleSize(poolSize)\r\n\t\t\t\t.setReadMode(ReadMode.SLAVE);\r\n\r\n\t\tconfig.setCodec(codec);\r\n\t\tredissonClient = Redisson.create(config);\r\n\r\n\r\nCache read:\r\n\r\n                final RMap<String, Config> cache = this.redissonClient.getMap(CONFIG_CACHE);\r\n\t\tif (cache.isEmpty()) {\r\n\t\t\tlog.info(\"found Config cache empty... reloading from database\");\r\n\t\t\treloadPartnerConfig();\r\n\t\t}\r\n\t\treturn cache.get(apiKey);\r\n\r\n\r\n@mrniko  Could you check this once you have some time. I am sure you can provide a relevant answer very fast.\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4046/comments",
    "author": "rjvharidas",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-12-23T11:45:49Z",
        "body": "please share log with `trace` logging level for `org.redisson` package."
      },
      {
        "user": "mrniko",
        "created_at": "2021-12-23T17:32:02Z",
        "body": "EVAL script uses write command so it's executed on master. You can use RMapCache.getWithTTLOnly() if idleTimeout is not defined."
      },
      {
        "user": "rjvharidas",
        "created_at": "2021-12-26T08:32:43Z",
        "body": "Thanks @mrniko , we have moved to  RMapCache.getWithTTLOnly() and now i can see the data is loading from read replica."
      },
      {
        "user": "formanojhr",
        "created_at": "2023-04-26T03:45:11Z",
        "body": "@mrniko is this issue also in cluster mode? for read replicas. I assume yes."
      }
    ]
  },
  {
    "number": 4034,
    "title": "RLocalCachedMap sometime does not sync data from Redis",
    "created_at": "2021-12-20T04:43:24Z",
    "closed_at": "2022-01-04T03:11:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4034",
    "body": "Hi,\r\nI have 2 servers that use the same RLocalCachedMap. Server A I use to put data and Server B just use to query data.\r\nI'm facing with issue that sometime Server A updates data but Server B data is still old (cached value is not updated). I checked log but no Redisson exception there.\r\n\r\nIf I invoke `localCachedMap.preloadCache()` on server B (via SOS REST call), data of server B will be updated.\r\n\r\nI'm using Redisson 3.16.5\r\nThis is my LocalCacheOptions\r\n`LocalCachedMapOptions.defaults()\r\n            .evictionPolicy(LocalCachedMapOptions.EvictionPolicy.NONE)\r\n            .cacheSize(0)\r\n            .syncStrategy(LocalCachedMapOptions.SyncStrategy.UPDATE)\r\n            .reconnectionStrategy(LocalCachedMapOptions.ReconnectionStrategy.NONE)\r\n            .writeMode(MapOptions.WriteMode.WRITE_BEHIND);`\r\nThis is my RedissonConfig\r\n`config.useSentinelServers()\r\n                .setMasterName(****)\r\n                .setPassword(****)\r\n                .setReadMode(ReadMode.SLAVE)\r\n                .setSubscriptionMode(SubscriptionMode.SLAVE)\r\n                .setKeepAlive(true)\r\n                .setTcpNoDelay(true)\r\n                .addSentinelAddress(redisUri)\r\n                .setSubscriptionsPerConnection(100)\r\n                .setSlaveConnectionPoolSize(1000)\r\n                .setMasterConnectionPoolSize(1000);`\r\n\r\nPlease help me to point out some ways to investigate and resolve this issue.\r\nThanks\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4034/comments",
    "author": "lehuuthanh5",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-12-21T07:09:31Z",
        "body": "This might be caused by dropping pubsub messages in network layer.\r\n\r\nDid you try to change syncStrategy to SyncStrategy.INVALIDATE ?"
      },
      {
        "user": "lehuuthanh5",
        "created_at": "2021-12-22T02:38:53Z",
        "body": "Thanks for replying.\r\nI had not try yet. SyncStrategy.INVALIDATE will make getting data slowdown.\r\nDoes Redisson have any method that can detect the problem? and I can trigger preloadCache.\r\nThanks"
      },
      {
        "user": "mrniko",
        "created_at": "2021-12-22T07:27:55Z",
        "body": "there is no such method"
      },
      {
        "user": "xyqshi",
        "created_at": "2023-07-27T19:28:12Z",
        "body": "> \r\n\r\nIf a message is dropped, wouldn't INVALIDATE also not work?"
      },
      {
        "user": "lehuuthanh5",
        "created_at": "2023-07-28T01:52:03Z",
        "body": "It may not work. \r\nAnyway, using the latest version of Redisson will fix this problem, It's more stable with RLocalCachedMap right now."
      }
    ]
  },
  {
    "number": 4028,
    "title": "org.springframework.dao.QueryTimeoutException: Command still hasn't been written into connection! Increase nettyThreads and/or retryInterval settings. Payload size in bytes: 0. Node source: NodeSource ",
    "created_at": "2021-12-17T07:57:02Z",
    "closed_at": "2022-01-17T09:45:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4028",
    "body": "[http-nio-30050-exec-8] jnpf.ResultException                    : org.springframework.dao.QueryTimeoutException: Command still hasn't been written into connection! Increase nettyThreads and/or retryInterval settings. Payload size in bytes: 0. Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@544414644 [redisClient=[addr=redis://218.90.122.145:6370], channel=[id: 0x78a18e59, L:/10.115.43.189:60890 - R:/218.90.122.145:6370], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@56f03af3(failure: java.util.concurrent.CancellationException)], command=(GET), params=[[103, 99, 108, 108, 111, 103, 105, 110, 95, 116, ...]], codec=org.redisson.client.codec.ByteArrayCodec]], command: (GET), params: [[103, 99, 108, 108, 111, 103, 105, 110, 95, 116, ...]] after 3 retry attempts; nested exception is org.redisson.client.RedisTimeoutException: Command still hasn't been written into connection! Increase nettyThreads and/or retryInterval settings. Payload size in bytes: 0. Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@544414644 [redisClient=[addr=redis://218.90.122.145:6370], channel=[id: 0x78a18e59, L:/10.115.43.189:60890 - R:/218.90.122.145:6370], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@56f03af3(failure: java.util.concurrent.CancellationException)], command=(GET), params=[[103, 99, 108, 108, 111, 103, 105, 110, 95, 116, ...]], codec=org.redisson.client.codec.ByteArrayCodec]], command: (GET), params: [[103, 99, 108, 108, 111, 103, 105, 110, 95, 116, ...]] after 3 retry attempts\r\n\tat org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:48)\r\n\tat org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:35)\r\n\tat org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:44)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.transform(RedissonConnection.java:223)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.syncFuture(RedissonConnection.java:218)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.sync(RedissonConnection.java:384)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.read(RedissonConnection.java:765)\r\n\tat org.redisson.spring.data.connection.RedissonConnection.get(RedissonConnection.java:499)\r\n\tat org.springframework.data.redis.core.DefaultValueOperations$1.inRedis(DefaultValueOperations.java:57)\r\n\tat org.springframework.data.redis.core.AbstractOperations$ValueDeserializingRedisCallback.doInRedis(AbstractOperations.java:60)\r\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:228)\r\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:188)\r\n\tat org.springframework.data.redis.core.AbstractOperations.execute(AbstractOperations.java:96)\r\n\tat org.springframework.data.redis.core.DefaultValueOperations.get(DefaultValueOperations.java:53)\r\n\tat jnpf.util.RedisUtil.getString(RedisUtil.java:216)\r\n\tat jnpf.util.UserProvider.get(UserProvider.java:56)\r\n\tat jnpf.util.UserProvider.get(UserProvider.java:72)\r\n\tat jnpf.DataSourceBindAspect.doAroundService(DataSourceBindAspect.java:58)\r\n\tat sun.reflect.GeneratedMethodAccessor605.invoke(Unknown Source)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4028/comments",
    "author": "xiaonannet",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-12-20T06:01:18Z",
        "body": "Can you share your Redisson config?"
      },
      {
        "user": "zchen-flashhold",
        "created_at": "2021-12-28T02:15:00Z",
        "body": "Same issue, any update here"
      },
      {
        "user": "mrniko",
        "created_at": "2021-12-28T06:13:50Z",
        "body": "@zchen-flashhold \r\n\r\ndid you try to reduce connection pool and/or increase nettyThreads ?"
      },
      {
        "user": "zchen-flashhold",
        "created_at": "2021-12-28T07:14:42Z",
        "body": "```\r\nsingleServerConfig:\r\n  idleConnectionTimeout: 10000\r\n  connectTimeout: 10000\r\n  timeout: 3000\r\n  retryAttempts: 3\r\n  retryInterval: 1500\r\n  subscriptionsPerConnection: 5\r\n  clientName: rcs-redis\r\n  subscriptionConnectionMinimumIdleSize: 1\r\n  subscriptionConnectionPoolSize: 1\r\n  connectionMinimumIdleSize: 32\r\n  connectionPoolSize: 64\r\n  database: 1\r\n  dnsMonitoringInterval: 5000\r\n  nettyThreads: 64\r\ncodec: !<org.redisson.codec.JsonJacksonCodec> { }\r\ntransportMode: \"NIO\"\r\n```\r\nOur configuration look like this. We change nettyThreads from 32 to 64, but we encounter the same problem"
      },
      {
        "user": "mrniko",
        "created_at": "2021-12-29T09:18:14Z",
        "body": "try to set connectionMinimumIdleSize = 16 and connectionPoolSize = 32"
      },
      {
        "user": "zchen-flashhold",
        "created_at": "2021-12-30T07:47:57Z",
        "body": "What's relationship between connectionPool and nettyThreads? Does the value of nettyThread should be large than the connectionPool (the sum of subscriptionConnectionPoolSize and connectionPoolSize)"
      },
      {
        "user": "mrniko",
        "created_at": "2022-01-17T09:45:03Z",
        "body": "They are not related to each other. But if nettyThreads amount isnt' sufficient and they all are busy you'll get this error."
      }
    ]
  },
  {
    "number": 4012,
    "title": "what's the difference between 'Replicated mode' with other mode?",
    "created_at": "2021-12-09T02:34:20Z",
    "closed_at": "2021-12-09T12:49:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4012",
    "body": "The document said 'Replicated mode' is for Azure or AWS, but these cloud service can also use jedis as client which just has single or cluster mode.\r\nSo what's the difference if I use the 'Replicated mode' instead of the 'single mode'?\r\n\r\n文档里说云托管模式是用来连接云计算运营商提供的Redis云服务，但是这些云服务厂商也可以通过jedis直接连接，而jedis只有常规的单机或者集群连接，是没有这种云托管模式的。\r\n所以使用云托管模式的话，跟用单机或者集群的方式有什么区别吗",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4012/comments",
    "author": "IcebergXTY",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-12-09T08:26:41Z",
        "body": "In Replicated mode failover is monitored. As well as slave adding/removing."
      }
    ]
  },
  {
    "number": 4008,
    "title": "Buffer overflow error while running tests after adding Redisson dependency",
    "created_at": "2021-12-07T18:08:20Z",
    "closed_at": "2022-06-09T07:14:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4008",
    "body": "This is happening on my CI/CD tool (Semaphore CI). After adding the Redisson dependency, the build always fails with the error:\r\n`*** buffer overflow detected ***: /usr/lib/jvm/java-11-openjdk-amd64/bin/java terminated`\r\n\r\nMy CI/CD uses a Ubuntu 18.04 VM and has Java 11.0.11 installed.\r\n\r\nI think the problem is likely related to that VM, as if I run the tests locally (Ubuntu 20.04, OpenJDK Runtime Environment AdoptOpenJDK-11.0.11+9) the tests are executed as expected.\r\n\r\nHas anybody had this problem before? Do you have any idea on what might be creating this error?\r\n\r\nThanks in advance for any help!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4008/comments",
    "author": "mdcarreira",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-12-28T09:48:45Z",
        "body": "Can you provide full trace of overflow?"
      },
      {
        "user": "mdcarreira",
        "created_at": "2021-12-29T17:00:05Z",
        "body": "I just spent the past couple of hours trying to retrieve more information about this crash, tried every setting I could find, but I couldn't get it to generate a JVM dump...\r\n\r\nAll I have is this:\r\n\r\n> (...)\r\n> [debug] Test run started\r\n> [debug] Test com.weldnote.welding.pqr.create.PQRCreatorBasedOnWPSTest.createPQR_AWSB21 started\r\n> [debug] Test com.weldnote.welding.pqr.create.PQRCreatorBasedOnWPSTest.createPQR_AWSB21 finished, took 0.035 sec\r\n> [debug] Test com.weldnote.welding.pqr.create.PQRCreatorBasedOnWPSTest.create_PQR_iso156141 started\r\n> [debug] Test com.weldnote.welding.pqr.create.PQRCreatorBasedOnWPSTest.create_PQR_iso156141 finished, took 0.014 sec\r\n> [debug] Test com.weldnote.welding.pqr.create.PQRCreatorBasedOnWPSTest.create_PQR_asmeix started\r\n> [debug] Test com.weldnote.welding.pqr.create.PQRCreatorBasedOnWPSTest.create_PQR_asmeix finished, took 0.018 sec\r\n> [debug] Test com.weldnote.welding.pqr.create.PQRCreatorBasedOnWPSTest.create_PQR_awsd11 started\r\n> [debug] Test com.weldnote.welding.pqr.create.PQRCreatorBasedOnWPSTest.create_PQR_awsd11 finished, took 0.004 sec\r\n> [debug] Test run finished: 0 failed, 0 ignored, 4 total, 0.072s\r\n> [debug]     Produced 0 nested tasks and 4 events.\r\n> [debug]   Running TaskDef(com.weldnote.com.weldnote.worker.projects.report.lists.FillerMaterialSectionCreatorTest, sbt.ForkMain$AnnotatedFingerscan@619419a5, false, [SuiteSelector])\r\n> [debug] Test run started\r\n> [debug] Test com.weldnote.com.weldnote.worker.projects.report.lists.FillerMaterialSectionCreatorTest.generate_filler_material_sections started\r\n> *** buffer overflow detected ***: /usr/lib/jvm/java-11-openjdk-amd64/bin/java terminated\r\n> [debug] Summary for JUnit not available.\r\n> [error] Error: Total 0, Failed 0, Errors 0, Passed 0\r\n> [error] Error during tests:\r\n> [error] \tRunning java with options -classpath /home/runner/weldnote_backend/target/scala-2.12/test-classes:/home/runner/weldnote_backend/target/web/classes/test:/home/runner/weldnote_backend/target/scala-2.12/classes:/home/runner/weldnote_backend/target/web/classes/main:/home/runner/weldnote_backend/lib/WeldnoteFonts.jar:/home/runner/weldnote_backend/lib/Arial Unicode.jar:/home/runner/weldnote_backend/lib/OpenSans.jar:/home/runner/weldnote_backend/lib/GE_Fonts.jar:/home/runner/.sbt/boot/scala-2.12.10/lib/scala-library.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-enhancer/1.2.2/play-enhancer-1.2.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/twirl-api_2.12/1.5.1/twirl-api_2.12-1.5.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/payintech/play-ebean_2.12/21.02/play-ebean_2.12-21.02.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-server_2.12/2.8.8/play-server_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-logback_2.12/2.8.8/play-logback_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-akka-http-server_2.12/2.8.8/play-akka-http-server_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-java-forms_2.12/2.8.8/play-java-forms_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/filters-helpers_2.12/2.8.8/filters-helpers_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-java-jdbc_2.12/2.8.8/play-java-jdbc_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ahc-ws_2.12/2.8.8/play-ahc-ws_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-java-jpa_2.12/2.8.8/play-java-jpa_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-guice_2.12/2.8.8/play-guice_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ehcache_2.12/2.8.8/play-ehcache_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/postgresql/postgresql/42.2.8/postgresql-42.2.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/flywaydb/flyway-play_2.12/7.14.0/flyway-play_2.12-7.14.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/bitbucket/b_c/jose4j/0.6.5/jose4j-0.6.5.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/hamcrest/hamcrest-all/1.3/hamcrest-all-1.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/avaje/avaje-agentloader/4.3/avaje-agentloader-4.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/commons-io/commons-io/2.6/commons-io-2.6.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/javax/el/javax.el-api/3.0.0/javax.el-api-3.0.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/glassfish/web/javax.el/2.2.6/javax.el-2.2.6.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/amazonaws/aws-java-sdk-s3/1.11.657/aws-java-sdk-s3-1.11.657.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/jxls/jxls/2.6.0/jxls-2.6.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/jxls/jxls-poi/1.2.0/jxls-poi-1.2.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/redis/clients/jedis/3.3.0/jedis-3.3.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-csv/1.7/commons-csv-1.7.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-text/1.8/commons-text-1.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-lang3/3.9/commons-lang3-3.9.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/levigo/jbig2/levigo-jbig2-imageio/2.0/levigo-jbig2-imageio-2.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/xhtmlrenderer/flying-saucer-core/9.1.22/flying-saucer-core-9.1.22.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/xhtmlrenderer/flying-saucer-pdf/9.1.22/flying-saucer-pdf-9.1.22.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/olap4j/olap4j/1.2.0/olap4j-1.2.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/lowagie/itext/2.1.7/itext-2.1.7.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/net/sf/jasperreports/jasperreports/6.10.0/jasperreports-6.10.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/rabbitmq/amqp-client/5.7.3/amqp-client-5.7.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/ghost4j/ghost4j/1.0.1/ghost4j-1.0.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/mockito/mockito-core/3.1.0/mockito-core-3.1.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/sentry/sentry-logback/1.7.28/sentry-logback-1.7.28.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/mixpanel/mixpanel-java/1.5.0/mixpanel-java-1.5.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/stripe/stripe-java/9.10.0/stripe-java-9.10.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/pdfbox/pdfbox/2.0.17/pdfbox-2.0.17.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean-mocker/12.6.0/ebean-mocker-12.6.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/tools/finder-generator/12.1.1/finder-generator-12.1.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean-querybean/12.11.1/ebean-querybean-12.11.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean-ddl-generator/12.11.1/ebean-ddl-generator-12.11.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/twelvemonkeys/imageio/imageio-core/3.4.2/imageio-core-3.4.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/twelvemonkeys/imageio/imageio-jpeg/3.4.2/imageio-jpeg-3.4.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/twelvemonkeys/imageio/imageio-tiff/3.4.2/imageio-tiff-3.4.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-json_2.12/2.9.2/play-json_2.12-2.9.2.jar:/home/runner/.cache/coursier/v1/https/jcenter.bintray.com/io/crnk/crnk-core/3.0.20190714142556/crnk-core-3.0.20190714142556.jar:/home/runner/.cache/coursier/v1/https/jcenter.bintray.com/io/crnk/crnk-setup-guice/3.0.20190714142556/crnk-setup-guice-3.0.20190714142556.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/wildbit/java/postmark/1.2.1/postmark-1.2.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/j2html/j2html/1.4.0/j2html-1.4.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/freemarker/freemarker/2.3.29/freemarker-2.3.29.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-afterburner/2.10.0/jackson-module-afterburner-2.10.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/atteo/evo-inflector/1.2.2/evo-inflector-1.2.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/squareup/okhttp3/okhttp/4.5.0/okhttp-4.5.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/microsoft/azure/applicationinsights-core/2.6.0/applicationinsights-core-2.6.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/microsoft/azure/msal4j/1.6.1/msal4j-1.6.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/newrelic/agent/java/newrelic-agent/6.4.1/newrelic-agent-6.4.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/newrelic/agent/java/newrelic-api/6.4.1/newrelic-api-6.4.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/github/siahsang/red-utils/1.0.4/red-utils-1.0.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/redisson/redisson/3.16.6/redisson-3.16.6.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/javax/xml/bind/jaxb-api/2.3.1/jaxb-api-2.3.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/persistence/org.eclipse.persistence.moxy/2.7.3/org.eclipse.persistence.moxy-2.7.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/jakarta/xml/bind/jakarta.xml.bind-api/3.0.1/jakarta.xml.bind-api-3.0.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/sun/xml/bind/jaxb-impl/3.0.2/jaxb-impl-3.0.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/github/davidmoten/odata-client-msgraph/0.1.65/odata-client-msgraph-0.1.65.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/github/davidmoten/odata-client-runtime/0.1.65/odata-client-runtime-0.1.65.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-test_2.12/2.8.8/play-test_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/exparity/hamcrest-date/2.0.7/hamcrest-date-2.0.7.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/jsoup/jsoup/1.12.1/jsoup-1.12.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/htmlunit/2.36.0/htmlunit-2.36.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fiftyonred/mock-jedis/0.4.0/mock-jedis-0.4.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/github/jasminb/jsonapi-converter/0.9/jsonapi-converter-0.9.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/javassist/javassist/3.21.0-GA/javassist-3.21.0-GA.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-xml_2.12/1.2.0/scala-xml_2.12-1.2.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-jdbc-evolutions_2.12/2.8.0/play-jdbc-evolutions_2.12-2.8.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean/12.11.1/ebean-12.11.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean-agent/12.7.1/ebean-agent-12.7.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean-migration/12.11.0/ebean-migration-12.11.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/reflections/reflections/0.9.11/reflections-0.9.11.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play_2.12/2.8.8/play_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-streams_2.12/2.8.8/play-streams_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-http-core_2.12/10.1.14/akka-http-core_2.12-10.1.14.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-java_2.12/2.8.8/play-java_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-java8-compat_2.12/0.9.1/scala-java8-compat_2.12-0.9.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/net/jodah/typetools/0.6.1/typetools-0.6.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/hibernate/validator/hibernate-validator/6.1.7.Final/hibernate-validator-6.1.7.Final.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/springframework/spring-context/5.2.13.RELEASE/spring-context-5.2.13.RELEASE.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/springframework/spring-core/5.2.13.RELEASE/spring-core-5.2.13.RELEASE.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/springframework/spring-beans/5.2.13.RELEASE/spring-beans-5.2.13.RELEASE.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-jdbc_2.12/2.8.8/play-jdbc_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws_2.12/2.8.8/play-ws_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ahc-ws-standalone_2.12/2.1.3/play-ahc-ws-standalone_2.12-2.1.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/shaded-asynchttpclient/2.1.3/shaded-asynchttpclient-2.1.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/shaded-oauth/2.1.3/shaded-oauth-2.1.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/javax/cache/cache-api/1.1.1/cache-api-1.1.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/hibernate/javax/persistence/hibernate-jpa-2.1-api/1.0.2.Final/hibernate-jpa-2.1-api-1.0.2.Final.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/google/inject/guice/4.2.3/guice-4.2.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/google/inject/extensions/guice-assistedinject/4.2.3/guice-assistedinject-4.2.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-cache_2.12/2.8.8/play-cache_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/net/sf/ehcache/ehcache/2.10.6/ehcache-2.10.6.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/ehcache/jcache/1.0.1/jcache-1.0.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/flywaydb/flyway-core/7.14.0/flyway-core-7.14.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/slf4j/slf4j-api/1.7.32/slf4j-api-1.7.32.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/amazonaws/aws-java-sdk-kms/1.11.657/aws-java-sdk-kms-1.11.657.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/amazonaws/aws-java-sdk-core/1.11.657/aws-java-sdk-core-1.11.657.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/amazonaws/jmespath-java/1.11.657/jmespath-java-1.11.657.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-jexl3/3.1/commons-jexl3-3.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/commons-beanutils/commons-beanutils/1.9.3/commons-beanutils-1.9.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/slf4j/jcl-over-slf4j/1.7.30/jcl-over-slf4j-1.7.30.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/ch/qos/logback/logback-core/1.2.3/logback-core-1.2.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/poi/poi/4.0.1/poi-4.0.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/poi/poi-ooxml/4.0.1/poi-ooxml-4.0.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/bouncycastle/bcmail-jdk14/1.64/bcmail-jdk14-1.64.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/bouncycastle/bctsp-jdk14/1.46/bctsp-jdk14-1.46.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/bouncycastle/bcprov-jdk14/1.64/bcprov-jdk14-1.64.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/xerces/xercesImpl/2.12.0/xercesImpl-2.12.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/bouncycastle/bcmail-jdk14/138/bcmail-jdk14-138.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/bouncycastle/bcprov-jdk14/138/bcprov-jdk14-138.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/commons-digester/commons-digester/2.1/commons-digester-2.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/commons-logging/commons-logging/1.2/commons-logging-1.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-collections4/4.2/commons-collections4-4.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/jfree/jcommon/1.0.23/jcommon-1.0.23.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/jfree/jfreechart/1.0.19/jfreechart-1.0.19.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jdt/core/compiler/ecj/4.4.2/ecj-4.4.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/codehaus/castor/castor-xml/1.4.1/castor-xml-1.4.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-core/2.12.5/jackson-core-2.12.5.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-databind/2.11.4/jackson-databind-2.11.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-annotations/2.12.5/jackson-annotations-2.12.5.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/net/java/dev/jna/jna/4.1.0/jna-4.1.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/log4j/log4j/1.2.17/log4j-1.2.17.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/xmlgraphics/xmlgraphics-commons/1.4/xmlgraphics-commons-1.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/net/bytebuddy/byte-buddy/1.11.0/byte-buddy-1.11.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/net/bytebuddy/byte-buddy-agent/1.9.10/byte-buddy-agent-1.9.10.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/objenesis/objenesis/2.6/objenesis-2.6.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/sentry/sentry/1.7.28/sentry-1.7.28.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/json/json/20090211/json-20090211.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/google/code/gson/gson/2.8.5/gson-2.8.5.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/pdfbox/fontbox/2.0.17/fontbox-2.0.17.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/ow2/asm/asm/7.0/asm-7.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/ow2/asm/asm-tree/7.0/asm-tree-7.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean-ddl-runner/1.0/ebean-ddl-runner-1.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/twelvemonkeys/common/common-lang/3.4.2/common-lang-3.4.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/twelvemonkeys/common/common-io/3.4.2/common-io-3.4.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/twelvemonkeys/common/common-image/3.4.2/common-image-3.4.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/twelvemonkeys/imageio/imageio-metadata/3.4.2/imageio-metadata-3.4.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-functional_2.12/2.9.2/play-functional_2.12-2.9.2.jar:/home/runner/.sbt/boot/scala-2.12.10/lib/scala-reflect.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/datatype/jackson-datatype-jdk8/2.12.4/jackson-datatype-jdk8-2.12.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/datatype/jackson-datatype-jsr310/2.12.4/jackson-datatype-jsr310-2.12.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/glassfish/jersey/core/jersey-client/2.25.1/jersey-client-2.25.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/eu/medsea/mimeutil/mime-util/2.1.3/mime-util-2.1.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/squareup/okio/okio/2.5.0/okio-2.5.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/jetbrains/kotlin/kotlin-stdlib/1.3.70/kotlin-stdlib-1.3.70.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/nimbusds/oauth2-oidc-sdk/7.4/oauth2-oidc-sdk-7.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/netty/netty-common/4.1.70.Final/netty-common-4.1.70.Final.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/netty/netty-codec/4.1.70.Final/netty-codec-4.1.70.Final.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/netty/netty-buffer/4.1.70.Final/netty-buffer-4.1.70.Final.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/netty/netty-transport/4.1.70.Final/netty-transport-4.1.70.Final.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/netty/netty-resolver/4.1.70.Final/netty-resolver-4.1.70.Final.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/netty/netty-resolver-dns/4.1.70.Final/netty-resolver-dns-4.1.70.Final.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/netty/netty-handler/4.1.70.Final/netty-handler-4.1.70.Final.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/projectreactor/reactor-core/3.4.4/reactor-core-3.4.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/reactivestreams/reactive-streams/1.0.3/reactive-streams-1.0.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/reactivex/rxjava3/rxjava/3.0.12/rxjava-3.0.12.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/jboss/marshalling/jboss-marshalling/2.0.11.Final/jboss-marshalling-2.0.11.Final.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/jboss/marshalling/jboss-marshalling-river/2.0.11.Final/jboss-marshalling-river-2.0.11.Final.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/dataformat/jackson-dataformat-yaml/2.12.5/jackson-dataformat-yaml-2.12.5.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/jodd/jodd-bean/5.1.6/jodd-bean-5.1.6.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/javax/activation/javax.activation-api/1.2.0/javax.activation-api-1.2.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/persistence/org.eclipse.persistence.core/2.7.3/org.eclipse.persistence.core-2.7.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/javax/validation/validation-api/2.0.1.Final/validation-api-2.0.1.Final.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/javax/json/javax.json-api/1.1.2/javax.json-api-1.1.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/sun/activation/jakarta.activation/2.0.1/jakarta.activation-2.0.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/sun/xml/bind/jaxb-core/3.0.2/jaxb-core-3.0.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/github/davidmoten/odata-client-microsoft-client-builder/0.1.65/odata-client-microsoft-client-builder-0.1.65.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/github/davidmoten/guava-mini/0.1.3/guava-mini-0.1.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/httpcomponents/httpclient/4.5.13/httpclient-4.5.13.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/glassfish/jaxb/jaxb-runtime/3.0.2/jaxb-runtime-3.0.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/junit/junit/4.13.2/junit-4.13.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/novocode/junit-interface/0.11/junit-interface-0.11.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/google/guava/guava/28.2-jre/guava-28.2-jre.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/google/code/findbugs/jsr305/3.0.2/jsr305-3.0.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/fluentlenium/fluentlenium-core/3.7.1/fluentlenium-core-3.7.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/htmlunit-driver/2.36.0/htmlunit-driver-2.36.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-api/3.141.59/selenium-api-3.141.59.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-support/3.141.59/selenium-support-3.141.59.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-firefox-driver/3.141.59/selenium-firefox-driver-3.141.59.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/xalan/xalan/2.7.2/xalan-2.7.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/httpcomponents/httpmime/4.5.9/httpmime-4.5.9.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/htmlunit-core-js/2.36.0/htmlunit-core-js-2.36.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/neko-htmlunit/2.36.0/neko-htmlunit-2.36.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/htmlunit-cssparser/1.5.0/htmlunit-cssparser-1.5.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/commons-net/commons-net/3.6/commons-net-3.6.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/brotli/dec/0.1.2/dec-0.1.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/websocket/websocket-client/9.4.20.v20190813/websocket-client-9.4.20.v20190813.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/squareup/retrofit2/retrofit/2.1.0/retrofit-2.1.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-jdbc-api_2.12/2.8.8/play-jdbc-api_2.12-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean-datasource/7.0/ebean-datasource-7.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean-api/12.11.1/ebean-api-12.11.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean-core/12.11.1/ebean-core-12.11.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/avaje/classpath-scanner/6.0/classpath-scanner-6.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/build-link/2.8.8/build-link-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/slf4j/jul-to-slf4j/1.7.30/jul-to-slf4j-1.7.30.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-actor_2.12/2.6.14/akka-actor_2.12-2.6.14.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-actor-typed_2.12/2.6.14/akka-actor-typed_2.12-2.6.14.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-slf4j_2.12/2.6.14/akka-slf4j_2.12-2.6.14.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-serialization-jackson_2.12/2.6.14/akka-serialization-jackson_2.12-2.6.14.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/jsonwebtoken/jjwt/0.9.1/jjwt-0.9.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/jakarta/transaction/jakarta.transaction-api/1.3.3/jakarta.transaction-api-1.3.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/javax/inject/javax.inject/1/javax.inject-1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/ssl-config-core_2.12/0.4.2/ssl-config-core_2.12-0.4.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-parser-combinators_2.12/1.1.2/scala-parser-combinators_2.12-1.1.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-stream_2.12/2.6.14/akka-stream_2.12-2.6.14.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-parsing_2.12/10.1.14/akka-parsing_2.12-10.1.14.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/jakarta/validation/jakarta.validation-api/2.0.2/jakarta.validation-api-2.0.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/jboss/logging/jboss-logging/3.3.2.Final/jboss-logging-3.3.2.Final.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/classmate/1.3.4/classmate-1.3.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/zaxxer/HikariCP/3.4.5/HikariCP-3.4.5.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/googlecode/usc/jdbcdslog/1.0.6.2/jdbcdslog-1.0.6.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/tyrex/tyrex/1.0.1/tyrex-1.0.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws-standalone_2.12/2.1.3/play-ws-standalone_2.12-2.1.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws-standalone-xml_2.12/2.1.3/play-ws-standalone-xml_2.12-2.1.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws-standalone-json_2.12/2.1.3/play-ws-standalone-json_2.12-2.1.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/cachecontrol_2.12/2.0.0/cachecontrol_2.12-2.0.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/software/amazon/ion/ion-java/1.0.2/ion-java-1.0.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/dataformat/jackson-dataformat-cbor/2.11.4/jackson-dataformat-cbor-2.11.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/joda-time/joda-time/2.8.1/joda-time-2.8.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/commons-codec/commons-codec/1.11/commons-codec-1.11.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-math3/3.6.1/commons-math3-3.6.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/poi/poi-ooxml-schemas/4.0.1/poi-ooxml-schemas-4.0.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/github/virtuald/curvesapi/1.05/curvesapi-1.05.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/bouncycastle/bcpkix-jdk14/1.64/bcpkix-jdk14-1.64.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/codehaus/castor/castor-core/1.4.1/castor-core-1.4.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/javax/ws/rs/javax.ws.rs-api/2.0.1/javax.ws.rs-api-2.0.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/glassfish/jersey/core/jersey-common/2.25.1/jersey-common-2.25.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/glassfish/hk2/hk2-api/2.5.0-b32/hk2-api-2.5.0-b32.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/glassfish/hk2/external/javax.inject/2.5.0-b32/javax.inject-2.5.0-b32.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/glassfish/hk2/hk2-locator/2.5.0-b32/hk2-locator-2.5.0-b32.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/jetbrains/kotlin/kotlin-stdlib-common/1.3.70/kotlin-stdlib-common-1.3.70.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/jetbrains/annotations/13.0/annotations-13.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/github/stephenc/jcip/jcip-annotations/1.0-1/jcip-annotations-1.0-1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/nimbusds/content-type/2.0/content-type-2.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/net/minidev/json-smart/2.3/json-smart-2.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/nimbusds/lang-tag/1.4.4/lang-tag-1.4.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/nimbusds/nimbus-jose-jwt/8.14.1/nimbus-jose-jwt-8.14.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/sun/mail/javax.mail/1.6.1/javax.mail-1.6.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/netty/netty-codec-dns/4.1.70.Final/netty-codec-dns-4.1.70.Final.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/yaml/snakeyaml/1.27/snakeyaml-1.27.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/jodd/jodd-core/5.1.6/jodd-core-5.1.6.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/persistence/org.eclipse.persistence.asm/2.7.3/org.eclipse.persistence.asm-2.7.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/httpcomponents/httpcore/4.4.13/httpcore-4.4.13.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/glassfish/jaxb/jaxb-core/3.0.2/jaxb-core-3.0.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-sbt/test-interface/1.0/test-interface-1.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/checkerframework/checker-qual/2.10.0/checker-qual-2.10.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/google/errorprone/error_prone_annotations/2.3.4/error_prone_annotations-2.3.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-remote-driver/3.141.59/selenium-remote-driver-3.141.59.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/atteo/classindex/classindex/3.4/classindex-3.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-exec/1.3/commons-exec-1.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/xalan/serializer/2.7.2/serializer-2.7.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-client/9.4.20.v20190813/jetty-client-9.4.20.v20190813.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-xml/9.4.20.v20190813/jetty-xml-9.4.20.v20190813.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-util/9.4.20.v20190813/jetty-util-9.4.20.v20190813.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-io/9.4.20.v20190813/jetty-io-9.4.20.v20190813.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/websocket/websocket-common/9.4.20.v20190813/websocket-common-9.4.20.v20190813.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean-datasource-api/7.0/ebean-datasource-api-7.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/avaje/avaje-config/1.3/avaje-config-1.3.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/persistence-api/2.2.4/persistence-api-2.2.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean-annotation/7.2/ebean-annotation-7.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean-types/2.1/ebean-types-2.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean-migration-auto/1.1/ebean-migration-auto-1.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean-core-type/12.11.1/ebean-core-type-12.11.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/ebean/ebean-externalmapping-api/12.11.1/ebean-externalmapping-api-12.11.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/antlr/antlr4-runtime/4.8-1/antlr4-runtime-4.8-1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/io/avaje/classpath-scanner-api/6.0/classpath-scanner-api-6.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-exceptions/2.8.8/play-exceptions-2.8.8.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/config/1.4.0/config-1.4.0.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-scala_2.12/2.11.4/jackson-module-scala_2.12-2.11.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-parameter-names/2.11.4/jackson-module-parameter-names-2.11.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/lz4/lz4-java/1.7.1/lz4-java-1.7.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-protobuf-v3_2.12/2.6.14/akka-protobuf-v3_2.12-2.6.14.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/xmlbeans/xmlbeans/3.0.2/xmlbeans-3.0.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/javax/annotation/javax.annotation-api/1.2/javax.annotation-api-1.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/glassfish/jersey/bundles/repackaged/jersey-guava/2.25.1/jersey-guava-2.25.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/glassfish/hk2/osgi-resource-locator/1.0.1/osgi-resource-locator-1.0.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/glassfish/hk2/hk2-utils/2.5.0-b32/hk2-utils-2.5.0-b32.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/glassfish/hk2/external/aopalliance-repackaged/2.5.0-b32/aopalliance-repackaged-2.5.0-b32.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/net/minidev/accessors-smart/1.2/accessors-smart-1.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/javax/activation/activation/1.1/activation-1.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/glassfish/jaxb/txw2/3.0.2/txw2-3.0.2.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/sun/istack/istack-commons-runtime/4.0.1/istack-commons-runtime-4.0.1.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-http/9.4.20.v20190813/jetty-http-9.4.20.v20190813.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/websocket/websocket-api/9.4.20.v20190813/websocket-api-9.4.20.v20190813.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-paranamer/2.11.4/jackson-module-paranamer-2.11.4.jar:/home/runner/.cache/coursier/v1/https/repo1.maven.org/maven2/com/thoughtworks/paranamer/paranamer/2.8/paranamer-2.8.jar:/home/runner/weldnote_backend/target/web/public/test:/home/runner/.sbt/boot/scala-2.12.10/org.scala-sbt/sbt/1.3.13/test-agent-1.3.13.jar:/home/runner/.sbt/boot/scala-2.12.10/org.scala-sbt/sbt/1.3.13/test-interface-1.0.jar sbt.ForkMain 36769 failed with exit code 134\r\n> [error] (Test / test) sbt.TestsFailedException: Tests unsuccessful"
      },
      {
        "user": "mrniko",
        "created_at": "2022-06-09T07:14:41Z",
        "body": "Unable to reproduce."
      }
    ]
  },
  {
    "number": 3995,
    "title": "Why Redisson is  connect  Timeout?",
    "created_at": "2021-11-30T10:09:09Z",
    "closed_at": "2021-12-28T10:10:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3995",
    "body": "[DC-STG][ERROR][sort][2021-11-28 15:02:10.497][]-[]-[][Thread-12] (ThreadPoolAgent.java:55)[get()] -> 系统异常\r\njava.util.concurrent.ExecutionException: org.springframework.dao.InvalidDataAccessApiUsageException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=19, freeConnectionsCounter=value:59:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.53.179:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@131875383 [redisClient=[addr=redis://192.168.53.179:6379], channel=[id: 0x699c31ec, L:/100.111.156.155:48866 - R:192.168.53.179/192.168.53.179:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@18ca11e9(failure: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://192.168.53.179:6379])], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]], command: (GET), params: [[115, 122, 45, 100, 99, 58, 115, 111, 114, 116, ...]] after 3 retry attempts; nested exception is org.redisson.client.RedisTimeoutException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=19, freeConnectionsCounter=value:59:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.53.179:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@131875383 [redisClient=[addr=redis://192.168.53.179:6379], channel=[id: 0x699c31ec, L:/100.111.156.155:48866 - R:192.168.53.179/192.168.53.179:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@18ca11e9(failure: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://192.168.53.179:6379])], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]], command: (GET), params: [[115, 122, 45, 100, 99, 58, 115, 111, 114, 116, ...]] after 3 retry attempts\r\n        at java.util.concurrent.FutureTask.report(FutureTask.java:122) ~[?:1.8.0_91]\r\n        at java.util.concurrent.FutureTask.get(FutureTask.java:192) ~[?:1.8.0_91]\r\n        at com.szatc.biz.service.sort.common.agent.ThreadPoolAgent.get(ThreadPoolAgent.java:52) [classes!/:1.0.0-SNAPSHOT]\r\n        at com.szatc.biz.service.sort.sort.impl.DataCacheImpl.init(DataCacheImpl.java:135) [classes!/:1.0.0-SNAPSHOT]\r\n        at com.szatc.biz.service.sort.sort.SortManagerCommon.setTime(SortManagerCommon.java:42) [classes!/:1.0.0-SNAPSHOT]\r\n        at com.szatc.biz.service.sort.sort.impl.SortServiceImpl.sortRealtime(SortServiceImpl.java:63) [classes!/:1.0.0-SNAPSHOT]\r\n        at com.szatc.biz.service.sort.controller.job.SortJobHandler.sortRealTime(SortJobHandler.java:109) [classes!/:1.0.0-SNAPSHOT]\r\n        at sun.reflect.GeneratedMethodAccessor579.invoke(Unknown Source) ~[?:?]\r\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_91]\r\n        at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_91]\r\n        at com.xxl.job.core.handler.impl.MethodJobHandler.execute(MethodJobHandler.java:29) [xxl-job-core-2.3.0.jar!/:?]\r\n        at com.xxl.job.core.thread.JobThread.run(JobThread.java:163) [xxl-job-core-2.3.0.jar!/:?]\r\nCaused by: org.springframework.dao.InvalidDataAccessApiUsageException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=19, freeConnectionsCounter=value:59:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.53.179:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@131875383 [redisClient=[addr=redis://192.168.53.179:6379], channel=[id: 0x699c31ec, L:/100.111.156.155:48866 - R:192.168.53.179/192.168.53.179:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@18ca11e9(failure: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://192.168.53.179:6379])], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]], command: (GET), params: [[115, 122, 45, 100, 99, 58, 115, 111, 114, 116, ...]] after 3 retry attempts; nested exception is org.redisson.client.RedisTimeoutException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=19, freeConnectionsCounter=value:59:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.53.179:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@131875383 [redisClient=[addr=redis://192.168.53.179:6379], channel=[id: 0x699c31ec, L:/100.111.156.155:48866 - R:192.168.53.179/192.168.53.179:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@18ca11e9(failure: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://192.168.53.179:6379])], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]], command: (GET), params: [[115, 122, 45, 100, 99, 58, 115, 111, 114, 116, ...]] after 3 retry attempts\r\n        at org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:48) ~[redisson-spring-data-21-3.11.2.jar!/:3.11.2]\r\n        at org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:35) ~[redisson-spring-data-21-3.11.2.jar!/:3.11.2]\r\n        at org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:44) ~[spring-data-redis-2.1.8.RELEASE.jar!/:2.1.8.RELEASE]\r\n        at org.redisson.spring.data.connection.RedissonConnection.transform(RedissonConnection.java:234) ~[redisson-spring-data-21-3.11.2.jar!/:3.11.2]\r\n        at org.redisson.spring.data.connection.RedissonConnection.syncFuture(RedissonConnection.java:229) ~[redisson-spring-data-21-3.11.2.jar!/:3.11.2]\r\n        at org.redisson.spring.data.connection.RedissonConnection.sync(RedissonConnection.java:459) ~[redisson-spring-data-21-3.11.2.jar!/:3.11.2]\r\n        at org.redisson.spring.data.connection.RedissonConnection.read(RedissonConnection.java:840) ~[redisson-spring-data-21-3.11.2.jar!/:3.11.2]\r\n        at org.redisson.spring.data.connection.RedissonConnection.get(RedissonConnection.java:574) ~[redisson-spring-data-21-3.11.2.jar!/:3.11.2]\r\n        at org.springframework.data.redis.cache.DefaultRedisCacheWriter.lambda$get$1(DefaultRedisCacheWriter.java:109) ~[spring-data-redis-2.1.8.RELEASE.jar!/:2.1.8.RELEASE]\r\n        at org.springframework.data.redis.cache.DefaultRedisCacheWriter.execute(DefaultRedisCacheWriter.java:242) ~[spring-data-redis-2.1.8.RELEASE.jar!/:2.1.8.RELEASE]\r\n        at org.springframework.data.redis.cache.DefaultRedisCacheWriter.get(DefaultRedisCacheWriter.java:109) ~[spring-data-redis-2.1.8.RELEASE.jar!/:2.1.8.RELEASE]\r\n        at org.springframework.data.redis.cache.RedisCache.lookup(RedisCache.java:82) ~[spring-data-redis-2.1.8.RELEASE.jar!/:2.1.8.RELEASE]\r\n        at org.springframework.cache.support.AbstractValueAdaptingCache.get(AbstractValueAdaptingCache.java:58) ~[spring-context-5.1.9.RELEASE.jar!/:5.1.9.RELEASE]\r\n        at org.springframework.cache.interceptor.AbstractCacheInvoker.doGet(AbstractCacheInvoker.java:73) ~[spring-context-5.1.9.RELEASE.jar!/:5.1.9.RELEASE]\r\n        at org.springframework.cache.interceptor.CacheAspectSupport.findInCaches(CacheAspectSupport.java:554) ~[spring-context-5.1.9.RELEASE.jar!/:5.1.9.RELEASE]\r\n        at org.springframework.cache.interceptor.CacheAspectSupport.findCachedItem(CacheAspectSupport.java:519) ~[spring-context-5.1.9.RELEASE.jar!/:5.1.9.RELEASE]\r\n        at org.springframework.cache.interceptor.CacheAspectSupport.execute(CacheAspectSupport.java:401) ~[spring-context-5.1.9.RELEASE.jar!/:5.1.9.RELEASE]\r\n        at org.springframework.cache.interceptor.CacheAspectSupport.execute(CacheAspectSupport.java:345) ~[spring-context-5.1.9.RELEASE.jar!/:5.1.9.RELEASE]\r\n        at org.springframework.cache.interceptor.CacheInterceptor.invoke(CacheInterceptor.java:61) ~[spring-context-5.1.9.RELEASE.jar!/:5.1.9.RELEASE]\r\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE]\r\n        at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) ~[spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE]\r\n        at com.szatc.biz.service.sort.service.impl.PointsKeywordServiceImpl$$EnhancerBySpringCGLIB$$d538eda5.selectAll(<generated>) ~[classes!/:1.0.0-SNAPSHOT]\r\n        at com.szatc.biz.service.sort.sort.impl.DataCacheImpl.lambda$init$0(DataCacheImpl.java:117) ~[classes!/:1.0.0-SNAPSHOT]\r\n        at org.springframework.cloud.sleuth.instrument.async.TraceCallable.call(TraceCallable.java:70) ~[spring-cloud-sleuth-core-2.1.1.RELEASE.jar!/:2.1.1.RELEASE]\r\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_91]\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) ~[?:1.8.0_91]\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~[?:1.8.0_91]\r\n        at java.lang.Thread.run(Thread.java:745) ~[?:1.8.0_91]\r\nCaused by: org.redisson.client.RedisTimeoutException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=19, freeConnectionsCounter=value:59:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.53.179:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@131875383 [redisClient=[addr=redis://192.168.53.179:6379], channel=[id: 0x699c31ec, L:/100.111.156.155:48866 - R:192.168.53.179/192.168.53.179:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@18ca11e9(failure: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://192.168.53.179:6379])], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]], command: (GET), params: [[115, 122, 45, 100, 99, 58, 115, 111, 114, 116, ...]] after 3 retry attempts\r\n        at org.redisson.command.CommandAsyncService$6.run(CommandAsyncService.java:715) ~[redisson-3.11.2.jar!/:3.11.2]\r\n        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672) ~[netty-all-4.1.58.Final.jar!/:4.1.58.Final]\r\n        at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747) ~[netty-all-4.1.58.Final.jar!/:4.1.58.Final]\r\n        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472) ~[netty-all-4.1.58.Final.jar!/:4.1.58.Final]\r\n        at java.lang.Thread.run(Thread.java:745) ~[?:1.8.0_91]",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3995/comments",
    "author": "larry6",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-12-03T08:53:22Z",
        "body": "Did you try to increase/reduce connections pool size and/or increase netty threads?"
      }
    ]
  },
  {
    "number": 3989,
    "title": " ERR Error running script (call to f_0fd7cdd6c1224471b29d6f7fc503462f3b252f12): @user_script:1: user_script:1: bad argument #2 to 'unpack' (data string too short",
    "created_at": "2021-11-26T18:24:24Z",
    "closed_at": "2021-11-30T06:09:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3989",
    "body": "I am unable to understand this error. Please help.\r\n` Execution exception[[RedisException: ERR Error running script (call to f_0fd7cdd6c1224471b29d6f7fc503462f3b252f12): @user_script:1: user_script:1: bad argument #2 to 'unpack' (data string too short) . channel: [id: 0xd4089e92, L:/10.212.134.41:60921 - R:core-dev-redis.6cbkbd.0001.aps1.cache.amazonaws.com/192.168.2.46:6379] command: (EVAL), params: [local result = {}; local idleKeys = {}; local res; if (#ARGV == 4) then  res = redis.call('hscan', K..., 3, ALLUS_XXX, redisson__timeout__set:{ALLUS_XXX}, redisson__idle__set:{ALLUS_XXX}, 1637948919729, 0, 10]]]\\\r\n`\r\n\r\nI am trying to read using `getMapCache(ALLUS_XXX)`\r\n\r\nalso, in redis cli if I do `hgetall ALLUS_XXX`.  This is the output\r\n\r\n```\r\n 1) \"3\"\r\n 2) \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"3\\\",\\\"ax\\\":\\\"21\\\",\\\"bp\\\":331.27,\\\"ap\\\":331.3,\\\"bs\\\":2,\\\"as\\\":1,\\\"t\\\":\\\"1637948895747\\\",\\\"q\\\":\\\"42893371\\\",\\\"z\\\":3}\"\r\n 3) \"2\"\r\n 4) \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"2\\\",\\\"ax\\\":\\\"19\\\",\\\"bp\\\":330.03,\\\"ap\\\":330.13,\\\"bs\\\":2,\\\"as\\\":3,\\\"t\\\":\\\"1637949585689\\\",\\\"q\\\":\\\"46053648\\\",\\\"z\\\":3}\"\r\n 5) \"12\"\r\n 6) \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"12\\\",\\\"ax\\\":\\\"11\\\",\\\"bp\\\":329.91,\\\"ap\\\":330.25,\\\"bs\\\":1,\\\"as\\\":12,\\\"t\\\":\\\"1637949676507\\\",\\\"q\\\":\\\"46258127\\\",\\\"z\\\":3}\"\r\n 7) \"9\"\r\n 8) \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"9\\\",\\\"ax\\\":\\\"15\\\",\\\"bp\\\":330.43,\\\"ap\\\":330.44,\\\"bs\\\":3,\\\"as\\\":3,\\\"t\\\":\\\"1637949113455\\\",\\\"q\\\":\\\"43838492\\\",\\\"z\\\":3}\"\r\n 9) \"15\"\r\n10) \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"15\\\",\\\"ax\\\":\\\"12\\\",\\\"bp\\\":330.34,\\\"ap\\\":330.37,\\\"bs\\\":2,\\\"as\\\":4,\\\"t\\\":\\\"1637949549028\\\",\\\"q\\\":\\\"45809932\\\",\\\"z\\\":3}\"\r\n11) \"10\"\r\n12) \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"10\\\",\\\"ax\\\":\\\"12\\\",\\\"bp\\\":330.26,\\\"ap\\\":330.37,\\\"bs\\\":1,\\\"as\\\":2,\\\"t\\\":\\\"1637949585833\\\",\\\"q\\\":\\\"46055016\\\",\\\"z\\\":3}\"\r\n13) \"18\"\r\n14) \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"18\\\",\\\"ax\\\":\\\"11\\\",\\\"bp\\\":330.15,\\\"ap\\\":330.25,\\\"bs\\\":2,\\\"as\\\":12,\\\"t\\\":\\\"1637949683953\\\",\\\"q\\\":\\\"46258667\\\",\\\"z\\\":3}\"\r\n15) \"1\"\r\n16) \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"1\\\",\\\"ax\\\":\\\"17\\\",\\\"bp\\\":330.21,\\\"ap\\\":330.31,\\\"bs\\\":4,\\\"as\\\":1,\\\"t\\\":\\\"1637949583379\\\",\\\"q\\\":\\\"46033150\\\",\\\"z\\\":3}\"\r\n17) \"11\"\r\n18) \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"11\\\",\\\"ax\\\":\\\"12\\\",\\\"bp\\\":329.91,\\\"ap\\\":330.2,\\\"bs\\\":4,\\\"as\\\":1,\\\"t\\\":\\\"1637949688637\\\",\\\"q\\\":\\\"46259504\\\",\\\"z\\\":3}\"\r\n19) \"7\"\r\n20) \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"7\\\",\\\"ax\\\":\\\"11\\\",\\\"bp\\\":330.15,\\\"ap\\\":330.25,\\\"bs\\\":2,\\\"as\\\":12,\\\"t\\\":\\\"1637949684316\\\",\\\"q\\\":\\\"46258719\\\",\\\"z\\\":3}\"\r\n21) \"20\"\r\n22) \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"20\\\",\\\"ax\\\":\\\"12\\\",\\\"bp\\\":330.11,\\\"ap\\\":330.26,\\\"bs\\\":1,\\\"as\\\":1,\\\"t\\\":\\\"1637949586232\\\",\\\"q\\\":\\\"46058248\\\",\\\"z\\\":3}\"\r\n23) \"19\"\r\n24) \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"19\\\",\\\"ax\\\":\\\"11\\\",\\\"bp\\\":329.91,\\\"ap\\\":330.25,\\\"bs\\\":2,\\\"as\\\":12,\\\"t\\\":\\\"1637949676537\\\",\\\"q\\\":\\\"46258138\\\",\\\"z\\\":3}\"\r\n25) \"8\"\r\n26) \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"8\\\",\\\"ax\\\":\\\"11\\\",\\\"bp\\\":330.06,\\\"ap\\\":330.25,\\\"bs\\\":1,\\\"as\\\":12,\\\"t\\\":\\\"1637949685035\\\",\\\"q\\\":\\\"46258880\\\",\\\"z\\\":3}\"\r\n27) \"17\"\r\n28) \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"17\\\",\\\"ax\\\":\\\"17\\\",\\\"bp\\\":329.37,\\\"ap\\\":330.16,\\\"bs\\\":2,\\\"as\\\":2,\\\"t\\\":\\\"1637949606270\\\",\\\"q\\\":\\\"46241118\\\",\\\"z\\\":3}\"\r\n29) \"21\"\r\n30) \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"21\\\",\\\"ax\\\":\\\"12\\\",\\\"bp\\\":330.9,\\\"ap\\\":331.09,\\\"bs\\\":1,\\\"as\\\":1,\\\"t\\\":\\\"1637949581667\\\",\\\"q\\\":\\\"46012327\\\",\\\"z\\\":3}\"\r\n```\r\n\r\n\r\nThis is easlily reproducible,\r\n1. ` HMSET ALLUS_XXX 1 \"{\\\"ev\\\":\\\"Q\\\",\\\"sym\\\":\\\"XXX\\\",\\\"bx\\\":\\\"1\\\",\\\"ax\\\":\\\"20\\\",\\\"bp\\\":157.2,\\\"ap\\\":157.21,\\\"bs\\\":5,\\\"as\\\":1,\\\"t\\\":\\\"1637949207844\\\",\\\"q\\\":\\\"60303179\\\",\\\"z\\\":3}\"`\r\n2. Now try to access this using redisson `getMapCache(\"ALLUS_XXX\").readAllEntrySet()`",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3989/comments",
    "author": "ashwinreal",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-11-27T05:38:02Z",
        "body": "use the same codec for data store and reading"
      },
      {
        "user": "ashwinreal",
        "created_at": "2021-11-27T08:21:47Z",
        "body": "> use the same codec for data store and reading\r\n\r\nWhat is the codec when we add keys using redis-cli  and want to read using redisson  @mrniko ?  I tried a few at random did not work"
      },
      {
        "user": "SplotyCode",
        "created_at": "2021-11-27T09:15:05Z",
        "body": "Have you tried StringCodec?"
      },
      {
        "user": "ashwinreal",
        "created_at": "2021-11-27T09:17:17Z",
        "body": " @mrniko  @SplotyCode i have tried both\r\n` redisService.client.getMapCache(key, StringCodec.INSTANCE ).readAllEntrySet()\r\n      redisService.client.getMapCache(key, ByteArrayCodec.INSTANCE ).readAllEntrySet()\r\n`"
      },
      {
        "user": "ashwinreal",
        "created_at": "2021-11-27T12:05:07Z",
        "body": "I feel this should not be hard to do , there should be a codec already defined for this ... all I am trying to do is `HMSET test_key 1 \"123\"\r\n` \r\nand then read this using redission. Somehow I am not getting any of the codecs to work for this use case . \r\nDo I need to define a custom codec for this ? Pls suggest @mrniko @SplotyCode "
      },
      {
        "user": "ashwinreal",
        "created_at": "2021-11-28T16:16:26Z",
        "body": "@mrniko @SplotyCode I am really stuck here . Any suggestions pls ?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-11-29T05:48:07Z",
        "body": "you can insert/update RMapCache entries only through its API or try RMap object"
      },
      {
        "user": "ashwinreal",
        "created_at": "2021-11-30T18:27:34Z",
        "body": "yes, this works \r\n`client.getMap(key, StringCodec.INSTANCE).readAllEntrySet`\r\nThanks @mrniko "
      },
      {
        "user": "chanhengseang3",
        "created_at": "2024-06-25T06:29:38Z",
        "body": "I got this error after added StringCodec.INSTANCE\r\n`redissonClient.getBoundedBlockingQueue(\"key\", StringCodec.INSTANCE)`\r\n```\r\ncom.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: 65\r\n\tat com.esotericsoftware.kryo.util.DefaultClassResolver.readClass(DefaultClassResolver.java:159)\r\n\tat com.esotericsoftware.kryo.Kryo.readClass(Kryo.java:758)\r\n\tat com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:869)\r\n\tat org.redisson.codec.Kryo5Codec$4.decode(Kryo5Codec.java:144)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:433)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:490)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:442)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:216)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:144)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:120)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:529)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:840)\r\n```"
      }
    ]
  },
  {
    "number": 3988,
    "title": "Why Redisson is unable to connect?",
    "created_at": "2021-11-26T16:29:51Z",
    "closed_at": "2021-12-28T10:10:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3988",
    "body": "On connection with redis I'm getting this:\r\n\r\norg.redisson.client.RedisConnectionException: Unable to connect to Redis server: IP/IP:6379\r\n        at org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:158) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]\r\n        at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]\r\n        at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:313) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]\r\n        at org.redisson.connection.pool.ConnectionPool.lambda$createConnection$3(ConnectionPool.java:279) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]\r\n        at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]\r\n        at org.redisson.client.RedisClient$2$1.run(RedisClient.java:242) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]\r\n        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at java.lang.Thread.run(Thread.java:831) [?:?]\r\nCaused by: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (AUTH), params: (password masked), Redis client: [addr=redis://IP:6379]\r\n        at org.redisson.client.RedisConnection.lambda$async$1(RedisConnection.java:251) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]\r\n        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:669) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:744) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:469) ~[patched_1.17.1.jar:git-Airplane-92]",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3988/comments",
    "author": "IM-IgniteDEV",
    "comments": [
      {
        "user": "SplotyCode",
        "created_at": "2021-11-27T09:17:32Z",
        "body": "Can you connect with redis-cli -h to the server from that host?"
      },
      {
        "user": "IM-IgniteDEV",
        "created_at": "2021-11-27T13:46:39Z",
        "body": "@SplotyCode Yes, I can connect."
      },
      {
        "user": "IM-IgniteDEV",
        "created_at": "2021-11-29T02:57:34Z",
        "body": "Any Ideas?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-11-29T05:49:57Z",
        "body": "is there any firewall which deny connecting for JVM?"
      },
      {
        "user": "IM-IgniteDEV",
        "created_at": "2021-11-29T11:25:55Z",
        "body": "`[12:21:49 WARN]: [io.netty.util.concurrent.DefaultPromise] An exception was thrown by org.redisson.client.RedisClient$2.operationComplete()\r\njava.util.concurrent.RejectedExecutionException: event executor terminated\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor.reject(SingleThreadEventExecutor.java:926) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor.offerTask(SingleThreadEventExecutor.java:353) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor.addTask(SingleThreadEventExecutor.java:346) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor.execute(SingleThreadEventExecutor.java:828) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor.execute(SingleThreadEventExecutor.java:818) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.AbstractEventExecutorGroup.execute(AbstractEventExecutorGroup.java:115) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at org.redisson.client.RedisClient$2.operationComplete(RedisClient.java:249) ~[CuriosLibrary-1.1.0-BETA-shaded(2).jar:?]\r\n        at org.redisson.client.RedisClient$2.operationComplete(RedisClient.java:222) ~[CuriosLibrary-1.1.0-BETA-shaded(2).jar:?]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.channel.nio.AbstractNioChannel.doClose(AbstractNioChannel.java:502) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.channel.socket.nio.NioSocketChannel.doClose(NioSocketChannel.java:342) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.channel.AbstractChannel$AbstractUnsafe.doClose0(AbstractChannel.java:772) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.channel.AbstractChannel$AbstractUnsafe.close(AbstractChannel.java:749) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.channel.AbstractChannel$AbstractUnsafe.close(AbstractChannel.java:620) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.channel.nio.NioEventLoop.closeAll(NioEventLoop.java:769) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:526) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [patched_1.17.1.jar:git-Airplane-92]\r\n        at java.lang.Thread.run(Thread.java:831) [?:?]\r\n[12:21:49 ERROR]: Could not pass event AsyncPlayerPreLoginEvent to v1.1.0-BETA\r\norg.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 3 of 24 were initialized. Redis server: X:X:6379\r\n        at org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:158) ~[CuriosLibrary-1.1.0-BETA-shaded(2).jar:?]\r\n        at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183) ~[CuriosLibrary-1.1.0-BETA-shaded(2).jar:?]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96) ~[CuriosLibrary-1.1.0-BETA-shaded(2).jar:?]\r\n        at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:313) ~[CuriosLibrary-1.1.0-BETA-shaded(2).jar:?]\r\n        at org.redisson.connection.pool.ConnectionPool.lambda$createConnection$3(ConnectionPool.java:279) ~[CuriosLibrary-1.1.0-BETA-shaded(2).jar:?]\r\n        at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183) ~[CuriosLibrary-1.1.0-BETA-shaded(2).jar:?]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96) ~[CuriosLibrary-1.1.0-BETA-shaded(2).jar:?]\r\n        at org.redisson.client.RedisClient$2$1.run(RedisClient.java:242) ~[CuriosLibrary-1.1.0-BETA-shaded(2).jar:?]\r\n        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at java.lang.Thread.run(Thread.java:831) [?:?]\r\nCaused by: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (AUTH), params: (password masked), Redis client: [addr=redis://X:6379]\r\n        at org.redisson.client.RedisConnection.lambda$async$1(RedisConnection.java:251) ~[CuriosLibrary-1.1.0-BETA-shaded(2).jar:?]\r\n        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:669) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:744) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:469) ~[patched_1.17.1.jar:git-Airplane-92]\r\n        ... 2 more`"
      },
      {
        "user": "IM-IgniteDEV",
        "created_at": "2021-11-29T11:58:15Z",
        "body": "> is there any firewall which deny connecting for JVM?\r\n\r\nPort opened even whole firewall disabled, not working."
      },
      {
        "user": "mrniko",
        "created_at": "2021-12-03T09:08:41Z",
        "body": "Sorry, unable to reproduce it. Seems a network problem."
      }
    ]
  },
  {
    "number": 3986,
    "title": "Codec ",
    "created_at": "2021-11-26T03:31:04Z",
    "closed_at": "2021-12-03T09:09:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3986",
    "body": "That code format is stable and I see a change in the code format",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3986/comments",
    "author": "wl980868110",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-11-26T07:13:52Z",
        "body": "can you provide more details about the issue?"
      }
    ]
  },
  {
    "number": 3985,
    "title": "java.lang.IllegalArgumentException: com.fasterxml.jackson.core.JsonParseException: Unrecognized token 'local': was expecting (JSON String, Number, Array, Object or token 'null', 'true' or 'false')  at [Source: (String)\"local.user@reg.com\"; line: 1, column: 6]",
    "created_at": "2021-11-25T23:04:50Z",
    "closed_at": "2021-12-03T09:09:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3985",
    "body": "Hello all i am trying to access json filed in criteria query but getting above error could you please help me for the same.\r\n\r\nsubquery.select(root).where(this.criteriaBuilder.equal((packageRoot.get(\"publis\")), userEmail));\r\n\r\nhere publis is the json in repository \r\n\r\n@CreatedBy\r\n\t@Column(name = \"pub_by\", columnDefinition = \"jsonb\", updatable = false)\r\n\t@Type(type = \"jsonb\")\r\n\tprivate User publis;\r\n\r\n\r\nand error is below\r\n\r\njava.lang.IllegalArgumentException: com.fasterxml.jackson.core.JsonParseException: Unrecognized token 'local': was expecting (JSON String, Number, Array, Object or token 'null', 'true' or 'false')\r\n at [Source: (String)\"local.user@registry.com\"; line: 1, column: 6]\r\n\tat com.vladmihalcea.hibernate.type.util.ObjectMapperWrapper.toJsonNode(ObjectMapperWrapper.java:68) ~[hibernate-types-52-2.4.3.jar:na]\r\n\tat com.vladmihalcea.hibernate.type.json.internal.JsonTypeDescriptor.unwrap(JsonTypeDescriptor.java:105) ~[hibernate-types-52-2.4.3.jar:na]\r\n\tat com.vladmihalcea.hibernate.type.json.internal.JsonBinarySqlTypeDescriptor$1.doBind(JsonBinarySqlTypeDescriptor.java:25) ~[hibernate-types-52-2.4.3.jar:na]\r\n\tat org.hibernate.type.descriptor.sql.BasicBinder.bind(BasicBinder.java:73) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.type.AbstractStandardBasicType.nullSafeSet(AbstractStandardBasicType.java:276) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.type.AbstractStandardBasicType.nullSafeSet(AbstractStandardBasicType.java:271) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.param.NamedParameterSpecification.bind(NamedParameterSpecification.java:53) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.loader.hql.QueryLoader.bindParameterValues(QueryLoader.java:648) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.loader.Loader.bindPreparedStatement(Loader.java:2125) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.loader.Loader.prepareQueryStatement(Loader.java:2102) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.loader.Loader.executeQueryStatement(Loader.java:2034) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.loader.Loader.executeQueryStatement(Loader.java:2012) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.loader.Loader.doQuery(Loader.java:948) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.loader.Loader.doQueryAndInitializeNonLazyCollections(Loader.java:349) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.loader.Loader.doList(Loader.java:2843) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.loader.Loader.doList(Loader.java:2825) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.loader.Loader.listIgnoreQueryCache(Loader.java:2657) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.loader.Loader.list(Loader.java:2652) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.loader.hql.QueryLoader.list(QueryLoader.java:506) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.hql.internal.ast.QueryTranslatorImpl.list(QueryTranslatorImpl.java:400) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.engine.query.spi.HQLQueryPlan.performList(HQLQueryPlan.java:219) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.internal.SessionImpl.list(SessionImpl.java:1414) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.query.internal.AbstractProducedQuery.doList(AbstractProducedQuery.java:1636) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.query.internal.AbstractProducedQuery.list(AbstractProducedQuery.java:1604) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.query.Query.getResultList(Query.java:165) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat org.hibernate.query.criteria.internal.compile.CriteriaQueryTypeQueryAdapter.getResultList(CriteriaQueryTypeQueryAdapter.java:76) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]\r\n\tat com.sap.apac.lcnc.library.repository.LibraryArtifactRepositoryCustomImpl.findAllArtifactsWithFilter(LibraryArtifactRepositoryCustomImpl.java:104) ~[classes/:na]\r\n\tat com.sap.apac.lcnc.library.repository.LibraryArtifactRepositoryCustomImpl$$FastClassBySpringCGLIB$$e8ae07f5.invoke(<generated>) ~[classes/:na]\r\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.3.12.jar:5.3.12]\r\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:783) ~[spring-aop-5.3.12.jar:5.3.12]\r\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.3.12.jar:5.3.12]\r\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:753) ~[spring-aop-5.3.12.jar:5.3.12]\r\n\tat org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:137) ~[spring-tx-5.3.12.jar:5.3.12]\r\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.3.12.jar:5.3.12]\r\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:753) ~[spring-aop-5.3.12.jar:5.3.12]\r\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:698) ~[spring-aop-5.3.12.jar:5.3.12]\r\n\tat com.sap.apac.lcnc.library.repository.LibraryArtifactRepositoryCustomImpl$$EnhancerBySpringCGLIB$$bac61a19.findAllArtifactsWithFilter(<generated>) ~[classes/:na]\r\n\tat com.sap.apac.lcnc.library.service.LibraryService.getAllArtifacts(LibraryService.java:107) ~[classes/:na]\r\n\tat com.sap.apac.lcnc.library.service.LibraryService$$FastClassBySpringCGLIB$$bbd19e44.invoke(<generated>) ~[classes/:na]\r\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.3.12.jar:5.3.12]\r\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689) ~[spring-aop-5.3.12.jar:5.3.12]\r\n\tat com.sap.apac.lcnc.library.service.LibraryService$$EnhancerBySpringCGLIB$$2f8e75eb.getAllArtifacts(<generated>) ~[classes/:na]\r\n\tat com.sap.apac.lcnc.library.controller.LibraryController.getArtifacts(LibraryController.java:62) ~[classes/:na]\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]\r\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]\r\n\tat org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205) ~[spring-web-5.3.12.jar:5.3.12]\r\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150) ~[spring-web-5.3.12.jar:5.3.12]\r\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117) ~[spring-webmvc-5.3.12.jar:5.3.12]\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) ~[spring-webmvc-5.3.12.jar:5.3.12]\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808) ~[spring-webmvc-5.3.12.jar:5.3.12]\r\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.3.12.jar:5.3.12]\r\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1067) ~[spring-webmvc-5.3.12.jar:5.3.12]\r\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:963) ~[spring-webmvc-5.3.12.jar:5.3.12]\r\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.3.12.jar:5.3.12]\r\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.12.jar:5.3.12]\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:655) ~[tomcat-embed-core-9.0.54.jar:4.0.FR]\r\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.3.12.jar:5.3.12]\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:764) ~[tomcat-embed-core-9.0.54.jar:4.0.FR]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:204) ~[spring-security-web-5.4.9.jar:5.4.9]\r\n\tat org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:183) ~[spring-security-web-5.4.9.jar:5.4.9]\r\n\tat org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) ~[spring-web-5.3.12.jar:5.3.12]\r\n\tat org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) ~[spring-web-5.3.12.jar:5.3.12]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.3.12.jar:5.3.12]\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.12.jar:5.3.12]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.3.12.jar:5.3.12]\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.12.jar:5.3.12]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:97) ~[spring-boot-actuator-2.4.12.jar:2.4.12]\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.12.jar:5.3.12]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.3.12.jar:5.3.12]\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.12.jar:5.3.12]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat com.sap.apac.lcnc.shared.security.xss.XSSFilter.doFilter(XSSFilter.java:26) ~[classes/:na]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:197) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:540) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.valves.RemoteIpValve.invoke(RemoteIpValve.java:769) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:357) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:382) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:895) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1722) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.54.jar:9.0.54]\r\n\tat java.base/java.lang.Thread.run(Thread.java:829) ~[na:na]\r\nCaused by: com.fasterxml.jackson.core.JsonParseException: Unrecognized token 'local': was expecting (JSON String, Number, Array, Object or token 'null', 'true' or 'false')\r\n at [Source: (String)\"local.user@registry.com\"; line: 1, column: 6]\r\n\tat com.fasterxml.jackson.core.JsonParser._constructError(JsonParser.java:1851) ~[jackson-core-2.11.4.jar:2.11.4]\r\n\tat com.fasterxml.jackson.core.base.ParserMinimalBase._reportError(ParserMinimalBase.java:717) ~[jackson-core-2.11.4.jar:2.11.4]\r\n\tat com.fasterxml.jackson.core.json.ReaderBasedJsonParser._reportInvalidToken(ReaderBasedJsonParser.java:2898) ~[jackson-core-2.11.4.jar:2.11.4]\r\n\tat com.fasterxml.jackson.core.json.ReaderBasedJsonParser._handleOddValue(ReaderBasedJsonParser.java:1944) ~[jackson-core-2.11.4.jar:2.11.4]\r\n\tat com.fasterxml.jackson.core.json.ReaderBasedJsonParser.nextToken(ReaderBasedJsonParser.java:776) ~[jackson-core-2.11.4.jar:2.11.4]\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readTreeAndClose(ObjectMapper.java:4553) ~[jackson-databind-2.11.2.jar:2.11.2]\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readTree(ObjectMapper.java:2972) ~[jackson-databind-2.11.2.jar:2.11.2]\r\n\tat com.vladmihalcea.hibernate.type.util.ObjectMapperWrapper.toJsonNode(ObjectMapperWrapper.java:66) ~[hibernate-types-52-2.4.3.jar:na]\r\n\t... 106 common frames omitted\r\n\r\n2021-11-26 04:12:15.964  INFO 21844 --- [nio-8080-exec-2] c.s.a.l.s.c.h.TenantConnectionProvider   : [RELEASE CONNECTION FOR TENANT] tlocaltenant \r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3985/comments",
    "author": "mukeshm1989",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-11-26T06:29:29Z",
        "body": "How does this issue relate to Redisson?"
      }
    ]
  },
  {
    "number": 3979,
    "title": "RDelayedQueue在集群情况下的take没有获取到部分到期的数据",
    "created_at": "2021-11-24T12:53:41Z",
    "closed_at": "2021-11-26T14:19:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3979",
    "body": "集群模式下推送的延时任务到达队列中，但是部分延时任务没有在take的时候弹出，没有报错信息\r\n\r\nredisson：3.16.3\r\n\r\n\r\n```java\r\nRBlockingQueue<T> blockingFairQueue = redissonClient.getBlockingQueue(queueName);\r\nRDelayedQueue<T> delayedQueue = redissonClient.getDelayedQueue(blockingFairQueue);\r\ndelayedQueue.offer(t, delay, timeUnit);\r\n\r\nwhile (!Thread.currentThread().isInterrupted() && !destroy) {\r\n                try {\r\n                    RBlockingQueue<T> blockingFairQueue = redissonClient.getBlockingQueue(queueName);\r\n                    T t = blockingFairQueue.take();\r\n                    log.info(\"监听队列线程{},获取到值:{}\", queueName, JSON.toJSONString(t));\r\n                    executor.execute(() -> {\r\n                        try {\r\n                            listener.invoke(t);\r\n                        } catch (Exception e) {\r\n                            log.error(\"延迟队列{}发送任务异常：\", queueName, e);\r\n                        }\r\n                    });\r\n                } catch (Exception e) {\r\n...\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3979/comments",
    "author": "qq502361472",
    "comments": [
      {
        "user": "qq502361472",
        "created_at": "2021-11-25T02:58:43Z",
        "body": "差不多是丢失了一半的数据，没有任何错误信息"
      },
      {
        "user": "mrniko",
        "created_at": "2021-11-26T07:32:00Z",
        "body": "You need to make sure that RDelayedQueue<T> delayedQueue = redissonClient.getDelayedQueue(blockingFairQueue); instance exists and not destroyed. It's required to transfer object to queue after delay.\r\n"
      },
      {
        "user": "qq502361472",
        "created_at": "2021-11-26T08:19:13Z",
        "body": "经过我测试改用下面的pom，并且不对cluster做任何配置，消息丢失的问题没了。我还在测试确认是由于我集群参数调整导致的消息丢失还是我自定义的配置导致消息丢失\r\n```xml\r\n<dependency>\r\n         <groupId>org.redisson</groupId>\r\n         <artifactId>redisson-spring-boot-starter</artifactId>\r\n         <version>3.16.4</version>\r\n     </dependency>\r\n```"
      },
      {
        "user": "qq502361472",
        "created_at": "2021-11-26T08:20:15Z",
        "body": "我没有销毁delayedQueue，而且debug的时候它正常存在"
      },
      {
        "user": "qq502361472",
        "created_at": "2021-11-26T09:25:45Z",
        "body": "测试下来是因为masterConnectionPoolSize配置的8太小导致的消息丢失 没有任何错误，现在配置16没有丢失的情况了"
      }
    ]
  },
  {
    "number": 3973,
    "title": "Is pipeline response list ordered?",
    "created_at": "2021-11-22T17:31:33Z",
    "closed_at": "2021-11-26T07:32:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3973",
    "body": "```\r\nfor(String key:keys){ \r\nbatch.getMap(key).readAllMapAsync(); \r\n}\r\nBatchResult<?> result = batch.execute(); \r\npipelineMapList = (List<Map<String, String>>) result.getResponses(); \r\n```\r\nAre pipelineMapList and keys kept the same order? If not, is there a way to get ordered result with response to the keys order.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3973/comments",
    "author": "Hailprob",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-11-23T05:58:15Z",
        "body": "result list maintains the same order as commands were invoked."
      }
    ]
  },
  {
    "number": 3964,
    "title": "use redisson-spring-boot-starter maven  library， Redis is a cluster deployment， stringRedisTemplate  can set value ，but get value is null",
    "created_at": "2021-11-19T08:08:34Z",
    "closed_at": "2021-11-22T08:28:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3964",
    "body": "springboot start is ok \r\nthe redisson and redis  initialize is ok \r\nnow, stringRedisTemplate  can set value ，but get value is null\r\n\r\no.r.cluster.ClusterConnectionManager Redis cluster nodes configuration got from /ip:8010:\r\nc3bbb85e6f200xxxx21a0d8565c6f6e ip:8010@18010 master - 0 1637305290350 3 connected 5461-10922\r\n8e53000a0c899xxxxece55b0bdfcb33 ip:8011@18011 slave 01757b52eb979ce033a1e432b39f8a50ad618f67 0 1637305291351 5 connected\r\nac91af2954dadxxxxc3f24063c068ca ip:8010@18010 myself,master - 0 1637305290000 1 connected 0-5460\r\nb2c347e18d3f1xxxxb3dc7719d32469 ip:8011@18011 slave c3bbb85e6f200ad51d6f340b6721a0d8565c6f6e 0 1637305290549 6 connected\r\n01757b52eb979xxxx9f8a50ad618f67 ip:8010@18010 master - 0 1637305289548 5 connected 10923-16383\r\nc388804b57f8axxxx9c23b1d2e8a5cd ip:8011@18011 slave ac91af2954dad6da0ba19fa272c3f24063c068ca 0 1637305290000 4 connected\r\n c.z.s.b.a.c.redis.RedisBidConfig setKey:biaoshuFile:908279900552007681:909736514967568385\r\n c.z.s.b.a.c.redis.RedisBidConfig StringRedisTemplate标识：null\r\n c.z.s.b.a.c.redis.RedisBidConfig StringRedisTemplate-xxp标识：null\r\n c.z.s.b.a.c.redis.RedisBidConfig stringRedisTemplate,org.springframework.data.redis.core.StringRedisTemplate@67c6cf76\r\n c.z.s.b.a.c.redis.RedisBidConfig getKey:biaoshuFile:908279900552007681:909736514967568385\r\n c.z.s.b.a.c.redis.RedisBidConfig StringRedisTemplate标识：null\r\n c.z.s.b.a.c.redis.RedisBidConfig StringRedisTemplate-xxp标识：null",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3964/comments",
    "author": "apple0521",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-11-19T08:20:00Z",
        "body": "Unable to reproduce. Here is the test:\r\n\r\n```java\r\n        StringRedisTemplate redisTemplate = new StringRedisTemplate();\r\n        redisTemplate.setConnectionFactory(new RedissonConnectionFactory(redisson));\r\n        redisTemplate.afterPropertiesSet();\r\n\r\n        redisTemplate.opsForValue().set(\"test\", \"test2\");\r\n        assertThat(redisTemplate.opsForValue().get(\"test\")).isEqualTo(\"test2\");\r\n```"
      },
      {
        "user": "apple0521",
        "created_at": "2021-11-19T08:53:49Z",
        "body": "code:\r\n \r\n\r\n        StringRedisTemplate redisTemplate = new StringRedisTemplate();\r\n        redisTemplate.setConnectionFactory(new RedissonConnectionFactory(redisson));\r\n        redisTemplate.afterPropertiesSet();\r\n        redisTemplate.opsForValue().set(\"test\", \"test2\");\r\n        log.info(\"test======:{}\",redisTemplate.opsForValue().get(\"test\"));\r\n        log.info(\"init redisTemplate--:{}\",redisTemplate);\r\n\r\nlog: \r\n   [redisson-netty-2-24] o.r.c.pool.SlaveConnectionPool 24 connections initialized for /10.61.6.84:8011\r\n  [redisson-netty-2-25] o.r.cluster.ClusterConnectionManager slaves: [redis://ip:8011] added for slot ranges: [[5461-10922]]\r\n  [redisson-netty-2-20] o.r.cluster.ClusterConnectionManager slaves: [redis://ip:8011] added for slot ranges: [[10923-16383]]\r\n  [redisson-netty-2-20] o.r.cluster.ClusterConnectionManager master: redis://ip:8010 added for slot ranges: [[10923-16383]]\r\n  [redisson-netty-2-25] o.r.cluster.ClusterConnectionManager master: redis://ip:8010 added for slot ranges: [[5461-10922]]\r\n  [redisson-netty-2-20] o.r.c.pool.SlaveConnectionPool 24 connections initialized for /ip:8011\r\n  [redisson-netty-2-25] o.r.c.pool.SlaveConnectionPool 24 connections initialized for /ip:8011\r\n  [main] c.z.s.b.a.c.r.RedisTemplateConfig test======:null\r\n  [main] c.z.s.b.a.c.r.RedisTemplateConfig init redisTemplate--:org.springframework.data.redis.core.StringRedisTemplate@422cb504\r\n\r\nRedis desktop manager :\r\nqy:0>get test\r\n\"test2\"\r\n\r\nif i remove the redisson-spring-boot-starter and not use redisson,  I could get value .\r\n "
      },
      {
        "user": "mrniko",
        "created_at": "2021-11-19T08:57:36Z",
        "body": "can you share log with TRACE logging level for `org.redisson` package?"
      },
      {
        "user": "apple0521",
        "created_at": "2021-11-19T09:28:06Z",
        "body": "aboout （set command get command） log\r\nlog:\r\n \r\n```\r\n[main] org.redisson.command.RedisExecutor acquired connection for command (SET) and params [[116, 101, 115, 116], [116, 101, 115, 116, 50]] from slot NodeSource [slot=6918, addr=null, redisClient=null, redirect=null, entry=null] using node /10.61.6.84:8010... RedisConnection@123697529 [redisClient=[addr=redis://10.61.6.84:8010], channel=[id: 0x93a535c1, L:/10.100.127.124:53304 - R:/10.61.6.84:8010], currentCommand=null]\r\n [redisson-netty-2-28] org.redisson.command.RedisExecutor connection released for command (SET) and params [[116, 101, 115, 116], [116, 101, 115, 116, 50]] from slot NodeSource [slot=6918, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@123697529 [redisClient=[addr=redis://10.61.6.84:8010], channel=[id: 0x93a535c1, L:/10.100.127.124:53304 - R:/10.61.6.84:8010], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@6a22522c(success: true)], command=(SET), params=[[116, 101, 115, 116], [116, 101, 115, 116, 50]], codec=org.redisson.client.codec.StringCodec]]\r\n\r\n[main] org.redisson.command.RedisExecutor acquired connection for command (GET) and params [[116, 101, 115, 116]] from slot NodeSource [slot=6918, addr=null, redisClient=null, redirect=null, entry=null] using node /10.61.6.85:8011... RedisConnection@1843866685 [redisClient=[addr=redis://10.61.6.85:8011], channel=[id: 0xb447d2ae, L:/10.100.127.124:48748 - R:/10.61.6.85:8011], currentCommand=null]\r\n [redisson-netty-2-4] org.redisson.command.RedisExecutor connection released for command (GET) and params [[116, 101, 115, 116]] from slot NodeSource [slot=6918, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@1843866685 [redisClient=[addr=redis://10.61.6.85:8011], channel=[id: 0xb447d2ae, L:/10.100.127.124:48748 - R:/10.61.6.85:8011], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@5e377d7c(success)], command=(GET), params=[[116, 101, 115, 116]], codec=org.redisson.client.codec.ByteArrayCodec]]\r\n\r\n[main] c.z.s.b.a.c.r.RedisTemplateConfig test======:null\r\n \r\n[main] c.z.s.b.a.c.r.RedisTemplateConfig init redisTemplate--:org.springframework.data.redis.core.StringRedisTemplate@c252f8c\r\n \r\n[main] org.redisson.command.RedisExecutor acquired connection for command (INFO DEFAULT) and params [] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node /10.61.6.84:8011... RedisConnection@437743065 [redisClient=[addr=redis://10.61.6.84:8011], channel=[id: 0x625087e2, L:/10.100.127.124:41752 - R:/10.61.6.84:8011], currentCommand=null]\r\n\r\n[redisson-netty-2-22] org.redisson.command.RedisExecutor connection released for command (INFO DEFAULT) and params [] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@437743065 [redisClient=[addr=redis://10.61.6.84:8011], channel=[id: 0x625087e2, L:/10.100.127.124:41752 - R:/10.61.6.84:8011], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@2f617c50(success: {aof_pending_bio_fsync=0, aof_buffer_length=0, aof_rewrite_scheduled=0, number_of_cached_scripts=0, mem_clients_slaves=0, keyspace_misses=8235, mem_allocator=jemalloc-5.1.0, multiplexing_api=epoll, aof_last_write_status=ok, used_memory_peak_perc=53.94%, run_id=29cfcb1da0201e315fdb032d67f4fe176dfaf487, uptime_in_seconds=10216764, maxmemory=0, active_defrag_hits=0, aof_base_size=0, atomicvar_api=atomic-builtin, total_system_memory_human=31.37G, gcc_version=8.3.0, second_repl_offset=-1, arch_bits=64, master_repl_offset=0, instantaneous_output_kbps=0.15, total_commands_processed=7612381, repl_backlog_size=1048576, sync_full=0, master_last_io_seconds_ago=-1, sync_partial_err=0, aof_last_cow_size=0, configured_hz=10, master_host=10.61.6.81, used_memory_startup=1449600, mem_clients_normal=5075528, used_cpu_user=9791.306975, aof_enabled=1, redis_mode=cluster, rdb_changes_since_last_save=0, used_memory_lua=37888, redis_build_id=442b43d467cd2b03, connected_slaves=0, expired_keys=0, used_memory=7785360, active_defrag_misses=0, active_defrag_key_misses=0, used_memory_rss=15564800, slave_read_only=1, rdb_last_bgsave_status=ok, process_id=1, rejected_connections=0, master_replid=d8480b9285fa099b3a28151ee9b67d3c5c28c2eb, used_memory_rss_human=14.84M, master_sync_in_progress=0, used_memory_scripts=0, rdb_bgsave_in_progress=0, rdb_last_cow_size=0, cluster_enabled=1, tcp_port=8011, os=Linux 5.4.108-1.el7.elrepo.x86_64 x86_64, mem_replication_backlog=0, aof_current_rewrite_time_sec=-1, allocator_rss_ratio=1.39, used_memory_overhead=6525128, repl_backlog_histlen=0, slave_expires_tracked_keys=0, used_cpu_sys=11815.536080, role=slave, used_memory_dataset_perc=19.89%, expired_stale_perc=0.00, allocator_frag_ratio=1.21, client_recent_max_input_buffer=4, aof_current_size=0, aof_last_bgrewrite_status=ok, used_memory_peak_human=13.76M, hz=10, used_memory_human=7.42M, aof_pending_rewrite=0, master_link_down_since_seconds=1637312907, maxmemory_policy=noeviction, rss_overhead_ratio=1.19, mem_fragmentation_ratio=2.01, rdb_last_bgsave_time_sec=-1, allocator_allocated=7798456, used_memory_dataset=1260232, blocked_clients=0, used_cpu_sys_children=0.001004, repl_backlog_active=0, master_port=8010, used_cpu_user_children=0.002028, sync_partial_ok=0, aof_rewrite_in_progress=0, redis_git_sha1=00000000, rdb_current_bgsave_time_sec=-1, active_defrag_running=0, aof_delayed_fsync=0, aof_last_rewrite_time_sec=-1, master_replid2=0000000000000000000000000000000000000000, config_file=/usr/local/etc/redis/redis.conf, lazyfree_pending_objects=0, used_memory_scripts_human=0B, loading=0, slave_priority=100, master_link_status=down, allocator_rss_bytes=3690496, pubsub_channels=2, used_memory_lua_human=37.00K, active_defrag_key_hits=0, slave_repl_offset=1, allocator_frag_bytes=1601864, migrate_cached_sockets=0, redis_git_dirty=0, total_system_memory=33679220736, mem_aof_buffer=0, rss_overhead_bytes=2473984, client_recent_max_output_buffer=0, connected_clients=298, mem_fragmentation_bytes=7821480, lru_clock=9922955, aof_rewrite_buffer_length=0, pubsub_patterns=1, expired_time_cap_reached_count=0, repl_backlog_first_byte_offset=0, total_net_output_bytes=1029445358, executable=/data/redis-server, evicted_keys=0, total_connections_received=1452818, allocator_active=9400320, mem_not_counted_for_evict=0, redis_version=5.0.5, total_net_input_bytes=342886528, latest_fork_usec=0, maxmemory_human=0B, used_memory_peak=14432792, allocator_resident=13090816, keyspace_hits=0, uptime_in_days=118, instantaneous_input_kbps=0.82, instantaneous_ops_per_sec=31, rdb_last_save_time=1627096143})], command=(INFO DEFAULT), params=[], codec=org.redisson.client.codec.StringCodec]]\r\n```\r\n\r\n\r\nredis config: \r\nspring.redis.cluster.nodes = 10.61.6.81:8010,10.61.6.81:8011,10.61.6.84:8010,10.61.6.84:8011,10.61.6.85:8010,10.61.6.85:8011"
      },
      {
        "user": "mrniko",
        "created_at": "2021-11-22T08:28:36Z",
        "body": "Seems there is replication lag between master and slave. Try to set readMode setting = MASTER."
      }
    ]
  },
  {
    "number": 3962,
    "title": "java.lang.IllegalArgumentException: Can't parse packet",
    "created_at": "2021-11-19T04:34:48Z",
    "closed_at": "2021-11-20T10:25:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3962",
    "body": "I got such an error when I try to clear the RedissonLocalCachedMap.\r\n`Redisson version:3.16.3\r\n`\r\n```\r\n2021-11-19 11:45:11:912 [redisson-netty-2-6] TRACE org.redisson.client.handler.CommandPubSubDecoder.decode:134 - reply: *3\r\n$7\r\nmessage\r\n$43\r\n{bdcampus:bdcampus-bind-fullKeyCache}:topic\r\n$115\r\n{\"@class\":\"org.redisson.cache.LocalCachedMapClear\",\"releaseSemaphore\":false,\"requestId\":\"cB+BvVX2HzwIsdIW11VcsA==\"}\r\n, channel: [id: 0x00eb8b6e, L:/100.66.209.243:49952 - R:redis-cluster/100.66.209.208:6379], command: null\r\n2021-11-19 11:45:11:912 [redisson-netty-2-3] DEBUG org.redisson.command.RedisExecutor.releaseConnection:536 - connection released for command (EVALSHA) and params [34cf7f8699dd099ce2a9aa94e01d4942168c7a3f, 3, bdcampus:bdcampus-bind-fullKeyCache, {bdcampus:bdcampus-bind-fullKeyCache}:topic, redisson__cache_updates_log:{bdcampus:bdcampus-bind-fullKeyCache}, PooledUnsafeDirectByteBuf(ridx: 0, widx: 115, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 22, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 60, cap: 256)] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@1829243899 [redisClient=[addr=redis://redis-cluster:6379], channel=[id: 0xc6fc6d40, L:/100.66.209.243:49954 - R:redis-cluster/100.66.209.208:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@c12e552(success: true)], command=(EVALSHA), params=[34cf7f8699dd099ce2a9aa94e01d4942168c7a3f, 3, bdcampus:bdcampus-bind-fullKeyCache, {bdcampus:bdcampus-bind-fullKeyCache}:topic, redisson__cache_updates_log:{bdcampus:bdcampus-bind-fullKeyCache}, PooledUnsafeDirectByteBuf(ridx: 0, widx: 115, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 22, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 60, cap: 256)], codec=org.redisson.client.codec.LongCodec], usage=0]\r\n2021-11-19 11:45:11:913 [redisson-netty-2-6] ERROR org.redisson.client.handler.CommandPubSubDecoder.decodeCommand:88 - Unable to decode data. channel: [id: 0x00eb8b6e, L:/100.66.209.243:49952 - R:redis-cluster/100.66.209.208:6379], reply: ReplayingDecoderByteBuf(ridx=190, widx=190)\r\njava.lang.IllegalArgumentException: Can't parse packet\r\n\tat org.redisson.cache.LocalCachedMessageCodec$1.decode(LocalCachedMessageCodec.java:112)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:383)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:427)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:392)\r\n\tat org.redisson.client.handler.CommandPubSubDecoder.decodeCommand(CommandPubSubDecoder.java:84)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:94)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n2021-11-19 11:45:11:913 [redisson-netty-2-6] ERROR org.redisson.client.handler.ErrorsLoggingHandler.exceptionCaught:47 - Exception occured. Channel: [id: 0x00eb8b6e, L:/100.66.209.243:49952 - R:redis-cluster/100.66.209.208:6379]\r\nio.netty.handler.codec.DecoderException: java.lang.IllegalArgumentException: Can't parse packet\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.lang.IllegalArgumentException: Can't parse packet\r\n\tat org.redisson.cache.LocalCachedMessageCodec$1.decode(LocalCachedMessageCodec.java:112)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:383)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:427)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:392)\r\n\tat org.redisson.client.handler.CommandPubSubDecoder.decodeCommand(CommandPubSubDecoder.java:84)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:94)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\t... 17 common frames omitted\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3962/comments",
    "author": "whitewindmills",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-11-19T05:14:48Z",
        "body": "Unable to reproduce it. Below is my code:\r\n\r\n```java\r\n        RLocalCachedMap<Object, Object> localCachedMap = redisson.getLocalCachedMap(\"udi-test\",\r\n                        LocalCachedMapOptions.defaults());\r\n\r\n        localCachedMap.put(\"1\", \"2\");\r\n        localCachedMap.put(\"3\", \"4\");\r\n\r\n        localCachedMap.clear();\r\n```\r\n\r\nCan you try 3.16.4 version?"
      }
    ]
  },
  {
    "number": 3961,
    "title": "Returning Null Value  from  redissonClient.getMapCache(CLIENT_MAP).get(key)  in replicated  multinode cluster. ",
    "created_at": "2021-11-18T14:58:34Z",
    "closed_at": "2021-11-23T18:37:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3961",
    "body": "Hello,\r\n\r\nI am trying to fetch  a value for a particular key from a replicated  multinode cluster.  This cluster has 2 nodes. Node1, Node2 with authentication on. I am inserting values and trying to fetch the same value.  \r\n Key-value pair insertion happened in node1. And while fetching the same key-value pair , I am suspecting it it trying to get it from node2. \r\n\r\nPlease find my code below\r\n\r\n--configuration\r\n Config config = new Config();\r\n                    config.useReplicatedServers()\r\n                            .addNodeAddress(node1).addNodeAddress(node2).setUsername(userName).setPassword(password)\r\n                            .setReadMode(ReadMode.MASTER_SLAVE);\r\n                    multiInstanceClient = Redisson.create(config);\r\n\r\n---storig\r\n if (redissonClient != null) {\r\n            RMapCache<String, String> cache = redissonClient.getMapCache(CLIENT_MAP, StringCodec.INSTANCE);\r\n            cache.put(tokenId, tokenValue,ttl,  TimeUnit.SECONDS);\r\n            return true;\r\n        }\r\n\r\n--- fetching the value\r\n\r\nif (redissonClient != null) {\r\n            RMapCache<Object, Object> cache = redissonClient.getMapCache(CLIENT_MAP);\r\n            if (!cache.isEmpty()) {    // size is 3 and the key is present in the list but still returning null on cache.get(key)\r\n               return cache.get(key) != null ? cache.get(key).toString() : null;\r\n            }\r\n        }\r\n\r\n\r\nFrom redis cli I had to do readonly on node2 inorder to c the keys. If readonly is only option to fetch the key-value pair from java code, how to code it?\r\n\r\nHelp is appreciated . Thank you in advance.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3961/comments",
    "author": "Reshmakoganti",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-11-22T06:27:08Z",
        "body": "slave node may return null value in case of replication lag."
      },
      {
        "user": "Reshmakoganti",
        "created_at": "2021-11-22T16:41:45Z",
        "body": "Thank you for your reply. How much lag time we can except? cache.get(key) is returning null consistently. "
      },
      {
        "user": "mrniko",
        "created_at": "2021-11-22T17:34:14Z",
        "body": "It depends on network throughput and data size"
      },
      {
        "user": "Reshmakoganti",
        "created_at": "2021-11-23T18:37:12Z",
        "body": "Thank you for your input. "
      }
    ]
  },
  {
    "number": 3946,
    "title": "java.lang.ClassCastException: java.lang.String cannot be cast to java.util.Set",
    "created_at": "2021-11-14T11:54:28Z",
    "closed_at": "2021-12-15T12:55:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3946",
    "body": "What can cause such an error?\r\n\r\n```\r\nException in thread \"redisson-3-4\" java.lang.ClassCastException: java.lang.String cannot be cast to java.util.Set\r\n\tat org.redisson.RedissonMap.readAllEntrySet(zb:513)\r\n\tat org.redisson.spring.session.RedissonSessionRepository$RedissonSession.load(RedissonSessionRepository.java:97)\r\n\tat org.redisson.spring.session.RedissonSessionRepository.findById(RedissonSessionRepository.java:319)\r\n\tat org.redisson.spring.session.RedissonSessionRepository.onMessage(RedissonSessionRepository.java:261)\r\n\tat org.redisson.spring.session.RedissonSessionRepository.onMessage(RedissonSessionRepository.java:53)\r\n\tat org.redisson.d.onPatternMessage(ol:156)\r\n\tat org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:84)\r\n\tat org.redisson.client.handler.CommandPubSubDecoder.lambda$enqueueMessage$0(CommandPubSubDecoder.java:188)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n[epollEventLoopGroup-2-5] WARN io.netty.channel.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.\r\njava.lang.IncompatibleClassChangeError: Found interface org.objectweb.asm.MethodVisitor, but class was expected\r\n\tat com.esotericsoftware.reflectasm.ConstructorAccess.insertConstructor(ConstructorAccess.java:128)\r\n\tat com.esotericsoftware.reflectasm.ConstructorAccess.get(ConstructorAccess.java:98)\r\n\tat com.esotericsoftware.kryo.Kryo$DefaultInstantiatorStrategy.newInstantiatorOf(Kryo.java:1271)\r\n\tat com.esotericsoftware.kryo.Kryo.newInstantiator(Kryo.java:1127)\r\n\tat com.esotericsoftware.kryo.Kryo.newInstance(Kryo.java:1136)\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.create(FieldSerializer.java:562)\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.read(FieldSerializer.java:538)\r\n\tat com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:813)\r\n\tat org.redisson.codec.KryoCodec$1.decode(KryoCodec.java:126)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:402)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:446)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:411)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:300)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:233)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:160)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:129)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)\r\n\tat io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796)\r\n\tat io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432)\r\n\tat io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3946/comments",
    "author": "bkoroliuk-amplify",
    "comments": [
      {
        "user": "bkoroliuk-amplify",
        "created_at": "2021-11-14T12:02:27Z",
        "body": "@mrniko full log is here:\r\n```\r\nRedisClientFactory: Successfully connected to Redis\r\n2021-11-12T10:44:03.819+0000: [GC (Allocation Failure)  336308K->78691K(490240K), 0.0151867 secs]\r\n[epollEventLoopGroup-2-3] WARN io.netty.channel.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.\r\njava.lang.IncompatibleClassChangeError: Found interface org.objectweb.asm.MethodVisitor, but class was expected\r\n\tat com.esotericsoftware.reflectasm.ConstructorAccess.insertConstructor(ConstructorAccess.java:128)\r\n\tat com.esotericsoftware.reflectasm.ConstructorAccess.get(ConstructorAccess.java:98)\r\n\tat com.esotericsoftware.kryo.Kryo$DefaultInstantiatorStrategy.newInstantiatorOf(Kryo.java:1271)\r\n\tat com.esotericsoftware.kryo.Kryo.newInstantiator(Kryo.java:1127)\r\n\tat com.esotericsoftware.kryo.Kryo.newInstance(Kryo.java:1136)\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.create(FieldSerializer.java:562)\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.read(FieldSerializer.java:538)\r\n\tat com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:813)\r\n\tat org.redisson.codec.KryoCodec$1.decode(KryoCodec.java:126)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:402)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:446)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:411)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:300)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:233)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:160)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:129)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)\r\n\tat io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796)\r\n\tat io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432)\r\n\tat io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n[epollEventLoopGroup-2-3] WARN io.netty.channel.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.\r\njava.lang.IncompatibleClassChangeError: Found interface org.objectweb.asm.MethodVisitor, but class was expected\r\n\tat com.esotericsoftware.reflectasm.ConstructorAccess.insertConstructor(ConstructorAccess.java:128)\r\n\tat com.esotericsoftware.reflectasm.ConstructorAccess.get(ConstructorAccess.java:98)\r\n\tat com.esotericsoftware.kryo.Kryo$DefaultInstantiatorStrategy.newInstantiatorOf(Kryo.java:1271)\r\n\tat com.esotericsoftware.kryo.Kryo.newInstantiator(Kryo.java:1127)\r\n\tat com.esotericsoftware.kryo.Kryo.newInstance(Kryo.java:1136)\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.create(FieldSerializer.java:562)\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.read(FieldSerializer.java:538)\r\n\tat com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:813)\r\n\tat org.redisson.codec.KryoCodec$1.decode(KryoCodec.java:126)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:402)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:446)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:411)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:300)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:233)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:160)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:129)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)\r\n\tat io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796)\r\n\tat io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432)\r\n\tat io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n[epollEventLoopGroup-2-3] WARN io.netty.channel.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.\r\njava.lang.IncompatibleClassChangeError: Found interface org.objectweb.asm.MethodVisitor, but class was expected\r\n\tat com.esotericsoftware.reflectasm.ConstructorAccess.insertConstructor(ConstructorAccess.java:128)\r\n\tat com.esotericsoftware.reflectasm.ConstructorAccess.get(ConstructorAccess.java:98)\r\n\tat com.esotericsoftware.kryo.Kryo$DefaultInstantiatorStrategy.newInstantiatorOf(Kryo.java:1271)\r\n\tat com.esotericsoftware.kryo.Kryo.newInstantiator(Kryo.java:1127)\r\n\tat com.esotericsoftware.kryo.Kryo.newInstance(Kryo.java:1136)\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.create(FieldSerializer.java:562)\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.read(FieldSerializer.java:538)\r\n\tat com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:813)\r\n\tat org.redisson.codec.KryoCodec$1.decode(KryoCodec.java:126)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:402)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:446)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:411)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:300)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:233)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:160)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:129)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)\r\n\tat io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796)\r\n\tat io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432)\r\n\tat io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n[epollEventLoopGroup-2-8] WARN io.netty.channel.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.\r\njava.lang.IncompatibleClassChangeError: Found interface org.objectweb.asm.MethodVisitor, but class was expected\r\n\tat com.esotericsoftware.reflectasm.ConstructorAccess.insertConstructor(ConstructorAccess.java:128)\r\n\tat com.esotericsoftware.reflectasm.ConstructorAccess.get(ConstructorAccess.java:98)\r\n\tat com.esotericsoftware.kryo.Kryo$DefaultInstantiatorStrategy.newInstantiatorOf(Kryo.java:1271)\r\n\tat com.esotericsoftware.kryo.Kryo.newInstantiator(Kryo.java:1127)\r\n\tat com.esotericsoftware.kryo.Kryo.newInstance(Kryo.java:1136)\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.create(FieldSerializer.java:562)\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.read(FieldSerializer.java:538)\r\n\tat com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:813)\r\n\tat org.redisson.codec.KryoCodec$1.decode(KryoCodec.java:126)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:402)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:446)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:411)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:300)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:233)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:160)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:129)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)\r\n\tat io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796)\r\n\tat io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432)\r\n\tat io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n[epollEventLoopGroup-2-6] WARN io.netty.channel.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.\r\njava.lang.IncompatibleClassChangeError: Found interface org.objectweb.asm.MethodVisitor, but class was expected\r\n\tat com.esotericsoftware.reflectasm.ConstructorAccess.insertConstructor(ConstructorAccess.java:128)\r\n\tat com.esotericsoftware.reflectasm.ConstructorAccess.get(ConstructorAccess.java:98)\r\n\tat com.esotericsoftware.kryo.Kryo$DefaultInstantiatorStrategy.newInstantiatorOf(Kryo.java:1271)\r\n\tat com.esotericsoftware.kryo.Kryo.newInstantiator(Kryo.java:1127)\r\n\tat com.esotericsoftware.kryo.Kryo.newInstance(Kryo.java:1136)\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.create(FieldSerializer.java:562)\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.read(FieldSerializer.java:538)\r\n\tat com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:813)\r\n\tat org.redisson.codec.KryoCodec$1.decode(KryoCodec.java:126)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:402)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:446)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:411)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:300)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:233)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:160)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:129)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)\r\n\tat io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796)\r\n\tat io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432)\r\n\tat io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nException in thread \"redisson-3-4\" java.lang.ClassCastException: java.lang.String cannot be cast to java.util.Set\r\n\tat org.redisson.RedissonMap.readAllEntrySet(zb:513)\r\n\tat org.redisson.spring.session.RedissonSessionRepository$RedissonSession.load(RedissonSessionRepository.java:97)\r\n\tat org.redisson.spring.session.RedissonSessionRepository.findById(RedissonSessionRepository.java:319)\r\n\tat org.redisson.spring.session.RedissonSessionRepository.onMessage(RedissonSessionRepository.java:261)\r\n\tat org.redisson.spring.session.RedissonSessionRepository.onMessage(RedissonSessionRepository.java:53)\r\n\tat org.redisson.d.onPatternMessage(ol:156)\r\n\tat org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:84)\r\n\tat org.redisson.client.handler.CommandPubSubDecoder.lambda$enqueueMessage$0(CommandPubSubDecoder.java:188)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n[epollEventLoopGroup-2-5] WARN io.netty.channel.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.\r\njava.lang.IncompatibleClassChangeError: Found interface org.objectweb.asm.MethodVisitor, but class was expected\r\n\tat com.esotericsoftware.reflectasm.ConstructorAccess.insertConstructor(ConstructorAccess.java:128)\r\n\tat com.esotericsoftware.reflectasm.ConstructorAccess.get(ConstructorAccess.java:98)\r\n\tat com.esotericsoftware.kryo.Kryo$DefaultInstantiatorStrategy.newInstantiatorOf(Kryo.java:1271)\r\n\tat com.esotericsoftware.kryo.Kryo.newInstantiator(Kryo.java:1127)\r\n\tat com.esotericsoftware.kryo.Kryo.newInstance(Kryo.java:1136)\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.create(FieldSerializer.java:562)\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.read(FieldSerializer.java:538)\r\n\tat com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:813)\r\n\tat org.redisson.codec.KryoCodec$1.decode(KryoCodec.java:126)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:402)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:446)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:411)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:300)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:233)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:160)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:129)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)\r\n\tat io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796)\r\n\tat io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432)\r\n\tat io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nException in thread \"redisson-3-6\" java.lang.ClassCastException: java.lang.String cannot be cast to java.util.Set\r\n\tat org.redisson.RedissonMap.readAllEntrySet(zb:513)\r\n\tat org.redisson.spring.session.RedissonSessionRepository$RedissonSession.load(RedissonSessionRepository.java:97)\r\n\tat org.redisson.spring.session.RedissonSessionRepository.findById(RedissonSessionRepository.java:319)\r\n\tat org.redisson.spring.session.RedissonSessionRepository.onMessage(RedissonSessionRepository.java:261)\r\n\tat org.redisson.spring.session.RedissonSessionRepository.onMessage(RedissonSessionRepository.java:53)\r\n\tat org.redisson.d.onPatternMessage(ol:156)\r\n\tat org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:84)\r\n\tat org.redisson.client.handler.CommandPubSubDecoder.lambda$enqueueMessage$0(CommandPubSubDecoder.java:188)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2021-11-14T13:18:20Z",
        "body": "which Redisson version do you use? this may happen if someone stored String instead of Set as Map value"
      },
      {
        "user": "bkoroliuk-amplify",
        "created_at": "2021-11-14T13:30:13Z",
        "body": "@mrniko 3.11.0"
      },
      {
        "user": "mrniko",
        "created_at": "2021-11-14T13:34:35Z",
        "body": "is there any scenario to reproduce it?"
      },
      {
        "user": "bkoroliuk-amplify",
        "created_at": "2021-11-16T16:23:22Z",
        "body": "@mrniko we switched from EC2 to AWS ECS and started seeing such errors:\r\n\r\n`org.redisson.client.RedisTimeoutException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:47:queue:0, freeConnectionsAmount=32, freeConnectionsCounter=value:64:queue:0, freezed=false, freezeReason=null, client=[addr=redis://{address}:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection [entry=[commandsBatch=0, entry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=32, freeConnectionsCounter=value:64:queue:0, freezed=false, freezeReason=null, client=[addr=redis://{address}:6379], nodeType=SLAVE, firstFail=0], commandsBatchSemaphore=value:0:queue:2, sendWorkers=0, connectionsAmount=2], redisClient=[addr=redis://{address}:6379]], command: (HGETALL), params: [spring:session:69ed68c0-6499-417a-8a6d-a51be479a9c4] after 3 retry attempts`\r\n\r\nStill works fine with EC2\r\n\r\nIncreasing netty threads to 64 and even 512 didn't help"
      },
      {
        "user": "mrniko",
        "created_at": "2021-11-16T17:06:01Z",
        "body": "I think this might happen due to limited resources of AWS ECS. How does AWS ECS handle JVM threads?"
      },
      {
        "user": "bkoroliuk-amplify",
        "created_at": "2021-11-18T08:49:37Z",
        "body": "@mrniko we tried to decrease thread count to minimal value and still the same issue. What do you think about upgrading from 3.11.0 to 3.16.4? Can we try it as an option?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-11-18T09:23:48Z",
        "body": "@bkoroliuk-amplify  you can try. Please note default codec changed to MarshallingCodec since 3.13.0 version"
      },
      {
        "user": "mrniko",
        "created_at": "2021-12-03T09:10:13Z",
        "body": "Have you resolved the issue?"
      },
      {
        "user": "bkoroliuk-amplify",
        "created_at": "2021-12-07T15:31:18Z",
        "body": "@mrniko We upgraded to the latest version of redissonpro (3.16.5) & Redis Cluster (6.2.5). Currently, we see another errors:\r\n\r\n```\r\n2021-12-07 15:20:13,117 | ERROR | [dd.trace_id= dd.span_id=] | org.redisson.client.handler.CommandDecoder | lb_0A65229E_0A650241_61AF7569_2425_001D/700fbf7f-4d67-4c28-a6b3-d71cbdfb6f8b | Unable to decode data. channel: [id: 0x02591be0, L:/10.101.3.252:40310 - R:10.101.3.216/10.101.3.216:6379], reply: ReplayingDecoderByteBuf(ridx=9482, widx=14808)\r\njava.lang.NullPointerException\r\n\tat org.redisson.client.handler.CommandDecoder.messageDecoder(CommandDecoder.java:488)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:449)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:410)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:226)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:143)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:100)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:795)\r\n\tat io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:480)\r\n\tat io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n```"
      },
      {
        "user": "bkoroliuk-amplify",
        "created_at": "2021-12-07T15:33:26Z",
        "body": "Error 2:\r\n\r\n```\r\n2021-12-07 15:20:14,718 | ERROR | [dd.trace_id= dd.span_id=] | org.redisson.client.handler.ErrorsLoggingHandler | lb_0A65229E_0A650241_61AF7569_2425_001D/700fbf7f-4d67-4c28-a6b3-d71cbdfb6f8b | Exception occured. Channel: [id: 0x9700d6a9, L:/10.101.3.252:52008 - R:10.101.5.112/10.101.5.112:6379]\r\nio.netty.handler.codec.DecoderException: java.lang.NullPointerException\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:795)\r\n\tat io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:480)\r\n\tat io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.lang.NullPointerException\r\n\tat org.redisson.client.handler.CommandDecoder.messageDecoder(CommandDecoder.java:488)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:449)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:410)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:226)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:143)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:100)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n```"
      },
      {
        "user": "bkoroliuk-amplify",
        "created_at": "2021-12-07T15:34:05Z",
        "body": "Error 3:\r\n\r\n```\r\n2021-12-07 15:17:39,918 | ERROR | [dd.trace_id=2883271266335823003 dd.span_id=7371369554827391597] | net.wgen.spring.common.ui.exceptionhandler.ExceptionResolver | lb_0A652A0E_0A650241_61AF7A96_5D3C_0055/01434522-c393-4c21-9dcb-b5031179b1f7 | Exception while processing request \r\norg.redisson.client.RedisResponseTimeoutException: Redis server response timeout (30000 ms) occured after 3 retry attempts. Increase nettyThreads and/or timeout settings. Try to define pingConnectionInterval setting. Command: (EVAL), params: [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, MY_APP_LICENSE, redisson__timeout__set:{MY_APP_LICENSE}, redisson__idle__set:{MY_APP_LICENSE}, redisson__map_cache__last_access__set:{MY_APP_LICENSE}, {MY_APP_LICENSE}:redisson_options, 1638890134786, PooledUnsafeDirectByteBuf(ridx: 0, widx: 173, cap: 256)], channel: null\r\n\tat org.redisson.command.RedisExecutor.lambda$scheduleResponseTimeout$5(yl:439)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715)\r\n\tat io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790)\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2021-12-07T16:19:30Z",
        "body": "@bkoroliuk-amplify \r\n\r\nIs there any way to reproduce it? Can you share trace logs for `org.redisson.client.handler` package and share output?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-12-13T08:50:15Z",
        "body": "any update?"
      },
      {
        "user": "bkoroliuk-amplify",
        "created_at": "2021-12-15T12:37:12Z",
        "body": "@mrniko we have finally fixed this issue for ECS, list of updates:\r\n\r\n- redisson-all `3.11.0 => 3.16.5`\r\n- Redis Cluster `3x => 6x`\r\n- com.esotericsoftware.kryo `=> 5.2.0`\r\n- de.javakaffee.kryo-serializers `=> 0.45`"
      },
      {
        "user": "mrniko",
        "created_at": "2021-12-15T12:55:42Z",
        "body": "Great. I'm closing it."
      }
    ]
  },
  {
    "number": 3936,
    "title": "PriorityBlockingQueue can duplicate elements be removed?",
    "created_at": "2021-11-05T09:42:32Z",
    "closed_at": "2021-11-08T08:09:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3936",
    "body": "I want to a sort queue and it can remove the duplicate elements.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3936/comments",
    "author": "MarvellousLiang",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-11-08T08:09:56Z",
        "body": "PriorityBlockingQueue doesn't support this function. You need to handle it manually."
      }
    ]
  },
  {
    "number": 3931,
    "title": "FstCodec",
    "created_at": "2021-11-03T02:27:13Z",
    "closed_at": "2024-04-04T05:08:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3931",
    "body": "String deserialization with high concurrency \"{}\"  or Object reference  \"[com.game.logical.global.bean.DropRateData@2ab839d5]\"\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3931/comments",
    "author": "wl980868110",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-11-03T07:21:08Z",
        "body": "FstCodec is deprecated. Please use MarshallingCodec instead."
      },
      {
        "user": "wl980868110",
        "created_at": "2021-11-03T08:51:28Z",
        "body": "MarshallingCodec is three times larger than FstCodec serialization\r\nCloud Redis has speed limiting\r\nFstCodec have advantages\r\n\r\n\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2021-11-03T09:45:35Z",
        "body": "As alternative you can use Kryo5Codec. You can also try to use compression codec like SnappyCodecV2 or LZ4Codec.\r\n"
      },
      {
        "user": "tanglz",
        "created_at": "2023-11-29T19:00:41Z",
        "body": "Can we use Kryo5Codec to read old data which use FstCodec?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-04-04T05:08:39Z",
        "body": "You need to extend Kryo5Codec class"
      }
    ]
  },
  {
    "number": 3926,
    "title": "FstCodec",
    "created_at": "2021-10-29T12:39:33Z",
    "closed_at": "2021-10-29T12:54:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3926",
    "body": "FstCodec  \r\nWhy did YOU rewrite the map\r\nIs there a problem",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3926/comments",
    "author": "wl980868110",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-10-29T12:54:36Z",
        "body": "there was an issue with serialization."
      },
      {
        "user": "wl980868110",
        "created_at": "2021-10-29T13:22:17Z",
        "body": "What's the problem\r\nmap value object  Field string Deserialization jvm crash\r\n\r\n\r\n\r\n\r\n"
      }
    ]
  },
  {
    "number": 3925,
    "title": "Redisson client injects weird characters at the beginning of strings",
    "created_at": "2021-10-29T12:01:41Z",
    "closed_at": "2021-10-29T12:28:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3925",
    "body": "I'm using Redisson client to publish String messages on a topic, but for some reasons, the published messages always contain some weird characters at the beginning:\r\n\r\neg: when I publish the string \"{\"event\":\"notification\"}\" at the redis level I end up with this: \"\\x04>\\x18{\"event\":\"notification\"}\"\r\n\r\n1) \"pmessage\"\r\n2) \"*\"\r\n3) \"active_project_users:1\"\r\n4) \"\\x04>\\x18{\\\"event\\\":\\\"notification\\\"}\"\r\n\r\nAny idea how I can make those weird chars go away?\r\n\r\nMy java code looks like this:\r\n\r\n private void publish(String channel, String message) {       \r\n        RTopic topic = redissonClient.getTopic(channel);\r\n        topic.publish(\"{\\\"event\\\":\\\"notification\\\"}\");\r\n    }\r\nI'm using redis:3.2 & radisson-spring-boot-starter 3.16.1\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3925/comments",
    "author": "ghevge",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-10-29T12:28:17Z",
        "body": "default codec is MarshallingCodec. You need to define StringCodec if you want data stored as plain text."
      },
      {
        "user": "ghevge",
        "created_at": "2021-10-29T12:44:10Z",
        "body": "Thanks!"
      }
    ]
  },
  {
    "number": 3911,
    "title": "when domain's ip change, redisson also reconnect old ip",
    "created_at": "2021-10-22T11:45:59Z",
    "closed_at": "2021-11-08T08:31:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3911",
    "body": "redisson version:3.11.5\r\n\r\nAfter the IP of the domain name changes, redisson always reconnects the old IP. The correct way is to disconnect from the server after the IP of the domain name changes. Redisson should reconnect to the new cluster IP\r\n\r\nwhy？What configuration is needed?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3911/comments",
    "author": "sunwuxiang",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-10-22T13:56:32Z",
        "body": "can you share a log?"
      }
    ]
  },
  {
    "number": 3901,
    "title": "Performing a GET on an existing key, which is set outside Redisson, returns `Unsupported protocol version 53`",
    "created_at": "2021-10-20T15:35:23Z",
    "closed_at": "2021-10-21T03:37:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3901",
    "body": "Trying with redisson - 3.16.3\r\n\r\nNot able to get the value already set in the redis.\r\nKey type stored in redis is of type STRING ( normal SET and GET operation )\t\r\n\r\nIn this test, I have set the key 'b' as follows using redis-cli:\r\n```\r\n\tMASTER:6379> set b 5\r\n\tOK\r\n\tMASTERNODE:6379> get b\r\n\t\"5\"\r\n```\r\nTrying the below code gives the following error:\r\n```\t\t\r\n\tConfig config = new Config();\r\n            config.useMasterSlaveServers()\r\n                .setMasterAddress(\"rediss://MASTERNODE:6379\")\r\n                .addSlaveAddress(\"rediss://REPLICA:6379\")\r\n                .setReadMode(ReadMode.SLAVE)\r\n                .setPassword(auth);\r\n        RedissonClient redisson = Redisson.create(config);\r\n        try{\r\n            \r\n            RBucket<String> bucket = redisson.getBucket(\"b\");\r\n            // bucket.set(\"5\");\r\n            String value = bucket.get();\r\n            System.out.println(\"\");\r\n            System.out.println(\"Output of `GET a` using Redisson: \" + value);\r\n        }\r\n        finally{\r\n            redisson.shutdown();\r\n        }\r\n```\r\nMESSAGES:\r\n```\t\t\r\n[redisson-netty-2-20] INFO org.redisson.connection.pool.MasterPubSubConnectionPool - 1 connections initialized for MASTERNODE/172.31.11.70:6379\r\n[redisson-netty-2-20] INFO org.redisson.connection.pool.MasterConnectionPool - 24 connections initialized for MASTERNODE/172.31.11.70:6379\r\n[redisson-netty-2-22] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for REPLICANODE/172.31.16.214:6379\r\n[redisson-netty-2-9] INFO org.redisson.connection.pool.SlaveConnectionPool - 24 connections initialized for REPLICANODE/172.31.16.214:6379\r\n[redisson-netty-2-29] ERROR org.redisson.client.handler.CommandDecoder - Unable to decode data. channel: [id: 0xe65711f6, L:/172.31.8.24:47214 - R:REPLICANODE/172.31.16.214:6379], reply: ReplayingDecoderByteBuf(ridx=7, widx=7), command: (GET), promise: RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@7ff9d957(incomplete)], params: [b]\r\njava.io.IOException: Unsupported protocol version 53\r\n        at org.jboss.marshalling.river.RiverUnmarshaller.start(RiverUnmarshaller.java:1375)\r\n        at org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:145)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:383)\r\n        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n        at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1372)\r\n        at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1235)\r\n        at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1284)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:446)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.lang.Thread.run(Thread.java:748)\r\n[redisson-netty-2-29] ERROR org.redisson.client.handler.ErrorsLoggingHandler - Exception occured. Channel: [id: 0xe65711f6, L:/172.31.8.24:47214 - R:REPLICANODE/172.31.16.214:6379]\r\nio.netty.handler.codec.DecoderException: java.io.IOException: Unsupported protocol version 53\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n        at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1372)\r\n        at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1235)\r\n        at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1284)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:446)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.io.IOException: Unsupported protocol version 53\r\n        at org.jboss.marshalling.river.RiverUnmarshaller.start(RiverUnmarshaller.java:1375)\r\n        at org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:145)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:383)\r\n        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n        ... 26 more\r\nException in thread \"main\" org.redisson.client.RedisException: Unexpected exception while processing command\r\n        at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:326)\r\n        at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:123)\r\n        at org.redisson.RedissonObject.get(RedissonObject.java:82)\r\n        at org.redisson.RedissonBucket.get(RedissonBucket.java:104)\r\n        at com.example.app.App.main(App.java:43)\r\nCaused by: java.io.IOException: Unsupported protocol version 53\r\n        at org.jboss.marshalling.river.RiverUnmarshaller.start(RiverUnmarshaller.java:1375)\r\n        at org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:145)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:383)\r\n        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n        at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1372)\r\n        at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1235)\r\n        at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1284)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:446)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.lang.Thread.run(Thread.java:748)\r\n\t\t\r\n```\t\t\r\nIf I uncomment the `bucket.set(\"5\")` and then try, it works.\r\nBut the value of key \"b\" is something like: \r\n```\r\n\tMASTERNODE:6379> get b\r\n\t\"\\x04>\\x015\"\r\n```\r\nWhy there are extra characters while creating a STRING key-value using RBucket ?\r\nIs there a way to streamline this so that [STRING] values set from other sources can be read with RBucket ?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3901/comments",
    "author": "sssyam",
    "comments": [
      {
        "user": "SplotyCode",
        "created_at": "2021-10-20T20:10:47Z",
        "body": "When creating an RBucket you can pass a Codec. For your use case you would want a StringCodec.\r\n```     \r\nRedissonClient client;\r\nRBucket<String> bucket = client.getBucket(\"b\", StringCodec.INSTANCE);\r\n```\r\n"
      }
    ]
  },
  {
    "number": 3897,
    "title": "AWS Elasticache Redis Replicated server and master failover",
    "created_at": "2021-10-18T17:34:08Z",
    "closed_at": "2021-10-27T05:40:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3897",
    "body": "Hi,\r\nwe use the latest version of redisson and a 3 node AWS Redis (one master, 2 replica).\r\nThe config yaml list all three node as replicated server.\r\n\r\nDuring a service update deployment, AWS update the 3 nodes, doing a failover of the master to an updated replica to update the last node.\r\nOur application has logged a few errors -READONLY You can't write against a read only replica.\r\nfor around 500ms.\r\n\r\nIs there an automatic system in redisson that will try to revalidate where is the master node in case of READONLY error ?\r\ndoes those 500ms between the moment AWS swith the old master to a read replica and promote a new master ?\r\nor is it the leftover of the scaninterval use by the connection manager to check for new master ?\r\nAny way to avoid or react (retry) easily on those errors ?\r\n(this error popup in code using cachemanager, but we also use RBucket)\r\n\r\nThanks.\r\n\r\n   stack_trace: org.redisson.client.RedisException: ERR Error running script (call to f_401d7fca9b4e9022dffaa4fd236958c2babbc2f3): @user_script:1: @user_script: 1: -READONLY You can't write against a read only replica.   . channel: [id: 0x5225fb11, L:/172.17.0.4:42752 - R:xxx.use1.cache.amazonaws.com/a.b.c.d:6379] command: (EVAL), promise: RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@24f6631a(incomplete)], params: [local insertable = false; local value = redis.call('hget', KEYS[1], ARGV[5]); local t, val;if value ..., 8, xxx, redisson__timeout__set:{xxx}, redisson__idle__set:{xxx}, redisson_map_cache_created:{xxx}, redisson_map_cache_updated:{xxx}, redisson__map_cache__last_access__set:{xxx}, redisson_map_cache_removed:{xxx}, {xxx}:redisson_options, ...]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:370)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1372)\r\n\tat io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1235)\r\n\tat io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1284)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:446)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Unknown Source)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3897/comments",
    "author": "CyrilDevOps",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-10-21T12:50:35Z",
        "body": "> Is there an automatic system in redisson that will try to revalidate where is the master node in case of READONLY error ?\r\n\r\nIt's not implemented yet. This can be handled as for RedisBusyException.\r\n\r\n> does those 500ms between the moment AWS swith the old master to a read replica and promote a new master ?\r\n\r\nIt's better to ask AWS Support Team. \r\n\r\nI need more logs. If `READONLY You can't write against a read only replica` error occurs after topology update then it's inaccurate implementation by Redis vendor. failover should be completed once node is ready for write operation in your case and not earlier."
      }
    ]
  },
  {
    "number": 3892,
    "title": "Is RBatch a single get/put call to Redis server using MGET/MSET functionality",
    "created_at": "2021-10-14T21:25:25Z",
    "closed_at": "2021-10-20T05:56:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3892",
    "body": "RBuckets uses MSET/MGET functionality but RBuckets.set() doesn't have an option to set TTL for entries.\r\n\r\nFrom documentation of RBatch, it was mentioned: RBatch requests are batched to separate queue and could be executed later with execute(). Does this mean each request in batch gets executed at once or is MSET/MGET functionality used to execute all requests of batch at once?\r\n\r\n@mrniko Can you please confirm if results of batch.execute() is in order and if value is not present in cache for get request, does it return null?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3892/comments",
    "author": "mevemula",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-10-15T04:57:19Z",
        "body": "`MSET` command doesn't allow to define TTL.\r\n\r\nRBatch is executed only if execute() method invoked. MSET/MGET functionality is used only if RBuckets methods were invoked."
      },
      {
        "user": "mevemula",
        "created_at": "2021-10-15T10:11:27Z",
        "body": "So for RBatch, each request from queue is executed at once asynchronously?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-10-15T10:24:58Z",
        "body": "No, commands are also queued."
      },
      {
        "user": "mevemula",
        "created_at": "2021-10-15T10:29:42Z",
        "body": "ok, thanks for quick response.\r\n\r\nAny suggestions on using RBuckets, RBucket and RBatch for latency improvement when frequency of calls to Redis increase per second?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-10-20T05:56:41Z",
        "body": "All I can say that it depends on data size. Sometimes batch faster than multiple calls."
      }
    ]
  },
  {
    "number": 3887,
    "title": "Unable to send PING command over channel: L:/127.0.0.1:65454 - R:localhost/127.0.0.1:7000",
    "created_at": "2021-10-13T11:39:10Z",
    "closed_at": "2021-10-15T05:35:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3887",
    "body": "I have a local redis server (version: 6.2.6), redisson(3.16.0) and **after a few mins of application startup**, I see errors related to Redis connect timeout in logs:\r\nUnable to send PING command over channel: [id: 0x87172b36, L:/127.0.0.1:65454 - R:localhost/127.0.0.1:7000]\r\n   [java] org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://localhost:7000]\r\n   [java] \tat org.redisson.client.RedisConnection.lambda$async$1(RedisConnection.java:219) ~[Redisson-3.16.0.jar:?]\r\n   [java] \tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672) ~[netty-all-4.1.jar:4.1.48.Final]\r\n   [java] \tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747) ~[netty-all-4.1.jar:4.1.48.Final]\r\n   [java] \tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472) ~[netty-all-4.1.jar:4.1.48.Final]\r\n   [java] \tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-all-4.1.jar:4.1.48.Final]\r\n   [java] \tat java.lang.Thread.run(Thread.java:829) [?:?]\r\n   \r\n**And sometimes during application startup, I see this error (not reproducible):**\r\n\r\n  Caused by: RedisConnectionException: Unable to init enough connections amount! Only 2 of 10 were initialized. Redis server: localhost/127.0.0.1:7000\r\n     [java] \tat ConnectionPool$1.lambda$run$0(ConnectionPool.java:158)\r\n     [java] \tat RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)\r\n     [java] \tat DefaultPromise.notifyListener0(DefaultPromise.java:577)\r\n     [java] \tat DefaultPromise.notifyListenersNow(DefaultPromise.java:551)\r\n     [java] \tat DefaultPromise.notifyListeners(DefaultPromise.java:490)\r\n     [java] \tat DefaultPromise.setValue0(DefaultPromise.java:615)\r\n     [java] \tat DefaultPromise.setFailure0(DefaultPromise.java:608)\r\n     [java] \tat DefaultPromise.tryFailure(DefaultPromise.java:117)\r\n     [java] \tat RedissonPromise.tryFailure(RedissonPromise.java:96)\r\n     [java] \tat ConnectionPool.promiseFailure(ConnectionPool.java:328)\r\n     [java] \tat ConnectionPool.lambda$createConnection$1(ConnectionPool.java:294)\r\n     [java] \tat RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)\r\n     [java] \tat DefaultPromise.notifyListener0(DefaultPromise.java:577)\r\n     [java] \tat DefaultPromise.notifyListeners0(DefaultPromise.java:570)\r\n     [java] \tat DefaultPromise.notifyListenersNow(DefaultPromise.java:549)\r\n     [java] \tat DefaultPromise.notifyListeners(DefaultPromise.java:490)\r\n     [java] \tat DefaultPromise.setValue0(DefaultPromise.java:615)\r\n     [java] \tat DefaultPromise.setFailure0(DefaultPromise.java:608)\r\n     [java] \tat DefaultPromise.tryFailure(DefaultPromise.java:117)\r\n     [java] \tat RedissonPromise.tryFailure(RedissonPromise.java:96)\r\n     [java] \tat RedisClient$2$1.run(RedisClient.java:242)\r\n     [java] \tat AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\r\n     [java] \tat SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)\r\n     [java] \tat NioEventLoop.run(NioEventLoop.java:500)\r\n     [java] \tat SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n     [java] \tat ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n     [java] \tat FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n     [java] \tat java.base/Thread.run(Thread.java:829)\r\n     [java] Caused by: RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://localhost:7000]\r\n     [java] \tat RedisConnection.lambda$async$1(RedisConnection.java:219)\r\n     [java] \tat HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672)\r\n     [java] \tat HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747)\r\n     [java] \tat HashedWheelTimer$Worker.run(HashedWheelTimer.java:472)\r\n     [java] \t... 2 more\r\n     \r\n   Redisson SingleServer Config:\r\n    .setConnectionPoolSize(15)\r\n        .setConnectionMinimumIdleSize(10)\r\n        .setConnectTimeout(3000)\r\n        .setRetryAttempts(0)\r\n        .setTimeout(60)\r\n        .setIdleConnectionTimeout(5000)\r\n        .setPingConnectionInterval(3000)\r\n\r\nIs this related to pingConnectionInterval settings? Also one other question, is retryAttempts = 1 considered as first attempt?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3887/comments",
    "author": "mevemula",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-10-15T05:34:03Z",
        "body": "Check your network connection.\r\n\r\n> Is this related to pingConnectionInterval settings?\r\n\r\nYes.\r\n\r\n> Also one other question, is retryAttempts = 1 considered as first attempt?\r\n\r\nConsidered as a single attempt."
      },
      {
        "user": "wcandml",
        "created_at": "2021-10-19T01:31:17Z",
        "body": "set \r\n`idleConnectionTimeout=pingConnectionInterval`\r\n\r\n the problem does not reappear。  @mevemula You can try, a temporary solution。"
      }
    ]
  },
  {
    "number": 3873,
    "title": "Reddison 3.16.3 is using netty-common 4.1.68.Final and netty-handler 4.1.68.Final but when I upgrade latest version of reddison is still using netty 4.1.66 version",
    "created_at": "2021-10-08T18:36:47Z",
    "closed_at": "2021-10-11T09:59:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3873",
    "body": "Hi Everyone!\r\n\r\nI am using in my pom.xml the latest version of ```reddison - 3.16.3``` which is supposed to use the latest versions of ```netty-handler``` and ```netty-codec```, but when I run ```mvn dependency:tree -Dincludes=io.netty:netty-codec``` and ```mvn dependency:tree -Dincludes=io.netty:netty-handler``` I see it is using ```4.1.66 version``` instead of ```4.1.68 version```.\r\n\r\nCan we take a look at this please?\r\n\r\nThank you.\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3873/comments",
    "author": "constantinirimia",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-10-11T09:58:54Z",
        "body": "Unable to reproduce it. Here is the output\r\n\r\n```\r\n[INFO] Scanning for projects...                                                                   \r\n[INFO] Inspecting build with total of 1 modules...                                                \r\n[INFO] Installing Nexus Staging features:                                                         \r\n[INFO]   ... total of 1 executions of maven-deploy-plugin replaced with nexus-staging-maven-plugin\r\n[INFO]                                                                                            \r\n[INFO] -----------------------< org.redisson:redisson >------------------------                   \r\n[INFO] Building Redisson 3.16.4-SNAPSHOT                                                          \r\n[INFO] --------------------------------[ jar ]---------------------------------                   \r\n[INFO]                                                                                            \r\n[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ redisson ---                          \r\n[INFO] org.redisson:redisson:jar:3.16.4-SNAPSHOT                                                  \r\n[INFO] \\- io.netty:netty-codec:jar:4.1.68.Final:compile                                           \r\n[INFO] ------------------------------------------------------------------------                   \r\n[INFO] BUILD SUCCESS                                                                              \r\n[INFO] ------------------------------------------------------------------------                   \r\n[INFO] Total time:  3.906 s                                                                       \r\n[INFO] Finished at: 2021-10-11T12:58:41+03:00                                                     \r\n[INFO] ------------------------------------------------------------------------                   \r\n                                                                                                  \r\nC:\\Devel\\projects\\redisson\\redisson>mvn dependency:tree -Dincludes=io.netty:netty-handler         \r\n[INFO] Scanning for projects...                                                                   \r\n[INFO] Inspecting build with total of 1 modules...                                                \r\n[INFO] Installing Nexus Staging features:                                                         \r\n[INFO]   ... total of 1 executions of maven-deploy-plugin replaced with nexus-staging-maven-plugin\r\n[INFO]                                                                                            \r\n[INFO] -----------------------< org.redisson:redisson >------------------------                   \r\n[INFO] Building Redisson 3.16.4-SNAPSHOT                                                          \r\n[INFO] --------------------------------[ jar ]---------------------------------                   \r\n[INFO]                                                                                            \r\n[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ redisson ---                          \r\n[INFO] org.redisson:redisson:jar:3.16.4-SNAPSHOT                                                  \r\n[INFO] \\- io.netty:netty-handler:jar:4.1.68.Final:compile                                         \r\n[INFO] ------------------------------------------------------------------------                   \r\n[INFO] BUILD SUCCESS                                                                              \r\n[INFO] ------------------------------------------------------------------------                   \r\n[INFO] Total time:  3.982 s                                                                       \r\n[INFO] Finished at: 2021-10-11T12:58:56+03:00                                                     \r\n[INFO] ------------------------------------------------------------------------                   \r\n```"
      },
      {
        "user": "tntstn",
        "created_at": "2021-12-03T11:19:36Z",
        "body": "@constantinirimia I have faced same problem, did you solve it and how?"
      },
      {
        "user": "philbrock",
        "created_at": "2023-01-05T16:43:00Z",
        "body": "> @constantinirimia I have faced same problem, did you solve it and how?\r\n\r\nAre you using Spring Boot at all? Spring Boot uses Maven's \"dependency management\" to define the versions of a whole lot of different dependencies via the `spring-boot-dependencies` POM, linked to by the `spring-boot-start-parent` POM, including the Netty libs. If you're finding expected versions of things are being replaced with older versions, *and* you're using Spring Boot, it's almost certainly why."
      }
    ]
  },
  {
    "number": 3870,
    "title": "How to get notified when the key has been expired by TTL",
    "created_at": "2021-10-07T09:29:53Z",
    "closed_at": "2021-10-08T06:31:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3870",
    "body": null,
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3870/comments",
    "author": "kpchu",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-10-08T06:31:39Z",
        "body": "Use `org.redisson.api.RBucket#addListener()` method."
      }
    ]
  },
  {
    "number": 3869,
    "title": "org.redisson.client.RedisResponseTimeoutException: Redis server response timeout when use RLock",
    "created_at": "2021-10-06T15:27:39Z",
    "closed_at": "2021-10-21T06:50:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3869",
    "body": "\r\n - TryLock fail providerCode: [NHATTRAN]{Exception:org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured after 3 retry attempts. Increase nettyThreads and/or timeout settings. Command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hincrby', KEYS[1], ARGV[2], 1); redis.call(..., 1, LOCK-SESSIONID-POSTPAID-NHATTRAN, 30000, 5d2016cc-0013-45c8-9983-d48f5df0901d:338], channel: [id: 0x4eac29a6, L:/10.42.82.134:41274 - R:10.109.3.26/10.109.3.26:8379] -- StackTrace:org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured after 3 retry attempts. Increase nettyThreads and/or timeout settings. Command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hincrby', KEYS[1], ARGV[2], 1); redis.call(..., 1, LOCK-SESSIONID-POSTPAID-NHATTRAN, 30000, 5d2016cc-0013-45c8-9983-d48f5df0901d:338], channel: [id: 0x4eac29a6, L:/10.42.82.134:41274 - R:10.109.3.26/10.109.3.26:8379\r\n \r\nMy Redis don't use cluster just only one node address.\r\n I used RLock for locking but was not successful because of Redis timeout. I restarted the service, it worked but it's not the best way in the production stage. \r\n I referred to the same issue about Redis timeout such as an increased nettyThreads or timeout config but it's not successful.\r\n\r\n ###Redis version\r\n3.12.3\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3869/comments",
    "author": "KietPT",
    "comments": [
      {
        "user": "KietPT",
        "created_at": "2021-10-06T15:30:51Z",
        "body": "do you mind if you check my above issue, @mrniko  ? Thank you very much"
      },
      {
        "user": "mrniko",
        "created_at": "2021-10-12T11:38:23Z",
        "body": "can you share code to reproduce?"
      }
    ]
  },
  {
    "number": 3860,
    "title": "How does PING influences the BATCH command?",
    "created_at": "2021-10-04T09:42:08Z",
    "closed_at": "2021-10-05T08:23:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3860",
    "body": "I'm doing a batch command in the following way:\r\n\r\n```\r\n...\r\n  final RBatch rBatch = redissonClient.createBatch();\r\n        for (final String key : keys) {\r\n            rBatch.getMap(key, StringCodec.INSTANCE).getAsync(fieldName);\r\n        }\r\n  final List<?> responses = rBatch.execute().getResponses();\r\n ...\r\n```\r\nFrom time to time we get the following Timeout exception:\r\n```\r\norg.redisson.client.RedisResponseTimeoutException: Redis server response timeout (20 ms) occured after 0 retry attempts. Increase nettyThreads and/or timeout settings. Try to define pingConnectionInterval setting. Command: null, params: null\r\n```\r\n\r\nI'm wondering about the *Try to define pingConnectionInterval setting.* in the WARN message. We use the default setting for PING (the 30s interval). What is the meaning of that sentence in the message? Is the PING necessary? Could we disable the PING?  How does the PING influences the batch command? Any suggestions how this WARN can be avoided?\r\n\r\n\r\nRedis: 5.0.5\r\nRedisson: 3.16.3\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3860/comments",
    "author": "mircea-pop",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-10-04T11:33:26Z",
        "body": "I think in your case it's just a network delay due to response size."
      },
      {
        "user": "mircea-pop",
        "created_at": "2021-10-04T13:04:58Z",
        "body": "so the message in this case is not specific, but rather a \"catch all\" approach.\r\nThanks!"
      },
      {
        "user": "mircea-pop",
        "created_at": "2021-10-04T13:06:12Z",
        "body": "would it be OK to completely disable the PING? is there some documentation on how the PING influences the connection pool?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-10-05T07:59:57Z",
        "body": "yes, you can disable PING. It's recommended only if your Redis setup is behind of proxy and it doesn't propagate connection interruptions."
      },
      {
        "user": "mircea-pop",
        "created_at": "2021-10-05T08:23:34Z",
        "body": "thank you! "
      }
    ]
  },
  {
    "number": 3858,
    "title": "when use CompletableFuture.runAsync to create thread we got no class definition found from redisson ",
    "created_at": "2021-10-03T14:54:21Z",
    "closed_at": "2021-10-22T07:21:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3858",
    "body": "when start new thread using CompletableFuture.runAsync we have no class definition found \r\n\r\nwe have useThreadClassLoader: true\r\n\r\n\r\norg.redisson.client.RedisException: Unexpected exception while processing command\r\n\tat org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:351)\r\n\tat org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:148)\r\n\tat org.redisson.RedissonObject.get(RedissonObject.java:81)\r\n\tat org.redisson.RedissonMap.get(RedissonMap.java:618)\r\n\r\nCaused by: java.io.IOException: java.lang.ClassNotFoundException: com.panaya.domain.tm.entityMetaData.PemEntity\r\n\tat org.redisson.codec.MarshallingCodec$3.decode(MarshallingCodec.java:153)\r\n\tat org.redisson.codec.SnappyCodec$3.decode(SnappyCodec.java:84)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:356)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:178)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(Byt",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3858/comments",
    "author": "wdaas",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-10-04T06:26:34Z",
        "body": "thread classloader of executor passed to CompletableFuture.runAsync isn't aware of these classes."
      }
    ]
  },
  {
    "number": 3839,
    "title": "Stream - DS",
    "created_at": "2021-09-19T23:26:36Z",
    "closed_at": "2021-09-24T13:52:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3839",
    "body": "Let's imagine a stream created like this.\r\n\r\n`RStreamReactive<String, PaymentEvent> stream = redissonReactiveClient.getStream(\"payment-stream\", new TypedJsonJacksonCodec(String.class, PaymentEvent.class));`\r\n\r\n  I thought I should be able to add a list of payment events into the stream. But looks like I need to always convert it into a map to add it to the stream.\r\n\r\n```\r\n  StreamAddArgs.entry()\r\n  StreamAddArgs.entries(....)\r\n```\r\n\r\n  My point is - each stream entry is for 1 event. Not for collection of events.\r\n  I have to add it like this.\r\n\r\n```\r\n  for(paymentevent : events){\r\n  \tStreamAddArgs.entry(\"unnessaryKey\", paymentevent);\r\n  \t.....\r\n  }\r\n```\r\nIf we see, the key is basically unnecessary here.\r\n\r\n Can you please explain the reason behind the such data structure? Is it because redis's limitation? Or do we have any other better use case?\r\n \r\n ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3839/comments",
    "author": "kitkars",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-09-22T14:19:04Z",
        "body": "> Can you please explain the reason behind the such data structure? Is it because redis's limitation? \r\n\r\nThis structure used by Redis"
      },
      {
        "user": "kitkars",
        "created_at": "2021-09-24T13:52:24Z",
        "body": "Ok Thanks @mrniko "
      }
    ]
  },
  {
    "number": 3834,
    "title": "Inconsistent Performance Retrieving Data From Redis with Redisson",
    "created_at": "2021-09-17T00:35:33Z",
    "closed_at": "2021-09-24T06:21:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3834",
    "body": "We have Redis setup in as a Master with 2 Slaves.  Generally it works well.  Occasionally when we pull a large cached object from Redis, the time to pull the data from the cache is 50-60 seconds.  The good times we have seen are 3-6 seconds to pull the same data.  Is their anything we can do to make it more consistent (obviously we want it to be in the 3-6 seconds range).  The data is stored in an RList.  This particular case the data is very large, 16-17MB.  This is an unusual case, but we need to be faster nonetheless.\r\n\r\nI have run the latency checks on the server, no issues there.\r\n\r\nI will add that we are constantly adding new items to the cache.  These items expire after 60 minutes (ttl).  The cache typically has about 1600 items in it at any given time (during peak usage hours).  Redis is running inside a Kubernetes environment, as is the client application (same K8S environment).  Memory usage for the 3 Redis instances is hovering around 70-80MB we have allocated 2G for each (max).\r\n\r\nIs there anything you can think of that would cause a request for cached item to suddenly take 50-60 seconds?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3834/comments",
    "author": "packley1",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-09-20T09:49:42Z",
        "body": "try to set retryInterval to 7 seconds"
      }
    ]
  },
  {
    "number": 3831,
    "title": "如何使用 jasypt 加密配置",
    "created_at": "2021-09-16T03:08:55Z",
    "closed_at": "2021-09-16T07:14:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3831",
    "body": "`redisson` 的配置好像无法使用 `jasypt` 进行加密解密？\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3831/comments",
    "author": "linyongfu2013",
    "comments": [
      {
        "user": "linyongfu2013",
        "created_at": "2021-09-16T03:51:34Z",
        "body": "使用单独的`redisson.yml` 无法使用`jasypt`加密解密，而写在`application.yml` 则可以\r\n```\r\nspring:\r\n  redis:\r\n    database: 2\r\n    host: 127.0.0.1\r\n    port: 1234\r\n    password: ENC(NPWxPDc4zQeCLUnv/iHez2TkBdc/WZjd)\r\n    lettuce:\r\n      pool:\r\n        min-idle: 1\r\n        max-idle: 5\r\n        max-active: 20\r\n        max-wait: 60000\r\n    redisson:\r\n#      file: \"classpath:redisson-dev.yml\"\r\n      config:\r\n        singleServerConfig:\r\n          address: \"redis://127.0.0.1:1234\"\r\n          password: ENC(NPWxPDc4zQeCLUnv/iHez2TkBdc/WZjd)\r\n          database: 2\r\n        threads: 0\r\n        nettyThreads: 0\r\n        codec:\r\n          class: \"org.redisson.codec.JsonJacksonCodec\"\r\n        transportMode: NIO\r\n```\r\n\r\n但是这样又出现另外一个问题，就是序列化变成了二进制，配置的序列化方式不起作用了。\r\n另外，文档写的默认的序列化是`JsonJacksonCodec`，但我实测并不是啊，默认用的还是二进制方式。"
      },
      {
        "user": "mrniko",
        "created_at": "2021-09-16T07:08:24Z",
        "body": "jasypt isn't supported. Default codec is MarshallingCodec"
      }
    ]
  },
  {
    "number": 3830,
    "title": "Unable to send PING during load test",
    "created_at": "2021-09-14T16:51:37Z",
    "closed_at": "2021-09-22T14:25:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3830",
    "body": "While running a load test, I'm occasionally seeing these \"Unable to send PING command\" errors. Wondering if there's a particular timeout setting I can use to try to overcome these. Separately, trying to understand if this could be related to spurious disconnects seen by a configured ConnectionListener. In a previous question, I asked about any experience/advice regarding how to manage cases where a RedissonClient loses connections that are never re-established. If a RedissonClient has disconnected from a cluster, what is the best way to heal it and re-establish connections to the cluster?\r\n\r\n[redisson-timer-11-1] 14 Sep 2021 12:04:25,110-0400 ERROR PingConnectionHandler  Unable to send PING command over channel: [id: 0x3a394b04, L:0.0.0.0/0.0.0.0:36126 ! R:prom-cnrpoc-redlock-1-dev-0001-002.prom-cnrpoc-redlock-1-dev.kct6w1.use1.cache.amazonaws.com/10.147.1\r\n        at org.redisson.client.RedisConnection.lambda$async$1(RedisConnection.java:219)                                                                                                                                                                                      \r\n        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:669)                                                                                                                                                                               \r\n        at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:744)                                                                                                                                                                        \r\n        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:469)                                                                                                                                                                                              \r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)                                                                                                                                                                             \r\n        at java.lang.Thread.run(Thread.java:748)                                                                                                                                                                                                                             \r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3830/comments",
    "author": "nattobean",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-09-16T07:12:59Z",
        "body": "> If a RedissonClient has disconnected from a cluster, what is the best way to heal it and re-establish connections to the cluster?\r\n\r\nRedisson reconnects automatically. I need logs to see that is the cause.\r\n\r\n> Unable to send PING command over channel\r\n\r\nCan you share full stacktrace? There is should be a root cause."
      },
      {
        "user": "nattobean",
        "created_at": "2021-09-22T15:27:27Z",
        "body": "Yes. I will collect the logs and share. Was traveling the last week. Thank you for responding."
      }
    ]
  },
  {
    "number": 3827,
    "title": "Question about ConnectionListener with AWS ElastiCache for Redis",
    "created_at": "2021-09-10T00:42:48Z",
    "closed_at": "2021-12-22T07:46:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3827",
    "body": "Hello,\r\n\r\nWe have multiple instances of an application running in AWS ECS.\r\n\r\nWe periodically encounter a scenario where one (not all) container's RedissonClient with ConnectionListener receives onDisconnect calls from previously connected Redis hosts that never connects again. Other containers remain connected to the same hosts and are able to operate as expected.\r\n\r\nHoping for assistance to understand a way to avoid this scenario.\r\n\r\nWhen we run against a docker cluster on our local computers, we are able to restart Redis instances at will and see disconnects and reconnects as we expect. Only in AWS do we find permanent disconnects. Eventually, our RedissonClient is disconnected from Redis completely and cannot make any progress on its work.\r\n\r\nThank you for any help.\r\n\r\nOur RedissonClient is created more or less like so:\r\n\r\n```\r\n    val redissonConfig = new RedissonConfig\r\n    val clusterConfig  = redissonConfig.useClusterServers\r\n\r\n    clusterConfig\r\n      .setConnectTimeout(...)\r\n      .setTimeout(...)\r\n      .setPingConnectionInterval(...)\r\n      .setRetryAttempts(...)\r\n      .setScanInterval(...)\r\n      .setPassword(...)\r\n\r\n    for (host <- hosts)\r\n      clusterConfig.addNodeAddress(host)\r\n\r\n    redissonConfig.setConnectionListener(new RedisConnectionListener(...))\r\n    val client = Redisson.create(redissonConfig)\r\n```\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3827/comments",
    "author": "nattobean",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-09-16T07:12:07Z",
        "body": "Can you share logs with `TRACE` logging level for `org.redisson` package?"
      },
      {
        "user": "nattobean",
        "created_at": "2021-09-23T01:04:37Z",
        "body": "The logs from my load test are pretty massive. Not sure what parts are most helpful. However, here is what I see just before all the onDisconnect calls:\r\n\r\n`[redisson-netty-16-3] 22 Sep 2021 19:24:32,757-0400 DEBUG IdleConnectionWatcher  Connection [id: 0xb06737df, L:/172.17.0.2:58650 ! R:prom-cnrpoc-redlock-2-dev-0001-001.prom-cnrpoc-redlock-2-dev.kct6w1.use1.cache.amazonaws.com/10.147.161.116:5432] has been closed due to idle timeout. Not used for 11015 ms\r\n`\r\nBut in AWS, I never see that host reconnect. BTW, that was a master node. What should trigger a reconnect? Is there a way to set the configuration so that connections to master nodes are always maintained?\r\n\r\nOne reason we are tracking connections with a ConnectionListener is to overcome performance degradation that we saw while doing failover testing. We are using RedissonRedLock (understanding it's deprecated), we are using the ConnectionListener to avoid asking RedLock to try to acquire a lock from a cluster we know is disconnected.\r\n\r\nIdeally, we would not have to worry about any of this. But when we triggered a primary failover in AWS, as I mentioned, performance degraded and did not appear to recover.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2021-12-22T07:46:30Z",
        "body": "> What should trigger a reconnect? \r\n\r\nReconnection is not triggered for closed idle connections.\r\n\r\n> Is there a way to set the configuration so that connections to master nodes are always maintained?\r\n\r\nYou need to increase `masterConnectionMinimumIdleSize` setting."
      }
    ]
  },
  {
    "number": 3815,
    "title": "Curious to ask, why deprecate the json configuration ?",
    "created_at": "2021-09-06T09:24:43Z",
    "closed_at": "2021-09-07T07:23:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3815",
    "body": "When I used `org.redisson.config.Config#fromJSON(java.lang.String)` to generate Config, I found that this method has been deprecated.\r\n\r\nWhen using `redisson-spring-boot-starter`, the value of `spring.redis.redisson.config` is String. I think json String is less prone to format errors than yaml String.\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3815/comments",
    "author": "roverbeta",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-09-06T10:08:12Z",
        "body": "to remove dependency from jackson json lib in future."
      }
    ]
  },
  {
    "number": 3790,
    "title": "Why Redission session manager stopped working after new virtual host in Tomcat",
    "created_at": "2021-08-21T02:06:20Z",
    "closed_at": "2021-09-23T05:42:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3790",
    "body": "Hello, our redisson session manager 3.10.6 has stopped persisting session data. It stays as long as browser session is on, but won't work otherwise, means closing browser and opening.\r\n\r\nWe are using SHIRO for authentication and authorisation, and redisson usually works in background with session management. However, with a recently introduced virtual host in tomcat and few tweaks in server.xml and nginx (upstream) new server block, the persistence has gone.\r\n\r\nOn top of it, we are also using BigBlueButton web conference solution which also work with redid-server. It developed some problems of its own, now not storing sessions as well.\r\n\r\nThis started happening once we introduced new domain and virtual host to the web server.\r\n\r\nBelow are the technical details\r\ntomcat/lib has redisson 3.10.6 tomcat-all and tomcat-7\r\n\r\ntomcat/conf has redisson.conf file\r\n_singleServerConfig:\r\n  idleConnectionTimeout: 10000\r\n  pingTimeout: 1000\r\n  connectTimeout: 10000\r\n  timeout: 3000\r\n  retryAttempts: 3\r\n  retryInterval: 1500\r\n  password: null\r\n  subscriptionsPerConnection: 5\r\n  clientName: null\r\n  address: \"redis://127.0.0.1:6379\"\r\n  subscriptionConnectionMinimumIdleSize: 1\r\n  subscriptionConnectionPoolSize: 50\r\n  connectionMinimumIdleSize: 32\r\n  connectionPoolSize: 64\r\n  database: 0\r\n  dnsMonitoringInterval: 5000\r\nthreads: 0\r\nnettyThreads: 0\r\ncodec: !<org.redisson.codec.JsonJacksonCodec> {}\r\ntransportMode: \"NIO\"_\r\n\r\nProject maven pom.xml has redisson 3.10.6 dependency\r\n_<dependency>\r\n\t\t\t<groupId>org.redisson</groupId>\r\n\t\t\t<artifactId>redisson</artifactId>\r\n\t\t\t<version>3.10.6</version>\r\n\t\t</dependency>_\r\n\r\nShiro.ini has default web session manager set\r\n_sessionManager = org.apache.shiro.web.session.mgt.DefaultWebSessionManager_\r\n\r\nWe made all kinds of changes and combinations, but still cannot make redisson persist our session. Help!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3790/comments",
    "author": "vijaykanta",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-09-23T05:42:16Z",
        "body": "Sorry, I have never used SHIRO and can't help here."
      }
    ]
  },
  {
    "number": 3789,
    "title": "MacOSDnsServerAddressStreamProvider",
    "created_at": "2021-08-20T15:35:25Z",
    "closed_at": "2021-08-24T05:17:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3789",
    "body": "I try netty-resolver-dns-native-macos 4.1.67.Final and 4.1.65.Final and 4.1.63.Final but didn't work.\r\nI found netty maybe not support m1 how can I solve this problem.\r\nredisson - 3.16.1\r\nspring-boot - 2.5.2\r\napple m1\r\n\r\n\r\nERROR i.n.r.d.DnsServerAddressStreamProviders - Unable to load io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider, fallback to system defaults. This may result in incorrect DNS resolutions on MacOS.\r\njava.lang.reflect.InvocationTargetException: null\r\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\r\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\r\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\r\n\tat io.netty.resolver.dns.DnsServerAddressStreamProviders.<clinit>(DnsServerAddressStreamProviders.java:64)\r\n\tat org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:187)\r\n\tat org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:139)\r\n\tat org.redisson.connection.SingleConnectionManager.<init>(SingleConnectionManager.java:30)\r\n\tat org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:190)\r\n\tat org.redisson.Redisson.<init>(Redisson.java:67)\r\n\tat org.redisson.Redisson.create(Redisson.java:108)\r\n\tat me.zhengjie.config.RedisConfig.redisson(RedisConfig.java:111)\r\n\tat me.zhengjie.config.RedisConfig$$EnhancerBySpringCGLIB$$9a155270.CGLIB$redisson$2(<generated>)\r\n\tat me.zhengjie.config.RedisConfig$$EnhancerBySpringCGLIB$$9a155270$$FastClassBySpringCGLIB$$28ee32e8.invoke(<generated>)\r\n\tat org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244)\r\n\tat org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331)\r\n\tat me.zhengjie.config.RedisConfig$$EnhancerBySpringCGLIB$$9a155270.redisson(<generated>)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:486)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1334)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1177)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:564)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)\r\n\tat org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:887)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:791)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:229)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1354)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:564)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)\r\n\tat org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:887)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:791)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:229)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1354)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:564)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)\r\n\tat org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:887)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:791)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:229)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1354)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:564)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:410)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1334)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1177)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:564)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:233)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1273)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1234)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveBean(DefaultListableBeanFactory.java:494)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:349)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:342)\r\n\tat org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration.getSingleBeanOrNull(GlobalMethodSecurityConfiguration.java:181)\r\n\tat org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration.accessDecisionManager(GlobalMethodSecurityConfiguration.java:253)\r\n\tat org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration.methodSecurityInterceptor(GlobalMethodSecurityConfiguration.java:143)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:638)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1334)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1177)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:564)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:213)\r\n\tat org.springframework.security.access.intercept.aopalliance.MethodSecurityMetadataSourceAdvisor.getAdvice(MethodSecurityMetadataSourceAdvisor.java:104)\r\n\tat org.springframework.aop.aspectj.AspectJProxyUtils.isAspectJAdvice(AspectJProxyUtils.java:73)\r\n\tat org.springframework.aop.aspectj.AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(AspectJProxyUtils.java:54)\r\n\tat org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator.extendAdvisors(AspectJAwareAdvisorAutoProxyCreator.java:95)\r\n\tat org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findEligibleAdvisors(AbstractAdvisorAutoProxyCreator.java:98)\r\n\tat org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean(AbstractAdvisorAutoProxyCreator.java:78)\r\n\tat org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:338)\r\n\tat org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:290)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:437)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1790)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:602)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:944)\r\n\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918)\r\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583)\r\n\tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145)\r\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754)\r\n\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434)\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:338)\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1343)\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1332)\r\n\tat me.zhengjie.AppRun.main(AppRun.java:46)\r\nCaused by: java.lang.UnsatisfiedLinkError: io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.resolvers()[Lio/netty/resolver/dns/macos/DnsResolver;\r\n\tat io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.resolvers(Native Method)\r\n\tat io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.retrieveCurrentMappings(MacOSDnsServerAddressStreamProvider.java:107)\r\n\tat io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.<init>(MacOSDnsServerAddressStreamProvider.java:103)\r\n\t... 132 common frames omitted\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3789/comments",
    "author": "EF03",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-08-23T05:42:37Z",
        "body": "It's better to open this issue in netty project."
      }
    ]
  },
  {
    "number": 3787,
    "title": "spring cache and jackson InvalidDefinitionException",
    "created_at": "2021-08-20T08:22:15Z",
    "closed_at": "2021-08-20T08:48:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3787",
    "body": "ERROR o.r.client.handler.CommandDecoder - Unable to decode data. channel: [id: 0x72310cd6, L:/127.0.0.1:14072 - R:127.0.0.1/127.0.0.1:6379], reply: ReplayingDecoderByteBuf(ridx=128, widx=128), command: (HGET), params: [role, PooledUnsafeDirectByteBuf(ridx: 0, widx: 8, cap: 256)]\r\ncom.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `org.springframework.security.core.authority.SimpleGrantedAuthority` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\r\n at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 104] (through reference chain: java.util.ArrayList[0])\r\n\tat com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:67)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.reportBadDefinition(DeserializationContext.java:1764)\r\n\tat com.fasterxml.jackson.databind.DatabindContext.reportBadDefinition(DatabindContext.java:400)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1209)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1415)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:362)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:230)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:197)\r\n\tat com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedForId(AsPropertyTypeDeserializer.java:139)\r\n\tat com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:107)\r\n\tat com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromAny(AsPropertyTypeDeserializer.java:208)\r\n\tat com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla.deserializeWithType(UntypedObjectDeserializer.java:771)\r\n\tat com.fasterxml.jackson.databind.deser.std.CollectionDeserializer._deserializeFromArray(CollectionDeserializer.java:357)\r\n\tat com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:244)\r\n\tat com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:28)\r\n\tat com.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer._deserialize(AsArrayTypeDeserializer.java:120)\r\n\tat com.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer.deserializeTypedFromArray(AsArrayTypeDeserializer.java:53)\r\n\tat com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromAny(AsPropertyTypeDeserializer.java:206)\r\n\tat com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla.deserializeWithType(UntypedObjectDeserializer.java:771)\r\n\tat com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:74)\r\n\tat com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:322)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4593)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3585)\r\n\tat org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:99)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:366)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:183)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:107)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n2021-08-20 16:02:53 [XNIO-1 task-1] ERROR me.zhengjie.config.RedisConfig - Redis occur handleCacheGetError：key -> [auth:1]\r\norg.redisson.client.RedisException: Unexpected exception while processing command\r\n\r\n\r\n\r\n\r\n\r\nI found key auth:1 is [\"java.util.ArrayList\",{\"@class\":\"org.springframework.security.core.authority.SimpleGrantedAuthority\",\"role\":\"admin\"}]].\r\n\r\nI think the problem is jackson turn this value to List<GrantedAuthority>.\r\nBut I don't know how to solve it exactly.\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3787/comments",
    "author": "EF03",
    "comments": [
      {
        "user": "EF03",
        "created_at": "2021-08-20T08:24:29Z",
        "body": "```\r\n@Bean\r\npublic CacheManager cacheManager(RedissonClient redissonClient) {\r\n    List<RedissonProperties.CacheGroup> cacheGroup = redissonProperties.getCacheGroup();\r\n    Map<String, CacheConfig> config = new HashMap<>(16);\r\n    for (RedissonProperties.CacheGroup group : cacheGroup) {\r\n        CacheConfig cacheConfig = new CacheConfig(group.getTtl(), group.getMaxIdleTime());\r\n        cacheConfig.setMaxSize(group.getMaxSize());\r\n        config.put(group.getGroupId(), cacheConfig);\r\n    }\r\n    return new RedissonSpringCacheManager(redissonClient, config, JsonJacksonCodec.INSTANCE);\r\n}\r\n```\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2021-08-20T08:28:10Z",
        "body": "try to use `MarshallingCodec` or `Kryo5Codec`"
      },
      {
        "user": "EF03",
        "created_at": "2021-08-20T08:48:08Z",
        "body": "I try MarshallingCodec it cloud work. thanks ^^"
      }
    ]
  },
  {
    "number": 3784,
    "title": "Delay queue message loss",
    "created_at": "2021-08-19T11:30:34Z",
    "closed_at": "2021-08-25T05:58:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3784",
    "body": "\r\n@Slf4j\r\n@Component\r\npublic class RedisDelayService {\r\n\r\n    @Autowired\r\n    private RedissonClient redissonClient;\r\n\r\n    /**\r\n     * 添加到消息队列\r\n     * @param value 添加到队列的对象\r\n     * @param delay 延迟时间\r\n     * @param timeUnit 时间单位\r\n     * @param queueName 队列名称\r\n     * @param <T>\r\n     */\r\n    public <T> void addQueue(T value , long delay, TimeUnit timeUnit, String queueName){\r\n        try {\r\n            log.info(\"添加到延时队列【{}】【{}】【{}】\",value,delay,queueName);\r\n            RBlockingDeque<T> blockingDeque = redissonClient.getBlockingDeque(queueName);\r\n            RDelayedQueue<T> delayedQueue = redissonClient.getDelayedQueue(blockingDeque);\r\n            delayedQueue.offer(value,delay,timeUnit);\r\n        } catch (Exception e) {\r\n            log.error(\"添加到延时队列失败：\"+e.getMessage(),e);\r\n            throw new RuntimeException(\"添加到延时队列失败\");\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 取值\r\n     */\r\n    public <T> T take(String queueName) throws InterruptedException {\r\n        RBlockingDeque<T> blockingDeque = redissonClient.getBlockingDeque(queueName);\r\n        RDelayedQueue<T> delayedQueue = redissonClient.getDelayedQueue(blockingDeque);\r\n        return blockingDeque.take();\r\n    }\r\n}\r\n\r\n\r\n\r\n@Component\r\n@Slf4j\r\npublic class RedisDelayQueueRunner implements ApplicationRunner {\r\n\r\n    @Autowired\r\n    private RedissonClient redissonClient;\r\n    @Autowired\r\n    private RedisDelayService redisDelayService;\r\n\r\n    @Override\r\n    public void run(ApplicationArguments args) throws Exception {\r\n\r\n        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);\r\n\r\n        scheduledThreadPoolExecutor\r\n                .scheduleWithFixedDelay(\r\n                        () -> {\r\n                            log.info(Thread.currentThread().getName());\r\n                            Employer callCdr = null;\r\n                            try {\r\n                                callCdr = redisDelayService.take(\"delay_queue\");\r\n                            }catch (InterruptedException e){\r\n                                   log.info(e.getMessage());\r\n                                   e.printStackTrace();\r\n                            }\r\n                            log.info(\"订单取消时间：\" + new SimpleDateFormat(\"hh:mm:ss\").format(new Date()) + \"==订单生成时间\" + callCdr.getPutTime());\r\n                            },\r\n                        1, 1, TimeUnit.SECONDS);\r\n\r\n    }\r\n\r\n}\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3784/comments",
    "author": "buhuigundeqiu",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-08-19T11:58:01Z",
        "body": "is there any code to reproduce the issue?"
      },
      {
        "user": "buhuigundeqiu",
        "created_at": "2021-08-20T04:01:47Z",
        "body": "> is there any code to reproduce the issue?\r\n\r\n>Hi, I'm pasting the code here"
      },
      {
        "user": "mrniko",
        "created_at": "2021-08-24T11:47:50Z",
        "body": "which Redisson version do you use?"
      },
      {
        "user": "buhuigundeqiu",
        "created_at": "2021-08-24T12:17:16Z",
        "body": "> which Redisson version do you use?\r\n\r\n>3.13.6"
      },
      {
        "user": "mrniko",
        "created_at": "2021-08-24T12:19:26Z",
        "body": "3.15.0 version contains fix for lost messages during blocking queue methods invocation. Please update to the latest version."
      }
    ]
  },
  {
    "number": 3779,
    "title": "TransportMode",
    "created_at": "2021-08-15T07:04:49Z",
    "closed_at": "2021-08-16T01:46:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3779",
    "body": "TransportMode Indicates the differences between different configurations\r\n\r\nWhy is NIO selected by default\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3779/comments",
    "author": "wl980868110",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-08-15T14:10:11Z",
        "body": "it's considered as optimal mode."
      },
      {
        "user": "wl980868110",
        "created_at": "2021-08-16T01:46:59Z",
        "body": "thank you"
      }
    ]
  },
  {
    "number": 3777,
    "title": "Topic listener removal",
    "created_at": "2021-08-14T20:32:10Z",
    "closed_at": "2021-08-15T05:17:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3777",
    "body": "Is it necessary to explicitly remove a Topic listener before shutdown, or does shutdown remove it anyway?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3777/comments",
    "author": "asarkar",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-08-15T04:53:12Z",
        "body": "No, it's not necessary."
      },
      {
        "user": "asarkar",
        "created_at": "2021-08-15T05:17:18Z",
        "body": "@mrniko Rephrasing as “shutdown removes all local listeners, no need to do it explicitly”, closing this ticket. Thank you."
      },
      {
        "user": "mrniko",
        "created_at": "2021-08-15T06:00:25Z",
        "body": "it doesn't remove listeners, just shutdown network connection to Redis."
      },
      {
        "user": "asarkar",
        "created_at": "2021-08-15T06:19:01Z",
        "body": "I’m confused, isn’t that the same thing? Unless the server keeps a count of the listeners."
      },
      {
        "user": "asarkar",
        "created_at": "2021-08-15T20:49:11Z",
        "body": "For the record, I've verified that the count is local to the JVM."
      }
    ]
  },
  {
    "number": 3775,
    "title": "nginx PROXY redis",
    "created_at": "2021-08-13T10:22:49Z",
    "closed_at": "2021-08-15T07:03:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3775",
    "body": "org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 150.109.250.34/150.109.250.34:6379\r\n        at org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:160)\r\n        at org.redisson.connection.pool.ConnectionPool$1$$Lambda$22/44206143.accept(Unknown Source)\r\n        at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)\r\n        at org.redisson.misc.RedissonPromise$$Lambda$17/1473623671.operationComplete(Unknown Source)\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551)\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)\r\n        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)\r\n        at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)\r\n        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\r\n        at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96)\r\n        at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:330)\r\n        at org.redisson.connection.pool.ConnectionPool.lambda$createConnection$1(ConnectionPool.java:296)\r\n        at org.redisson.connection.pool.ConnectionPool$$Lambda$21/1213290808.accept(Unknown Source)\r\n        at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)\r\n        at org.redisson.misc.RedissonPromise$$Lambda$17/1473623671.operationComplete(Unknown Source)\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570)\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549)\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)\r\n        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)\r\n        at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)\r\n        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\r\n        at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96)\r\n        at org.redisson.client.RedisClient$2$1.run(RedisClient.java:240)\r\n        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.lang.Thread.run(Thread.java:745)\r\nCaused by: org.redisson.client.RedisException: ERR unknown command 'PROXY'. channel: [id: 0x25e8b191, L:/172.29.0.4:39298 - R:150.109.250.34/150.109.250.34:6379] command: (AUTH), params: (password masked)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:355)\r\n        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:196)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498)\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355)\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)\r\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n        ... 4 more\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3775/comments",
    "author": "wl980868110",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-08-13T10:43:34Z",
        "body": "there is no `proxy` command in Redis."
      },
      {
        "user": "wl980868110",
        "created_at": "2021-08-15T07:03:20Z",
        "body": "The problem of our PROXY"
      }
    ]
  },
  {
    "number": 3765,
    "title": "Does near cache options also apply to the backing RMap?",
    "created_at": "2021-08-10T01:11:47Z",
    "closed_at": "2021-08-10T06:50:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3765",
    "body": "I can set max size, eviction algorithm etc. using `LocalCachedMapOptions`, but it's unclear from the documentation if those options also apply to the backing `RMap`. Given that `RLocalCachedMap` does not subclass `RMapCache`, I'm guessing no, but would like to hear from a maintainer.\r\nYou can use this ticket for improving the documentation in this respect.\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3765/comments",
    "author": "asarkar",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-08-10T05:12:50Z",
        "body": "LocalCachedMapOptions applied only to local cache. Also comment to each settings mention local cache only, not RMap object."
      },
      {
        "user": "asarkar",
        "created_at": "2021-08-10T05:14:58Z",
        "body": "@mrniko Is there a way to apply the same settings both locally and on the server?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-08-10T06:29:17Z",
        "body": "Local cache support for MapCache object supported in PRO version only."
      }
    ]
  },
  {
    "number": 3755,
    "title": "Redisson throwing java.io.NotSerializableException when trying to publish something in a topic",
    "created_at": "2021-08-02T21:18:34Z",
    "closed_at": "2021-08-03T06:18:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3755",
    "body": "I'm really confused as to why I got this error, and I might have misunderstood how topics work with objects in Java.\r\n\r\nSo basically when doing `RedissonClient#getTopic(nameOfTheTopic).publish(objectToPublish)`, I'm getting this NotSerializableException.\r\n\r\nThe object I'm trying to send is this class:\r\n```java\r\nimport java.time.LocalDate;\r\n\r\npublic class ClassToPublish {\r\n\r\n    private final String command;\r\n    private final LocalDate date;\r\n\r\n    public ClassToPublish(String command, LocalDate date) {\r\n        this.command = command;\r\n        this.date = date;\r\n    }\r\n\r\n    public String getCommand() {\r\n        return command;\r\n    }\r\n\r\n    public LocalDate getDate() {\r\n        return date;\r\n    }\r\n\r\n}\r\n```\r\n\r\nCan't you send classes other than the ones from the JRE or am I missing something that I need to do in order to be able to do so?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3755/comments",
    "author": "MAXOUXAX",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-08-03T06:18:40Z",
        "body": "default codec is MarshallingCodec. It requires Serializable interface implementation for each object."
      }
    ]
  },
  {
    "number": 3754,
    "title": "Is there any guideline for upgrading the middle value of a version",
    "created_at": "2021-08-02T05:14:11Z",
    "closed_at": "2021-08-05T07:43:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3754",
    "body": "Will it be an incompatible version when I upgrade from 3.11.x to 3.15.x?\r\nIs there any reason or guideline for the version value?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3754/comments",
    "author": "ieiayaobb",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-08-02T08:28:20Z",
        "body": "There is no such guideline. No API breaking changes were made since 3.11.0 version."
      },
      {
        "user": "ieiayaobb",
        "created_at": "2021-08-05T07:43:14Z",
        "body": "I see, thanks.\r\nClose this PR"
      }
    ]
  },
  {
    "number": 3746,
    "title": "not consistent response",
    "created_at": "2021-07-27T08:39:55Z",
    "closed_at": "2021-08-03T06:41:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3746",
    "body": "We have 2 application servers (Tomcats) and our application is not sticky which mean that every request can reach different application server.\r\nIn our flow we upload data from one server to Redis and then read data from the second server but don't get the uploaded data.\r\nCan the reason for this behavior can be related to local cache implementation in Redisson? Can we disable it per put request or only disable it for all Redisson client requests?\r\n\r\nwe use to get the data\r\nRMapCache<String, Object> map = redisson.getMapCache \r\n\r\nand to put data \r\nmap.fastPutAsync(key, value, units, timeUnit);\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3746/comments",
    "author": "wdaas",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-07-27T08:58:22Z",
        "body": "> In our flow we upload data from one server to Redis and then read data from the second server but don't get the uploaded data.\r\n\r\nYou encounter replication lag between Redis servers. You can use RBatch object with `syncSlaves` setting set to sync this process.\r\n\r\nDid you wait for async method to finish before you attempt to read data?"
      },
      {
        "user": "wdaas",
        "created_at": "2021-07-27T09:16:37Z",
        "body": "we use putAsync how we can wait to finish?\r\n\r\nis there some cache at local server that prevents us to get updated data?\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2021-07-27T09:19:47Z",
        "body": "> we use putAsync how we can wait to finish?\r\n\r\nAdding feature complete handler.\r\n\r\n> is there some cache at local server that prevents us to get updated data?\r\n\r\nNo, RMapCache object doesn't store data on Java side. You can check source code."
      }
    ]
  },
  {
    "number": 3737,
    "title": "data consistency",
    "created_at": "2021-07-22T02:24:09Z",
    "closed_at": "2021-07-27T04:56:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3737",
    "body": "分布式锁，以redlock为例\r\n客户端两台：客户端a，客户端b\r\n客户端执行秒杀操作，直接操作redis，\r\n1、首先客户端a，客户端b同时抢锁，\r\n2、最终客户端a获取锁，然后执行业务处理（不需要网络）\r\n3、这时客户端a 网络通信故障，致使客户端b获取到锁了，客户端b正常操作，修改状态数据（redis 数据）\r\n4、之后接着客户端a网络正常了，也直接修改状态数据，（修正状态在lock 之后，但是显然此时客户端a处于无锁状态）\r\n\r\n这样数据一致性不就没有保证了吗？\r\n\r\n1、a.lock\r\n2、业务逻辑\r\n3、修正状态\r\n4、a.unlock\r\n\r\n走的第二步，第三步客户端处于无锁状态的，\r\n一种想法1、后台watchdog 线程，检测到超时后阻塞业务线程 （但是好像没找到阻塞非当前线程的api)\r\n另一种想法2、在unlock 时，假如redis 当前持锁线程非自己时，抛异常（貌似是这么处理的，不过，这样处理的话，那不是正确操作\r\n应当捕获unlock 下的异常，然后对修改状态的操作做补偿了，也好像不太对）。",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3737/comments",
    "author": "TangXianJun1",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-07-23T05:59:16Z",
        "body": "you need to define big enough `leaseTimeout` value during lock acquisition. So Redis state can survive absence of client during this period of time."
      },
      {
        "user": "TangXianJun1",
        "created_at": "2021-07-30T03:20:10Z",
        "body": "define big enough leaseTimeout can solves most situations，optimistic locking can be used in extreme cases.\r\nhave studeied ,This is what happens with distributed locks today\r\nfinally thanks for your comments."
      }
    ]
  },
  {
    "number": 3735,
    "title": "ClassNotFoundException Exception RemoteServiceResponse",
    "created_at": "2021-07-19T15:57:38Z",
    "closed_at": "2021-08-02T09:52:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3735",
    "body": "Hi, \r\nWe are intermediately getting ClassNotFoundException exception while using redisson-spring-data-23:3.16.0. Could someone guide on the issue and its resolution please.\r\n\r\nUsing bare minimum config as below.\r\n            config.useClusterServers()\r\n                    .addNodeAddress(host)\r\n                    .setPassword(password)\r\n                    .setPingConnectionInterval(pingConnectionInterval)\r\n                    .setKeepAlive(keepAlive);\r\n\r\n2021-07-19 15:52:53.763 ERROR 17 --- [sson-netty-2-31] o.r.client.handler.CommandDecoder        : Unable to decode data. channel: [id: 0x810739dd, L:/10.118.165.160:58932 - R:euw-dev-004-develop-redis.redis.cache.windows.net/10.118.221.36:6379], reply: ReplayingDecoderByteBuf(ridx=2003, widx=2003), command: (BLPOP), params: [{remote_response}:c99cdcb5-dc74-4ed0-8a21-b62e5d392436, 0]\r\n\r\njava.io.IOException: java.lang.ClassNotFoundException: org.redisson.remote.RemoteServiceResponse\r\n\tat org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:148) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:358) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:402) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:367) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:177) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507) ~[netty-codec-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[netty-codec-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat java.base/java.lang.Thread.run(Unknown Source) ~[na:na]\r\nCaused by: java.lang.ClassNotFoundException: org.redisson.remote.RemoteServiceResponse\r\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(Unknown Source) ~[na:na]\r\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(Unknown Source) ~[na:na]\r\n\tat java.base/java.lang.ClassLoader.loadClass(Unknown Source) ~[na:na]\r\n\tat java.base/java.lang.Class.forName0(Native Method) ~[na:na]\r\n\tat java.base/java.lang.Class.forName(Unknown Source) ~[na:na]\r\n\tat org.jboss.marshalling.AbstractClassResolver.loadClass(AbstractClassResolver.java:129) ~[jboss-marshalling-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.AbstractClassResolver.resolveClass(AbstractClassResolver.java:110) ~[jboss-marshalling-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadClassDescriptor(RiverUnmarshaller.java:1048) ~[jboss-marshalling-river-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1381) ~[jboss-marshalling-river-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:298) ~[jboss-marshalling-river-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:231) ~[jboss-marshalling-river-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.AbstractObjectInput.readObject(AbstractObjectInput.java:41) ~[jboss-marshalling-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:146) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\t... 25 common frames omitted\r\n\r\n2021-07-19 15:52:53.765 ERROR 17 --- [sson-netty-2-31] org.redisson.remote.AsyncRemoteProxy     : Can't get response from {remote_response}:c99cdcb5-dc74-4ed0-8a21-b62e5d392436\r\n\r\njava.io.IOException: java.lang.ClassNotFoundException: org.redisson.remote.RemoteServiceResponse\r\n\tat org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:148) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:358) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:402) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:367) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:177) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507) ~[netty-codec-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[netty-codec-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat java.base/java.lang.Thread.run(Unknown Source) ~[na:na]\r\nCaused by: java.lang.ClassNotFoundException: org.redisson.remote.RemoteServiceResponse\r\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(Unknown Source) ~[na:na]\r\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(Unknown Source) ~[na:na]\r\n\tat java.base/java.lang.ClassLoader.loadClass(Unknown Source) ~[na:na]\r\n\tat java.base/java.lang.Class.forName0(Native Method) ~[na:na]\r\n\tat java.base/java.lang.Class.forName(Unknown Source) ~[na:na]\r\n\tat org.jboss.marshalling.AbstractClassResolver.loadClass(AbstractClassResolver.java:129) ~[jboss-marshalling-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.AbstractClassResolver.resolveClass(AbstractClassResolver.java:110) ~[jboss-marshalling-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadClassDescriptor(RiverUnmarshaller.java:1048) ~[jboss-marshalling-river-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1381) ~[jboss-marshalling-river-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:298) ~[jboss-marshalling-river-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:231) ~[jboss-marshalling-river-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.AbstractObjectInput.readObject(AbstractObjectInput.java:41) ~[jboss-marshalling-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:146) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\t... 25 common frames omitted\r\n\r\n2021-07-19 15:52:53.767 ERROR 17 --- [sson-netty-2-31] o.r.client.handler.ErrorsLoggingHandler  : Exception occured. Channel: [id: 0x810739dd, L:/10.118.165.160:58932 - R:euw-dev-004-develop-redis.redis.cache.windows.net/10.118.221.36:6379]\r\n\r\nio.netty.handler.codec.DecoderException: java.io.IOException: java.lang.ClassNotFoundException: org.redisson.remote.RemoteServiceResponse\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421) ~[netty-codec-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[netty-codec-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat java.base/java.lang.Thread.run(Unknown Source) ~[na:na]\r\nCaused by: java.io.IOException: java.lang.ClassNotFoundException: org.redisson.remote.RemoteServiceResponse\r\n\tat org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:148) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:358) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:402) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:367) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:177) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507) ~[netty-codec-4.1.65.Final.jar!/:4.1.65.Final]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.65.Final.jar!/:4.1.65.Final]\r\n\t... 17 common frames omitted\r\nCaused by: java.lang.ClassNotFoundException: org.redisson.remote.RemoteServiceResponse\r\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(Unknown Source) ~[na:na]\r\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(Unknown Source) ~[na:na]\r\n\tat java.base/java.lang.ClassLoader.loadClass(Unknown Source) ~[na:na]\r\n\tat java.base/java.lang.Class.forName0(Native Method) ~[na:na]\r\n\tat java.base/java.lang.Class.forName(Unknown Source) ~[na:na]\r\n\tat org.jboss.marshalling.AbstractClassResolver.loadClass(AbstractClassResolver.java:129) ~[jboss-marshalling-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.AbstractClassResolver.resolveClass(AbstractClassResolver.java:110) ~[jboss-marshalling-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadClassDescriptor(RiverUnmarshaller.java:1048) ~[jboss-marshalling-river-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1381) ~[jboss-marshalling-river-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:298) ~[jboss-marshalling-river-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:231) ~[jboss-marshalling-river-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.jboss.marshalling.AbstractObjectInput.readObject(AbstractObjectInput.java:41) ~[jboss-marshalling-2.0.11.Final.jar!/:2.0.11.Final]\r\n\tat org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:146) ~[redisson-3.16.0.jar!/:3.16.0]\r\n\t... 25 common frames omitted\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3735/comments",
    "author": "abhijit911turbo",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-07-22T15:18:43Z",
        "body": "This is a classloader problem."
      }
    ]
  },
  {
    "number": 3727,
    "title": "RMapCache",
    "created_at": "2021-07-12T07:36:47Z",
    "closed_at": "2021-07-27T04:57:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3727",
    "body": "hi,\r\nWe use RMapCache object to save our data, but we can see that the redisson client gets all the map when we need data and not a specific key on the map.\r\n\r\nis there a better way or map to prevent this behaviour and get the key we want instead of all the map and continue having TTL leave map ?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3727/comments",
    "author": "wdaas",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-07-12T07:38:24Z",
        "body": "> but we can see that the redisson client gets all the map when we need data and not a specific key on the map.\r\n\r\nPlease share code to reproduce."
      },
      {
        "user": "wdaas",
        "created_at": "2021-07-12T07:45:37Z",
        "body": "\r\ni think when we get all the map at this.getCacheMap(mapName); and not getting just specific key value at map.get(key);\r\n\r\n try {\r\n            RMapCache<String, Object> map = this.getCacheMap(mapName);\r\n            if(map != null){\r\n                Object returnValue = map.get(key);\r\n                return returnValue;\r\n            }\r\n        }catch (Exception e) {\r\n            String msg = \"failed to retrieve object element from redis cache for  \"+currentDBUrl+mapName+\" with key \"+key;\r\n            logger.error(msg,e);\r\n            TicketingService.createDailyFixedAmountTickets(msg, Category.REDISSON_CACHE_FAILURE,\r\n                    Environment.PRODUCTION, e, null, msg, maxTicketsPerDay);\r\n        }\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2021-07-12T07:48:18Z",
        "body": "You can check the code, it doesn't fetch all the data. It uses HGET command in lua-script."
      }
    ]
  },
  {
    "number": 3725,
    "title": "org.redisson.client.RedisConnectionClosedException: Command (EVAL), params: [if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then redis.call('pexpire', KEYS[1], ARGV[1]); retu..., 1, * * :10, 30000, 961d0a00-de8f-4176-935d-c4b7a71b17e8:911] succesfully sent, but channel [id: 0x96383] has been closed!",
    "created_at": "2021-07-10T06:58:50Z",
    "closed_at": "2021-07-27T04:58:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3725",
    "body": "   项目中引入三个redis相关的依赖，本次新增redisson 3.9.1。\r\n<dependency>\r\n                <groupId>org.redisson</groupId>\r\n                <artifactId>redisson-spring-boot-starter</artifactId>\r\n                <version>3.9.1</version>\r\n     </dependency>\r\n\r\n    <dependency>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-starter-data-redis</artifactId>\r\n                <version>2.3.0.RELEASE</version>\r\n  </dependency>\r\n\r\n     <dependency>\r\n                <groupId>redis.clients</groupId>\r\n                <artifactId>jedis</artifactId>\r\n                <version>2.9.1</version>\r\n       </dependency>\r\n\r\n 没有重写redisson配置，使用默认的spring.redis配置\r\n\r\n现在线上报有\r\norg.redisson.client.RedisConnectionClosedException: Command (EVAL), params: [if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then redis.call('pexpire', KEYS[1], ARGV[1]); retu..., 1, * * :10, 30000, 961d0a00-de8f-4176-935d-c4b7a71b17e8:911] succesfully sent, but channel [id: 0x96383] has been closed! 异常。\r\n\r\n并伴有jedis报错\r\nCannot get Jedis connection; nested exception is redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool\r\n\r\n请问是否因为本次引入redisson 导致 无法正常使用jedis。\r\n\r\n使用代码如下：\r\n        RLock lock = redissonClient.getLock(MessageFormat.format(ConstantRedis.BATCH_JOB_REDIS_KEY, shardingIndex));\r\n        boolean bool = false;\r\n        try {\r\n            bool = lock.tryLock();\r\n            if (bool) {\r\n                List<TScrmBatchJob> batchJobList = tScrmBatchJobMapper.selectBatchTask(shardingIndex\r\n                        , Lists.newArrayList(BatchJobStatusEnum.STATUS.WAIT.getCode(), BatchJobStatusEnum.STATUS.ING.getCode())\r\n                        , maxSize, MAX_RETRY_COUNT);\r\n                if (CollUtil.isEmpty(batchJobList)) {\r\n                    return;\r\n                } ...\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3725/comments",
    "author": "JinmiGas",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-07-12T12:07:53Z",
        "body": "Do you use Redisson or Jedis?"
      }
    ]
  },
  {
    "number": 3724,
    "title": "Ask a lock reentry problem, sub method using thread pool call",
    "created_at": "2021-07-10T01:54:54Z",
    "closed_at": "2021-07-12T12:08:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3724",
    "body": "If the thread ID is used as the key value for reentry, is there any problem if the thread pool is used for calling the sub method? Can the key value be specified externally? And if the thread number will be repeated",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3724/comments",
    "author": "shazidongdong",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-07-12T12:08:25Z",
        "body": "no, since counter is used in this case."
      }
    ]
  },
  {
    "number": 3719,
    "title": "org.redisson.client.WriteRedisConnectionException: Unable to write command into connection! Node source: NodeSource",
    "created_at": "2021-07-09T04:47:02Z",
    "closed_at": "2021-07-10T03:32:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3719",
    "body": "1、my redisson version is: 3.12.3\r\n\r\n2、my code like this:\r\nRBlockingQueue queue = redissonClient.getBlockingQueue(\"queue_name\");\r\nXXVo = queue.take();\r\n\r\n\r\n3、my problem is:\r\norg.redisson.client.WriteRedisConnectionException: Unable to write command into connection! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeS\r\nubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:9:queue:0, freeConnectionsAmount=10, freeConnectionsCounter=value:13:queue:0, freezed=false, freezeReason=null, client=[addr=redis://x.x.x.x\r\n:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@94976719 [redisClient=[addr=redis://x.x.x.x:6379], channel=[id: 0xd7d1fa38, L:0.0.0.0/0.0.0.0:33596], currentCommand=null], command: (BLPO\r\nP), params: [xx_key, 0] after 3 retry attempts\r\n\r\n4、additional: \r\nthe queue may have 100 element, 99 take success, but 1 take occurred error above.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3719/comments",
    "author": "githubylw",
    "comments": [
      {
        "user": "coolbtoc",
        "created_at": "2022-05-24T09:32:10Z",
        "body": "how to resolution it? thx"
      }
    ]
  },
  {
    "number": 3717,
    "title": "Kotlin objects with JsonJacksonCodec ",
    "created_at": "2021-07-06T22:39:29Z",
    "closed_at": "2021-09-06T10:46:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3717",
    "body": "Hi!!\r\n\r\nI'm using Redis as a cache provider with the help of Redisson in a kotlin service.\r\n\r\nAt first I tried to set in redis non Serializable objects and I had to change to a JsonJacksonCodec in order to encode non Serializable objects. However some code at initTypeInclusion from JsonJacksonCode.java is avoiding our jackson to write @class property for kotlin classes (they are closed by default).\r\n\r\nI have created a custom Codec in kotlin extending JsonJacksonCodec:\r\n\r\n```\r\npackage com.bumble.utils.redis.redisson\r\n\r\nimport com.fasterxml.jackson.databind.ObjectMapper\r\nimport com.fasterxml.jackson.databind.jsontype.BasicPolymorphicTypeValidator\r\nimport org.redisson.codec.JsonJacksonCodec\r\n\r\nclass JsonJacksonKotlinCodec(objectMapper: ObjectMapper) : JsonJacksonCodec(objectMapper) {\r\n\r\n    override fun initTypeInclusion(mapObjectMapper: ObjectMapper) {\r\n        mapObjectMapper.activateDefaultTyping(BasicPolymorphicTypeValidator.builder()\r\n            .allowIfBaseType(Any::class.java)\r\n            .build(), ObjectMapper.DefaultTyping.EVERYTHING)\r\n    }\r\n}\r\n```\r\n\r\nAnd I start redisson with:\r\n\r\n```\r\n                val codec = JsonJacksonKotlinCodec(ObjectMapper())\r\n                codec.objectMapper.registerKotlinModule()\r\n                config.codec = codec\r\n                config.useSingleServer().address = redisConfig.host\r\n```\r\n\r\nAnd everything works! Now I can serialize and deserialize kotlin classes into Json and keep them in redis.\r\n\r\nHowever I'm wondering, as we are passing class type to getBucket:\r\n\r\n`redisProvider.getClient()?.getBucket<V>(cacheKeyToString(namespace, key))?.get()?.awaitSingleOrNull()`\r\n\r\n**Can't we just use that information to indicate Jackson which class should be used to deserialize???**\r\n\r\n**Also, did you find OK my JsonJacksonKotlinCodec?**\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3717/comments",
    "author": "elfogre",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-07-27T05:02:38Z",
        "body": "> Also, did you find OK my JsonJacksonKotlinCodec?\r\n\r\nYes.\r\n\r\n> Can't we just use that information to indicate Jackson which class should be used to deserialize???\r\n\r\nUnfortunately no, you can look at similar implementation of TypedJsonJacksonCodec. Which allows to specify types in constructor."
      }
    ]
  },
  {
    "number": 3713,
    "title": "Unsupported protocol version 50",
    "created_at": "2021-07-06T03:59:26Z",
    "closed_at": "2021-07-06T09:42:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3713",
    "body": "Retrieve data error，Beg big guy to help see\r\n\r\n Caused by: java.io.IOException: Unsupported protocol version 50\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.start(RiverUnmarshaller.java:1375) ~[jboss-marshalling-river-2.0.11.Final.jar:2.0.11.Final]\r\n\tat org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:145) ~[redisson-3.16.0.jar:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:358) ~[redisson-3.16.0.jar:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:177) ~[redisson-3.16.0.jar:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116) ~[redisson-3.16.0.jar:3.16.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101) ~[redisson-3.16.0.jar:3.16.0]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:508) ~[netty-codec-4.1.60.Final.jar:4.1.60.Final]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.60.Final.jar:4.1.60.Final]\r\n\t... 17 common frames omitted\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3713/comments",
    "author": "shiguota",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-07-06T09:42:21Z",
        "body": "update your JDK to 1.8+"
      }
    ]
  },
  {
    "number": 3701,
    "title": "Transaction support for other DS",
    "created_at": "2021-06-30T04:17:25Z",
    "closed_at": "2021-06-30T20:23:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3701",
    "body": "Currently in transaction mode, we have options for updating only limited data structure.\r\nFor ex: List is not supported.\r\n\r\nIs there any reason for this?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3701/comments",
    "author": "kitkars",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-06-30T07:16:23Z",
        "body": "Complexity of implementation."
      },
      {
        "user": "kitkars",
        "created_at": "2021-06-30T20:23:21Z",
        "body": "Understood. Lua script could be an alternative."
      }
    ]
  },
  {
    "number": 3691,
    "title": "Error message from Redis: ERR invalid command channel: [id: 0x33948139, L:/10.0.3.228:40080 - R:/172.16.1.9:6379]",
    "created_at": "2021-06-28T12:42:11Z",
    "closed_at": "2021-06-30T08:26:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3691",
    "body": "i user redisson version is 3.13.2\r\n\r\nError message from Redis: ERR invalid command channel: [id: 0x33948139, L:/10.0.3.228:40080 - R:/172.16.1.9:6379]\r\n\r\nWhat does this mean, please?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3691/comments",
    "author": "dnfhujun",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-06-29T05:06:45Z",
        "body": "it means some commands aren't supported by your Redis version."
      }
    ]
  },
  {
    "number": 3689,
    "title": "redisson crashing ",
    "created_at": "2021-06-26T18:45:15Z",
    "closed_at": "2021-07-27T13:54:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3689",
    "body": "org.redisson.client.RedisException: java.lang.InterruptedException: ImmediateEventExecutor$ImmediatePromise@2e24330d(incomplete)\r\norg.redisson.client.RedisException: java.lang.InterruptedException: ImmediateEventExecutor$ImmediatePromise@2e24330d(incomplete)\r\n        at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:115)\r\n        at org.redisson.RedissonObject.get(RedissonObject.java:82)\r\n        at org.redisson.RedissonList.add(RedissonList.java:115)\r\n  \r\nCaused by: java.lang.InterruptedException: ImmediateEventExecutor$ImmediatePromise@2e24330d(incomplete)\r\n        at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)\r\n        at org.redisson.misc.RedissonPromise.await(RedissonPromise.java:110)\r\n        at org.redisson.misc.RedissonPromise.await(RedissonPromise.java:35)\r\n        at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:112)\r\n        ... 13 more\r\n^C\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3689/comments",
    "author": "mom1705",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-06-29T05:07:08Z",
        "body": "How to reproduce it?"
      }
    ]
  },
  {
    "number": 3684,
    "title": "Connecting to AWS Elasticache cluster using cluster endpoint",
    "created_at": "2021-06-25T15:02:17Z",
    "closed_at": "2021-06-25T18:05:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3684",
    "body": "Hello,\r\nAWS EC exposes 2 ways of connecting to multi-node cluster.\r\nIt gives us a cluster-endpoint AND it also gives us endpoints for each node.\r\nNow, in redisson I see that there's a cluster connection config which requires each of the node endpoint address alongwith replicase i think.\r\nAnd then there's singleServerConfig.\r\n\r\nI was wondering what's the best way to handle this? If I use single server config with cluster endpoint, will it be okay?\r\n\r\nOr I always need to use cluster connection config with all node endpoints registered.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3684/comments",
    "author": "mayurgoenka",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-06-25T15:17:29Z",
        "body": "you can use endpoint with AWS EC"
      },
      {
        "user": "mayurgoenka",
        "created_at": "2021-06-25T18:05:31Z",
        "body": "thanks @mrniko for confirmation."
      }
    ]
  },
  {
    "number": 3679,
    "title": "关于分布式调度有个疑问需要咨询一下",
    "created_at": "2021-06-24T12:43:59Z",
    "closed_at": "2021-07-05T07:30:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3679",
    "body": "我在测试过程中创建分布式调度任务，但是发现我每次重新运行，都会创建一个新的Task，我看taskId是根据ThreadLocal生成的，导致后续work会执行两个task的任务，这个是我哪里理解不对，或者使用方法不对吗？\r\n代码如下：\r\n```\r\n    @Test\r\n    void test_schedule() {\r\n        WorkerOptions workerOptions = WorkerOptions.defaults().workers(1);\r\n        ExecutorOptions executorOptions = ExecutorOptions.defaults();\r\n        RScheduledExecutorService executorService = redissonClient\r\n                .getExecutorService(\"test\", executorOptions);\r\n        executorService.registerWorkers(workerOptions);\r\n\r\n        executorService.scheduleAtFixedRate((Runnable & Serializable) () -> System.out.println(\"11111111\"),\r\n                                            10, 1, TimeUnit.SECONDS);\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3679/comments",
    "author": "ziminghua",
    "comments": [
      {
        "user": "stanstanwang",
        "created_at": "2021-06-25T04:14:41Z",
        "body": "是理解不对， redisson 可以用于做轻量的任务， 都是运行动态创建的\r\n\r\n你可以启动一次之后， 把这段注释掉 executorService.scheduleAtFixedRate 来模拟动态创建情况\r\n\r\n或者你每次跑之前 unregister 一下旧的任务\r\n"
      },
      {
        "user": "ziminghua",
        "created_at": "2021-06-25T08:04:55Z",
        "body": "这样做相当于 调度服务要和调度worker分开吗？\r\n如果我调度服务做集群了，是不是每个服务节点启动都会生成一个执行任务呢？"
      },
      {
        "user": "stanstanwang",
        "created_at": "2021-06-27T01:32:19Z",
        "body": "分不分开没关系， 主要是注册任务的时候 redisson 不会帮你去重， 每次注册任务都是当成全新的任务去跑的\r\n\r\n注册任务之后会响应 taskId， 可以在服务启动注册任务之前用这个 cancel 掉\r\n\r\n集群的话是随机分配一个实例去跑的， 有点像发送一个mq， 集群内随机一个实例去消费一样， 也不会有任务并发执行的情况"
      }
    ]
  },
  {
    "number": 3677,
    "title": "class not found exception with redisson tomcat code",
    "created_at": "2021-06-23T14:48:03Z",
    "closed_at": "2021-08-23T08:56:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3677",
    "body": "we got following exception with Redisson tomcat decode \r\nversion 3.14.0\r\ncodec: org.redisson.codec.SnappyCodec\r\n\r\njava.lang.ClassNotFoundException: org.springframework.security.web.savedrequest.DefaultSavedRequest\r\n        at org.redisson.codec.MarshallingCodec$3.decode(MarshallingCodec.java:153) ~[redisson-all-3.14.0.jar:3.14.0]\r\n        at org.redisson.codec.SnappyCodec$3.decode(SnappyCodec.java:84) ~[redisson-all-3.14.0.jar:3.14.0]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:356) [redisson-all-3.14.0.jar:3.14.0]\r\n        at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:400) [redisson-all-3.14.0.jar:3.14.0]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:365) [redisson-all-3.14.0.jar:3.14.0]\r\n        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:178) [redisson-all-3.14.0.jar:3.14.0]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) [redisson-all-3.14.0.jar:3.14.0]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [redisson-all-3.14.0.jar:3.14.0]\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [redisson-all-3.14.0.jar:3.14.0]\r\n        at java.lang.Thread.run(Thread.java:748) [na:1.8.0_261]\r\nCaused by: java.lang.ClassNotFoundException: org.springframework.security.web.savedrequest.DefaultSavedRequest\r\n        at java.net.URLClassLoader.findClass(URLClassLoader.java:382) ~[na:1.8.0_261]\r\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:418) ~[na:1.8.0_261]\r\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:351) ~[na:1.8.0_261]\r\n        at java.lang.Class.forName0(Native Method) ~[na:1.8.0_261]\r\n        at java.lang.Class.forName(Class.java:348) ~[na:1.8.0_261]\r\n        at org.jboss.marshalling.AbstractClassResolver.loadClass(AbstractClassResolver.java:129) ~[redisson-all-3.14.0.jar:3.14.0]\r\n        at org.jboss.marshalling.AbstractClassResolver.resolveClass(AbstractClassResolver.java:110) ~[redisson-all-3.14.0.jar:3.14.0]\r\n        at org.jboss.marshalling.river.RiverUnmarshaller.doReadClassDescriptor(RiverUnmarshaller.java:1033) ~[redisson-all-3.14.0.jar:3.14.0]\r\n        at org.jboss.marshalling.river.RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1366) ~[redisson-all-3.14.0.jar:3.14.0]\r\n        at org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:283) ~[redisson-all-3.14.0.jar:3.14.0]\r\n        at org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:216) ~[redisson-all-3.14.0.jar:3.14.0]\r\n        at org.jboss.marshalling.AbstractObjectInput.readObject(AbstractObjectInput.java:41) ~[redisson-all-3.14.0.jar:3.14.0]\r\n        at org.redisson.codec.MarshallingCodec$3.decode(MarshallingCodec.java:151) ~[redisson-all-3.14.0.jar:3.14.0]\r\n        ... 26 common frames omitted\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3677/comments",
    "author": "wdaas",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-06-23T15:58:25Z",
        "body": "try to set `useThreadClassLoader = false`"
      },
      {
        "user": "wdaas",
        "created_at": "2021-08-23T08:37:18Z",
        "body": "hi\r\nafter we change this configuration we still have the same exception ."
      }
    ]
  },
  {
    "number": 3675,
    "title": "'Not all slots covered!' on startup in AWS Elasticache",
    "created_at": "2021-06-21T10:39:59Z",
    "closed_at": "2021-06-28T08:31:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3675",
    "body": "We run a Redis cluster in AWS ElastiCache. On a service startup we sometimes get the following exception (used dots instead of potential NDA data):\r\n```\r\nApplication run failed\r\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name '...' defined in class path resource [...]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redissonClient' threw exception; nested exception is org.redisson.client.RedisConnectionException: Not all slots covered! Only 7647 slots are available. Set checkSlotsCoverage = false to avoid this check.\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:627) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:456) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1321) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$1(AbstractBeanFactory.java:356) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.cloud.context.scope.GenericScope$BeanLifecycleWrapper.getBean(GenericScope.java:390) ~[spring-cloud-context-2.1.0.RELEASE.jar:2.1.0.RELEASE]\r\n\tat org.springframework.cloud.context.scope.GenericScope.get(GenericScope.java:184) ~[spring-cloud-context-2.1.0.RELEASE.jar:2.1.0.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:353) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1105) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.cloud.context.scope.refresh.RefreshScope.eagerlyInitialize(RefreshScope.java:130) ~[spring-cloud-context-2.1.0.RELEASE.jar:2.1.0.RELEASE]\r\n\tat org.springframework.cloud.context.scope.refresh.RefreshScope.start(RefreshScope.java:121) ~[spring-cloud-context-2.1.0.RELEASE.jar:2.1.0.RELEASE]\r\n\tat org.springframework.cloud.context.scope.refresh.RefreshScope.onApplicationEvent(RefreshScope.java:115) ~[spring-cloud-context-2.1.0.RELEASE.jar:2.1.0.RELEASE]\r\n\tat org.springframework.cloud.context.scope.refresh.RefreshScope.onApplicationEvent(RefreshScope.java:71) ~[spring-cloud-context-2.1.0.RELEASE.jar:2.1.0.RELEASE]\r\n\tat org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:402) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:359) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:896) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.finishRefresh(ServletWebServerApplicationContext.java:162) ~[spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE]\r\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:552) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141) ~[spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:743) [spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:390) [spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:312) [spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1214) [spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1203) [spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE]\r\nCaused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redissonClient' threw exception; nested exception is org.redisson.client.RedisConnectionException: Not all slots covered! Only 7647 slots are available. Set checkSlotsCoverage = false to avoid this check.\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:622) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\t... 30 more\r\nCaused by: org.redisson.client.RedisConnectionException: Not all slots covered! Only 7647 slots are available. Set checkSlotsCoverage = false to avoid this check.\r\n\tat org.redisson.cluster.ClusterConnectionManager.<init>(ClusterConnectionManager.java:157) ~[redisson-3.13.5.jar:3.13.5]\r\n\tat org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:206) ~[redisson-3.13.5.jar:3.13.5]\r\n\tat org.redisson.Redisson.<init>(Redisson.java:64) ~[redisson-3.13.5.jar:3.13.5]\r\n\tat org.redisson.Redisson.create(Redisson.java:104) ~[redisson-3.13.5.jar:3.13.5]\r\n\tat ...RedissonConfiguration.redissonClient(RedissonConfiguration.java:62) ~[...]\r\n\tat org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:363) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat ...RedissonConfiguration$$EnhancerBySpringCGLIB$$72fc472b.redissonClient(<generated>) ~[...]\r\n\tat jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:?]\r\n\tat jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:?]\r\n\tat jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:?]\r\n\tat java.lang.reflect.Method.invoke(Method.java:566) ~[?:?]\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:622) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]\r\n\t... 30 more\r\nCaused by: org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 9 of 32 were initialized. Redis server: <url>.cache.amazonaws.com/<ip>:6379\r\n\tat org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:159) ~[redisson-3.13.5.jar:3.13.5]\r\n\tat org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183) ~[redisson-3.13.5.jar:3.13.5]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:500) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:474) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:413) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:538) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:531) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:111) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96) ~[redisson-3.13.5.jar:3.13.5]\r\n\tat org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:329) ~[redisson-3.13.5.jar:3.13.5]\r\n\tat org.redisson.connection.pool.ConnectionPool.lambda$createConnection$1(ConnectionPool.java:295) ~[redisson-3.13.5.jar:3.13.5]\r\n\tat org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183) ~[redisson-3.13.5.jar:3.13.5]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:500) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:493) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:472) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:413) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:538) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:531) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:111) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96) ~[redisson-3.13.5.jar:3.13.5]\r\n\tat org.redisson.client.RedisClient$2$1.run(RedisClient.java:239) ~[redisson-3.13.5.jar:3.13.5]\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:416) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:515) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat java.lang.Thread.run(Thread.java:829) ~[?:?]\r\nCaused by: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=rediss://<url>.cache.amazonaws.com:6379]\r\n\tat org.redisson.client.RedisConnection.lambda$async$1(RedisConnection.java:207) ~[redisson-3.13.5.jar:3.13.5]\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]\r\n\tat java.lang.Thread.run(Thread.java:829) ~[?:?]\r\n```\r\n\r\nPods restart several times and eventually they succeed to connect.\r\n\r\nRedis version: 6.0.5\r\nRedisson version: `3.13.5`\r\nRedisson config:\r\n```\r\n{\"clusterServersConfig\": {\"idleConnectionTimeout\":10000,\"connectTimeout\":10000,\"timeout\":3000,\"retryAttempts\":3,\"retryInterval\":1500,\"subscriptionsPerConnection\":5,\"sslEnableEndpointIdentification\":true,\"sslProvider\":\"JDK\",\"pingConnectionInterval\":3000,\"keepAlive\":true,\"tcpNoDelay\":true,\"loadBalancer\":{\"class\":\"org.redisson.connection.balancer.RoundRobinLoadBalancer\"},\"slaveConnectionMinimumIdleSize\":0,\"slaveConnectionPoolSize\":0,\"failedSlaveReconnectionInterval\":3000,\"failedSlaveCheckInterval\":180000,\"masterConnectionMinimumIdleSize\":32,\"masterConnectionPoolSize\":64,\"readMode\":\"MASTER\",\"subscriptionMode\":\"MASTER\",\"subscriptionConnectionMinimumIdleSize\":1,\"subscriptionConnectionPoolSize\":50,\"dnsMonitoringInterval\":5000,\"natMapper\":{\"class\":\"org.redisson.api.DefaultNatMapper\"},\"nodeAddresses\":[\"redis://...\"],\"scanInterval\":5000,\"checkSlotsCoverage\":true},\"threads\":16,\"nettyThreads\":32,\"codec\":{\"class\":\"...\"},\"referenceEnabled\":true,\"transportMode\":\"NIO\",\"lockWatchdogTimeout\":30000,\"keepPubSubOrder\":true,\"decodeInExecutor\":false,\"useScriptCache\":true,\"minCleanUpDelay\":5,\"maxCleanUpDelay\":1800,\"cleanUpKeysAmount\":100,\"nettyHook\":{\"class\":\"org.redisson.client.DefaultNettyHook\"},\"useThreadClassLoader\":true,\"addressResolverGroupFactory\":{\"class\":\"org.redisson.connection.DnsAddressResolverGroupFactory\"}}\r\n```\r\n\r\nAs far as I understood, redisson sends a ping on `AbstractNIOChannel.finishConnect` if `pingConnectionInterval > 0`, and this ping fails.\r\n\r\nIs it possible to fix this issue without disabling slot coverage check? If not, is it safe enough to disable that check?\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3675/comments",
    "author": "DanilaVaratyntsev",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-06-21T12:24:19Z",
        "body": "> Unable to init enough connections amount! Only 9 of 32 were initialized\r\n\r\nTry to reduce connection pool size. "
      }
    ]
  },
  {
    "number": 3670,
    "title": "Reactive Client - Key does not expire",
    "created_at": "2021-06-19T16:43:45Z",
    "closed_at": "2021-06-21T09:08:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3670",
    "body": "Why does expire method not work for reactive client?\r\n\r\n        RedissonReactiveClient rclient = ....;\r\n        RBucketReactive<String> bucket = rclient.getBucket(\"demo\");\r\n        bucket.set(\"hello world\").subscribe();\r\n        bucket.expire(5, TimeUnit.SECONDS).subscribe();\r\n        rclient.shutdown();\r\n\r\nI can still see the keys and values after 10 seconds. Looks like the client should not be shutdown to expire the keys? Can we not set the expire key as part of the expire method invocation itself?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3670/comments",
    "author": "kitkars",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-06-21T09:08:01Z",
        "body": "you need to make a request on subscribe."
      }
    ]
  },
  {
    "number": 3669,
    "title": "Can't set expiration time for bloomFilter key?",
    "created_at": "2021-06-19T16:29:58Z",
    "closed_at": "2021-09-06T10:47:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3669",
    "body": "Can't set expiration time for bloomFilter key?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3669/comments",
    "author": "w350727743",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-09-06T10:47:22Z",
        "body": "Below is the code example:\r\n\r\n```java\r\n        RBloomFilter<String> filter = redisson.getBloomFilter(\"filter\");\r\n        filter.tryInit(55000000L, 0.03);\r\n\r\n        filter.add(\"test\");\r\n        filter.expire(Instant.now().plusSeconds(2));\r\n```"
      }
    ]
  },
  {
    "number": 3659,
    "title": "ClassCastException occurs ",
    "created_at": "2021-06-15T09:31:12Z",
    "closed_at": "2021-06-29T07:22:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3659",
    "body": "I'm seeing these errors in logs, this for `Instant` and others for Enums as well\r\n\r\nMy value serializer is `StringSerializer` and the codec is not defined explicitly so it would be picking by default.\r\n\r\nWhat would be the issue? Do I need to change to JDK serializer or Jackson one?\r\n\r\n```\r\n2021-06-14 15:00:19,622 ERROR org.redisson.client.handler.CommandDecoder [redisson-netty-5-21] Unable to decode data. channel: [id: 0xa39136eb, L:/10.11.4.187:52704 - R:redis/172.20.33.10:6379], reply: ReplayingDecoderByteBuf(ridx=712, widx=712), command: (HGET), params: [new-vendor-date, PooledUnsafeDirectByteBuf(ridx: 0, widx: 469, cap: 512)]\r\njava.lang.ClassCastException: Cannot cast java.lang.String to java.time.Instant\r\n    at java.base/java.lang.Class.cast(Unknown Source)\r\n    at org.jboss.marshalling.reflect.SerializableField.setObject(SerializableField.java:342)\r\n    at org.jboss.marshalling.river.RiverUnmarshaller.readFields(RiverUnmarshaller.java:1864)\r\n    at org.jboss.marshalling.river.RiverUnmarshaller.doInitSerializable(RiverUnmarshaller.java:1778)\r\n    at org.jboss.marshalling.river.RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1406)\r\n    at org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:283)\r\n    at org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:231)\r\n    at org.jboss.marshalling.river.RiverUnmarshaller.doReadCollectionObject(RiverUnmarshaller.java:187)\r\n    at org.jboss.marshalling.river.RiverUnmarshaller.readCollectionData(RiverUnmarshaller.java:861)\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3659/comments",
    "author": "ahsanbagwan",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-06-16T08:36:52Z",
        "body": "Can you provide code example? Which StringSerializer do you use?"
      },
      {
        "user": "ahsanbagwan",
        "created_at": "2021-06-16T10:48:54Z",
        "body": "StringRedisSerializer\r\n\r\n```\r\n@Bean\r\npublic RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redissonConnectionFactory) {\r\n    RedisTemplate<String, Object> template = new RedisTemplate<>();\r\n    template.setConnectionFactory(redissonConnectionFactory);\r\n    template.setKeySerializer(new StringRedisSerializer());\r\n    template.setValueSerializer(new StringRedisSerializer());\r\n    return template;\r\n}\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2021-06-16T14:38:25Z",
        "body": "default codec isn't compatible with StringRedisSerializer. Try to use StringCodec instead"
      }
    ]
  },
  {
    "number": 3654,
    "title": "Is order of Operations in a RBatch guaranteed?",
    "created_at": "2021-06-11T06:09:58Z",
    "closed_at": "2021-06-14T07:58:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3654",
    "body": "Sorry if this is obvious, but i did not find any documentstion about this:\r\n\r\nIf i am using **RBatch** and create let's say a Bucket from it, and call setAsync on the bucket 100 times before executing the batch, is the order of the operations in the batch guaranteed to be the order in which\r\n```\r\nsetAsync(Object)\r\n```\r\nhas been called?\r\n\r\nIn other words, is there any way i could end up with anything but the last value i set to the bucket after the RBatch is executed? For instance if the Marshalling of the 99th value took some time?\r\n\r\nBucket is just an example here, i am also using RMaps the same way.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3654/comments",
    "author": "uweschaefer",
    "comments": [
      {
        "user": "uweschaefer",
        "created_at": "2021-06-27T18:51:10Z",
        "body": "Thanks for answering, @mrniko \r\n\r\nis there an example somewhere? i fail to understand how RLock helps me in this case.\r\nOr did you refer to RedissonFairLock ?\r\n\r\nthx\r\n\r\nPS: One important thing i realized i failed to mention:\r\n\r\nall setAsync(Object) calls **come from the same Thread**.\r\njust like `stringList.stream().forEach(myStringBucket::setAsync);`"
      },
      {
        "user": "mrniko",
        "created_at": "2021-06-29T07:46:43Z",
        "body": "In batch list of operations is always ordered. But RBatch object isn't thread-safe."
      },
      {
        "user": "uweschaefer",
        "created_at": "2021-06-29T09:15:21Z",
        "body": "Thanks, this is very good news."
      }
    ]
  },
  {
    "number": 3636,
    "title": "Redis Lock - question about edge case",
    "created_at": "2021-06-03T17:48:02Z",
    "closed_at": "2021-08-06T09:40:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3636",
    "body": "I am looking to use Redis for exclusive locks of resources.\r\nIf they fail and two workers will _think_ they are holding the lock, that can end up in, let's say, really bad data corruption.\r\nI know that a lot of edge cases in Redisson have been covered, however how about this one:\r\n\r\n1. Worker1 acquires lock with time of \"infinity\" (until manual release)\r\n2. Worker1 loses connection to _Redis instance_, while access to everything else still works and it continues operation on data, databases etc....\r\n3. Lock gets removed from the database, because it expired in 30s (lock watchdog timeout), because of no bump by watchdog\r\n4. Worker2 has good connection to Redis and is able to acquire the lock and start it's operation on data (leading to corruption)\r\n5. Worker1 gets Redis connection back, it's watchdog tries to recreate the lock in background ASAP, however it lost the race because the lock was already acquired by Worker2\r\n6. Both Worker1 and Worker2 now think they are holding the lock :(\r\n\r\nLooking by the code comments, this seems to be expected behavior/known edge case - one of very few in regards to locks.\r\nIf I am correct with this scenario, what would you recommend? Going with non-redis solution like etcd or zookeeper, for example?\r\n_or_ maybe set the watchdog timeout to a value that will always be **more than** the execution time of task under that lock _and_ have some custom code for removing failed locks on boot?\r\n(so if Worker1 is down I either wait for it come back and automatically clean it's locks that are no longer valid **or** manually remove the locks owned by Worker1 assuming I want to safely get rid of it)\r\n\r\nAnd is there a mechanism to check periodically whether watchdog has lost the race to _reacquire_ the lock and allow application to act on it?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3636/comments",
    "author": "ninja-",
    "comments": [
      {
        "user": "Cesarla",
        "created_at": "2021-07-14T16:42:37Z",
        "body": "Hi @ninja-, in one of the projects I work we implemented our own watchdog that periodically checks if the lock `isHeldByCurrentThread()` to avoid scenarios like the one you mentioned."
      },
      {
        "user": "ninja-",
        "created_at": "2021-07-14T16:44:16Z",
        "body": "if that method is actually quering the database instead of checking local state, that might be useful for a solution. thanks :+1: "
      },
      {
        "user": "Cesarla",
        "created_at": "2021-07-14T16:46:16Z",
        "body": "It does a lookup against redis:\r\n```\r\n    @Override\r\n    public boolean isHeldByThread(long threadId) {\r\n        RFuture<Boolean> future = commandExecutor.writeAsync(getName(), LongCodec.INSTANCE, RedisCommands.HEXISTS, getName(), getLockName(threadId));\r\n        return get(future);\r\n    }\r\n\r\n```"
      }
    ]
  },
  {
    "number": 3632,
    "title": "Exception in redisson decode",
    "created_at": "2021-06-02T13:28:53Z",
    "closed_at": "2021-06-14T08:06:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3632",
    "body": "Hi,\r\n\r\nis following exception is also related to netty version or there is other problem , by the way this is only happening  when I use it in RTopic pubsub MessageListener.OnMessage() :)\r\n\r\n**Redisson version**\r\n3.15.3\r\n\r\nCaused by: java.io.IOException: java.lang.ClassNotFoundException: com.sibisoft.northstar.pms.VoiceMailExtRequestDTO\r\n        at org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:65)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:358)\r\n        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:177)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501)\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n        ... 2 more\r\nCaused by: java.lang.ClassNotFoundException: com.sibisoft.northstar.pms.VoiceMailExtRequestDTO\r\n        at java.net.URLClassLoader.findClass(URLClassLoader.java:381)\r\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)\r\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)\r\n        at java.lang.Class.forName0(Native Method)\r\n        at java.lang.Class.forName(Class.java:348)\r\n        at java.io.ObjectInputStream.resolveClass(ObjectInputStream.java:686)\r\n        at org.redisson.codec.CustomObjectInputStream.resolveClass(CustomObjectInputStream.java:46)\r\n        at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1868)\r\n        at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751)\r\n        at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042)\r\n        at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)\r\n        at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431)\r\n        at java.util.ArrayList.readObject(ArrayList.java:797)\r\n        at sun.reflect.GeneratedMethodAccessor182.invoke(Unknown Source)\r\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n        at java.lang.reflect.Method.invoke(Method.java:498)\r\n        at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1170)\r\n        at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2178)\r\n        at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2069)\r\n        at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)\r\n        at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2287)\r\n        at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2211)\r\n        at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2069)\r\n        at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)\r\n        at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431)\r\n        at org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:58)\r\n        ... 23 more\r\nERROR 2021-06-02 18:24:58,477 - NorthstarMap.get:176 - redisson client exception: Unexpected exception while processing command\r\norg.redisson.client.RedisException: Unexpected exception while processing command\r\n        at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:324)\r\n        at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:121)\r\n        at org.redisson.RedissonObject.get(RedissonObject.java:81)\r\n        at org.redisson.RedissonMap.get(RedissonMap.java:639)\r\n        at com.sibisoft.northstar.util.NorthstarMap.get(NorthstarMap.java:174)\r\n        at com.sibisoft.northstar.pms.interfaces.voicemail.homisco.HomiscoMessageListener.onMessage(HomiscoMessageListener.java:31)\r\n        at com.sibisoft.northstar.pms.interfaces.voicemail.homisco.HomiscoMessageListener.onMessage(HomiscoMessageListener.java:16)\r\n        at org.redisson.PubSubMessageListener.onMessage(PubSubMessageListener.java:79)\r\n        at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:78)\r\n        at org.redisson.client.handler.CommandPubSubDecoder$1.run(CommandPubSubDecoder.java:149)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.io.IOException: java.lang.ClassNotFoundException: com.sibisoft.northstar.pms.VoiceMailExtRequestDTO\r\n        at org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:65)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:358)\r\n        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:177)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501)\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n        ... 2 more\r\nCaused by: java.lang.ClassNotFoundException: com.sibisoft.northstar.pms.VoiceMailExtRequestDTO\r\n        at java.net.URLClassLoader.findClass(URLClassLoader.java:381)\r\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)\r\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)\r\n        at java.lang.Class.forName0(Native Method)\r\n        at java.lang.Class.forName(Class.java:348)\r\n        at java.io.ObjectInputStream.resolveClass(ObjectInputStream.java:686)\r\n        at org.redisson.codec.CustomObjectInputStream.resolveClass(CustomObjectInputStream.java:46)\r\n        at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1868)\r\n        at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751)\r\n        at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042)\r\n        at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)\r\n        at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431)\r\n        at java.util.ArrayList.readObject(ArrayList.java:797)\r\n        at sun.reflect.GeneratedMethodAccessor182.invoke(Unknown Source)\r\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n        at java.lang.reflect.Method.invoke(Method.java:498)\r\n        at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1170)\r\n        at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2178)\r\n        at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2069)\r\n        at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)\r\n        at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2287)\r\n        at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2211)\r\n        at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2069)\r\n        at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)\r\n        at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431)\r\n        at org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:58)\r\n        ... 23 more",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3632/comments",
    "author": "meherwer-ali",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-06-03T08:42:31Z",
        "body": "It's classloader problem. Try to set useThreadClassLoader = false"
      }
    ]
  },
  {
    "number": 3626,
    "title": "Will RLOS indexed based querying work in cluster enabled Redis?",
    "created_at": "2021-05-28T05:46:43Z",
    "closed_at": "2021-05-28T05:49:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3626",
    "body": "When we use cluster enabled Redis like AWS EC, it's possible that objects gets stored on different shards. Will the indexed based querying still work here?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3626/comments",
    "author": "mayurgoenka",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-05-28T05:49:13Z",
        "body": "Sharded index supported only in PRO version."
      },
      {
        "user": "mayurgoenka",
        "created_at": "2021-05-28T05:51:10Z",
        "body": "I really appreciate the quick turnaround. You are doing a great job @mrniko. Thanks a lot!"
      },
      {
        "user": "mrniko",
        "created_at": "2021-05-28T06:02:53Z",
        "body": "@mayurgoenka \r\n\r\nThank you!"
      },
      {
        "user": "mayurgoenka",
        "created_at": "2021-06-02T13:15:33Z",
        "body": "Hi @mrniko , \r\nI see that the index is created in the following fashion:\r\n`\"redisson_live_object_index:{com.org.application.MyLiveObject}:index_field:<some_hash>\"`\r\n\r\nI see that we are using hash tag : `{com.org.application.MyLiveObject}` for storing all indices belonging to same class inside same keyslot.\r\n\r\nIn my use case, m trying to store billions of objects of the same class MyLiveObject and there are multiple indices as well. It's obvious that this won't fit in the same keyslot and will need sharding.\r\n\r\nYour comment, \"Sharded index supported only in PRO version.\", does this mean that the index itself will also get sharded across nodes and above use case will still work in PRO version? Same hashtag `{com.org.application.MyLiveObject}` won't be used in PRO version for indices?\r\n\r\nSorry for the repeated query, but just want to make sure before I finalise my design.\r\n\r\nHope my query is clear."
      },
      {
        "user": "mrniko",
        "created_at": "2021-06-02T13:30:41Z",
        "body": "Hi @mayurgoenka, \r\n\r\n> does this mean that the index itself will also get sharded across nodes and above use case will still work in PRO version\r\n\r\nIn this case name will be different to distribute evenly across all Redis master nodes.\r\n\r\n> Same hashtag {com.org.application.MyLiveObject} won't be used in PRO version for indices?\r\n\r\nThis name still will be present in key, but without braces.\r\n"
      },
      {
        "user": "mayurgoenka",
        "created_at": "2021-06-02T13:42:13Z",
        "body": "Thank you @mrniko , this means that I can safely use RLOS for huge data in redis clustered mode.\r\n\r\n\r\nAnother query is, are there any plans for supporting batch operations and transactions with RLOS objects? "
      },
      {
        "user": "mrniko",
        "created_at": "2021-06-02T14:03:16Z",
        "body": "What kind of batch / transaction operations over RLOS do you need? Could you describe some use cases?"
      },
      {
        "user": "mayurgoenka",
        "created_at": "2021-06-02T14:45:49Z",
        "body": "Suppose I want to merge 1000s of Live objects into redis cache, like a batch update OR batch insert. I see that we do have rlos.persist(list) but I not sure if its using pipelining inside or not? Also, rlos.merge(list) is what I was primarily looking for. \r\nThese operations are mainly required for warming up the cache in my use case.\r\n\r\n\r\nTransactions could be required when I want to update 2 different Live objects together or not do them at all. Live objects here can be of same class or different classes.\r\nI need this in my use case because there's a parent-child type of relationship in my application, where if I delete the parent object, child object also needs to get deleted."
      },
      {
        "user": "mrniko",
        "created_at": "2021-06-08T10:27:07Z",
        "body": "`org.redisson.api.RLiveObjectService#persist(T...)` method stores object in a batch. `merge()` method for multiple object isn't implemented yet.\r\n\r\nAs for transactions, I can recommend you to use RLock object."
      },
      {
        "user": "mayurgoenka",
        "created_at": "2021-06-09T05:58:26Z",
        "body": "yes, thank you for the response @mrniko , appreciate it."
      }
    ]
  },
  {
    "number": 3615,
    "title": "AWS ElasticCache Redis(Cluster Mode Disabled) Cannot Find Redis Node After Failover",
    "created_at": "2021-05-15T02:05:29Z",
    "closed_at": "2021-05-15T10:21:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3615",
    "body": "We are using Redission to connect AWS ElasticCache Redis(Cluster Mode Disabled), but we found exception below, even we upgraded to the version 3.15.1. And we don't see these exception unit we restart our service. \r\n\r\nException:\r\n\r\norg.redisson.client.RedisNodeNotFoundException: Node: NodeSource [slot=null, addr=null, redisClient=[addr=redis://xxx.cache.amazonaws.com:6379], redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:999:queue:0, freeConnectionsAmount=24, freeConnectionsCounter=value:10000:queue:0, freezed=false, freezeReason=null, client=[addr=redis://xxx.cache.amazonaws.com:6379], nodeType=MASTER, firstFail=0]]] hasn't been discovered yet. Increase value of retryAttempts and/or retryInterval settings.\r\nat org.redisson.connection.MasterSlaveConnectionManager.createNodeNotFoundFuture(MasterSlaveConnectionManager.java:647)\r\nat org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:629)\r\nat org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:643)\r\nat org.redisson.command.RedisExecutor.execute(RedisExecutor.java:115)\r\nat org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:243)\r\nat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672)\r\nat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747)\r\nat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472)\r\nat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\nat java.lang.Thread.run(Thread.java:748)\r\n\r\nVersion:\r\n\r\nRedission: 3.15.1\r\nAWS ElasticCache Redis(Cluster Mode Disabled): 5.0.6\r\n\r\nConfig:\r\n\r\nConfig config = new Config();\r\nconfig.useSingleServer().setAddress(\"redis://\" + host + \":\" + port)\r\n                .setConnectTimeout(30000)\r\n                .setSubscriptionsPerConnection(5000)\r\n                .setSubscriptionConnectionPoolSize(1000)\r\n                .setConnectionPoolSize(10000)\r\n                .setPingConnectionInterval(1000)\r\n                .setRetryInterval(3000);\r\n\r\nDo I need to change the config to useReplicatedServer() or useSingleServer() also can support AWS ElasticCache Redis(Cluster Mode Disabled)\r\n\r\nThanks a lot!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3615/comments",
    "author": "DarrenChenGo",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-05-15T10:20:26Z",
        "body": "You need to use useReplicatedServer() for non-clustered AWS ElasticCache Redis setup. `useSingleServer()` doesn't handle failover"
      },
      {
        "user": "DarrenChenGo",
        "created_at": "2021-05-16T10:16:33Z",
        "body": "Hi @mrniko \r\nI just replace the useSingleServer() with useReplicatedServer(), but now there is another exception is \"too many open files\" when do the concurrent test, below is my redission config, please take a look, thank you!\r\n\r\nConfig config = new Config();\r\n        if (\"localhost\".equalsIgnoreCase(host)) {\r\n            config.useSingleServer().setAddress(\"redis://\" + host + \":\" + port)\r\n                    .setConnectTimeout(30000)\r\n                    .setSubscriptionsPerConnection(5000)\r\n                    .setSubscriptionConnectionPoolSize(1000)\r\n                    .setPingConnectionInterval(1000)\r\n                    .setRetryInterval(3000);\r\n        } else {\r\n            List<String> hosts = new ArrayList<>();\r\n            if (StringUtils.isNotBlank(nodes)) {\r\n                hosts.addAll(Arrays.asList(nodes.split(\",\")));\r\n            } else {\r\n                hosts.add(host);\r\n            }\r\n            ReplicatedServersConfig serverConfig = config.useReplicatedServers();\r\n            hosts.forEach(h  -> serverConfig.addNodeAddress(\"redis://\" + h + \":\" + port));\r\n            serverConfig.setConnectTimeout(5000)\r\n                    .setSubscriptionsPerConnection(5000)\r\n                    .setSubscriptionConnectionPoolSize(1000)\r\n                    .setPingConnectionInterval(1000)\r\n                    .setRetryInterval(3000)\r\n                    .setMasterConnectionPoolSize(5000)\r\n                    .setSlaveConnectionPoolSize(5000)\r\n                    .setTimeout(5000);\r\n        }\r\n        config.setEventLoopGroup(new NioEventLoopGroup());\r\n        return Redisson.create(config);"
      },
      {
        "user": "mrniko",
        "created_at": "2021-05-26T05:16:14Z",
        "body": "I think you need to decrease connections amount"
      },
      {
        "user": "winfet",
        "created_at": "2022-01-12T07:11:08Z",
        "body": "We got the same exception with redisson 3.13.3. Every time after failover we got an RedisNodeNotFoundException.\r\nBut the exception only happens when we call RKey.deletebyPattern.  \r\nAfter update to 3.16.7 the problem not happen again. \r\nCan someone tell me which commit solved this problem?\r\n\r\nWe tried ReplicatedServersConfig on 3.13.3 but not take effect. SingleServerConig with 3.16.7 is ok.\r\n"
      }
    ]
  },
  {
    "number": 3606,
    "title": "How to isolate MapListener to a single database",
    "created_at": "2021-05-11T22:38:07Z",
    "closed_at": "2021-05-12T16:21:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3606",
    "body": "I have some code which adds a listener\r\n\r\n`\t\t\t\t\trmapCache.addListener(new EntryCreatedListener<String, Object>() {\r\n\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\tpublic void onCreated(EntryEvent<String, Object> event) {\r\n\t\t\t\t\t\t\tpublishRedisEvent(new RedisEvent(cacheKey, event));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n`\r\n\r\nwhich works great, apart from the fact that I'm getting notifications on events in databases i'm not using.  I.e., i'm using database 0, but I get events from database 1.  \r\n\r\nHow can I isolate events to the database that i'm using.\r\n\r\nthanks, Mitchell",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3606/comments",
    "author": "mcacker",
    "comments": [
      {
        "user": "mcacker",
        "created_at": "2021-05-11T23:48:13Z",
        "body": "To answer my own question, I've prefixed the key names with the database number.  It's less than ideal, but seems to work fine.\r\n\r\nIt would be nice if we could inject a channel name for the events so that wouldn't have to be done.\r\n\r\nI'd still like to hear of any alternatives"
      },
      {
        "user": "mrniko",
        "created_at": "2021-05-12T09:52:46Z",
        "body": ">  I've prefixed the key names with the database number\r\n\r\nI can use `nameMapper` setting for this."
      }
    ]
  },
  {
    "number": 3601,
    "title": "RTopic -ERR only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context",
    "created_at": "2021-05-10T03:09:25Z",
    "closed_at": "2021-05-10T06:15:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3601",
    "body": "Did I use Rtopic incorrectly?\r\nCode:\r\n```\r\n void pubEvent(){\r\n  RTopic topic = redissonClient.getTopic(\"test-topic\")\r\n  topic.publish(new Event(\"hello world\"))\r\n}\r\n\r\n void subEvent(){\r\n   RTopic topic = redissonClient.getTopic(\"test-topic\")\r\n   topic.addListener(new MessageListener<Event>(){\r\n            @Override\r\n            public void onMessage(CharSequence channel, Event event) {\r\n                log.debug(\"channel:{},Event :{}\", channel, event);\r\n            }\r\n  })\r\n}\r\n\r\n public static void main(String[] args){\r\n             Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(this::pubEvent, 1000, 10000, TimeUnit.MILLISECONDS);\r\n             subEvent();\r\n             Thread.sleep(1000000);\r\n }\r\n```\r\n\r\nConfig:\r\n```\r\nspring:\r\n  redis:\r\n    redisson:\r\n      config: |\r\n        singleServerConfig:\r\n          address: \"redis://localhost:6379\"\r\n          connectTimeout: 30000\r\n          pingConnectionInterval: 10000\r\n        codec: !<org.redisson.codec.JsonJacksonCodec> {}\r\n```\r\n\r\nError:\r\n```\r\n2021-05-10 10:56:48.237 ERROR 10184 --- [isson-timer-4-1] o.r.c.handler.PingConnectionHandler      : Unable to send PING command over channel: [id: 0x6657975f, L:/2.0.1.49:54140 - R:/172.19.13.25:6379]\r\norg.redisson.client.RedisException: ERR only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context. channel: [id: 0x6657975f, L:/2.0.1.49:54140 - R:/172.19.13.25:6379] command: (PING), params: []\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:343) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.client.handler.CommandPubSubDecoder.decodeCommand(CommandPubSubDecoder.java:83) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501) ~[netty-codec-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[netty-codec-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.51.Final.jar:4.1.51.Final]\r\n\tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_262]\r\n````",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3601/comments",
    "author": "facelezzzz",
    "comments": [
      {
        "user": "facelezzzz",
        "created_at": "2021-05-10T03:24:18Z",
        "body": "maybe redis version problem"
      },
      {
        "user": "mrniko",
        "created_at": "2021-05-10T06:07:23Z",
        "body": "yes, usage is correct. which Redis vendor do you use?"
      },
      {
        "user": "facelezzzz",
        "created_at": "2021-05-10T06:15:22Z",
        "body": "The redis of our qa environment is version 2.8, and there is no problem after upgrading to 4.0\r\nthx"
      }
    ]
  },
  {
    "number": 3595,
    "title": "Connection pooling mechanism in redisson",
    "created_at": "2021-05-06T08:40:39Z",
    "closed_at": "2021-05-11T05:07:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3595",
    "body": "HI Team,\r\nI had a doubt regarding redisson connection pooling management.\r\n\r\nI have an application with a high volume of traffic and hence get a lot of concurrent requests.\r\nHave optimised my connection pool accordingly.But i have the following query\r\n\r\nWhat if a new request arrives and all the connections are busy in case of unprecedented volume.\r\n\r\nHow does redisson handle such scenarios.Is there a connection request time out , post which it tries to create a new connection if pool is exhausted OR the request is rejected in absence of a connection in the pool .\r\n\r\nregards,\r\nAC",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3595/comments",
    "author": "ankitgooner",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-05-07T05:16:27Z",
        "body": "> Is there a connection request time out , post which it tries to create a new connection if pool is exhausted OR the request is rejected in absence of a connection in the pool .\r\n\r\nRedisson makes a new attempts to execute command according to `retryInterval` and `retryAttempts` settings."
      }
    ]
  },
  {
    "number": 3593,
    "title": "When using distributed locks, why not use the JVM locks first to reduce the pressure of redis?",
    "created_at": "2021-05-05T08:34:16Z",
    "closed_at": "2021-05-16T14:24:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3593",
    "body": "When using distributed locks, why not use the JVM locks first to reduce the pressure of redis?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3593/comments",
    "author": "tanzheng231",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-05-11T05:09:10Z",
        "body": "can you provide more information about what you are trying to accomplish?"
      },
      {
        "user": "michael-o",
        "created_at": "2021-05-16T13:04:37Z",
        "body": "> \r\n> \r\n> When using distributed locks, why not use the JVM locks first to reduce the pressure of redis?\r\n\r\nThat sounds like non-sense, doesn't it?"
      }
    ]
  },
  {
    "number": 3585,
    "title": "ConnectionListener configuration",
    "created_at": "2021-04-28T14:35:28Z",
    "closed_at": "2021-04-29T17:27:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3585",
    "body": "Good morning:\r\n\r\nI hope you are doing well. \r\nI would like to know which is the process or thread that is used by the ConnectionListener so that the RedissonClient reconnects to the Redis Server. \r\n\r\nI mean we can get onConnect and onDisconnect events, but I would like to know how Redisson implements reconnection mechanisms so that the listener can trigger the onConnect event. \r\nCould that mechanisms (process/thread) be configured by using the YAML config? Or have a behavioral properties set by default for all the implementations that use it?\r\n\r\nI appreciate your attention and collaboration with the related details about this topic. ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3585/comments",
    "author": "willy23martin",
    "comments": [
      {
        "user": "willy23martin",
        "created_at": "2021-04-28T22:18:16Z",
        "body": "Do you know how RedissonClient re-establishes the connection pool after an outage? After an onDisconnect event received, for example?\r\n\r\nI appreciate your help."
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-29T08:59:14Z",
        "body": "> Could that mechanisms (process/thread) be configured by using the YAML config? Or have a behavioral properties set by default for all the implementations that use it?\r\n\r\nWhy do you need this?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-29T09:00:13Z",
        "body": "Redisson re-establish connections to Redis nodes, once they were discovered by topology manager"
      },
      {
        "user": "willy23martin",
        "created_at": "2021-04-29T14:29:21Z",
        "body": "Thank you @mrniko  for your explanations about the re-establish process . I have been trying to understand how to set properly the YAML config file (or the Config object) so that I can improve resiliancy in the connection to the Redis Cluster.\r\n\r\nThank you so much. I really appreciate that.\r\n"
      }
    ]
  },
  {
    "number": 3580,
    "title": "Async lock thread affinity",
    "created_at": "2021-04-27T07:42:51Z",
    "closed_at": "2021-05-12T08:01:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3580",
    "body": "Hi,\r\n\r\nI'm working on a kotlin micronaut web app which is attempting to be fully async and we're using redisson for distributed locks.\r\n\r\nI'm somewhat unclear on how to exactly use it correctly.\r\n\r\nThe official documentation says `RLock object behaves according to the Java Lock specification. It means only lock owner thread can unlock it otherwise IllegalMonitorStateException would be thrown. Otherwise consider to use RSemaphore object.` which sounds weird as in an async context, executing on a specific threads is never guaranteed.\r\n\r\nThe code I'm using for now, in a kotlin suspendable func, is like this:\r\n``` kotlin\r\nval lock = rediClinet.getLock(\"lock_name)\r\ntry {\r\n    (lock.lockAsync(50, TimeUnit.SECONDS) as CompletionStage<Void>).await()\r\n    //fancy kotlin async code here.\r\n}\r\nfinally {\r\n    (lock.unlockAsync() as CompletionStage<Void>).await()\r\n}\r\n```\r\n\r\nThe unlock line is not guaranteed to execute on the same thread as the lockAsync line.\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3580/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-05-11T05:12:28Z",
        "body": "Hi,\r\n\r\nuse `unlockAsync(threadId)` method instead."
      },
      {
        "user": "ghost",
        "created_at": "2021-05-12T07:41:42Z",
        "body": "But what do use as `threadId` ?\r\nAny numbers as long as I use the same number across acquire/release methods?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-05-12T07:58:15Z",
        "body": "you need to pass the same id to `lockAsync()` and `unlockAsync()` methods. It might be any id."
      },
      {
        "user": "ghost",
        "created_at": "2021-05-12T08:01:55Z",
        "body": "ok, thanks.\r\n\r\nmust say this is a very unexpected design for an distributed lock."
      }
    ]
  },
  {
    "number": 3574,
    "title": "Redisson Java Client-RedisCluster-YAML config-RedisNodeNotFoundException",
    "created_at": "2021-04-24T11:15:31Z",
    "closed_at": "2021-05-11T05:13:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3574",
    "body": "Good morning:\r\n\r\nI have been working in the implementation of a Redisson client to connect a Java application to Redis cluster defined by a YAML config file (loaded from the Config class) and by using RBucket as a class to put and get key-value pairs.\r\n\r\nThe connection is primary established by calling Redisson.create(config) method. Sometimes, even if a master is up after an outage, a RedisNodeNotFoundException exception happen saying that we need to increase the value of retryAttempts and/or retryInterval settings.\r\n\r\nI really appreciate if you can give me some advices, recommendations about some configuration fields I could have missed, or something about the uses of RBucket or Redisson.create method in order to make it more resilient and to solve that issue.\r\n\r\nThank you so much in advance.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3574/comments",
    "author": "willy23martin",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-04-26T05:57:05Z",
        "body": "Can you share full stack trace?"
      },
      {
        "user": "willy23martin",
        "created_at": "2021-04-26T13:49:17Z",
        "body": "Yes.\r\nThe message was the following:\r\n\r\n\"org.redisson.client.RedisNodeFoundException: Node for slot: 13871 hasn't been discovered yet. Check cluster slots coverage using CLUSTER NODES command. Increade value of retryAttempts and/or retryInterval settings.\"\r\n\r\nDo you have any suggestions about the way I manage the Redisson connection. Should I modify something or take into account some strategy you recommend for resilient and HA environments?\r\n\r\nThank you so much for your help."
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-27T05:57:24Z",
        "body": "Do you invoke `Redisson.create(config)` right after Redis cluster start?"
      },
      {
        "user": "willy23martin",
        "created_at": "2021-04-27T13:18:22Z",
        "body": "Yes @mrniko I invoked that after cluster started. But sometimes RedissonClient loose connection. \r\nI found yesterday the use of the interface ConnectionListener with both onConnect and onDisconnect that should be set before Redisson.create(config), as I understood you said in other GitHub issue. That has been working for me because I can monitor the connection. But once is reestablished how do you consider it would be managed? I would run all the process from the beginning (loading the config) OR just continue with the current connection. Has the connection a timeout in which it needs to be recreated again? Those are the criteria or suggestions I am looking for in order to make the implementation more resilient. \r\n\r\nI appreciate your suggestions. :)"
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-30T05:56:27Z",
        "body": "try to set `checkSlotsCoverage` = false.\r\n\r\n>  But once is reestablished how do you consider it would be managed? I would run all the process from the beginning (loading the config) OR just continue with the current connection\r\n\r\nRedisson reconnects automatically broken channels."
      }
    ]
  },
  {
    "number": 3572,
    "title": "The best way to create Redisson client",
    "created_at": "2021-04-23T15:59:22Z",
    "closed_at": "2021-05-11T05:14:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3572",
    "body": "Hey guys! We're using Redisson in our app and instantiating it as a Singleton. But faced some weird behavior when the Redis cluster was rebooted. We're calling the method `RMap.getAll(Set<K> keys)` and this time got incorrect data from Redis. Seems like some of the Redisson workers returned the requested data and other ones not. \r\nNow we're trying to create the Redisson client for each request to avoid the mentioned issue. Is it a good idea or will be better to create it one time along with the application?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3572/comments",
    "author": "dpavluchenko",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-04-23T16:12:57Z",
        "body": "Creating Redisson client per request is a bad practice. \r\n\r\n> But faced some weird behavior when the Redis cluster was rebooted. We're calling the method getAll(Set<K> keys) and this time got incorrect data from Redis.\r\n\r\nCan you provide more details? what does incorrect data mean?"
      },
      {
        "user": "dpavluchenko",
        "created_at": "2021-04-23T16:31:17Z",
        "body": "Can you provide more details? what does incorrect data mean?\r\n>  We've received only some part of expected from this method values. For this reason, we got bad results in our application's logic. I can’t imagine how it's happened. Everything worked properly(with Singleton client) till Redis was rebooted. Now we're trying to find the reason for this issue.\r\n"
      },
      {
        "user": "dpavluchenko",
        "created_at": "2021-04-26T07:15:28Z",
        "body": "@mrniko Also, one more question:\r\nDo you know how to prevent/avoid issues when the Redis cluster is rebooting or modifying to another type(we are using AWS ElasticCache Redis)? Maybe for this case exists some configuration.\r\nSeems like the Redisson client(created along with the app as Singleton) keeps some connections to the \"old\" cluster that already died and doesn’t want to reconnect to the new one. Is it possible or I'm wrong?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-26T07:18:01Z",
        "body": "Redisson refreshes topology after Redis cluster restart and reconnects to new discovered nodes. If it's not for your case then can you share Redisson logs with `debug` logging level?"
      },
      {
        "user": "dpavluchenko",
        "created_at": "2021-04-26T07:23:32Z",
        "body": "How to enable debug log level? Cause we are using redisson in the AWS lambda function."
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-26T07:24:39Z",
        "body": "you need to set it in your logging implementation like Logback, log4j..."
      },
      {
        "user": "dpavluchenko",
        "created_at": "2021-04-26T12:21:57Z",
        "body": "@mrniko We've successfully reproduced the mentioned issue(when Redis was rebooted we got \"bad\" results in our logic) \r\nHere is an exception stack trace we are seeing each time when got incorrect results. Could you please take a look?\r\n\r\n`2021-04-26 11:49:02.393,Apr 26, 2021 11:49:02 AM io.netty.util.concurrent.DefaultPromise notifyListener0\r\n2021-04-26 11:49:02.393,WARNING: An exception was thrown by org.redisson.misc.RedissonPromise$$Lambda$550/0x000000084046f040.operationComplete()\r\n2021-04-26 11:49:02.393,java.lang.NoClassDefFoundError: io/netty/bootstrap/FailedChannel\r\n2021-04-26 11:49:02.393,at io.netty.bootstrap.AbstractBootstrap.initAndRegister(AbstractBootstrap.java:320)\r\n2021-04-26 11:49:02.393,at io.netty.bootstrap.Bootstrap.doResolveAndConnect(Bootstrap.java:155)\r\n2021-04-26 11:49:02.393,at io.netty.bootstrap.Bootstrap.connect(Bootstrap.java:139)\r\n2021-04-26 11:49:02.393,at org.redisson.client.RedisClient.lambda$connectAsync$0(RedisClient.java:220)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)\r\n2021-04-26 11:49:02.393,at org.redisson.client.RedisClient.connectAsync(RedisClient.java:214)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.ClientConnectionsEntry.connect(ClientConnectionsEntry.java:177)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.pool.ConnectionPool.connect(ConnectionPool.java:270)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.pool.ConnectionPool.createConnection(ConnectionPool.java:292)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.pool.ConnectionPool.access$000(ConnectionPool.java:52)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.pool.ConnectionPool$1.run(ConnectionPool.java:120)\r\n2021-04-26 11:49:02.393,at org.redisson.pubsub.AsyncSemaphore.tryRun(AsyncSemaphore.java:86)\r\n2021-04-26 11:49:02.393,at org.redisson.pubsub.AsyncSemaphore.acquire(AsyncSemaphore.java:66)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.ClientConnectionsEntry.acquireConnection(ClientConnectionsEntry.java:147)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.pool.ConnectionPool.acquireConnection(ConnectionPool.java:181)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.pool.ConnectionPool.createConnection(ConnectionPool.java:115)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.pool.ConnectionPool.initConnections(ConnectionPool.java:99)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.pool.ConnectionPool.initConnections(ConnectionPool.java:83)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.pool.SlaveConnectionPool.initConnections(SlaveConnectionPool.java:30)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.balancer.LoadBalancerManager.unfreeze(LoadBalancerManager.java:157)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.balancer.LoadBalancerManager.unfreeze(LoadBalancerManager.java:122)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.MasterSlaveEntry.slaveUp(MasterSlaveEntry.java:382)\r\n2021-04-26 11:49:02.393,at org.redisson.cluster.ClusterConnectionManager.lambda$addRemoveSlaves$11(ClusterConnectionManager.java:535)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.TransferListener.accept(TransferListener.java:42)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.TransferListener.accept(TransferListener.java:26)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.CountableListener.decCounter(CountableListener.java:54)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.CountableListener.accept(CountableListener.java:71)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.CountableListener.accept(CountableListener.java:26)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:166)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.pool.ConnectionPool.connectedSuccessful(ConnectionPool.java:313)\r\n2021-04-26 11:49:02.393,at org.redisson.connection.pool.ConnectionPool.lambda$createConnection$1(ConnectionPool.java:304)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.393,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.393,at org.redisson.client.RedisClient$2$1.run(RedisClient.java:237)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)\r\n2021-04-26 11:49:02.393,at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n2021-04-26 11:49:02.393,at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n2021-04-26 11:49:02.393,at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n2021-04-26 11:49:02.393,at java.base/java.lang.Thread.run(Unknown Source)\r\n2021-04-26 11:49:02.393,Caused by: java.lang.ClassNotFoundException: io.netty.bootstrap.FailedChannel. Current classpath: file:/var/task/\r\n2021-04-26 11:49:02.393,at lambdainternal.CustomerClassLoader.findClass(CustomerClassLoader.java:63)\r\n2021-04-26 11:49:02.393,at java.base/java.lang.ClassLoader.loadClass(Unknown Source)\r\n2021-04-26 11:49:02.393,at java.base/java.lang.ClassLoader.loadClass(Unknown Source)\r\n2021-04-26 11:49:02.393,... 87 more\r\n2021-04-26 11:49:02.393,Caused by: java.io.FileNotFoundException: /var/task/io/netty/bootstrap/FailedChannel.class (Too many open files)\r\n2021-04-26 11:49:02.393,at java.base/java.io.FileInputStream.open0(Native Method)\r\n2021-04-26 11:49:02.393,at java.base/java.io.FileInputStream.open(Unknown Source)\r\n2021-04-26 11:49:02.393,at java.base/java.io.FileInputStream.<init>(Unknown Source)\r\n2021-04-26 11:49:02.393,at java.base/jdk.internal.loader.URLClassPath$FileLoader$1.getInputStream(Unknown Source)\r\n2021-04-26 11:49:02.393,at java.base/jdk.internal.loader.Resource.cachedInputStream(Unknown Source)\r\n2021-04-26 11:49:02.393,at java.base/jdk.internal.loader.Resource.getByteBuffer(Unknown Source)\r\n2021-04-26 11:49:02.393,at java.base/java.net.URLClassLoader.defineClass(Unknown Source)\r\n2021-04-26 11:49:02.393,at java.base/java.net.URLClassLoader$1.run(Unknown Source)\r\n2021-04-26 11:49:02.393,at java.base/java.net.URLClassLoader$1.run(Unknown Source)\r\n2021-04-26 11:49:02.393,at java.base/java.security.AccessController.doPrivileged(Native Method)\r\n2021-04-26 11:49:02.393,at java.base/java.net.URLClassLoader.findClass(Unknown Source)\r\n2021-04-26 11:49:02.393,at lambdainternal.CustomerClassLoader.findClass(CustomerClassLoader.java:60)\r\n2021-04-26 11:49:02.393,... 89 more\r\n2021-04-26 11:49:02.395,Apr 26, 2021 11:49:02 AM io.netty.util.concurrent.DefaultPromise notifyListener0\r\n2021-04-26 11:49:02.395,WARNING: An exception was thrown by org.redisson.misc.RedissonPromise$$Lambda$550/0x000000084046f040.operationComplete()\r\n2021-04-26 11:49:02.395,java.lang.NoClassDefFoundError: io/netty/bootstrap/FailedChannel\r\n2021-04-26 11:49:02.395,at io.netty.bootstrap.AbstractBootstrap.initAndRegister(AbstractBootstrap.java:320)\r\n2021-04-26 11:49:02.395,at io.netty.bootstrap.Bootstrap.doResolveAndConnect(Bootstrap.java:155)\r\n2021-04-26 11:49:02.395,at io.netty.bootstrap.Bootstrap.connect(Bootstrap.java:139)\r\n2021-04-26 11:49:02.395,at org.redisson.client.RedisClient.lambda$connectAsync$0(RedisClient.java:220)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)\r\n2021-04-26 11:49:02.395,at org.redisson.client.RedisClient.connectAsync(RedisClient.java:214)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.ClientConnectionsEntry.connect(ClientConnectionsEntry.java:177)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.pool.ConnectionPool.connect(ConnectionPool.java:270)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.pool.ConnectionPool.createConnection(ConnectionPool.java:292)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.pool.ConnectionPool.access$000(ConnectionPool.java:52)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.pool.ConnectionPool$1.run(ConnectionPool.java:120)\r\n2021-04-26 11:49:02.395,at org.redisson.pubsub.AsyncSemaphore.tryRun(AsyncSemaphore.java:86)\r\n2021-04-26 11:49:02.395,at org.redisson.pubsub.AsyncSemaphore.acquire(AsyncSemaphore.java:66)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.ClientConnectionsEntry.acquireConnection(ClientConnectionsEntry.java:147)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.pool.ConnectionPool.acquireConnection(ConnectionPool.java:181)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.pool.ConnectionPool.createConnection(ConnectionPool.java:115)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.pool.ConnectionPool.initConnections(ConnectionPool.java:99)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.pool.ConnectionPool.initConnections(ConnectionPool.java:83)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.pool.SlaveConnectionPool.initConnections(SlaveConnectionPool.java:30)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.balancer.LoadBalancerManager.unfreeze(LoadBalancerManager.java:157)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.balancer.LoadBalancerManager.unfreeze(LoadBalancerManager.java:122)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.MasterSlaveEntry.slaveUp(MasterSlaveEntry.java:382)\r\n2021-04-26 11:49:02.395,at org.redisson.cluster.ClusterConnectionManager.lambda$addRemoveSlaves$11(ClusterConnectionManager.java:535)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.TransferListener.accept(TransferListener.java:42)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.TransferListener.accept(TransferListener.java:26)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.CountableListener.decCounter(CountableListener.java:54)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.CountableListener.accept(CountableListener.java:71)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.CountableListener.accept(CountableListener.java:26)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:166)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.pool.ConnectionPool.connectedSuccessful(ConnectionPool.java:313)\r\n2021-04-26 11:49:02.395,at org.redisson.connection.pool.ConnectionPool.lambda$createConnection$1(ConnectionPool.java:304)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.395,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.395,at org.redisson.client.RedisClient$2$1.run(RedisClient.java:237)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)\r\n2021-04-26 11:49:02.395,at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n2021-04-26 11:49:02.395,at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n2021-04-26 11:49:02.395,at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n2021-04-26 11:49:02.395,at java.base/java.lang.Thread.run(Unknown Source)\r\n2021-04-26 11:49:02.396,Apr 26, 2021 11:49:02 AM io.netty.util.concurrent.DefaultPromise notifyListener0\r\n2021-04-26 11:49:02.396,WARNING: An exception was thrown by org.redisson.misc.RedissonPromise$$Lambda$550/0x000000084046f040.operationComplete()\r\n2021-04-26 11:49:02.396,java.lang.NoClassDefFoundError: io/netty/bootstrap/FailedChannel\r\n2021-04-26 11:49:02.396,at io.netty.bootstrap.AbstractBootstrap.initAndRegister(AbstractBootstrap.java:320)\r\n2021-04-26 11:49:02.396,at io.netty.bootstrap.Bootstrap.doResolveAndConnect(Bootstrap.java:155)\r\n2021-04-26 11:49:02.396,at io.netty.bootstrap.Bootstrap.connect(Bootstrap.java:139)\r\n2021-04-26 11:49:02.396,at org.redisson.client.RedisClient.lambda$connectAsync$0(RedisClient.java:220)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)\r\n2021-04-26 11:49:02.396,at org.redisson.client.RedisClient.connectAsync(RedisClient.java:214)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.ClientConnectionsEntry.connect(ClientConnectionsEntry.java:177)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.pool.ConnectionPool.connect(ConnectionPool.java:270)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.pool.ConnectionPool.createConnection(ConnectionPool.java:292)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.pool.ConnectionPool.access$000(ConnectionPool.java:52)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.pool.ConnectionPool$1.run(ConnectionPool.java:120)\r\n2021-04-26 11:49:02.396,at org.redisson.pubsub.AsyncSemaphore.tryRun(AsyncSemaphore.java:86)\r\n2021-04-26 11:49:02.396,at org.redisson.pubsub.AsyncSemaphore.acquire(AsyncSemaphore.java:66)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.ClientConnectionsEntry.acquireConnection(ClientConnectionsEntry.java:147)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.pool.ConnectionPool.acquireConnection(ConnectionPool.java:181)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.pool.ConnectionPool.createConnection(ConnectionPool.java:115)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.pool.ConnectionPool.initConnections(ConnectionPool.java:99)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.pool.ConnectionPool.initConnections(ConnectionPool.java:83)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.pool.SlaveConnectionPool.initConnections(SlaveConnectionPool.java:30)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.balancer.LoadBalancerManager.unfreeze(LoadBalancerManager.java:157)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.balancer.LoadBalancerManager.unfreeze(LoadBalancerManager.java:122)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.MasterSlaveEntry.slaveUp(MasterSlaveEntry.java:382)\r\n2021-04-26 11:49:02.396,at org.redisson.cluster.ClusterConnectionManager.lambda$addRemoveSlaves$11(ClusterConnectionManager.java:535)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.TransferListener.accept(TransferListener.java:42)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.TransferListener.accept(TransferListener.java:26)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.CountableListener.decCounter(CountableListener.java:54)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.CountableListener.accept(CountableListener.java:71)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.CountableListener.accept(CountableListener.java:26)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:166)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.pool.ConnectionPool.connectedSuccessful(ConnectionPool.java:313)\r\n2021-04-26 11:49:02.396,at org.redisson.connection.pool.ConnectionPool.lambda$createConnection$1(ConnectionPool.java:304)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.396,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.396,at org.redisson.client.RedisClient$2$1.run(RedisClient.java:237)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)\r\n2021-04-26 11:49:02.396,at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n2021-04-26 11:49:02.396,at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n2021-04-26 11:49:02.396,at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n2021-04-26 11:49:02.396,at java.base/java.lang.Thread.run(Unknown Source)\r\n2021-04-26 11:49:02.398,Apr 26, 2021 11:49:02 AM io.netty.util.concurrent.DefaultPromise notifyListener0\r\n2021-04-26 11:49:02.398,WARNING: An exception was thrown by org.redisson.misc.RedissonPromise$$Lambda$550/0x000000084046f040.operationComplete()\r\n2021-04-26 11:49:02.398,java.lang.NoClassDefFoundError: io/netty/bootstrap/FailedChannel\r\n2021-04-26 11:49:02.398,at io.netty.bootstrap.AbstractBootstrap.initAndRegister(AbstractBootstrap.java:320)\r\n2021-04-26 11:49:02.398,at io.netty.bootstrap.Bootstrap.doResolveAndConnect(Bootstrap.java:155)\r\n2021-04-26 11:49:02.398,at io.netty.bootstrap.Bootstrap.connect(Bootstrap.java:139)\r\n2021-04-26 11:49:02.398,at org.redisson.client.RedisClient.lambda$connectAsync$0(RedisClient.java:220)\r\n2021-04-26 11:49:02.398,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)\r\n2021-04-26 11:49:02.398,at org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)\r\n2021-04-26 11:49:02.398,at org.redisson.client.RedisClient.connectAsync(RedisClient.java:214)\r\n2021-04-26 11:49:02.398,at org.redisson.connection.ClientConnectionsEntry.connect(ClientConnectionsEntry.java:177)\r\n2021-04-26 11:49:02.398,at org.redisson.connection.pool.ConnectionPool.connect(ConnectionPool.java:270)\r\n2021-04-26 11:49:02.398,at org.redisson.connection.pool.ConnectionPool.createConnection(ConnectionPool.java:292)\r\n2021-04-26 11:49:02.398,at org.redisson.connection.pool.ConnectionPool.access$000(ConnectionPool.java:52)\r\n2021-04-26 11:49:02.398,at org.redisson.connection.pool.ConnectionPool$1.run(ConnectionPool.java:120)\r\n2021-04-26 11:49:02.398,at org.redisson.pubsub.AsyncSemaphore.tryRun(AsyncSemaphore.java:86)\r\n2021-04-26 11:49:02.398,at org.redisson.pubsub.AsyncSemaphore.acquire(AsyncSemaphore.java:66)\r\n2021-04-26 11:49:02.398,at org.redisson.connection.ClientConnectionsEntry.acquireConnection(ClientConnectionsEntry.java:147)\r\n2021-04-26 11:49:02.398,at org.redisson.connection.pool.ConnectionPool.acquireConnection(ConnectionPool.java:181)\r\n2021-04-26 11:49:02.398,at org.redisson.connection.pool.ConnectionPool.createConnection(ConnectionPool.java:115)\r\n2021-04-26 11:49:02.398,at org.redisson.connection.pool.ConnectionPool.initConnections(ConnectionPool.java:99)\r\n2021-04-26 11:49:02.398,at org.redisson.connection.pool.ConnectionPool.initConnections(ConnectionPool.java:83)\r\n2021-04-26 11:49:02.398,at org.redisson.connection.pool.SlaveConnectionPool.initConnections(SlaveConnectionPool.java:30)\r\n2021-04-26 11:49:02.398,at org.redisson.connection.balancer.LoadBalancerManager.unfreeze(LoadBalancerManager.java:157)\r\n2021-04-26 11:49:02.398,at org.redisson.connection.balancer.LoadBalancerManager.unfreeze(LoadBalancerManager.java:122)\r\n2021-04-26 11:49:02.398,at org.redisson.connection.MasterSlaveEntry.slaveUp(MasterSlaveEntry.java:382)\r\n2021-04-26 11:49:02.398,at org.redisson.cluster.ClusterConnectionManager.lambda$addRemoveSlaves$11(ClusterConnectionManager.java:535)\r\n2021-04-26 11:49:02.398,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.398,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.398,at org.redisson.misc.TransferListener.accept(TransferListener.java:42)\r\n2021-04-26 11:49:02.398,at org.redisson.misc.TransferListener.accept(TransferListener.java:26)\r\n2021-04-26 11:49:02.398,at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n2021-04-26 11:49:02.398,at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n2021-04-26 11:49:02.398,at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n2021-04-26 11:49:02.398,at org.redisson.misc.CountableListener.decCounter(CountableListener.java:54)\r\n2021-04-26 11:49:02.398,at org.redisson.misc.CountableListener.accept(CountableListener.java:71)\r\n2021-04-26 11:49:02.398,at org.redisson.misc.CountableListener.accept(CountableListener.java:26)`"
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-27T06:01:04Z",
        "body": "> java.lang.NoClassDefFoundError: io/netty/bootstrap/FailedChannel\r\n\r\nDid you check classpath? It seems some classes are absent"
      },
      {
        "user": "dpavluchenko",
        "created_at": "2021-04-27T06:35:59Z",
        "body": "Yeah, they are present. Moreover, everything works properly till we modify the AWS Redis cluster to another type. \r\nAnd I've noticed this issue is reproduced only when we are using Clustered Redis. With simple server everything is ok."
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-27T06:45:38Z",
        "body": "> And I've noticed this issue is reproduced only when we are using Clustered Redis\r\n\r\nI need Redisson logs to sort out"
      }
    ]
  },
  {
    "number": 3569,
    "title": "Simple key value read and write example",
    "created_at": "2021-04-23T06:54:37Z",
    "closed_at": "2021-04-27T05:59:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3569",
    "body": "Hi Team,\r\n            Can you share a sample on how to read/write a simple key value  using RedissonReactiveClient\r\n\r\nkey: String\r\nvalue:  java object\r\n\r\nReactive way of writing and reading will be great help.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3569/comments",
    "author": "ShanmugamC",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-04-23T12:45:46Z",
        "body": "Use `RedissonReactiveClient.getBucket()` method."
      },
      {
        "user": "ShanmugamC",
        "created_at": "2021-04-23T15:44:50Z",
        "body": "@mrniko Thanks a lot for your quick help !"
      }
    ]
  },
  {
    "number": 3565,
    "title": "How to print current open connections in redisson client?",
    "created_at": "2021-04-22T18:45:55Z",
    "closed_at": "2021-08-11T05:19:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3565",
    "body": "I am trying to tune redisson client connection pool configuration and I am using cluster mode to connect to ElastiCache. I am trying to analyse what is current connections utilised and other connection pool details. \r\nCan anyone please help me how to print the information?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3565/comments",
    "author": "harshamadala",
    "comments": [
      {
        "user": "harshamadala",
        "created_at": "2021-04-25T11:31:56Z",
        "body": "Can anyone please reply? This will help to understand how redisson is behaving internally with respect to connections. "
      },
      {
        "user": "mrniko",
        "created_at": "2021-08-11T05:19:56Z",
        "body": "you can set `DEBUG` logging level to `org.redisson` package to see connection acquisition/release."
      }
    ]
  },
  {
    "number": 3555,
    "title": "Eviction for Entities Annotated with a Region that contains \":\" caracter",
    "created_at": "2021-04-15T00:00:21Z",
    "closed_at": "2025-01-07T16:56:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3555",
    "body": "My entities are annotated with Regions following Redis hierarchy, using colons:\r\n\r\n`@Cache(region = \"jpa:entity:Product\", usage = CacheConcurrencyStrategy.READ_WRITE)` \r\n\r\nHow could I set the eviction times for these Entities, on our `application.properties`?\r\n\r\nWe try:\r\n```\r\nspring.jpa.properties.hibernate.cache.redisson.*.expiration.time_to_live=1000\r\nspring.jpa.properties.hibernate.cache.redisson.jpa:entity:Product.expiration.time_to_live=1000\r\nspring.jpa.properties.hibernate.cache.redisson.jpa\\:entity\\:Product.expiration.time_to_live=1000\r\n```\r\n\r\nBut none of them worked.\r\nReplacing the region to string that is not colon delimiter, works as a charm.\r\n\r\nAny advice?\r\nThanks!!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3555/comments",
    "author": "regisoliveira",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2025-01-07T16:56:11Z",
        "body": "Unable to reproduce it using standard hibernate properties. Seems like it's a Spring jpa issue."
      }
    ]
  },
  {
    "number": 3552,
    "title": "exception in redisson decode",
    "created_at": "2021-04-13T08:11:14Z",
    "closed_at": "2021-05-11T05:15:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3552",
    "body": "hi,\r\n\r\nis following exception is also related to netty version or there is other problem , by the way wasn't happen to us before production :)\r\n\r\n2021-04-13 00:56:32.886 ERROR [redisson-netty-5-6] [UID:, MSG_ID:] [org.redisson.client.handler.CommandDecoder] <Unable to decode data. channel: [id: 0x7cf299d2, L:/10.20.30.46:60492 - R**********amazonaws.com/*********], reply: ReplayingDecoderByteBuf(ridx=731, widx=16046), command: (HGETALL), params: [redisson:tomcat_session:FC5EA1D579A23B0EABBE7309D03486F2.APP_EMEA_2103]>\r\n\r\njava.io.IOException: java.lang.ClassNotFoundException: com.panaya.as.blexecuter.imp.BaseBLContext\r\n\tat org.redisson.codec.MarshallingCodec$3.decode(MarshallingCodec.java:153) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.codec.SnappyCodec$3.decode(SnappyCodec.java:84) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:356) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:400) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:365) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:178) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_261]\r\nCaused by: java.lang.ClassNotFoundException: com.panaya.as.blexecuter.imp.BaseBLContext\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:382) ~[na:1.8.0_261]\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:418) ~[na:1.8.0_261]\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:351) ~[na:1.8.0_261]\r\n\tat java.lang.Class.forName0(Native Method) ~[na:1.8.0_261]\r\n\tat java.lang.Class.forName(Class.java:348) ~[na:1.8.0_261]\r\n\tat org.jboss.marshalling.AbstractClassResolver.loadClass(AbstractClassResolver.java:129) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.jboss.marshalling.AbstractClassResolver.resolveClass(AbstractClassResolver.java:110) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadClassDescriptor(RiverUnmarshaller.java:1033) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1366) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:283) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:216) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.jboss.marshalling.AbstractObjectInput.readObject(AbstractObjectInput.java:41) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.codec.MarshallingCodec$3.decode(MarshallingCodec.java:151) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\t... 26 common frames omitted\r\n2021-04-13 00:56:32.887 ERROR [redisson-netty-5-6] [UID:, MSG_ID:] [org.redisson.client.handler.ErrorsLoggingHandler] <Exception occured. Channel: [id: 0x7cf299d2, L:/10.20.30.46:60492 - R:emea-redis.mugo7l.ng.0001.euw1.cache.amazonaws.com/10.20.100.149:6379]>\r\nio.netty.handler.codec.DecoderException: java.io.IOException: java.lang.ClassNotFoundException: com.panaya.as.blexecuter.imp.BaseBLContext\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [redisson-all-3.14.0.jar:3.14.0]\r\n\tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_261]\r\nCaused by: java.io.IOException: java.lang.ClassNotFoundException: com.panaya.as.blexecuter.imp.BaseBLContext\r\n\tat org.redisson.codec.MarshallingCodec$3.decode(MarshallingCodec.java:153) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.codec.SnappyCodec$3.decode(SnappyCodec.java:84) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:356) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:400) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:365) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:178) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\t... 17 common frames omitted\r\nCaused by: java.lang.ClassNotFoundException: com.panaya.as.blexecuter.imp.BaseBLContext\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:382) ~[na:1.8.0_261]\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:418) ~[na:1.8.0_261]\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:351) ~[na:1.8.0_261]\r\n\tat java.lang.Class.forName0(Native Method) ~[na:1.8.0_261]\r\n\tat java.lang.Class.forName(Class.java:348) ~[na:1.8.0_261]\r\n\tat org.jboss.marshalling.AbstractClassResolver.loadClass(AbstractClassResolver.java:129) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.jboss.marshalling.AbstractClassResolver.resolveClass(AbstractClassResolver.java:110) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadClassDescriptor(RiverUnmarshaller.java:1033) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1366) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:283) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:216) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.jboss.marshalling.AbstractObjectInput.readObject(AbstractObjectInput.java:41) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\tat org.redisson.codec.MarshallingCodec$3.decode(MarshallingCodec.java:151) ~[redisson-all-3.14.0.jar:3.14.0]\r\n\t... 26 common frames omitted",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3552/comments",
    "author": "wdaas",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-04-13T09:25:04Z",
        "body": "That's related to class loader problem. Try to set `useThreadClassLoader` = false and check your classpath for class presence."
      },
      {
        "user": "wdaas",
        "created_at": "2021-04-13T09:57:36Z",
        "body": "to add it to redisson.yaml file ?\r\nis there is a reason why it happens to us in specific env and other env not even it is same code and configuration?, "
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-13T13:17:28Z",
        "body": "> to add it to redisson.yaml file ?\r\n\r\nYes.\r\n\r\n> is there is a reason why it happens to us in specific env and other env not even it is same code and configuration?,\r\n\r\nTo answer this question you need to look at classloader hierarchy in debug."
      },
      {
        "user": "lilaizhencn",
        "created_at": "2021-04-15T07:01:29Z",
        "body": "when i test use openj9, also throw this error."
      }
    ]
  },
  {
    "number": 3548,
    "title": "some time we see exception on DNSMonitor ",
    "created_at": "2021-04-12T11:00:26Z",
    "closed_at": "2021-04-12T11:31:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3548",
    "body": "hi,\r\nwe see some time following exception at the log , we don't know the reason for it \r\n\r\n2021-04-12 06:15:11.452 ERROR [redisson-netty-2-15] [UID:, MSG_ID:] [org.redisson.connection.DNSMonitor] <Unable to resolve **********.amazonaws.com>\r\njava.lang.IndexOutOfBoundsException: Index: 0, Size: 0\r\n\tat java.util.ArrayList.rangeCheck(ArrayList.java:659) ~[na:1.8.0_261]\r\n\tat java.util.ArrayList.get(ArrayList.java:435) ~[na:1.8.0_261]\r\n\tat io.netty.resolver.dns.DnsNameResolver.doResolveCached(DnsNameResolver.java:613) ~[netty-all-4.1.15.Final.jar:4.1.15.Final]\r\nat io.netty.resolver.dns.DnsNameResolver.doResolve(DnsNameResolver.java:593) ~[netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat io.netty.resolver.dns.DnsNameResolver.doResolve(DnsNameResolver.java:527) ~[netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat io.netty.resolver.SimpleNameResolver.resolve(SimpleNameResolver.java:63) ~[netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat io.netty.resolver.dns.InflightNameResolver.resolve(InflightNameResolver.java:100) ~[netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat io.netty.resolver.dns.InflightNameResolver.resolve(InflightNameResolver.java:66) ~[netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat io.netty.resolver.dns.InflightNameResolver.resolve(InflightNameResolver.java:51) ~[netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat io.netty.resolver.InetSocketAddressResolver.doResolve(InetSocketAddressResolver.java:57) ~[netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat io.netty.resolver.InetSocketAddressResolver.doResolve(InetSocketAddressResolver.java:32) ~[netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat io.netty.resolver.AbstractAddressResolver.resolve(AbstractAddressResolver.java:108) ~[netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat org.redisson.connection.DNSMonitor.monitorMasters(DNSMonitor.java:103) ~[redisson-3.14.0.jar:3.14.0]\r\n\tat org.redisson.connection.DNSMonitor.access$300(DNSMonitor.java:45) ~[redisson-3.14.0.jar:3.14.0]\r\n\tat org.redisson.connection.DNSMonitor$1.run(DNSMonitor.java:92) ~[redisson-3.14.0.jar:3.14.0]\r\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38) ~[netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:120) ~[netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) [netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403) [netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463) [netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858) [netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138) [netty-all-4.1.15.Final.jar:4.1.15.Final]\r\n\tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_261]",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3548/comments",
    "author": "wdaas",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-04-12T11:02:49Z",
        "body": "I assume the issue in netty resolver. Did you try to update netty?"
      },
      {
        "user": "wdaas",
        "created_at": "2021-04-12T11:08:36Z",
        "body": "to which version we need to update it? currently, I see  4.1.15, \r\nis there a specific reason why it happens and when?\r\nbecause other Radisson behaviour works fine?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-12T11:09:28Z",
        "body": "to the latest"
      },
      {
        "user": "wdaas",
        "created_at": "2021-04-12T11:15:30Z",
        "body": "thanks.\r\nbut i can't understand the exception and why it happens, if you can share with us?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-12T11:29:55Z",
        "body": "According to stacktrace this issue happens in netty. I don't know the reason. Since 4.1.15 version a lot of issues regarding dns resolving have been fixed."
      },
      {
        "user": "wdaas",
        "created_at": "2021-04-12T11:31:18Z",
        "body": "thanks alot"
      }
    ]
  },
  {
    "number": 3546,
    "title": "Object not added in RSet",
    "created_at": "2021-04-12T08:04:23Z",
    "closed_at": "2021-04-13T05:43:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3546",
    "body": "In the below code, we are facing intermittent issues where` System.out.println(\"Your Ids: \"+ids1)` is not printed when we add something and RedissionSet reference doesn't contain anything even after adding objects to it.\r\n```\r\nfinal Set<String> homeIds = platformCache.getSet(Home.fetchProductCacheKey(productId));\r\n\r\nList<String> getIds = callToDb.getProductId(productId);\r\n\r\nfor(String ids : getIds) {\r\nhomeIds.add(ids);\r\n}\r\n\r\nfor(String ids1: homeIds) { // This for loop is not run since homeids were empty sometimes.\r\nSystem.out.println(\"Your Ids: \"+ids1);\r\n}\r\n\r\n```\r\n\r\nAre we doing anything wrong? Any help will be appreciated.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3546/comments",
    "author": "vipul1231",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-04-12T08:53:19Z",
        "body": "Try ReadMode.MASTER setting"
      },
      {
        "user": "vipul1231",
        "created_at": "2021-04-12T10:10:54Z",
        "body": "I believe this setting will move reading data to master node ?. This will increase traffic to my master node. Please correct me if I am wrong."
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-12T12:43:20Z",
        "body": "This issue happens due to replication lag between slave/master nodes."
      },
      {
        "user": "vipul1231",
        "created_at": "2021-04-13T05:43:13Z",
        "body": "Ok thanks. Closing this issue."
      }
    ]
  },
  {
    "number": 3545,
    "title": "org.redisson.client.WriteRedisConnectionException ",
    "created_at": "2021-04-11T14:44:08Z",
    "closed_at": "2021-09-06T10:49:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3545",
    "body": "Some time getting following exception in unit tests but not always \r\n```\r\norg.redisson.client.WriteRedisConnectionException: Unable to write command into connection! \r\nNode source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null],\r\n connection: RedisConnection@1405217801 [redisClient=[addr=redis://localhost:6333], \r\nchannel=[id: 0xec022dc7, L:0.0.0.0/0.0.0.0:38200], currentCommand=null], command: (EVAL), \r\nparams: [local v = redis.call('hget', KEYS[1], ARGV[1]); \r\nredis.call('hset', KEYS[1], ARGV[1], ARGV[2]); retur..., 1,  \r\nRequestCache, PooledUnsafeDirectByteBuf(ridx: 0, widx: 42, cap: 256), \r\nPooledUnsafeDirectByteBuf(ridx: 0, widx: 103, cap: 256)] after 3 retry attempts\r\nCaused by: io.netty.channel.StacklessClosedChannelException\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3545/comments",
    "author": "kamalbctg",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-04-12T12:54:51Z",
        "body": "you need to check your network if channels are closed often."
      },
      {
        "user": "kamalbctg",
        "created_at": "2021-04-12T13:53:27Z",
        "body": "@mrniko  thank you for reply. I have 14 tests some time(1 out of 100 run) one of them failed. i am starting embedded-redis with @BeforeClass also check with external redis never seen instance is down as i can perform redis operation using redis-client. By the way my implementation have Rlock.    "
      },
      {
        "user": "packley1",
        "created_at": "2021-07-26T22:09:32Z",
        "body": "> you need to check your instance since it closes channels.\r\n\r\nWhat do you mean by this?  Are you saying that the Redis Server is closing the connection?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-07-27T04:28:14Z",
        "body": "@packley1 \r\n\r\nI mean to check network"
      },
      {
        "user": "packley1",
        "created_at": "2021-07-27T13:20:09Z",
        "body": "> @packley1\r\n> \r\n> I mean to check network\r\n\r\nSo we are seeing this same error, but only under very specific conditions.  Generally everything works well, we load tested and did not see this error.  However, when we attempt to retrieve a large object (roughly 18MB) from the cache, it is fine.  However, if multiple threads retrieve the same large object from the cache at about the same time, we start seeing this error.  When we fetch the item from the cache, we do update the expiry time from each thread - could this be an issue (updating the same cached object from multiple threads)?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-07-27T13:54:07Z",
        "body": "@packley1 \r\n\r\nYou need to increase nettyThreads amount. Decoding 18Mb of data may make netty thread busy and block queued connection operations."
      },
      {
        "user": "packley1",
        "created_at": "2021-07-28T04:48:47Z",
        "body": "> @packley1\r\n> \r\n> You need to increase nettyThreads amount. Decoding 18Mb of data may make netty thread busy and block queued connection operations.\r\n\r\nI did try this, set it to 128.... No changes.\r\n\r\nMy solution/work around is to make sure the same key is not requested simultaneously.  So far this is promising.\r\n\r\nI will put together the sequence which causes this issue, in the next day or so."
      },
      {
        "user": "xqdd",
        "created_at": "2021-09-07T08:46:03Z",
        "body": "> > @packley1\r\n> > You need to increase nettyThreads amount. Decoding 18Mb of data may make netty thread busy and block queued connection operations.\r\n> \r\n> I did try this, set it to 128.... No changes.\r\n> \r\n> My solution/work around is to make sure the same key is not requested simultaneously. So far this is promising.\r\n> \r\n> I will put together the sequence which causes this issue, in the next day or so.\r\n\r\n@packley1  any update?\r\n\r\n"
      },
      {
        "user": "packley1",
        "created_at": "2021-09-07T12:51:27Z",
        "body": "In a nut shell this problem occurs when we make simultaneous requests to REDIS for cached data which is large (in our case the cached data was 18Mb)."
      },
      {
        "user": "mrniko",
        "created_at": "2021-09-14T06:20:41Z",
        "body": "@packley1 \r\n\r\nDid you try to increase connections amount?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-09-17T08:23:32Z",
        "body": "I have checked. Increased size of connection pool solves the issue."
      }
    ]
  },
  {
    "number": 3544,
    "title": "Why ExpirationEntry use LinkedHashMap to save threadId",
    "created_at": "2021-04-09T09:28:20Z",
    "closed_at": "2021-04-13T02:50:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3544",
    "body": "Reddison watchDog strategy use timerTask to increase key expiration time while set the lock success\r\n\r\n    private void renewExpiration() {\r\n        ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());\r\n        if (ee == null) {\r\n            return;\r\n        }\r\n        \r\n        Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() {\r\n            @Override\r\n            public void run(Timeout timeout) throws Exception {\r\n                ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());\r\n                if (ent == null) {\r\n                    return;\r\n                }\r\n                Long threadId = ent.getFirstThreadId();\r\n                if (threadId == null) {\r\n                    return;\r\n                }\r\n                \r\n                RFuture<Boolean> future = renewExpirationAsync(threadId);\r\n                ......\r\n       }\r\n   }\r\n\r\n  First use **entryName** to get ExpirationEntry object. For the same entryName, other threads can't get the key because locked(ps: same thread can get and counter++)，so why use LinkedHashMap to save thread if there only have one thread?\r\n\r\n`public static class ExpirationEntry {\r\n\r\n        private final Map<Long, Integer> threadIds = new LinkedHashMap<>();\r\n        private volatile Timeout timeout;\r\n\r\n        public ExpirationEntry() {\r\n            super();\r\n        }\r\n\r\n        public synchronized void addThreadId(long threadId) {\r\n            Integer counter = threadIds.get(threadId);\r\n            if (counter == null) {\r\n                counter = 1;\r\n            } else {\r\n                counter++;\r\n            }\r\n            threadIds.put(threadId, counter);\r\n        }\r\n}`",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3544/comments",
    "author": "yukerui",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-04-12T13:14:20Z",
        "body": "in case of readwrite lock there are might be multiple read locks."
      },
      {
        "user": "yukerui",
        "created_at": "2021-04-13T02:50:36Z",
        "body": "> in case of readwrite lock there are might be multiple read locks.\r\n\r\nUnderstood, thank you for your reply"
      }
    ]
  },
  {
    "number": 3539,
    "title": "Collection RLocalCachedMap  thread safe question",
    "created_at": "2021-04-07T07:22:05Z",
    "closed_at": "2021-04-08T06:50:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3539",
    "body": "hi,im use redisson collection ,and this is my code \r\n t6 put kv to localCachedMap,\r\n then concurrent requests t5, found   duplicate records\r\n``` java\r\n    @GetMapping(\"/t5\")\r\n    public String t5() {\r\n        RLocalCachedMap<Long, Map<Long, String>> rcount = redisson.getLocalCachedMap(\"tt2\", LocalCachedMapOptions.defaults());\r\n        Iterator<Map.Entry<Long, Map<Long, String>>> iterator = rcount.entrySet().iterator();\r\n        int i = 0;\r\n        while (iterator.hasNext()) {\r\n            Map.Entry<Long, Map<Long, String>> item = iterator.next();\r\n            if (i >= 10) {\r\n                break;\r\n            }\r\n            Long key = item.getKey();\r\n            Map<Long, String> pair = item.getValue();\r\n            log.info(\"left---- : \" + item.getKey() + \"val---- : \" + pair.get(key));\r\n            rcount.remove(key);\r\n            log.info(\"size : \",rcount.size());\r\n            i++;\r\n            log.info(\"---------------------------------------------------------\");\r\n\r\n        }\r\n        rcount.destroy();\r\n        return \"ok!\";\r\n    }\r\n\r\n    @GetMapping(\"/t6\")\r\n    public String t6() {\r\n        RLocalCachedMap<Long, Map<Long, String>> rcount = redisson.getLocalCachedMap(\"tt2\", LocalCachedMapOptions.defaults());\r\n        for (int i = 100; i < 1000; i++) {\r\n            HashMap hashMap = Maps.newHashMap();\r\n            hashMap.put(Long.valueOf(i), \"val\" + i);\r\n            rcount.put(Long.valueOf(i), hashMap);\r\n        }\r\n        return \"ok!\";\r\n    }\r\n```\r\nrequest  log\r\n```\r\n2021-04-07 15:05:36.532  INFO 1860 --- [io-8082-exec-10] com.test.controller.TController      : ---------------------------------------------------------\r\n2021-04-07 15:05:36.532  INFO 1860 --- [io-8082-exec-10] com.test.controller.TController      : left---- : 972val---- : val972\r\n2021-04-07 15:05:36.534  INFO 1860 --- [nio-8082-exec-9] com.test.controller.TController      : ---------------------------------------------------------\r\n2021-04-07 15:05:36.534  INFO 1860 --- [nio-8082-exec-9] com.test.controller.TController      : left---- : 972val---- : val972\r\n2021-04-07 15:05:36.536  INFO 1860 --- [io-8082-exec-10] com.test.controller.TController      : size : \r\n2021-04-07 15:05:36.537  INFO 1860 --- [nio-8082-exec-9] com.test.controller.TController      : size : \r\n2021-04-07 15:05:36.537  INFO 1860 --- [io-8082-exec-10] com.test.controller.TController      : ---------------------------------------------------------\r\n2021-04-07 15:05:36.537  INFO 1860 --- [io-8082-exec-10] com.test.controller.TController      : left---- : 875val---- : val875\r\n2021-04-07 15:05:36.539  INFO 1860 --- [nio-8082-exec-9] com.test.controller.TController      : ---------------------------------------------------------\r\n2021-04-07 15:05:36.539  INFO 1860 --- [nio-8082-exec-9] com.test.controller.TController      : left---- : 875val---- : val875\r\n2021-04-07 15:05:36.540  INFO 1860 --- [io-8082-exec-10] com.test.controller.TController      : size : \r\n2021-04-07 15:05:36.542  INFO 1860 --- [io-8082-exec-10] com.test.controller.TController      : ---------------------------------------------------------\r\n2021-04-07 15:05:36.542  INFO 1860 --- [nio-8082-exec-9] com.test.controller.TController      : size : \r\n2021-04-07 15:05:36.542  INFO 1860 --- [io-8082-exec-10] com.test.controller.TController      : left---- : 561val---- : val561\r\n2021-04-07 15:05:36.544  INFO 1860 --- [nio-8082-exec-9] com.test.controller.TController      : ---------------------------------------------------------\r\n2021-04-07 15:05:36.544  INFO 1860 --- [nio-8082-exec-9] com.test.controller.TController      : left---- : 561val---- : val561\r\n2021-04-07 15:05:36.545  INFO 1860 --- [io-8082-exec-10] com.test.controller.TController      : size : \r\n2021-04-07 15:05:36.547  INFO 1860 --- [io-8082-exec-10] com.test.controller.TController      : ---------------------------------------------------------\r\n2021-04-07 15:05:36.547  INFO 1860 --- [nio-8082-exec-9] com.test.controller.TController      : size : \r\n2021-04-07 15:05:36.550  INFO 1860 --- [nio-8082-exec-9] com.test.controller.TController      : ---------------------------------------------------------\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3539/comments",
    "author": "tayfer",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-04-07T07:52:37Z",
        "body": "Local cache map doesn't use hashCode/equals methods, but hash of serialized state. Since Redis doesn't use hashCode/equals either."
      },
      {
        "user": "tayfer",
        "created_at": "2021-04-08T06:47:40Z",
        "body": " iterator itself is not thread-safe"
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-08T06:50:42Z",
        "body": "yes, since as any other iterator it's has internal state. `hasNext` and `next` methods should be called by the same thread"
      }
    ]
  },
  {
    "number": 3538,
    "title": "Handling of shard being down in a Redis cluster",
    "created_at": "2021-04-06T06:44:34Z",
    "closed_at": "2021-06-30T08:45:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3538",
    "body": "Hi\r\n\r\nDoes Redisson has any logic for intelligently handling a scenario where a particular shard is down in Redis. Possible 'intelligent' solutions could be to-\r\n1. Avoid calling Redis cluster for keys located over that shard\r\n2. Not keep retrying for keys which are continuously failing\r\n\r\nAll these solutions may enable it to keep serving the traffic for which ever keys it can from other shards.\r\nThis is possible only with some built in knowledge of key distribution across shards, I am not aware if redisson has that context ?\r\n\r\nThanks!\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3538/comments",
    "author": "shaurya10000",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-04-06T06:52:52Z",
        "body": "> Avoid calling Redis cluster for keys located over that shard\r\n> Not keep retrying for keys which are continuously failing\r\n\r\nYou can control that with `retryInterval` setting. No attempts are made if you set it `0`."
      }
    ]
  },
  {
    "number": 3537,
    "title": "Object lost due to TTL",
    "created_at": "2021-04-05T11:17:02Z",
    "closed_at": "2021-04-06T09:03:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3537",
    "body": "We are trying the below approach to get the data from Redis with TTL.\r\n\r\nRMap<String, Object> rMap = this.client.getMap(this.getEnvCacheKey(cacheKey));\r\nrMap.expire(this.defaultTTL, TimeUnit.SECONDS);\r\n\r\n//Fetch the object\r\nObject object = rMap.get(\"id\");\r\n\r\n//Putting the same in list\r\nList<Object> list = new ArrayList<>();\r\nlist.add(object);\r\n\r\n//Now TTL expires of key and object deleted.\r\n\r\nNow list.size == 0 and my application failing due to this since the object fetched in removed from memory.\r\n\r\nPlease any approach to mitigate this issue.\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3537/comments",
    "author": "vipul1231",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-04-05T11:36:48Z",
        "body": "Please check you code. Since returned object by `get()` can't `disappear` after TTL once it was returned."
      },
      {
        "user": "vipul1231",
        "created_at": "2021-04-05T12:21:43Z",
        "body": "The same thing is happening with getList as well.\r\n\r\nfinal RList<V> rList = client.getList(getEnvCacheKey(cacheKey));\r\nrList.expire(7L, TimeUnit.SECONDS);\r\n\r\nrlist.add(\"Value1\");\r\nrlist.add(\"Value2\");\r\n\r\nassertThat(rList).containsOnly(\"Value1\", \"Value2\");\r\n\r\nNow after 7 seconds \r\nrlist.size() becomes 0\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-05T12:42:13Z",
        "body": "assertion is for `set` object and not `rlist`"
      },
      {
        "user": "vipul1231",
        "created_at": "2021-04-05T12:52:40Z",
        "body": "Updated the example."
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-06T09:03:36Z",
        "body": "that's expected behaviour to get empty list after 7 seconds, since ttl is 7 seconds"
      }
    ]
  },
  {
    "number": 3536,
    "title": "Caused by: java.lang.NullPointerException",
    "created_at": "2021-04-05T10:29:56Z",
    "closed_at": "2021-04-16T06:07:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3536",
    "body": "Hi Team,\r\n\r\nwhile we are using Redisson 2.15.1. \r\nJava 1.7.80\r\nWith 3 redis clusters and 3 application instances\r\nwith below redisson.conf \r\n\r\n`{\r\n   \"clusterServersConfig\":{\r\n      \"idleConnectionTimeout\":10000,\r\n      \"connectTimeout\":10000,\r\n      \"timeout\":3000,\r\n      \"retryAttempts\":3,\r\n      \"retryInterval\":1500,\r\n      \"failedSlaveReconnectionInterval\":3000,\r\n      \"failedSlaveCheckInterval\":60000,\r\n      \"password\":null,\r\n      \"subscriptionsPerConnection\":10,\r\n      \"clientName\":null,\r\n      \"loadBalancer\":{\r\n         \"class\":\"org.redisson.connection.balancer.RoundRobinLoadBalancer\"\r\n      },\r\n      \"subscriptionConnectionMinimumIdleSize\":1,\r\n      \"subscriptionConnectionPoolSize\":50,\r\n      \"slaveConnectionMinimumIdleSize\":1,\r\n      \"slaveConnectionPoolSize\":2,\r\n      \"masterConnectionMinimumIdleSize\":1,\r\n      \"masterConnectionPoolSize\":2,\r\n      \"readMode\":\"MASTER\",\r\n      \"subscriptionMode\":\"MASTER\",\r\n      \"nodeAddresses\":[\r\n         \"master1\",\r\n \t \"master2”,\r\n\t \"master3”,\r\n\t \"master1-slave1”,\r\n\t \"master1-slave2”,\r\n \t \"master1-slave3”,\r\n \t \"master2-slave1”,\r\n\t \"master2-slave2”,\r\n \t \"master2-slave3”,\r\n \t \"master3-slave1”,\r\n\t \"master3-slave2”,\r\n \t \"master3-slave3”,\r\n\r\n      ],\r\n      \"scanInterval\":1000,\r\n      \"pingConnectionInterval\": 0,\r\n      \"keepAlive\": false,\r\n      \"tcpNoDelay\": false,\r\n   },\r\n   \"threads\":0,\r\n   \"nettyThreads\": 0,\r\n   \"codec\":{\r\n      \"class\":\"org.redisson.codec.SerializationCodec\"\r\n   },\r\n   \"transportMode\":\"NIO\"\r\n}`\r\n\r\n\r\nAnd getting below error.\r\n\r\n\r\n\r\norg.redisson.client.RedisException: Unexpected exception while processing command\r\n\tat org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:414)\r\n\tat org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:211)\r\n\tat org.redisson.RedissonObject.get(RedissonObject.java:75)\r\n\tat org.redisson.RedissonMap.putAll(RedissonMap.java:296)\r\n\tat org.redisson.tomcat.RedissonSession.access(RedissonSession.java:117)\r\n\tat org.redisson.tomcat.RedissonSessionManager.findSession(RedissonSessionManager.java:176)\r\n\tat org.apache.catalina.connector.Request.doGetSession(Request.java:2855)\r\n\tat org.apache.catalina.connector.Request.getSession(Request.java:2254)\r\n\tat org.redisson.tomcat.UpdateValve.invoke(UpdateValve.java:60)\r\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:518)\r\n\tat org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1091)\r\n\tat org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:668)\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1527)\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1484)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\nCaused by: java.lang.NullPointerException\r\n\tat org.redisson.codec.CompositeCodec.getValueDecoder(CompositeCodec.java:74)\r\n\tat org.redisson.client.handler.CommandDecoder.selectDecoder(CommandDecoder.java:464)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:329)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:130)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:110)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:656)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:591)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:508)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:470)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:909)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\t... 1 more",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3536/comments",
    "author": "NaveenSadhana",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-04-05T10:59:37Z",
        "body": "`valueDecoder` passed to `CompositeCodec` is `null`. Make sure it's not null during construction."
      },
      {
        "user": "NaveenSadhana",
        "created_at": "2021-04-05T17:31:08Z",
        "body": "@mrniko, the error qps is 0.01 out of 24.5 success qps.... This issue is not occurring all the time. So not able to replicate frequently and also not able to replicate in DEV environment"
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-09T07:47:38Z",
        "body": "Unable to reproduce it with the latest version"
      }
    ]
  },
  {
    "number": 3528,
    "title": "Exrta bytes in the value are missing when saved using local cache mode (getLocalMapedCache) ",
    "created_at": "2021-03-30T09:48:31Z",
    "closed_at": "2021-04-16T06:08:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3528",
    "body": "This is a very simple java program using Redisson adding products to a productTableCache\r\n\r\n```\r\n        // save the prod to ProdTableCache\r\n        Product prod1 = new Product(\"DirectProd102\", \"Mobile\", 1000);\r\n        Product prod2 = new Product(\"LocalProd102\", \"Mobile\", 1000);\r\n        String prodMapKey = \"ProductTable\";\r\n        final TypedJsonJacksonCodec prodCodec = new TypedJsonJacksonCodec(String.class, Product.class, new ObjectMapper());\r\n        RMapCache<String, Product> prodDirectMap = redisson.getMapCache(prodMapKey, prodCodec);\r\n        prodDirectMap.put(prod1.id, prod1);\r\n\r\n```\r\nWhen i look from redis-cli , i see these extra bytes added to the product value in redis - what are these additional bytes ? \r\n\r\n```\r\n127.0.0.1:6001> hscan ProductTable 0\r\n1) \"0\"\r\n    3) \"\\\"DirectProd102\\\"\"\r\n    4) \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00-\\x00\\x00\\x00\\x00\\x00\\x00\\x00{\\\"id\\\":\\\"Prod102\\\",\\\"name\\\":\\\" Mobile  \\\",\\\"price\\\":1000}\"\r\n\r\n```\r\nNow if i insert another product using `Redisson getLocalMapedCache` i dont see these additional bytes \r\n\r\n```\r\n        Product prod2 = new Product(\"LocalProd102\", \"Mobile\", 1000);\r\n        RLocalCachedMap<String, Product> prodLocalMap = redisson.getLocalCachedMap(prodMapKey, prodCodec, options);\r\n        prodLocalMap.put(prod2.id, prod2);\r\n\r\n```\r\n```\r\n127.0.0.1:6001> hscan ProductTable 0\r\n1) \"0\"\r\n2)  1) \"\\\"LocalProd102\\\"\"\r\n    2) \"{\\\"id\\\":\\\"LocalProd102\\\",\\\"name\\\":\\\"Mobile\\\",\\\"price\\\":1000}\"\r\n\r\n```\r\nBut now if i refer to `LocalProd102 `in an `EVALSHA `script , it gives exception possibly because the additional bytes are not found. \r\n\r\nAny help or prior experience in this regards ? \r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3528/comments",
    "author": "a2oravi",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-04-12T16:43:43Z",
        "body": "RMapCache stores idleTimeout along with value. RLocalCachedMap doesn't store this value."
      }
    ]
  },
  {
    "number": 3516,
    "title": "MaxIdleTime on Redis Live Object",
    "created_at": "2021-03-23T15:48:58Z",
    "closed_at": "2021-09-06T10:51:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3516",
    "body": "Hi,\r\nIs it possible to set maxIdleTime on Live Object in Redisson?\r\nIf not, is there another option to delete unused objects?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3516/comments",
    "author": "bbartekb",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-09-06T10:51:04Z",
        "body": "Redis doesn't support maxIdleTime for objects. Only TTL can be defined. You can add unused object to RSet object and then delete all objects stored in this set."
      }
    ]
  },
  {
    "number": 3513,
    "title": "can redisson lock accross apps written by different language?",
    "created_at": "2021-03-22T08:14:12Z",
    "closed_at": "2021-04-09T07:48:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3513",
    "body": "can redisson lock accross apps written by different language like golang, python?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3513/comments",
    "author": "Duncan-tree-zhou",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-03-25T07:32:06Z",
        "body": "Yes, it can be done."
      },
      {
        "user": "Duncan-tree-zhou",
        "created_at": "2021-03-29T11:35:13Z",
        "body": "> Yes, it can be done.\r\n\r\nso how to make it? are there any examples or doc to do it in golang and python?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-09T07:48:24Z",
        "body": "You can review java code."
      }
    ]
  },
  {
    "number": 3512,
    "title": "redisson用阿里云集群版redis的问题 ",
    "created_at": "2021-03-21T14:54:41Z",
    "closed_at": "2021-03-25T09:31:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3512",
    "body": "阿里云集群版redis限制了使用EVAL命令。\r\norg.springframework.web.util.NestedServletException: Request processing failed; nested exception is org.redisson.client.RedisException: ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS array, and KEYS should not be in expression. channel",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3512/comments",
    "author": "anchuang",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-03-25T07:33:10Z",
        "body": "Please contact your Redis vendor to solve the issue. Redis doesn't have such limitation and some of keys might be generated dynamically."
      },
      {
        "user": "anchuang",
        "created_at": "2021-03-25T09:31:26Z",
        "body": "Okay, thank you"
      }
    ]
  },
  {
    "number": 3493,
    "title": "Transaction in Redis Live Object Service",
    "created_at": "2021-03-16T21:14:11Z",
    "closed_at": "2021-03-18T06:56:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3493",
    "body": "Hi,\r\n\r\nIs it possible to perform transaction on Redis Live Object?\r\nI want write a new instance of MyClass - only if new instance is newer than previous one. \r\nI need method similar to 'merge' in RMap. \r\n\r\n    @REntity\r\n    public class MyClass {\r\n\r\n        @RId\r\n        private String key;\r\n\r\n        @RIndex\r\n        public Date createDate;\r\n\r\n        @RIndex\r\n        public String externalValue;\r\n     }\r\n\r\nSo I need to compare dates of old and new objects and then save new object only if it newer. It has be executed in one transaction. In other thread someone can update fields in this object.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3493/comments",
    "author": "bbartekb",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-03-17T08:46:35Z",
        "body": "Wrap this function with RLock object with name based on object id."
      },
      {
        "user": "bbartekb",
        "created_at": "2021-03-17T21:33:02Z",
        "body": "Thank you for your response!\r\n\r\nIt works for me with tryLock()\r\n\r\n    public void updateLiveObjectEntry(MyClass myObject) {\r\n        RLiveObjectService rLiveObjectService = getRedissonConnection().getClient().getLiveObjectService();\r\n        RLock lock = getRedissonConnection().getClient().getLock(myObject.getKey());\r\n\r\n        try {\r\n            lock.tryLock(10, TimeUnit.SECONDS);\r\n            if (myObject.getCreateDate().after(rLiveObjectService.get(MyClass.class, myObject.getKey()).getCreateDate())) {\r\n                rLiveObjectService.merge(myObject);\r\n            }\r\n        } catch (InterruptedException e) {\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n    \r\nIs my solution correct? \r\nI think this lock is not connected with my LiveObject, so myObject entry is not locked. It will be work if in all usage I use method updateLiveObjectEntry().\r\n    "
      },
      {
        "user": "mrniko",
        "created_at": "2021-03-18T05:31:12Z",
        "body": "you can use follow lock name: `String lockName = MyClass.class.getName() + \":\" + myObject.getKey()`. If you have any doubts about the key uniqueness with different Object classes."
      },
      {
        "user": "bbartekb",
        "created_at": "2021-03-18T06:56:07Z",
        "body": "Ok, thank you."
      }
    ]
  },
  {
    "number": 3492,
    "title": "with service cluster,a machine have held the lock,another machine will unlock successfully?",
    "created_at": "2021-03-16T09:49:18Z",
    "closed_at": "2021-03-25T08:13:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3492",
    "body": "the method 'tryAcquireAsync' of RedissonLock class,use current thread IDas redis value.\r\nif two machine have same thread ID,a machine have held the lock,another machine will unlock successfully?\r\nRedissonLock class can use a map to store current application have own Lock,if service reentrant or unlock,\r\nverify that it have the lock before.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3492/comments",
    "author": "li-shaoke",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-03-25T08:13:54Z",
        "body": "> if two machine have same thread ID,a machine have held the lock,another machine will unlock successfully?\r\n\r\nNo, because every lock owner uses Redisson instance id along with thread id."
      }
    ]
  },
  {
    "number": 3485,
    "title": "Abnormal behaviour in redis mapwriter execution",
    "created_at": "2021-03-16T07:57:43Z",
    "closed_at": "2021-03-25T08:20:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3485",
    "body": "We have used write behind mode in mapoption,\r\nmy code written in write method is executing fine but after some time \r\ni have observed that i am getting \"org.redisson.client.RedisOutOfMemoryException\" exception after that my write method of mapwriter is not getting called, \r\ncan yo please help me out in these.\r\n\r\nAlso observed that after getting any throwable error in write method same behaviour is getting replicate.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3485/comments",
    "author": "BhaveshPunjabi",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-03-18T08:13:33Z",
        "body": "RedisOutOfMemoryException means Redis memory is full. Did you check it?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-03-18T08:13:59Z",
        "body": "> Also observed that after getting any throwable error in write method same behaviour is getting replicate.\r\n\r\nCan you share stacktrace?"
      },
      {
        "user": "BhaveshPunjabi",
        "created_at": "2021-03-19T04:20:30Z",
        "body": "    at org.redisson.MapWriteBehindTask.lambda$null$0(MapWriteBehindTask.java:100)\r\n    at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\r\n    at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\r\n    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n    at java.base/java.lang.Thread.run(Thread.java:834)"
      },
      {
        "user": "BhaveshPunjabi",
        "created_at": "2021-03-19T04:23:26Z",
        "body": "yes i checked memory was getting 100 % utilized"
      },
      {
        "user": "mrniko",
        "created_at": "2021-03-19T07:13:46Z",
        "body": "> yes i checked memory was getting 100 % utilized\r\n\r\nRedisson stores only data you sent to Redis nothing more. You may try to use compression codecs like SnappyCodec and LZ4"
      }
    ]
  },
  {
    "number": 3476,
    "title": "Caused by: java.lang.ClassNotFoundException: com.fasterxml.jackson.core.TSFBuilder",
    "created_at": "2021-03-14T23:59:36Z",
    "closed_at": "2021-03-16T16:49:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3476",
    "body": "keep getting this error when i try this\r\nConfig.fromYAML(PropertiesUtil.getResourceAsFile(REDISSON_RESOURCE_NAME));\r\n\r\nthe exception is \r\nCaused by: java.lang.NoClassDefFoundError: com/fasterxml/jackson/core/TSFBuilder\r\n\tat org.redisson.config.ConfigSupport.<init>(ConfigSupport.java:92)\r\n\tat org.redisson.config.Config.fromYAML(Config.java:661)\r\n\tat org.redisson.config.Config.fromYAML(Config.java:657)\r\n\r\nwhen I try to look at the code can't find usage for TSFBuilder at class ConfigSupport",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3476/comments",
    "author": "wdaas",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-03-15T04:57:00Z",
        "body": "Check for absence of two jackson libs in classpath with different versions"
      },
      {
        "user": "wdaas",
        "created_at": "2021-03-16T16:49:38Z",
        "body": "thanks @mrniko \r\n\r\nthe problem was that redis 3.14.0 have dependency to jackson-dataformat-yaml.jar and it import version 2.11.1\r\nbut in our project we work with Jackson-core 2.7.6 .\r\n\r\nby add explicitly at mvn file dependency for version 2.7.6 for jackson-dataformat-yaml.jar we fix the issue."
      }
    ]
  },
  {
    "number": 3475,
    "title": "what is the minimum version for \"jackson-core\" required for redisson 3.14.0",
    "created_at": "2021-03-14T15:41:17Z",
    "closed_at": "2021-03-15T05:32:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3475",
    "body": "what is the minimum version for \"jackson-core\" required for redisson 3.14.0",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3475/comments",
    "author": "wdaas",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-03-15T05:32:28Z",
        "body": "2.6.x"
      }
    ]
  },
  {
    "number": 3474,
    "title": "Why redisson lock implements use WAIT command",
    "created_at": "2021-03-13T02:16:02Z",
    "closed_at": "2021-03-17T11:09:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3474",
    "body": "I am using redisson lock in my project, but the redis cluster i use in product env forbidden to use WAIT command, so the redisson lock alway ends up to and RedisException with message \" wait command not found\", I try every lock implements in redisson, all the same, so what should i do to fix this ? change anothe redis or write a lock by myselft ?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3474/comments",
    "author": "deanisty",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-03-13T04:50:11Z",
        "body": "wait is used to sync lock state with slaves and increase lock durability. With this feature RedLock isn't needed anymore."
      },
      {
        "user": "deanisty",
        "created_at": "2021-03-13T08:04:01Z",
        "body": "> wait is used to sync lock state with slaves and increase lock durability. With this feature RedLock isn't needed anymore.\r\n\r\nSo, does \"**wait**\" command will slow down redis in some circumstance, thus my cloud redis service provider not allow to use \"wait\" in **cluster** mode."
      },
      {
        "user": "mrniko",
        "created_at": "2021-03-17T11:09:35Z",
        "body": "yes, it can. I'm afraid I can't change this behavior due to incomplete implementation of Redis protocol by one vendor."
      }
    ]
  },
  {
    "number": 3465,
    "title": "CommandDecoder:181 - Unable to decode data. channel: Unsupported protocol version 0",
    "created_at": "2021-03-10T19:05:40Z",
    "closed_at": "2021-03-10T19:52:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3465",
    "body": "I am trying to store a basic POJO called **MobileNotificationDTO** inside an RMap<Long,MobileNotificationDTO> using `MarshallingCodec`\r\n\r\n```\r\npublic class MobileNotificationDTO implements Serializable {\r\n\r\n    private Long id;\r\n    private LocalDateTime createdOn;\r\n    private boolean sent;\r\n\r\n    public Long getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(Long id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public LocalDateTime getCreatedOn() {\r\n        return createdOn;\r\n    }\r\n\r\n    public void setCreatedOn(LocalDateTime createdOn) {\r\n        this.createdOn = createdOn;\r\n    }\r\n\r\n    public boolean isSent() {\r\n        return sent;\r\n    }\r\n\r\n    public void setSent(boolean sent) {\r\n        this.sent = sent;\r\n    }\r\n}\r\n\r\n```\r\n\r\nWriting an integration test, it is failing to retrieve the POJO from the map\r\n\r\n```\r\n    @Before\r\n    public void setUp() throws Exception {\r\n\r\n        Config config = new Config();\r\n\r\n        ObjectMapper objectMapper = new ObjectMapper();\r\n        config.setCodec(new MarshallingCodec());\r\n        config.useSingleServer()\r\n                .setAddress(\"redis://localhost:6379\");\r\n\r\n\r\n        redissonClient = Redisson.create(config);\r\n        cache = new MobileNotificationsCache(redissonClient);\r\n    }\r\n\r\n\r\n    @Test\r\n    public void put_WhenMobileNotificationIsSet_ThenValueIsCachedCorrectly() {\r\n        final Long id = 682124L;\r\n        final LocalDateTime createdOn = LocalDateTime.now();\r\n        final MobileNotificationDTO dto = new MobileNotificationDTO();\r\n        dto.setId(123L);\r\n        dto.setCreatedOn(createdOn);\r\n        dto.setSent(true);\r\n\r\n        redissonClient.getMapCache(MobileNotificationsCache.CACHE_NAME).put(id, dto);\r\n\r\n        RMap<Long, MobileNotificationDTO> map = redissonClient.getMapCache(MobileNotificationsCache.CACHE_NAME, new LongCodec());\r\n        assertThat(map.size()).isEqualTo(1);\r\n        MobileNotificationDTO result = map.get(id);\r\n        assertThat(result.getId()).isEqualTo(123L);\r\n        assertThat(result.getCreatedOn()).isEqualTo(createdOn);\r\n        assertThat(result.isSent()).isTrue();\r\n\r\n    }\r\n```\r\n\r\n\r\nThe full error is as follows\r\n\r\n>  ERROR CommandDecoder:181 - Unable to decode data. channel: [id: 0x6ef3b6fd, L:/127.0.0.1:57900 - R:localhost/127.0.0.1:6379], reply: ReplayingDecoderByteBuf(ridx=171, widx=171), command: (HGET), params: [MOBILE_NOTIFICATIONS, PooledUnsafeDirectByteBuf(ridx: 0, widx: 10, cap: 256)]\r\n> java.io.IOException: Unsupported protocol version 0\r\n> \tat org.jboss.marshalling.river.RiverUnmarshaller.start(RiverUnmarshaller.java:1348)\r\n> \tat org.redisson.codec.MarshallingCodec$3.decode(MarshallingCodec.java:150)\r\n> \tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:359)\r\n> \tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:178)\r\n> \tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117)\r\n> \tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102)\r\n> \tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:508)\r\n> \tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n> \tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n> \tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n> \tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n> \tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n> \tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n> \tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n> \tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n> \tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n> \tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n> \tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)\r\n> \tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)\r\n> \tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)\r\n> \tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n> \tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n> \tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n> \tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n> \tat java.lang.Thread.run(Thread.java:748)\r\n> 2021-03-10 18:57:56 ERROR ErrorsLoggingHandler:47 - Exception occured. Channel: [id: 0x6ef3b6fd, L:/127.0.0.1:57900 - R:localhost/127.0.0.1:6379]\r\n> io.netty.handler.codec.DecoderException: java.io.IOException: Unsupported protocol version 0\r\n\r\n\r\nAny ideas how to fix this issue? I have tried JsonMarshallingCode and StringCodec but still the same error",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3465/comments",
    "author": "tomaytotomato",
    "comments": [
      {
        "user": "hipopular",
        "created_at": "2021-08-06T06:59:17Z",
        "body": "2021-08-06 14:53:42.691 [redisson-netty-2-6] [] ERROR org.redisson.client.handler.ErrorsLoggingHandler => Exception occured. Channel: [id: 0x8fff9d26, L:/10.190.0.233:63675 - R:r-xxxx]\r\nException in thread \"TW-SINGLE_GOODS\" org.redisson.client.RedisException: Unexpected exception while processing command\r\n\tat org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:324)\r\n\tat org.redisson.command.CommandAsyncService.getInterrupted(CommandAsyncService.java:137)\r\n\tat org.redisson.RedissonBlockingDeque.takeFirst(RedissonBlockingDeque.java:209)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.io.IOException: Unsupported protocol version 0\r\n\tat org.jboss.marshalling.river.RiverUnmarshaller.start(RiverUnmarshaller.java:1375)\r\n\tat org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:145)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:366)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:410)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:375)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:183)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:107)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:628)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:563)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:480)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:442)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\r\n有没有办法解决，最新版本3.16.1"
      },
      {
        "user": "mrniko",
        "created_at": "2021-08-06T07:01:11Z",
        "body": "@hipopular \r\n\r\nYou're trying to decode data serialized with different codec. Not a default one."
      },
      {
        "user": "hipopular",
        "created_at": "2021-08-06T09:48:51Z",
        "body": "为什么会出现这种情况 ，写入/读取的数据 都是默认编解码器的 没有自定义噢 ，只有在阿里云上有这种问题 ，很奇怪"
      },
      {
        "user": "mrniko",
        "created_at": "2021-08-06T10:00:29Z",
        "body": "@hipopular \r\n\r\nYou can set `TRACE` logging level for `org.redisson.client.handler.CommandDecoder` to spot an actual value."
      }
    ]
  },
  {
    "number": 3464,
    "title": "redis重启之后某些服务器连接redis一直没恢复报MasterConnectionPool no available Redis entries错误",
    "created_at": "2021-03-10T18:30:43Z",
    "closed_at": "2021-03-25T08:20:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3464",
    "body": "Caused by: org.redisson.client.RedisConnectionException: MasterConnectionPool no available Redis entries.  Disconnected hosts: [/1**.**.**.**]\r\n\tat org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:198)\r\n\tat org.redisson.connection.pool.MasterConnectionPool.get(MasterConnectionPool.java:31)\r\n\tat org.redisson.connection.MasterSlaveEntry.connectionWriteOp(MasterSlaveEntry.java:535)\r\n\tat org.redisson.connection.SingleEntry.connectionReadOp(SingleEntry.java:45)\r\n\tat org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:807)\r\n\tat org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:496)\r\n\tat org.redisson.command.CommandAsyncService.readAsync(CommandAsyncService.java:351)\r\n\tat org.redisson.RedissonBucket.getAsync(RedissonBucket.java:102)\r\n\tat org.redisson.RedissonBucket.get(RedissonBucket.java:97)\r\n\t... 146 more\r\n\r\n\r\nredisson配置\r\n.setFailedAttempts(1).setConnectTimeout(300).setRetryAttempts(0).setTimeout(100);",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3464/comments",
    "author": "cclouds",
    "comments": [
      {
        "user": "cclouds",
        "created_at": "2021-03-10T18:58:08Z",
        "body": "version\r\n3.6.0"
      },
      {
        "user": "mrniko",
        "created_at": "2021-03-11T06:03:45Z",
        "body": "Update to 3.6.5 version."
      },
      {
        "user": "cclouds",
        "created_at": "2021-03-11T06:13:17Z",
        "body": "> Update to 3.6.5 version.\r\n\r\nThank you"
      }
    ]
  },
  {
    "number": 3462,
    "title": "Is there a simple way to change node address dynamically?",
    "created_at": "2021-03-09T10:22:04Z",
    "closed_at": "2021-03-17T10:49:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3462",
    "body": "I try to use redisson(3.7.0) as my redis cluster client, and I need to change the connection address of redisson dynamically, in Spring environment, is there a simple way to do that? Does it need to consider the instance with old connection's recycle?\r\n\r\nI tried to get the redisson instance directly and update the node information of its config like:\r\n\r\n```java\r\nRedisson redisson = ctx.getBean(\"redisson\");\r\nConfig conf = redisson.getConfig();\r\nconf.useClusterServers().getNodeAddresses().clear();\r\nconf.useClusterServers().addNodeAddress(\"new-address\");\r\n```\r\n\r\nbut it failed(it could work sometimes).",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3462/comments",
    "author": "catxu",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-03-09T10:31:05Z",
        "body": "dynamic change of configuration is not supported"
      }
    ]
  },
  {
    "number": 3461,
    "title": "Can we set a local cache size for RSetMultimapCache?",
    "created_at": "2021-03-09T04:46:47Z",
    "closed_at": "2021-03-25T08:21:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3461",
    "body": "Is there a way to set an upper limit on the number of elements that are kept in the local cache?  I don't see a way to do this and our TTLs are very long.  I don't see a way to clear the local cache ourselves either.  Containers like `RLocalCachedMap` have `clearLocalCache()`, but `RSetMultimapCache` does not.\r\nThanks!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3461/comments",
    "author": "luxe",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-03-10T08:32:31Z",
        "body": "RSetMultimapCache doesn't support local cache feature"
      }
    ]
  },
  {
    "number": 3459,
    "title": "How Redisson's DelayQueue offer same element as one element？",
    "created_at": "2021-03-08T09:07:53Z",
    "closed_at": "2021-03-17T10:49:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3459",
    "body": "As far as I know, Redisson implements delayQueue through zset and list,zset will not add repeatedly for the same member\r\n\r\n127.0.0.1:6379> zadd myzset  1 mykey\r\n(integer) 1\r\n127.0.0.1:6379> zadd myzset  2 mykey\r\n(integer) 0\r\n127.0.0.1:6379> zcard myzset\r\n(integer) 1\r\n\r\nBelow is my code：\r\n`import junit.framework.TestCase;\r\nimport org.junit.Test;\r\nimport org.redisson.Redisson;\r\nimport org.redisson.api.RBlockingQueue;\r\nimport org.redisson.api.RDelayedQueue;\r\nimport org.redisson.api.RedissonClient;\r\nimport org.redisson.config.Config;\r\n\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n\r\npublic class RedissonTest extends TestCase {\r\n\r\n    private RedissonClient redisson;\r\n\r\n\r\n    protected void init() {\r\n        // connects to 127.0.0.1:6379 by default\r\n//        RedissonClient redisson = Redisson.create();\r\n\r\n        Config config = new Config();\r\n        config.useSingleServer().setAddress(\"redis://localhost:6379\");\r\n        redisson = Redisson.create(config);\r\n    }\r\n\r\n\r\n    @Test\r\n    public void testDelayedQueue() throws InterruptedException {\r\n        init();\r\n        RBlockingQueue<String> distinationQueue = redisson.getBlockingQueue(\"redisson-blocking-test\");\r\n        RDelayedQueue<String> delayedQueue = redisson.getDelayedQueue(distinationQueue);\r\n        // move object to distinationQueue in 10 seconds\r\n        delayedQueue.offer(\"msg1\", 13, TimeUnit.HOURS);\r\n        // move object to distinationQueue in 1 minutes\r\n        delayedQueue.offer(\"msg1\", 40, TimeUnit.HOURS);\r\n    }\r\n\r\n\r\n}`\r\n\r\nbut there has two elements:\r\n127.0.0.1:6379> keys *\r\n1) \"myzset\"\r\n2) \"redisson_delay_queue:{redisson-blocking-test}\"\r\n3) \"redisson_delay_queue_timeout:{redission-blocking}\"\r\n4) \"redission-blocking\"\r\n5) \"redisson_delay_queue:{redisson-blocking}\"\r\n6) \"redisson_delay_queue:{redission-blocking}\"\r\n7) \"redisson_delay_queue_timeout:{redisson-blocking}\"\r\n8) \"redisson_delay_queue_timeout:{redisson-blocking-test}\"\r\n127.0.0.1:6379> zcard redisson_delay_queue_timeout:{redisson-blocking-test}\r\n(integer) 2\r\n127.0.0.1:6379> ZRANGEBYSCORE redisson_delay_queue_timeout:{redisson-blocking-test} -inf +inf\r\n1) \"\\x0e\\xb2\\xb6!F[\\xd9C\\a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04>\\x04msg1\"\r\n2) \"NH\\xef\\x7f\\x16\\xb8\\xb2\\xc3\\a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04>\\x04msg1\"\r\n\r\nhow can i tell redisson they are same member\r\n\r\nThank you for help me!\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3459/comments",
    "author": "hehuang139",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-03-17T10:47:11Z",
        "body": "Queue object allows to keep duplicated elements. So this is expected behavior. I store randomId with element, this allows to keep the same element in zset."
      }
    ]
  },
  {
    "number": 3436,
    "title": "Deserialization issue with Kryo5Codec post schema change.",
    "created_at": "2021-02-23T06:27:07Z",
    "closed_at": "2021-03-17T11:10:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3436",
    "body": "",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3436/comments",
    "author": "brijnkh",
    "comments": [
      {
        "user": "brijnkh",
        "created_at": "2021-02-23T06:34:05Z",
        "body": "**Java Code:**\r\n\r\nKryo5Codec testCodec = new Kryo5Codec(RedisCodecAvroSessionDataReaderTest.class.getClassLoader());\r\nConfig config = new Config();\r\nconfig.useSingleServer().setAddress(\"redis://localhost:6379\");\r\nconfig.setCodec(testCodec);\r\nRedissonClient redissonClient = Redisson.create(config);\r\ntry {\r\n\tString keyStr = \"keytest12\";\r\n\tsessionRMap = redissonClient.getMap(\"SESSIONS\", testCodec);\r\n\tSessionData retSession = sessionRMap.get(keyStr);\r\n\tSystem.out.println(\"Stored Display Name: \" + retSession.getDisplayName());\r\n\tSystem.out.println(\"Stored Time: \" + retSession.getUpdateTimeMillis());\r\n\tSystem.out.println(\"Stored Extra Display Name: \" + retSession.getExtraDisplayName());\r\n} catch (Exception e) {\r\n\te.printStackTrace();\r\n} finally {\r\n\tredissonClient.shutdown();\r\n}\r\n\r\n**Avro Updated schema:**\r\n\r\n{\r\n\"name\": \"SessionData\",\r\n\"type\": \"record\",\r\n\"namespace\": \"com.avro\",\r\n\"doc\": \"Session information\",\r\n\"fields\": [\r\n{\r\n\"name\": \"sessionId\",\r\n\"type\": [\r\n\"null\",\r\n\"string\"\r\n],\r\n\"doc\": \"the unique identifier for the session\"\r\n},\r\n{\r\n\"name\": \"displayName\",\r\n\"type\": [\r\n\"null\",\r\n\"string\"\r\n],\r\n\"doc\": \"the display name of participant\"\r\n},\r\n{\r\n\"name\": \"updateTimeMillis\",\r\n\"type\": \"long\",\r\n\"doc\": \"timestamp(miliseconds) at which record was last updated\"\r\n},\r\n{\r\n\"name\": \"extraDisplayName\",\r\n\"type\": [\r\n\"null\",\r\n\"string\"\r\n],\r\n\"doc\": \"the Extra display name of participant\"\r\n}\r\n]\r\n}\r\n\r\n**Note: extraDisplayName field is the one which was added later in the schema.**\r\n\r\n**Expected Behavior:**\r\nDeserialization works normally.\r\n\r\n**Actual behavior:**\r\nGetting below exception:\r\n11:49:27.290 [redisson-netty-2-10] ERROR org.redisson.client.handler.CommandDecoder - Unable to decode data. channel: [id: 0x1f101757, L:/127.0.0.1:53427 - R:localhost/127.0.0.1:6379], reply: ReplayingDecoderByteBuf(ridx=101, widx=101), command: (HGET), params: [SESSIONS, PooledUnsafeDirectByteBuf(ridx: 0, widx: 10, cap: 256)]\r\ncom.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: --XXXXXXX\r\n\r\nt com.esotericsoftware.kryo.util.DefaultClassResolver.readClass(DefaultClassResolver.java:167)\r\n\tat com.esotericsoftware.kryo.Kryo.readClass(Kryo.java:691)\r\n\tat com.esotericsoftware.kryo.serializers.ReflectField.read(ReflectField.java:118)\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.read(FieldSerializer.java:124)\r\n\tat com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:813)\r\n\tat org.redisson.codec.Kryo5Codec$4.decode(Kryo5Codec.java:95)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:356)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:178)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:508)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\t\r\n**Redisson Version:**\r\n3.14.0\r\n\r\n**Kryo Version:**\r\n5.0.3\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2021-02-23T07:09:39Z",
        "body": "This issue related to codec itself, not Redisson. JsonJacksonCodec works fine in this case."
      },
      {
        "user": "brijnkh",
        "created_at": "2021-02-23T07:29:49Z",
        "body": "@mrniko we have an issue with JsonJacksonCodec right? #3327 \r\nI need to deserialize post change in schema.\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2021-02-23T07:34:10Z",
        "body": "I mean use JsonJacksonCodec without schema."
      },
      {
        "user": "brijnkh",
        "created_at": "2021-02-23T09:55:26Z",
        "body": "@mrniko Is there any other way to handle schema change?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-03-17T11:10:33Z",
        "body": "I can't suggest the other solution"
      }
    ]
  },
  {
    "number": 3426,
    "title": "Will the next version of redisson plan to update netty to the latest version?",
    "created_at": "2021-02-19T09:31:45Z",
    "closed_at": "2021-02-23T07:10:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3426",
    "body": "Hi mrniko, \r\nWhen will redisson 3.15.1 be released? Will you update netty to the latest version?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3426/comments",
    "author": "rexzhong79626",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-02-19T09:34:49Z",
        "body": "During this month. Netty has already been updated."
      }
    ]
  },
  {
    "number": 3414,
    "title": "about addandget API ",
    "created_at": "2021-02-09T09:53:27Z",
    "closed_at": "2021-02-22T12:26:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3414",
    "body": "when i want to use the addandget API,i found the number convert throw a ClassCastException. \r\nsource code:BaseTransactionalMap.java \r\n``` \r\nBigDecimal currentValue = BigDecimal.ZERO; \r\nif (entry != MapEntry.NULL) { \r\ncurrentValue = (BigDecimal) entry.getValue(); \r\n} \r\nBigDecimal res = currentValue.add(new BigDecimal(value.toString())); \r\n``` \r\nthe error is on third line \r\nCan I use new BigDecimal(entry.getValue()) instead?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3414/comments",
    "author": "boboanyko",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-02-10T07:43:23Z",
        "body": "Did you try to use StringCodec?"
      }
    ]
  },
  {
    "number": 3407,
    "title": "Redis cluster master restart cause tps down and can't recover",
    "created_at": "2021-02-08T09:56:43Z",
    "closed_at": "2021-03-27T05:46:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3407",
    "body": "**Expected behavior**\r\nRedis cluster master down, redisson client update cluster state, and tps come down.  After a period of time, restart master node,  tps come back to normal.\r\n\r\n**Actual behavior**\r\nrestart master node,  tps  can't recover , just come back a little.  And server no error.\r\n\r\n**Steps to reproduce or test case**\r\n5 master and 5 slave\r\nmaster 1 down and wait for slave become master\r\nrestart master 1,  observe tps\r\n\r\n```\r\nconfig\r\n    readMode: \"MASTER\"\r\n    subscriptionMode: \"MASTER\"\r\n    nodeAddresses:\r\n        - \"redis://127.0.0.1:7001\"\r\n        - \"redis://127.0.0.1:7002\"\r\n        - \"redis://127.0.0.1:7003\"\r\n        - \"redis://127.0.0.1:7004\"\r\n        - \"redis://127.0.0.1:7005\"\r\n        - \"redis://127.0.0.1:7006\"\r\n        - \"redis://127.0.0.1:7007\"\r\n        - \"redis://127.0.0.1:7008\"\r\n        - \"redis://127.0.0.1:7009\"\r\n        - \"redis://127.0.0.1:7010\"\r\n    scanInterval: 1000\r\n    failedSlaveReconnectionInterval: 3000\r\n    failedSlaveCheckInterval: 3000\r\n    pingConnectionInterval: 5000\r\n```\r\n\r\n**version**\r\nredisson version : 3.14.1\r\n\r\nLooking forward for your response, Thank you!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3407/comments",
    "author": "tony1991",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-02-08T12:41:07Z",
        "body": "Can you set `TRACE` logging level for `org.redisson` and try again? Please share log output then."
      }
    ]
  },
  {
    "number": 3398,
    "title": "org.redisson.api.RAtomicLong#expireAt(long)  Cause the value to be deleted  ",
    "created_at": "2021-02-03T07:55:21Z",
    "closed_at": "2021-02-03T07:59:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3398",
    "body": "Redisson:3.15.0\r\nredis:4.0.9\r\n\r\norg.redisson.api.RAtomicLong#expireAt(long)\r\nCannot find the key of aKey after execution\r\n\r\nWhy is this ?\r\n\r\njava code\r\n```\r\n        Config config = new Config();\r\n        config.useSingleServer()\r\n                .setAddress(\"redis://127.0.0.1:6379\")\r\n                .setDatabase(0);\r\n        RedissonClient redissonClient = Redisson.create(config);\r\n\r\n        String aKey = \"aKey\";\r\n        RAtomicLong aAtomic = redissonClient.getAtomicLong(aKey);\r\n        long aValue0 = aAtomic.get();\r\n        LOG.info(\"aKey-value0[{}]\", aValue0);\r\n\r\n        aAtomic.incrementAndGet();\r\n        long aValue1 = aAtomic.get();\r\n        LOG.info(\"aKey-value1[{}]\", aValue1);\r\n        aAtomic.expireAt(1000 * 60 * 60);\r\n\r\n        long aValue2 = aAtomic.get();\r\n        LOG.info(\"aKey-value2[{}]\", aValue2);\r\n\r\n        LOG.info(\"---------------------------------------------------------\");\r\n\r\n        String bKey = \"bKey\";\r\n        RAtomicLong bAtomic = redissonClient.getAtomicLong(bKey);\r\n        long bValue0 = bAtomic.get();\r\n        LOG.info(\"bKey-value0[{}]\", bValue0);\r\n\r\n        bAtomic.incrementAndGet();\r\n        bAtomic.expire(10, TimeUnit.HOURS);\r\n\r\n        long bValue1 = bAtomic.get();\r\n        LOG.info(\"bKey-value1[{}]\", bValue1);\r\n\r\n        LOG.info(\"---------------------------------------------------------\");\r\n\r\n        String cKey = \"cKey\";\r\n        RAtomicLong cAtomic = redissonClient.getAtomicLong(cKey);\r\n        long cValue0 = cAtomic.get();\r\n        LOG.info(\"cKey-value0[{}]\", cValue0);\r\n\r\n        cAtomic.incrementAndGet();\r\n\r\n        long cValue1 = cAtomic.get();\r\n        LOG.info(\"cKey-value1[{}]\", cValue1);\r\n\r\n        redissonClient.shutdown();\r\n```\r\nlog...\r\n```\r\n15:45:35.913 [main] INFO org.redisson.Version - Redisson 3.15.0\r\n15:45:36.804 [redisson-netty-2-17] INFO org.redisson.connection.pool.MasterPubSubConnectionPool - 1 connections initialized for /127.0.0.1:6379\r\n15:45:36.817 [redisson-netty-2-17] INFO org.redisson.connection.pool.MasterConnectionPool - 24 connections initialized for /127.0.0.1:6379\r\n15:45:36.877 [main] INFO RedissonClient - aKey-value0[0]\r\n15:45:36.880 [main] INFO RedissonClient - aKey-value1[1]\r\n15:45:36.881 [main] INFO RedissonClient - aKey-value2[0]\r\n15:45:36.881 [main] INFO RedissonClient - ---------------------------------------------------------\r\n15:45:36.882 [main] INFO RedissonClient - bKey-value0[0]\r\n15:45:36.886 [main] INFO RedissonClient - bKey-value1[1]\r\n15:45:36.887 [main] INFO RedissonClient - ---------------------------------------------------------\r\n15:45:36.887 [main] INFO RedissonClient - cKey-value0[0]\r\n15:45:36.889 [main] INFO RedissonClient - cKey-value1[1]\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3398/comments",
    "author": "NoSugarIce",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-02-03T07:59:08Z",
        "body": "Because `expireAt()` method accepts date in milliseconds."
      },
      {
        "user": "NoSugarIce",
        "created_at": "2021-02-03T08:10:28Z",
        "body": "> Because `expireAt()` method accepts date in milliseconds.\r\n\r\n@mrniko Thanks, I realized the problem when I saw the code comments a few minutes after issuing the question ."
      }
    ]
  },
  {
    "number": 3392,
    "title": "version  upgrade",
    "created_at": "2021-01-30T03:15:48Z",
    "closed_at": "2021-01-31T09:29:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3392",
    "body": "redisson-all-3.12.1.jar  upgrade  redisson-all-3.14.0.jar \r\ncompiler error  \r\norg.nustaq.serialization.annotations.Version;    cannot find      so  add  fst-2.57.jar\r\nstart fail   \r\njava.lang.NoClassDefFoundError: org/objenesis/Objenesis\r\n\tat org.redisson.codec.FstCodec.<init>(FstCodec.java:182)\r\n\tat com.game.logical.global.RedissonUtils.buildRedissonConfig(RedissonUtils.java:45)\r\n\tat com.game.logical.global.RedissonUtils.<init>(RedissonUtils.java:35)\r\nCaused by: java.lang.ClassNotFoundException: org.objenesis.Objenesis\r\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:372)\r\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:361)\r\n\tat java.security.AccessController.doPrivileged(Native Method)\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:360)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\r\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\r\n\r\nadd objenesis-2.5.1.jar\r\nnormal start  \r\norg.redisson.transaction.TransactionException: Unable to execute transaction\r\n\tat org.redisson.transaction.RedissonTransaction.commit(RedissonTransaction.java:287)\r\n\tat org.redisson.transaction.RedissonTransaction.commit(RedissonTransaction.java:258)\r\n\r\nCaused by: org.redisson.client.RedisException: ERR unknown command 'WAIT'. channel: [id: 0x7208d34e, L:/10.2.100.83:20976 - R:/10.2.12.183:6379] command: (WAIT), params: [1, 5000]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:343)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:247)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:189)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102)\r\n\r\n\r\n\r\nredisson-all-3.12.1.jar  升级到  redisson-all-3.14.0.jar \r\n Import  org.nustaq.serialization.annotations.Version  报错  我就添加了 fst-2.57.jar\r\n启动时报错\r\njava.lang.NoClassDefFoundError: org/objenesis/Objenesis\r\n\tat org.redisson.codec.FstCodec.<init>(FstCodec.java:182)\r\n\tat com.game.logical.global.RedissonUtils.buildRedissonConfig(RedissonUtils.java:45)\r\n\tat com.game.logical.global.RedissonUtils.<init>(RedissonUtils.java:35)\r\nCaused by: java.lang.ClassNotFoundException: org.objenesis.Objenesis\r\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:372)\r\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:361)\r\n\tat java.security.AccessController.doPrivileged(Native Method)\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:360)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\r\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\r\n\r\n\r\nCould you tell me how to resolve this problem\r\n\r\n\r\n我就添加了\r\nadd objenesis-2.5.1.jar\r\n能正常启动 但是在执行事务是异常  事务混滚\r\n\r\norg.redisson.transaction.TransactionException: Unable to execute transaction\r\n\tat org.redisson.transaction.RedissonTransaction.commit(RedissonTransaction.java:287)\r\n\tat org.redisson.transaction.RedissonTransaction.commit(RedissonTransaction.java:258)\r\n\r\nCaused by: org.redisson.client.RedisException: ERR unknown command 'WAIT'. channel: [id: 0x7208d34e, L:/10.2.100.83:20976 - R:/10.2.12.183:6379] command: (WAIT), params: [1, 5000]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:343)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:247)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:189)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102)\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3392/comments",
    "author": "wl980868110",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-01-31T09:29:25Z",
        "body": "> ERR unknown command 'WAIT`\r\n\r\nupdate your Redis to 3.0+"
      }
    ]
  },
  {
    "number": 3390,
    "title": "RBatch response order with cluster env ?",
    "created_at": "2021-01-28T16:31:38Z",
    "closed_at": "2021-02-05T06:19:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3390",
    "body": "> In cluster environment batch executed in map\\reduce way. It aggregates commands for each node and sends them simultaneously, then result got from each node added to common result list.\r\n\r\n```\r\n\r\n    /**\r\n     * Executes all operations accumulated during async methods invocations.\r\n     * <p>\r\n     * If cluster configuration used then operations are grouped by slot ids\r\n     * and may be executed on different servers. Thus command execution order could be changed\r\n     *\r\n     * @return List with result object for each command\r\n     * @throws RedisException in case of any error\r\n     *\r\n     */\r\n    BatchResult<?> execute() throws RedisException;\r\n```\r\n\r\nRead above tips, I was not sure about responses order for origin commands.\r\nCould you help me make sure about this?\r\n\r\n1.When commands send group by slots, but I want know responses order is right with original commands?\r\n\r\n\r\nthx~ ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3390/comments",
    "author": "waylink",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-01-29T07:03:15Z",
        "body": "You'll always get correct response, but in cluster environment result in BatchResult can have different order."
      },
      {
        "user": "waylink",
        "created_at": "2021-01-29T07:12:57Z",
        "body": "> You'll always get correct response, but in cluster environment result in BatchResult can have different order.\r\n\r\n~~in cluster env result in batchResult have different order.~~\r\n\r\nHow to understand ?  in cluster env"
      },
      {
        "user": "mrniko",
        "created_at": "2021-01-31T09:37:01Z",
        "body": "result has different order since single request spliced into different requests and executed concurrently on different Redis nodes. If keys of such commands don't belong to the same master node."
      },
      {
        "user": "waylink",
        "created_at": "2021-01-31T10:13:27Z",
        "body": "> result has different order since single request spliced into different requests and executed concurrently on different Redis nodes. If keys of such commands don't belong to the same master node.\r\n\r\nall right.\r\n\r\nInvoker always get correct response in cluster env.\r\n\r\nOnly warning : BatchResult[] has different order for execute in cluster env."
      },
      {
        "user": "mrniko",
        "created_at": "2021-02-05T06:19:14Z",
        "body": "It's better to attach handler to each command executed in RBatch rather than use result list:\r\n\r\n```java\r\n\t\tRBatch batch = client.createBatch(batchOptions);\r\n\t\tfor (int i = 0; i < 10; i++) {\r\n\t\t\tString key = \"\" + i;\r\n                        RFuture<Object> t = batch.getBucket(key).getAsync();\r\n                        t.whenComplete((res, ex) -> {\r\n                \r\n                       });\r\n\t\t}\r\n\t\tbatch.execute();\r\n```"
      }
    ]
  },
  {
    "number": 3387,
    "title": "RPC is very slow",
    "created_at": "2021-01-27T10:21:32Z",
    "closed_at": "2021-01-31T09:32:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3387",
    "body": "RPC  very slowly. It takes about 1 second to get data for 10 times. How to solve this problem",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3387/comments",
    "author": "mobyqll1102",
    "comments": [
      {
        "user": "yangwn",
        "created_at": "2021-01-29T10:12:22Z",
        "body": "我也发现这个问题，最后换成Dubbo或Rest RPC来做解决了。\r\nRedisson感觉除了分布式锁有借鉴之外，其他的特性，都比较慢。特别是RedisoonSchedule，RedissonLiveObject, RedissonCache 与Lettuce没有可比性，差了一个数量级。\r\n而且数量越大越明显，感觉不太敢用了。"
      },
      {
        "user": "mrniko",
        "created_at": "2021-01-29T12:03:25Z",
        "body": "Can you share your code?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-01-29T12:11:58Z",
        "body": "local simulation of 10000 concurrent invocations with two threads takes about 8 seconds. Here is the test:\r\n\r\n```java\r\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\r\n        RRemoteService remoteService = redisson.getRemoteService();\r\n        remoteService.register(RemoteInterface.class, new RemoteImpl());\r\n        RemoteInterface service = redisson.getRemoteService().get(RemoteInterface.class);\r\n\r\n        List<Future<?>> futures = new ArrayList<>();\r\n\r\n        int iterations = 10000;\r\n        CountDownLatch l = new CountDownLatch(iterations);\r\n        long t = System.currentTimeMillis();\r\n        for (int i = 0; i < iterations; i++) {\r\n            futures.add(executorService.submit(() -> {\r\n                try {\r\n                    if (ThreadLocalRandom.current().nextBoolean()) {\r\n                        service.resultMethod(1L);\r\n                    } else {\r\n                        service.methodOverload();\r\n                    }\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n                l.countDown();\r\n            }));\r\n        }\r\n\r\n        l.await(10, TimeUnit.SECONDS);\r\n```"
      }
    ]
  },
  {
    "number": 3386,
    "title": "redisson client configuration when using AWS elastic cache with single end point but with replicas ",
    "created_at": "2021-01-26T13:05:54Z",
    "closed_at": "2021-02-23T07:13:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3386",
    "body": "what the optimal configuration when we use redisson as session manager and as a cache service , and the Redis cache provided by AWS elastic cache with a single endpoint that had replicas in the case of AZ failure ?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3386/comments",
    "author": "wdaas",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-01-27T08:12:39Z",
        "body": "Default settings are already optimal. Other settings like `nettyThreads`, `connectionPoolSize` ... depend on data size, app server performance, Redis performance, network and application load."
      },
      {
        "user": "wdaas",
        "created_at": "2021-01-27T08:37:07Z",
        "body": "hi,\r\nthanks for the replay i currently because I have one endpoint by AWS elastic cache that has replicas for the backup purposes i use as the following is it enough?\r\n\r\nsingleServerConfig:\r\n  idleConnectionTimeout: 10000\r\n  connectTimeout: 10000\r\n  timeout: 10000\r\n  retryAttempts: 3\r\n  retryInterval: 1000\r\n  password: null\r\n  subscriptionsPerConnection: 5\r\n  clientName: null\r\n  address: \"redis://address:6379\"\r\n  subscriptionConnectionMinimumIdleSize: 1\r\n  subscriptionConnectionPoolSize: 50\r\n  connectionMinimumIdleSize: 5\r\n  connectionPoolSize: 250\r\n  database: 0\r\n  dnsMonitoringInterval: 5000\r\nthreads: 0\r\nnettyThreads: 0\r\ncodec: !<org.redisson.codec.SnappyCodec> {}\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2021-01-27T09:49:24Z",
        "body": "I think you can use default pool size, usually it's enough. Set nettyThreads more than 32, since they used in redis decoding process."
      }
    ]
  },
  {
    "number": 3382,
    "title": "No response after 1000ms",
    "created_at": "2021-01-25T10:41:58Z",
    "closed_at": "2021-01-26T06:45:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3382",
    "body": "\t\r\nat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: org.redisson.remote.RemoteServiceTimeoutException: No response after 1000ms\r\n\tat org.redisson.remote.BaseRemoteProxy$1.run(BaseRemoteProxy.java:149)\r\n\tat io.netty.util.concurrent.PromiseTask.runTask(PromiseTask.java:98)\r\n\tat io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:170)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\r\n\t... 4 more",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3382/comments",
    "author": "zhaojian770627",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-01-25T10:58:27Z",
        "body": "the reason could be in network or remoteservice handler"
      }
    ]
  },
  {
    "number": 3379,
    "title": "Is redisson using write behind strategy guarantee data sync to DB\" ",
    "created_at": "2021-01-25T07:14:47Z",
    "closed_at": "2021-01-25T07:26:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3379",
    "body": "I m exploring the use of write behind strategy, just wonder is it guarantee data sync to DB.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3379/comments",
    "author": "seedarren",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-01-25T07:26:33Z",
        "body": "No, because data is written in asynchronous mode"
      }
    ]
  },
  {
    "number": 3374,
    "title": "time_to_live and max_idle_time doesn't work in redisson as 2 level cache in hibernate",
    "created_at": "2021-01-22T10:31:32Z",
    "closed_at": "2021-01-23T05:12:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3374",
    "body": "Hello everybody,\r\nI try to use Redisson  as second level cache in my jpa spring boot application it works fine i see that it cache entities in redis it just i need to set a time to live and time to idle on cache entries i use this configuration below but it doesn't work:\r\n\r\n`spring.jpa.properties.hibernate.cache.use_second_level_cache=true\r\nspring.cache.type=redis\r\n\r\nhibernate.cache.redisson.entity.expiration.time_to_live=1000\r\nhibernate.cache.redisson.entity.expiration.max_idle_time=1000\r\nhibernate.cache.redisson.collection.expiration.time_to_live=1000\r\nhibernate.cache.redisson.collection.expiration.max_idle_time=1000\r\n\r\nspring.jpa.properties.hibernate.cache.region.factory_class=org.redisson.hibernate.RedissonRegionFactory\r\nspring.jpa.properties.hibernate.cache.redisson.config=redisson/redisson-dev.yaml\r\nspring.jpa.properties.hibernate.cache.redisson.fallback=true\r\nspring.jpa.properties.javax.persistence.sharedCache.mode=ENABLE_SELECTIVE\r\n\r\nserver.port=8888\r\nspring.datasource.url=jdbc:h2:mem:testdb\r\nspring.datasource.driverClassName=org.h2.Driver\r\nspring.datasource.username=sa\r\nspring.datasource.password=\r\n\r\nspring.jpa.database-plateform=org.hibernate.dialect.H2Dialect\r\nspring.jpa.hibernate.ddl-auto=update\r\nspring.h2.console.enabled=true\r\nlogging.level.org.hibernate.SQL=DEBUG\r\nlogging.level.org.hibernate.type=TRACE\r\n`\r\n\r\ni use  redisson-hibernate-53  as dependancy\r\n\r\nAny help on this will help ,thank you.\r\n  \r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3374/comments",
    "author": "yeagerrrr",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-01-22T12:07:55Z",
        "body": "I think spring config file doesn't pickup custom hibernate settings used by Redisson. Try to define them in hibernate config xml file"
      },
      {
        "user": "yeagerrrr",
        "created_at": "2021-01-22T12:32:22Z",
        "body": "it works !!!!!\r\ni just use : \r\n\r\nspring.jpa.properties.hibernate.cache.redisson.entity.expiration.time_to_live=1000\r\nspring.jpa.properties.hibernate.cache.redisson.entity.expiration.max_idle_time=1000\r\nspring.jpa.properties.hibernate.cache.redisson.collection.expiration.time_to_live=1000\r\nspring.jpa.properties.hibernate.cache.redisson.collection.expiration.max_idle_time=1000\r\n\r\nintead of : \r\n\r\nhibernate.cache.redisson.entity.expiration.time_to_live=1000\r\nhibernate.cache.redisson.entity.expiration.max_idle_time=1000\r\nhibernate.cache.redisson.collection.expiration.time_to_live=1000\r\nhibernate.cache.redisson.collection.expiration.max_idle_time=1000\r\n\r\n@mrniko thank you very much for your answer 👍 "
      },
      {
        "user": "mrniko",
        "created_at": "2021-01-23T05:12:18Z",
        "body": "I'm closing this"
      }
    ]
  },
  {
    "number": 3363,
    "title": "FstCodec error",
    "created_at": "2021-01-20T09:46:43Z",
    "closed_at": "2021-02-03T08:09:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3363",
    "body": "Use version redisson-all-3.12.1\r\nData abnormal under high concurrency\r\nnormal data \r\n\"roleId2\": \"ROLEINFO#7001#21693#4002#4\",\r\nFault data\r\n\"roleId2\": \"com.game.logical.role.beans.OtherHeroBean@5300e72\",\r\n\"roleId2\": [10006,10001,10007,12001],\r\n\"roleId2\": [],\r\n\r\nAll of the places we assign are strings\r\n\r\nUnder what circumstances does this happen to the data or is it a bug that has been fixed? If so, in what version did you change those things\r\n\r\n我们有个数据是string  所有赋值的地方也是string  数据会莫名其妙变成对象 不知道是写的问题还是读的问题  取出错误数据后使用会造成jvm宕机 不是必现 有概率出现\r\n什么情况下数据会出现这种情况  还是这是个bug 已经修复  如果已经修复 是在哪个版本 修改了那些东西  \r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3363/comments",
    "author": "wl980868110",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-01-20T11:55:09Z",
        "body": "fstcodec is a binary codec"
      },
      {
        "user": "wl980868110",
        "created_at": "2021-01-20T13:48:56Z",
        "body": "I mean after the parsing"
      },
      {
        "user": "wl980868110",
        "created_at": "2021-01-20T16:39:51Z",
        "body": "I mean after deserialization"
      },
      {
        "user": "WolfHawk-GITHUB",
        "created_at": "2021-01-21T03:26:14Z",
        "body": "问题的意思是正常使用中。遇到下面的问题。\r\n正常数据格式。\"roleId2\": \"ROLEINFO#7001#21693#4002#4\"  不知道什么情况下。数据突然变成了\r\n\"roleId2\": \"com.game.logical.role.beans.OtherHeroBean@5300e72\",\r\n\"roleId2\": [10006,10001,10007,12001],\r\n\"roleId2\": [],\r\n这样的不可理解的格式。甚至变成了一个代码中的对象。正常使用不可能这样赋值。我也遇到过这样的问题。"
      },
      {
        "user": "WolfHawk-GITHUB",
        "created_at": "2021-01-21T03:32:58Z",
        "body": "public class CrossAllStarPopRankRedis extends BaseRedissonDbBean implements Serializable\r\n{\r\n\tprivate static final long serialVersionUID=1L;\r\n\t/** 活动id */\r\n\tprivate int activityId;\r\n\t/** 排行榜MAP */\r\n\tprivate Map<String,CrossAllStarCommonDataBean> rankMap=new ConcurrentHashMap<>();\r\n\t/** 队伍 排行榜MAP */\r\n\tprivate Map<String,CrossAllStarCommonDataBean> teamRankMap=new ConcurrentHashMap<>();\r\n}\r\npublic class CrossAllStarCommonDataBean implements Serializable\r\n{\r\n\tprivate static final long serialVersionUID=1L;\r\n\t/** 玩家信息主键 */\r\n\tprivate String roleKey;\r\n\t/** 积分 */\r\n\tprivate long score;\r\n\t/** 战斗 */\r\n\tprivate long battle;\r\n}\r\n\r\n比如redis数据CrossAllStarPopRankRedis 。其CrossAllStarCommonDataBean 中的roleKey就会出现上述情况。就是String的偶尔会出现，int，long不会。"
      },
      {
        "user": "mrniko",
        "created_at": "2021-01-21T07:23:02Z",
        "body": "Did you try to use another codec?"
      },
      {
        "user": "wl980868110",
        "created_at": "2021-01-21T07:26:21Z",
        "body": "no  .   We chose this encoder for performance consideration "
      },
      {
        "user": "mrniko",
        "created_at": "2021-01-21T07:35:21Z",
        "body": "I recommend to use MarshallingCodec which is default. FstCodec may cause errors during deserialization according to user reports."
      },
      {
        "user": "wl980868110",
        "created_at": "2021-01-21T08:08:43Z",
        "body": "redisson-all-3.4.1 use   fst 2.47 .   redisson-all-3.12.1 use   fst 2.57   .    fst  Version 2.57 reduced to  fst 2.47   Why was the version lowered  "
      },
      {
        "user": "mrniko",
        "created_at": "2021-02-03T08:09:46Z",
        "body": "version isn't reduced since 2.57 > 2.47"
      }
    ]
  },
  {
    "number": 3359,
    "title": "org.redisson.client.RedisTimeoutException: Command still hasn’t been written into connection!  Increase nettyThreads and/or retryInterval settings.",
    "created_at": "2021-01-20T07:25:28Z",
    "closed_at": "2021-01-26T06:47:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3359",
    "body": "Got this exception continuously for a minute and then became fine. Would like to know what is the root cause of this. \r\nUsing Redisson : 3.13.2\r\n\r\n\r\norg.redisson.client.RedisTimeoutException: Command still hasn’t been written into connection! \r\n Increase nettyThreads and/or retryInterval settings. \r\n Payload size in bytes: 0. Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry \r\n [masterEntry=[freeSubscribeConnectionsAmount=4, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=33, \r\n freeConnectionsCounter=value:62:queue:0, freezed=false, \r\n freezeReason=null, client=[addr=******], nodeType=MASTER, \r\n firstFail=0]]], connection: RedisConnection@145638153 \r\n [redisClient=[addr=******], channel=[id: 0x20213438, \r\n L:/10.20.13.18:45856 - R:*****], currentCommand=null], \r\n command: null, params: null after 3 retry attempts",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3359/comments",
    "author": "mraees",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-01-20T07:27:18Z",
        "body": "do use async/rx/reactive api?"
      },
      {
        "user": "mraees",
        "created_at": "2021-01-20T07:40:18Z",
        "body": "I do use \r\nfinal RBatch batchOperation = redissonClient.createBatch();\r\nbatchOperation.getAtomicLong(redisKey).incrementAndGetAsync(); -> this line is inside a for loop. This is an async API right!!"
      },
      {
        "user": "mrniko",
        "created_at": "2021-01-20T08:54:57Z",
        "body": "If you use blocking commands in async listeners this will cause such error."
      },
      {
        "user": "ShanmugamC",
        "created_at": "2021-04-24T17:01:11Z",
        "body": "@mrniko any workaround to avoid this issue for reactive api?\r\n\r\nI got this error for redis GET commands as well but used reactive."
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-24T17:26:16Z",
        "body": "@ShanmugamC \r\n\r\nCan you share code sample?"
      },
      {
        "user": "ShanmugamC",
        "created_at": "2021-04-24T17:49:25Z",
        "body": "Got below trace, i used FstCodec\r\n\r\nStack trace:\r\n\t\tat org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:208)\r\n\t\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672)\r\n\t\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747)\r\n\t\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472)\r\n\t\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\t\tat java.base/java.lang.Thread.run(Thread.java:832)"
      }
    ]
  },
  {
    "number": 3357,
    "title": "Redis Cluster master down and restart，redisson can‘t update cluster state",
    "created_at": "2021-01-20T02:59:05Z",
    "closed_at": "2021-01-28T13:17:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3357",
    "body": "**Expected behavior**\r\nredis cluster master down one by one.After a period of time, restart master node, redisson client can't update cluster state\r\n\r\n**Actual behavior**\r\nredisson can't write command to master, and report error.\r\n\r\n**Steps to reproduce or test case**\r\nIt doesn't have to happen\r\n**1.test case**\r\n    3 master and 3 slave\r\n1.   master 1 down and wait slave 1 become master\r\n2.   master 2 down and wait slave 2 become master\r\n3.   master 3 down and wait slave 3 become master\r\n4.  restart all master and There's a certain probability\r\n\r\n**2.redisson can't update cluster state exception**\r\n```java\r\nWriteRedisConnectionException: Unable to write command into connection! Node source: NodeSource [slot=9394, addr=null, redisClient=null, redirect=null, entry=null], connection:\r\n\tat org.redisson.command.RedisExecutor.checkWriteFuture(RedisExecutor.java:271) ~[redisson-3.14.0.jar:3.14.0]\r\n\tat org.redisson.command.RedisExecutor.access$100(RedisExecutor.java:58) ~[redisson-3.14.0.jar:3.14.0]\r\n\tat org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:156) ~[redisson-3.14.0.jar:3.14.0]\r\n\tat org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:153) ~[redisson-3.14.0.jar:3.14.0]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1009) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:870) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]\r\n\tat java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]\r\nCaused by: io.netty.channel.StacklessClosedChannelException\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]\r\n```\r\n\r\n**3. a redisson-netty thread is runnable and recursion all the time** \r\n```java\r\n\"redisson-netty-2-19\" #31 prio=5 os_prio=0 tid=0x00007fac4c03c800 nid=0x4cd5 runnable [0x00007fac9c511000]\r\n   java.lang.Thread.State: RUNNABLE\r\n\tat java.lang.Throwable.fillInStackTrace(Native Method)\r\n\tat java.lang.Throwable.fillInStackTrace(Throwable.java:783)\r\n\t- locked <0x00000000fbf21860> (a org.redisson.client.RedisConnectionException)\r\n\tat java.lang.Throwable.<init>(Throwable.java:265)\r\n\tat java.lang.Exception.<init>(Exception.java:66)\r\n\tat java.lang.RuntimeException.<init>(RuntimeException.java:62)\r\n\tat org.redisson.client.RedisException.<init>(RedisException.java:35)\r\n\tat org.redisson.client.RedisConnectionException.<init>(RedisConnectionException.java:28)\r\n\tat org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:218)\r\n\tat org.redisson.connection.pool.PubSubConnectionPool.get(PubSubConnectionPool.java:32)\r\n\tat org.redisson.connection.pool.PubSubConnectionPool.get(PubSubConnectionPool.java:39)\r\n\tat org.redisson.connection.balancer.LoadBalancerManager.nextPubSubConnection(LoadBalancerManager.java:204)\r\n\tat org.redisson.connection.MasterSlaveEntry.nextPubSubConnection(MasterSlaveEntry.java:519)\r\n\tat org.redisson.pubsub.PublishSubscribeService.nextPubSubConnection(PublishSubscribeService.java:267)\r\n\tat org.redisson.pubsub.PublishSubscribeService.connect(PublishSubscribeService.java:273)\r\n\tat org.redisson.pubsub.PublishSubscribeService.access$200(PublishSubscribeService.java:55)\r\n\tat org.redisson.pubsub.PublishSubscribeService$1.run(PublishSubscribeService.java:164)\r\n\tat org.redisson.pubsub.AsyncSemaphore.tryRun(AsyncSemaphore.java:86)\r\n\tat org.redisson.pubsub.AsyncSemaphore.acquire(AsyncSemaphore.java:66)\r\n\tat org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:150)\r\n\tat org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$0(PublishSubscribeService.java:127)\r\n\tat org.redisson.pubsub.PublishSubscribeService$$Lambda$68/1506703662.run(Unknown Source)\r\n\tat org.redisson.pubsub.AsyncSemaphore.tryRun(AsyncSemaphore.java:86)\r\n\tat org.redisson.pubsub.AsyncSemaphore.acquire(AsyncSemaphore.java:66)\r\n\tat org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:121)\r\n\tat org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:115)\r\n\tat org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:575)\r\n\tat org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$8(PublishSubscribeService.java:578)\r\n\tat org.redisson.pubsub.PublishSubscribeService$$Lambda$108/720202126.accept(Unknown Source)\r\n\tat org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)\r\n\tat org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)\r\n\tat io.netty.util.concurrent.DefaultPromise.access$200(DefaultPromise.java:35)\r\n\tat io.netty.util.concurrent.DefaultPromise$1.run(DefaultPromise.java:502)\r\n\tat io.netty.util.concurrent.ImmediateEventExecutor.execute(ImmediateEventExecutor.java:118)\r\n\tat io.netty.util.concurrent.DefaultPromise.safeExecute(DefaultPromise.java:842)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:499)\r\n\tat io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)\r\n\tat org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)\r\n\tat org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:576)\r\n\tat org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$8(PublishSubscribeService.java:578)\r\n\tat org.redisson.pubsub.PublishSubscribeService$$Lambda$108/720202126.accept(Unknown Source)\r\n\tat org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)\r\n\tat org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n\tat io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)\r\n\tat org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)\r\n\tat org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:576)\r\n\tat org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$8(PublishSubscribeService.java:578)\r\n\tat org.redisson.pubsub.PublishSubscribeService$$Lambda$108/720202126.accept(Unknown Source)\r\n\tat org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)\r\n\tat org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n\tat io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)\r\n\tat org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)\r\n\tat org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:576)\r\n\tat org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$8(PublishSubscribeService.java:578)\r\n\tat org.redisson.pubsub.PublishSubscribeService$$Lambda$108/720202126.accept(Unknown Source)\r\n\tat org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)\r\n\tat org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n\tat io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)\r\n\tat org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)\r\n\tat org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:576)\r\n\tat org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$8(PublishSubscribeService.java:578)\r\n\tat org.redisson.pubsub.PublishSubscribeService$$Lambda$108/720202126.accept(Unknown Source)\r\n\tat org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)\r\n\tat org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n\tat io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)\r\n\tat org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)\r\n\tat org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:576)\r\n\tat org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$8(PublishSubscribeService.java:578)\r\n\tat org.redisson.pubsub.PublishSubscribeService$$Lambda$108/720202126.accept(Unknown Source)\r\n\tat org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)\r\n\tat org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n\tat io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)\r\n\tat org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)\r\n\tat org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:576)\r\n\tat org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$8(PublishSubscribeService.java:578)\r\n\tat org.redisson.pubsub.PublishSubscribeService$$Lambda$108/720202126.accept(Unknown Source)\r\n\tat org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)\r\n\tat org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n\tat io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)\r\n\tat org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)\r\n\tat org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:576)\r\n\tat org.redisson.pubsub.PublishSubscribeService.lambda$reattachPubSubListeners$7(PublishSubscribeService.java:568)\r\n\tat org.redisson.pubsub.PublishSubscribeService$$Lambda$107/1175549604.accept(Unknown Source)\r\n\tat org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n\tat org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n\tat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n\tat io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)\r\n\tat io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n\tat org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n\tat org.redisson.pubsub.PublishSubscribeService$5$1$1.onStatus(PublishSubscribeService.java:430)\r\n\tat org.redisson.pubsub.PubSubConnectionEntry$1.onStatus(PubSubConnectionEntry.java:187)\r\n\tat org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:72)\r\n\tat org.redisson.client.RedisPubSubConnection$1.operationComplete(RedisPubSubConnection.java:116)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)\r\n\tat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)\r\n\tat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609)\r\n\tat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1009)\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:870)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764)\r\n\tat io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(Redefined)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)\r\n\tat io.netty.channel.nio.NioEventLoop.run(Redefined)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\n```\r\n**4.Redis version**\r\n6.0.9\r\n**5.Redisson version**\r\n3.14.1\r\n\r\n**6.Redisson configuration**\r\n```java\r\nclusterServersConfig:\r\n  idleConnectionTimeout: 60000\r\n  connectTimeout: 10000\r\n  timeout: 60000\r\n  retryAttempts: 3\r\n  retryInterval: 3000\r\n  failedSlaveReconnectionInterval: 3000\r\n  failedSlaveCheckInterval: 60000\r\n  password: \"xuanwu-T3st*17\"\r\n  subscriptionsPerConnection: 5\r\n  clientName: null\r\n  loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}\r\n  subscriptionConnectionMinimumIdleSize: 1\r\n  subscriptionConnectionPoolSize: 4\r\n  slaveConnectionMinimumIdleSize: 16\r\n  slaveConnectionPoolSize: 64\r\n  masterConnectionMinimumIdleSize: 16\r\n  masterConnectionPoolSize: 64\r\n  readMode: \"MASTER_SLAVE\"\r\n  subscriptionMode: \"SLAVE\"\r\n  nodeAddresses:\r\n    - \"redis://172.16.0.114:8001\"\r\n    - \"redis://172.16.0.114:8002\"\r\n    - \"redis://172.16.0.114:8003\"\r\n    - \"redis://172.16.0.115:8001\"\r\n    - \"redis://172.16.0.115:8002\"\r\n    - \"redis://172.16.0.115:8003\"\r\n  scanInterval: 2000\r\n  pingConnectionInterval: 5000\r\n  keepAlive: true\r\n  tcpNoDelay: true\r\ncodec: !<org.redisson.codec.JsonJacksonCodec> {}\r\ntransportMode: \"NIO\"\r\nuseScriptCache: true\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3357/comments",
    "author": "xiaowenyu",
    "comments": [
      {
        "user": "yusufdaud",
        "created_at": "2022-01-25T10:32:05Z",
        "body": "@xiaowenyu What was the solution"
      },
      {
        "user": "Chippyer",
        "created_at": "2022-09-14T01:59:29Z",
        "body": "@xiaowenyu Can you share the process"
      }
    ]
  },
  {
    "number": 3351,
    "title": "can i use redisson with spring cloud getway and webflux",
    "created_at": "2021-01-18T07:55:01Z",
    "closed_at": "2021-01-18T08:58:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3351",
    "body": "when i use redisson in spring cloud getway filter , \r\n```java\r\npublic class AuthenticationFilter implements GlobalFilter {\r\n    @Override\r\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\r\n        // authenticate token\r\n        RLock rLock = redissonClient.getLock(\"authenticate\");\r\n        try {\r\n            boolean res = rLock.tryLock(0, TimeUnit.SECONDS);\r\n            if(res) {\r\n                // get lock success\r\n                return chain.filter(exchange).then(Mono.fromRunnable(() -> {\r\n                    // unlock\r\n                    rLock.unlock();\r\n                    }));\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\nbut when i unlock this rLock report error log `not locked by current thread `, this rLock is not the same thread when i locked, how can i fix this problem",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3351/comments",
    "author": "418545106",
    "comments": [
      {
        "user": "418545106",
        "created_at": "2021-01-18T08:58:08Z",
        "body": "use `rLock.forceUnlock();` to fix this problem."
      },
      {
        "user": "mrniko",
        "created_at": "2021-01-18T09:40:33Z",
        "body": "You can use `RSemaphore` object instead."
      }
    ]
  },
  {
    "number": 3348,
    "title": "Redisson mapwriter",
    "created_at": "2021-01-17T07:22:51Z",
    "closed_at": "2021-01-25T10:59:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3348",
    "body": "I am using RMapCache<String,Object> with map option with write mode as WRITE_BEHIND \r\nnow when i put something in cache after particular delay it is getting executed after dealy provided,\r\nbut what i need is map writer should pick entry from map unless it is cache but it is not doing so it is only getting executed once.\r\n\r\nCan anyone help what can i do in this case or there is any alternative?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3348/comments",
    "author": "BhaveshPunjabi",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-01-17T09:29:29Z",
        "body": "MapWriter writes cache entry during put operation execution only."
      },
      {
        "user": "BhaveshPunjabi",
        "created_at": "2021-01-17T09:33:02Z",
        "body": "is there any alternative way in which i can loop my cache entry till the value is not getting evicted?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-01-20T06:44:44Z",
        "body": "I'm afraid no."
      }
    ]
  },
  {
    "number": 3345,
    "title": "about slave node down status",
    "created_at": "2021-01-15T08:12:19Z",
    "closed_at": "2021-03-25T08:53:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3345",
    "body": "flags field that “sentinel slaves xxx” command result contains “s_down” or “disconnected”, manager will freezed the node,\r\nbut master-link-status than “sentinel slaves xxx” command result is “err”, slave node is in “LOADING Redis is loading the dataset in memory” status, why not add this condition in slave node state check? just like \r\n```\r\nString ip = map.get(\"ip\");\r\nString port = map.get(\"port\");\r\nString flags = map.get(\"flags\");\r\nString masterHost = map.get(\"master-host\");\r\nString masterPort = map.get(\"master-port\");\r\nString masterLinkStatus = map.get(\"master-link-status\");\r\n\r\nRedisURI slaveAddr = toURI(ip, port);\r\nif (flags.contains(\"s_down\") || flags.contains(\"disconnected\") || masterLinkStatus.contains(\"err\")) {\r\n    slaveDown(slaveAddr);\r\n    continue;\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3345/comments",
    "author": "mikawudi",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-02-03T09:51:03Z",
        "body": "Can you suggest PR?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-03-25T08:53:18Z",
        "body": "merged"
      }
    ]
  },
  {
    "number": 3331,
    "title": "Problem with serialisation/deserialisation query cache for Hibernate Cache",
    "created_at": "2021-01-11T16:23:27Z",
    "closed_at": "2021-04-21T10:46:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3331",
    "body": "I am using:\r\n\r\n- redisson 3.14.1\r\n- hibernate 5.4.12\r\n\r\n\r\ncodec: **SnappyCodec**\r\nWhen I try to put query data to Redis I receive an error\r\n\r\n`Caused by: java.lang.IllegalArgumentException: java.io.NotSerializableException: org.hibernate.metamodel.model.convert.internal.JpaAttributeConverterImpl\r\n\tat org.redisson.command.CommandAsyncService.encodeMapKey(CommandAsyncService.java:727) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.RedissonObject.encodeMapKey(RedissonObject.java:297) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.RedissonMapCache.getOperationAsync(RedissonMapCache.java:524) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.RedissonMap.getAsync(RedissonMap.java:1072) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.RedissonMap.get(RedissonMap.java:618) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.hibernate.RedissonStorage.getFromCache(RedissonStorage.java:102) ~[redisson-hibernate-53-3.14.1.jar:3.14.1]\r\n\t... 136 common frames omitted\r\nCaused by: java.io.NotSerializableException: org.hibernate.metamodel.model.convert.internal.JpaAttributeConverterImpl\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:274) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteFields(RiverMarshaller.java:1143) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteSerializableObject(RiverMarshaller.java:1101) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:268) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteFields(RiverMarshaller.java:1143) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteSerializableObject(RiverMarshaller.java:1101) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteSerializableObject(RiverMarshaller.java:1080) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteSerializableObject(RiverMarshaller.java:1080) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:268) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteFields(RiverMarshaller.java:1143) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteSerializableObject(RiverMarshaller.java:1101) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:268) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.BlockMarshaller.doWriteObject(BlockMarshaller.java:65) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.BlockMarshaller.writeObject(BlockMarshaller.java:56) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.MarshallerObjectOutputStream.writeObjectOverride(MarshallerObjectOutputStream.java:50) ~[jboss-marshalling-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverObjectOutputStream.writeObjectOverride(RiverObjectOutputStream.java:179) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:344) ~[na:1.8.0_191]\r\n\tat java.util.HashMap.internalWriteEntries(HashMap.java:1790) ~[na:1.8.0_191]\r\n\tat java.util.HashMap.writeObject(HashMap.java:1363) ~[na:1.8.0_191]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_191]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_191]\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_191]\r\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_191]\r\n\tat org.jboss.marshalling.reflect.JDKSpecific$SerMethods.callWriteObject(JDKSpecific.java:163) ~[jboss-marshalling-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.reflect.SerializableClass.callWriteObject(SerializableClass.java:193) ~[jboss-marshalling-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteSerializableObject(RiverMarshaller.java:1089) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:268) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteFields(RiverMarshaller.java:1143) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteSerializableObject(RiverMarshaller.java:1101) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:268) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.AbstractObjectOutput.writeObject(AbstractObjectOutput.java:58) ~[jboss-marshalling-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.jboss.marshalling.AbstractMarshaller.writeObject(AbstractMarshaller.java:111) ~[jboss-marshalling-2.0.10.Final.jar:2.0.10.Final]\r\n\tat org.redisson.codec.MarshallingCodec$4.encode(MarshallingCodec.java:170) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.codec.SnappyCodec$4.encode(SnappyCodec.java:96) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.command.CommandAsyncService.encodeMapKey(CommandAsyncService.java:725) ~[redisson-3.14.1.jar:3.14.1]\r\n\t... 141 common frames omitted\r\nCaused by: org.jboss.marshalling.TraceInformation: null`\r\n\r\nThen I try to change the codec to **Kryo5Codec**\r\n`Caused by: com.esotericsoftware.kryo.KryoException: Class cannot be created (missing no-arg constructor): org.hibernate.cache.internal.QueryResultsCacheImpl$CacheItem\r\n\tat com.esotericsoftware.kryo.util.DefaultInstantiatorStrategy.newInstantiatorOf(DefaultInstantiatorStrategy.java:114) ~[kryo-5.0.3.jar:na]\r\n\tat com.esotericsoftware.kryo.Kryo.newInstantiator(Kryo.java:1119) ~[kryo-5.0.3.jar:na]\r\n\tat com.esotericsoftware.kryo.Kryo.newInstance(Kryo.java:1128) ~[kryo-5.0.3.jar:na]\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.create(FieldSerializer.java:153) ~[kryo-5.0.3.jar:na]\r\n\tat com.esotericsoftware.kryo.serializers.FieldSerializer.read(FieldSerializer.java:118) ~[kryo-5.0.3.jar:na]\r\n\tat com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:813) ~[kryo-5.0.3.jar:na]\r\n\tat org.redisson.codec.Kryo5Codec$4.decode(Kryo5Codec.java:95) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:356) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:178) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498) ~[netty-codec-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[netty-codec-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.45.Final.jar:4.1.45.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.45.Final.jar:4.1.45.Final]\r\n\t... 1 common frames omitted`\r\n\r\nWhat am I doing wrong?\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3331/comments",
    "author": "rhrytsiv",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-01-12T05:43:19Z",
        "body": "can you provide test code to reproduce it?"
      },
      {
        "user": "rhrytsiv",
        "created_at": "2021-01-12T09:15:31Z",
        "body": "Entity:\r\n\r\n`@Entity\r\n@Table(name = \"account_quota_messages\")\r\n@Getter\r\n@Setter\r\n@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)\r\npublic class AccountQuotaMessagesEntity extends BaseDateTrackingEntity {\r\n\r\n  @EmbeddedId private AccountQuotaMessagesKey id;\r\n\r\n  @Column(name = \"daily_messages_limit\", nullable = false)\r\n  private Integer dailyMessagesLimit;\r\n\r\n  @Column(name = \"monthly_messages_limit\", nullable = false)\r\n  private Integer monthlyMessagesLimit;\r\n}`\r\n\r\nEmbeddedId:\r\n\r\n`@Embeddable\r\n@Getter\r\n@Setter\r\n@EqualsAndHashCode\r\n@NoArgsConstructor\r\n@AllArgsConstructor\r\npublic class AccountQuotaMessagesKey implements Serializable {\r\n\r\n  @ManyToOne\r\n  @JoinColumn(name = \"account_id\", nullable = false)\r\n  private AccountEntity account;\r\n\r\n  @Column(name = \"message_channel_id\", nullable = false, columnDefinition = \"TINYINT\")\r\n  @Convert(converter = ChannelTypeConverter.class)\r\n  private ChannelType channelType;\r\n}`\r\n\r\nRepository:\r\n\r\n`  @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)\r\n  @QueryHints(@QueryHint(name = \"org.hibernate.cacheable\", value = \"true\"))\r\n  @Query(\r\n      \"SELECT aqm.monthlyMessagesLimit FROM AccountQuotaMessagesEntity aqm \"\r\n          + \"WHERE aqm.id.account.id = :accountId AND aqm.id.channelType = :channelType\")\r\n  Integer findAccountMonthlyMessagesLimitForChannelType(\r\n      @Param(\"accountId\") String accountId, @Param(\"channelType\") ChannelType channelType);`\r\n\r\nRedisson config:\r\n\r\n`public static Config createCacheConfig(Map<String, String> props) {\r\n    Config config = new Config();\r\n    config.setCodec(new SnappyCodec());\r\n\r\n    ReplicatedServersConfig replicatedServersConfig =\r\n        config\r\n            .useReplicatedServers()\r\n            // connection\r\n            .addNodeAddress(props.get(HOSTS).split(\",\"))\r\n            .setRetryAttempts(Integer.parseInt(props.get(CACHE_CONNECT_RETRIES)))\r\n            .setConnectTimeout(Integer.parseInt(props.get(CACHE_CONNECT_TIMEOUT)))\r\n            .setReadMode(ReadMode.MASTER_SLAVE)\r\n            // pools sizes\r\n            .setSlaveConnectionPoolSize(Integer.parseInt(props.get(CONNECTION_POOL_SIZE)))\r\n            .setSlaveConnectionMinimumIdleSize(\r\n                Integer.parseInt(props.get(CONNECTION_POOL_SIZE_IDLE)))\r\n            .setMasterConnectionPoolSize(Integer.parseInt(props.get(CONNECTION_POOL_SIZE)))\r\n            .setMasterConnectionMinimumIdleSize(\r\n                Integer.parseInt(props.get(CONNECTION_POOL_SIZE_IDLE)))\r\n            // subscription pools sizes\r\n            .setSubscriptionConnectionPoolSize(Integer.parseInt(props.get(SUBSCRIPTION_POOL_SIZE)))\r\n            .setSubscriptionConnectionMinimumIdleSize(\r\n                Integer.parseInt(props.get(SUBSCRIPTION_POOL_SIZE_IDLE)))\r\n            .setSubscriptionsPerConnection(\r\n                Integer.parseInt(props.get(SUBSCRIPTION_PER_CONNECTION)));\r\n    return config;\r\n  }`\r\n\r\n\r\nChannelType is enumeration "
      },
      {
        "user": "mrniko",
        "created_at": "2021-01-15T14:32:54Z",
        "body": "try to implement query without repository method."
      },
      {
        "user": "ivan-zaitsev",
        "created_at": "2021-02-01T15:35:29Z",
        "body": "When I want to pass **Instant** to a method attribute I got the same exception (Caused by: java.lang.IllegalArgumentException: java.io.NotSerializableException: org.hibernate.metamodel.model.convert.internal.JpaAttributeConverterImpl)\r\n\r\nQuery example: \r\n\r\n@QueryHints({ @QueryHint(name = CACHEABLE, value = \"true\") }) \r\nEntity findByIdAndExpirationDate(Long id, **Instant** expirationDate);\r\n\r\nIt works without the **Instant** attribute. In the database, the expirationDate type is **timestamp**. "
      },
      {
        "user": "mrniko",
        "created_at": "2021-02-01T15:42:31Z",
        "body": "let me check that"
      },
      {
        "user": "ivan-zaitsev",
        "created_at": "2021-02-01T18:59:12Z",
        "body": "The error is reproduced only with this converter, without it everything works.\r\n\r\n```\r\n@Converter(autoApply = true)\r\npublic class InstantConverter implements AttributeConverter<Instant, Timestamp> {\r\n\r\n    @Override\r\n    public Timestamp convertToDatabaseColumn(Instant instant) {\r\n        return instant != null ? Timestamp.from(instant) : null;\r\n    }\r\n\r\n    @Override\r\n    public Instant convertToEntityAttribute(Timestamp timestamp) {\r\n        return timestamp != null ? timestamp.toInstant() : null;\r\n    }\r\n\r\n}\r\n```"
      },
      {
        "user": "ivan-zaitsev",
        "created_at": "2021-02-02T06:14:03Z",
        "body": "I guess redisson does not support `AttributeConverter`"
      },
      {
        "user": "mrniko",
        "created_at": "2021-02-11T09:30:45Z",
        "body": "It's a hibernate bug because it doesn't work even with `CachingRegionFactory.class` cache provider."
      },
      {
        "user": "mrniko",
        "created_at": "2021-02-11T10:07:03Z",
        "body": "@ivan909020 \r\n\r\nDoes it work with `CachingRegionFactory.class` ?"
      }
    ]
  },
  {
    "number": 3323,
    "title": "RedissonMultiLock#tryLock  The difference between leasetime and newLeasetime",
    "created_at": "2021-01-05T04:18:04Z",
    "closed_at": "2021-01-31T09:39:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3323",
    "body": "org.redisson.RedissonMultiLock#tryLock(long, long, java.util.concurrent.TimeUnit)\r\n\r\nIn this method, both waittime and leasetime are specified. That is to say, the leasetime and waittime of the input parameter are not equal to - 1. When locking, newleasetime is used, which is twice as much as waittime. Why not use the leasetime in the input parameter\r\n\r\nversion：org.redisson:redisson:3.13.2",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3323/comments",
    "author": "mapy95",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-01-31T09:39:09Z",
        "body": "waitTime applied only to acquire lock and not connected with leaseTime parameter, which applied only when lock was acquired."
      }
    ]
  },
  {
    "number": 3310,
    "title": "How to optimize slow queries by Redisson RSet.readAll() ?",
    "created_at": "2020-12-26T09:25:33Z",
    "closed_at": "2021-01-15T08:27:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3310",
    "body": "Hi,\r\n\r\n    Recently, I used Redission RSet to save Object Collections (size from 10,000 to 40,000). When I used readAll() action to fetch all of objects in the set, it caused a lot of slow queries(cost over 100,000 microseconds).\r\n\r\n    I know that storing too many objects, and that too long a key can be a performance drop, so I'd love to know how I can store so many objects and read them all efficiently with Redisson. \r\n\r\nThanks~\r\n\r\n**Object Example:**\r\n```java\r\npublic class DataDTO implements Serializable {\r\n    private String data;\r\n    private String datas;\r\n    private String label;\r\n    private Long posNum;\r\n    private Long negNum;\r\n    private Integer dataLength;\r\n    private Integer posFreq;\r\n    private Integer negFreq;\r\n    private Long totalCountNum;\r\n    private Long tgi;\r\n}\r\n```\r\n\r\n**RSet Example:**\r\n```java\r\nRSet<DataDTO> dataSet =   redissonClient.getSet(CacheName);\r\n//when I store a list of obecjts (size over 100,000)\r\ndataSet.addAll( dataList);\r\n\r\n//when I read all of the objects\r\ndataSet.readAll();\r\n```\r\n\r\n**Redis connection properties:**\r\n```java\r\n            Config config = new Config();\r\n            config.setThreads(0);\r\n            config.setNettyThreads(0);\r\n            config.setCodec(new FastjsonCodec());\r\n            config.setTransportMode(TransportMode.NIO);\r\n\r\n            String node = redisProperties.getSingle().getAddress();\r\n            node = node.startsWith(\"redis://\") ? node : \"redis://\" + node;\r\n            SingleServerConfig serverConfig = config.useSingleServer()\r\n                    .setDatabase(0)\r\n                    .setAddress(node)\r\n                    .setTimeout(5000)\r\n                    .setConnectionPoolSize(64)\r\n                    .setConnectionMinimumIdleSize(32)           \r\n                    .setSubscriptionConnectionMinimumIdleSize(1)\r\n                    .setSubscriptionConnectionPoolSize(50)\r\n                    .setSubscriptionsPerConnection(5)\r\n                    .setConnectTimeout(10000)\r\n                    .setRetryAttempts(3)\r\n                    .setRetryInterval(1500)\r\n                    .setIdleConnectionTimeout(10000);\r\n```\r\n**Redis Condition:** \r\nsingle model\r\n\r\n**Redisson Version:**\r\n3.10.2",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3310/comments",
    "author": "CzyerChen",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-12-29T05:58:42Z",
        "body": "try to use org.redisson.api.RSet#iterator(int) method. This method allows to adjust batch size loaded per Redis request."
      },
      {
        "user": "CzyerChen",
        "created_at": "2020-12-30T02:18:24Z",
        "body": "Thank you so much for your feedback!\r\nBut I tried again, not shortened the query duration.\r\n\r\n**Firstly, I saved 40,000 dtos into RSet**\r\n```java\r\n        RSet<DataDTO> datas = cacheService.getTaskResultSet(\"xxxx\");\r\n        List<DataDTO> list = new ArrayList<>();\r\n        for(int i =0 ;i<40000;i++){\r\n            DataDTO dto = new DataDTO();\r\n            dto.setData(\"aaa\"+i);\r\n            dto.setLabel(\"bbb\"+i);\r\n            dto.setPosNum((long) i);\r\n            dto.setNegNum((long)i -1);\r\n            dto.setTgi((long)(i/10));\r\n            dto.setTotalCountNum((long)(i+2000));\r\n           list.add(dto);\r\n        }\r\n        datas.addAll(list);\r\n    }\r\n```\r\n\r\n**Secondly, I tried readAll() command**\r\n```\r\n RSet<DataDTO> datas = cacheService.getTaskResultSet(\"xxxx\");\r\n Set<DataDTO> dataDTOS = set.readAll();\r\n\r\n// It cost 3.5s to get the results from redis\r\n// the redis slowlog report below:\r\n 5)    1)   \"2\"\r\n  2)   \"1609293239\"\r\n  3)   \"37900\"\r\n  4)      1)    \"SMEMBERS\"\r\n   2)    \"task.result.xxxx\"\r\n```\r\n\r\n**Thirdly, I tried iterator(count) command**\r\n```\r\n RSet<DataDTO> datas = cacheService.getTaskResultSet(\"xxxx\");\r\n\r\nList<DataDTO>list = new ArrayList<>();\r\n        if(!set.isEmpty()) {\r\n            Iterator<DataDTO> iterator = set.iterator(10000);\r\n            while (iterator.hasNext()) {\r\n                iterator.forEachRemaining(list::add);\r\n            }\r\n        }\r\nSystem.out.println(list.size());\r\n\r\n// It cost 3.4s to get the results from redis\r\n// the redis slowlog report below:\r\n\r\n1)    1)   \"6\"\r\n  2)   \"1609293349\"\r\n  3)   \"17576\"\r\n  4)      1)    \"SSCAN\"\r\n   2)    \"task.result.xxxx\"\r\n   3)    \"24781\"\r\n   4)    \"COUNT\"\r\n   5)    \"10000\"\r\n\r\n 2)    1)   \"5\"\r\n  2)   \"1609293348\"\r\n  3)   \"15994\"\r\n  4)      1)    \"SSCAN\"\r\n   2)    \"task.result.xxxx\"\r\n   3)    \"18670\"\r\n   4)    \"COUNT\"\r\n   5)    \"10000\"\r\n\r\n 3)    1)   \"4\"\r\n  2)   \"1609293347\"\r\n  3)   \"17423\"\r\n  4)      1)    \"SSCAN\"\r\n   2)    \"task.result.xxxx\"\r\n   3)    \"18268\"\r\n   4)    \"COUNT\"\r\n   5)    \"10000\"\r\n\r\n\r\n 4)    1)   \"3\"\r\n  2)   \"1609293346\"\r\n  3)   \"25773\"\r\n  4)      1)    \"SSCAN\"\r\n   2)    \"task.result.xxxx\"\r\n   3)    \"0\"\r\n   4)    \"COUNT\"\r\n   5)    \"10000\"\r\n\r\n```\r\n\r\nThen, I shortened the batch size for 5000, 1000, and I got time cost for 3.4s, 3.7s. Obviously, the total time cost did not improved so much(just got less slow queries). So, Is there any suggestions I can improve my query for total contents from Redis, or change my storage components?\r\n\r\nThanks~"
      },
      {
        "user": "mrniko",
        "created_at": "2020-12-30T06:45:32Z",
        "body": "did you try to use compression codec like SnappyCodecV2?"
      },
      {
        "user": "CzyerChen",
        "created_at": "2020-12-30T08:15:51Z",
        "body": "Hi~ the configuration is below:\r\n```java\r\nConfig config = new Config();\r\n            config.setThreads(0);\r\n            config.setNettyThreads(0);\r\n            config.setCodec(new FastjsonCodec());  //codec is here\r\n            config.setTransportMode(TransportMode.NIO);\r\n```"
      }
    ]
  },
  {
    "number": 3309,
    "title": "Unable to send PING command over channel   ClosedChannelException",
    "created_at": "2020-12-23T07:03:55Z",
    "closed_at": "2021-01-04T09:59:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3309",
    "body": "\r\nversion:3.14.0\r\n\r\n    @Bean(destroyMethod = \"shutdown\")\r\n    @ConditionalOnMissingBean\r\n    RedissonClient redissonClient() throws Exception {\r\n        Config config = new Config();\r\n        config.useClusterServers()\r\n                .setScanInterval(2000)\r\n                .setPassword(redissonConfig.getPassword())\r\n                .addNodeAddress(redissonConfig.getCluster().getNodes())\r\n        ;\r\n        Codec codec=(Codec) ClassUtils.forName(redissonConfig.getCodec(),ClassUtils.getDefaultClassLoader()).newInstance();\r\n        config.setCodec(codec);\r\n        config.setEventLoopGroup(new NioEventLoopGroup());\r\n        return Redisson.create(config);\r\n    }\r\n\r\nCluster\r\n\r\n\r\n```\r\n2020-12-23 15:01:25.787 ERROR 84897 --- [isson-timer-4-1] o.r.c.handler.PingConnectionHandler      : Unable to send PING command over channel: [id: 0x4f80e738, L:/10.8.0.218:53174 ! R:/10.10.48.62:6385]\r\n\r\njava.nio.channels.ClosedChannelException: null\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.newClosedChannelException(AbstractChannel.java:957) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:865) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-all-4.1.49.Final.jar:4.1.49.Final]\r\n\tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_261]\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3309/comments",
    "author": "yjjn",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-12-23T08:52:45Z",
        "body": "> java.nio.channels.ClosedChannelException\r\n\r\nCheck your network"
      },
      {
        "user": "yjjn",
        "created_at": "2020-12-24T01:47:45Z",
        "body": "Successful operation of redis\r\nconsole print Unable to send PING command over channel"
      }
    ]
  },
  {
    "number": 3304,
    "title": "Why does the first IP of the cluster automatically change to the intranet IP?",
    "created_at": "2020-12-22T02:34:40Z",
    "closed_at": "2020-12-28T07:13:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3304",
    "body": "This is my configration file\r\n```yml\r\nspring:\r\n  redis:\r\n    timeout: 10000\r\n    cluster:\r\n      nodes:\r\n        - 120.79.8.153:7000\r\n        - 120.79.8.153:7001\r\n        - 120.79.8.153:7002\r\n        - 120.79.8.153:7003\r\n        - 120.79.8.153:7004\r\n        - 120.79.8.153:7005\r\n```\r\nThis is my log. note that the ip of port 7000 has changed,\r\n```log\r\na0eb8a93e3ce9a3ac2d15c73a9d8c3bf7064904d 120.79.8.153:7002@17002 master - 0 1608603104000 3 connected 10923-16383\r\ndfc494ff70a7b10af271a8e132899c47e771fecc 120.79.8.153:7004@17004 slave 20e35d1e53f766ae93a7158f5e8ff4ac379ef8a0 0 1608603105000 1 connected\r\n422579dc30a3aa20cc2cc2e119f893691dcfdca7 120.79.8.153:7005@17005 slave 645a4f040a4bb12b91aa52c23373c4b5acc7c84b 0 1608603105945 2 connected\r\n20e35d1e53f766ae93a7158f5e8ff4ac379ef8a0 172.18.40.70:7000@17000 myself,master - 0 1608603106000 1 connected 0-5460\r\nc295c0f4b6bac3cc3b883e73dd53826cb9a48204 120.79.8.153:7003@17003 slave a0eb8a93e3ce9a3ac2d15c73a9d8c3bf7064904d 0 1608603104944 3 connected\r\n645a4f040a4bb12b91aa52c23373c4b5acc7c84b 120.79.8.153:7001@17001 master - 0 1608603106947 2 connected 5461-10922\r\n```\r\nWhen I test the code on my computer, I always get an error: Can't connect to master: redis://172.18.40.70:7000 with slot ranges: [[0-5460]]",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3304/comments",
    "author": "HeyChiang",
    "comments": [
      {
        "user": "HeyChiang",
        "created_at": "2020-12-22T07:07:50Z",
        "body": "Hello，Is anybody here?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-12-22T08:12:45Z",
        "body": "because you have this ip in cluster configuration 172.18.40.70. Check your Redis cluster config"
      },
      {
        "user": "HeyChiang",
        "created_at": "2020-12-22T08:55:17Z",
        "body": "you're right. \r\n\r\nWhen I used `redis-cli --cluster create`, it automatically changed the server's external network ip to internal network ip.\r\n\r\nIt's strange."
      },
      {
        "user": "Ljia-ncu",
        "created_at": "2020-12-27T15:10:08Z",
        "body": "just replace the intranet ip within nodes.conf of all nodes with the public ip.\r\ne.g.\r\nsed -i 's/172.18.40.70/120.79.8.153/g' /node-${port}/data/nodes.conf"
      }
    ]
  },
  {
    "number": 3301,
    "title": "First call to RMapCache get() 10 times slower than subsequent calls why?",
    "created_at": "2020-12-20T00:11:01Z",
    "closed_at": "2021-01-19T08:38:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3301",
    "body": "Trying to understand the slow performance of get(). I run a test program:\r\n\r\n        RMapCache<String, RedisUserData> userMap = redisson.getMapCache(\"userMap\");\r\n\r\n        int NUM_USERS = 10;\r\n\r\n        for(int i=0; i<NUM_USERS; i++) {\r\n\r\n            Instant start = Instant.now();\r\n            RedisUserData userData = userMap.get(\"userABC\");\r\n            Instant end = Instant.now();\r\n\r\n            System.out.println(Duration.between(start, end).toNanos()/1e6 +\r\n                \" millis/user\");\r\n\r\n            Thread.sleep(10000);\r\n        }\r\n\r\nThe output is:\r\n\r\n7.7 millis/user\r\n0.7 millis/user\r\n0.5 millis/user\r\n0.2 millis/user\r\n0.2 millis/user\r\n0.3 millis/user\r\n0.4 millis/user\r\n0.2 millis/user\r\n0.4 millis/user\r\n0.1 millis/user\r\n\r\nWhat is happening on the first call that isn't happening afterwards?\r\n\r\nMany thanks for your help.\r\n\r\n\r\nWHat is happening \r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3301/comments",
    "author": "fotherda71",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-01-13T11:00:53Z",
        "body": "which codec do you use?"
      }
    ]
  },
  {
    "number": 3288,
    "title": "how to manual change read mode at redis cluster",
    "created_at": "2020-12-12T14:06:58Z",
    "closed_at": "2020-12-29T06:00:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3288",
    "body": "I have some high loading action, I hope it can run at SLAVE nodes, and other action at MATER nodes.\r\nex：\r\nscan key by pattern and mget value by keys at SLAVE nodes.\r\nnormal get and set at MASTER nodes\r\nhow to assign nodes when I use some high loading action？",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3288/comments",
    "author": "poolqa",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-12-29T06:00:56Z",
        "body": "the only solution is to create two Redisson instances with shared `eventLoopGroup` and `executor` objects."
      }
    ]
  },
  {
    "number": 3287,
    "title": "Why does it take RLock nearly 1 second to get the lock?",
    "created_at": "2020-12-11T08:21:26Z",
    "closed_at": "2021-02-06T10:43:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3287",
    "body": "There are only 10 redission client connected to the redis server, no more than 4 threads competing for the lock.\r\nIt is weird that my redis server cpu and memory usage is no more than 10%.\r\nMy redisson version is 3.12.5.\r\nIs there any one knows the reason?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3287/comments",
    "author": "popgo-mos",
    "comments": [
      {
        "user": "merzMario",
        "created_at": "2020-12-11T23:27:47Z",
        "body": "Show your configurations\n\n发自我的iPhone\n\n> 在 2020年12月11日，下午4:22，popgo-mos <notifications@github.com> 写道：\n> \n> ﻿\n> There are only 10 redission client connected to the redis server, no more than 4 threads competing for the lock.\n> It is weird that my redis server cpu and memory usage is no more than 10%.\n> My redisson version is 3.12.5.\n> Is there any one knows the reason?\n> \n> —\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n"
      },
      {
        "user": "popgo-mos",
        "created_at": "2020-12-13T23:55:03Z",
        "body": "        Config config = new Config();\r\n        config.useSingleServer().setAddress(nodeAddress)\r\n                .setPassword(password).setDatabase(database);\r\n        config.setCodec(new FstCodec());\r\n        redissonClient = Redisson.create(config);\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2021-02-15T12:43:36Z",
        "body": "update to 3.13.1+ version"
      }
    ]
  },
  {
    "number": 3284,
    "title": "Using external EventLoopGroup with the Blocking API",
    "created_at": "2020-12-10T18:22:59Z",
    "closed_at": "2020-12-16T10:27:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3284",
    "body": "I'm using Redisson RBLoomFilter  over Vert.x and I need to call the contains method, which is blocking (i didn't find any async option)\r\nIs it possible to use Vert.x Netty EventLoopGroup instead of Redisson Netty threads without blocking the eventloop?\r\nThe blocking nature of the contains method blocks netty threads? or is it using a different thread pool for blocking operations?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3284/comments",
    "author": "shaharoliver",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-12-16T06:58:53Z",
        "body": "> Is it possible to use Vert.x Netty EventLoopGroup instead of Redisson Netty threads without blocking the eventloop?\r\n\r\nIt's hard to say, I have never done this.\r\n\r\nnetty threads aren't blocked by Redisson."
      },
      {
        "user": "shaharoliver",
        "created_at": "2020-12-16T10:26:01Z",
        "body": "> > Is it possible to use Vert.x Netty EventLoopGroup instead of Redisson Netty threads without blocking the eventloop?\r\n> \r\n> It's hard to say, I have never done this.\r\n> \r\n> netty threads aren't blocked by Redisson.\r\n\r\nthanks,\r\nit's possible with \r\n`        Config config = new Config();\r\n        config.setEventLoopGroup(vertx.nettyEventLoopGroup())\r\n`"
      }
    ]
  },
  {
    "number": 3280,
    "title": "After immediate put call get method returned null",
    "created_at": "2020-12-10T06:08:30Z",
    "closed_at": "2020-12-10T06:38:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3280",
    "body": "We are using Rmap/RadissonMap , and use fastPut method to put key in cache and immediately after this method call ,Call get method and that return some time null and some time working fine please suggest solution for this issue.\r\n\r\nMy redis is in master-slave architecture with sentinel.\r\nRedisson client configure as sentinel configurations so my understanding all the put should used master node of redis and all get should use slaves.\r\n\r\nTotal request=5371\r\nNull return=155\r\nvalue return=5216 ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3280/comments",
    "author": "ankitsingh95",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-12-10T06:38:29Z",
        "body": "this happens due to sync lag between master and slave. Try to use readMode = MASTER or speedup your Redis/Network."
      },
      {
        "user": "ankitsingh95",
        "created_at": "2020-12-10T07:52:48Z",
        "body": "Any put method available that return sync status between master and slave "
      }
    ]
  },
  {
    "number": 3276,
    "title": "redis-clusters mode with one master node crashed , why redisson client still connect the crashed node?",
    "created_at": "2020-12-09T12:06:56Z",
    "closed_at": "2020-12-10T08:39:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3276",
    "body": "hi , \r\n  i want to use redis-cluster and client is redisson, i ran test case as follow:\r\n   step 1: run the test code;\r\n   step 2: during the loop , i killed one master node (192.168.199.142:8001) .\r\n\r\n   on console log : there still has command set request to  192.168.199.142:8001 node and continuous attempt try output ,  is that right or reasonable? thks.\r\n or how can i do to avoid the request to 8001 node?\r\n \r\nrelated version:\r\nredis : 4.0.5\r\nredisson: 3.10.6\r\n\r\ncode as follows:\r\n```\r\n    private static  RedissonClient redissonClient = null;\r\n    public static void main(String[] args) throws IOException {\r\n        // connects to 127.0.0.1:6379 by default\r\n        /**\r\n         * 192.168.199.142:8004 slave\r\n         * 192.168.199.142:8005 slave\r\n         * 192.168.199.142:8006 slave\r\n         * 192.168.199.142:8003 master\r\n         * 192.168.199.142:8002 master\r\n         * 192.168.199.142:8001 master\r\n         */\r\n        loadRedissionClient();\r\n        for (int i = 0; i < times_10W; i++) {\r\n            try{\r\n                RBucket rBucket = redissonClient.getBucket(String.valueOf(i));\r\n                rBucket.set(format()+ \"_value_%test&%||||%___\"+ i);\r\n                System.out.println(rBucket.get());\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void loadRedissionClient() {\r\n        Config config = new Config();\r\n        config.useClusterServers()\r\n                .setScanInterval(2000)\r\n                .setConnectTimeout(2000)\r\n                .setTimeout(2000)\r\n                .setConnectTimeout(2000)\r\n                .addNodeAddress(\"redis://192.168.199.142:8001\", \"redis://192.168.199.142:8002\",\"redis://192.168.199.142:8003\",\r\n                        \"redis://192.168.199.142:8004\", \"redis://192.168.199.142:8005\",\"redis://192.168.199.142:8006\");\r\n        redissonClient = Redisson.create(config);\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3276/comments",
    "author": "xiari",
    "comments": [
      {
        "user": "yinghuzhu",
        "created_at": "2020-12-10T01:47:33Z",
        "body": "I have the same issue"
      },
      {
        "user": "xiari",
        "created_at": "2020-12-10T08:38:57Z",
        "body": "upate to version:   <version>3.14.0</version> \r\nfixed."
      }
    ]
  },
  {
    "number": 3275,
    "title": "Can I get and update an object in an RBatch operation?",
    "created_at": "2020-12-09T03:40:09Z",
    "closed_at": "2020-12-10T06:31:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3275",
    "body": "Apologies if this has been asked before, or if this is the wrong forum for this kind of question.\r\n\r\nI'd like to update the timestamp field of a java object in an RBucket, keeping the object's other fields as-is.\r\n\r\nCan I do this in the context of an RBatch?  It's not super clear from the documentation I've found - I can't tell whether batching only supports pipelining a bunch of writes, or if it can do reads and then writes based on the results of those reads in a single batch operation.\r\n\r\npseudocode for what I'm trying to do:\r\n\r\nval batch = redis.client.createBatch()\r\nval bucket = batch.getBucket<MyStruct>(mykey)\r\nval struct = bucket.async.get() ?: createMyStruct(params)\r\nstruct.lastUpdated = System.currentTimeMillis()\r\nbucket.setAsync(struct)\r\nif (expireKeys) bucket.expireAsync(24, TimeUnit.HOURS)\r\nbatch.executeAsync()\r\n\r\nI'm not sure if the batch will wait for the result of the read before updating it and performing the write.\r\n\r\nIf this isn't the right way to do it, should I just perform a synchronous get followed by an async update?  Thank you.\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3275/comments",
    "author": "steveyegge",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-12-10T06:31:42Z",
        "body": "RBatch can do both read and writes but it's impossible to execute operation depending on read result in the same batch."
      }
    ]
  },
  {
    "number": 3273,
    "title": "Unable to send PING command over channel: [id: 0xcffcc397, L:/10.16.18.65:57542 ! R:/10.18.8.156:6380]",
    "created_at": "2020-12-08T14:35:41Z",
    "closed_at": "2020-12-21T14:41:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3273",
    "body": "[order-center:10.16.18.65:7003]>>2020-12-07 20:32:31.073>>ERROR>>18357>>[redisson-timer-4-1]>>org.redisson.client.handler.PingConnectionHandler$1:89 -> Unable to send PING command over channel: [id: 0x09d44210, L:/10.16.18.65:57558 ! R:/10.18.8.156:6380]\r\n\r\nio.netty.channel.StacklessClosedChannelException: null\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source)\r\n\r\n[order-center:10.16.18.65:7003]>>2020-12-07 20:32:31.073>>ERROR>>18357>>[redisson-timer-4-1]>>org.redisson.client.handler.PingConnectionHandler$1:89 -> Unable to send PING command over channel: [id: 0x1747256d, L:/10.16.18.65:57526 ! R:/10.18.8.156:6380]\r\n\r\nio.netty.channel.StacklessClosedChannelException: null\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source)\r\n\r\n[order-center:10.16.18.65:7003]>>2020-12-07 20:32:31.073>>ERROR>>18357>>[redisson-timer-4-1]>>org.redisson.client.handler.PingConnectionHandler$1:89 -> Unable to send PING command over channel: [id: 0x35b04a5a, L:/10.16.18.65:57540 ! R:/10.18.8.156:6380]\r\n\r\nio.netty.channel.StacklessClosedChannelException: null\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3273/comments",
    "author": "dhlsoft",
    "comments": [
      {
        "user": "dhlsoft",
        "created_at": "2020-12-08T14:37:33Z",
        "body": "using 3.14.0"
      },
      {
        "user": "mrniko",
        "created_at": "2020-12-09T08:48:33Z",
        "body": "StacklessClosedChannelException - channel is closed"
      },
      {
        "user": "dhlsoft",
        "created_at": "2020-12-10T04:35:52Z",
        "body": "> StacklessClosedChannelException - channel is closed\r\n\r\nHow to avoid this problem ?   pingConnectionInterval: 0？\r\n\r\npingConnectionInterval=0\r\norg.redisson.client.RedisTimeoutException: Command execution timeout for command: (CLUSTER NODES), params: [], Redis client: [addr=redis://10.18.8.157:6380]"
      },
      {
        "user": "pouyakhoshkhoo",
        "created_at": "2020-12-14T17:02:01Z",
        "body": "I've got the same problem.  Changing pingConnectionInterval to 10 seconds will resolve the error. I wonder why this error happens in the first place. "
      },
      {
        "user": "danielgatis-mb",
        "created_at": "2021-01-06T16:32:34Z",
        "body": "Same here using 3.14.1. Why this error happens? The default timeout already is 30s.\r\n \r\n```\r\n    /**\r\n     * Defines PING command sending interval per connection to Redis.\r\n     * <code>0</code> means disable.\r\n     * <p>\r\n     * Default is <code>30000</code>\r\n     * \r\n     * @param pingConnectionInterval - time in milliseconds\r\n     * @return config\r\n     */\r\n    public T setPingConnectionInterval(int pingConnectionInterval) {\r\n        this.pingConnectionInterval = pingConnectionInterval;\r\n        return (T) this;\r\n    }\r\n```\r\n\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2021-01-06T17:51:02Z",
        "body": "@danielgatis-mb \r\n\r\n> Changing pingConnectionInterval to 10 seconds will resolve the error\r\n\r\nDid you try to set it to 10 ? "
      },
      {
        "user": "wedtlcy",
        "created_at": "2021-07-15T08:40:43Z",
        "body": "一定要将其设置为 10 ？我设置15还是有这个错"
      },
      {
        "user": "zhengquan45",
        "created_at": "2022-10-25T05:51:16Z",
        "body": "Why set it 10 seconds，can work？"
      },
      {
        "user": "shiranyosef1",
        "created_at": "2023-02-27T06:39:55Z",
        "body": "`pingConnectionInterval` already set for me to 1000, why is it still happening?  @mrniko \r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2023-02-28T13:33:21Z",
        "body": "@shiranyosef1 \r\n\r\nthe root cause is StacklessClosedChannelException - channel is closed. You need to check your network."
      },
      {
        "user": "shiranyosef1",
        "created_at": "2023-02-28T13:40:02Z",
        "body": "@mrniko The network seems ok, we are working with AWS Elasticache. Is that common?\r\nhow would you suggest debugging this? "
      },
      {
        "user": "mrniko",
        "created_at": "2023-02-28T16:54:02Z",
        "body": "@shiranyosef1 \r\n\r\ntry to reduce connections amount."
      }
    ]
  },
  {
    "number": 3268,
    "title": "Print the SearchDomainUnknownHostException repeatedly when connected to redis sentinel cluster on the Kubernetes",
    "created_at": "2020-12-07T14:59:53Z",
    "closed_at": "2021-01-03T16:04:48Z",
    "labels": [
      "question",
      "dns"
    ],
    "url": "https://github.com/redisson/redisson/issues/3268",
    "body": "When I use redission 3.13.6 to connect to the redis sentinel cluster on the kubernetes,it will print following logs every few seconds.The address of cluster is redis-cluster:26379 which is the servername on kubernetes. But when I change the address to its IP address which is 172.30.49.77:26379,the error is missing.How to resovle this problem when use servicename address.\r\n\r\n2020-12-07 21:45:02,655 INFO  [metrics-infra-ewell] [nioEventLoopGroup-5-4] [o.r.c.SentinelConnectionManager:558] - trace[] sentinel: redis://172.30.49.77:26379 added\r\n2020-12-07 21:45:03,588 WARN  [metrics-infra-ewell] [nioEventLoopGroup-5-2] [o.r.c.SentinelConnectionManager:501] - trace[] sentinel: redis://172.30.151.185:26379 is down\r\n2020-12-07 21:45:04,599 WARN  [metrics-infra-ewell] [nioEventLoopGroup-5-2] [o.r.c.SentinelConnectionManager:501] - trace[] sentinel: redis://172.30.49.77:26379 is down\r\n2020-12-07 21:45:04,604 INFO  [metrics-infra-ewell] [nioEventLoopGroup-5-2] [o.r.c.SentinelConnectionManager:558] - trace[] sentinel: redis://172.30.151.185:26379 added\r\n2020-12-07 21:45:05,886 ERROR [metrics-infra-ewell] [nioEventLoopGroup-2-2] [o.r.c.SentinelConnectionManager:285] - trace[] Unable to resolve redis-cluster\r\nio.netty.resolver.dns.DnsResolveContext$SearchDomainUnknownHostException: Search domain query failed. Original hostname: 'redis-cluster' failed to resolve 'redis-cluster.devcommon.svc.cluster.local'\r\n\tat io.netty.resolver.dns.DnsResolveContext.finishResolve(DnsResolveContext.java:845)\r\n\tat io.netty.resolver.dns.DnsResolveContext.tryToFinishResolve(DnsResolveContext.java:806)\r\n\tat io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:333)\r\n\tat io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:322)\r\n\tat io.netty.resolver.dns.DnsResolveContext.access$500(DnsResolveContext.java:62)\r\n\tat io.netty.resolver.dns.DnsResolveContext$3.operationComplete(DnsResolveContext.java:379)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:485)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)\r\n\tat io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:162)\r\n\tat io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:33)\r\n\tat io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:354)\r\n\tat io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:322)\r\n\tat io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:909)\r\n\tat io.netty.resolver.dns.DnsResolveContext.internalResolve(DnsResolveContext.java:272)\r\n\tat io.netty.resolver.dns.DnsResolveContext.doSearchDomainQuery(DnsResolveContext.java:244)\r\n\tat io.netty.resolver.dns.DnsAddressResolveContext.doSearchDomainQuery(DnsAddressResolveContext.java:98)\r\n\tat io.netty.resolver.dns.DnsResolveContext.resolve(DnsResolveContext.java:211)\r\n\tat io.netty.resolver.dns.DnsNameResolver.doResolveAllUncached(DnsNameResolver.java:972)\r\n\tat io.netty.resolver.dns.DnsNameResolver.doResolveAll(DnsNameResolver.java:925)\r\n\tat io.netty.resolver.dns.DnsNameResolver.doResolveAll(DnsNameResolver.java:893)\r\n\tat io.netty.resolver.SimpleNameResolver.resolveAll(SimpleNameResolver.java:81)\r\n\tat io.netty.resolver.dns.InflightNameResolver.resolve(InflightNameResolver.java:96)\r\n\tat io.netty.resolver.dns.InflightNameResolver.resolveAll(InflightNameResolver.java:71)\r\n\tat io.netty.resolver.dns.InflightNameResolver.resolveAll(InflightNameResolver.java:56)\r\n\tat io.netty.resolver.InetSocketAddressResolver.doResolveAll(InetSocketAddressResolver.java:75)\r\n\tat io.netty.resolver.InetSocketAddressResolver.doResolveAll(InetSocketAddressResolver.java:32)\r\n\tat io.netty.resolver.AbstractAddressResolver.resolveAll(AbstractAddressResolver.java:160)\r\n\tat org.redisson.connection.SentinelConnectionManager.performSentinelDNSCheck(SentinelConnectionManager.java:280)\r\n\tat org.redisson.connection.SentinelConnectionManager.access$200(SentinelConnectionManager.java:54)\r\n\tat org.redisson.connection.SentinelConnectionManager$1.run(SentinelConnectionManager.java:273)\r\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\r\n\tat io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:127)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:466)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: io.netty.resolver.dns.DnsNameResolverException: [/192.168.190.226:53] failed to send a query (no stack trace available)\r\nCaused by: java.nio.channels.ClosedChannelException: null\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source)\r\n2020-12-07 21:45:07,659 INFO  [metrics-infra-ewell] [nioEventLoopGroup-5-2] [o.r.c.SentinelConnectionManager:558] - trace[] sentinel: redis://172.30.49.77:26379 added\r\n2020-12-07 21:45:07,831 WARN  [metrics-infra-ewell] [nioEventLoopGroup-5-1] [o.r.c.SentinelConnectionManager:501] - trace[] sentinel: redis://172.30.49.77:26379 is down\r\n2020-12-07 21:45:10,894 ERROR [metrics-infra-ewell] [nioEventLoopGroup-2-2] [o.r.c.SentinelConnectionManager:285] - trace[] Unable to resolve redis-cluster\r\nio.netty.resolver.dns.DnsResolveContext$SearchDomainUnknownHostException: Search domain query failed. Original hostname: 'redis-cluster' failed to resolve 'redis-cluster.devcommon.svc.cluster.local'\r\n\tat io.netty.resolver.dns.DnsResolveContext.finishResolve(DnsResolveContext.java:845)\r\n\tat io.netty.resolver.dns.DnsResolveContext.tryToFinishResolve(DnsResolveContext.java:806)\r\n\tat io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:333)\r\n\tat io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:322)\r\n\tat io.netty.resolver.dns.DnsResolveContext.access$500(DnsResolveContext.java:62)\r\n\tat io.netty.resolver.dns.DnsResolveContext$3.operationComplete(DnsResolveContext.java:379)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:504)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:483)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)\r\n\tat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121)\r\n\tat io.netty.resolver.dns.DnsQueryContext.setFailure(DnsQueryContext.java:216)\r\n\tat io.netty.resolver.dns.DnsQueryContext.onQueryWriteCompletion(DnsQueryContext.java:151)\r\n\tat io.netty.resolver.dns.DnsQueryContext.access$200(DnsQueryContext.java:43)\r\n\tat io.netty.resolver.dns.DnsQueryContext$3.operationComplete(DnsQueryContext.java:143)\r\n\tat io.netty.resolver.dns.DnsQueryContext$3.operationComplete(DnsQueryContext.java:140)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:485)\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)\r\n\tat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121)\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:987)\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:869)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1391)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.access$1700(AbstractChannelHandlerContext.java:38)\r\n\tat io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1104)\r\n\tat io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1151)\r\n\tat io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1075)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:466)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: io.netty.resolver.dns.DnsNameResolverException: [/192.168.190.226:53] failed to send a query (no stack trace available)\r\nCaused by: java.nio.channels.ClosedChannelException: null\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3268/comments",
    "author": "zewade",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-12-08T12:08:53Z",
        "body": "Caused by: io.netty.resolver.dns.DnsNameResolverException: [/192.168.190.226:53] failed to send a query"
      },
      {
        "user": "zewade",
        "created_at": "2020-12-09T06:31:31Z",
        "body": "> Caused by: io.netty.resolver.dns.DnsNameResolverException: [/192.168.190.226:53] failed to send a query\r\n\r\nCould I set dnsMonitoringInterval = -1 to avoid this error log?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-12-09T08:23:25Z",
        "body": "I'm afraid no, since `redis-cluster.devcommon.svc.cluster.local` host should be resolved in any way."
      },
      {
        "user": "youdang123",
        "created_at": "2022-04-22T09:01:20Z",
        "body": "@zewade @mrniko I also encountered the same problem, how to solve it"
      },
      {
        "user": "mrniko",
        "created_at": "2022-04-23T07:41:13Z",
        "body": "@youdang123 \r\n\r\nDid you try to specify fully qualified name?"
      }
    ]
  },
  {
    "number": 3252,
    "title": "Problem to deserialize object with jackson",
    "created_at": "2020-12-01T17:33:57Z",
    "closed_at": "2021-03-25T08:52:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3252",
    "body": "Hey guys could you tell me what i am doing wrong here\r\n\r\nI have an interface and it has many different implementations, so for example there is a call create account it should return CreateAccountResponse or any other interface realisation \r\n\r\n   \r\nCould not execute the callcom.fasterxml.jackson.databind.exc.InvalidTypeIdException: Missing type id when trying to resolve subtype of [simple type, class com.opngo.nowos.nowos.api.response.DataResponse]: missing type id property 'operation' (for POJO property 'response')\r\n     at [Source: (okhttp3.ResponseBody$BomAwareReader); line: 1, column: 180] (through reference chain: com.opngo.nowos.nowos.NowOSResponse[\"response\"])\r\n```\r\n\r\nHere is my Interface \r\n\r\n@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"operation\")\r\n    @JsonSubTypes({@JsonSubTypes.Type(value = AuthResponse.class, name = \"account_auth\")})\r\n    public interface DataResponse {\r\n        ///\r\n    }\r\n\r\nHere is one of the response objects that implements the interface mentioned above\r\n\r\n   ```\r\n @RequiredArgsConstructor\r\n    public class AuthResponse implements DataResponse {\r\n    \r\n        @JsonProperty\r\n        private final String accountID;\r\n        @JsonProperty\r\n        private final String authToken;\r\n        @JsonProperty\r\n        private final String language;\r\n    }\r\n\r\nHere is main Response that have that interface that should bring correct response object \r\n\r\npublic class NowOSResponse {\r\n    \r\n        @JsonProperty\r\n        private final String operation;\r\n        @JsonProperty\r\n        private final String version;\r\n        @JsonProperty\r\n        private final DataResponse response;\r\n        @JsonProperty\r\n        private final String status;\r\n    \r\n    }\r\n\r\nAnd finally just wanted to mention that the goal of such approach and receiving different responses for each call is to test their properties, so i am casting interface to the correct class depending on the call \r\n\r\n @Test\r\n        void shouldAuthorizeAccount(){\r\n            NowOSResponse response = accountApi.authorizeAccount(new AccountAuth());\r\n            AuthResponse authResponse = (AuthResponse) response.getResponse();\r\n            commonResponseAssertions(response, ACCOUNT_AUTH.getLabel());\r\n            assertFalse(authResponse.getAuthToken().isEmpty());\r\n        }\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3252/comments",
    "author": "ArtjomProzorov",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-03-25T08:52:22Z",
        "body": "you need to remove type id field in this case by overriding `org.redisson.codec.JsonJacksonCodec#initTypeInclusion` method."
      }
    ]
  },
  {
    "number": 3242,
    "title": "isHeldByCurrentThread() goes wrong",
    "created_at": "2020-11-24T08:34:22Z",
    "closed_at": "2020-12-02T11:10:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3242",
    "body": "org.redisson.client.RedisException: Unexpected exception while processing command\r\n\tat org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:338)\r\n\tat org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:140)\r\n\tat org.redisson.RedissonObject.get(RedissonObject.java:90)\r\n\tat org.redisson.RedissonLock.isHeldByThread(RedissonLock.java:523)\r\n\tat org.redisson.RedissonLock.isHeldByCurrentThread(RedissonLock.java:517)\r\n\tat com.hikvision.ga.vnsc.mls.modules.distribute.redis.RedissonDistributedLocker.unlock(RedissonDistributedLocker.java:49)\r\n\tat com.hikvision.ga.vnsc.mls.modules.distribute.redis.RedissLockUtil.unlock(RedissLockUtil.java:30)\r\n\tat com.hikvision.ga.vnsc.mls.modules.privilege.handler.CountHandler.updateCurrentLink(CountHandler.java:776)\r\n\tat com.hikvision.ga.vnsc.mls.modules.privilege.handler.CountHandler.updateSingleCurrentLink(CountHandler.java:530)\r\n\tat com.hikvision.ga.vnsc.mls.modules.privilege.handler.CountHandler.updateCountByRegister(CountHandler.java:481)\r\n\tat com.hikvision.ga.vnsc.mls.modules.notifier.DefaultNotifier.updateLinkEurl(DefaultNotifier.java:251)\r\n\tat com.hikvision.ga.vnsc.mls.modules.notifier.DefaultNotifier.notify(DefaultNotifier.java:137)\r\n\tat com.hikvision.ga.vnsc.mls.modules.notifier.DefaultNotifier$$FastClassBySpringCGLIB$$b3dd79bb.invoke(<generated>)\r\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:685)\r\n\tat com.hikvision.ga.vnsc.mls.modules.notifier.DefaultNotifier$$EnhancerBySpringCGLIB$$a14831d5.notify(<generated>)\r\n\tat com.hikvision.ga.vnsc.mls.modules.module.media.handler.AbstractMessageHandler.notify(AbstractMessageHandler.java:174)\r\n\tat com.hikvision.ga.vnsc.mls.modules.module.media.handler.RegisterReqHandler.getResponse(RegisterReqHandler.java:140)\r\n\tat com.hikvision.ga.vnsc.mls.modules.module.media.handler.RegisterReqHandler.lambda$doHandle$0(RegisterReqHandler.java:75)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)\r\nCaused by: java.lang.NullPointerException: null\r\n\tat org.redisson.client.handler.CommandEncoder.encode(CommandEncoder.java:131)\r\n\tat org.redisson.client.handler.CommandEncoder.encode(CommandEncoder.java:100)\r\n\tat org.redisson.client.handler.CommandEncoder.encode(CommandEncoder.java:56)\r\n\tat io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:107)\r\n\tat org.redisson.client.handler.CommandEncoder.write(CommandEncoder.java:76)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:716)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:708)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:791)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:701)\r\n\tat io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:120)\r\n\tat org.redisson.client.handler.CommandBatchEncoder.write(CommandBatchEncoder.java:45)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:716)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:708)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:791)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:701)\r\n\tat io.netty.channel.ChannelDuplexHandler.write(ChannelDuplexHandler.java:115)\r\n\tat org.redisson.client.handler.CommandsQueue.write(CommandsQueue.java:97)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:716)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:763)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:789)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(AbstractChannelHandlerContext.java:757)\r\n\tat io.netty.channel.DefaultChannelPipeline.writeAndFlush(DefaultChannelPipeline.java:1031)\r\n\tat io.netty.channel.AbstractChannel.writeAndFlush(AbstractChannel.java:298)\r\n\tat org.redisson.client.handler.CommandsQueue.sendData(CommandsQueue.java:123)\r\n\tat org.redisson.client.handler.CommandsQueue.write(CommandsQueue.java:100)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:716)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:708)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.access$1700(AbstractChannelHandlerContext.java:56)\r\n\tat io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1102)\r\n\tat io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1149)\r\n\tat io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1073)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:416)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:515)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3242/comments",
    "author": "VicQwz",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-11-24T10:55:33Z",
        "body": "check lock name for null value"
      },
      {
        "user": "VicQwz",
        "created_at": "2020-12-02T11:09:58Z",
        "body": "Thanks a lot"
      }
    ]
  },
  {
    "number": 3239,
    "title": "How to programmatically initialize redisson hibernate second level cache",
    "created_at": "2020-11-24T00:52:01Z",
    "closed_at": "2021-04-12T16:46:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3239",
    "body": "My application uses:\r\n```\r\norg.redisson:redisson-hibernate-53:3.13.6\r\norg.redisson:redisson:3.13.1\r\norg.redisson:redisson-spring-data-22:3.12.5\r\nid 'org.springframework.boot' version '2.3.0.RELEASE'\r\n```\r\nI am using spring boot along with redisson for http session management and spring data. The configuration is programmatically initialized and works well. \r\nI am trying to add hibernate 2nd level cache back by redis. I cannot find documentation on how this can be done programmatically. I have the following beans: `RedissonClient`, `RedissonConnectionFactory` and `RedisTemplate` ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3239/comments",
    "author": "smirandamedallia",
    "comments": [
      {
        "user": "smirandamedallia",
        "created_at": "2020-11-25T19:34:08Z",
        "body": "Upgraded to redisson `3.14.0` now \r\nI have added the following class \r\n```\r\n@Configuration\r\n@DependsOn(\"redis-client\")\r\npublic class RedissonPersistenceCachingConfiguration extends RedissonRegionFactory {\r\n\tprivate RedissonClient redissonClient;\r\n\r\n\t@Autowired\r\n\tpublic RedissonPersistenceCachingConfiguration(RedissonClient redissonClient) {\r\n\t\tthis.redissonClient = redissonClient;\r\n\t}\r\n\r\n\t@Override\r\n\tprotected RedissonClient createRedissonClient(Map properties) {\r\n\t\treturn redissonClient;\r\n\t}\r\n}\r\n```\r\n\r\nThe `RedissonClient` looks to be injected as expected but hibernate initialization fails with the below error\r\n\r\n```\r\nCaused by: org.hibernate.service.spi.ServiceException: Unable to create requested service [org.hibernate.cache.spi.RegionFactory]\r\n\tat org.hibernate.service.internal.AbstractServiceRegistryImpl.createService(AbstractServiceRegistryImpl.java:275)\r\n\tat org.hibernate.service.internal.AbstractServiceRegistryImpl.initializeService(AbstractServiceRegistryImpl.java:237)\r\n\tat org.hibernate.service.internal.AbstractServiceRegistryImpl.getService(AbstractServiceRegistryImpl.java:214)\r\n\tat org.hibernate.boot.internal.MetadataBuilderImpl$MetadataBuildingOptionsImpl.<init>(MetadataBuilderImpl.java:694)\r\n\tat org.hibernate.boot.internal.MetadataBuilderImpl.<init>(MetadataBuilderImpl.java:122)\r\n\tat org.hibernate.boot.MetadataSources.getMetadataBuilder(MetadataSources.java:141)\r\n\tat org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.<init>(EntityManagerFactoryBuilderImpl.java:238)\r\n\tat org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.<init>(EntityManagerFactoryBuilderImpl.java:168)\r\n\tat org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:52)\r\n\tat org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365)\r\n\tat org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:391)\r\n\tat java.base/java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:264)\r\n\tat java.base/java.util.concurrent.FutureTask.run(FutureTask.java)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)\r\nCaused by: org.hibernate.boot.registry.selector.spi.StrategySelectionException: Could not instantiate named strategy class [com.medallia.sso.relay.configuration.RedissonPersistenceCachingConfiguration]\r\n\tat org.hibernate.boot.registry.selector.internal.StrategySelectorImpl.resolveStrategy(StrategySelectorImpl.java:247)\r\n\tat org.hibernate.boot.registry.selector.internal.StrategySelectorImpl.resolveStrategy(StrategySelectorImpl.java:192)\r\n\tat org.hibernate.cache.internal.RegionFactoryInitiator.resolveRegionFactory(RegionFactoryInitiator.java:93)\r\n\tat org.hibernate.cache.internal.RegionFactoryInitiator.initiateService(RegionFactoryInitiator.java:47)\r\n\tat org.hibernate.cache.internal.RegionFactoryInitiator.initiateService(RegionFactoryInitiator.java:32)\r\n\tat org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.initiateService(StandardServiceRegistryImpl.java:101)\r\n\tat org.hibernate.service.internal.AbstractServiceRegistryImpl.createService(AbstractServiceRegistryImpl.java:263)\r\n\t... 15 more\r\nCaused by: org.hibernate.service.spi.ServiceException: Unable to call constructor of RegionFactory impl [com.medallia.sso.relay.configuration.RedissonPersistenceCachingConfiguration]\r\n\tat org.hibernate.cache.internal.StrategyCreatorRegionFactoryImpl.create(StrategyCreatorRegionFactoryImpl.java:65)\r\n\tat org.hibernate.cache.internal.StrategyCreatorRegionFactoryImpl.create(StrategyCreatorRegionFactoryImpl.java:23)\r\n\tat org.hibernate.boot.registry.selector.internal.StrategySelectorImpl.resolveStrategy(StrategySelectorImpl.java:243)\r\n\t... 21 more\r\nCaused by: java.lang.InstantiationException: com.medallia.sso.relay.configuration.RedissonPersistenceCachingConfiguration\r\n\tat java.base/java.lang.Class.newInstance(Class.java:571)\r\n\tat org.hibernate.cache.internal.StrategyCreatorRegionFactoryImpl.create(StrategyCreatorRegionFactoryImpl.java:62)\r\n\t... 23 more\r\nCaused by: java.lang.NoSuchMethodException: com.medallia.sso.relay.configuration.RedissonPersistenceCachingConfiguration.<init>()\r\n\tat java.base/java.lang.Class.getConstructor0(Class.java:3349)\r\n\tat java.base/java.lang.Class.newInstance(Class.java:556)\r\n\t... 24 more\r\n```\r\nis there another way of sharing the previously created `RedissonClient` ?"
      },
      {
        "user": "smirandamedallia",
        "created_at": "2020-12-01T21:34:32Z",
        "body": "any updates on this @mrniko "
      },
      {
        "user": "mrniko",
        "created_at": "2020-12-03T11:11:23Z",
        "body": "`java.lang.NoSuchMethodException: com.medallia.sso.relay.configuration.RedissonPersistenceCachingConfiguration.<init>()`\r\n\r\nYou need to check your class constructor\r\n"
      },
      {
        "user": "smirandamedallia",
        "created_at": "2020-12-04T00:46:17Z",
        "body": "@mrniko \r\nYes I see that but even adding a default constructor in `RedissonPersistenceCachingConfiguration` doesn't help since when\r\n`RedissonRegionFactory#prepareForUse` is called the Overriden method `createRedissonClient` returns `null` since the `RedissonClient` is never injected. \r\n\r\nMainly what I am trying to do is have `RedissonRegionFactory` use the `RedissonClient` which already has been created (I have already created one for spring sessions).\r\n`RedissonRegionFactory` looks to only support creating a client from properties rather than reusing one if it already exists as a bean"
      },
      {
        "user": "smirandamedallia",
        "created_at": "2020-12-16T23:23:45Z",
        "body": "@mrniko any suggests on above"
      },
      {
        "user": "mrniko",
        "created_at": "2020-12-17T07:07:21Z",
        "body": "I can suggest you to put Redisson in JNDI and use JndiRedissonRegionFactory"
      },
      {
        "user": "moose-byte",
        "created_at": "2022-03-25T00:52:38Z",
        "body": "Do you have an example of this? I keep reading about it, but I don't see any examples. Maybe I haven't looked deep enough"
      },
      {
        "user": "chenygs",
        "created_at": "2023-09-22T07:10:54Z",
        "body": "``/**\r\n * @Author chenygs\r\n * @Date 2023/3/7 15:38\r\n */\r\n@AllArgsConstructor\r\npublic class New2RedisRegionFactory extends RedissonRegionFactory {\r\n    private static final long serialVersionUID = 8887392285596501033L;\r\n\r\n    private RedissonClient redissonClient;\r\n\r\n    @Override\r\n    protected RedissonClient createRedissonClient(Map properties) {\r\n        return redissonClient;\r\n    }\r\n}\r\n\r\n\r\n    @Bean\r\n    @Primary\r\n    public HibernatePropertiesCustomizer setRegionFactory(RedissonClient redisson) {\r\n        return hibernateProperties -> {\r\n            hibernateProperties.put(AvailableSettings.USE_SECOND_LEVEL_CACHE, true);\r\n            hibernateProperties.put(AvailableSettings.CACHE_REGION_FACTORY, new New2RedisRegionFactory(redisson));\r\n            hibernateProperties.put(AvailableSettings.CACHE_REGION_PREFIX, \"imv3::\");\r\n            hibernateProperties.put(AvailableSettings.JPA_SHARED_CACHE_MODE, SharedCacheMode.ENABLE_SELECTIVE);\r\n            hibernateProperties.put(AvailableSettings.USE_QUERY_CACHE, true);\r\n//            hibernateProperties.put(\"hibernate.cache.redisson.entity.expiration.time_to_live\", \"7000\");\r\n        };\r\n    }\r\n\r\n"
      }
    ]
  },
  {
    "number": 3238,
    "title": "Redis elasticache (ReplicatedServersConfig) RW/RO endpoint or all nodes ?",
    "created_at": "2020-11-23T21:33:11Z",
    "closed_at": "2020-11-24T06:31:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3238",
    "body": "Hi,\r\n\r\nI am trying to use redisson to connect to an AWS Elasticache (not cluster) redis,\r\nI can't find a clear answer on what 'nodes' should I list in redisson config.\r\n\r\nShould I put : (using AWS front endpoints)\r\nmaster.myredis.xxxx.usw2.cache.amazonaws.com:6379,\r\nreader.myredis.xxxx.usw2.cache.amazonaws.com:6379\r\n\r\nor (all nodes endpoint) :\r\nmyredis-001.xxx.usw2.cache.amazonaws.com:6379,\r\nmyredis-002.xxx.usw2.cache.amazonaws.com:6379,\r\nmyredis-003.xxx.usw2.cache.amazonaws.com:6379,\r\n...\r\n\r\n(in the past I used the master.myredis... directly in a node application, didn't dig more into it then).\r\n\r\nThanks.\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3238/comments",
    "author": "CyrilDevOps",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-11-24T06:31:20Z",
        "body": "for non-cluster AWS Elasticache setup (replicated mode) you need to list all nodes in configuration"
      }
    ]
  },
  {
    "number": 3231,
    "title": "ElementsSubscribeService",
    "created_at": "2020-11-21T10:44:49Z",
    "closed_at": "2020-12-04T12:21:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3231",
    "body": "hi, I'm using redisson's ElementsSubscribeService along with redis BRPOPLPUSH command to subscribe to a redis list, so that I can retrieve an element from the tail of the list (and move that element to the head of the same list) when another client pushes an element to this list.\r\nBut when I push an element to the list and consume that element from the same application (spring context), the consumer's redisson operation got blocked during handling.\r\nconsumer pseudo code:\r\n```\r\npublic class RedissonConsumer implements ApplicationRunner, Consumer<Object>{\r\n   \r\n    // implements Consumer\r\n    @override\r\n    public accept(Object obj){\r\n        redisson.getLock(obj);\r\n        try{\r\n            if(lock.tryLock()){\r\n                // handle this message\r\n            }\r\n        }finally{\r\n            // it got blocked here !!!!\r\n            if(lock.isHeldByCurrentThread()){\r\n                lock.unlock();\r\n            }\r\n        }\r\n    }\r\n\r\n    // implements ApplicationRunner\r\n    @Override\r\n    public void run(ApplicationArguments args) throws Exception {\r\n        redisson().getConnectionManager().getElementsSubscribeService()\r\n            // BRPOPLPUSH the same queue\r\n            .subscribeOnElements(() -> blockingQueue().takeLastAndOfferFirstToAsync(queue()), this);\r\n    }\r\n}\r\n```\r\n\r\n\r\nhere is the log right before the consumer got stuck:\r\n`11-21-2020 18:41:02.802 DEBUG [redisson-netty-10-2] [ef6a4d1a805343bb940527ce0b1c2401] o.r.c.RedisExecutor.sendCommand: acquired connection for command (HEXISTS) and params [lock..., f2562a06-3333-de34-91a6-5ce57111892d:26] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=1, freeConnectionsCounter=value:61:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]] using node /127.0.0.1:6379... RedisConnection@1489204891 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xde7fb2e3, L:/127.0.0.1:64542 - R:/127.0.0.1:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@33046ebc(success: {\"data\":\"d1725d293d494bc58a798887febe0f4e\"})], command=(BRPOPLPUSH), params=[951fb209-26ed-47ed-b57d-f7f743a51d6b, 951fb209-26ed-47ed-b57d-f7f743a51d6b, 0], codec=org.redisson.codec.JsonJacksonCodec]]\r\n`\r\n\r\n\r\nlog after:\r\n`\r\n11-21-2020 18:41:07.196 DEBUG [redisson-timer-12-1] [] o.r.c.RedisExecutor.lambda$releaseConnection$7: connection released for command (HEXISTS) and params [lock..., f2562a06-3333-de34-91a6-5ce57111892d:26] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=3, freeConnectionsCounter=value:63:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]] using connection RedisConnection@1489204891 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xde7fb2e3, L:/127.0.0.1:64542 - R:/127.0.0.1:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@33046ebc(success: {\"data\":\"d1725d293d494bc58a798887febe0f4e\"})], command=(BRPOPLPUSH), params=[951fb209-26ed-47ed-b57d-f7f743a51d6b, 951fb209-26ed-47ed-b57d-f7f743a51d6b, 0], codec=org.redisson.codec.JsonJacksonCodec]]\r\n11-21-2020 18:41:07.197 WARN [redisson-netty-10-2] [ef6a4d1a805343bb940527ce0b1c2401] i.n.u.c.DefaultPromise.notifyListener0: An exception was thrown by org.redisson.misc.RedissonPromise$$Lambda$769/1780936422.operationComplete()\r\norg.redisson.client.RedisTimeoutException: Command still hasn't been written into connection! Increase nettyThreads and/or retryInterval settings. Payload size in bytes: 0. Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=2, freeConnectionsCounter=value:62:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1489204891 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xde7fb2e3, L:/127.0.0.1:64542 - R:/127.0.0.1:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@33046ebc(success: {\"data\":\"d1725d293d494bc58a798887febe0f4e\"})], command=(BRPOPLPUSH), params=[951fb209-26ed-47ed-b57d-f7f743a51d6b, 951fb209-26ed-47ed-b57d-f7f743a51d6b, 0], codec=org.redisson.codec.JsonJacksonCodec]], command: (HEXISTS), params: [lock..., f2562a06-3333-de34-91a6-5ce57111892d:26] after 3 retry attempts\r\n\tat org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:200) ~[redisson-3.12.5.jar:3.12.5]\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672) ~[netty-common-4.1.52.Final.jar:4.1.52.Final]\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747) ~[netty-common-4.1.52.Final.jar:4.1.52.Final]\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472) ~[netty-common-4.1.52.Final.jar:4.1.52.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.52.Final.jar:4.1.52.Final]\r\n\tat java.lang.Thread.run(Thread.java:748) [?:1.8.0_162]`\r\ncan you help me with this? many thanks!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3231/comments",
    "author": "darknessp",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-12-04T12:21:34Z",
        "body": "ElementsSubscribeService isn't intended for external usage."
      }
    ]
  },
  {
    "number": 3229,
    "title": "redisson-spring-boot-starter， version 3.13.6  ",
    "created_at": "2020-11-21T08:11:30Z",
    "closed_at": "2020-11-22T14:02:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3229",
    "body": "\r\n<groupId>org.redisson</groupId>\r\n<artifactId>redisson-spring-boot-starter</artifactId>\r\n<version>3.13.6</version>\r\n\r\nWhen I use the following command, an exception is thrown，I tried a lot of high version, the error message is the same.\r\nI use the  version: 3.5.5, It is work. so why the high version doesn't work ?\r\n\r\ngeo.radiusWithDistance(lon, lat, 3, GeoUnit.KILOMETERS, GeoOrder.ASC, 10);\r\n\r\nException in thread \"main\" org.redisson.client.RedisException: ERR unknown command 'GEORADIUS_RO'. channel: [id: 0x85a94190, L:/127.0.0.1:52892 - R:/127.0.0.1:6379] command: (GEORADIUS_RO)\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3229/comments",
    "author": "seart",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-11-22T14:01:50Z",
        "body": "GEORADIUS_RO is used to read data from Redis slave. You need to update to Redis to 3.2.10 version or higher to get it work."
      },
      {
        "user": "seart",
        "created_at": "2020-11-24T06:01:13Z",
        "body": "> GEORADIUS_RO is used to read data from Redis slave. You need to update to Redis to 3.2.10 version or higher to get it work.\r\n\r\nthanks，I thought 13 was bigger than 2 ， but it was smaller than 2"
      }
    ]
  },
  {
    "number": 3227,
    "title": "Rlock not able to handle 200 concurrent requests",
    "created_at": "2020-11-20T18:32:13Z",
    "closed_at": "2020-12-03T07:30:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3227",
    "body": "Hi,\r\nI was trying to use distributed lock to do some operations and here I am facing an issue - it wasn't able to handle more than 200 concurrent requests\r\n\r\nI am using redis as single server instance for this testing and here is my code\r\n\r\ntry {\r\n            RLock lock = redisTemplate.getLock(\"lock\");\r\n            boolean lockStatus = lock.tryLock(10000L, 200L,TimeUnit.MILLISECONDS);\r\n            log.info(\"lock status\" + String.valueOf(lockStatus));\r\n            // do some operations - this operation doesn't take more than 100 ms and so the same can be simulated with sleep \r\n            Thread.sleep(100)\r\n            if(lock.isHeldByCurrentThread()){\r\n                 lock.unlock();\r\n             }\r\n        }catch (Exception e) {\r\n            log.error(\"Exception Occured \" + e);\r\n        }\r\n\r\nPlease advise on what to look for to handle higher concurrency and handle the required requests per second. Our target was to handle around 1k concurrent requests ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3227/comments",
    "author": "sagar694",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-12-03T07:30:59Z",
        "body": "performance depends on factors like: network, CPU resources of both application and Redis"
      }
    ]
  },
  {
    "number": 3222,
    "title": "为什么redissonClient 使用getMap() 或者 getSet() 这种集合的时候会把所有值给取出来；",
    "created_at": "2020-11-20T01:32:02Z",
    "closed_at": "2020-12-03T08:45:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3222",
    "body": "",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3222/comments",
    "author": "tanzheng231",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-12-03T08:45:23Z",
        "body": "It doesn't load all values. You can see it in code."
      }
    ]
  },
  {
    "number": 3220,
    "title": "compatibility with spring-session 2020.0.1",
    "created_at": "2020-11-19T12:04:15Z",
    "closed_at": "2020-11-22T14:03:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3220",
    "body": "i have seen on the wiki that currently redisson officially supports spring-boot up to version 2.3, the same for spring-session and spring-data. which version of reddisson library should I use when running with spring-boot 2.4.0 and spring-session 2020.0.1?\r\n\r\n```\r\ncompile 'org.springframework.session:spring-session-core:2.3.1.RELEASE'\r\ncompile 'org.redisson:redisson-spring-data-23:3.13.6'\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3220/comments",
    "author": "BigMichi1",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-11-22T14:03:29Z",
        "body": "Redisson 3.14.0 version. Since it support Spring Data 2.4.0 version used by spring-boot 2.4.0"
      }
    ]
  },
  {
    "number": 3213,
    "title": "why task was submit into database 0 while I already set database 15",
    "created_at": "2020-11-15T10:35:55Z",
    "closed_at": "2020-11-26T12:04:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3213",
    "body": "```java\r\npublic static void main(String[] args) {\r\n        Config config = new Config();\r\n        config.useSingleServer().setAddress(\"redis://localhost:6379\").setDatabase(15);\r\n        config.setCodec(new JsonJacksonCodec());\r\n        config.setThreads(16);\r\n        config.setNettyThreads(32);\r\n        config.setTransportMode(TransportMode.NIO);\r\n        RedissonClient redissonClient = Redisson.create(config);\r\n\r\n        ExecutorOptions options = ExecutorOptions.defaults();\r\n        RExecutorService executor = redissonClient.getExecutorService(\"myExecutor\",options);\r\n        RExecutorFuture<TenantPO> submit = executor.submitAsync(new Task());\r\n    }\r\n\r\n    public static class Task implements Callable<Long>{\r\n\r\n        @Override\r\n        public Long call() throws Exception {\r\n            System.out.println(\"task over\");\r\n            return 233L;\r\n        }\r\n    }\r\n```\r\n我用15号库想提交一个任务，但是没有执行，结果发现，任务信息保存在0号库里，想问下为什么\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3213/comments",
    "author": "mihone",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-11-26T12:04:08Z",
        "body": "unable to reproduce it with the latest version"
      }
    ]
  },
  {
    "number": 3205,
    "title": "RMap is holding huge memory compared to normal object in Redis",
    "created_at": "2020-11-11T10:53:24Z",
    "closed_at": "2020-11-11T14:56:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3205",
    "body": "While working on memory improvements for Redis, I came across with an issue where I have observed that Redis is using huge memory for RMap compared to normal object. \r\n\r\nI have execute below code and I observed below things:\r\n- I could see memory occupied in Redis for key `abcd-abcd:map` is 10728729 bytes(10.72 MB), I have used command `MEMORY USAGE abcd-abcd:map`.\r\n- I could see memory occupied in Redis for key `abcd-abcd` is 1170360 bytes(1.17 MB), I used command `MEMORY USAGE abcd-abcd`\r\n\r\nMy question is if I am saving one object(`hashmap`) as an `RMap` and saving the same object(`hashmap`) as a value in another `Map` then why the object saved in `RMap` is occupying huge amount of memory compared to other case?\r\n\r\nPlease note currently I kept `SIZE` as 100000, but in my case I need to save 1-2 million(or more than that) objects in `RMap` and in that case I can see huge memory utilization in Redis.\r\n\r\nCan someone please review this and share their thoughts?\r\n\r\n```\r\npublic class RedisTest {\r\n  \r\n  private static final int SIZE = 100000;\r\n  private static Codec compositeCodec = new \r\n      CompositeCodec(new StringCodec(), new LZ4Codec(new SerializationCodec()),  new SerializationCodec());\r\n  private static String initId = \"abcd-abcd\";\r\n\r\n  public static void main(String[] args) {\r\n    Config config = new Config();\r\n    config.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");\r\n    RedissonClient redissonClient = Redisson.create(config);\r\n    RMap<String,String> rmap = redissonClient.getMap(initId + \":map\", compositeCodec);\r\n    Map<String, String> hashMap = getMap();\r\n    rmap.putAll(hashMap);\r\n    RMap<Object, Object> rootMap = redissonClient.getMap(initId, compositeCodec);\r\n    rootMap.put(\"object\", hashMap);\r\n    redissonClient.shutdown();\r\n  }\r\n  \r\n  private static Map<String, String> getMap() {\r\n    Map<String, String> hashMap = new HashMap<>();\r\n    for (int i = 0; i < SIZE; i++) {\r\n      hashMap.put(\"keykeykeykeykeykeykeykeykeykeykeykey\"+i, \"valuevaluevaluevaluevaluevaluevaluevaluevalue\"+i);\r\n    }\r\n    return hashMap;\r\n  }\r\n\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3205/comments",
    "author": "ravinirmal10",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-11-11T14:56:08Z",
        "body": "`rmap` object is greater since it has **100000 entries** and `rootMap` has lower size because it has only **one entry**. Moreover map with single entry has repeated strings in value, like \"valuevaluevaluevaluevaluevaluevaluevaluevalue\" \"keykeykeykeykeykeykeykeykeykeykeykey\", which are subject for compression with a good ratio."
      },
      {
        "user": "ravinirmal10",
        "created_at": "2020-11-11T15:51:40Z",
        "body": "> `rmap` object is greater since it has **100000 entries** and `rootMap` has lower size because it has only **one entry**. Moreover map with single entry has repeated strings in value, like \"valuevaluevaluevaluevaluevaluevaluevaluevalue\" \"keykeykeykeykeykeykeykeykeykeykeykey\", which are subject for compression with a good ratio.\r\n\r\n@mrniko - I understand that due to more number of entries it is occupying higher amount of memory, but the difference is way higher(nearly 800% in this case) compared to single object.\r\n\r\nAlso, map with single entry and multiple entries have exact same strings i.e. `hashMap` object has exact same amount of data when its stored into `RMap` OR `rootMap`, the only difference is in `RMap` each key-value stored as separate entries and in `rootMap` it is stored as single entry.\r\n\r\n"
      }
    ]
  },
  {
    "number": 3187,
    "title": "Behavior of locks vs conditions like network partition",
    "created_at": "2020-11-04T14:00:54Z",
    "closed_at": "2020-11-05T11:44:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3187",
    "body": "Hello everyone,\r\n\r\nCouldn't find my answer in docs or by looking briefly at the implementation, so posting the question here.\r\n\r\nLet's assume a system, where X instances of the same application are working concurrently on processing some data. In general, the instances can work concurrently, but some specific data items must not be processed at the same time by more than one instance, as this would produce race condition.\r\n\r\nTo synchronize application instances and avoid race conditions, we've set up a Redis instance, and we use Redisson's locking mechanism to achieve exclusive execution. In general, the workflow for an instance looks like this:\r\n(take a lock A) -> (process data) -> (release lock A)\r\n\r\nThen, obviously, the other instances, that want to process the conflicting data item, need to wait for lock A to be released. Processing an item can take anywhere between several seconds and several days. so a lock might be held for a long time (and we use this auto-renewal feature for locks to have the lock prolonged as needed behind the scenes by Redisson).\r\n\r\nMy question is - what happens if an instance, that is currently holding the lock, loses connectivity to Redis (and therefore the lock times out and is then taken by another instance), and then after some time it regains the connectivity? Will it finish processing the data without holding the lock, and then fail on releasing the lock? Or maybe something else would happen?\r\n\r\nI'd really appreciate your feedback on this.\r\n\r\nBest Regards,\r\nPaweł",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3187/comments",
    "author": "pnaw94",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-11-04T15:44:25Z",
        "body": "> Will it finish processing the data without holding the lock, and then fail on releasing the lock?\r\n\r\nIt will finish without holding lock if connectionWatchdogTimeout occured by that moment."
      },
      {
        "user": "pnaw94",
        "created_at": "2020-11-05T11:44:58Z",
        "body": "@mrniko thanks for the answer! I think that's all I need at that point."
      }
    ]
  },
  {
    "number": 3185,
    "title": "How to clear Redis cache when deployed to 2 or more containers?",
    "created_at": "2020-11-02T03:02:25Z",
    "closed_at": "2020-11-04T10:09:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3185",
    "body": "In my Spring Boot project, I have one redis container deployed in Docker swarm cluster. I use it as Hibernate 2nd level cache for the application. I use Redisson client to manually clear the cache using the following code\r\n```\r\nConfig config = new Config();\r\nconfig.useSingleServer().setAddress(\"redis://\" + redisProperties.getHost() + \":\" + redisProperties.getPort());\r\nRedissonClient redisson = Redisson.create(config);\r\nredisson.getKeys().flushdb();\r\nlogger.info(\"Successfully cleared the Redis Cache\");\r\nredisson.shutdown();\r\n```\r\n\r\nNow I would like to scale it to multiple containers to withstand failover and distribute the load. If I do that, how can I clear the cache in 2 or more containers at the same time?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3185/comments",
    "author": "pavankjadda",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-11-02T09:29:20Z",
        "body": "if containers connected to the same Redis setup then you need to call flushdb once in any container."
      },
      {
        "user": "pavankjadda",
        "created_at": "2020-11-02T16:02:44Z",
        "body": "My swarm cluster has 3 nodes. 1 manager and 2 worker nodes. And I scaled Redis service to 2 containers. Based on what I read, for each container docker swarm creates volumes that are local to each node. So, when I use flushdb in any container, would it clear cache in both?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-11-04T10:09:25Z",
        "body": "> So, when I use flushdb in any container, would it clear cache in both?\r\n\r\nYes"
      },
      {
        "user": "pavankjadda",
        "created_at": "2021-01-20T17:52:45Z",
        "body": "Okay, I tried it. It's not clearing cache in both containers. One container cache is being cleared and other one not, leaves the data in consistent state."
      }
    ]
  },
  {
    "number": 3183,
    "title": "Desired TTL is not being set for new cache maps",
    "created_at": "2020-10-29T12:04:43Z",
    "closed_at": "2020-10-30T06:48:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3183",
    "body": "Hi, \r\n\r\nI am trying to set the TTL on the cache map as shown in the snippet below but I am noticing that the TTL is set to -1 and not the value I am passing. Is this the right way to go about setting the TTL for the cache maps? If not what is the right way?\r\n\r\n```\r\nprivate RedissonClient client;\r\n.\r\n.\r\n.\r\npublic <K, V> RMap<K, V> getCachedMap(String key, long expiry, TimeUnit timeUnit) {\r\n    if (!isConnectionAlive()) {\r\n        return null;\r\n    }\r\n    try {\r\n        RMap<K, V> map = client.getMap(key);\r\n        map.expire(expiry, timeUnit);\r\n        return map;\r\n    } catch (RedisTimeoutException | RedisConnectionException e) {\r\n        setConnectionAlive(false);\r\n        logger.error(\"RedisTimeoutException | RedisConnectionException occurred.\", e);\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\nThis is what I see on enabling the debug logs: \r\n```acquired connection for command (PEXPIRE) and params [INTERACTIVE:event.9cf3de43-8c57-4247-a454-78c615cfdf1a.instance.acc38bdd-fdcb-4232-a701-eb7dadda894a..., 86400000] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=50, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=49, freeConnectionsCounter=value:199:queue:0, freezed=false, freezeReason=null, client=[addr=redis://redis:6379], nodeType=MASTER, firstFail=0]]] using node redis/169.254.169.3:6379... RedisConnection@1303942170 [redisClient=[addr=redis://redis:6379], channel=[id: 0x3a5aaba3, L:/169.254.169.30:53094 - R:redis/169.254.169.3:6379], currentCommand=null]```\r\n\r\nSo looks like it is indeed trying to set the TTL. \r\n\r\nI am using redisson version `3.13.1`",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3183/comments",
    "author": "CodeEighty8",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-30T06:48:58Z",
        "body": "Expiration can't be applied to empty maps. You need to store at least one entry in map and then set expiration time."
      }
    ]
  },
  {
    "number": 3176,
    "title": "About tomcat context.xml ",
    "created_at": "2020-10-28T01:36:28Z",
    "closed_at": "2020-10-30T06:43:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3176",
    "body": "I am not very clear about the specific role of readmode=\"MEMORY\". If readmode=\"MEMORY\" should be enabled at the same time broadcastSessionEvents=\"true\" this attribute to ensure the consistency of multiple copies of the session? Does readmode=\"MEMORY\" just store an extra session in the tomcat memory? When I simulate redis downtime, redisson will not directly read the cache from tomcat, but continue to connect to redis to get the session.I need help,thanks.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3176/comments",
    "author": "y2yya",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-30T06:42:52Z",
        "body": "> broadcastSessionEvents=\"true\" this attribute to ensure the consistency of multiple copies of the session?\r\n\r\n`broadcastSessionEvents` broadcasts only session create and destroy events.\r\n\r\nin readmode=\"MEMORY\" Redisson read session attributes from memory. If it doesn't exist in memory then Redisson loads it from Redis."
      }
    ]
  },
  {
    "number": 3175,
    "title": "How to set the sessionIdLength in the Tomcat 9 redisson?",
    "created_at": "2020-10-27T22:03:22Z",
    "closed_at": "2020-10-28T03:47:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3175",
    "body": "How can I set the `sessionIdLength` in the context.xml?\r\n\r\n```\r\n<Manager sessionIdLength=\"64\" className=\"org.redisson.tomcat.RedissonSessionManager\" configPath=\"${catalina.base}/conf/redisson.conf\" broadcastSessionEvents=\"true\" readMode=\"MEMORY\" updateMode=\"DEFAULT\"/>\r\n```\r\n\r\nThis didn't worked, the default is 16.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3175/comments",
    "author": "luiszimmermann",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-28T03:47:58Z",
        "body": "it's controlled through SessionIdGenerator, not Redisson manager.\r\n```xml\r\n <SessionIdGenerator sessionIdLength=\"64\" />\r\n```"
      }
    ]
  },
  {
    "number": 3173,
    "title": "evalSha/evalShaAsyn returns null for MAPVALUE / MAPVALUELIST returnType",
    "created_at": "2020-10-27T17:40:02Z",
    "closed_at": "2020-11-11T08:33:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3173",
    "body": "### Env setup:\r\nredisson client : 3.13.6\r\nredis-cli\r\n--\r\n\r\n127.0.0.1:6379> hmset \"u:id-1\" f1 \"id-1_f1\" f2 \"id-1_f2\" f3 \"id-1_f3\"\r\n127.0.0.1:6379> hmset \"u:id-2\" f1 \"id-2_f1\" f2 \"id-2_f2\" f3 \"id-2_f3\"\r\n127.0.0.1:6379> hmset \"u:id-3\" f1 \"id-3_f1\" f2 \"id-3_f2\" f3 \"id-3_f3\"\r\n\r\n\r\n## Expected Output \r\n`# evalsha 9ad57862683cb52805f941819a65cc502a1bc0de 3 \"u:id-1\" \"u:id-2\" \"u:id-3\" `\r\n```\r\n1) 1) \"id-1_f1\"\r\n2) \"id-1_f2\"\r\n3) \"id-1_f3\"\r\n2) 1) \"id-2_f1\"\r\n2) \"id-2_f2\"\r\n3) \"id-2_f3\"\r\n3) 1) \"id-3_f1\"\r\n2) \"id-3_f2\"\r\n3) \"id-3_f3\"\r\n\r\n```\r\n\r\n### Lua Script\r\n\r\n```\r\nfinal RScript script = redisson.getScript(StringCodec.INSTANCE);\r\nString luaScript = \"local data = {} for i=1,#KEYS do local fields = redis.call('hmget', KEYS[i], 'f1', 'f2', 'f3', 'f4') data[i] = fields end return data\";\r\n       \r\nString sha = script.scriptLoadAsync(luaScript);\r\nSystem.out.println(sha)\r\nfinal ImmutableList<String> immutableList = ImmutableList.of(\"u:id-1\", \"u:id-2\", \"u:id-3\");\r\n// tried ReturnType.MAPVALUE , ReturnType. MAPVALUELIST\r\nList<Object> results = redisson.getScript().evalSha(RScript.Mode.READ_ONLY,  sha,  RScript.ReturnType.MULTI,  Collections.singletonList(immutableList))\r\nfor (List<String> stringList : (List<List<String>>) result) {\r\n      System.out.println(stringList.size());\r\n      System.out.println(stringList);\r\n }\r\n```\r\n\r\n**Actual output:** \r\n9ad57862683cb52805f941819a65cc502a1bc0de\r\n4\r\n[null, null, null, null]\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3173/comments",
    "author": "ramkrishs",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-11-11T08:33:31Z",
        "body": "Here is correct code you need to use:\r\n\r\n```java\r\n        Map<String, String> map = new HashMap<>();\r\n        map.put(\"f1\", \"id-1_f1\");\r\n        map.put(\"f2\", \"id-1_f2\");\r\n        map.put(\"f3\", \"id-1_f3\");\r\n        redisson.getMap(\"u:id-1\", StringCodec.INSTANCE).putAll(map);\r\n\r\n        Map<String, String> map2 = new HashMap<>();\r\n        map2.put(\"f1\", \"id-2_f1\");\r\n        map2.put(\"f2\", \"id-2_f2\");\r\n        map2.put(\"f3\", \"id-2_f3\");\r\n        redisson.getMap(\"u:id-2\", StringCodec.INSTANCE).putAll(map2);\r\n\r\n        Map<String, String> map3 = new HashMap<>();\r\n        map3.put(\"f1\", \"id-3_f1\");\r\n        map3.put(\"f2\", \"id-3_f2\");\r\n        map3.put(\"f3\", \"id-3_f3\");\r\n        redisson.getMap(\"u:id-3\", StringCodec.INSTANCE).putAll(map3);\r\n\r\n        final RScript script = redisson.getScript(StringCodec.INSTANCE);\r\n        String luaScript = \"local data = {} for i=1,#KEYS do local fields = redis.call('hmget', KEYS[i], 'f1', 'f2', 'f3', 'f4') data[i] = fields end return data\";\r\n\r\n        String sha = script.scriptLoad(luaScript);\r\n        System.out.println(sha);\r\n        final List<Object> immutableList = **Arrays.asList(\"u:id-1\", \"u:id-2\", \"u:id-3\");**\r\n        // tried ReturnType.MAPVALUE , ReturnType. MAPVALUELIST\r\n        List<Object> results = redisson.getScript(**StringCodec.INSTANCE**).evalSha(RScript.Mode.READ_ONLY,  sha,  RScript.ReturnType.MULTI, immutableList);\r\n        for (List<String> stringList : (List<List<String>>) (Object)results) {\r\n              System.out.println(stringList.size());\r\n              System.out.println(stringList);\r\n        }\r\n```"
      }
    ]
  },
  {
    "number": 3164,
    "title": "Will RList<>.add(V) return false ever? ",
    "created_at": "2020-10-27T06:36:40Z",
    "closed_at": "2020-10-31T06:58:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3164",
    "body": "Will `RList<>.add(V)` return false ever? \r\n\r\nIt looks like `RedisCommands.RPUSH_BOOLEAN` command always return true based on below convertor implementation, can you please let's know will it every return `false` assuming there is no `RedisTimeoutException`? \r\n\r\n```\r\npublic class TrueReplayConvertor implements Convertor<Boolean> {\r\n    @Override\r\n    public Boolean convert(Object obj) {\r\n        return true;\r\n    }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3164/comments",
    "author": "rgampa",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-31T06:58:44Z",
        "body": "it doesn't return false since element is always added to list, otherwise exception is thrown."
      }
    ]
  },
  {
    "number": 3159,
    "title": "Redisson RMap isEmpty() returns unexpected result",
    "created_at": "2020-10-23T10:29:10Z",
    "closed_at": "2020-11-11T07:42:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3159",
    "body": "I have a map stored in redis cluster. When I try to get this map to know if a given key exists in it, I am using\r\n```\r\n        String key = \"mykey\";\r\n        RMap<String, String> rmap = redissonClient.getMap(\"mapK\", new StringCodec());\r\n        if(rmap.isEmpty() || rmap.get(key) == null){\r\n            throw new RuntimeException(\"no value found with key: \" + key);\r\n        }\r\n        ....\r\n```\r\nIt works at most times. But somehow the RuntimeException I defined above will be throw out sometimes unexpectedly. Which means `rMap.isEmpty` returns true with no exception, while the fact is we do have this key stored in redis.\r\n\r\nIn addition, I found a exception in another thread,\r\n```\r\n[redisson-timer-4-1] o.r.cluster.ClusterConnectionManager     : Can't execute CLUSTER_NODES with /10.211.63.61:6379\r\norg.redisson.client.RedisTimeoutException: Command execution timeout for command: (CLUSTER NODES), params: [], Redis client: [addr=redis://10.211.63.61:6379]\r\n\tat org.redisson.client.RedisConnection.lambda$async$1(RedisConnection.java:207) ~[redisson-3.13.3.jar!/:3.13.3]\r\n        .....\r\n```\r\n\r\nDoes this exception impact the result when I was calling `rMap.isEmpty()'?  And how can I avoid this problem?\r\n ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3159/comments",
    "author": "fletcher142",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-23T10:33:42Z",
        "body": "> Does this exception impact the result when I was calling `rMap.isEmpty()'? And how can I avoid this problem?\r\n\r\nThis might happen due to replication lag between master and slave. Try to set readMode = MASTER. "
      },
      {
        "user": "fletcher142",
        "created_at": "2020-10-23T10:51:04Z",
        "body": "> > Does this exception impact the result when I was calling `rMap.isEmpty()'? And how can I avoid this problem?\r\n> \r\n> This might happen due to replication lag between master and slave. Try to set readMode = MASTER.\r\n\r\nProbably it's not caused by the replication lag, because the fact is, I will constantly call `rMap.isEmpty()`, and it returns false at previous times which is expected, but suddenly it returns true at one point, even this key has not removed from this map. So is that possible caused by connection issue?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-10-23T10:54:56Z",
        "body": "No, since with connection issue you would get an error"
      }
    ]
  },
  {
    "number": 3155,
    "title": "How to get RLock list? Rkeys is not work",
    "created_at": "2020-10-23T03:58:44Z",
    "closed_at": "2020-11-23T13:47:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3155",
    "body": "Rkeys does not contains RLock keys.  Only me?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3155/comments",
    "author": "shuxiaogang",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-23T14:46:59Z",
        "body": "Please provide code sample to reproduce the issue."
      }
    ]
  },
  {
    "number": 3154,
    "title": "如何重现阿里云集群版redis不支持redisson的错误",
    "created_at": "2020-10-23T02:58:34Z",
    "closed_at": "2020-10-23T04:53:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3154",
    "body": "阿里云集群版redis限制了EVAL命令，按理来说用redisson会报错用不了，但是我测试了没有报错，想问下要怎么重现",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3154/comments",
    "author": "bean326",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-23T04:53:30Z",
        "body": "Please contact your redis vendor"
      }
    ]
  },
  {
    "number": 3144,
    "title": "redisson用阿里云集群版redis的问题",
    "created_at": "2020-10-21T08:35:06Z",
    "closed_at": "2020-10-21T10:19:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3144",
    "body": "阿里云集群版redis限制了使用EVAL命令，以前也测试过确实会报错，但我现在不知道怎么重现那个错误了，想确认下是不是现在redisson底层处理了什么，让它能用阿里云的集群版redis了",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3144/comments",
    "author": "bean326",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-21T10:19:15Z",
        "body": "Eval command is necessary for the most Redisson objects."
      },
      {
        "user": "bean326",
        "created_at": "2020-10-22T07:04:27Z",
        "body": "我申请了一个阿里云的集群版redis来测试，但无论存还是取对象都没有报错，一切正常，有点搞不懂了。。。"
      }
    ]
  },
  {
    "number": 3117,
    "title": "RMapCache.keySet inconsistent behaviour",
    "created_at": "2020-10-10T07:47:19Z",
    "closed_at": "2020-11-11T07:44:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3117",
    "body": "Hello,\r\n\r\nI am using redisson **3.12.5**\r\n\r\nI have this map \"REMOTE_SESSIONS\" and I am trying to access it using getMapCache ( RMapCache )\r\nAfter fetching the map I am querying it's keys , using keySet but I am seeing inconsistent behaviour and I am not sure why.\r\n\r\nI might be using the library wrong but this is driving me crazy :) \r\n\r\nHere is my code\r\n\r\n```\r\n        List<RMapCache> cacheList = new ArrayList<>();\r\n        int count = 10;\r\n        // get 10 caches\r\n        for (int i = 0; i < count; i++) {\r\n            cacheList.add(redissonClient.getMapCache(\"REMOTE_SESSIONS\", StringCodec.INSTANCE));\r\n        }\r\n\r\n        // for each one of them print the keyset\r\n        for (int i = 0; i < count; i++) {\r\n            Set set = cacheList.get(i).keySet(100);\r\n            Iterator iterator = set.iterator();\r\n            int actualCount = 0;\r\n            while (iterator.hasNext()){\r\n                iterator.next();\r\n                actualCount++;\r\n            }\r\n            System.out.println(\"COUNT (from size) = \" + set.size() + \" - COUNT (actual) = \" + actualCount);\r\n        }\r\n```\r\nI am doing the following:\r\n\r\nGet 10 instances of REMOTE_SESSIONS cache. For each of them print the count given by size and then the actual count , retrieved via iterator traversal.\r\n\r\nAnd I get the following output:\r\n\r\n```\r\nCOUNT (from size) = 23 - COUNT (actual) = 23\r\nCOUNT (from size) = 23 - COUNT (actual) = 4\r\nCOUNT (from size) = 23 - COUNT (actual) = 4\r\nCOUNT (from size) = 23 - COUNT (actual) = 4\r\nCOUNT (from size) = 23 - COUNT (actual) = 4\r\nCOUNT (from size) = 23 - COUNT (actual) = 4\r\nCOUNT (from size) = 23 - COUNT (actual) = 23\r\nCOUNT (from size) = 23 - COUNT (actual) = 23\r\nCOUNT (from size) = 23 - COUNT (actual) = 23\r\nCOUNT (from size) = 23 - COUNT (actual) = 23\r\n```\r\n\r\nFor some reason the actual content of the keySet is varying. This might be related to the fact that under the scenes this is implemented using HSCAN but can't really tell why.\r\n\r\nAny idea why this is happening and can I access the keys from a map.\r\n\r\nMy end goal would be to query the keys using a pattern but that doesn't work consistent either.\r\n\r\nAny help is greatly appreciated.\r\nThanks",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3117/comments",
    "author": "mlemnaru",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-12T05:37:27Z",
        "body": "Which Redis version do you use?"
      },
      {
        "user": "mlemnaru",
        "created_at": "2020-10-12T07:28:35Z",
        "body": "We use **Redislabs** , and from the settings page I see this:\r\n\r\n**Redis Version Compliance - 6.0.5**\r\n\r\nSo I am guessing that is the installed redis version.\r\n\r\nWe connect to redis using singleServerConfig. Like so:\r\n\r\n        Config config = new Config();\r\n        config.setNettyThreads(16);\r\n        config.useSingleServer().setAddress(redisHost + \":\" + redisPort)\r\n            .setConnectionPoolSize(connectionPoolSize)\r\n            .setPassword(password);\r\n\r\nBtw: **I recently done some more tests locally using the same config , but locally I have redis 6.0.8 installed and there it does not reproduce.** \r\n\r\nCould it have anything to do with how redislabs is setting up their instances ? \r\n\r\nThanks"
      },
      {
        "user": "mrniko",
        "created_at": "2020-10-12T08:57:40Z",
        "body": "Seems `hscan` command used in LUA-script works wrong in Redislabs's Redis implementation."
      }
    ]
  },
  {
    "number": 3115,
    "title": "Redisson don't switch read operation properly when slave is down",
    "created_at": "2020-10-08T09:55:35Z",
    "closed_at": "2020-10-12T05:35:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3115",
    "body": "I configured master-slave configuration for standalone Redis. readMode = ReadMode.MASTER_SLAVE\r\n\r\nval server = config.useMasterSlaveServers().apply {\r\n    masterAddress = master.uri\r\n    laves.forEach { addSlaveAddress(it.uri) }\r\n    val weights = mutableMapOf<String, Int>()\r\n    slaves.asSequence()\r\n        .map { it.uri to getReadProbabilityOrDefault(it.readProbability) }\r\n        .toMap(weights)\r\n     weights[master.uri] = getReadProbabilityOrDefault(master.readProbability)\r\n     loadBalancer = RoundRobinLoadBalancer()\r\n     readMode = _ReadMode.MASTER_SLAVE_\r\n}\r\n\r\nWhen I do on slave `debug segfault` there aren't operations in a monitor on a master node. Only after timeout in 180000 ms all operations will start to perform on the master node. My code didn't receive any exception from Redisson.\r\n\r\nI can reduce a delay by setting up `failedSlaveCheckInterval = 3000` parameter but why Redisson didn't switch to slave after the first failed command?   \r\nAnd that more important _why Redisson didn't send any command to the master node_?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3115/comments",
    "author": "neismit",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-12T05:35:52Z",
        "body": "> but why Redisson didn't switch to slave after the first failed command?\r\n\r\nIt waits for topology update. In useMasterSlaveServers mode topology is not updated."
      },
      {
        "user": "neismit",
        "created_at": "2020-10-13T08:13:00Z",
        "body": "> It waits for topology update. In useMasterSlaveServers mode topology is not updated.\r\n\r\nHow can I avoid pause?\r\nConfigure standalone Master-slave with another configuration?\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2020-10-13T09:34:35Z",
        "body": "try to use cluster or sentinel mode"
      },
      {
        "user": "neismit",
        "created_at": "2020-10-14T09:39:51Z",
        "body": "> try to use cluster or sentinel mode\r\n\r\nwe use standalone redis without sentinel. Just master node with several read slaves. It's not a cluster.\r\nRedisson don't have any options for that configuration?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-10-14T09:42:44Z",
        "body": "In this case Redisson can't update topology without any info about it."
      }
    ]
  },
  {
    "number": 3113,
    "title": "No interface method addListener (ReactNative module)",
    "created_at": "2020-10-08T08:28:56Z",
    "closed_at": "2020-10-23T16:03:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3113",
    "body": "**Redis version**: 2.7.1 \r\n**Error:**\r\n```\r\n java.lang.NoSuchMethodError: No interface method addListener(Lorg/redisson/api/listener/PatternMessageListener;)I in class Lorg/redisson/api/RPatternTopic; or its super classes (declaration of 'org.redisson.api.RPatternTopic')\r\n```\r\n**Code**\r\n```\r\nimport org.redisson.api.RPatternTopic;\r\nimport org.redisson.api.RedissonClient;\r\nimport org.redisson.api.listener.PatternMessageListener;\r\n\r\nConfig config = Config.fromJSON(jsonConfig);\r\nconfig.setCodec(new StringCodec());\r\nRedissonClient   client = Redisson.create(config);\r\n//M Message String \r\nPatternMessageListener<String> patternMessageListener = TopicListener.create(uuid);\r\n//this function \r\nBoolean success = client.topicSubscribe(topicName, patternMessageListener);\r\n```\r\n\r\n```\r\nimport org.redisson.api.RPatternTopic;\r\nimport org.redisson.api.RedissonClient;\r\nimport org.redisson.api.listener.PatternMessageListener;\r\n<T> Boolean topicSubscribe(final String topicName, final PatternMessageListener<T> listener) throws Exception {\r\n        //topicName = request\r\n        //get topic name according to the listener ID\r\n        Integer listenerId = _listeners.get(topicName);\r\n        WritableMap metaMap = Arguments.createMap();\r\n        //topic name not null => can get can create topic\r\n        //get RPatternTopic \r\n        RPatternTopic<T> topic = client().getPatternTopic(topicName);\r\n        if(topic==null) {\r\n            metaMap.putString(\"isTopicNull\", \"topic is NULL\");\r\n            return false;\r\n        }\r\n        List<String> patternNames =  topic.getPatternNames();\r\n        //got move here\r\n        if(!patternNames.isEmpty()) {\r\n            //patternMaps: request\r\n            metaMap.putString(\"patternMaps\", patternNames.get(0));\r\n        }\r\n        EventEmitter.getInstance().emit(\"redis.log\", metaMap);\r\n\r\n        if(topic !=null) {\r\n            //error at this function cannot find \r\n            int topicId = topic.addListener(listener);\r\n            metaMap.putInt(\"topicId\", topicId);\r\n            EventEmitter.getInstance().emit(\"redis.log\", metaMap);\r\n            _listeners.put(topicName, topicId);\r\n        }\r\n        return true;\r\n  }\r\n```\r\n**Behavior:**\r\n`topic` does find the function getPatternNames(). However, interface method addListener(Lorg/redisson/api/listener/PatternMessageListener) cannot be found in class Lorg/redisson/api/RPatternTopic.\r\n\r\n**Expected Behavior:**\r\naddListener can be found.\r\n\r\nPlease help me, I am in urgent right now. Thank you very much.\r\nI think when compiling code in Android. The function is removed from the interface.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3113/comments",
    "author": "ltphy",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-23T16:03:30Z",
        "body": "I'm afraid I can't help with ReactNative issues."
      }
    ]
  },
  {
    "number": 3110,
    "title": "Is there a way to batch read values from the RMap using key pattern?",
    "created_at": "2020-10-07T20:08:43Z",
    "closed_at": "2020-10-08T06:07:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3110",
    "body": "I'm looking through the documentation and it doesn't seem currently possible to batch multiple values(pattern) calls.\r\nIf this functionality doesn't exist will it be possible to add it in the future versions?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3110/comments",
    "author": "peterlitvak",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-08T06:07:16Z",
        "body": "I'm afraid it's impossible since it's a scan command which can return even empty result for the first call for non empty data. So requires multiple calls."
      }
    ]
  },
  {
    "number": 3109,
    "title": "reddison can not stop my program",
    "created_at": "2020-10-07T19:22:54Z",
    "closed_at": "2020-10-08T13:28:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3109",
    "body": "I wrote a program to test the connection to Redis, it successfully connected to Radis but the program does not stop in the end.\r\n\r\nredisson.yaml\r\n```properties\r\nsingleServerConfig:\r\nidleConnectionTimeout: 10000\r\nconnectTimeout: 10000\r\ntimeout: 3000\r\nretryAttempts: 3\r\nretryInterval: 1500\r\npassword: null\r\nsubscriptionsPerConnection: 5\r\nclientName: null\r\naddress: \"redis://127.0.0.1:6379\"\r\nsubscriptionConnectionMinimumIdleSize: 1\r\nsubscriptionConnectionPoolSize: 50\r\nconnectionMinimumIdleSize: 24\r\nconnectionPoolSize: 64\r\ndatabase: 0\r\ndnsMonitoringInterval: 5000\r\nthreads: 16\r\nnettyThreads: 32\r\ncodec: !<org.redisson.codec.SnappyCodec> {}\r\ntransportMode: \"NIO\" \r\n```\r\n\r\nmy dependency in Gradle:\r\n```Gradle\r\n'org.redisson:redisson-hibernate-52:3.13.5'\r\n```\r\n\r\nwhen Get thread dump, my console:\r\n```console\r\n\"redisson-netty-2-24@7998\" prio=5 tid=0x2e nid=NA runnable\r\n  java.lang.Thread.State: RUNNABLE\r\n\t  at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(WindowsSelectorImpl.java:-1)\r\n\t  at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(WindowsSelectorImpl.java:296)\r\n\t  at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(WindowsSelectorImpl.java:278)\r\n\t  at sun.nio.ch.WindowsSelectorImpl.doSelect(WindowsSelectorImpl.java:159)\r\n\t  at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)\r\n\t  - locked <merged>(a sun.nio.ch.WindowsSelectorImpl)\r\n\t  - locked <merged>(a java.util.Collections$UnmodifiableSet)\r\n\t  - locked <merged>(a io.netty.channel.nio.SelectedSelectionKeySet)\r\n\t  at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)\r\n\t  at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:101)\r\n\t  at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:68)\r\n\t  at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:805)\r\n\t  at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:457)\r\n\t  at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\t  at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\t  at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\t  at java.lang.Thread.run(Thread.java:748) \r\n```\r\n\r\nI think the problem is in netty, but my netty version is final (4.1.52)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3109/comments",
    "author": "taagholi",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-08T06:03:19Z",
        "body": "Is there example code to reproduce it?"
      },
      {
        "user": "taagholi",
        "created_at": "2020-10-08T10:51:36Z",
        "body": "Hiberantate Configuration:\r\n```java\r\nconfiguration.setProperty(Environment.USE_SECOND_LEVEL_CACHE, \"true\");\r\nconfiguration.setProperty(Environment.CACHE_REGION_FACTORY, org.redisson.hibernate.RedissonRegionFactory.class.getName());\r\nconfiguration.setProperty(Environment.CACHE_REGION_PREFIX, \"hibernate\");\r\nconfiguration.setProperty(\"hibernate.cache.redisson.config\", \"redis/redisson.yaml\");\r\n```\r\nEntity\r\n```java\r\nimport org.hibernate.annotations.CacheConcurrencyStrategy;\r\n\r\nimport javax.persistence.*;\r\n\r\n\r\n@Entity\r\n@Cacheable\r\n@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)\r\n@Table(name=\"t_LoanTopic\")\r\npublic class LoanTopic extends com.fanap.domain.shared.Entity{\r\n\r\n    private String modificationDate;\r\n    private String name;\r\n    private Integer percent;\r\n    private String topicCode;\r\n\r\n    public LoanTopic() {\r\n    }\r\n    \r\n    @Column(name=\"c_modificationDate\")\r\n    public String getModificationDate() {\r\n        return this.modificationDate;\r\n    }\r\n\r\n    public void setModificationDate(String modificationDate) {\r\n        this.modificationDate = modificationDate;\r\n    }\r\n\r\n    \r\n    @Column(name=\"c_name\")\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    \r\n    @Column(name=\"c_percent\")\r\n    public Integer getPercent() {\r\n        return this.percent;\r\n    }\r\n\r\n    public void setPercent(Integer percent) {\r\n        this.percent = percent;\r\n    }\r\n\r\n    \r\n    @Column(name=\"c_topicCode\")\r\n    public String getTopicCode() {\r\n        return this.topicCode;\r\n    }\r\n\r\n    public void setTopicCode(String topicCode) {\r\n        this.topicCode = topicCode;\r\n    }\r\n    \r\n\r\n}\r\n```\r\n\r\n```java\r\npublic static void main(String[] args) throws Exception {\r\n        log.info(\"start\");\r\n        HibernateSession session = HibernateManager.createSession();\r\n        try {\r\n            LoanTopic loanTopic = (LoanTopic) session.load(LoanTopic.class, 18416868581L);\r\n        } finally {\r\n            session.close();\r\n        }\r\n        log.info(\"after first load\");\r\n        session = HibernateManager.createSession();\r\n        try {\r\n            LoanTopic loanTopic = (LoanTopic) session.load(LoanTopic.class, 18416868581L);\r\n        } finally {\r\n            session.close();\r\n        }\r\n        log.info(\"waiting for terminate.....\");\r\n    }\r\n```\r\n\r\nbest regards.."
      },
      {
        "user": "mrniko",
        "created_at": "2020-10-08T12:13:55Z",
        "body": "You need to shutdown Hibernate Session factory"
      },
      {
        "user": "taagholi",
        "created_at": "2020-10-08T12:43:45Z",
        "body": "session.close() represent session was closed(shut downed).\r\n\r\nAfter adding the dependency redisson to my project, even if I write a main that only prints Hello world, there is this problem."
      },
      {
        "user": "mrniko",
        "created_at": "2020-10-08T13:27:59Z",
        "body": "call `SessionFactory.close()` method"
      },
      {
        "user": "diddowill",
        "created_at": "2022-08-02T09:41:16Z",
        "body": "Essentially this is still reddisson's problem. I use reddission client directly and meet the same issue. \r\nWith method shutdown() called on reddison client, my program exit normally."
      }
    ]
  },
  {
    "number": 3108,
    "title": "RMap's values(pattern) doesn't seem to work on a simple test",
    "created_at": "2020-10-07T13:18:25Z",
    "closed_at": "2020-11-11T08:12:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3108",
    "body": "The following simple test doesn't seem to work:\r\n```@Test\r\n    public void test() {\r\n\r\n        String mapName = UUID.randomUUID().toString();\r\n        RMap<String, String> map = redissonClient.getMap(mapName, JsonJacksonCodec.INSTANCE);\r\n\r\n        try {\r\n            map.put(\"prefix_1_1_\", \"1\");\r\n            map.put(\"prefix_1_2_\", \"2\");\r\n            map.put(\"prefix_2_3_\", \"3\");\r\n            map.put(\"prefix_2_4_\", \"4\");\r\n\r\n            Collection<String> entries = map.values(\"prefix*\");\r\n\r\n            assertThat(entries).hasSize(4);\r\n        } finally {\r\n            redissonClient.getMap(mapName).delete();\r\n        }\r\n    }\r\n```\r\nVersion of redisson is 3.13.4\r\nI'm pretty sure I'm missing something here so didn't post it as a bug",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3108/comments",
    "author": "peterlitvak",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-07T14:33:27Z",
        "body": "You need to use StringCodec for map keys."
      },
      {
        "user": "peterlitvak",
        "created_at": "2020-10-07T14:42:31Z",
        "body": "Does it mean I need to create my own codec with JsonJacksoCodec for the values (since I need values to be JSON encoded objects) and StringCodec for the keys?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-10-07T14:43:39Z",
        "body": "You can use CompositeCodec to use StringCodec for keys and JsonJacksonCodec for values"
      },
      {
        "user": "peterlitvak",
        "created_at": "2020-10-07T14:44:19Z",
        "body": "Thank you!"
      }
    ]
  },
  {
    "number": 3093,
    "title": "RedissonClient#getMap(String) throws java.io.IOException: Unsupported protocol version 109",
    "created_at": "2020-09-29T12:01:04Z",
    "closed_at": "2020-09-30T11:48:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3093",
    "body": "hello ,\r\n\r\nI am trying to retrieve some data from Redis Instance (which **I use it as Hibernate 2LC**), when I try to get some map data it throws **java.io.IOException**, and message is **Unsupported protocol version 109**.\r\n\r\nhere is my code snippet:\r\n\r\n\t@Inject\r\n\tRedissonClient redissonClient;\r\n\r\n\t@Test\r\n\tpublic void getMap() {\r\n\r\n\t\tString mapKey = \"{query.MyClass.myQuery}:redisson_options\";\r\n\t\tRMap<Object, Object> map = redissonClient.getMap(mapKey);\r\n\t\tassert !map.isEmpty();\r\n\r\n\t\ttry {\r\n\t\t\tmap.forEach((key, value) -> {\r\n\t\t\t\tSystem.out.println(key);\r\n\t\t\t\tSystem.out.println(value);\r\n\t\t\t});\r\n\r\n\t\t}catch (Throwable t) {\r\n\t\t\tSystem.out.println(\r\n\t\t\t\t\tt.getCause().getMessage()\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\nwhich mistakes am I doing while retrieving the data from map?\r\n(datas are put to Redis by Hibernate)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3093/comments",
    "author": "4fath",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-29T13:38:16Z",
        "body": "I wouldn't recommend to modify hibernate local cache data stored in Redis."
      },
      {
        "user": "4fath",
        "created_at": "2020-09-30T11:48:55Z",
        "body": "hi @mrniko ,\r\nI just wanted to change max-size option on the redis. it worked with the following. the issue is, I needed to give Codec when retrieving data.\r\n\r\n        String redisKey = String.format(\"{%s}:redisson_option\", entityOrRegion);\r\n\r\n        RMap<Object, Object> map = client.getMap(redisKey, ByteArrayCodec.INSTANCE);\r\n\r\n        ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);\r\n        buffer.putLong(value);\r\n\r\n        map.put(\"max-size\".getBytes(), buffer.array());\r\n\r\n\r\nisn't it strange? Codec was MarshalingCodec when Hibernate doing things, but if I need to get data, I needed to use different codec.\r\n"
      }
    ]
  },
  {
    "number": 3088,
    "title": "setPingTimeout",
    "created_at": "2020-09-28T07:54:02Z",
    "closed_at": "2020-09-28T08:55:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3088",
    "body": "How to set Ping timeout without setPingTimeout?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3088/comments",
    "author": "cwj-bot",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-28T08:55:10Z",
        "body": "it's renamed to `pingConnectionInterval` setting"
      }
    ]
  },
  {
    "number": 3086,
    "title": "Unable to init enough connections amount! Only 25 from 32 were initialized. Redis server: my-redis-service/11.99.77.00:6379",
    "created_at": "2020-09-27T12:50:59Z",
    "closed_at": "2020-09-28T04:40:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3086",
    "body": "",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3086/comments",
    "author": "liukaifeng",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-28T04:40:27Z",
        "body": "in 3.13.3 version amount of simultaneously created connections during pool initialization reduced to 10. Try the latest version\r\n"
      }
    ]
  },
  {
    "number": 3085,
    "title": "Subscribe timeout: (7500ms)",
    "created_at": "2020-09-27T09:27:24Z",
    "closed_at": "2020-10-06T08:21:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3085",
    "body": "I Increase two params,but it doesn't work.Can you tell me the reason.\r\n\r\nredission version: 3.13.4\r\nerror:\r\n`        org.redisson.client.RedisTimeoutException: Subscribe timeout: (7500ms). Increase 'subscriptionsPerConnection' and/or 'subscriptionConnectionPoolSize' parameters.\r\n\tat org.redisson.command.CommandAsyncService.syncSubscription(CommandAsyncService.java:118) ~[redisson-3.13.4.jar:3.13.4]\r\n\tat org.redisson.RedissonLock.lock(RedissonLock.java:185) ~[redisson-3.13.4.jar:3.13.4]\r\n\tat org.redisson.RedissonLock.lock(RedissonLock.java:147) ~[redisson-3.13.4.jar:3.13.4]`\r\n\r\n\r\nmy config:\r\n`        Config config = new Config();\r\n        String redisUrl = String.format(\"redis://%s:%s\", redisProperties.getHost() + \"\", redisProperties.getPort() +\r\n                \"\");\r\n        config.useSingleServer()\r\n                .setAddress(redisUrl)\r\n                .setDnsMonitoringInterval(-1)\r\n                .setSubscriptionConnectionPoolSize(200)\r\n                .setConnectTimeout(30000).setSubscriptionsPerConnection(5000)\r\n                .setSubscriptionConnectionMinimumIdleSize(64)\r\n                .setPassword(redisProperties.getPassword())\r\n                .setDatabase(redisProperties.getDatabase());`\r\n\r\nmy code:  Multi thread call\r\n`        RLock lock = redissonClient.getLock(lockBizIdKey);\r\n        try {\r\n            lock.lock();\r\n        } catch (Exception e) {\r\n            log.info(\"bizTag = {}\", bizTag, e);\r\n        } finally {\r\n            lock.unlock();\r\n        }`\r\n\r\nI use another redis server ,it works well. which param of redis can effect it?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3085/comments",
    "author": "wittychen",
    "comments": [
      {
        "user": "wittychen",
        "created_at": "2020-09-27T16:38:32Z",
        "body": "Maybe caused by Twemproxy.\r\nHow can I solve this problem.  "
      },
      {
        "user": "mrniko",
        "created_at": "2020-09-28T09:20:42Z",
        "body": "Can you reproduce it without twemproxy?"
      },
      {
        "user": "wittychen",
        "created_at": "2020-09-29T01:57:18Z",
        "body": "> Can you reproduce it without twemproxy?\r\n\r\nIt works well without  twemproxy.\r\nDo you have plans to support twemproxy?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-09-29T06:46:47Z",
        "body": "I'm afraid no. With PRO version you don't need it."
      }
    ]
  },
  {
    "number": 3084,
    "title": " org.redisson.tomcat.RedissonSessionManager.findSession Session can't be found",
    "created_at": "2020-09-26T13:51:11Z",
    "closed_at": "2020-09-29T06:53:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3084",
    "body": "my version  is redisson-all-3.13.4\r\nredisson-tomcat-8-3.13.4\r\n\r\ni have see the close question about this  and try it ,but it does not work.    my webproject is based on SSM+shiro",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3084/comments",
    "author": "Spring1901",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-26T14:36:38Z",
        "body": "could you set `TRACE` logging level for `org.redisson` package and share output?"
      },
      {
        "user": "Spring1901",
        "created_at": "2020-09-27T02:46:40Z",
        "body": "thank you very much, i have find the question ,it is my question. it is ok now,"
      }
    ]
  },
  {
    "number": 3080,
    "title": "ElastiCache fail over with primary/reader endpoints not working with replicatedServersConfig",
    "created_at": "2020-09-24T14:01:54Z",
    "closed_at": "2021-04-12T16:47:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3080",
    "body": "I'm currently working with an ElastiCache Redis Cluster (cluster mode disabled) and I have 3 nodes (1 primary node and 2 replica nodes). I'm working with an application configured with the Redisson Tomcat Session Manager. I'm currently testing the ElastiCache failover. I had to set the retryAttempts to 30, the retryInterval to 1000, and use the 3 node endpoints in the nodeAddresses, but with that I'm able to successfully fail over the ElastiCache cluster without disrupting the application. However, if I use only the primary endpoint (master) and the reader endpoint (replica) in the nodeAddresses an ElastiCache fail over disrupts the application. Are the primary/reader endpoints not supported with the replicatedServersConfig?\r\n\r\nMy configuration for the replicatedServersConfig and context.xml is below:\r\n\r\nreplicatedServersConfig:\r\n  idleConnectionTimeout: 10000\r\n  connectTimeout: 10000\r\n  timeout: 3000\r\n  retryAttempts: 30\r\n  retryInterval: 1000\r\n  failedSlaveReconnectionInterval: 3000\r\n  failedSlaveCheckInterval: 60000\r\n  password: null\r\n  subscriptionsPerConnection: 5\r\n  clientName: null\r\n  loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}\r\n  subscriptionConnectionMinimumIdleSize: 1\r\n  subscriptionConnectionPoolSize: 50\r\n  slaveConnectionMinimumIdleSize: 24\r\n  slaveConnectionPoolSize: 64\r\n  masterConnectionMinimumIdleSize: 24\r\n  masterConnectionPoolSize: 64\r\n  readMode: \"MASTER\"\r\n  subscriptionMode: \"SLAVE\"\r\n  nodeAddresses:\r\n  \"rediss://node-endpoint-1:6379\"\r\n  \"rediss://node-endpoint-2:6379\"\r\n  \"rediss://node-endpoint-3:6379\"\r\n  scanInterval: 1000\r\nthreads: 16\r\nnettyThreads: 32\r\ncodec: !<org.redisson.codec.FstCodec> {}\r\ntransportMode: \"NIO\"\r\n\r\nManager className=\"org.redisson.tomcat.RedissonSessionManager\"\r\n  configPath=\"${catalina.base}/redisson.conf\" \r\n  readMode=\"MEMORY\" updateMode=\"DEFAULT\" broadcastSessionEvents=\"false\"\r\n  keyPrefix=\"\"",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3080/comments",
    "author": "dms486",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-24T14:09:32Z",
        "body": "You need to define all node endpoints in configuration for non-clustered ElastiCache mode."
      },
      {
        "user": "dms486",
        "created_at": "2020-09-24T14:41:58Z",
        "body": "Thanks. If I switch to ElastiCache Redis Cluster (cluster mode enabled) and use clusterServersConfig, will I be able to use the configuration endpoint instead of the node endpoints?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-09-24T17:25:02Z",
        "body": "Sure"
      },
      {
        "user": "dms486",
        "created_at": "2020-10-06T00:33:44Z",
        "body": "@mrniko is it possible to make this a feature request? Would help with maintenance if we could target the primary endpoint instead of the node endpoints directly"
      },
      {
        "user": "mrniko",
        "created_at": "2020-10-06T05:52:36Z",
        "body": "> Would help with maintenance if we could target the primary endpoint instead of the node endpoints directly\r\n\r\nYou can do it in ElastiCache Redis Cluster"
      }
    ]
  },
  {
    "number": 3071,
    "title": "org.redisson.client.WriteRedisConnectionException: Channel has been closed! ",
    "created_at": "2020-09-22T02:32:49Z",
    "closed_at": "2020-11-11T15:09:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3071",
    "body": "When I used 1.11.1 , after application running 2 hour , find this problem\r\n2020-09-21 21:02:32,039-[org.redisson.cluster.ClusterConnectionManager.lambda$updateClusterState$6(ClusterConnectionManager.java:368)]-[ERROR] Can't execute CLUSTER_NODES with 10.1.15.48/10.1.15.48:7000\r\norg.redisson.client.RedisTimeoutException: Command execution timeout for command: (CLUSTER NODES), params: [], Redis client: [addr=redis://10.1.15.48:7000]\r\n\tat org.redisson.client.RedisConnection$1.run(RedisConnection.java:209)\r\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\r\n\tat io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:127)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute$$$capture(AbstractEventExecutor.java:163)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:495)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n\r\norg.redisson.client.WriteRedisConnectionException: Channel has been closed! Can't write command: (CLUSTER NODES), params: [] to channel: [id: 0x4af9e652, L:/10.1.25.43:56984 ! R:10.1.15.48/10.1.15.48:7000]\r\n\tat org.redisson.client.handler.CommandsQueue.channelInactive(CommandsQueue.java:94)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:242)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:228)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:221)\r\n\tat org.redisson.client.handler.ConnectionWatchdog.channelInactive(ConnectionWatchdog.java:82)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:242)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:228)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:221)\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelInactive(ChannelInboundHandlerAdapter.java:75)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:242)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:228)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:221)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1403)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:242)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:228)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:912)\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe$8.run(AbstractChannel.java:827)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute$$$capture(AbstractEventExecutor.java:163)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:495)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n2020-09-21 21:54:37,930-[org.redisson.cluster.ClusterConnectionManager.lambda$updateClusterState$6(ClusterConnectionManager.java:368)]-[ERROR] Can't execute CLUSTER_NODES with 10.1.15.48/10.1.15.48:7000\r\norg.redisson.client.WriteRedisConnectionException: Channel has been closed! Can't write command: (CLUSTER NODES), params: [] to channel: [id: 0x8a46668f, L:0.0.0.0/0.0.0.0:57243 ! R:10.1.15.48/10.1.15.48:7000]\r\n\tat org.redisson.client.handler.CommandsQueue.channelInactive(CommandsQueue.java:94)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:242)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:228)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:221)\r\n\tat org.redisson.client.handler.ConnectionWatchdog.channelInactive(ConnectionWatchdog.java:82)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:242)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:228)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:221)\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelInactive(ChannelInboundHandlerAdapter.java:75)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:242)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:228)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:221)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1403)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:242)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:228)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:912)\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe$8.run(AbstractChannel.java:827)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute$$$capture(AbstractEventExecutor.java:163)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:495)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n2020-09-21 21:54:37,932-[org.redisson.cluster.ClusterConnectionManager.lambda$updateClusterState$6(ClusterConnectionManager.java:368)]-[ERROR] Can't execute CLUSTER_NODES with 10.1.15.48/10.1.15.48:7002\r\norg.redisson.client.WriteRedisConnectionException: Channel has been closed! Can't write command: (CLUSTER NODES), params: [] to channel: [id: 0x02b19048, L:0.0.0.0/0.0.0.0:57089 ! R:10.1.15.48/10.1.15.48:7002]\r\n\tat org.redisson.client.handler.CommandsQueue.channelInactive(CommandsQueue.java:94)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:242)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:228)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:221)\r\n\tat org.redisson.client.handler.ConnectionWatchdog.channelInactive(ConnectionWatchdog.java:82)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:242)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:228)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:221)\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelInactive(ChannelInboundHandlerAdapter.java:75)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:242)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:228)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:221)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1403)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:242)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:228)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:912)\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe$8.run(AbstractChannel.java:827)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute$$$capture(AbstractEventExecutor.java:163)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:495)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n2020-09-21 21:54:37,935-[org.redisson.cluster.ClusterConnectionManager.lambda$updateClusterState$6(ClusterConnectionManager.java:368)]-[ERROR] Can't execute CLUSTER_NODES with 10.1.15.48/10.1.15.48:7001",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3071/comments",
    "author": "LeonardoEzio",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-22T04:26:35Z",
        "body": "I'm afraid there is nothing to do if `Channel has been closed!`"
      },
      {
        "user": "LeonardoEzio",
        "created_at": "2020-09-22T04:38:06Z",
        "body": "How avoid this problem ? "
      },
      {
        "user": "mrniko",
        "created_at": "2020-09-22T04:39:11Z",
        "body": "Check connections amount on Redis side, Redis cpu and memory load"
      },
      {
        "user": "LeonardoEzio",
        "created_at": "2020-09-22T04:40:01Z",
        "body": "This is nothing exception with redis cluster. "
      },
      {
        "user": "LeonardoEzio",
        "created_at": "2020-09-23T03:46:14Z",
        "body": "I still don't know why the channel has been closed !!! my redis cluster is ok during that time "
      }
    ]
  },
  {
    "number": 3068,
    "title": "Increased Logging for Tomcat Session Manager",
    "created_at": "2020-09-21T16:07:43Z",
    "closed_at": "2020-09-21T17:09:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3068",
    "body": "How can I increase the logging from Redisson when using the Tomcat Session Manager? I'm not running into an issue, but just want to know how to do that if needed.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3068/comments",
    "author": "dms486",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-21T16:43:04Z",
        "body": "Redisson uses slf4j-api, so you need to setup slf4j implementation like logback"
      }
    ]
  },
  {
    "number": 3065,
    "title": "Unable to connect to Redis server: 127.0.0.1/127.0.0.1:6379",
    "created_at": "2020-09-21T07:29:17Z",
    "closed_at": "2020-09-22T04:27:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3065",
    "body": " @Bean\r\n    public RedissonClient redissonClient(){\r\n        Config config = new Config();\r\n        String redisUrl = String.format(\"redis://%s:%s\",redisProperties.getHost()+\"\",redisProperties.getPort()+\"\");\r\n        config.useSingleServer().setAddress(redisUrl).setPassword(redisProperties.getPassword());\r\n        config.useSingleServer().setDatabase(3);\r\n        return Redisson.create(config);\r\n    }\r\n\r\n请问这是什么问题呢。。。。",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3065/comments",
    "author": "yanzhisishui",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-21T07:59:14Z",
        "body": "check your network"
      },
      {
        "user": "yanzhisishui",
        "created_at": "2020-09-21T08:24:43Z",
        "body": "我用Redis客户端都可以连上的，springboot里面也可以使用redistemplate，网络没问题呢。很迷茫 不知道为啥会报这个错误，是不是还有其他配置啊？\r\n\r\n\r\n\r\n\r\n------------------&nbsp;原始邮件&nbsp;------------------\r\n发件人: \"Nikita Koksharov\"<notifications@github.com&gt;; \r\n发送时间: 2020年9月21日(星期一) 下午3:59\r\n收件人: \"redisson/redisson\"<redisson@noreply.github.com&gt;; \r\n抄送: \"Never Part Too\"<1481232419@qq.com&gt;; \"Author\"<author@noreply.github.com&gt;; \r\n主题: Re: [redisson/redisson] Unable to connect to Redis server: 127.0.0.1/127.0.0.1:6379 (#3065)\r\n\r\n\r\n\r\n\r\n\r\n \r\ncheck your network\r\n \r\n—\r\nYou are receiving this because you authored the thread.\r\nReply to this email directly, view it on GitHub, or unsubscribe."
      },
      {
        "user": "yanzhisishui",
        "created_at": "2020-09-21T08:35:16Z",
        "body": "找到问题了，我的redis没有密码，把setPassword去掉就行了"
      }
    ]
  },
  {
    "number": 3053,
    "title": "Fail to start with Tomcat8",
    "created_at": "2020-09-15T11:48:33Z",
    "closed_at": "2020-10-01T07:33:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3053",
    "body": "I followed instructions for Tomcat, copied two jars to lib dir, edited context.xml, created conf.yaml, however, keep getting:\r\n\r\n```\r\n15-Sep-2020 11:38:07.402 SEVERE [localhost-startStop-1] org.apache.catalina.core.StandardContext.startInternal The session manager failed to start\r\n org.apache.catalina.LifecycleException: Failed to start component [org.redisson.tomcat.RedissonSessionManager[/coreweb]]\r\n\tat org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:167)\r\n\tat org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5253)\r\n\tat org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\r\n\tat org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:754)\r\n\tat org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:730)\r\n\tat org.apache.catalina.core.StandardHost.addChild(StandardHost.java:734)\r\n\tat org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:980)\r\n\tat org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1852)\r\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.lang.NoClassDefFoundError: com/fasterxml/jackson/core/JsonFactory\r\n\tat org.redisson.config.Config.fromJSON(Config.java:584)\r\n\tat org.redisson.tomcat.RedissonSessionManager.buildClient(RedissonSessionManager.java:342)\r\n\tat org.redisson.tomcat.RedissonSessionManager.startInternal(RedissonSessionManager.java:234)\r\n\tat org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\r\n\t... 12 more\r\nCaused by: java.lang.ClassNotFoundException: com.fasterxml.jackson.core.JsonFactory\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:382)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\r\n\t... 16 more\r\n```\r\nDo I need add more libs to classpath?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3053/comments",
    "author": "bianchi2",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-22T04:29:30Z",
        "body": "com.fasterxml.jackson.core.JsonFactory is already included in `redisson-all.jar`"
      },
      {
        "user": "contentfree",
        "created_at": "2025-01-30T19:03:39Z",
        "body": "I'm suddenly getting this as well, possibly after updating jackson-core to 2.18. \n\nWhat do I need to adjust in my pom.xml to make Redisson happy?"
      }
    ]
  },
  {
    "number": 3049,
    "title": "Is there configs suggestions",
    "created_at": "2020-09-14T06:40:56Z",
    "closed_at": "2020-09-28T04:53:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3049",
    "body": "Hi, is there any suggestions for configuring these 'size' values based on the config of Redis server\r\n- threads\r\n- nettyThreads\r\n- masterConnectionPoolSize\r\n- masterConnectionMinimumIdleSize\r\n- slaveConnectionPoolSize\r\n- slaveConnectionMinimumIdleSize\r\n- subscriptionConnectionPoolSize\r\n- subscriptionConnectionMinimumIdleSize\r\n\r\nFor example, my Redis cluster server:\r\n - 8 vCPU\r\n - 26 GB memory\r\n - 4 instances (2 slots) \r\n - 50 consumers\r\n\r\nI know it may depend on the commands I am using, so I just want to know a basic suggestion.\r\nIs there any formula I can follow for configuring?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3049/comments",
    "author": "ieiayaobb",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-28T04:53:23Z",
        "body": "I'm afraid there is no formula. Settings depend on each use case."
      }
    ]
  },
  {
    "number": 3041,
    "title": "Is redisson-tomcat 3.13.0 compatible with redisson-all 3.12.4?",
    "created_at": "2020-09-09T02:18:06Z",
    "closed_at": "2020-09-09T06:18:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3041",
    "body": "",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3041/comments",
    "author": "Ethns",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-09T06:18:22Z",
        "body": "Yes, since it doesn't use any specific api of 3.13.0"
      }
    ]
  },
  {
    "number": 3036,
    "title": "Migration form 3.12 to 3.13. FST to Marshalling Codec migration without downtime",
    "created_at": "2020-09-07T07:41:52Z",
    "closed_at": "2020-09-08T05:27:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3036",
    "body": "We have multiple instance of web app and all pointing to same AWS Elasticache (redis). When new version deployed some of them will use old Redisson lib (with previous default codec, FST).\r\nAny suggestion appreciate to deploy new version with new codec smoothly without downtime?\r\n\r\nThanks in advance \r\nMarko",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3036/comments",
    "author": "mimarko",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-08T05:27:14Z",
        "body": "Just define FST codec in configuration, so MarshailingCodec won't be used. There is no seamless way for such transition."
      }
    ]
  },
  {
    "number": 3035,
    "title": "appear org.redisson.client.RedisResponseTimeoutException",
    "created_at": "2020-09-07T03:33:12Z",
    "closed_at": "2020-09-28T04:54:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3035",
    "body": "您好：\r\nHello:\r\n\r\n在使用Redisson作为分布式锁时，不定期会出现RedisResponseTimeoutException(具体错误信息如下)，已经按照之前的issue的回答中进行设置，包括设置pingConnectionInterval，以及nettyThreads，但是还是出现了该问题，目前不知道该怎么处理，非常希望能得到您的帮助，非常感谢。\r\n\r\nWhen using Redisson as a distributed lock, RedisResponseTimeoutException will appear from time to time (the specific error message is as follows), which has been set in accordance with the answer to the previous issue, including setting pingConnectionInterval and nettyThreads, but this problem still occurs. I don’t know the How to deal with it, I really hope to get your help, thank you very much.\r\n\r\n**Expected behavior**\r\n\r\n[2020-09-07 10:49:47.411] [http-nio-9023-exec-7] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] [] [] [] - Servlet.service() for servlet [dispatcherServlet] in context with path [/activity/provider] threw exception [Request processing failed; nested exception is org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured after 3 retry attempts. Command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, PrizeActivityServiceImpl:getActivityPrize, 10000, fab0e7c0-940c-423b-af4e-dd86dac6d31f:71], channel: [id: 0x7df78ed5, L:/172.20.2.62:51408 - R:172.18.215.46/172.18.215.46:6389]] with root cause\r\norg.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured after 3 retry attempts. Command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, PrizeActivityServiceImpl:getActivityPrize, 10000, fab0e7c0-940c-423b-af4e-dd86dac6d31f:71], channel: [id: 0x7df78ed5, L:/172.20.2.62:51408 - R:172.18.215.46/172.18.215.46:6389]\r\nat org.redisson.command.RedisExecutor$3.run(RedisExecutor.java:338)\r\nat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)\r\nat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)\r\nat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485)\r\nat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\nat java.lang.Thread.run(Thread.java:748)\r\n\r\n**Redis version**\r\n5.0.5\r\n\r\n**Redisson version**\r\n3.11.5\r\n\r\n**Redisson configuration**\r\n@configuration\r\npublic class RedissonManager {\r\n\r\n@Autowired\r\nprivate RedissonProperties redissonProperties;\r\n\r\n@Bean\r\npublic RedissonClient getRedissonSingle() {\r\n    String address = \"redis://\"+redissonProperties.getHost() + \":\" + redissonProperties.getPort();\r\n    Config config = new Config();\r\n    SingleServerConfig serverConfig = config.useSingleServer()\r\n            .setPingConnectionInterval(1000)\r\n            .setRetryInterval(1000)\r\n            .setRetryAttempts(3)\r\n            .setAddress(address);\r\n    if(StringUtils.isNotBlank(redissonProperties.getPassword())) {\r\n        serverConfig.setPassword(redissonProperties.getPassword());\r\n    }\r\n    config.setCodec(new StringCodec());\r\n    config.setLockWatchdogTimeout(30*1000);\r\n    config.setNettyThreads(64);\r\n    return Redisson.create(config);\r\n}\r\n}",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3035/comments",
    "author": "chenpengliang0909",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-07T05:25:03Z",
        "body": "> 3 retry attempts\r\n\r\nmeans that command is not sent after every attempt in 1000ms as you defined in config. Check your network or try to increase nettyThreads to 96"
      },
      {
        "user": "chenpengliang0909",
        "created_at": "2020-09-08T09:22:52Z",
        "body": "检查网络是正常的，因为缓存的数据是能正常访问的，并且重启客户端应用后，这个异常消失，能正常使用锁了，很奇怪；\r\nchecking the network is normal, because the cached data can be accessed normally, and after restarting the client application, this exception disappears and the lock can be used normally, which is strange"
      },
      {
        "user": "mrniko",
        "created_at": "2020-09-08T09:28:01Z",
        "body": "Do you use `RBatch` object?"
      },
      {
        "user": "chenpengliang0909",
        "created_at": "2020-09-08T09:36:29Z",
        "body": "实现缓存的技术，不是使用Redisson，而是spring data redis；仅使用Redisson实现分布式锁，操作锁的工具类如下：\r\nThe technology to implement caching is not Redisson, but spring data redis; only Redisson is used to implement distributed locks. The tools for operating locks are as follows:\r\n\r\n\r\n@Component\r\npublic class RedissonDistributedLockerUtils {\r\n\r\n    private RedissonDistributedLockerUtils () {}\r\n\r\n    @Autowired\r\n    private RedissonClient redissonClient;\r\n\r\n    private static RedissonDistributedLockerUtils lockerUtils;\r\n\r\n    public static boolean getTryLock(String lockKey, TimeUnit unit, int waitTime, int leaseTime) {\r\n        RLock lock = lockerUtils.redissonClient.getLock(lockKey);\r\n        try {\r\n            return lock.tryLock(waitTime, leaseTime, unit);\r\n        } catch (InterruptedException e) {\r\n            return false;\r\n        }\r\n    }\r\n\t\r\n    public static void unlock(String lockKey) {\r\n        RLock lock = lockerUtils.redissonClient.getLock(lockKey);\r\n        lock.unlock();\r\n    }\r\n\r\n}"
      },
      {
        "user": "chenpengliang0909",
        "created_at": "2020-09-10T02:45:21Z",
        "body": "是否有对应的处理建议呢？\r\nIs there a corresponding treatment suggestion? @mrniko "
      },
      {
        "user": "mrniko",
        "created_at": "2020-09-11T09:38:46Z",
        "body": "Do you use Redisson's implementation of spring data redis API?"
      }
    ]
  },
  {
    "number": 3028,
    "title": "sessionDestroyedMessage  and sessionCreatedMessage question",
    "created_at": "2020-09-02T09:14:02Z",
    "closed_at": "2021-02-24T06:29:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3028",
    "body": "- version: 3.11.6\r\n\r\n- config: \r\n\r\n`\t<Manager className=\"org.redisson.tomcat.RedissonSessionManager\"\r\n\t         configPath=\"${catalina.base}/src/test/webapp/WEB-INF/redisson.yaml\"\r\n\t\t\t readMode=\"REDIS\"\r\n\t\t\t updateMode=\"DEFAULT\"\r\n\t         broadcastSessionEvents=\"true\"/>`\r\n\r\n- question:\r\n\r\nwe have two server: A, B\r\n\r\n1.  when `session.setAttribute(key, value);` on A server\r\n\r\n2.  `session.invalidate();` on B server.  \r\n\r\n3.  `session.setAttribute(key, value);` on A server,\r\n\r\n4. now `session.getAttribute(key);` on B server will return null\r\n\r\nwhy this happened? ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3028/comments",
    "author": "201528013329027",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-11T09:23:57Z",
        "body": "Could you share redisson logs for both servers? (set logging level = `TRACE` for `org.redisson` package)"
      }
    ]
  },
  {
    "number": 3022,
    "title": "Is setAPI executable with multiple threads?",
    "created_at": "2020-09-01T09:17:56Z",
    "closed_at": "2020-09-01T10:03:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3022",
    "body": "Regarding the execution of \"API: org.redisson.api.RBucket#set(V value, long timeToLive, TimeUnit timeUnit)\", is there a way to call multiple using a netty thread?\r\n\r\nI tried the following, but it did not run in multi.\r\n```java\r\nMap<K, V> values = new new HashMap<K, V>();\r\nfor (Entry<K, V> entry : values.entrySet()) {\r\n    bucket.set(ObjectMapper.writeValueAsString(entry.getValue()), 10, TimeUnit.SECONDS);\r\n}\r\n```\r\nredisson.json\r\n```json\r\n{\r\n  \"clusterServersConfig\": {\r\n    \"subscriptionConnectionMinimumIdleSize\": 1,\r\n    \"subscriptionConnectionPoolSize\": 150,\r\n    \"slaveConnectionMinimumIdleSize\": 1,\r\n    \"slaveConnectionPoolSize\": 150,\r\n    \"masterConnectionMinimumIdleSize\": 1,\r\n    \"masterConnectionPoolSize\": 150,\r\n    \"readMode\": \"MASTER_SLAVE\",\r\n    \"nodeAddresses\": [\r\n      \"redis://[redis endpoint]:6379\"\r\n    ],\r\n    \"scanInterval\": 600000,\r\n    \"retryAttempts\": 5,\r\n    \"retryInterval\": 15000\r\n  }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3022/comments",
    "author": "tatsuya-0714",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-01T09:51:51Z",
        "body": "`RBucket.set()` method is fully thread-safe, but I wouldn't recommend to use blocking operations in netty threads"
      }
    ]
  },
  {
    "number": 3018,
    "title": "a question about lock acquisition",
    "created_at": "2020-08-30T15:53:55Z",
    "closed_at": "2020-08-31T14:24:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3018",
    "body": "**I have a question about lock acquisition.**\r\nassume two services A and B acquire locks to access shared resources.\r\n 1. A has acquired the lock.\r\n 2. When B tries to acquire the lock. it will find the lock is held by other service(A).\r\n 3. So B will subscribe to the channel, for acquiring the lock.\r\n 4. before B subscribe to the channel,A release the lock and publish some messages.\r\n**What happens next?**\r\nB is waiting for the messages that is published by the lock holder(A), but A has published the messages and released the lock.\r\nHow did you solve it?\r\n\r\nI'm sorry I didn't understand the source code,Thank you very much for your work.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3018/comments",
    "author": "WongJiYong",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-08-31T14:24:19Z",
        "body": "> before B subscribe to the channel,A release the lock and publish some messages.\r\nWhat happens next?\r\nB is waiting for the messages that is published by the lock holder(A), but A has published the messages and released the lock.\r\nHow did you solve it?\r\n\r\nIt will try to acquire the lock after subscription and then wait for a message on the subscribed pubsub channel."
      }
    ]
  },
  {
    "number": 3010,
    "title": "cannot be cast to org.redisson.api.RMap",
    "created_at": "2020-08-26T03:26:06Z",
    "closed_at": "2020-09-11T04:25:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3010",
    "body": "An error occurred when setting the expiration time ：\r\n   java.lang.ClassCastException: com.model.test.JobRecordRedisEntity cannot be cast to org.redisson.api.RMap\r\n\r\nJobRecordRedisEntity entity = new JobRecordRedisEntity();\r\n            entity.setFireInstanceId(\"q\"+i);\r\n            entity.setJobId(\"111111\");\r\n            entity.setFailcount(4);\r\n            entity.setCreatetime(3333333333333l);\r\n            entity.setScheduleFireTime(\"q\");\r\n            entity.setNextFireTime(\"w\");\r\n            entity.setExecutedTime(\"w\"+i);\r\n            entity.setRunningResult(\"seccess\");\r\n            entity.setMisfired(\"3\");\r\n            entity.setRecordId(\"123456qaz\");\r\n         \r\n            boolean exists = service.isExists(service.get(JobRecordRedisEntity.class, entity.getRecordId()));\r\n            if (exists){\r\n                service.merge(entity);\r\n            }else {\r\n                service.persist(entity);\r\n            }\r\n\r\n            **service.asRMap(entity).expire(3, TimeUnit.SECONDS);**",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3010/comments",
    "author": "mitht",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-11T04:25:53Z",
        "body": "Because `JobRecordRedisEntity` doesn't implement `org.redisson.api.RMap` interface. Use proxy object instead like this:\r\n```\r\nentity = service.persist(entity);\r\n```"
      }
    ]
  },
  {
    "number": 3008,
    "title": "Does redisson work with tomcat singlesignon valve ",
    "created_at": "2020-08-25T16:48:49Z",
    "closed_at": "2020-09-22T04:30:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3008",
    "body": "Hi,\r\nIf we have configured the org.apache.catalina.authenticator.SingleSignOn valve in our application, does Redisson push the ssoId also to Redis? Do we have to make any other configuration changes other than what's mentioned in redisson-tomcat Readme for this to work?\r\nThanks",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3008/comments",
    "author": "ssn2020",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-08-28T11:45:36Z",
        "body": "SingleSignOn stores principal as `javax.security.auth.subject` attribute in Session which is stored in Redis. Let me know if you have any issues. "
      }
    ]
  },
  {
    "number": 3002,
    "title": "Get with byte[] Key",
    "created_at": "2020-08-21T18:01:06Z",
    "closed_at": "2020-09-17T08:03:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3002",
    "body": "Is there an interface I can use to do **_get, set and del_** operations with _byte[]_ keys?\r\n\r\n```java\r\npublic byte[] get(byte[] key) {\r\n      if (key == null) {\r\n         return new byte[0];\r\n      }\r\n      return redissonClient.getBucket(key);\r\n}\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3002/comments",
    "author": "Shabirmean",
    "comments": [
      {
        "user": "michael-o",
        "created_at": "2020-09-11T17:20:09Z",
        "body": "Obviously not. Why don't you convert it to a hex string with `0x` prefixed?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-09-17T08:03:45Z",
        "body": "Each object bounded to String name. I would recommend you to convert byte[] into hex or base64 string."
      }
    ]
  },
  {
    "number": 2997,
    "title": "Delayed queue cannot store data in the target queue on time in cluster mode, but it is normal in single mode",
    "created_at": "2020-08-21T01:57:18Z",
    "closed_at": "2021-12-03T10:23:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2997",
    "body": "In cluster mode, delayed queue can't put the data to the target queue on time. The timeout data will be put into the target queue when the next offer is made\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2997/comments",
    "author": "chaosyoung97",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-01T07:45:41Z",
        "body": "Did you sync time across all application instances which use Redisson client?"
      },
      {
        "user": "chaosyoung97",
        "created_at": "2021-12-03T03:14:30Z",
        "body": "Yes, at present, I use rdelayedqueue. Touch () to avoid this problem, but I don't know if it's right to do so"
      },
      {
        "user": "mrniko",
        "created_at": "2021-12-03T10:23:22Z",
        "body": "You need to keep RDelayedQueue instance, so it can transfer elements to target queue."
      }
    ]
  },
  {
    "number": 2988,
    "title": "Issue in connecting cluster",
    "created_at": "2020-08-19T08:56:18Z",
    "closed_at": "2020-08-21T16:15:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2988",
    "body": "Hi, I am facing error while connecting to cluster.\r\n\r\nIt is giving following error::\r\n\r\njava.lang.IllegalArgumentException: port out of range:-1\r\nat java.net.InetSocketAddress.checkPort(InetSocketAddress.java:143)\r\nat java.net.InetSocketAddress.(InetSocketAddress.java:224)\r\nat org.redisson.client.RedisClient.(RedisClient.java:93)\r\nat org.redisson.connection.MasterSlaveConnectionManager.createClient(MasterSlaveConnectionManager.java:310)\r\nat org.redisson.cluster.ClusterConnectionManager.connect(ClusterConnectionManager.java:150)\r\nat org.redisson.cluster.ClusterConnectionManager.(ClusterConnectionManager.java:81)\r\nat org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:172)\r\nat org.redisson.Redisson.(Redisson.java:103)\r\nat org.redisson.Redisson.create(Redisson.java:133)\r\n\r\n**Actually it not generating ClientPartition.getMasterAddress() properly.**\r\nAddress is //127.0.0.1:8001@18001 as recorded by CLUSTER_NODES, but it reads it as host: 18001 and port=-1.\r\n\r\n**Cluster config from CLUSTER_NODES::**\r\n[ClusterNodeInfo [nodeId=4317f285b359ddc3ac08bb85239924509146e475, address=//127.0.0.1:8003@18003, flags=[SLAVE], slaveOf=4118a348827e6107d7e35522a251fd39c5a8f82b, slotRanges=[]], ClusterNodeInfo [nodeId=2f7b93c80d3721b3fb26fe87bc28ed04a63fe0ec, address=//127.0.0.1:8005@18005, flags=[SLAVE], slaveOf=8b81c3e1acb4e1959a83267540058d1a6bffa12f, slotRanges=[]], ClusterNodeInfo [nodeId=4118a348827e6107d7e35522a251fd39c5a8f82b, address=//127.0.0.1:8001@18001, flags=[MASTER], slaveOf=null, slotRanges=[[5461-10922]]], ClusterNodeInfo [nodeId=a0770863d893a5b8106a83e247cea2544f99ef36, address=//127.0.0.1:8004@18004, flags=[SLAVE], slaveOf=6b9da1bbe38b978a3017406e5c1e310f4706cfc8, slotRanges=[]], ClusterNodeInfo [nodeId=8b81c3e1acb4e1959a83267540058d1a6bffa12f, address=//127.0.0.1:8000@18000, flags=[MYSELF, MASTER], slaveOf=null, slotRanges=[[0-5460]]], ClusterNodeInfo [nodeId=6b9da1bbe38b978a3017406e5c1e310f4706cfc8, address=//127.0.0.1:8002@18002, flags=[MASTER], slaveOf=null, slotRanges=[[10923-16383]]]]\r\n\r\n**My code is ::**\r\nConfig config = new Config();\r\nconfig.useClusterServers()\r\n.addNodeAddress(\"redis://127.0.0.1:8000\");\r\nRedissonClient redisson = Redisson.create(config);\r\n\r\nRMap<String, String> map = redisson.getMap(\"simpleMap\");\r\nmap.put(\"mapKey\", \"This is a map value\");\r\nString mapValue = map.get(\"mapKey\");\r\nSystem.out.println(\"stored map value: \" + mapValue);\r\nredisson.shutdown();\r\n\r\nAlso, tried with \r\n.addNodeAddress(\"127.0.0.1:8000\");\r\n\r\n**Dependencies::**\r\n\r\n <dependency>\r\n     <groupId>org.redisson</groupId>\r\n     <artifactId>redisson</artifactId>\r\n     <version>2.3.0</version>\r\n </dependency>\r\n\r\nLet me know if any other detail is required.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2988/comments",
    "author": "NitinK91",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-08-19T09:47:28Z",
        "body": "Unable to reproduce it with latest version"
      },
      {
        "user": "NitinK91",
        "created_at": "2020-08-19T10:34:50Z",
        "body": "Thanks @mrniko .\r\n\r\nPlease suggest the solution.\r\n\r\nI am using java 8.\r\n\r\nThe issue is URI.create //127.0.0.1:8001@18001 makes it host- 18001 i.e reading the cluster bus port."
      },
      {
        "user": "mrniko",
        "created_at": "2020-08-21T16:15:29Z",
        "body": "> Please suggest the solution\r\n\r\nUpdate to the latest version. 2.x version line is not supported"
      }
    ]
  },
  {
    "number": 2985,
    "title": "redisson-spring-boot-starter 依赖 setIfAbsent 返回null",
    "created_at": "2020-08-18T09:29:29Z",
    "closed_at": "2020-08-18T09:53:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2985",
    "body": "mvn 依赖redisson-spring-boot-starter以后\r\nredisTemplate.opsForValue().setIfAbsent 返回null， 但是值已经被设置。\r\n这是什么问题？",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2985/comments",
    "author": "seominho77",
    "comments": [
      {
        "user": "freshgeek",
        "created_at": "2021-08-27T09:18:12Z",
        "body": "什么原因说下？\r\n\r\n> mvn 依赖redisson-spring-boot-starter以后\r\n> redisTemplate.opsForValue().setIfAbsent 返回null， 但是值已经被设置。\r\n> 这是什么问题？\r\n\r\n"
      }
    ]
  },
  {
    "number": 2976,
    "title": "slave ***** has been disconnected after 500 ms interval since moment of the first failed connection",
    "created_at": "2020-08-12T01:48:38Z",
    "closed_at": "2020-08-12T12:17:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2976",
    "body": "redisson version 3.13.3 \r\nAfter upgrading to 3.13.3, the problem has not been solved.\r\nReport an error every morning, usually once. Both errors occur at the same time.\r\n\r\nerror 1：\r\nslave **** has been disconnected after 500 ms interval since moment of the first failed connection.\r\nerror2:\r\norg.redisson.client.RedisConnectionException:SlaveConnectionPool no available Redis entries.  Disconnected hosts: [*****]\r\nat org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:219)\r\nat org.redisson.connection.pool.SlaveConnectionPool.get(SlaveConnectionPool.java:30)\r\nat org.redisson.connection.balancer.LoadBalancerManager.nextConnection(LoadBalancerManager.java:248)\r\nat org.redisson.connection.MasterSlaveEntry.connectionReadOp(MasterSlaveEntry.java:464)\r\nat org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:621)\r\nat org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:644)\r\nat org.redisson.command.RedisExecutor.execute(RedisExecutor.java:116)\r\nat org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:244)\r\nat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)\r\nat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)\r\nat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485)\r\nat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\nat java.lang.Thread.run(Thread.java:748)\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2976/comments",
    "author": "cwj-bot",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-08-12T04:22:38Z",
        "body": "I would recommend you to check your network or increase `failedSlaveCheckInterval` setting"
      }
    ]
  },
  {
    "number": 2975,
    "title": "Change hostname or port at runtime",
    "created_at": "2020-08-11T22:31:29Z",
    "closed_at": "2020-08-21T15:31:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2975",
    "body": "Is there any way to change the redissonClient hostname at runtime and force the connexion to the new ip:port ?\r\n\r\nI tried to remove listener from the previous client, shutdown and then create a new RedissonClient and a listener with the updated config but when I receive the first message, Redisson is shutdown and throw an exception. \r\n\r\nIt is possible to use the @RefreshScope from spring boot to achieve this goal ?\r\n\r\nThanks you ! ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2975/comments",
    "author": "gh-axel-czarniak",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-08-12T12:30:20Z",
        "body": "> I tried to remove listener from the previous client, shutdown and then create a new RedissonClient and a listener with the updated config but when I receive the first message, Redisson is shutdown and throw an exception.\r\n\r\nI think you use previous instance of Redisson in this case."
      }
    ]
  },
  {
    "number": 2974,
    "title": "can i use spring.redis.pool.size to  change connectionPoolSize?",
    "created_at": "2020-08-11T10:24:34Z",
    "closed_at": "2020-08-17T07:22:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2974",
    "body": "can i use spring.redis.pool.size to  change connectionPoolSize? although use redisson.yaml can set this parameter. however, I want to only set parameters in application.properties, then i can put application.properties in git which used in spring-cloud-config.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2974/comments",
    "author": "gaoyang143",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-08-11T10:32:31Z",
        "body": "I'm afraid no, use redisson.yaml config instead:\r\n\r\nspring.redis.redisson.config=classpath:redisson.yaml"
      }
    ]
  },
  {
    "number": 2971,
    "title": "tryLock设置5分钟超时，但是一分钟没到锁就自动释放了。",
    "created_at": "2020-08-10T10:15:05Z",
    "closed_at": "2020-09-10T08:05:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2971",
    "body": "```\r\ntry{\r\n      lock.tryLock(300, TimeUnit.SECONDS);\r\n      Thread.sleep(60000L);\r\n    } catch (InterruptedException e) {\r\n      System.out.println(\"timeout!\")\r\n    } finally {\r\n      lock.unlock();\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2971/comments",
    "author": "shizhengchao",
    "comments": [
      {
        "user": "qq31715879",
        "created_at": "2020-09-07T01:48:38Z",
        "body": "问题定位到了吗"
      },
      {
        "user": "mrniko",
        "created_at": "2020-09-07T05:40:45Z",
        "body": "unable to reproduce"
      },
      {
        "user": "shizhengchao",
        "created_at": "2020-09-07T07:12:01Z",
        "body": "> 问题定位到了吗\r\n\r\n定位到了，因为Redession的RLock继承了java的Lock类，而Lock类里的tryLock是两个参数（申请锁的超时时间，单位），并没有锁的过期时间的设置，所以当使用了两个参数的tryLock，就调用到了Lock类的实现上去了。所以应该用tryLock(long waitTime, long leaseTime, TimeUnit unit),三个参数的。"
      }
    ]
  },
  {
    "number": 2970,
    "title": "Not able to  remove custom object from RScoredSortedSet JAVA",
    "created_at": "2020-08-10T03:57:27Z",
    "closed_at": "2020-08-11T05:59:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2970",
    "body": "`RScoredSortedSet<CustomObj> set = redisson.getScoredSortedSet(key);\r\nCustomObj obj = new CustomObj(1,2);\r\nset.add(obj);\r\n\r\nset.remove(obj); // this is not removing obj from sorted set`\r\n\r\n\r\nI have code like above in my application. i am not able to remove custom obj from RScoredSortedSet.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2970/comments",
    "author": "kakadiyahardik",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-08-10T04:57:31Z",
        "body": "Unable to reproduce it. could you share test code?"
      },
      {
        "user": "kakadiyahardik",
        "created_at": "2020-08-11T04:28:06Z",
        "body": "public class Data {\r\n    private String id;\r\n    private String type;\r\n    private long expireAt;\r\n\r\n    public Data(String id, String type, long expireAt) {\r\n        this.id = id;\r\n        this.type = type;\r\n        this.expireAt = expireAt;\r\n    }\r\n\r\n    public Data() {\r\n    }\r\n\r\n// gettter & setter\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (this == obj)\r\n            return true;\r\n        if (obj == null)\r\n            return false;\r\n        if (getClass() != obj.getClass())\r\n            return false;\r\n        Data data2 = (Data) obj;\r\n        if (id == null) {\r\n            return data2.id == null;\r\n        } else return id.equals(data2.id);\r\n    }\r\n}\r\n\r\nRScoredSortedSet<Data> set = redisson.getScoredSortedSet(key);\r\nData a = new Data(\"1\",\"a\",0);\r\nset.add(0,a);\r\n\r\nData b = new Data(\"2\",\"a\",0);\r\nset.add(0,b);\r\n\r\nData c = new Data(\"3\",\"a\",0);\r\nset.add(0,c);\r\n\r\n// now i am trying to delete data with id =1\r\nset.remove(a);\r\n\r\n// its not removing data object with id 1 from set.\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2020-08-11T05:59:06Z",
        "body": "Unable to reproduce. I used default codec and latest Redisson version. Here is my test:\r\n\r\n```java\r\n    public static class Data implements Serializable {\r\n        private String id;\r\n        private String type;\r\n        private long expireAt;\r\n\r\n        public Data(String id, String type, long expireAt) {\r\n            this.id = id;\r\n            this.type = type;\r\n            this.expireAt = expireAt;\r\n        }\r\n\r\n        public Data() {\r\n        }\r\n\r\n    // gettter & setter\r\n\r\n        @Override\r\n        public boolean equals(Object obj) {\r\n            if (this == obj)\r\n                return true;\r\n            if (obj == null)\r\n                return false;\r\n            if (getClass() != obj.getClass())\r\n                return false;\r\n            Data data2 = (Data) obj;\r\n            if (id == null) {\r\n                return data2.id == null;\r\n            } else return id.equals(data2.id);\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void test1() {\r\n        RScoredSortedSet<Data> set = redisson.getScoredSortedSet(\"test\");\r\n        Data a = new Data(\"1\",\"a\",0);\r\n        set.add(0,a);\r\n\r\n        Data b = new Data(\"2\",\"a\",0);\r\n        set.add(0,b);\r\n\r\n        Data c = new Data(\"3\",\"a\",0);\r\n        set.add(0,c);\r\n\r\n        // now i am trying to delete data with id =1\r\n        assertThat(set.remove(a)).isTrue();\r\n    }\r\n\r\n```"
      }
    ]
  },
  {
    "number": 2967,
    "title": "when i try batch persist, but return result is not correct. please help .thanks.",
    "created_at": "2020-08-07T03:23:01Z",
    "closed_at": "2020-08-07T08:40:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2967",
    "body": "code like as below:\r\n---------------------------------------------------------------------------------------------------\r\n// batch persist\r\nList<XXXXXX> persistResut = RLiveObjectService.persist(XXXXXX1, XXXXX2, XXXXX3);\r\n// story result\r\nMap<XXXXXX> map = RedissonLocalCacheMap;\r\n\r\nfor(XXXX xxx : persistResut){\r\n\tmap.put(xxx.id, xxxx);\r\n}\r\n---------------------------------------------------------------------------------------------------\r\nresult will throw exception:\r\nException in thread java.lang.IllegalArgumentException: REntity should be attached to Redisson before save.\r\n\r\ni think ,current object:xxx always java object, not link to redisson object , if i add some code ,will be normal. \r\neg:\r\nfor(XXXX xxx : persistResut){\r\n        // new link to redisson object\r\n        xxx = RLiveObjectService.get(XXXXX, PersistName);\r\n\tmap.put(xxx.id, xxxx);\r\n}\r\n\r\nso i think batch persist result why not link to redisson object automatic ?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2967/comments",
    "author": "tanrui988",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-08-07T03:39:01Z",
        "body": "You can't pass RedissonLocalCacheMap as Live objects to `RLiveObjectService.persist` method."
      }
    ]
  },
  {
    "number": 2966,
    "title": "function: RLiveObjectService.persist() ,why not have batch method? someone can help me ? persist very slowly one by one.",
    "created_at": "2020-08-06T10:04:18Z",
    "closed_at": "2020-08-06T10:26:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2966",
    "body": "",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2966/comments",
    "author": "tanrui988",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-08-06T10:26:06Z",
        "body": "In latest version this method accepts multiple objects and store them in batch."
      }
    ]
  },
  {
    "number": 2961,
    "title": "The value stored in RedIS is different from the target value",
    "created_at": "2020-08-05T09:01:14Z",
    "closed_at": "2020-08-05T09:48:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2961",
    "body": "target：aaa\r\nstored in redis ：\\xFC\\x01aaa\r\n\r\n```\r\nRBucket<Object result = thisredissonClient.getBucket(key)\r\nif(!resultisExists()){\r\n  result.set(\"aaa\",5,TimeUnit.MINUTES);\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2961/comments",
    "author": "boboanyko",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-08-05T09:48:44Z",
        "body": "that's expected since MarshallingCodec is used by default. you need to use StringCodec instead"
      }
    ]
  },
  {
    "number": 2946,
    "title": "Caused by: java.io.IOException: java.io.IOException: Failed to read the next byte at org.redisson.codec.FstCodec",
    "created_at": "2020-07-29T07:02:04Z",
    "closed_at": "2020-08-03T06:42:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2946",
    "body": "Using Redisson client to connect to the Redis server. My Java Object has changed recently, added a new variable into my Java Object.\r\nStarted seeing this exception since then. How can I use the updated Object.\r\n\r\nCaused by: java.io.IOException: java.io.IOException: Failed to read the next byte\r\n\tat org.redisson.codec.FstCodec$FSTDefaultStreamCoderFactory$1.readStringUTF(FstCodec.java:146) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.nustaq.serialization.FSTClazzNameRegistry.decodeClass(FSTClazzNameRegistry.java:168) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.coders.FSTStreamDecoder.readClass(FSTStreamDecoder.java:478) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readClass(FSTObjectInput.java:939) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:347) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:713) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:566) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245) ~[fst-2.57.jar:?]\r\n\tat org.redisson.codec.FstCodec$1.decode(FstCodec.java:250) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:378) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:422) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:387) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:422) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:387) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:209) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:147) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) ~[netty-codec-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) ~[netty-codec-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:648) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:583) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:500) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897) ~[netty-common-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.31.Final.jar:4.1.31.Final]\r\n\tat java.lang.Thread.run(Thread.java:748) ~[?:1.8.0_181]\r\nCaused by: java.io.IOException: Failed to read the next byte\r\n\tat org.nustaq.serialization.coders.FSTStreamDecoder.readFByte(FSTStreamDecoder.java:294) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.coders.FSTStreamDecoder.readFInt(FSTStreamDecoder.java:252) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.coders.FSTStreamDecoder.readStringUTF(FSTStreamDecoder.java:77) ~[fst-2.57.jar:?]\r\n\tat org.redisson.codec.FstCodec$FSTDefaultStreamCoderFactory$1.readStringUTF(FstCodec.java:142) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.nustaq.serialization.FSTClazzNameRegistry.decodeClass(FSTClazzNameRegistry.java:168) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.coders.FSTStreamDecoder.readClass(FSTStreamDecoder.java:478) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readClass(FSTObjectInput.java:939) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:347) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:713) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:566) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311) ~[fst-2.57.jar:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245) ~[fst-2.57.jar:?]\r\n\tat org.redisson.codec.FstCodec$1.decode(FstCodec.java:250) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:378) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:422) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:387) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:422) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:387) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:209) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:147) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) ~[redisson-3.11.5.jar:3.11.5]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) ~[netty-codec-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) ~[netty-codec-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:648) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:583) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:500) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462) ~[netty-transport-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897) ~[netty-common-4.1.31.Final.jar:4.1.31.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.31.Final.jar:4.1.31.Final]\r\n\tat java.lang.Thread.run(Thread.java:748) ~[?:1.8.0_181]\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2946/comments",
    "author": "skkumbha7",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-07-29T08:50:58Z",
        "body": "You need to recreate cache or use jackson codec"
      }
    ]
  },
  {
    "number": 2945,
    "title": "Failure on ProxyJCacheConfiguration",
    "created_at": "2020-07-28T20:15:02Z",
    "closed_at": "2020-07-29T15:03:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2945",
    "body": "Hello,\r\nI have an application on Spring boot 2.2.6 using Caffeine Cache with `@EnableCaching` and `@Cachable` annotations.\r\n\r\n```\r\n@Bean\r\n    fun cacheManager(caffeineConfig: CaffeineConfig): CacheManager {\r\n        val caches: MutableList<CaffeineCache> = ArrayList()\r\n        for (cacheMap in caffeineConfig.caches) {\r\n            val entry: Map.Entry<String, String> = cacheMap.entries.iterator().next()\r\n            val cacheName: String = entry.key\r\n            val cacheSpec: CaffeineSpec = CaffeineSpec.parse(entry.value)\r\n            val caffeineCache: CaffeineCache = CaffeineCache(cacheName, Caffeine.from(cacheSpec).recordStats().build())\r\n            caches.add(caffeineCache)\r\n        }\r\n\r\n        val simpleCacheManager: SimpleCacheManager = SimpleCacheManager()\r\n        simpleCacheManager.setCaches(caches)\r\n        return simpleCacheManager\r\n    }\r\n```\r\n\r\nAnd I'm trying to integrate redisson 3.12.5 to only read from a Redis cache.\r\n```\r\n@Bean\r\n    @Profile(\"!dev\")\r\n    fun reboundDataCache(): RedissonClient {\r\n        val config = Config()\r\n        config.useClusterServers()\r\n            .addNodeAddress(this.redisHost)\r\n            .setReadMode(ReadMode.MASTER_SLAVE)\r\n            .setTimeout(this.readTimeout)\r\n            .setConnectTimeout(this.connectTimeout)\r\n            .setCheckSlotsCoverage(false)\r\n\r\n        return Redisson.create(config)\r\n    }\r\n```\r\nWhen the app is starting up I'm getting this error and the app fails to start:\r\n\r\n```\r\n020-07-28 16:42:14.305 main ERROR org.springframework.boot.SpringApplication Application run failed\r\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'meterRegistryPostProcessor' defined in class path resource [org/springframework/boot/actuate/autoconfigure/metrics/MetricsAutoConfiguration.class]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.cache.annotation.ProxyCachingConfiguration': Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.cache.config.internalJCacheAdvisor' defined in class path resource [org/springframework/cache/jcache/config/ProxyJCacheConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor]: Factory method 'cacheAdvisor' threw exception; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'jCacheOperationSource' defined in class path resource [org/springframework/cache/jcache/config/ProxyJCacheConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.cache.jcache.interceptor.JCacheOperationSource]: Factory method 'cacheOperationSource' threw exception; nested exception is java.lang.NoSuchFieldError: cacheManager\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:603)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:207)\r\n\tat org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(PostProcessorRegistrationDelegate.java:240)\r\n\tat org.springframework.context.support.AbstractApplicationContext.registerBeanPostProcessors(AbstractApplicationContext.java:722)\r\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:535)\r\n\tat org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:66)\r\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747)\r\n\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397)\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:315)\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1226)\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1215)\r\n\tat com.expedia.api.customer.ApplicationKt.main(Application.kt:17)\r\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.cache.annotation.ProxyCachingConfiguration': Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.cache.config.internalJCacheAdvisor' defined in class path resource [org/springframework/cache/jcache/config/ProxyJCacheConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor]: Factory method 'cacheAdvisor' threw exception; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'jCacheOperationSource' defined in class path resource [org/springframework/cache/jcache/config/ProxyJCacheConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.cache.jcache.interceptor.JCacheOperationSource]: Factory method 'cacheOperationSource' threw exception; nested exception is java.lang.NoSuchFieldError: cacheManager\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:603)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:409)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1338)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1177)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:207)\r\n\tat org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans(BeanFactoryAdvisorRetrievalHelper.java:91)\r\n\tat org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findCandidateAdvisors(AbstractAdvisorAutoProxyCreator.java:109)\r\n\tat org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findEligibleAdvisors(AbstractAdvisorAutoProxyCreator.java:94)\r\n\tat org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean(AbstractAdvisorAutoProxyCreator.java:76)\r\n\tat org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:347)\r\n\tat org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:299)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:431)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1800)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595)\r\n\t... 15 more\r\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.cache.config.internalJCacheAdvisor' defined in class path resource [org/springframework/cache/jcacDisconnected from the target VM, address: '127.0.0.1:57790', transport: 'socket'\r\n```\r\n\r\nAny clue?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2945/comments",
    "author": "charlesdmir",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-07-29T04:22:35Z",
        "body": "> Failed to instantiate [org.springframework.cache.jcache.interceptor.JCacheOperationSource]: Factory method 'cacheOperationSource' threw exception; nested exception is java.lang.NoSuchFieldError: cacheManager\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:603)\r\n\r\nMake sure you don't have two different versions of spring in classpath"
      },
      {
        "user": "charlesdmir",
        "created_at": "2020-07-29T14:42:21Z",
        "body": "I checked, and this is what I have from spring \r\n```\r\norg.springframework.boot:spring-boot-actuator-autoconfigure:jar:2.2.6.RELEASE:compile\r\norg.springframework.boot:spring-boot-actuator:jar:2.2.6.RELEASE:compile\r\norg.springframework.boot:spring-boot-autoconfigure:jar:2.2.6.RELEASE:compile\r\norg.springframework.boot:spring-boot-configuration-processor:jar:2.2.6.RELEASE:compile\r\norg.springframework.boot:spring-boot-starter-actuator:jar:2.2.6.RELEASE:compile\r\norg.springframework.boot:spring-boot-starter-json:jar:2.2.6.RELEASE:compile\r\norg.springframework.boot:spring-boot-starter-log4j2:jar:2.2.6.RELEASE:compile\r\norg.springframework.boot:spring-boot-starter-reactor-netty:jar:2.2.6.RELEASE:compile\r\norg.springframework.boot:spring-boot-starter-test:jar:2.2.6.RELEASE:test\r\norg.springframework.boot:spring-boot-starter-validation:jar:2.2.6.RELEASE:compile\r\norg.springframework.boot:spring-boot-starter-webflux:jar:2.2.6.RELEASE:compile\r\norg.springframework.boot:spring-boot-starter:jar:2.2.6.RELEASE:compile\r\norg.springframework.boot:spring-boot-test-autoconfigure:jar:2.2.6.RELEASE:test\r\norg.springframework.boot:spring-boot-test:jar:2.2.6.RELEASE:test\r\norg.springframework.boot:spring-boot:jar:2.2.6.RELEASE:compile\r\norg.springframework.cloud:spring-cloud-commons:jar:2.2.0.RC1:compile\r\norg.springframework.cloud:spring-cloud-context:jar:2.2.0.RC1:compile\r\norg.springframework.cloud:spring-cloud-starter-vault-config:jar:2.2.0.RC1:compile\r\norg.springframework.cloud:spring-cloud-starter:jar:2.2.0.RC1:compile\r\norg.springframework.cloud:spring-cloud-vault-config:jar:2.2.0.RC1:compile\r\norg.springframework.security.oauth:spring-security-oauth2:jar:2.3.7.RELEASE:compile\r\norg.springframework.security:spring-security-config:jar:5.2.2.RELEASE:compile\r\norg.springframework.security:spring-security-core:jar:5.2.2.RELEASE:compile\r\norg.springframework.security:spring-security-crypto:jar:5.2.2.RELEASE:compile\r\norg.springframework.security:spring-security-rsa:jar:1.0.7.RELEASE:compile\r\norg.springframework.vault:spring-vault-core:jar:2.2.0.RC1:compile\r\norg.springframework:spring-aop:jar:5.2.5.RELEASE:compile\r\norg.springframework:spring-beans:jar:5.2.5.RELEASE:compile\r\norg.springframework:spring-context-support:jar:4.3.14.RELEASE:compile\r\norg.springframework:spring-context:jar:5.2.5.RELEASE:compile\r\norg.springframework:spring-core:jar:5.2.5.RELEASE:compile\r\norg.springframework:spring-expression:jar:5.2.5.RELEASE:compile\r\norg.springframework:spring-jcl:jar:5.2.5.RELEASE:compile\r\norg.springframework:spring-test:jar:5.2.5.RELEASE:test\r\norg.springframework:spring-web:jar:5.2.5.RELEASE:compile\r\norg.springframework:spring-webflux:jar:5.2.5.RELEASE:compile\r\n```"
      },
      {
        "user": "charlesdmir",
        "created_at": "2020-07-29T15:03:07Z",
        "body": "A colleague found it on my comment the discrepancy on versions:\r\n```\r\norg.springframework:spring-context-support:jar:4.3.14.RELEASE:compile\r\norg.springframework:spring-context:jar:5.2.5.RELEASE:compile\r\n```"
      },
      {
        "user": "sunnyding602",
        "created_at": "2023-09-07T22:22:24Z",
        "body": "Thank you soooo much! I had the same issue, after I upgrading spring-context-support and spring-context to the same version the issue disappeared. I will want to figure out where it's trying to creating the ProxyJCacheConfiguration class"
      }
    ]
  },
  {
    "number": 2943,
    "title": "ExecutorService - how to specify workers",
    "created_at": "2020-07-28T09:36:15Z",
    "closed_at": "2020-08-28T12:31:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2943",
    "body": "hi, I wonder what does the workers mean when I register a worker:\r\n```\r\n WorkerOptions options = WorkerOptions.defaults()\r\n    // Defines workers amount used to execute tasks.\r\n    // Default is 1.\r\n    .workers(2)\r\n```\r\nDo I have to specify all the workers that might be registered into this cluster? The problem is that the auto-scaling strategy makes it hard to specify the number of all workers, because the number varies in runtime.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2943/comments",
    "author": "darknessp",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-07-28T10:08:36Z",
        "body": "it means units used to execute tasks and executed on shared executorService (threads amount defined in threads settings)."
      },
      {
        "user": "darknessp",
        "created_at": "2020-07-29T01:46:57Z",
        "body": "> it means units used to execute tasks and executed on shared executorService (threads amount defined in threads settings).\r\n\r\nwhat's its scope? single jvm or the whole cluster?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-07-29T04:22:53Z",
        "body": "jvm"
      }
    ]
  },
  {
    "number": 2942,
    "title": "redission 释放锁出错",
    "created_at": "2020-07-27T01:38:05Z",
    "closed_at": "2020-07-27T05:05:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2942",
    "body": "java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: 5a6318da-6385-4436-8f10-075c6b714929 thread-id: 183\r\norg.redisson.RedissonLock.unlock(RedissonLock.java:367)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2942/comments",
    "author": "gediaogege",
    "comments": [
      {
        "user": "wangwei-ying",
        "created_at": "2020-07-27T02:48:37Z",
        "body": ",,,提示很明显了吧,, 不是这个线程加的锁,无法释放\r\n"
      }
    ]
  },
  {
    "number": 2940,
    "title": "org.redisson.client.RedisTimeoutException  use RLock",
    "created_at": "2020-07-24T06:38:32Z",
    "closed_at": "2020-08-28T12:33:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2940",
    "body": "**Environment Info:**\r\n\r\nredis-server:4.0.11\r\nredission-version:3.12.0\r\nconfig:\r\nclusterServersConfig:\r\n  idleConnectionTimeout: 10000\r\n  pingTimeout: 1000\r\n  connectTimeout: 10000\r\n  timeout: 3000\r\n  retryAttempts: 3\r\n  retryInterval: 1500\r\n  subscriptionsPerConnection: 5\r\n  sslEnableEndpointIdentification: true\r\n  sslProvider: \"JDK\"\r\n  pingConnectionInterval: 60000\r\n  keepAlive: false\r\n  tcpNoDelay: false\r\n  loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}\r\n  slaveConnectionMinimumIdleSize: 24\r\n  slaveConnectionPoolSize: 64\r\n  failedSlaveReconnectionInterval: 3000\r\n  failedSlaveCheckInterval: 180000\r\n  masterConnectionMinimumIdleSize: 24\r\n  masterConnectionPoolSize: 64\r\n  readMode: \"SLAVE\"\r\n  subscriptionMode: \"MASTER\"\r\n  subscriptionConnectionMinimumIdleSize: 1\r\n  subscriptionConnectionPoolSize: 50\r\n  dnsMonitoringInterval: 5000\r\n  natMap: {}\r\n  nodeAddresses:\r\n  - \"redis://x.x.x.22:6370\"\r\n  - \"redis://x.x.x.23:6370\"\r\n  - \"redis://x.x.x.24:6370\"\r\n  - \"redis://x.x.x.25:6370\"\r\n  - \"redis://x.x.x.26:6370\"\r\n  - \"redis://x.x.x.27:6370\"\r\n  scanInterval: 2000\r\n  checkSlotsCoverage: false\r\n  slaveSubscriptionConnectionPoolSize: 50\r\n  slaveSubscriptionConnectionMinimumIdleSize: 1\r\nthreads: 16\r\nnettyThreads: 32\r\nreferenceEnabled: true\r\ntransportMode: \"NIO\"\r\nlockWatchdogTimeout: 30000\r\nkeepPubSubOrder: true\r\ndecodeInExecutor: false\r\nuseScriptCache: false\r\nminCleanUpDelay: 5\r\nmaxCleanUpDelay: 1800\r\naddressResolverGroupFactory: !<org.redisson.connection.DnsAddressResolverGroupFactory> {}\r\n\r\n\r\n\r\n**error:**\r\n`org.redisson.client.RedisTimeoutException: Unable to acquire connection! Increase connection pool size and/or retryInterval settings Node source: NodeSource [slot=16255, addr=redis://x.x.x.22:6370, redisClient=null, redirect=MOVED, entry=null], command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, call_job:callLock:4acda4eb2e204e809541e46526400c3b, 30000, 55613171-821a-400b-b56b-0274529ac468:275] after 0 retry attempts\r\n\tat org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:191)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747)\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:745)`\r\n\r\n\r\nThe online environment has been running for many days without problems, and the above error has been reported recently and it is normal after restarting.\r\nWhen the error is reported, the application still has 27 connections to x.x.x.22:6370\r\nExcept  the connections to x.x.x.22:6370 has errors, other redis nodes have no errors\r\nThe application is using redisClient at the same time, but no error is reported,indicating that there should be no problem with the network\r\n\r\nquestion:\r\nI want to know what are the possible reasons for the above error\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2940/comments",
    "author": "tmaerd",
    "comments": [
      {
        "user": "qertyop",
        "created_at": "2020-08-03T01:42:40Z",
        "body": "I also have almost the same issue, @mrniko coud you please help?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-08-28T12:33:11Z",
        "body": "> org.redisson.client.RedisTimeoutException: Unable to acquire connection! \r\n\r\nThis error means that all connections are busy."
      }
    ]
  },
  {
    "number": 2933,
    "title": "Watchdog for RSemaphore",
    "created_at": "2020-07-21T01:52:05Z",
    "closed_at": "2021-02-03T09:49:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2933",
    "body": "RLock is great mechanism for distributed locking since it has a watchdog for releasing lock when client application is dead. \r\n\r\nHowever, when it comes to reactive version (RLockReactive) it becomes totally unuseful because unlocking can be done only by the thread that performs locking. And with reactive streams this never happens for sure.\r\n\r\nInstead, it is suggested to use RSemaphore as an alternative since it is not bound to threads. In general, it does the job. However, when client application becomes dead, already performed lock hangs forever. Setting key expiration time partially solves the problem, however, actual atomic operation time may differ, so it is usually difficult to choose the correct timeout.\r\n\r\nAnother option is a watchdog, but apparently Redisson one does not work with RSemaphore.\r\n\r\nSo, is it possible to configure the Redisson watchdog for prolonging RSemaphore expire time? Or the only way out is implementing own watchdog?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2933/comments",
    "author": "abagiev",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-09-11T09:33:42Z",
        "body": "I can suggest you to use `RPermitExpirableSemaphore` so you can define `leaseTime` per permit."
      },
      {
        "user": "tomasz-galuszka",
        "created_at": "2021-01-29T09:54:30Z",
        "body": "I have a case when I used the `RPermitExpirableSemaphore` as a lock for `RMapCacheReactive` **get by key** method.\r\nThe flow:\r\n1) I get the element by key\r\n2) If not exists I create a semaphore which includes a **map key in the name** then I do `trySetPermits(1)` and `tryAcquire(lockWaitTime.toMillis(), lockLeaseTime.toMillis(), MILLISECONDS)`\r\n3) Then I do `flatMap` and run a function to get the value with attached `doFinally` which calls `semaphore.release(permitId)`\r\n\r\nAll works fine for 50, 100, 200, 500 asynchronous executions (the function to get the data is executed only once), great !\r\n\r\nMy problem is when I checked the redis KEYS. There are multiple KEYS related to my semaphore name and they stays there forever. Is there an easy way to clean them up when not used for some time ? \r\n\r\nOr do I need to do something like below by myself ? \r\n````\r\n                mySemaphore.expire(lockExpireTime.toMillis(), MILLISECONDS)\r\n                        .doOnNext(r -> log.info(\"Set expired: {}\", r)).subscribe();\r\n````\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2021-02-03T09:48:45Z",
        "body": "Yes, you need to clear it on your side"
      },
      {
        "user": "drshiki",
        "created_at": "2021-07-14T17:34:20Z",
        "body": "use RLock without leaseTime causes automatically turning on watch dog but RSemaphore doesn't.  it is not so trivial, is there any plan to add watch dog to RSemaphore？\r\n\r\n> \r\n> \r\n> Yes, you need to clear it on your side\r\n\r\n"
      }
    ]
  },
  {
    "number": 2920,
    "title": "Caused by: org.redisson.client.RedisException: ERR unsupported unit provided. please use m, km, ft, mi.",
    "created_at": "2020-07-15T15:41:05Z",
    "closed_at": "2020-07-16T13:01:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2920",
    "body": "```\r\nCaused by: org.springframework.dao.InvalidDataAccessApiUsageException: ERR unsupported unit provided. please use m, km, ft, mi. channel: [id: 0x872913fa, L:/127.0.0.1:45976 - R:/127.0.0.1:6379] command: (GEORADIUS), params: [[116, 101, 115, 116, 45, 108, 111, 99, 97, 116, ...], 116.9412419137, 39.2212812254, 6378.137, , WITHCOORD, COUNT, 3, ASC]; nested exception is org.redisson.client.RedisException: ERR unsupported unit provided. please use m, km, ft, mi. channel: [id: 0x872913fa, L:/127.0.0.1:45976 - R:/127.0.0.1:6379] command: (GEORADIUS), params: [[116, 101, 115, 116, 45, 108, 111, 99, 97, 116, ...], 116.9412419137, 39.2212812254, 6378.137, , WITHCOORD, COUNT, 3, ASC]\r\n\tat org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:48) ~[redisson-spring-data-23-3.13.2.jar:3.13.2]\r\n\tat org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:35) ~[redisson-spring-data-23-3.13.2.jar:3.13.2]\r\n\tat org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:44) ~[spring-data-redis-2.3.1.RELEASE.jar:2.3.1.RELEASE]\r\n\tat org.redisson.spring.data.connection.RedissonConnection.transform(RedissonConnection.java:217) ~[redisson-spring-data-23-3.13.2.jar:3.13.2]\r\n\tat org.redisson.spring.data.connection.RedissonConnection.syncFuture(RedissonConnection.java:212) ~[redisson-spring-data-23-3.13.2.jar:3.13.2]\r\n\tat org.redisson.spring.data.connection.RedissonConnection.sync(RedissonConnection.java:378) ~[redisson-spring-data-23-3.13.2.jar:3.13.2]\r\n\tat org.redisson.spring.data.connection.RedissonConnection.read(RedissonConnection.java:759) ~[redisson-spring-data-23-3.13.2.jar:3.13.2]\r\n\tat org.redisson.spring.data.connection.RedissonConnection.geoRadius(RedissonConnection.java:2026) ~[redisson-spring-data-23-3.13.2.jar:3.13.2]\r\n\tat org.springframework.data.redis.core.DefaultGeoOperations.lambda$radius$7(DefaultGeoOperations.java:181) ~[spring-data-redis-2.3.1.RELEASE.jar:2.3.1.RELEASE]\r\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:228) ~[spring-data-redis-2.3.1.RELEASE.jar:2.3.1.RELEASE]\r\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:188) ~[spring-data-redis-2.3.1.RELEASE.jar:2.3.1.RELEASE]\r\n\tat org.springframework.data.redis.core.AbstractOperations.execute(AbstractOperations.java:96) ~[spring-data-redis-2.3.1.RELEASE.jar:2.3.1.RELEASE]\r\n\tat org.springframework.data.redis.core.DefaultGeoOperations.radius(DefaultGeoOperations.java:181) ~[spring-data-redis-2.3.1.RELEASE.jar:2.3.1.RELEASE]\r\n\tat com.condingfly.Application.testNearByXY(Application.java:98) [classes/:na]\r\n\tat com.condingfly.Application.run(Application.java:41) [classes/:na]\r\n\tat org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:795) [spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]\r\n\t... 5 common frames omitted\r\nCaused by: org.redisson.client.RedisException: ERR unsupported unit provided. please use m, km, ft, mi. channel: [id: 0x872913fa, L:/127.0.0.1:45976 - R:/127.0.0.1:6379] command: (GEORADIUS), params: [[116, 101, 115, 116, 45, 108, 111, 99, 97, 116, ...], 116.9412419137, 39.2212812254, 6378.137, , WITHCOORD, COUNT, 3, ASC]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:365) ~[redisson-3.13.2.jar:3.13.2]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:196) ~[redisson-3.13.2.jar:3.13.2]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134) ~[redisson-3.13.2.jar:3.13.2]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104) ~[redisson-3.13.2.jar:3.13.2]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501) ~[netty-codec-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[netty-codec-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]\r\n\tat java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_231]\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2920/comments",
    "author": "hegphegp",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-07-15T16:22:30Z",
        "body": "Can you share the code to reproduce the issue?"
      },
      {
        "user": "hegphegp",
        "created_at": "2020-07-16T13:01:53Z",
        "body": "This is my fault. I ran the wrong command. sorry."
      },
      {
        "user": "ruanun",
        "created_at": "2022-03-11T07:59:01Z",
        "body": "I encountered the same problem when using Redis geo for the project, but it worked fine when using km units\r\n\r\n@hegphegp "
      },
      {
        "user": "mrniko",
        "created_at": "2022-03-11T09:25:38Z",
        "body": "@ruanun \r\n\r\nCan you share the code to reproduce issue?"
      }
    ]
  },
  {
    "number": 2914,
    "title": "redisson-netty thread lock",
    "created_at": "2020-07-13T20:51:29Z",
    "closed_at": "2020-07-15T16:23:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2914",
    "body": "Hi,\r\n\r\nWe have setup Redis cluster and populated key/values. Some Keys contain more than 2M fields. When we call getAll of RMap using redission client, it takes more than 30 mins and goes to idle state. We analyzed the thread dump and noticed the below errors. We are using redission client (3.13.1). Is this known issue with Redisson client?\r\n\r\nError\r\n\r\n\"redisson-netty-2-150\" #361 prio=5 os_prio=0 tid=0x44001e000000 nid=0x329 [ JVM locked by VM (w/poll advisory bit) running, polling bits: safep rstak gpgc_clean_new]\r\njava.lang.Thread.State.RUNNABLE\r\nat sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)\r\nat sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)\r\nat sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:93)\r\nat sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)\r\n- locked <0x000004049490fd10> (a io.netty.channel.nio.SelectedSelectionKeySet)\r\n- locked <0x00000404948ffaa8> (a java.util.Collections$UnmodifiableSet)\r\n- locked <0x00000404948ff998> (a sun.nio.ch.EPollSelectorImpl)\r\nat sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)\r\nat sun.nio.ch.SelectorImpl.select(SelectorImpl.java:101)\r\nat io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:68)\r\nat io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:803)\r\nat io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:457)\r\nat io.netty.util.concurrrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\nat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\nat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\nat java.lang.Thread.run(Thread.java:748)\r\n\r\nCode snippet/configuration\r\n\r\nString nodeAdd=\"redis://host:port\";\r\nString pwd = \"***\";\r\nString clientName = \"Test\";\r\nInteger timeout = 1500;\r\nInteger connectTimeout = 1500;\r\nInteger subscriptionsPerConnection = 5;\r\nInteger subscriptionConnectionPoolSize= 50;\r\nInteger subscriptionsPerConnection = 5;\r\nInteger subscriptionsConnectionMinimumIdleSize = 1;\r\n\r\nInteger masterConnectionMimimumIdleSize = 32;\r\nInteger masterConnectionPoolSize= 64;\r\n\r\nInteger retryAttempts = 5;\r\nInteger retryInterval = 1500;\r\nInteger threads = 100;\r\nInteger nettyThreads = 500;\r\n\r\nConfig config = new Config();\r\n// set the above parms to config\r\nclient = Redisson.create(config);",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2914/comments",
    "author": "demo-cmvc",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-07-14T04:47:35Z",
        "body": "I don't see any error here. Thread is in RUNNABLE state."
      }
    ]
  },
  {
    "number": 2913,
    "title": "RedissonResponseTimeoutException in HSCAN ",
    "created_at": "2020-07-13T17:05:47Z",
    "closed_at": "2020-07-24T08:57:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2913",
    "body": "The application is throwing RedissonResponseTimeoutException. It is happening when Redisson fires HSCAN command because the code is iterating over HashMap with size of 8.5k entries. Below is the exception message\r\n\r\n\r\n`org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (6000 ms) occured after 6 retry attempts. Increase nettyThreads and/or timeout settings. Try to define pingConnectionInterval setting. Command: (HSCAN)`\r\n\r\nI tried increasing the netty thread to 64 and retryAttempts to 6 and timeout time to 6000.\r\n\r\nRedisson version : 3.12.5\r\nRedis version: 5",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2913/comments",
    "author": "Aviisek",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-07-13T17:08:50Z",
        "body": "does it happen only with hscan command? what is the size of data it returns? it might be network delay due to size of transferred data."
      },
      {
        "user": "Aviisek",
        "created_at": "2020-07-13T17:30:00Z",
        "body": "Thanks @mrniko for looking into this. \r\nI am getting this exception only with HSCAN.\r\nThe complete scenario here is - \r\nI am getting RMap reference and then Iterating over it using RMap#entrySet. This RMap has almost 8.5k entries. So what I suspect is Its making so many network calls to fetch entries to iterate over map and eventually being timedout. does it fetch map values in some batch size or all at once? What do you suggest @mrniko ?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-07-14T06:51:00Z",
        "body": "The problem is that map entries are too big. Try to use `RMap.entrySet(2)` method. 2 - is size of entries amount to fetch per Redis request."
      },
      {
        "user": "Aviisek",
        "created_at": "2020-07-14T08:53:09Z",
        "body": "Actually this exception is not consistent. \r\nYes, I will try this method and will let you know the result.  Thanks @mrniko ."
      },
      {
        "user": "Aviisek",
        "created_at": "2020-07-24T08:57:37Z",
        "body": "So, it seemed it was because of long operation on this huge hashmap. So, in order to handle this, I did refactor the code to reduce.  "
      }
    ]
  },
  {
    "number": 2912,
    "title": "RedisTimeoutException on ElastiCache being called by Kubernetes",
    "created_at": "2020-07-13T12:18:18Z",
    "closed_at": "2020-07-13T23:17:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2912",
    "body": "Hey there!\r\n\r\nWe moved our code to production and we are facing a lot of timeout errors:\r\n\r\n```\r\norg.redisson.client.RedisTimeoutException: Redis server response timeout (0 ms) occured for command: (GET) with params: [5b9220a8bed49eef9219da4007d28fb3] channel: [id: 0xdd5244f5, L:/172.16.93.114:57196 - R:sec-redis-cluster-0003-002.sec-redis-cluster.pu81s0.nae1.cache.amazonaws.com/172.16.70.62:6379]\r\n\tat org.redisson.command.CommandAsyncService$11.run(CommandAsyncService.java:697)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747)\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472)\r\n\tat java.lang.Thread.run(Thread.java:834)\r\n```\r\n\r\nIt's happening for GET and PSETEX commands. I have found the FAQ with possible solutions like increase nettyThreads and I was wondering if our problem is related with FAQ instructions - our code is super simple, it's a spring boot application with the following implementation:\r\n\r\napplication.properties\r\n```\r\n#CACHE\r\nspring.redis.host=rediss://clustercfg.sec-redis-cluster.pu81s0.nae1.cache.amazonaws.com\r\nspring.redis.port=6379\r\nspring.redis.password=\r\n```\r\n\r\nCacheServiceImpl.kt\r\n```\r\n@Service\r\nclass CacheServiceImpl(val redissonClient: RedissonClient) : CacheService {\r\n\r\n    private val logger = logger<CacheServiceImpl>()\r\n\r\n    override fun put(key: String, value: String, expiresInSeconds: Long) {\r\n        val rBucket = getBucket(key)\r\n\r\n        rBucket.set(value, expiresInSeconds, TimeUnit.SECONDS)\r\n    }\r\n\r\n    override fun get(key: String): String? {\r\n        val rBucket = getBucket(key)\r\n\r\n        return rBucket.get()\r\n    }\r\n\r\n    private fun getBucket(key: String) = redissonClient.getBucket<String>(key, StringCodec.INSTANCE)\r\n}\r\n```\r\n\r\nFor now, we don't have massive requests, probably it's missing some configuration or just update Redisson Client because we are using a super outdated version `3.5.6`.\r\n\r\nDo you have any other suggestion behind update lib? Do you know if is possible set `nettyThread` using application.properties?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2912/comments",
    "author": "daviddelucca",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-07-13T12:39:39Z",
        "body": "You set 0ms response timeout. "
      },
      {
        "user": "daviddelucca",
        "created_at": "2020-07-13T23:17:51Z",
        "body": "Since the timeout error is gone - solved it by bumping to newest version, I'll open a new thread with new error. I'll be glad if you could give me some ideas"
      }
    ]
  },
  {
    "number": 2908,
    "title": "Reasoning behind returning false on RSemaphore",
    "created_at": "2020-07-10T21:29:08Z",
    "closed_at": "2020-08-28T12:29:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2908",
    "body": "Why do methods such as `trySetPermits` only return false when the attempt fails? I am trying to debug an issue around using semaphores, and this method is returning false; however, since no exception is thrown, I have no insight into why this is failing. \r\n\r\nWhat would be the possible reasons for failing on this method?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2908/comments",
    "author": "aikendaniel",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-08-28T12:29:18Z",
        "body": "Unable to reproduce the issue."
      }
    ]
  },
  {
    "number": 2898,
    "title": "Getting Register a custom serializer implementing instantiate or define empty constructor - redis cache on wildfly",
    "created_at": "2020-07-07T15:54:24Z",
    "closed_at": "2020-07-07T17:34:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2898",
    "body": "Hello, When I deploy my code on Wildfly-19 with Redisson client to connect to Redis cluster. I am getting below error.\r\n\r\n**Here is my redis configuration**\r\nclusterServersConfig:\r\n  idleConnectionTimeout: 10000\r\n  connectTimeout: 10000\r\n  timeout: 3000\r\n  retryAttempts: 3\r\n  retryInterval: 1500\r\n  failedSlaveReconnectionInterval: 3000\r\n  failedSlaveCheckInterval: 10000\r\n  subscriptionsPerConnection: 5\r\n  subscriptionConnectionMinimumIdleSize: 1\r\n  subscriptionConnectionPoolSize: 50\r\n  slaveConnectionMinimumIdleSize: 24\r\n  slaveConnectionPoolSize: 64\r\n  masterConnectionMinimumIdleSize: 24\r\n  masterConnectionPoolSize: 64\r\n  readMode: \"SLAVE\"\r\n  subscriptionMode: \"SLAVE\"\r\n  scanInterval: 1000\r\n  pingConnectionInterval: 0\r\n  keepAlive: false\r\n  tcpNoDelay: false\r\nthreads: 16\r\nnettyThreads: 32\r\ncodec: !<org.redisson.codec.FstCodec> {}\r\ntransportMode: \"NIO\"\r\n\r\n\r\n**Exception:**\r\n\r\n2020-07-07 21:18:13,475 ERROR [org.redisson.client.handler.ErrorsLoggingHandler] (redisson-netty-2-18) Exception occured. Channel: [id: 0x4e4f015f, L:/172.20.137.105:63544 - R:apps-xx-dev-cache.xxxti.use1.cache.amazonaws.com/xx.xx6.88.10:6379]: io.netty.handler.codec.DecoderException: java.io.IOException: java.io.IOException: <undefined referencee>:Failed to instantiate 'com.xxxx.StandardColumnInfo'. Register a custom serializer implementing instantiate or define empty constructor.\r\n\tat deployment.pc.ear//io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)\r\n\tat deployment.pc.ear//io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\tat deployment.pc.ear//io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat deployment.pc.ear//io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat deployment.pc.ear//io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat deployment.pc.ear//io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1518)\r\n\tat deployment.pc.ear//io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1267)\r\n\tat deployment.pc.ear//io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1314)\r\n\tat deployment.pc.ear//io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501)\r\n\tat deployment.pc.ear//io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:440)\r\n\tat deployment.pc.ear//io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\tat deployment.pc.ear//io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat deployment.pc.ear//io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat deployment.pc.ear//io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\r\n\tat deployment.pc.ear//io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat deployment.pc.ear//io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\r\n\tat deployment.pc.ear//io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\r\n\tat deployment.pc.ear//io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat deployment.pc.ear//io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\r\n\tat deployment.pc.ear//io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)\r\n\tat deployment.pc.ear//io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)\r\n\tat deployment.pc.ear//io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)\r\n\tat deployment.pc.ear//io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n\tat deployment.pc.ear//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\tat deployment.pc.ear//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat deployment.pc.ear//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)\r\nCaused by: java.io.IOException: java.io.IOException: <undefined referencee>:Failed to instantiate 'com.xxxx.StandardColumnInfo'. Register a custom serializer implementing instantiate or define empty constructor.\r\n\tat deployment.pc.ear//org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247)\r\n\tat deployment.pc.ear//org.redisson.codec.FstCodec$1.decode(FstCodec.java:250)\r\n\tat deployment.pc.ear//org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:375)\r\n\tat deployment.pc.ear//org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:419)\r\n\tat deployment.pc.ear//org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:384)\r\n\tat deployment.pc.ear//org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:419)\r\n\tat deployment.pc.ear//org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:384)\r\n\tat deployment.pc.ear//org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:196)\r\n\tat deployment.pc.ear//org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134)\r\n\tat deployment.pc.ear//org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104)\r\n\tat deployment.pc.ear//io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501)\r\n\tat deployment.pc.ear//io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\t... 26 more\r\nCaused by: java.io.IOException: <undefined referencee>:Failed to instantiate 'com.xxx.StandardColumnInfo'. Register a custom serializer implementing instantiate or define empty constructor.\r\n\tat deployment.pc.ear//org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:533)\r\n\tat deployment.pc.ear//org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374)\r\n\tat deployment.pc.ear//org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331)\r\n\tat deployment.pc.ear//org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311)\r\n\tat deployment.pc.ear//org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245)\r\n\r\n\r\nPlease suggest some help.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2898/comments",
    "author": "sunilchaurha",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-07-07T17:34:23Z",
        "body": "Try switch to MarshallingCodec or SerializableCodec"
      },
      {
        "user": "sunilchaurha",
        "created_at": "2020-07-07T18:31:55Z",
        "body": "tried with MarshallingCodec but was getting encoding error."
      },
      {
        "user": "mrniko",
        "created_at": "2020-07-10T05:02:58Z",
        "body": "Could you share code example to reproduce it?"
      },
      {
        "user": "sunilchaurha",
        "created_at": "2020-07-10T07:37:32Z",
        "body": "Hi, sharing code to reproduce is difficult because there is lot of coupled code. \r\nFor now I overridden BasicCodec and wrote my own codec class. Which works fine as SerializationCode. "
      }
    ]
  },
  {
    "number": 2897,
    "title": "Strange characters on value when read data in other language",
    "created_at": "2020-07-06T18:45:50Z",
    "closed_at": "2020-07-07T11:43:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2897",
    "body": "Hey there!\r\n\r\nI was wondering if it's possible to perform a simple operation like we do on Redis StackExchange (c#) client:\r\n\r\n```\r\nIDatabase db = redis.GetDatabase();\r\nstring value = \"abcdefg\";\r\nvar expires = 1000;\r\ndb.StringSet(\"mykey\", value, expires);\r\n...\r\nstring value = db.StringGet(\"mykey\");\r\nConsole.WriteLine(value); // writes: \"abcdefg\r\n```\r\n\r\nRight now I'm using a Map but I would like to make it simple as this example on C#. \r\n\r\n```\r\n    override fun put(collection: String, key: String, value: String, expiresInSeconds: Long) {\r\n        logger.info(\"Storing key $key into collection $collection\")\r\n        val cacheMap = getMapCache(collection)\r\n\r\n        cacheMap.put(key, value, 3600, TimeUnit.SECONDS)\r\n    }\r\n\r\n    private fun getMapCache(collection: String) = redissonClient.getMapCache<String, String>(\"any\", StringCodec())\r\n```\r\n\r\nWhen I try to retrieve values fro other clients like C# or Python, I got some strange characters on value like `????????�\u0003??????myvalue`.\r\n\r\nIs there any option to clear/remove those characters on Redisson and store it as plain string?\r\n\r\nIs there any option to store it simple as we do in C#?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2897/comments",
    "author": "daviddelucca",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-07-07T04:37:33Z",
        "body": "Here is how you can do the same with Redisson:\r\n\r\n```java\r\nRBucket b = redisson.getBucket(\"mykey\", StringCodec.INSTANCE);\r\nb.set(\"value\", 1, TimeUnit.SECONDS);\r\n\r\nb.get(); // = \"value\"\r\n```\r\n\r\n> When I try to retrieve values fro other clients like C# or Python, I got some strange characters on value like ????????��??????myvalue.\r\n\r\nBecause default Redisson codec is `MarshallingCodec`"
      },
      {
        "user": "daviddelucca",
        "created_at": "2020-07-07T09:12:38Z",
        "body": "Is possible to remove those characters or create a custom codec?\r\n\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2020-07-07T11:20:56Z",
        "body": "You can use StringCodec instead"
      },
      {
        "user": "daviddelucca",
        "created_at": "2020-07-07T11:43:54Z",
        "body": "Thank you very much!"
      }
    ]
  },
  {
    "number": 2892,
    "title": "Unable to decode data. channel: [id: 0x34a72ba5, L:/xxxxxxx - R:xxxxxxxx], reply: ReplayingDecoderByteBuf(ridx=88, widx=88) java.lang.NullPointerException: null",
    "created_at": "2020-07-05T12:56:18Z",
    "closed_at": "2020-07-31T06:08:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2892",
    "body": "spring boot version 2.0.4\r\nredisson version 3.11.6\r\n\r\nused redisson  RedissonDelayedQueue\r\n\r\n\r\nUnable to decode data. channel: [id: 0x34a72ba5, L:/xxxxxxx - R:xxxxxxxx], reply: ReplayingDecoderByteBuf(ridx=88, widx=88) java.lang.NullPointerException: null\r\n\r\n\r\nthanks for your help ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2892/comments",
    "author": "alexpassionate",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-07-11T04:51:27Z",
        "body": "make sure you don't share the same name between different Redisson objects."
      },
      {
        "user": "alexpassionate",
        "created_at": "2020-07-18T04:55:50Z",
        "body": "> make sure you don't share the same name between different Redisson objects.\r\n\r\nhow to make sure share the same name between different Redisson objects ?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-07-18T05:53:03Z",
        "body": "This should be checked on application side not Redisson"
      },
      {
        "user": "alexpassionate",
        "created_at": "2020-07-18T06:08:49Z",
        "body": "> This should be checked on application side not Redisson\r\n\r\nWhat represents sharing the same name and being a queue object? What the program should do."
      },
      {
        "user": "alexpassionate",
        "created_at": "2020-07-18T06:10:50Z",
        "body": "Reporting this error can affect data loss. "
      },
      {
        "user": "mrniko",
        "created_at": "2020-07-18T09:35:01Z",
        "body": "Can you provide test code to reproduce this?"
      }
    ]
  },
  {
    "number": 2888,
    "title": "Set Redisson config using AWS ElastiCache as Clustered Mode",
    "created_at": "2020-07-02T23:45:55Z",
    "closed_at": "2020-07-03T17:05:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2888",
    "body": "Hey there!\r\n\r\nWhat is the proper way to configure Redisson when you have a AWS ElastiCache Redis running as Clustered Mode? I have tried to set using it as follows:\r\n\r\n```\r\n    val nodeAddress = \"redis://test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com:6379\" \r\n    val config = Config()\r\n    val configCluster = config.useClusterServers().addNodeAddress(nodeAddress)\r\n    val client = Redisson.create(config)\r\n```\r\n\r\nNode endpoint: test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com\r\nConfiguration endpoint: test-rest-encryption.p0vefj.clustercfg.use1.cache.amazonaws.com\r\n\r\nFor `nodeAddress`, I have tried to use configuration endpoint and node endpoint but fails in both case (connection timed out):\r\n\r\n```\r\n21:04:39.542 [main] WARN  o.r.cluster.ClusterConnectionManager - connection timed out: test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com/172.31.19.41:6379\r\nException in thread \"main\" org.redisson.client.RedisConnectionException: Can't connect to servers!\r\n\tat org.redisson.cluster.ClusterConnectionManager.<init>(ClusterConnectionManager.java:144)\r\n\tat org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:237)\r\n\tat org.redisson.Redisson.<init>(Redisson.java:117)\r\n\tat org.redisson.Redisson.create(Redisson.java:156)\r\n\tat aus.web.SessionManagerApplicationKt.main(SessionManagerApplication.kt:23)\r\nCaused by: io.netty.channel.ConnectTimeoutException: connection timed out: test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com/172.31.19.41:6379\r\n\tat io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:261)\r\n\tat io.netty.util.concurrent.PromiseTask.runTask(PromiseTask.java:98)\r\n\tat io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:170)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)\r\n```\r\n\r\nAm I missing something?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2888/comments",
    "author": "daviddelucca",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-07-03T05:28:56Z",
        "body": "Is your application located in the same security group?"
      },
      {
        "user": "daviddelucca",
        "created_at": "2020-07-03T09:04:12Z",
        "body": "Yes, it’s in the same SG!\r\n\r\nDo you usually use configuration endpoint or node endpoint? I have read in docs about to use node endpoint but it throws the same exception 😞\r\n\r\n\r\n"
      },
      {
        "user": "daviddelucca",
        "created_at": "2020-07-03T16:44:10Z",
        "body": "@mrniko I have figured part of the problem: the client throws an exception if I try to connect to cluster with option `Encryption in-transit` enabled. Does this client support Encryption in-transit and Encryption at-rest?\r\n\r\nI'm using version 3.5.6"
      },
      {
        "user": "mrniko",
        "created_at": "2020-07-03T17:04:01Z",
        "body": "use rediss:// prefix for SSL connection. And select latest Redisson version for new projects."
      },
      {
        "user": "daviddelucca",
        "created_at": "2020-07-03T17:05:54Z",
        "body": "Solved! It was the prefix!\r\n"
      }
    ]
  },
  {
    "number": 2887,
    "title": "请问购买阿里云的集群是个域名，redisson集群如何配置？",
    "created_at": "2020-07-02T13:06:51Z",
    "closed_at": "2020-07-03T02:15:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2887",
    "body": "如题",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2887/comments",
    "author": "ZShUn",
    "comments": [
      {
        "user": "dongxuqian",
        "created_at": "2023-09-14T02:26:42Z",
        "body": "好奇怎么配置的，也遇到这个问题，阿里云集群版代理模式，怎么使用redisson"
      },
      {
        "user": "mrniko",
        "created_at": "2023-09-14T06:57:56Z",
        "body": "Just specify Redis hostname in Redisson cluster mode configuration"
      }
    ]
  },
  {
    "number": 2877,
    "title": "Redis native commands are not supported using redisson client",
    "created_at": "2020-06-29T14:49:00Z",
    "closed_at": "2021-12-28T04:18:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2877",
    "body": "I wanted to run Redis Native commands using redisson provided low-level client, However.  Some of the commands i see not exposed from RedisCommands.java are: \r\n\r\n**HASH COMMANDS Not supported** \r\nHINCRBY\r\nHINCRBYFLOAT\r\nHMGET\r\n\r\n**STRING COMMANDS NOT SUPPORTED** \r\nBITFIELD\r\nBITOPS\r\nDECRBY\r\nSETEX \r\nSTRALGO\r\n\r\nI just explored String and Hash commands, however list of commands not supported might be more. \r\n\r\nUsage:\r\n RedisClient redisClient = RedisClient.create(new RedisClientConfig().setAddress(\"redis://localhost:6379\"));\r\n RedisConnection conn = redisClient.connect();\r\n conn.async(StringCodec.INSTANCE, RedisCommands.MSET, \"keys1\",\"values1\",\"keys2\",\"values2\");\r\n\r\n\r\na) Is there are way i can actually run the redis native commands via some interfaces ?\r\nb) Any reason why redisson is not exposing complete set of redis native commands ?  Does Redisson make any effort on a regular basis to support new commands that are offered by Redis   ?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2877/comments",
    "author": "shashanka981",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-29T15:11:00Z",
        "body": "> HASH COMMANDS Not supported\r\n\r\nYou can see how they used in RedissonMap object.\r\n\r\n> STRING COMMANDS NOT SUPPORTED\r\n\r\nRedisCommands#BITOP\r\nSETEX is used in RedissonBucket object.\r\n\r\nAnyway you can always create RedissonCommand and implement missed command.\r\n"
      },
      {
        "user": "shashanka981",
        "created_at": "2020-06-29T15:26:15Z",
        "body": "For my usecase, i was actually interested to not do anything beyond inserting a hash entry. However RMap does lot of things which may be a overhead for my usecases.\r\n\r\nYou said \"Anyway you can always create RedissonCommand and implement missed command.\"\r\nCan you point to some documentation about the usage of this interface. I cant find any interface/class by name RedissonCommand"
      },
      {
        "user": "mrniko",
        "created_at": "2020-06-29T15:28:00Z",
        "body": "> Can you point to some documentation about the usage of this interface\r\n\r\nI'm afraid there is no such documentation at the moment.\r\n\r\n> However RMap does lot of things which may be a overhead for my usecases.\r\n\r\nFor example?"
      },
      {
        "user": "shashanka981",
        "created_at": "2020-06-29T17:08:31Z",
        "body": "\"I'm afraid there is no such documentation at the moment.\"\r\n       Can you give the correct name of the class/interface ?\r\n\r\n\"However RMap does lot of things which may be a overhead for my usecases.\"\r\nI was actually looking for a one-one mapping from redis command to redisson command , all exposed from single interface/class so that i am actually sure there we are doing a minimal exection needed. From the code, i see RMap seems to be reasonably doing minimal though. "
      },
      {
        "user": "feknall",
        "created_at": "2021-05-18T10:22:55Z",
        "body": "> \"I'm afraid there is no such documentation at the moment.\"\r\n> Can you give the correct name of the class/interface ?\r\n\r\nI think \"org.redisson.client.protocol.RedisCommands\" is the correct name. Maybe it can give you an idea about what you are looking for.\r\n```\r\n<dependency>\r\n      <groupId>org.redisson</groupId>\r\n      <artifactId>redisson</artifactId>\r\n      <version>3.15.0</version>\r\n</dependency>\r\n```"
      }
    ]
  },
  {
    "number": 2876,
    "title": "error: Provider org.redisson.jcache.JCachingProvider not a subtype",
    "created_at": "2020-06-29T12:59:01Z",
    "closed_at": "2020-07-24T10:57:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2876",
    "body": "I am running tomcat with Equinox and want to use redisson for session storage. The shared session storage works fine but I have this error in my `localhost.xxx.log`. \r\n\r\n```\r\njava.util.ServiceConfigurationError: javax.cache.spi.CachingProvider: Provider org.redisson.jcache.JCachingProvider not a subtype\r\n\tjava.util.ServiceLoader.fail(ServiceLoader.java:239)\r\n\tjava.util.ServiceLoader.access$300(ServiceLoader.java:185)\r\n\tjava.util.ServiceLoader$LazyIterator.nextService(ServiceLoader.java:376)\r\n\tjava.util.ServiceLoader$LazyIterator.next(ServiceLoader.java:404)\r\n\tjava.util.ServiceLoader$1.next(ServiceLoader.java:480)\r\n\tjavax.cache.Caching$CachingProviderRegistry$1.run(Caching.java:438)\r\n\tjavax.cache.Caching$CachingProviderRegistry$1.run(Caching.java:432)\r\n\tjava.security.AccessController.doPrivileged(Native Method)\r\n\tjavax.cache.Caching$CachingProviderRegistry.getCachingProviders(Caching.java:432)\r\n\tjavax.cache.Caching$CachingProviderRegistry.getCachingProvider(Caching.java:370)\r\n\tjavax.cache.Caching$CachingProviderRegistry.getCachingProvider(Caching.java:351)\r\n\tjavax.cache.Caching.getCachingProvider(Caching.java:142)\r\n```\r\n\r\nHere is my `redisson.config.yaml`\r\n```\r\nuseThreadClassLoader: false\r\n\r\nsingleServerConfig:\r\n  address: \"redis://redis:6379\"\r\n```\r\n\r\nI am not actually interested in replacing the caching provider. I'd like to use redisson only for shared session storage.\r\n\r\nAppreciate your ideas.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2876/comments",
    "author": "sam701",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-29T13:36:57Z",
        "body": "I only can say obvious here: `JCachingProvider` loaded with a different classloader than `javax.cache.spi.CachingProvider` interface it implementing.\r\n\r\n`useThreadClassLoader` setting is only used during Redis data decoding and won't help."
      },
      {
        "user": "sam701",
        "created_at": "2020-06-30T10:43:17Z",
        "body": "👍  😄  thanks, that helped. I removed `cache-api-*.jar` from webapp, so that there is just one implementation bundled in `redisson-all-*`"
      },
      {
        "user": "sam701",
        "created_at": "2020-07-01T08:29:17Z",
        "body": "Hmm, unfortunately, the issue is still present. Here is the setup: \r\n- tomcat runs a webapp that uses `ehcache` with `cache-api-1.0.0`\r\n- `redisson-all.jar` and `redisson-tomcat-8.jar` are located in `tomcat/lib`\r\n\r\nAs soon as the webapp calls `Caching.getCachingProvider(EhcacheCachingProvider.class.getName(), this.getClass().getClassLoader());`, there is the exception `Provider org.redisson.jcache.JCachingProvider not a subtype`. As far as I understand Ehcache extends the `CachingProvider` from the webapp ClassLoader, but the Redisson extends the `CachingProvider` from the tomcat (common) ClassLoader.\r\n\r\nRemoving `cache-api` jar from the webapp, as I described above, is fragile, because Redisson can change its `cache-api` version any time. Another approach I see is to additionally copy `redisson-all.jar` to the webapp `WEB-INF/lib` directory. But it is also a hack, since the webapp does not need it. @mrniko What would you recommend to deal with Ehcache in the webapp?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-07-24T10:50:15Z",
        "body": "I would recommend you to replace ehcache with redisson :)"
      },
      {
        "user": "sam701",
        "created_at": "2020-07-24T10:57:21Z",
        "body": "😄   got it. \r\n\r\nBut honestly I ended up writing my own redis session manager. It is really tiny one with a single dependency to jedis."
      },
      {
        "user": "adbhutrai",
        "created_at": "2024-03-21T16:10:33Z",
        "body": "Do we have any update on this? We are facing the same problem with Spring and ehcache on tomcat 10. We don't want to use redis cache for local cache."
      },
      {
        "user": "mrniko",
        "created_at": "2024-03-21T16:27:21Z",
        "body": "@adbhutrai \r\n\r\nDid you try to remove META-INF\\services\\javax.cache.spi.CachingProvider file from Redisson jar file?"
      },
      {
        "user": "adbhutrai",
        "created_at": "2024-03-21T16:35:57Z",
        "body": "No, I did not remove that."
      },
      {
        "user": "adbhutrai",
        "created_at": "2024-03-21T16:42:45Z",
        "body": "Here is the stacktrace of the error:\r\n\r\n21-Mar-2024 16:37:37.365 INFO [main] org.apache.catalina.core.ApplicationContext.log 2 Spring WebApplicationInitializers detected on classpath\r\n21-Mar-2024 16:37:38.491 INFO [main] org.apache.catalina.core.ApplicationContext.log Initializing Spring root WebApplicationContext\r\n21-Mar-2024 16:38:13.698 SEVERE [main] org.apache.catalina.core.StandardContext.listenerStart Exception sending context initialized event to listener instance of class [org.springframework.web.context.ContextLoaderListener]\r\n\torg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'jCacheCacheManager' defined in class path resource []: Failed to instantiate [org.springframework.cache.jcache.JCacheCacheManager]: Factory method 'jCacheCacheManager' threw exception with message: Error creating bean with name 'cacheManager' defined in class path resource []: Failed to instantiate [javax.cache.CacheManager]: Factory method 'cacheManager' threw exception with message: javax.cache.spi.CachingProvider: org.redisson.jcache.JCachingProvider not a subtype\r\n\t\tat org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:655)\r\n\t\tat org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:489)\r\n\t\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1336)\r\n\t\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1166)\r\n\t\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:563)\r\n\t\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:523)\r\n\t\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:325)\r\n\t\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)\r\n\t\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:323)\r\n\t\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)\r\n\t\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)\r\n\t\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:946)\r\n\t\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:616)\r\n\t\tat org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:394)\r\n\t\tat org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:274)\r\n\t\tat org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:102)\r\n\t\tat org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4436)\r\n\t\tat org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:4876)\r\n\t\tat org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:171)\r\n\t\tat org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:683)\r\n\t\tat org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:658)\r\n\t\tat org.apache.catalina.core.StandardHost.addChild(StandardHost.java:712)\r\n\t\tat org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:969)\r\n\t\tat org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1911)\r\n\t\tat java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)\r\n\t\tat java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)\r\n\t\tat org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75)\r\n\t\tat java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:123)\r\n\t\tat org.apache.catalina.startup.HostConfig.deployWARs(HostConfig.java:771)\r\n\t\tat org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:423)\r\n\t\tat org.apache.catalina.startup.HostConfig.start(HostConfig.java:1629)\r\n\t\tat org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:303)\r\n\t\tat org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:114)\r\n\t\tat org.apache.catalina.util.LifecycleBase.setStateInternal(LifecycleBase.java:402)\r\n\t\tat org.apache.catalina.util.LifecycleBase.setState(LifecycleBase.java:345)\r\n\t\tat org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:893)\r\n\t\tat org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:845)\r\n\t\tat org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:171)\r\n\t\tat org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1332)\r\n\t\tat org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1322)\r\n\t\tat java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)\r\n\t\tat org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75)\r\n\t\tat java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:145)\r\n\t\tat org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:866)\r\n\t\tat org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:240)\r\n\t\tat org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:171)\r\n\t\tat org.apache.catalina.core.StandardService.startInternal(StandardService.java:433)\r\n\t\tat org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:171)\r\n\t\tat org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:921)\r\n\t\tat org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:171)\r\n\t\tat org.apache.catalina.startup.Catalina.start(Catalina.java:757)\r\n\t\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\t\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\r\n\t\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\t\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\r\n\t\tat org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:345)\r\n\t\tat org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:476)\r\n\tCaused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.cache.jcache.JCacheCacheManager]: Factory method 'jCacheCacheManager' threw exception with message: Error creating bean with name 'cacheManager' defined in class path resource []: Failed to instantiate [javax.cache.CacheManager]: Factory method 'cacheManager' threw exception with message: javax.cache.spi.CachingProvider: org.redisson.jcache.JCachingProvider not a subtype\r\n\t\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:178)\r\n\t\tat org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:651)\r\n\t\t... 56 more\r\n\tCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'cacheManager' defined in class path resource []: Failed to instantiate [javax.cache.CacheManager]: Factory method 'cacheManager' threw exception with message: javax.cache.spi.CachingProvider: org.redisson.jcache.JCachingProvider not a subtype\r\n\t\tat org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:655)\r\n\t\tat org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:489)\r\n\t\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1336)\r\n\t\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1166)\r\n\t\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:563)\r\n\t\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:523)\r\n\t\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:325)\r\n\t\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)\r\n\t\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:323)\r\n\t\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)\r\n\t\tat org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.resolveBeanReference(ConfigurationClassEnhancer.java:362)\r\n\t\tat org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:334)\r\n\t\tat ie.davy.configuration.spring.ServicesConfiguration$$SpringCGLIB$$0.cacheManager(<generated>)\r\n\t\tat ie.davy.configuration.spring.ServicesConfiguration.jCacheCacheManager(ServicesConfiguration.java:71)\r\n\t\tat ie.davy.configuration.spring.ServicesConfiguration$$SpringCGLIB$$0.CGLIB$jCacheCacheManager$1(<generated>)\r\n\t\tat ie.davy.configuration.spring.ServicesConfiguration$$SpringCGLIB$$FastClass$$1.invoke(<generated>)\r\n\t\tat org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:258)\r\n\t\tat org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331)\r\n\t\tat ie.davy.configuration.spring.ServicesConfiguration$$SpringCGLIB$$0.jCacheCacheManager(<generated>)\r\n\t\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\t\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\r\n\t\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\t\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\r\n\t\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:140)\r\n\t\t... 57 more\r\n\tCaused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [javax.cache.CacheManager]: Factory method 'cacheManager' threw exception with message: javax.cache.spi.CachingProvider: org.redisson.jcache.JCachingProvider not a subtype\r\n\t\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:178)\r\n\t\tat org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:651)\r\n\t\t... 80 more\r\n\tCaused by: java.util.ServiceConfigurationError: javax.cache.spi.CachingProvider: org.redisson.jcache.JCachingProvider not a subtype\r\n\t\tat java.base/java.util.ServiceLoader.fail(ServiceLoader.java:593)\r\n\t\tat java.base/java.util.ServiceLoader$LazyClassPathLookupIterator.hasNextService(ServiceLoader.java:1244)\r\n\t\tat java.base/java.util.ServiceLoader$LazyClassPathLookupIterator.hasNext(ServiceLoader.java:1273)\r\n\t\tat java.base/java.util.ServiceLoader$2.hasNext(ServiceLoader.java:1309)\r\n\t\tat java.base/java.util.ServiceLoader$3.hasNext(ServiceLoader.java:1393)\r\n\t\tat javax.cache.Caching$CachingProviderRegistry$1.run(Caching.java:448)\r\n\t\tat javax.cache.Caching$CachingProviderRegistry$1.run(Caching.java:442)\r\n\t\tat java.base/java.security.AccessController.doPrivileged(AccessController.java:318)\r\n\t\tat javax.cache.Caching$CachingProviderRegistry.getCachingProviders(Caching.java:442)\r\n\t\tat javax.cache.Caching$CachingProviderRegistry.getCachingProvider(Caching.java:529)\r\n\t\tat javax.cache.Caching$CachingProviderRegistry.getCachingProvider(Caching.java:476)\r\n\t\tat javax.cache.Caching.getCachingProvider(Caching.java:226)\r\n\t\tat ie.davy.configuration.spring.ServicesConfiguration.cacheManager(ServicesConfiguration.java:79)\r\n\t\tat ie.davy.configuration.spring.ServicesConfiguration$$SpringCGLIB$$0.CGLIB$cacheManager$0(<generated>)\r\n\t\tat ie.davy.configuration.spring.ServicesConfiguration$$SpringCGLIB$$FastClass$$1.invoke(<generated>)\r\n\t\tat org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:258)\r\n\t\tat org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331)\r\n\t\tat ie.davy.configuration.spring.ServicesConfiguration$$SpringCGLIB$$0.cacheManager(<generated>)\r\n\t\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\t\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\r\n\t\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\t\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\r\n\t\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:140)\r\n\t\t... 81 more\r\n21-Mar-2024 16:38:15.259 INFO [main] org.apache.catalina.core.ApplicationContext.log Closing Spring root WebApplicationContext\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2024-03-21T16:55:42Z",
        "body": "removing META-INF\\services\\javax.cache.spi.CachingProvider file from redisson.jar should resolve the issue"
      }
    ]
  },
  {
    "number": 2873,
    "title": "redissonClient.getTopic重复消费",
    "created_at": "2020-06-28T12:27:38Z",
    "closed_at": "2020-07-11T04:47:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2873",
    "body": "```\r\nRTopic topic = redissonClient.getTopic(\"testExceptionTopic\");\r\n\r\n        topic.addListener(String.class, new MessageListener<String>() {\r\n            @Override\r\n            public void onMessage(CharSequence charSequence, String calc) {\r\n                if (!lockUtils.acquireLock(calc)){\r\n                    return;\r\n                }\r\n                System.out.println(\"2onMessage:{}\" + charSequence+\",calc:{}\"+ calc);\r\n            }\r\n        });\r\n```\r\n集群形式下，多个订阅会重复消费吗",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2873/comments",
    "author": "0532",
    "comments": [
      {
        "user": "honestAnt",
        "created_at": "2020-07-08T02:50:35Z",
        "body": "会的，要加锁控制"
      }
    ]
  },
  {
    "number": 2867,
    "title": "How could i deserialize a value which put by RedisTemplate of Spring from redis ? ",
    "created_at": "2020-06-23T06:44:08Z",
    "closed_at": "2020-06-23T11:07:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2867",
    "body": "How could i deserialize a value which put by RedisTemplate of Spring from redis ? \r\n\r\nespecially when i used RedisTemplate of spring before in my project, and now changed to Redisson.\r\n\r\nI get an deserialize failed error.\r\n\r\n `redisTemplate.opsForValue().set(\"hello\", \"world\", 5, TimeUnit.MINUTES);\r\n  String result = (String)client.getBucket(\"hello\").get();\r\n`\r\n\r\n>exception stack as follows:\r\n, channel: [id: 0x0451a86f, L:/127.0.0.1:60224 - R:127.0.0.1/127.0.0.1:6379], command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@2875662c(incomplete)], command=(GET), params=[hello], codec=org.redisson.codec.JsonJacksonCodec]\r\ncom.fasterxml.jackson.core.JsonParseException: Unrecognized token 'world': was expecting ('true', 'false' or 'null')\r\n at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 11]\r\n\tat com.fasterxml.jackson.core.JsonParser._constructError(JsonParser.java:1804)\r\n\tat com.fasterxml.jackson.core.base.ParserMinimalBase._reportError(ParserMinimalBase.java:703)\r\n\tat com.fasterxml.jackson.core.json.UTF8StreamJsonParser._reportInvalidToken(UTF8StreamJsonParser.java:3532)\r\n\tat com.fasterxml.jackson.core.json.UTF8StreamJsonParser._handleUnexpectedValue(UTF8StreamJsonParser.java:2627)\r\n\tat com.fasterxml.jackson.core.json.UTF8StreamJsonParser._nextTokenNotInObject(UTF8StreamJsonParser.java:832)\r\n\tat com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextToken(UTF8StreamJsonParser.java:729)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._initForReading(ObjectMapper.java:4141)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4000)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3070)\r\n\tat org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:95)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:352)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:128)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:108)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2867/comments",
    "author": "Chasun-fhd",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-23T11:07:41Z",
        "body": "I think you need to use either StringCodec or BinaryCodec"
      }
    ]
  },
  {
    "number": 2865,
    "title": "redisson 3.13.1 Always connected to redis cluster and can not to acquire lock,but no exception",
    "created_at": "2020-06-22T14:46:52Z",
    "closed_at": "2020-08-05T03:36:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2865",
    "body": "redis version:5.0.8\r\nredisson version: 3.13.1\r\n\r\ni have built redis cluster with six instance。and use cluster nodes to view clusters info。\r\n\r\n81c9bd0505d0d610f3b059ef5027b8794f96b5bb 192.168.200.150:7004@17004 master - 0 1592836302435 5 connected 13107-16383\r\n\r\ne60bd6fbe90da89dad41022a365d4e379b88ce8e 192.168.200.150:7000@17000 myself,master - 0 1592836298000 1 connected 0-3276\r\n\r\n336b6c4f860a8a991e64768d4f71bd82e1f8e621 192.168.200.150:7001@17001 master - 0 1592836300420 2 connected 3277-6553\r\n\r\n16f3ecdaff94e0bac2b017962107181f7238639b 192.168.200.150:7003@17003 master - 0 1592836301428 4 connected 9830-13106\r\n\r\n55c193e6503d06592128a95e33dd422369efd859 192.168.200.150:7002@17002 master - 0 1592836301000 3 connected 6554-9829\r\n\r\nbut when i try to acquire redissonRedLock, i can not to acquire lock. the IDEA console info:\r\n [redisson-netty-8-17] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n [redisson-netty-8-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n [redisson-netty-11-17] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n [redisson-netty-11-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n [redisson-netty-14-17] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n [redisson-netty-14-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n [redisson-netty-2-18] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n [redisson-netty-2-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n [redisson-netty-5-18] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n [redisson-netty-5-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n [redisson-netty-8-18] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n [redisson-netty-8-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n [redisson-netty-11-18] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n [redisson-netty-11-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n[redisson-netty-14-18] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n [redisson-netty-14-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2865/comments",
    "author": "wzh900521",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-23T10:55:26Z",
        "body": "RedLock is deprecated now in favor of RLock with enforced slaves sync in clustered environment."
      }
    ]
  },
  {
    "number": 2863,
    "title": "Why the redisson reconnected the connection  and still throw exceptions",
    "created_at": "2020-06-20T09:44:12Z",
    "closed_at": "2020-07-01T14:02:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2863",
    "body": "       config.setCodec(new StringCodec())\r\n                .useSingleServer()\r\n                .setAddress(\"redis://\" + \"******\" + \":\" + \"6379\")\r\n                .setConnectionMinimumIdleSize(3)\r\n                .setConnectionPoolSize(3)\r\n\r\nusing the latest version .\r\nAfter debugging,I found that when the connection lost,redisson will try to reconnect and it do succeed,but it still throw an Exception.\r\nI have try enlarging the timeout options,But it just idel there .Can somebody tell me how to solve this?\r\n\r\n\r\n////////////////////////////////////////////\r\n\r\n2020-06-20 17:41:58.529 [http-nio-18080-exec-1] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet].log:175 - USER: NULL_USER Servlet.service() for servlet [dispatcherServlet] in context with path [/api] threw exception \r\norg.redisson.client.RedisTimeoutException: Command still hasn't been written into connection! Increase nettyThreads and/or retryInterval settings. Payload size in bytes: 29. Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@491672465 [redisClient=[addr=redis://*******:6379], channel=[id: 0x1a073aa2, L:/192.168.0.111:60488 - R:/1******:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@326e8324(failure: java.util.concurrent.CancellationException)], command=(PSETEX), params=[user:token:secret:13560124863, 2592000000, PooledUnsafeDirectByteBuf(ridx: 0, widx: 29, cap: 256)], codec=org.redisson.client.codec.StringCodec]], command: (PSETEX), params: [user:token:secret:13560124863, 2592000000, PooledUnsafeDirectByteBuf(ridx: 0, widx: 29, cap: 256)] after 3 retry attempts\r\n\tat org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:200)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:680)\r\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:755)\r\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:483)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2863/comments",
    "author": "11800222",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-22T06:30:40Z",
        "body": "Which Redisson version do you use?"
      },
      {
        "user": "wzh900521",
        "created_at": "2020-06-22T14:50:16Z",
        "body": "**hello, I use Redisson version is 3.13.1。but i can not to acquire lock。constantly refresh in the console**\r\n\r\n\r\n22:34:26.535 [redisson-netty-8-17] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n22:34:26.535 [redisson-netty-8-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n22:34:26.613 [redisson-netty-11-17] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n22:34:26.613 [redisson-netty-11-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n22:34:26.676 [redisson-netty-14-17] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n22:34:26.676 [redisson-netty-14-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n22:34:31.322 [redisson-netty-2-18] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n22:34:31.322 [redisson-netty-2-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n22:34:31.455 [redisson-netty-5-18] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n22:34:31.455 [redisson-netty-5-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n22:34:31.537 [redisson-netty-8-18] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n22:34:31.537 [redisson-netty-8-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n22:34:31.615 [redisson-netty-11-18] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n22:34:31.615 [redisson-netty-11-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n22:34:31.677 [redisson-netty-14-18] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150\r\n22:34:31.677 [redisson-netty-14-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150\r\n"
      },
      {
        "user": "11800222",
        "created_at": "2020-06-23T02:23:14Z",
        "body": "> Which Redisson version do you use?\r\n\r\n 3.13.1"
      },
      {
        "user": "mrniko",
        "created_at": "2020-06-23T11:10:35Z",
        "body": "Try to set `pingConnectionInterval` setting"
      }
    ]
  },
  {
    "number": 2855,
    "title": "Issue with config when trying Tomcat Session Management",
    "created_at": "2020-06-18T16:52:46Z",
    "closed_at": "2020-06-19T08:40:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2855",
    "body": "I'm attempting to the RedissonSessionManager to handle sessions for tomcat.  I have setup the manager like this in my tomcat context.xml file\r\n`Manager className=\"org.redisson.tomcat.RedissonSessionManager\"\r\n             configPath=\"${catalina.base}/conf/redisson.yaml\" readMode=\"MEMORY\" updateMode=\"DEFAULT\" />`\r\n\r\nand created the following redisson.yaml file\r\n\r\n`singleServerConfig:\r\n  idleConnectionTimeout: 10000\r\n  connectTimeout: 10000\r\n  timeout: 3000\r\n  retryAttempts: 3\r\n  retryInterval: 1500\r\n  password: null\r\n  subscriptionsPerConnection: 5\r\n  clientName: null\r\n  address: \"redis://<removed this>:6379\"\r\n  subscriptionConnectionMinimumIdleSize: 1\r\n  subscriptionConnectionPoolSize: 50\r\n  connectionMinimumIdleSize: 24\r\n  connectionPoolSize: 64\r\n  database: 0\r\n  dnsMonitoringInterval: 5000\r\nthreads: 16\r\nnettyThreads: 32\r\ncodec: !<org.redisson.codec.FstCodec> {}\r\ntransportMode: \"NIO\"`\r\n\r\nWith it set like this I get this error,......\r\n`aused by: java.lang.NoSuchMethodError: org.nustaq.serialization.FSTConfiguration.getJsonFieldNames()Lorg/nustaq/serialization/coders/FSTJsonFieldNames;                at org.redisson.codec.FstCodec.copy(FstCodec.java:201)\r\n                at org.redisson.codec.FstCodec.<init>(FstCodec.java:190)                ... 46 more`\r\n\r\nI had to manually add the fst-2.47.jar as well as the objenesis-3.1.jar to get this and I'm kind of stuck now.  \r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2855/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-19T08:39:47Z",
        "body": "starting from 3.13.0 MarshallingCodec is used by default and boundled with redisson-all.jar. So you don't need to add this codec manually.\r\n\r\njava.lang.NoSuchMethodError usually means that you have two different versions of the same lib in classpath"
      },
      {
        "user": "ghost",
        "created_at": "2020-06-19T11:44:47Z",
        "body": "Thanks for the update."
      }
    ]
  },
  {
    "number": 2848,
    "title": "org.redisson.client.RedisException: BUSY Redis is busy running a script.",
    "created_at": "2020-06-17T14:28:52Z",
    "closed_at": "2020-07-02T12:50:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2848",
    "body": "We are using redis delay queue and see below error with around 20k message in queue.\r\n\r\norg.redisson.client.RedisException: BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.. channel: [id: 0x6186980c, L:/127.0.0.1:54603 - R:/127.0.0.1:6379] command: CommandData [promise=org.redisson.misc.RedissonPromise@16ae7198[Not completed], command=(LPOP), params=[delayEventQueue-local], codec=org.redisson.codec.JsonJacksonCodec@4631b499]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:266)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:126)\r\n\r\n\r\nBelow is the config.\r\n\r\n{\r\n  \"singleServerConfig\":{\r\n    \"idleConnectionTimeout\":10000,\r\n    \"pingConnectionInterval\":1000,\r\n    \"connectTimeout\":10000,\r\n    \"timeout\":3000,\r\n    \"retryAttempts\":3,\r\n    \"retryInterval\":1500,\r\n    \"reconnectionTimeout\":3000,\r\n    \"failedAttempts\":3,\r\n    \"password\":null,\r\n    \"subscriptionsPerConnection\":5,\r\n    \"clientName\":null,\r\n    \"address\": \"redis://127.0.0.1:6379\",\r\n    \"subscriptionConnectionMinimumIdleSize\":1,\r\n    \"subscriptionConnectionPoolSize\":50,\r\n    \"connectionMinimumIdleSize\":10,\r\n    \"connectionPoolSize\":64,\r\n    \"database\":0,\r\n    \"dnsMonitoringInterval\":5000\r\n  },\r\n  \"threads\":0,\r\n  \"nettyThreads\":0,\r\n  \"codec\":null,\r\n  \"useLinuxNativeEpoll\":false\r\n}\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2848/comments",
    "author": "anilkonduru",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-17T15:29:23Z",
        "body": "I you need to reduce messages amount processed in script."
      },
      {
        "user": "anilkonduru",
        "created_at": "2020-06-17T16:45:00Z",
        "body": "@mrniko this is not a script. Polling for message on RQueue every 1 sec with a scheduler.\r\n\r\nRQueue<AppData> readQueue = redissonClient.getQueue(\"qname\");\r\n**AppData data = readQueue.poll();**\r\n\r\nI am seeing both issues mentioned below when there are good number (10000) messages on the queue.\r\n1) \"BUSY Redis is busy running a script.\" \r\n2) org.redisson.client.RedisTimeoutException: Redis server response timeout (3000 ms) occurred for command:\r\n\r\n**Adding pingConnectionInterval didn't help.**\r\n\r\n\r\norg.redisson.client.RedisException: BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.. channel: [id: 0xa6d2bad5, L:/127.0.0.1:61710 - R:/127.0.0.1:6379] command: (LPOP), params: [delayEventQueue-local]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:287)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2020-06-18T03:46:11Z",
        "body": "try to run SLOWLOG to get more info about slow scripts."
      }
    ]
  },
  {
    "number": 2847,
    "title": "Using lockAsync with Scala Akka ",
    "created_at": "2020-06-17T10:29:22Z",
    "closed_at": "2020-06-17T23:31:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2847",
    "body": "Hi,\r\n\r\nDoes lockAsync / unlockAsync and bucket async APIs work with Akka actor using Scala/Play?\r\n\r\nI am getting the exceptin below:\r\n\r\njava.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id\r\n\r\nIs that because of unlockAsync being triggered inside Future of lockAsync? I am using Scala converters to get Scala Futures from these APIs.\r\n\r\nIf I generate my own thread ids using random long then it does work.\r\n\r\nThanks\r\nRakesh\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2847/comments",
    "author": "shahrakesh",
    "comments": [
      {
        "user": "shahrakesh",
        "created_at": "2020-06-17T11:04:56Z",
        "body": "Complete Exception stack trace:\r\n\r\njava.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: 557321d4-b4c4-4154-85d4-83b6bee99eb2 thread-id: 26\r\n        at org.redisson.RedissonLock.lambda$unlockAsync$3(RedissonLock.java:601)\r\n        at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551)\r\n        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)\r\n        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)\r\n        at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:604)\r\n        at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\r\n        at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)\r\n        at org.redisson.client.handler.CommandDecoder.completeResponse(CommandDecoder.java:451)\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2020-06-17T16:11:25Z",
        "body": "use methods with threadId parameter."
      },
      {
        "user": "shahrakesh",
        "created_at": "2020-06-17T21:11:38Z",
        "body": "Thanks for confirming. "
      }
    ]
  },
  {
    "number": 2844,
    "title": "Is it possible to access to the data maintained or written by Redisson in Nodejs? And would it be a bad practice?",
    "created_at": "2020-06-17T04:51:15Z",
    "closed_at": "2020-06-29T06:23:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2844",
    "body": "Hi, I have using Redisson for not a long time, and I realize that I need my old project to access to Redis and retrieve data that is maintained by the current Java code which use Redisson. \r\nBut Redisson is not just a redis client but a In-Memory Data Grid, therefore it's quite different and not compatible friendly for nodejs program for it only has pure redis client tools to use. \r\nSo the idea I have is:\r\n1. Write a Java Redisson program as a proxy and serve data for nodejs program. \r\n2. Figure out how Redisson save data, for sorted set, and Bucket, and write a package for nodejs to decode data from Redis. \r\n3. Give up Redisson and use pure redis client, like Redis. \r\n\r\nIs there any other solutions? Or is there any nodejs middleware for Redisson? Would that be difficult to write one for Redisson(I haven't read much source code of Redisson yet)? \r\nThanks. ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2844/comments",
    "author": "XLCYun",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-17T04:54:52Z",
        "body": "> But Redisson is not just a redis client but a In-Memory Data Grid, therefore it's quite different and not compatible friendly for nodejs program for it only has pure redis client tools to use.\r\n\r\nIt's still remains redis client and compatible with others as long as they store the data in the same format."
      },
      {
        "user": "XLCYun",
        "created_at": "2020-06-17T05:43:41Z",
        "body": "> > But Redisson is not just a redis client but a In-Memory Data Grid, therefore it's quite different and not compatible friendly for nodejs program for it only has pure redis client tools to use.\r\n> \r\n> It's still remains redis client and compatible with others as long as they store the data in the same format.\r\n\r\nHi, thanks for you reply. I see that Redisson use `Marshalling` Codec as default codec, and it store `true` as `\"\\x04P\"` and `false` as `\"\\x04Q\"`, and String `\"A\"` as `\"\\x04>\\x01A\"`.\r\nI think these prefixes are added by `MarshallingCodec`, so are you saying I should write a nodejs program to decode these value if it's possible, or I should write a Codec on my own? \r\nAm I going to the right direction and which one should be preferred by your opinion? Thanks. "
      },
      {
        "user": "mrniko",
        "created_at": "2020-06-17T07:17:20Z",
        "body": "You can use json codec, for example."
      },
      {
        "user": "XLCYun",
        "created_at": "2020-06-29T06:23:55Z",
        "body": "Locks maintained by Redisson might be bit tricky to cooperate with in Node.js. Use `JsonJacksonCodec` or other codec is easy for sharing data between different program written in different language. Issue closed, thanks for the help @mrniko . "
      }
    ]
  },
  {
    "number": 2842,
    "title": "How to retrieve DelayedQueue by name using getDelayedQueue",
    "created_at": "2020-06-17T02:39:53Z",
    "closed_at": "2020-06-17T14:42:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2842",
    "body": "Want to understand how to retrieve delayed queue (RDelayedQueue) by name using getDelayedQueue method on org.redisson.api.RedissonClient. \r\n\r\nDoes it require to call redissonClient.getDelayedQueue(destinationQueue) every time before queuing a message as below or retrieve queue once and use it for every message queuing ?\r\n\r\nRDelayedQueue..offer(message, delayInMillisFromCurrent, TimeUnit.MILLISECONDS);",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2842/comments",
    "author": "anilkonduru",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-17T04:52:10Z",
        "body": "No, you can store RDelayedQueue instance and use it."
      },
      {
        "user": "anilkonduru",
        "created_at": "2020-06-17T14:42:38Z",
        "body": "@mrniko Thanks, that helps."
      }
    ]
  },
  {
    "number": 2841,
    "title": "RedisTimeoutException: Redis server response timeout (3000 ms) occured for command: (LPOP) with params: [delayEventQueue-local]",
    "created_at": "2020-06-17T01:44:08Z",
    "closed_at": "2020-07-02T12:50:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2841",
    "body": "I am getting below error while trying push a message to RDelayedQueue. Using Redission version 3.6.2. Any thoughts?\r\n\r\norg.redisson.client.RedisTimeoutException: Redis server response timeout (3000 ms) occured for command: (LPOP) with params: [delayEventQueue-local] channel: [id: 0x1b6f637b, L:/127.0.0.1:50820 - R:/127.0.0.1:6379]\r\n\r\nAlso, below error pop up sometimes.\r\n\r\norg.redisson.client.RedisTimeoutException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=org.redisson.connection.SingleEntry@52d9b542], connection: [id: 0xb7d5d47c, L:/127.0.0.1:54223 - R:/127.0.0.1:6379], command: (EVAL), command params: [local result = {}; local items = redis.call('lrange', KEYS[1], 0, -1); for i, v in ipairs(items) do ..., 1, redisson_delay_queue:{delayEventQueue-local}] after 3 retry attempts\r\n\r\n\r\nBelow are my settings.\r\n\r\n{\r\n  \"singleServerConfig\":{\r\n    \"idleConnectionTimeout\":10000,\r\n    \"pingTimeout\":1000,\r\n    \"connectTimeout\":10000,\r\n    \"timeout\":3000,\r\n    \"retryAttempts\":3,\r\n    \"retryInterval\":1500,\r\n    \"reconnectionTimeout\":3000,\r\n    \"failedAttempts\":3,\r\n    \"password\":null,\r\n    \"subscriptionsPerConnection\":5,\r\n    \"clientName\":null,\r\n    \"address\": \"redis://127.0.0.1:6379\",\r\n    \"subscriptionConnectionMinimumIdleSize\":1,\r\n    \"subscriptionConnectionPoolSize\":50,\r\n    \"connectionMinimumIdleSize\":10,\r\n    \"connectionPoolSize\":64,\r\n    \"database\":0,\r\n    \"dnsMonitoringInterval\":5000\r\n  },\r\n  \"threads\":16,\r\n  \"nettyThreads\":32,\r\n  \"codec\":null,\r\n  \"useLinuxNativeEpoll\":false\r\n}\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2841/comments",
    "author": "anilkonduru",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-17T04:44:57Z",
        "body": "set `pingConnectionInterval` instead of `pingTimeout`"
      }
    ]
  },
  {
    "number": 2838,
    "title": "AWS elastic cache Shards support in Redisson",
    "created_at": "2020-06-15T13:04:58Z",
    "closed_at": "2020-06-15T13:20:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2838",
    "body": "I have a sharded AWS cluster enabled elastic cache with multiple shards.\r\nI want to use the Redisson client to interact with my AWS Elastic Cache .\r\nCan this be possible in OpenSource Redisson or it's possible only in Redisson pro?\r\n\r\nAlso it would be really helpful if you can share a sample code to connect to a sharded AWS elastic Cache using Redisson Client\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2838/comments",
    "author": "akshitjain",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-15T13:17:38Z",
        "body": "Just use AWS endpoint as node address in Redisson cluster config."
      }
    ]
  },
  {
    "number": 2829,
    "title": "support redis version?",
    "created_at": "2020-06-10T09:58:13Z",
    "closed_at": "2020-06-10T14:26:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2829",
    "body": "redisson support redis 6.0+ ?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2829/comments",
    "author": "mail6562",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-10T14:26:51Z",
        "body": "Yes."
      }
    ]
  },
  {
    "number": 2828,
    "title": "redisson lock",
    "created_at": "2020-06-10T09:22:01Z",
    "closed_at": "2020-06-10T16:43:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2828",
    "body": "Hello,\r\nI have a quick question about the redisson lock.\r\nDoes the redisson lock is share between all clients ? We have several services/jvm and we want to be sure that these services cannot read / write in concurrently on the same ressources.\r\nWe use AWS redis with 1 master and 2 slave.\r\n\r\nThank you\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2828/comments",
    "author": "gderemetz",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-10T16:43:55Z",
        "body": "> Does the redisson lock is share between all clients ?\r\n\r\nYes. Since as long as clients connected to the same Redis database."
      }
    ]
  },
  {
    "number": 2826,
    "title": "volumes for redis replica nodes in docker swaram environment?",
    "created_at": "2020-06-09T07:27:15Z",
    "closed_at": "2020-10-01T07:42:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2826",
    "body": "We have an application in which we are using Redis as a small database.\r\n\r\nWe are using Redis in a master-slave configuration in docker swarm environment. We have **1 master node and 2 replica nodes**.\r\n\r\nFor persistent storage we have enabled volumes for master/replica nodes in docker swarm environment e.g if container restarts it can pick data from the volumes file on disk.\r\n\r\nFew of my doubts are as below -\r\n- Is it necessary to enable volumes for replica nodes?\r\n- If we have volumes enabled for replica nodes, in a scenario when replica docker container restarts, will it pick its data from its volumes file on disk? or it ignores that file and only get data after syncing with master node?\r\n\r\nPlease let me know if you need more information.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2826/comments",
    "author": "kuldeepsidhu88",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-01T07:42:42Z",
        "body": "> Is it necessary to enable volumes for replica nodes?\r\n\r\nNo\r\n\r\n> If we have volumes enabled for replica nodes, in a scenario when replica docker container restarts, will it pick its data from its volumes file on disk? or it ignores that file and only get data after syncing with master node?\r\n\r\nReplica is synced with master on start."
      },
      {
        "user": "kuldeepsidhu88",
        "created_at": "2020-10-04T07:46:14Z",
        "body": "@mrniko If we add sentinel in this scenario, and I want to have persistence for my redis, in that case do we need to enable volumes for all nodes master and replica ?\r\nI am thinking if actual master goes down and one of the replica becomes master, how can we have persistence in that case if we do not have volumes enabled for replica nodes?"
      }
    ]
  },
  {
    "number": 2816,
    "title": "AWS Reader DNS being defined as master during failover",
    "created_at": "2020-06-03T16:18:52Z",
    "closed_at": "2020-06-13T03:57:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2816",
    "body": "Scenario:\r\nWe configured Redisson with 2 AWS DNS endpoints: Primary and Reader. Primary has one node and Reader has 2.\r\n\r\nAfter failover, one of the read replicas got promoted as the primary. Technically, since this happened behind the scene in AWS, we should not see any change to the Primary and Reader.\r\n\r\nHowever, in Redisson log, we saw the type of the Reader endpoint got changed to be Master\r\n\r\nBefore failover:\r\nredis://primary.dns - Type: Master\r\n\r\nAfter failover:\r\nredis://reader.dns - Type: Master\r\n\r\nWonder if this is a bug or we didn't configure our Redisson correctly. Any help would be greatly appreciated\r\n\r\nRedisson version: 3.10.4\r\nConfiguration:\r\n- ReplicatedServers\r\n- ReadMode.MASTER\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2816/comments",
    "author": "h-ngo",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-04T10:27:49Z",
        "body": "Could you share full Redisson log output? "
      },
      {
        "user": "h-ngo",
        "created_at": "2020-06-04T16:40:03Z",
        "body": "@mrniko Will try to get your the logs as soon as I can. There are some internal info that will need to be filtered out before I can share. Thanks a lot."
      },
      {
        "user": "h-ngo",
        "created_at": "2020-06-13T03:57:25Z",
        "body": "Closing this as we have decided to switch to cluster mode. Testing result looks much more promising than replicated mode."
      }
    ]
  },
  {
    "number": 2807,
    "title": "redisson lock uncontrolled release ",
    "created_at": "2020-05-31T09:49:56Z",
    "closed_at": "2020-08-28T12:31:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2807",
    "body": "Hi all, \r\nI am facing strange problems with Redisson lock.\r\nI use the lock without expiration - which means is that watchdog mechanism in-charge of updating the lease time of the lock in redis.\r\nThreads that are using the lock, lock it for time ranging from couple of seconds to 300 seconds or even more.\r\n**The problem:**\r\nsometimes when a thread(that acquired it) tries to release the lock the thread receives **IllegalMonitorStateException** , which means that this lock is already released. \r\n\r\nOne solution was to increase the watchdog timeout - I increased it to 100 seconds and it decreased the number of errors but they still occur from time to time...\r\n\r\nI don't want to increase the timeout even more because this doesn't address the root problem.\r\nHow can I solve this? is anyone else encountered this behaviour? \r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2807/comments",
    "author": "mishanius",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-07-03T05:35:25Z",
        "body": "> sometimes when a thread(that acquired it) tries to release the lock the thread receives IllegalMonitorStateException\r\n\r\nPlease check that you use the same thread to release it."
      }
    ]
  },
  {
    "number": 2805,
    "title": "Unable to decode data. channel:[id: 0x571044ad, L:/10.0.0.1] message: +PONG +PONG",
    "created_at": "2020-05-30T03:12:51Z",
    "closed_at": "2020-06-18T07:48:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2805",
    "body": "Unable to decode data. channel: [id: 0x571044ad,] message: +PONG\r\n+PONG\r\n+PONG\r\n:2\r\n+PONG\r\n+PONG\r\n*2\r\n$1\r\n0\r\n*0\r\n+PONG\r\n+PONG\r\n+PONG\r\n$-1\r\n+PONG\r\n+PONG\r\n+PONG\r\n+PONG\r\n+PONG\r\n:1\r\n+PONG\r\n+PONG\r\n+PONG\r\n+PONG\r\n+PONG\r\n:2\r\n+PONG\r\n+PONG\r\n:1\r\n+PONG\r\n+PONG\r\n+PONG\r\n:1\r\n+PONG\r\n+PONG\r\n+PONG\r\n$-1\r\n+PONG\r\n+PONG\r\n+PONG\r\n:1\r\n+PONG\r\n+PONG\r\n+PONG\r\n+PONG\r\n+PONG\r\n$-1\r\n+PONG\r\n+PONG\r\n+PONG\r\n:0\r\n+PONG\r\n+PONG\r\n+PONG\r\n+PONG\r\n+PONG\r\n+PONG\r\n$34\r\n+PONG\r\n+PONG\r\n+PONG\r\n......\r\njava.lang.ClassCastException: null\r\n\r\n大佬们能帮忙看看redisson在什么情况下才会返回以上这些+PONG的信息，现在一直不能重现上面的返回内容。\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2805/comments",
    "author": "huashaofei",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-30T04:31:30Z",
        "body": "Which Redisson version do you use?"
      },
      {
        "user": "huashaofei",
        "created_at": "2020-06-02T05:42:31Z",
        "body": "----- 原始邮件 -----\n发件人：Nikita Koksharov <notifications@github.com>\n收件人：redisson/redisson <redisson@noreply.github.com>\n抄送人：huashaofei <huashaofei17@sina.com>,  Author <author@noreply.github.com>\n主题：Re: [redisson/redisson] Unable to decode data. channel:[id: 0x571044ad, L:/10.0.0.1] message: +PONG +PONG (#2805)\n日期：2020年05月30日 12点31分\n\n\r\nWhich Redisson version do you use?\r\n\r\n—\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or unsubscribe."
      }
    ]
  },
  {
    "number": 2789,
    "title": "Redisson scalable put on cluster nodes",
    "created_at": "2020-05-21T14:53:55Z",
    "closed_at": "2020-07-03T05:34:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2789",
    "body": "Hello:\r\n\r\nI am new to Redis. And I wrote a simple code to test hashmap objects in a Redis cluster of 3 nodes.\r\n\r\n\r\n    final ClusterServersConfig clusterconfig = config.useClusterServers();\r\n    clusterconfig.addNodeAddress(clusternodeurl1);\r\n    clusterconfig.addNodeAddress(clusternodeurl2);\r\n    clusterconfig.addNodeAddress(clusternodeurl3);\r\n    redisson = Redisson.create(config);\r\n    map = redisson.getMapCache(\"test\");\r\n    map.put(\"key1\", \"value1\");\r\n    map.put(\"key2\", \"value2\");\r\n\r\n\r\nThen I try the redis-cli to get all hashmap objects. it seems that all pairs are stored on the same cluster node instead of round-robin.\r\n\r\n192.168.5.66:6379> HGETALL test\r\n-> Redirected to slot [6918] located at 192.168.5.62:6379\r\n1) \"\\xfc\\x04key1\"\r\n2) \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xfc\\x06value1\"\r\n3) \"\\xfc\\x04key2\"\r\n4) \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xfc\\x06value2\"\r\n\r\n\r\nHowever, when I use the redis-cli to put key and value pairs into the cluster, I can see it is round-robin.\r\n\r\nMay I know how to put hashmap object in the round-robin way?\r\n\r\nIn my test environment, redission maven\r\n    <dependency>\r\n        <groupId>org.redisson</groupId>\r\n        <artifactId>redisson</artifactId>\r\n        <version>3.12.3</version>\r\n    </dependency>\r\n\r\nredis server 6.0.1.\r\n\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2789/comments",
    "author": "bingzhang",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-22T07:46:49Z",
        "body": "> it seems that all pairs are stored on the same cluster node instead of round-robin.\r\n\r\nThat's correct since map data belong to a single Redis key."
      },
      {
        "user": "mrniko",
        "created_at": "2020-05-22T07:47:41Z",
        "body": "> However, when I use the redis-cli to put key and value pairs into the cluster, I can see it is round-robin.\r\n\r\n> -> Redirected to slot [6918] located at 192.168.5.62:6379\r\n\r\nIt's just redirect call to the node which holds with map"
      },
      {
        "user": "bingzhang",
        "created_at": "2020-05-22T14:32:02Z",
        "body": "@mrniko Thank you very much. \r\n\r\nIn my user case, I need to store key, value pair into redis cluster. May you please suggest or show me whether there is a way to do scalable put using redission lib? If there is a document or sample code, that will be very helpful.\r\n\r\nThanks."
      },
      {
        "user": "mrniko",
        "created_at": "2020-07-03T05:34:19Z",
        "body": "ClusteredMapCache object available in PRO version"
      }
    ]
  },
  {
    "number": 2788,
    "title": "Why we need to execute SENTINEL SENTINELS command? ",
    "created_at": "2020-05-21T04:49:47Z",
    "closed_at": "2020-05-21T07:03:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2788",
    "body": "In this case, I configured the all intranet domain sentinel node list info。\r\nlike this\r\n\r\n``` yml\r\nspring:\r\n    redis:\r\n        sentinel:\r\n          nodes:\r\n            - inner.domain1:port\r\n            - inner.domain2:port\r\n            - inner.domain3:port\r\n          master: master_name\r\n```\r\nBut I can't start redisson successfully,  it throws a **RedisConnectionException** with '**SENTINEL SENTINELS command returns less than 2 nodes..**' message\r\n\r\nBecause the first configured sentinel node will be used to execute the **SENTINEL SENTINELS MASTER_NAME** command when initializing the **SentinelConnectionManager**, and then try to connect to the returned node list.\r\n\r\nBut the IP:PORT information of the sentinel node list we return is inaccessible by the current machine（By default, we only allow access via intranet domain）, So all these sentinel node failed to register, except the current node（It uses intranet domain access）。\r\n\r\n``` java\r\nList<Map<String, String>> sentinelSentinels = connection.sync(StringCodec.INSTANCE, RedisCommands.SENTINEL_SENTINELS, cfg.getMasterName());\r\nList<RFuture<Void>> connectionFutures = new ArrayList<>(sentinelSentinels.size());\r\nfor (Map<String, String> map : sentinelSentinels) {\r\n\tif (map.isEmpty()) {\r\n\t\tcontinue;\r\n\t}\r\n\r\n\tString ip = map.get(\"ip\");\r\n\tString port = map.get(\"port\");\r\n\r\n\tRedisURI sentinelAddr = toURI(ip, port);\r\n\t// I cannot register this node \r\n\t// because I cannot access it use this ip and port\r\n\tRFuture<Void> future = registerSentinel(sentinelAddr, this.config);\r\n\tconnectionFutures.add(future);\r\n}\r\nRedisURI currentAddr = toURI(client.getAddr().getAddress().getHostAddress(), \"\" + client.getAddr().getPort());\r\nRFuture<Void> f = registerSentinel(currentAddr, this.config);\r\n\r\n\r\n```\r\n\r\nCan we add an option to directly use the configured node list without having to execute the  **SENTINEL SENTINELS MASTER_NAME** command to get the list?\r\n\r\nNow, I called dba to restart the sentinel node list, and replaced the sentinel list information, so that the information returned by sentinel list api can be accessed by my current machine, temporarily solved this problem.\r\n\r\nHowever, if my new machine in another network cluster also needs to use redisson to connect to this sentinel cluster, things will become more troublesome.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2788/comments",
    "author": "nameqxq",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-21T07:03:32Z",
        "body": "> Can we add an option to directly use the configured node list without having to execute the SENTINEL SENTINELS MASTER_NAME command to get the list?\r\n\r\nYou can set `checkSentinelsList = false`"
      },
      {
        "user": "nameqxq",
        "created_at": "2020-05-21T07:05:43Z",
        "body": "But then I only have one sentinel node, but obviously I can have three"
      },
      {
        "user": "mrniko",
        "created_at": "2020-05-21T08:38:33Z",
        "body": "this setting only skip this check `SENTINEL SENTINELS command returns less than 2 nodes..`"
      },
      {
        "user": "nameqxq",
        "created_at": "2020-05-21T08:50:01Z",
        "body": "But in this logic, **break** will cause my other two sentinel nodes not to be registered\r\ncheckSentinelsList = false only make this not throw Exception\r\n``` java\r\nfor (String address : cfg.getSentinelAddresses()) {\r\n\tRedisURI addr = new RedisURI(address);\r\n\t// skip some code\r\n\tList<Map<String, String>> sentinelSentinels = connection.sync(StringCodec.INSTANCE, RedisCommands.SENTINEL_SENTINELS, cfg.getMasterName());\r\n\tList<RFuture<Void>> connectionFutures = new ArrayList<>(sentinelSentinels.size());\r\n\tfor (Map<String, String> map : sentinelSentinels) {\r\n\t\tif (map.isEmpty()) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tString ip = map.get(\"ip\");\r\n\t\tString port = map.get(\"port\");\r\n\t\tRedisURI sentinelAddr = toURI(ip, port);\r\n\t \tRFuture<Void> future = registerSentinel(sentinelAddr, this.config);\r\n\t\tconnectionFutures.add(future);\r\n\t}\r\n\r\n\tRedisURI currentAddr = toURI(client.getAddr().getAddress().getHostAddress(), \"\" + client.getAddr().getPort());\r\n\tRFuture<Void> f = registerSentinel(currentAddr, this.config);\r\n\tconnectionFutures.add(f);\r\n\r\n\tfor (RFuture<Void> future : connectionFutures) {\r\n\t\tfuture.awaitUninterruptibly(this.config.getConnectTimeout());\r\n\t}\r\n\t// the other two sentinel nodes that I configured did not register successfully\r\n\tbreak;\r\n}\r\n// skip some code ..\r\n// checkSentinelsList = false only make this not throw Exception\r\nif (cfg.isCheckSentinelsList()) {\r\n\tif (sentinels.size() < 2) {\r\n\t\tstopThreads();\r\n\t\tthrow new RedisConnectionException(\"SENTINEL SENTINELS command returns less than 2 nodes! At least two sentinels should be defined in Redis configuration. Set checkSentinelsList = false to avoid this check.\", lastException);\r\n\t}\r\n}\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2020-05-21T08:55:55Z",
        "body": "sentinels are added in registerSentinel method"
      },
      {
        "user": "nameqxq",
        "created_at": "2020-05-21T09:01:54Z",
        "body": "But my sentinels can only be accessed through the intranet domain（I will configure all the nodes），and the sentinel list api returned ip port is inaccessible.\r\n``` java\r\nList<Map<String, String>> sentinelSentinels = connection.sync(StringCodec.INSTANCE, RedisCommands.SENTINEL_SENTINELS, cfg.getMasterName());\r\nList<RFuture<Void>> connectionFutures = new ArrayList<>(sentinelSentinels.size());\r\nfor (Map<String, String> map : sentinelSentinels) {\r\n\tif (map.isEmpty()) {\r\n\t\tcontinue;\r\n\t}\r\n\r\n\tString ip = map.get(\"ip\");\r\n\tString port = map.get(\"port\");\r\n\r\n\tRedisURI sentinelAddr = toURI(ip, port);\r\n\t// I cannot register this node \r\n\t// because I cannot access it use this ip and port\r\n\tRFuture<Void> future = registerSentinel(sentinelAddr, this.config);\r\n\tconnectionFutures.add(future);\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 2783,
    "title": "org.redisson.client.RedisTimeoutException: Subscribe timeout: (30000ms)",
    "created_at": "2020-05-19T05:48:12Z",
    "closed_at": "2020-06-16T07:26:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2783",
    "body": "每隔一段时间获取分布式锁的时候就会抛出这个异常，抛出异常前主节点曾宕掉，哨兵选举出主节点后就出现了这个问题",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2783/comments",
    "author": "AlliumDuck",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-16T07:26:56Z",
        "body": "Increase subscription connections pool size"
      }
    ]
  },
  {
    "number": 2782,
    "title": "How to configure scheduling times? ",
    "created_at": "2020-05-19T03:56:55Z",
    "closed_at": "2020-05-19T05:29:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2782",
    "body": "When using the periodic scheduling method（e.g. RScheduledExecutorService.scheduleAtFixedRate）, I want to stop scheduling after a specified number of times. What should I do?\r\nThanks!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2782/comments",
    "author": "hgqapp",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-19T05:29:49Z",
        "body": "You can implement this logic right in the task.\r\n\r\n```java\r\nclass RunnableTask implements Runnable {\r\n\r\n    @RInject\r\n    private RedissonClient redissonClient;\r\n\r\n    @RInject\r\n    private String taskId;\r\n\r\n    public void run() {\r\n         if (redissonClient.getAtomicLong(\"\").incrementAndGet() == 10) {\r\n              redissonClient.getExecutorService(\"\").cancelTask(taskId);\r\n         }\r\n    }\r\n}\r\n```"
      },
      {
        "user": "hgqapp",
        "created_at": "2020-05-19T06:04:34Z",
        "body": "@mrniko Thanks, your answer is very useful to me."
      }
    ]
  },
  {
    "number": 2772,
    "title": "redis-cli scan 0 COUNT 20 equivalent in redisson",
    "created_at": "2020-05-15T05:08:41Z",
    "closed_at": "2020-05-19T07:59:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2772",
    "body": "I want to know what is the >redis-cli scan 0 COUNT 20 equivalent in redisson. I have 4  million records in redis and want to iterate through them (with a key pattern)\r\n\r\nI tried using Stream<String> getKeysStreamByPattern(String var1, int var2); and Iterable<String> getKeysByPattern(String var1, int var2); but it hangs infinitly. ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2772/comments",
    "author": "rautnin1103",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-15T07:15:46Z",
        "body": "> I tried using Stream getKeysStreamByPattern(String var1, int var2); and Iterable getKeysByPattern(String var1, int var2); but it hangs infinitly.\r\n\r\nThese methods are equivalent to scan 0 COUNT 20 command. Did you define 20 as second argument? Do you use the same machine used to invoke command through redis-cli?"
      }
    ]
  },
  {
    "number": 2767,
    "title": "sentinel: redis://xxx was down",
    "created_at": "2020-05-14T04:44:19Z",
    "closed_at": "2020-05-14T07:35:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2767",
    "body": "I use org.redisson:redisson-spring-boot-starter:3.12.5.\r\nWhen spring-boot app with spring yaml redis section\r\n      redis:\r\n        password: \"X\"\r\n        sentinel:\r\n          password: \"X\"\r\n          master: mymaster\r\n          nodes: XXX:26379\r\nstarted i see in log file\r\n\r\n[redisson-netty-2-18] WARN  o.r.c.SentinelConnectionManager updateSentinels sentinel: redis://10.110.22.88:26379 was down\r\n09:40:12 [redisson-netty-2-17] INFO  o.r.c.SentinelConnectionManager lambda$null$7 sentinel: redis://10.148.2.50:26379 added\r\n09:40:15 [redisson-netty-2-26] INFO  o.r.c.SentinelConnectionManager lambda$null$7 sentinel: redis://10.110.22.88:26379 added\r\n09:40:16 [redisson-netty-2-2] WARN  o.r.c.SentinelConnectionManager updateSentinels sentinel: redis://10.148.11.233:26379 was down\r\n09:40:17 [redisson-netty-2-21] WARN  o.r.c.SentinelConnectionManager updateSentinels sentinel: redis://10.110.22.88:26379 was down\r\n09:40:17 [redisson-netty-2-5] INFO  o.r.c.SentinelConnectionManager lambda$null$7 sentinel: redis://10.148.11.233:26379 added\r\n09:40:20 [redisson-netty-2-30] INFO  o.r.c.SentinelConnectionManager lambda$null$7 sentinel: redis://10.110.22.88:26379 added\r\n09:40:21 [redisson-netty-2-26] WARN  o.r.c.SentinelConnectionManager updateSentinels sentinel: redis://10.110.22.88:26379 was down\r\n09:40:25 [redisson-netty-2-19] INFO  o.r.c.SentinelConnectionManager lambda$null$7 sentinel: redis://10.110.22.88:26379 added\r\n.....\r\n09:57:38 [redisson-netty-2-10] WARN  o.r.c.SentinelConnectionManager updateSentinels sentinel: redis://10.110.22.88:26379 was down\r\n09:57:42 [redisson-netty-2-1] INFO  o.r.c.SentinelConnectionManager lambda$null$7 sentinel: redis://10.110.22.88:26379 added\r\n09:57:43 [redisson-netty-2-10] WARN  o.r.c.SentinelConnectionManager updateSentinels sentinel: redis://10.110.22.88:26379 was down\r\n09:57:47 [redisson-netty-2-9] INFO  o.r.c.SentinelConnectionManager lambda$null$7 sentinel: redis://10.110.22.88:26379 added\r\n09:57:48 [redisson-netty-2-11] WARN  o.r.c.SentinelConnectionManager updateSentinels sentinel: redis://10.110.22.88:26379 was down\r\n\r\nWhat's wrong?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2767/comments",
    "author": "LancasteP",
    "comments": [
      {
        "user": "blacktang",
        "created_at": "2020-05-14T06:53:17Z",
        "body": "me too . do you have any idea to handle it?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-05-14T07:34:59Z",
        "body": "Make sure all sentinels have the same list of sentinel addresses"
      },
      {
        "user": "uniqueSkeeter",
        "created_at": "2020-05-29T03:54:39Z",
        "body": "Is this a error log or not? "
      },
      {
        "user": "nigam3008",
        "created_at": "2020-10-02T21:22:02Z",
        "body": "I am facing a similar issue. Could you please explain \"Make sure all sentinels have the same list of sentinel addresses\" mean with an example?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-10-05T05:00:44Z",
        "body": "`SENTINEL SENTINELS` command returns the same list for all Sentinel Redis nodes"
      },
      {
        "user": "javaXiaoHan",
        "created_at": "2021-12-09T07:47:25Z",
        "body": "> I am facing a similar issue. Could you please explain \"Make sure all sentinels have the same list of sentinel addresses\" mean with an example?\r\n\r\ndid you solve this issue?"
      }
    ]
  },
  {
    "number": 2766,
    "title": "RScoredSortedSet.entryRange() can't get entry list under redis cluster？ ",
    "created_at": "2020-05-13T14:38:36Z",
    "closed_at": "2020-05-13T17:16:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2766",
    "body": "### Redisson version：3.7.5\r\n### **I created a redis cluster of three masters and three slaves in the virtual machine.**\r\n\r\n192.168.10.139 master  0-5460\r\n192.168.10.140 master  5461-10922\r\n192.168.10.141 master  10923-16383\r\n192.168.10.142 slave\r\n192.168.10.143 slave \r\n192.168.10.144 slave\r\n\r\n### **I want to test whether the scoresortedset supports clustering.So I wrote a unit test class**\r\n\r\n\r\n\r\n@Before\r\n    public void setUp(){\r\n        Config config = new Config();\r\n        config.useClusterServers()\r\n                .setPassword(\"123456\")\r\n                .setScanInterval(2000) // 集群状态扫描间隔时间，单位是毫秒\r\n                .addNodeAddress(\"redis://192.168.10.139:6379\", \"redis://192.168.10.140:6379\")\r\n                .addNodeAddress(\"redis://192.168.10.141:6379\", \"redis://192.168.10.142:6379\")\r\n                .addNodeAddress(\"redis://192.168.10.143:6379\", \"redis://192.168.10.144:6379\");\r\n        redissonClient = Redisson.create(config);\r\n    }\r\n\r\n@Test\r\n    public void redisClusterTest(){\r\n        RScoredSortedSet<String> set = redissonClient.getScoredSortedSet(\"xuyikai\");\r\n        for(int i=1;i<=10;i++){\r\n            boolean isAdd = set.tryAdd(i, \"key：\" + i);\r\n            log.info(\"isAdd:{}\",isAdd);\r\n        }\r\n        log.info(\"set size:{}\",set.size());\r\n        Collection<ScoredEntry<String>> scoredEntries = set.entryRange(0,10);\r\n        for (ScoredEntry<String> entry : scoredEntries) {\r\n            String key = entry.getValue();\r\n            Double score = entry.getScore();\r\n            log.info(\"key:{},score:{}\",key,score);\r\n        }\r\n    }\r\n\r\n### **I found that the key and score can be inserted normally in the scoreportedset, but when I try to read the size of the current scoreportedset, I find that the return value is 0.**\r\n### **This is the output：**\r\n\r\n\r\n2020-05-13 22:29:17,531 [main] INFO  org.redisson.Version# logVersion : 41 - Redisson 3.7.5\r\n2020-05-13 22:29:18,230 [main] INFO  o.r.cluster.ClusterConnectionManager# <init> : 120 - Redis cluster nodes configuration got from 192.168.10.139/192.168.10.139:6379:\r\n3d1cc11809e1e057a0f4347df55ac5497035bc59 192.168.10.142:6379@16379 slave e1d330c89353464f871e4fe37ed2bb744e26d9f1 0 1589380157345 4 connected\r\ned84d533c89be5b453349be85ea62236b7e388fd 192.168.10.140:6379@16379 master - 0 1589380157553 2 connected 5461-10922\r\ne1d330c89353464f871e4fe37ed2bb744e26d9f1 192.168.10.141:6379@16379 master - 0 1589380156277 3 connected 10923-16383\r\nc699c611bb722a38588acd51a561755598fbdda7 192.168.10.139:6379@16379 myself,master - 0 1589380156000 1 connected 0-5460\r\n68a78c982c84cc39fb0a500be9007cf08df2d1eb 192.168.10.143:6379@16379 slave c699c611bb722a38588acd51a561755598fbdda7 0 1589380157000 5 connected\r\n0bf30336b5397e3172bbc39827375bfbadbd500e 192.168.10.144:6379@16379 slave ed84d533c89be5b453349be85ea62236b7e388fd 0 1589380157764 6 connected\r\n\r\n2020-05-13 22:29:18,252 [redisson-netty-1-2] INFO  o.r.cluster.ClusterConnectionManager# operationComplete : 244 - slaves: [redis://192.168.10.143:6379] added for slot ranges: [[0-5460]]\r\n2020-05-13 22:29:18,256 [redisson-netty-1-5] INFO  o.r.cluster.ClusterConnectionManager# operationComplete : 244 - slaves: [redis://192.168.10.144:6379] added for slot ranges: [[5461-10922]]\r\n2020-05-13 22:29:18,275 [redisson-netty-1-7] INFO  o.r.cluster.ClusterConnectionManager# operationComplete : 244 - slaves: [redis://192.168.10.142:6379] added for slot ranges: [[10923-16383]]\r\n2020-05-13 22:29:18,291 [redisson-netty-1-5] INFO  o.r.c.p.MasterPubSubConnectionPool# operationComplete : 144 - 1 connections initialized for 192.168.10.141/192.168.10.141:6379\r\n2020-05-13 22:29:18,298 [redisson-netty-1-12] INFO  o.r.c.pool.PubSubConnectionPool# operationComplete : 144 - 1 connections initialized for 192.168.10.144/192.168.10.144:6379\r\n2020-05-13 22:29:18,299 [redisson-netty-1-2] INFO  o.r.c.pool.PubSubConnectionPool# operationComplete : 144 - 1 connections initialized for 192.168.10.142/192.168.10.142:6379\r\n2020-05-13 22:29:18,299 [redisson-netty-1-11] INFO  o.r.c.p.MasterPubSubConnectionPool# operationComplete : 144 - 1 connections initialized for 192.168.10.140/192.168.10.140:6379\r\n2020-05-13 22:29:18,343 [redisson-netty-1-8] INFO  o.r.c.pool.PubSubConnectionPool# operationComplete : 144 - 1 connections initialized for 192.168.10.143/192.168.10.143:6379\r\n2020-05-13 22:29:18,345 [redisson-netty-1-9] INFO  o.r.c.pool.MasterConnectionPool# operationComplete : 144 - 32 connections initialized for 192.168.10.140/192.168.10.140:6379\r\n2020-05-13 22:29:18,345 [redisson-netty-1-1] INFO  o.r.c.pool.MasterConnectionPool# operationComplete : 144 - 32 connections initialized for 192.168.10.139/192.168.10.139:6379\r\n2020-05-13 22:29:18,346 [redisson-netty-1-10] INFO  o.r.c.p.MasterPubSubConnectionPool# operationComplete : 144 - 1 connections initialized for 192.168.10.139/192.168.10.139:6379\r\n2020-05-13 22:29:18,348 [redisson-netty-1-10] INFO  o.r.cluster.ClusterConnectionManager# operationComplete : 267 - master: redis://192.168.10.139:6379 added for slot ranges: [[0-5460]]\r\n2020-05-13 22:29:18,352 [redisson-netty-1-2] INFO  o.r.c.pool.SlaveConnectionPool# operationComplete : 144 - 32 connections initialized for 192.168.10.144/192.168.10.144:6379\r\n2020-05-13 22:29:18,352 [redisson-netty-1-3] INFO  o.r.c.pool.SlaveConnectionPool# operationComplete : 144 - 32 connections initialized for 192.168.10.142/192.168.10.142:6379\r\n2020-05-13 22:29:18,352 [redisson-netty-1-5] INFO  o.r.c.pool.MasterConnectionPool# operationComplete : 144 - 32 connections initialized for 192.168.10.141/192.168.10.141:6379\r\n2020-05-13 22:29:18,352 [redisson-netty-1-9] INFO  o.r.cluster.ClusterConnectionManager# operationComplete : 267 - master: redis://192.168.10.140:6379 added for slot ranges: [[5461-10922]]\r\n2020-05-13 22:29:18,354 [redisson-netty-1-5] INFO  o.r.cluster.ClusterConnectionManager# operationComplete : 267 - master: redis://192.168.10.141:6379 added for slot ranges: [[10923-16383]]\r\n2020-05-13 22:29:18,357 [redisson-netty-1-7] INFO  o.r.c.pool.SlaveConnectionPool# operationComplete : 144 - 32 connections initialized for 192.168.10.143/192.168.10.143:6379\r\n2020-05-13 22:29:18,371 [main] INFO  com.mbkj.mall.RedisClusterTest# redisClusterTest : 65 - isAdd:true\r\n2020-05-13 22:29:18,372 [main] INFO  com.mbkj.mall.RedisClusterTest# redisClusterTest : 65 - isAdd:true\r\n2020-05-13 22:29:18,373 [main] INFO  com.mbkj.mall.RedisClusterTest# redisClusterTest : 65 - isAdd:true\r\n2020-05-13 22:29:18,374 [main] INFO  com.mbkj.mall.RedisClusterTest# redisClusterTest : 65 - isAdd:true\r\n2020-05-13 22:29:18,375 [main] INFO  com.mbkj.mall.RedisClusterTest# redisClusterTest : 65 - isAdd:true\r\n2020-05-13 22:29:18,376 [main] INFO  com.mbkj.mall.RedisClusterTest# redisClusterTest : 65 - isAdd:true\r\n2020-05-13 22:29:18,377 [main] INFO  com.mbkj.mall.RedisClusterTest# redisClusterTest : 65 - isAdd:true\r\n2020-05-13 22:29:18,378 [main] INFO  com.mbkj.mall.RedisClusterTest# redisClusterTest : 65 - isAdd:true\r\n2020-05-13 22:29:18,379 [main] INFO  com.mbkj.mall.RedisClusterTest# redisClusterTest : 65 - isAdd:true\r\n2020-05-13 22:29:18,381 [main] INFO  com.mbkj.mall.RedisClusterTest# redisClusterTest : 65 - isAdd:true\r\n2020-05-13 22:29:18,382 [main] INFO  com.mbkj.mall.RedisClusterTest# redisClusterTest : 68 - set size:0\r\n\r\n### **I tried distributed lock under this condition. It seems that there is no problem, so I am confused about the above problems**\r\n### **I hope you can answer my question, thank you**\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2766/comments",
    "author": "xuyikai1",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-13T17:16:13Z",
        "body": "Seems there is a replication lag between master and slave. You may try to use `readMode=Master` to avoid this. RLock is always use Redis master."
      },
      {
        "user": "xuyikai1",
        "created_at": "2020-05-14T08:17:45Z",
        "body": "Thank you for your answer. As you said, it solved the problem"
      }
    ]
  },
  {
    "number": 2764,
    "title": "redis主从切换后报错",
    "created_at": "2020-05-13T08:15:34Z",
    "closed_at": "2020-05-13T14:08:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2764",
    "body": "[local expiredValues = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); if #exp..., 3, timer_queue, redisson_delay_queue_timeout:{timer_queue}, redisson_delay_queue:{timer_queue}, 1588874410282, 100]\r\norg.redisson.client.RedisException: ERR READONLY You can't write against a read only instance. channel:\r\n\r\nredisson版本3.10.6",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2764/comments",
    "author": "nautLiu",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-13T09:22:17Z",
        "body": "Is there code example to reproduce it?"
      },
      {
        "user": "nautLiu",
        "created_at": "2020-05-13T09:24:53Z",
        "body": "> Is there code example to reproduce it?\r\ninit redisson code:\r\n Config config = new Config();\r\n   config.useSingleServer().setAddress(appProperties.redissonAddress).setPassword(appProperties.redissonPassword)\r\n                .setDatabase(2);\r\n        RedissonClient redissonClient = Redisson.create(config);"
      },
      {
        "user": "mrniko",
        "created_at": "2020-05-13T14:08:47Z",
        "body": "> ERR READONLY You can't write against a read only instance.\r\n\r\nSingle Redis server doesn't have slaves, please check your Redis setup config."
      }
    ]
  },
  {
    "number": 2762,
    "title": "RateLimiter Overall configuration across different nodes",
    "created_at": "2020-05-11T19:43:11Z",
    "closed_at": "2020-05-17T06:37:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2762",
    "body": "Hi,\r\n\r\nI have 3 different processes accessing Redis. I am using the below code to make sure only one node gets hold of the resource for the specified time.\r\n\r\nRRateLimiter limiter = redisson.getRateLimiter(\"test\");\r\n//1 permit for every 60 seconds\r\nlimiter.trySetRate(RateType.OVERALL, 1, 60, RateIntervalUnit.SECONDS);\r\n\r\nMy understanding here is 1 permit is available for every 60 seconds. If one node is processing the code after acquiring the permit, other nodes trying to call acquire should get as false.\r\nlimiter.tryAcquire(1, 2, RateIntervalUnit.SECONDS)\r\n\r\nHere, other nodes are able to acquire the lock without 60 seconds delay. Is there something wrong with the usage? Please help me understand how would I hold the access on the resource for the specified time.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2762/comments",
    "author": "riruvurilp",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-12T06:31:52Z",
        "body": "> If one node is processing the code after acquiring the permit, other nodes trying to call acquire should get as false.\r\n\r\nYes, this is how it works\r\n\r\n> If one node is processing the code after acquiring the permit, other nodes trying to call acquire should get as false.\r\nlimiter.tryAcquire(1, 2, RateIntervalUnit.SECONDS)\r\n\r\nCould you provide code to reproduce it? Also make sure all nodes connected to the same Redis db."
      },
      {
        "user": "riruvurilp",
        "created_at": "2020-05-16T21:31:48Z",
        "body": "Thanks @mrniko. I tested this again, it is working as per the documentation."
      }
    ]
  },
  {
    "number": 2759,
    "title": "Do async operations come with ordering guarantees?",
    "created_at": "2020-05-07T22:54:27Z",
    "closed_at": "2020-05-08T13:48:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2759",
    "body": "Is the order in which async operations are submitted to the Redisson client guaranteed to match the order in which they are actually executed?\r\nFor context, I am using `RStream.addAllAsync` to submit items to a stream, and I need the items stream order to exactly match the `addAllAsync` call order. Are there any race conditions possible with rapid calls to this method (1-2ms delays between calls) that would result in out-of-order insertion?\r\n\r\nThanks in advance!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2759/comments",
    "author": "ilyusha",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-08T08:39:37Z",
        "body": "> Is the order in which async operations are submitted to the Redisson client guaranteed to match the order in which they are actually executed?\r\n\r\nIt might be guaranteed only if you use single connection to Redis"
      },
      {
        "user": "johnou",
        "created_at": "2020-05-08T08:45:55Z",
        "body": "@mrniko even then it is not guaranteed because of the retry system. @ilyusha yes OOO is possible unless you chain the next add to the previous future."
      },
      {
        "user": "ilyusha",
        "created_at": "2020-05-08T13:48:37Z",
        "body": "Thanks @mrniko and @johnou! That was my hunch but I wanted to make sure."
      }
    ]
  },
  {
    "number": 2757,
    "title": "(missing no-arg constructor): org.apache.catalina.realm.GenericPrincipal",
    "created_at": "2020-05-07T16:28:23Z",
    "closed_at": "2020-06-18T13:29:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2757",
    "body": "Environment: \r\n- RHEL 7.7\r\n- Apache Tomcat 9.0.31\r\n- AWS ElastiCache/Redis\r\n\r\nScenario: \r\nAn app is hosted by two tomcat instances, Tomcat A, and Tomcat B, both are configured with AWS ElastiCache/Redis. The host is registered with AWS Application Load Balancer (sticky enabled).\r\n- The user logon to Tomcat A, and the session is cached by Redis -- good.\r\n- I killed Tomcat A\r\n- Load balancer started forwarding the traffic to Tomcat B -- Expected\r\n- The user continue to work wit the app\r\n- Tomcat B detect the change, and try to fetch session id from Redis, the I get this error, see stack dump:\r\n\r\n* conext.xml\r\n readMode=\"MEMORY\" updateMode=\"DEFAULT\" broadcastSessionEvents=\"true\"\r\n\r\n* redisson.yaml\r\nsingleServerConfig:\r\n   address: \"redis://*********************:6379\"\r\n   pingConnectionInterval: 60000\r\n   timeout: 60000\r\nnettyThreads: 256\r\ncodec: !<org.redisson.codec.KryoCodec> {}\r\n\r\n* Redis/Kryo libraries:\r\nreflectasm-1.11.9.jar\r\nredisson-tomcat-9-3.12.5.jar\r\nredisson-all-3.12.5.jar\r\nobjenesis-2.1.jar\r\nkryo-serializers-0.45.jar\r\nkryo-4.0.2.jar\r\nminlog-1.3.0.jar\r\n\r\n* Stack dump\r\n\r\nCaused by: com.esotericsoftware.kryo.KryoException: Class cannot be created (missing no-arg constructor): org.apache.catalina.realm.GenericPrincipal\r\n        at com.esotericsoftware.kryo.Kryo$DefaultInstantiatorStrategy.newInstantiatorOf(Kryo.java:1319) ~[kryo-4.0.2.jar:?]\r\n        at com.esotericsoftware.kryo.Kryo.newInstantiator(Kryo.java:1127) ~[kryo-4.0.2.jar:?]\r\n        at com.esotericsoftware.kryo.Kryo.newInstance(Kryo.java:1136) ~[kryo-4.0.2.jar:?]\r\n        at com.esotericsoftware.kryo.serializers.FieldSerializer.create(FieldSerializer.java:562) ~[kryo-4.0.2.jar:?]\r\n        at com.esotericsoftware.kryo.serializers.FieldSerializer.read(FieldSerializer.java:538) ~[kryo-4.0.2.jar:?]\r\n        at com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:816) ~[kryo-4.0.2.jar:?]\r\n        at org.redisson.codec.KryoCodec$1.decode(KryoCodec.java:63) ~[redisson-all-3.12.5.jar:3.12.5]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:368) ~[redisson-all-3.12.5.jar:3.12.5]\r\n        at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:412) ~[redisson-all-3.12.5.jar:3.12.5]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:377) ~[redisson-all-3.12.5.jar:3.12.5]\r\n        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:196) ~[redisson-all-3.12.5.jar:3.12.5]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134) ~[redisson-all-3.12.5.jar:3.12.5]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104) ~[redisson-all-3.12.5.jar:3.12.5]\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498) ~[redisson-all-3.12.5.jar:3.12.5]\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[redisson-all-3.12.5.jar:3.12.5]\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2757/comments",
    "author": "whigley",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-08T08:37:08Z",
        "body": "Did you try MarshallingCodec or SerializationCodec?"
      },
      {
        "user": "whigley",
        "created_at": "2020-05-11T20:56:02Z",
        "body": "I have tried both, With MarshallingCodec, it only works with Redis 3.12.6 RC (I get ymal paraser error when using the released version 3.12.5).\r\nBoth MarshallingCodec and SerializationCodec fails on serializing ThreadLocal\r\njava.io.NotSerializableException: java.land.ThreadLocal\r\nThis happens because ThreadLocal is not serializable.\r\nThis issue didn't happen with Kryo because ThreadLocal has no-args contractor. \r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2020-05-12T06:29:03Z",
        "body": "I don't see ThreadLocal object in GenericPrincipal"
      }
    ]
  },
  {
    "number": 2756,
    "title": "What's the best way to update an attribute outside the normal flow?",
    "created_at": "2020-05-07T11:10:33Z",
    "closed_at": "2020-05-12T06:27:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2756",
    "body": "I use Redisson-Tomcat with update mode `AFTER_REQUEST`. I'd like to do an update to a specific session attribute before the request gets to the `UpdateValve`. I think (ignoring for the moment ClassLoader issues) I can do something like `redissonManager.getTopic().publish(new AttributeUpdateMessage(redissonManager.getNodeId(), session.getId(), \"qq\", \"vv\", encoder));` but is there a better way?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2756/comments",
    "author": "jonyt",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-12T06:27:30Z",
        "body": "You can insert your valve before UpdateValve through `getEngine().getPipeline()` API."
      }
    ]
  },
  {
    "number": 2754,
    "title": "Ratelimiter occur error in aliyun redis",
    "created_at": "2020-05-06T14:09:10Z",
    "closed_at": "2020-05-12T06:21:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2754",
    "body": "**Exception as below:**\r\n\r\n[05-06 21:59:06] [ERROR] [http-nio-8889-e] o.a.c.c.C.[.[.[/showservice].[dispatcherServlet]   - Servlet.service() for servlet [dispatcherServlet] in context with path [/showservice] threw exception\r\norg.redisson.client.RedisException: ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS array, and KEYS should not be in expression. channel: [id: 0x7091849f, L:/172.16.156.8:38216 - R:r-bp128ubvf0obdjoh62.redis.rds.aliyuncs.com/172.16.156.9:6379] command: (EVAL), params: [local rate = redis.call('hget', KEYS[1], 'rate');local interval = redis.call('hget', KEYS[1], 'inter..., 3, live:rate-limiter:119.126.28.207:1000, {live:rate-limiter:119.126.28.217:1000}:value, {live:rate-limiter:119.126.28.207:1000}:value:3a0eaa24-eead-492b-990f-458f32dcc846, 1, 3a0eaa24-eead-492b-990f-458f32dcc846]\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:371)\r\n        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:215)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:153)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)\r\n        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:682)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:617)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:534)\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906)\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.lang.Thread.run(Thread.java:748)\r\n\r\n**config：**\r\nReplicatedServersConfig replicatedServersConfig = config.useReplicatedServers()\r\n                    // 主节点变化扫描间隔时间\r\n                    .setScanInterval(2000)\r\n                    .addNodeAddress(aliyunRedisAddress);\r\n\r\n            if (redisConfig.hasPassword()) {\r\n                replicatedServersConfig.setPassword(redisConfig.getPassword());\r\n            }\r\nredissonClient = Redisson.create(config);\r\n\r\n**redis:**  aliyun redis cluster\r\n\r\n**redisson:** 3.12.5",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2754/comments",
    "author": "1985815103",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-12T06:21:55Z",
        "body": "Please contact Redis vendor on this issue. Redis OS doesn't have it."
      }
    ]
  },
  {
    "number": 2752,
    "title": "How to stop Redisson connecting to a stale node",
    "created_at": "2020-05-06T00:38:41Z",
    "closed_at": "2020-05-07T22:39:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2752",
    "body": "We have a Redis cluster in AWS, in which there're 50 master nodes. Each master node has 1 slave node.\r\n\r\nOne of the nodes looks like:\r\n001-001.usw2.cache.amazonaws.com (master)\r\n001-002.usw2.cache.amazonaws.com (slave)\r\n\r\nI use nslookup to check the ip address of these dns records.\r\nmaster(001-001.usw2.cache.amazonaws.com) has ip : 172.31.33.149\r\nslave(001-002.usw2.cache.amazonaws.com) has ip : 172.31.33.51\r\n\r\nOur Redisson client keeps connecting to an unknown ip:  172.31.33.151\r\n\r\nPer the result of \"cluster nodes\", I found that the unknown ip is a failed slave node,\r\n```\r\nb34bae2fef43d70f75be8162140188e87823012f 172.31.33.151:6379 slave,fail bc8f4f25b680672c389192d076d8f050a0705675 1587800858187 1587800853882 290 connected\r\nbc8f4f25b680672c389192d076d8f050a0705675 172.31.30.149:6379 master - 0 1588725334984 290 connected 10924-10976 11014-11287\r\nd3d42e9140d2aa90237023c1938ce1ad5ee331bd 172.31.33.51:6379 slave bc8f4f25b680672c389192d076d8f050a0705675 0 1588725335480 290 connected\r\n```\r\n\r\nPer the AWS console, I'm sure that dns name of the current slave is 172.31.33.51. \r\nSo the ip 151 should be stale and we should not reconnect to that address. The retry attempts throw a timeout exception and make cpu/memory usage high, which lead to memory leak issue.\r\n```\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T00:44:47.475020436Z\",\"thread\":\"redisson-netty-8-25\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588725887,\"nanoOfSecond\":474607000},\"threadId\":156,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-5b75584d77-4c4gm\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"9c34263d-8f20-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"1631140833\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-225-82.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"fb46025e3378900deb8b095ab0b0b011436779227ec18351e721a587cb377808\",\"container_hash\":\"c3afd6353de439e6101efc9ff908f940664e0dfbaf976499bae061abef11c5d5\"}}\r\n```\r\n\r\nOur system do have connection for the master node (ip 172.31.33.149) and the new slave node (ip 172.31.33.51)\r\n\r\nIs there any way/configuration to stop Redisson connecting to the stale node?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2752/comments",
    "author": "stevenli1217",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-06T06:12:26Z",
        "body": "Redisson disconnects slaves marked as failed. You'll see `slave: {} has down for slot ranges: {}` in logs."
      },
      {
        "user": "stevenli1217",
        "created_at": "2020-05-06T06:22:42Z",
        "body": "For that 151 node, I do see `slave: {} has down for slot ranges` in logs, but it still keep reconnecting to that node.\r\n\r\nI filter the log using `172.31.33.151` and only find the following lines:\r\n```\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:13.427492152Z\",\"thread\":\"redisson-netty-8-24\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746553,\"nanoOfSecond\":426639000},\"threadId\":134,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-vkwr9\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c137bd44-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-228-119.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"4a702325f23116477eaf1b2d5f6f67635bde22f11ec517559fc0b0039afe455e\",\"container_hash\":\"15f2e47e1b930d20c39f630c74a5d8906beb3e5698b9e14b93479f46e6167581\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:12.394918696Z\",\"thread\":\"redisson-netty-8-27\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746552,\"nanoOfSecond\":321573000},\"threadId\":137,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-vkwr9\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c137bd44-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-228-119.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"4a702325f23116477eaf1b2d5f6f67635bde22f11ec517559fc0b0039afe455e\",\"container_hash\":\"15f2e47e1b930d20c39f630c74a5d8906beb3e5698b9e14b93479f46e6167581\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:11.196710914Z\",\"thread\":\"redisson-netty-8-2\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746551,\"nanoOfSecond\":196275000},\"threadId\":112,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-vkwr9\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c137bd44-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-228-119.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"4a702325f23116477eaf1b2d5f6f67635bde22f11ec517559fc0b0039afe455e\",\"container_hash\":\"15f2e47e1b930d20c39f630c74a5d8906beb3e5698b9e14b93479f46e6167581\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:08.77209891Z\",\"thread\":\"redisson-netty-8-20\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746548,\"nanoOfSecond\":764567000},\"threadId\":131,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-9h49c\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c069c677-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-223-56.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"e001807313e4566009ea1197d8f51e53073b5d3756dc5e1f1c6f7dec47f78d4a\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:07.612810974Z\",\"thread\":\"redisson-netty-8-3\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746547,\"nanoOfSecond\":608447000},\"threadId\":113,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-7zrmw\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c0b612aa-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-229-121.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"15755f40138c7e78cc8b1fad2085c07de12c45598dac4836d49548c2ee6f5c72\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:07.574045514Z\",\"thread\":\"redisson-netty-8-10\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746547,\"nanoOfSecond\":564127000},\"threadId\":120,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-9h49c\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c069c677-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-223-56.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"e001807313e4566009ea1197d8f51e53073b5d3756dc5e1f1c6f7dec47f78d4a\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:06.425406286Z\",\"thread\":\"redisson-netty-8-28\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746546,\"nanoOfSecond\":425029000},\"threadId\":138,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-7zrmw\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c0b612aa-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-229-121.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"15755f40138c7e78cc8b1fad2085c07de12c45598dac4836d49548c2ee6f5c72\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:06.276810543Z\",\"thread\":\"redisson-netty-8-13\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746546,\"nanoOfSecond\":276340000},\"threadId\":123,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-9h49c\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c069c677-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-223-56.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"e001807313e4566009ea1197d8f51e53073b5d3756dc5e1f1c6f7dec47f78d4a\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:05.51045522Z\",\"thread\":\"redisson-netty-8-17\",\"level\":\"WARN\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"slave: redis://172.31.33.151:6379 has down for slot ranges: [[11014-11287], [10924-10976]]\",\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746545,\"nanoOfSecond\":425797000},\"threadId\":127,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-7zrmw\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c0b612aa-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-229-121.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"15755f40138c7e78cc8b1fad2085c07de12c45598dac4836d49548c2ee6f5c72\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:04.973462828Z\",\"thread\":\"redisson-netty-8-22\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746544,\"nanoOfSecond\":964655000},\"threadId\":132,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-9h49c\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c069c677-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-223-56.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"e001807313e4566009ea1197d8f51e53073b5d3756dc5e1f1c6f7dec47f78d4a\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:04.409984759Z\",\"thread\":\"redisson-netty-8-30\",\"level\":\"INFO\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"slave: redis://172.31.33.151:6379 has up for slot ranges: [[11014-11287], [10924-10976]]\",\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746544,\"nanoOfSecond\":238907000},\"threadId\":140,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-7zrmw\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c0b612aa-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-229-121.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"15755f40138c7e78cc8b1fad2085c07de12c45598dac4836d49548c2ee6f5c72\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:04.20865479Z\",\"thread\":\"redisson-netty-8-14\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746544,\"nanoOfSecond\":136717000},\"threadId\":124,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-7zrmw\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c0b612aa-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-229-121.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"15755f40138c7e78cc8b1fad2085c07de12c45598dac4836d49548c2ee6f5c72\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:03.865757335Z\",\"thread\":\"redisson-netty-8-23\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746543,\"nanoOfSecond\":865084000},\"threadId\":133,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-9h49c\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c069c677-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-223-56.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"e001807313e4566009ea1197d8f51e53073b5d3756dc5e1f1c6f7dec47f78d4a\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:03.114878764Z\",\"thread\":\"redisson-netty-8-12\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746543,\"nanoOfSecond\":108397000},\"threadId\":122,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-7zrmw\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c0b612aa-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-229-121.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"15755f40138c7e78cc8b1fad2085c07de12c45598dac4836d49548c2ee6f5c72\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:02.704430753Z\",\"thread\":\"redisson-netty-8-31\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746542,\"nanoOfSecond\":703988000},\"threadId\":141,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-gm9gf\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c12877d6-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-223-174.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"90439d85a6ec634495e6b1a748418371fde8d70cac7968546e92cfa0f8455312\",\"container_hash\":\"15f2e47e1b930d20c39f630c74a5d8906beb3e5698b9e14b93479f46e6167581\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:02.586978208Z\",\"thread\":\"redisson-netty-8-6\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746542,\"nanoOfSecond\":586543000},\"threadId\":116,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-9h49c\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c069c677-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-223-56.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"e001807313e4566009ea1197d8f51e53073b5d3756dc5e1f1c6f7dec47f78d4a\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:02.010907767Z\",\"thread\":\"redisson-netty-8-26\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746542,\"nanoOfSecond\":8493000},\"threadId\":136,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-7zrmw\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c0b612aa-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-229-121.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"15755f40138c7e78cc8b1fad2085c07de12c45598dac4836d49548c2ee6f5c72\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:01.770971236Z\",\"thread\":\"redisson-netty-8-15\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746541,\"nanoOfSecond\":580186000},\"threadId\":125,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-gm9gf\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c12877d6-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-223-174.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"90439d85a6ec634495e6b1a748418371fde8d70cac7968546e92cfa0f8455312\",\"container_hash\":\"15f2e47e1b930d20c39f630c74a5d8906beb3e5698b9e14b93479f46e6167581\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:01.329285089Z\",\"thread\":\"redisson-netty-8-17\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746541,\"nanoOfSecond\":318829000},\"threadId\":127,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-5b7ps\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c1300b36-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-224-191.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"b42b71642cef15280476940818a63579a87e9694fa956f2e80112ebe9e903a62\",\"container_hash\":\"15f2e47e1b930d20c39f630c74a5d8906beb3e5698b9e14b93479f46e6167581\"}}\r\n{\"stream\":\"stdout\",\"time\":\"2020-05-06T06:29:00.720237073Z\",\"thread\":\"redisson-netty-8-11\",\"level\":\"ERROR\",\"loggerName\":\"org.redisson.cluster.ClusterConnectionManager\",\"message\":\"Can't add slave: redis://172.31.33.151:6379\",\"thrown\":{\"commonElementCount\":0,\"localizedMessage\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"message\":\"Unable to connect to Redis server: 172.31.33.151/172.31.33.151:6379\",\"name\":\"org.redisson.client.RedisConnectionException\",\"cause\":{\"commonElementCount\":6,\"localizedMessage\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"message\":\"connection timed out: 172.31.33.151/172.31.33.151:6379\",\"name\":\"io.netty.channel.ConnectTimeoutException\",\"extendedStackTrace\":[{\"class\":\"io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1\",\"method\":\"run\",\"file\":\"AbstractNioChannel.java\",\"line\":267,\"exact\":false,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.PromiseTask$RunnableAdapter\",\"method\":\"call\",\"file\":\"PromiseTask.java\",\"line\":38,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.ScheduledFutureTask\",\"method\":\"run\",\"file\":\"ScheduledFutureTask.java\",\"line\":127,\"exact\":false,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"}]},\"extendedStackTrace\":[{\"class\":\"org.redisson.connection.pool.ConnectionPool$1\",\"method\":\"lambda$run$0\",\"file\":\"ConnectionPool.java\",\"line\":160,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":485,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"promiseFailure\",\"file\":\"ConnectionPool.java\",\"line\":330,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.connection.pool.ConnectionPool\",\"method\":\"lambda$createConnection$1\",\"file\":\"ConnectionPool.java\",\"line\":296,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"lambda$onComplete$0\",\"file\":\"RedissonPromise.java\",\"line\":183,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListener0\",\"file\":\"DefaultPromise.java\",\"line\":511,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners0\",\"file\":\"DefaultPromise.java\",\"line\":504,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListenersNow\",\"file\":\"DefaultPromise.java\",\"line\":483,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"notifyListeners\",\"file\":\"DefaultPromise.java\",\"line\":424,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.DefaultPromise\",\"method\":\"tryFailure\",\"file\":\"DefaultPromise.java\",\"line\":121,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"org.redisson.misc.RedissonPromise\",\"method\":\"tryFailure\",\"file\":\"RedissonPromise.java\",\"line\":96,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"org.redisson.client.RedisClient$2$2\",\"method\":\"run\",\"file\":\"RedisClient.java\",\"line\":249,\"exact\":true,\"location\":\"redisson-3.12.0.jar!/\",\"version\":\"3.12.0\"},{\"class\":\"io.netty.util.concurrent.AbstractEventExecutor\",\"method\":\"safeExecute\",\"file\":\"AbstractEventExecutor.java\",\"line\":163,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"method\":\"runAllTasks\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":404,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.channel.nio.NioEventLoop\",\"method\":\"run\",\"file\":\"NioEventLoop.java\",\"line\":466,\"exact\":true,\"location\":\"netty-transport-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.SingleThreadEventExecutor$5\",\"method\":\"run\",\"file\":\"SingleThreadEventExecutor.java\",\"line\":897,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"io.netty.util.concurrent.FastThreadLocalRunnable\",\"method\":\"run\",\"file\":\"FastThreadLocalRunnable.java\",\"line\":30,\"exact\":true,\"location\":\"netty-common-4.1.31.Final.jar!/\",\"version\":\"4.1.31.Final\"},{\"class\":\"java.lang.Thread\",\"method\":\"run\",\"file\":\"Thread.java\",\"line\":834,\"exact\":true,\"location\":\"?\",\"version\":\"?\"}]},\"endOfBatch\":false,\"loggerFqcn\":\"org.apache.logging.slf4j.Log4jLogger\",\"instant\":{\"epochSecond\":1588746540,\"nanoOfSecond\":719827000},\"threadId\":121,\"threadPriority\":5,\"meta\":{\"env\":\"prod\"},\"kubernetes\":{\"pod_name\":\"merchant-data-service-kafka-consumer-85b9cf7b4f-7zrmw\",\"namespace_name\":\"merchant-data-service\",\"pod_id\":\"c0b612aa-8f51-11ea-9d66-06e0ee830e70\",\"labels\":{\"app\":\"kafka-consumer\",\"managed-by\":\"Tiller\",\"pod-template-hash\":\"4165793609\",\"service\":\"merchant-data-service\"},\"host\":\"ip-172-31-229-121.us-west-2.compute.internal\",\"container_name\":\"kafka-consumer\",\"docker_id\":\"15755f40138c7e78cc8b1fad2085c07de12c45598dac4836d49548c2ee6f5c72\"}}\r\n```"
      },
      {
        "user": "stevenli1217",
        "created_at": "2020-05-06T06:35:25Z",
        "body": "Per the logs, sometimes it's up and sometimes it's down again.  But per the result of \"cluster nodes\", its status is always \"fail\"."
      },
      {
        "user": "mrniko",
        "created_at": "2020-05-07T07:04:41Z",
        "body": "How did you define aws cluster nodes in config as single endpoint host?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-05-07T07:22:20Z",
        "body": "Unable to reproduce it. Could you share Redisson output log?"
      },
      {
        "user": "stevenli1217",
        "created_at": "2020-05-07T22:39:58Z",
        "body": "Cannot reproduce it either. It occurred in prod.\r\n\r\nWill ping you if I get the log."
      }
    ]
  },
  {
    "number": 2749,
    "title": "Distributed scheduled executor service ",
    "created_at": "2020-05-05T00:31:15Z",
    "closed_at": "2020-05-05T09:32:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2749",
    "body": "**Distributed scheduled executor service occur exception：**\r\n\r\n`Caused by: java.lang.IllegalArgumentException: java.io.IOException: java.lang.RuntimeException: Class org.redisson.Redisson does not implement Serializable or externalizable`\r\n`\tat org.redisson.RedissonExecutorService.encode(RedissonExecutorService.java:383)`\r\n`\tat org.redisson.RedissonExecutorService.scheduleAsync(RedissonExecutorService.java:979)`\r\n`\tat org.redisson.RedissonExecutorService.schedule(RedissonExecutorService.java:969)`\r\n`\tat com.xiaoyun.ws.support.ServerPacketSchedule.scheduleSendPackets(ServerPacketSchedule.java:46)`\r\n`\tat com.xiaoyun.ws.support.ServerPacketSchedule.<init>(ServerPacketSchedule.java:35)`\r\n`\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)`\r\n`\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)`\r\n`\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)`\r\n`\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)`\r\n`\tat org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:172)`\r\n`\t... 21 common frames omitted`\r\n`Caused by: java.io.IOException: java.lang.RuntimeException: Class org.redisson.Redisson does not implement Serializable or externalizable`\r\n`\tat org.redisson.codec.FstCodec$2.encode(FstCodec.java:279)`\r\n`\tat org.redisson.RedissonExecutorService.encode(RedissonExecutorService.java:378)`\r\n`\t... 30 common frames omitted`\r\n`Caused by: java.lang.RuntimeException: Class org.redisson.Redisson does not implement Serializable or externalizable`\r\n`\tat org.nustaq.serialization.FSTClazzInfo.<init>(FSTClazzInfo.java:144)`\r\n`\tat org.nustaq.serialization.FSTClazzInfoRegistry.getCLInfo(FSTClazzInfoRegistry.java:129)`\r\n`\tat org.nustaq.serialization.FSTObjectOutput.getFstClazzInfo(FSTObjectOutput.java:534)`\r\n`\tat org.nustaq.serialization.FSTObjectOutput.writeObjectWithContext(FSTObjectOutput.java:416)`\r\n`\tat org.nustaq.serialization.FSTObjectOutput.writeObjectWithContext(FSTObjectOutput.java:369)`\r\n`\tat org.nustaq.serialization.FSTObjectOutput.writeObjectFields(FSTObjectOutput.java:664)`\r\n`\tat org.nustaq.serialization.FSTObjectOutput.defaultWriteObject(FSTObjectOutput.java:546)`\r\n`\tat org.nustaq.serialization.FSTObjectOutput.writeObjectWithContext(FSTObjectOutput.java:458)`\r\n`\tat org.nustaq.serialization.FSTObjectOutput.writeObjectInternal(FSTObjectOutput.java:327)`\r\n`\tat org.nustaq.serialization.FSTObjectOutput.writeObject(FSTObjectOutput.java:294)`\r\n`\tat org.nustaq.serialization.FSTObjectOutput.writeObject(FSTObjectOutput.java:204)`\r\n`\tat org.redisson.codec.FstCodec$2.encode(FstCodec.java:271)`\r\n\r\n\r\n**code as：**\r\n` executorService = redisson.getExecutorService(\"ServerPacketSchedule\");`\r\n` RunnableTask runnableTask = new RunnableTask(bootstrap, redisson );`\r\n` scheduledFuture = executorService.schedule(runnableTask, CronSchedule.of(\"0/1 * * * * ?\"));`\r\n\r\n` public static class RunnableTask implements Runnable, Serializable {`\r\n`     private RedissonClient redissonClient;`\r\n`     private TioWebSocketServerBootstrap bootstrap;`\r\n` `\r\n`     public RunnableTask(TioWebSocketServerBootstrap bootstrap, RedissonClient redissonClient) {`\r\n`         this.redissonClient = redissonClient;`\r\n`         this.bootstrap = bootstrap;`\r\n`     }`\r\n`     @Override`\r\n`     public void run() {`\r\n`         RList<Object> list = redissonClient.getList(\"live:packet-buffer\");`\r\n`         if (CollectionUtils.isNotEmpty(list)) {`\r\n`             WsResponse wsResponse = ServerPacket.createBath(list.toArray());`\r\n`             Tio.sendToAll(bootstrap.getTioConfig(), wsResponse);`\r\n`             list.clear();`\r\n`         }`\r\n`     }`\r\n` }`\r\n\r\n**redisson-version：3.12.5**",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2749/comments",
    "author": "1985815103",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-05T09:32:14Z",
        "body": "You need to use @Injected annotation instead of passing Redisson as argument."
      },
      {
        "user": "1985815103",
        "created_at": "2020-05-05T11:20:10Z",
        "body": "> \r\n> \r\n> You need to use @injected annotation instead of passing Redisson as argument.\r\n\r\nbut at charpter in wiki (9.4.4. Scheduling a task with Spring beans) can use Spring's @Autowire, @Value to inject spring bean"
      },
      {
        "user": "mrniko",
        "created_at": "2020-05-05T11:35:59Z",
        "body": "Sorry, I meant \"@RInject\" annotation"
      },
      {
        "user": "1985815103",
        "created_at": "2020-05-06T05:44:06Z",
        "body": "> \r\n> \r\n> Sorry, I meant \"@RInject\" annotation\r\n\r\nThanks，I have one more question : \r\ni don't kown why RunnableTask  can't not inject spring bean \"TioWebSocketServerBootstrap \"\r\n\r\n**Code:**\r\n        executorService = redisson.getExecutorService(\"ServerPacketSchedule\");\r\n        WorkerOptions options = WorkerOptions.defaults();\r\n        options.taskTimeout(60, TimeUnit.SECONDS);\r\n        options.workers(2);\r\n        .addListener(new TaskSuccessListener() {\r\n            @Override\r\n            public <T> void onSucceeded(String taskId, T result) {\r\n                System.out.println(\"f\");\r\n            }\r\n        });\r\nscheduledFuture = executorService.scheduleAtFixedRate(new RunnableTask(), 0, 1, TimeUnit.SECONDS);\r\n\r\n**The Task (must implements Serializable or else throw not  Serializable Exception)**\r\npublic class RunnableTask implements Runnable, Serializable {\r\n    @RInject\r\n    private RedissonClient redissonClient;\r\n    @Autowired\r\n    private TioWebSocketServerBootstrap bootstrap;\r\n\r\n    @Override\r\n    public void run() {\r\n        System.out.println(bootstrap);\r\n    }\r\n}\r\n\r\n**The output console:**\r\nnull\r\nf\r\nnull\r\nf\r\nnull\r\nf\r\n\r\n\r\n\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2020-05-06T06:20:34Z",
        "body": "TaskSuccessListener is global setting and invoked for every task"
      }
    ]
  },
  {
    "number": 2748,
    "title": "Command execution timeout for command: (SENTINEL GET-MASTER-ADDR-BY-NAME)",
    "created_at": "2020-05-04T18:31:04Z",
    "closed_at": "2020-05-12T10:52:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2748",
    "body": "Redisson version: 3.12.4\r\n\r\nIn production we are seeing intermittent error spikes of background sentinel commands timeout failures like `SENTINEL SENTINELS`, `SENTINEL SLAVES`, `SENTINEL GET-MASTER-ADDR-BY-NAME`. Are these related to available `nettyThreads`? This is happening only in couple of servers, we have around 100+ servers in production with similar settings. At the same time we didn't see any regular application side used commands' redis timeouts. \r\n\r\n```\r\norg.redisson.client.RedisTimeoutException: Command execution timeout for command: (SENTINEL GET-MASTER-ADDR-BY-NAME)\r\n```\r\nCan you let me know what could be reason for these intermittent errors? ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2748/comments",
    "author": "rgampa",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-12T10:52:22Z",
        "body": "Please check Redis instance load and network"
      },
      {
        "user": "rgampa",
        "created_at": "2020-05-12T22:27:27Z",
        "body": "@mrniko Yes, checked the redis load and network side of things, they look good. Am curious why only SentinelConnectionManager failing to execute these background sentinel commands intermittently due to timeout. In the sentinel config what's the use of the flag `checkSentinelsList`?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-10-07T05:26:48Z",
        "body": "> In the sentinel config what's the use of the flag checkSentinelsList?\r\n\r\nIt checks for presence of at least 2 sentinels in Redis setup"
      }
    ]
  },
  {
    "number": 2747,
    "title": "masterConnectionPoolSize cannot limit the maximum connection pool size",
    "created_at": "2020-05-04T07:12:56Z",
    "closed_at": "2020-05-12T10:50:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2747",
    "body": "```\r\n7000: 115\r\n7001: 79\r\n7002: 110\r\n7003: 55\r\n7004: 63\r\n7005: 70\r\nbfecab1697163710144b8b2d856ec9849644ce19 127.0.0.1:7004@17004 slave 156092ec03d87f4758ead59d381115bc814fb02d 0 1588575861519 5 connected\r\n156092ec03d87f4758ead59d381115bc814fb02d 127.0.0.1:7000@17000 master - 0 1588575863034 1 connected 0-5460\r\n33b499b2eaa6b5b3cce9000a2c69f6377e115f5b 127.0.0.1:7002@17002 master - 0 1588575862021 3 connected 10923-16383\r\nb91203ffc948b641f1d6e72fccee5b89abc063ad 127.0.0.1:7003@17003 slave 33b499b2eaa6b5b3cce9000a2c69f6377e115f5b 0 1588575861519 4 connected\r\na2b3d429e43d749577366e7890af4b849c7ba11c 127.0.0.1:7005@17005 myself,slave e5c2bd7af1c0929ffa792b4da28b58c143a39671 0 1588575862000 6 connected\r\ne5c2bd7af1c0929ffa792b4da28b58c143a39671 127.0.0.1:7001@17001 master - 0 1588575861013 2 connected 5461-10922\r\n```\r\n\r\n**Description** : I set slaveConnectionPoolSize/masterConnectionPoolSize to 64.  But node 7000/7002(master) has 115 connections \r\n**Question_1**: Is this a bug?\r\n\r\n**Description** : I waited for a long time to check if those connections can be killed.  Unfortunately, those connections are always alive. It seems that idleConnectionTimeout doesn't work as expected. \r\n```\r\nid=193 addr=172.18.0.1:49182 fd=128 name=MyServiceName age=414 idle=366 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=psetex\r\n```\r\n**Question_2** : I'm wondering if there's something wrong with my configuration or it's a bug?\r\n\r\n\r\nMy Configuration is as followed: Cluster mode\r\n```\r\n  idleConnectionTimeout: 30000\r\n  slaveConnectionMinimumIdleSize: 16\r\n  slaveConnectionPoolSize: 64\r\n  masterConnectionMinimumIdleSize: 16\r\n  masterConnectionPoolSize: 64\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2747/comments",
    "author": "stevenli1217",
    "comments": [
      {
        "user": "stevenli1217",
        "created_at": "2020-05-04T07:25:13Z",
        "body": "This issue can be reproduced by restart Redis cluster while Redisson keeps writing/reading data to/from redis cluster."
      },
      {
        "user": "mrniko",
        "created_at": "2020-05-05T07:15:47Z",
        "body": "> But node 7000/7002(master) has 115 connections\r\n\r\nRedisson prints in log how many connections it establish. What is TCP state of connections?"
      }
    ]
  },
  {
    "number": 2743,
    "title": "Can't connect to server for AWS ElastiCache Redis",
    "created_at": "2020-04-30T18:14:03Z",
    "closed_at": "2020-05-02T04:30:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2743",
    "body": "### Background\r\nI'm using redis as a lock manager in my application. I set up the AWS elasticache redis server with 1 primary and 2 replicas. \r\n\r\n### Expected behavior\r\n\r\nAll Redisson clients can connect to the server \r\n\r\n### Actual behavior\r\n\r\nMy application is running on mutiple ec2 instances, there is always some instances(for example 2/10, 5/30) can't connect to elasticache redis server. \r\n\r\n### Steps to reproduce or test case\r\n\r\nWhen I deploy the application through beanstalk. There is always some instance fail at the healthcheck. When I check the log of those instances. Here is what I found:\r\n\r\n```\r\n7:49:43.767 [redisson-netty-9-2] DEBUG io.netty.buffer.AbstractByteBuf - -Dio.netty.buffer.checkAccessible: true\r\n17:49:43.767 [redisson-netty-9-2] DEBUG io.netty.buffer.AbstractByteBuf - -Dio.netty.buffer.checkBounds: true\r\n17:49:43.767 [redisson-netty-9-2] DEBUG i.n.util.ResourceLeakDetectorFactory - Loaded default ResourceLeakDetector: io.netty.util.ResourceLeakDetector@48fb807b\r\n17:49:43.798 [redisson-netty-9-2] WARN  io.netty.util.ReferenceCountUtil - Failed to release a message: DatagramPacket(=> /(ip address), PooledUnsafeDirectByteBuf(freed))\r\n17:49:43.894 [redisson-netty-9-2] DEBUG i.netty.resolver.dns.DnsNameResolver - [id: 0xf7a028f9] RECEIVED: [42375: /172.30.0.2:53], DatagramDnsResponse(from: /172.30.0.2:53, to: /0.0.0.0:46149, 42375, QUERY(0), NoError(0), RD RA)\r\n17:49:43.897 [redisson-netty-9-2] DEBUG i.netty.resolver.dns.DnsQueryContext - [id: 0xf7a028f9] WRITE: [51958: /172.30.0.2:53], DefaultDnsQuestion(redis endpoint). IN A)\r\n17:49:43.904 [redisson-netty-9-2] WARN  io.netty.util.ReferenceCountUtil - Failed to release a message: DatagramPacket(=> /(ip address), PooledUnsafeDirectByteBuf(freed))\r\n17:49:43.915 [redisson-netty-9-2] WARN  io.netty.util.ReferenceCountUtil - Failed to release a message: DatagramDnsResponse(from: /(ip address), to: /0.0.0.0:46149, 42375, QUERY(0), NoError(0), RD RA)\r\n17:49:43.921 [redisson-netty-9-2] DEBUG i.netty.resolver.dns.DnsNameResolver - [id: 0xf7a028f9] RECEIVED: [51958: /172.30.0.2:53], DatagramDnsResponse(from: /(ip address), to: /0.0.0.0:46149, 51958, QUERY(0), NoError(0), RD RA)\r\n17:49:43.965 [redisson-netty-9-2] WARN  io.netty.util.ReferenceCountUtil - Failed to release a message: DatagramDnsResponse(from: /(ip address), to: /0.0.0.0:46149, 51958, QUERY(0), NoError(0), RD RA)\r\n17:49:44.055 [redisson-netty-9-3] DEBUG io.netty.handler.ssl.JdkSslContext - Default protocols (JDK): [TLSv1.2, TLSv1.1, TLSv1]\r\n17:49:44.058 [redisson-netty-9-3] DEBUG io.netty.handler.ssl.JdkSslContext - Default cipher suites (JDK): [TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_256_CBC_SHA]\r\n17:49:44.227 [redisson-netty-9-3] DEBUG io.netty.handler.ssl.SslHandler - [id: 0xea4a64c3, L:/(ip address) - R:(redis master endpoint)/(ip address):6379] SSLEngine.closeInbound() raised an exception.\r\n17:49:44.230 [redisson-netty-9-3] WARN  io.netty.util.ReferenceCountUtil - Failed to release a message: PooledUnsafeDirectByteBuf(freed)\r\nCaused by: org.redisson.client.RedisConnectionException: Can't connect to servers!\r\n\tat org.redisson.connection.ReplicatedConnectionManager.<init>(ReplicatedConnectionManager.java:98) ~[redisson-3.12.5.jar:3.12.5]\r\n\tat org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:206) ~[redisson-3.12.5.jar:3.12.5]\r\n\tat org.redisson.Redisson.<init>(Redisson.java:64) ~[redisson-3.12.5.jar:3.12.5]\r\n\tat org.redisson.Redisson.create(Redisson.java:104) ~[redisson-3.12.5.jar:3.12.5]\r\n\r\n```\r\n\r\n### Redis version\r\n\r\n5.0.5\r\n\r\n### Redisson version\r\n\r\n3.12.5\r\n\r\n### Redisson configuration\r\n\r\nI use replicated serverConfig and I only pass the one master endpoint in the config.\r\n\r\n  ```\r\n    // 1. Create config object  \r\n  Config config = new Config();  \r\n ReplicatedServersConfig replicatedServersConfig = config.useReplicatedServers();  \r\n    String redisURIFormat = \"rediss://%s:%d\";  \r\n  replicatedServersConfig.addNodeAddress(String.format(redisURIFormat, context.get().getEndpoint(), context.get().getPort()));  \r\n  replicatedServersConfig.setPassword(context.get().getAuthToken());  \r\n return Redisson.create(config);",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2743/comments",
    "author": "coldray",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-01T07:11:48Z",
        "body": "Please share full stacktrace. I don't see the root exception."
      },
      {
        "user": "coldray",
        "created_at": "2020-05-01T20:03:22Z",
        "body": "Because when I set the log level to trace, there are lots of logs. Previously I use grep command to find redisson related logs. That's not deep enough to find the root cause. So I looked into the log file and found that. It looks to me is the jar conflict issue. I have many io netty jar which is lower than the redisson's version 4.1.48.Final. Is there a way to exclude all of them in pom file, right now I have to exclude each of them one by one. \r\nio.netty.util.ReferenceCountUtil - Failed to release a message: DatagramPacket(=> /172.30.0.2:53, PooledUnsafeDirectByteBuf(freed))\r\njava.lang.IncompatibleClassChangeError: Class io.netty.util.Recycler$DefaultHandle does not implement the requested interface io.netty.util.internal.ObjectPool$Handle\r\n\tat io.netty.buffer.PooledByteBuf.recycle(PooledByteBuf.java:179) ~[netty-buffer-4.1.48.Final.jar:4.1.48.Final]\r\n\tat io.netty.buffer.PooledByteBuf.deallocate(PooledByteBuf.java:174) ~[netty-buffer-4.1.48.Final.jar:4.1.48.Final]\r\n\tat io.netty.buffer.AbstractReferenceCountedByteBuf.handleRelease(AbstractReferenceCountedByteBuf.java:110) ~[netty-buffer-4.1.48.Final.jar:4.1.48.Final]\r\n\tat io.netty.buffer.AbstractReferenceCountedByteBuf.release(AbstractReferenceCountedByteBuf.java:100) ~[netty-buffer-4.1.48.Final.jar:4.1.48.Final]\r\n\tat io.netty.util.ReferenceCountUtil.release(ReferenceCountUtil.java:88) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.DefaultAddressedEnvelope.release(DefaultAddressedEnvelope.java:101) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.util.ReferenceCountUtil.release(ReferenceCountUtil.java:88) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.util.ReferenceCountUtil.safeRelease(ReferenceCountUtil.java:113) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.ChannelOutboundBuffer.remove(ChannelOutboundBuffer.java:257) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.nio.AbstractNioMessageChannel.doWrite(AbstractNioMessageChannel.java:149) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:934) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.flush0(AbstractNioChannel.java:360) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:901) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:1396) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:776) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:768) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:749) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.ChannelOutboundHandlerAdapter.flush(ChannelOutboundHandlerAdapter.java:115) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:776) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:802) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:814) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(AbstractChannelHandlerContext.java:794) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.writeAndFlush(DefaultChannelPipeline.java:1066) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannel.writeAndFlush(AbstractChannel.java:305) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.resolver.dns.DnsQueryContext.writeQuery(DnsQueryContext.java:136) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.resolver.dns.DnsQueryContext.sendQuery(DnsQueryContext.java:118) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.resolver.dns.DnsQueryContext.query(DnsQueryContext.java:113) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.resolver.dns.DnsNameResolver.query0(DnsNameResolver.java:948) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:343) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.resolver.dns.DnsResolveContext.followCname(DnsResolveContext.java:758) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.resolver.dns.DnsResolveContext.onResponseCNAME(DnsResolveContext.java:594) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.resolver.dns.DnsResolveContext.onExpectedResponse(DnsResolveContext.java:568) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.resolver.dns.DnsResolveContext.onResponse(DnsResolveContext.java:409) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.resolver.dns.DnsResolveContext.access$600(DnsResolveContext.java:62) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.resolver.dns.DnsResolveContext$3.operationComplete(DnsResolveContext.java:370) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:504) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:483) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:103) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.resolver.dns.DnsQueryContext.setSuccess(DnsQueryContext.java:192) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.resolver.dns.DnsQueryContext.finish(DnsQueryContext.java:184) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.resolver.dns.DnsNameResolver$DnsResponseHandler.channelRead(DnsNameResolver.java:984) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:102) ~[netty-codec-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe.read(AbstractNioMessageChannel.java:93) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:646) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysPlain(NioEventLoop.java:546) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:500) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:460) ~[netty-transport-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-all-4.1.27.Final.jar:4.1.27.Final]\r\n\tat java.base/java.lang.Thread.run(Thread.java:834) ~[na:na]"
      },
      {
        "user": "mrniko",
        "created_at": "2020-05-02T04:30:38Z",
        "body": "> It looks to me is the jar conflict issue\r\n\r\nThat's right"
      }
    ]
  },
  {
    "number": 2740,
    "title": "Idle connection is not killed after timeout",
    "created_at": "2020-04-30T00:54:00Z",
    "closed_at": "2020-04-30T20:47:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2740",
    "body": "clusterServersConfig:\r\n  idleConnectionTimeout: 30000\r\n  pingTimeout: 1000\r\n  subscriptionConnectionMinimumIdleSize: 1\r\n  subscriptionConnectionPoolSize: 10\r\n  slaveConnectionMinimumIdleSize: 1\r\n  slaveConnectionPoolSize: 2\r\n  masterConnectionMinimumIdleSize: 3\r\n  masterConnectionPoolSize: 4\r\n  pingConnectionInterval: 0\r\n  keepAlive: true\r\n\r\nI use the above settings. The connections is always 2 event the idle time is bigger than 20 seconds.\r\n`id=134 addr=172.18.0.1:43642 fd=19 name=MerchantDataService age=1278 idle=1278 flags=r db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=readonly\r\nid=135 addr=172.18.0.1:43696 fd=20 name=MerchantDataService age=1278 idle=1278 flags=r db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=readonly`\r\n\r\nDid I miss something?\r\n\r\nBtw, for the connections in master node, it always 4 and no connection is closed after idleConnectionTimeout.\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2740/comments",
    "author": "stevenli1217",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-04-30T06:03:20Z",
        "body": "Redisson opens additional connection per node to retrieve topology information"
      },
      {
        "user": "stevenli1217",
        "created_at": "2020-04-30T20:47:35Z",
        "body": "Thank you!"
      }
    ]
  },
  {
    "number": 2734,
    "title": "how to use Redisson Lock if lua 'eval' is forbiddened in Redis Cluster because of not good support ?",
    "created_at": "2020-04-29T07:24:26Z",
    "closed_at": "2020-04-29T08:07:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2734",
    "body": "In Redis Cluster, all keys require in same slot with lua, so 'lua eval' is forbiddened in some case or in company，then how to solve this to use Redisson Lock?\r\n\r\n`Caused by: org.redisson.client.RedisException: ERR unknown command 'EVAL'`",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2734/comments",
    "author": "kute",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-04-29T08:07:29Z",
        "body": "I'm afraid there is no any solution in this case."
      }
    ]
  },
  {
    "number": 2728,
    "title": "Connection Pool refresh. Redis ips keep changing. ",
    "created_at": "2020-04-25T10:52:51Z",
    "closed_at": "2020-04-25T12:22:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2728",
    "body": "Hi, we have deployed our Redis on Kubernetes and the pods can die. One of our java apps uses redisson. I want to know if there is any setting that if one of my pod dies and a new pod comes up with new IP redisson can get the new IP and refresh the connection pool? \r\n\r\nExtra information: \r\nRedis Mode: Cluster\r\nRedis Version: 3.2.1",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2728/comments",
    "author": "chowmean",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-04-25T12:22:53Z",
        "body": "Yes, connections will be reconnected once pod came up"
      },
      {
        "user": "WuKongQC",
        "created_at": "2020-10-14T08:14:50Z",
        "body": "I have the similar question. if one redis cluster die, wo set dns to new ips, redisson will not connect to new ips, why ?  how to solve this problem? thanks."
      },
      {
        "user": "mrniko",
        "created_at": "2020-10-14T09:21:30Z",
        "body": "@WuKongQC \r\n\r\nips should be changed in Redis cluster topology as well."
      }
    ]
  },
  {
    "number": 2726,
    "title": "Question about retryAttempts&retryInterval",
    "created_at": "2020-04-24T03:04:00Z",
    "closed_at": "2020-04-24T07:09:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2726",
    "body": "In our environment, we see randomly long time access due to some commands go to 1 time or 2 times retry.  ~1500ms(retryInterval) passed after connection acquired but not able to send command and go to attempt. \r\n\r\nRestart Redis server will recover it. \r\n\r\nI wonder to know:\r\n1. In which possible scenarios Redis command can't be sent to Redis server, and enter retry mode?\r\n2. Why restart Redis server can recover?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2726/comments",
    "author": "empty117",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-04-24T05:14:21Z",
        "body": "> In which possible scenarios Redis command can't be sent to Redis server, and enter retry mode?\r\n\r\nIf connection became broken due to network issue or Redis CPU 100% spike.\r\nTry to set `pingConnectionInterval` setting"
      },
      {
        "user": "empty117",
        "created_at": "2020-04-24T05:29:48Z",
        "body": "@mrniko : What's the usage to set \"pingConnectionInterval\"?\r\nI am sure Redis CPU is not 100% spike. About connections, i set like this:\r\n -  idleConnectionTimeout: 10000\r\n - masterConnectionMinimumIdleSize: 32\r\n - masterConnectionPoolSize: 256\r\n\r\nWhat i understood is if load is not quite high, connection number will back to 32 in case some connections got ldel time more than 10s. But i see connection number  is keeping more than 200 even in very free time."
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-24T05:57:16Z",
        "body": "> But i see connection number is keeping more than 200 even in very free time.\r\n\r\nI sure that these connections weren't used for more than 10s? connection pool use them in round robin."
      },
      {
        "user": "empty117",
        "created_at": "2020-04-24T06:05:02Z",
        "body": "@mrniko : When Redisson startup, how many connections will be established? masterConnectionMinimumIdleSize: 32 or masterConnectionPoolSize: 256?\r\n\r\nI suppose \"pingConnectionInterval\" is used to detect broken connections. If this was set, in each connection, redisson will regularly execute PING command. Will it impact the connection IDLE time?\r\n\r\nFor instance: If i set pingConnectionInterval=5000, idleConnectionTimeout=10000, Does it mean connection will never been IDEL timeout?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-24T06:08:35Z",
        "body": "> If this was set, in each connection, redisson will regularly execute PING command. Will it impact the connection IDLE time?\r\n\r\nIt shouldn't since PingConnectionHandler doesn't use conneciton pool"
      },
      {
        "user": "empty117",
        "created_at": "2020-04-24T07:09:36Z",
        "body": "thanks, clear to me now."
      }
    ]
  },
  {
    "number": 2724,
    "title": "RBlockingQueue延时队列到期不能poll到值。是不是我的使用方式有问题。",
    "created_at": "2020-04-23T10:36:43Z",
    "closed_at": "2020-09-23T14:36:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2724",
    "body": "用offer的形式放入延时队列，再用poll的形式取值。现在出现的现象是，有时候到过期时间，但是没有取到值，需要再次往里offer的时候才会取到值值。\r\n//存的代码\r\n        RBlockingQueue<QueueTask> blockingFairQueue = redisson.getBlockingQueue(task.getQueueName());\r\n        RDelayedQueue<QueueTask> delayedQueue = redisson.getDelayedQueue(blockingFairQueue);\r\n        delayedQueue.offer(task, task.getDelayTime(), task.getTimeUnit() == null ? TimeUnit.MINUTES : task.getTimeUnit());\r\n        delayedQueue.destroy();\r\n\r\n//取的代码：\r\nwhile (true){\r\n                RBlockingQueue<QueueTask> blockingFairQueue = redisUtils.getRedisson().getBlockingQueue(queueName);\r\n                    task = blockingFairQueue.poll(1,TimeUnit.MINUTES);\r\n            }\r\n\r\n//配置的集群模式\r\nconfig.useClusterServers().setScanInterval(2000).addNodeAddress(newNodes.toArray(new String[0]))\r\n                    .setSubscriptionConnectionMinimumIdleSize(subscriptionConnectionMinimumIdleSize)\r\n                    .setSubscriptionConnectionPoolSize(subscriptionConnectionPoolSize)\r\n                    .setSubscriptionsPerConnection(subscriptionsPerConnection)\r\n                    .setClientName(clientName)\r\n                    .setRetryAttempts(retryAttempts)\r\n                    .setRetryInterval(retryInterval)\r\n                    .setTimeout(timeout)\r\n                    .setConnectTimeout(connectTimeout)\r\n                    .setIdleConnectionTimeout(idleConnectionTimeout)\r\n                    .setPassword(password)\r\n                    .setMasterConnectionPoolSize(masterConnectionPoolSize)\r\n                    .setMasterConnectionMinimumIdleSize(masterConnectionMinimumIdleSize)\r\n                    .setSlaveConnectionPoolSize(slaveConnectionPoolSize)\r\n                    .setSlaveConnectionMinimumIdleSize(slaveConnectionMinimumIdleSize);\r\n\r\n//单点模式配置\r\nconfig.useSingleServer().setAddress(address)\r\n                    .setConnectionMinimumIdleSize(connectionMinimumIdleSize)\r\n                    .setConnectionPoolSize(connectionPoolSize)\r\n                    .setDatabase(database)\r\n                    .setDnsMonitoringInterval(dnsMonitoringInterval)\r\n                    .setSubscriptionConnectionMinimumIdleSize(subscriptionConnectionMinimumIdleSize)\r\n                    .setSubscriptionConnectionPoolSize(subscriptionConnectionPoolSize)\r\n                    .setSubscriptionsPerConnection(subscriptionsPerConnection)\r\n                    .setClientName(clientName)\r\n                    .setRetryAttempts(retryAttempts)\r\n                    .setRetryInterval(retryInterval)\r\n                    .setTimeout(timeout)\r\n                    .setConnectTimeout(connectTimeout)\r\n                    .setIdleConnectionTimeout(idleConnectionTimeout)\r\n                    .setPassword(password);\r\n\r\nredisson版本：3.11.4",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2724/comments",
    "author": "LionsArmstrong",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-04-23T11:19:15Z",
        "body": "It's happening since delayed elements transfered on Redisson side"
      },
      {
        "user": "LionsArmstrong",
        "created_at": "2020-04-24T01:47:38Z",
        "body": "如何避免此类问题的发生呢？降低延迟时间吗？业务延时时间为30到90分钟不等的。现在数据的使用量不是很大。经常会发生这样的问题。"
      },
      {
        "user": "LionsArmstrong",
        "created_at": "2020-04-24T01:48:35Z",
        "body": "How to avoid such problems? Reduce delay time? The service delay time varies from 30 to 90 minutes. Now the amount of data used is not very large. Such problems often occur."
      },
      {
        "user": "zcs100",
        "created_at": "2020-05-30T14:35:12Z",
        "body": "@LionsArmstrong 我也遇到了相同的问题，运行中会有丢消息的情况，现在解决了吗？能分享一下吗"
      },
      {
        "user": "ManaStuDent",
        "created_at": "2020-06-30T05:53:50Z",
        "body": "遇到同样的问题在 2.15.2 版本中，我这里和 Springmvc 整合时遇到的问题，Junit 单元测试的时候就没有问题，在使用 Springmvc 中使用 @PostConstruct 注解为消费者开启一个 Thread 线程时，生产者发送单个消息后，消费者有时候能消费到，有时候消费不到，但是当生产者连续发送多个消息，消费者就一定能够消费到。"
      },
      {
        "user": "1186792881",
        "created_at": "2020-08-13T08:15:01Z",
        "body": "I also encountered the same problem, how to solve it"
      },
      {
        "user": "Yorkehan",
        "created_at": "2020-08-16T14:10:29Z",
        "body": "I also encountered the same problem, how to solve it"
      },
      {
        "user": "serical",
        "created_at": "2020-08-29T03:27:06Z",
        "body": "I also encountered the same problem, how to solve it\r\n\r\n"
      },
      {
        "user": "534519560",
        "created_at": "2020-09-23T08:33:25Z",
        "body": "使用这样的方式添加元素试试看,我这样就正常了\r\n`    queue.offer(task, 5, TimeUnit.SECONDS);\r\n        Thread.sleep(1);\r\n        queue.destroy();`"
      },
      {
        "user": "LionsArmstrong",
        "created_at": "2020-11-09T07:00:01Z",
        "body": "@zcs100 @1186792881 @ManaStuDent 可以尝试一下，以下方式。基本可以解决延时获取不到数据的问题。\r\nRBlockingQueue<QueueTask> blockingFairQueue = redisUtils.getRedisson().getBlockingQueue(queueName);\r\nredisUtils.getRedisson().getDelayedQueue(blockingFairQueue);\r\ntask = blockingFairQueue.poll(1,TimeUnit.MINUTES);"
      },
      {
        "user": "xrayw",
        "created_at": "2020-11-10T03:13:48Z",
        "body": "@LionsArmstrong  老哥, 是说中间要加一个getDelayedQueue()的无用代码才可以避免? 这是什么原理啊 😄 "
      },
      {
        "user": "serical",
        "created_at": "2020-11-10T13:05:54Z",
        "body": "我现在是这么解决的😂\r\n```java\r\n    @PostConstruct\r\n    public void init() {\r\n        // 1秒钟刷新延迟队列一次\r\n        final Timer timer = new Timer();\r\n        timer.schedule(new TimerTask() {\r\n            @Override\r\n            public void run() {\r\n                refresh();\r\n            }\r\n        }, 1000, 1000);\r\n    }\r\n\r\n    /**\r\n     * 重启刷新延迟队列\r\n     */\r\n    private void refresh() {\r\n        RDelayedQueue<String> imageSuitRetryQueue = redissonClient.getDelayedQueue(redissonClient.getBlockingQueue(\"key\"));\r\n        imageSuitRetryQueue.destroy();\r\n    }\r\n```"
      },
      {
        "user": "astorage",
        "created_at": "2020-11-20T03:14:42Z",
        "body": "> @zcs100 @1186792881 @ManaStuDent 可以尝试一下，以下方式。基本可以解决延时获取不到数据的问题。\r\n> RBlockingQueue blockingFairQueue = redisUtils.getRedisson().getBlockingQueue(queueName);\r\n> redisUtils.getRedisson().getDelayedQueue(blockingFairQueue);\r\n> task = blockingFairQueue.poll(1,TimeUnit.MINUTES);\r\n\r\n出现这个问题现象的原理是什么？是发送端延迟没有发送，还是接受方的问题？"
      },
      {
        "user": "LionsArmstrong",
        "created_at": "2021-02-09T01:28:21Z",
        "body": "@astorage \r\n\r\n> > @zcs100 @1186792881 @ManaStuDent 可以尝试一下，以下方式。基本可以解决延时获取不到数据的问题。\r\n> > RBlockingQueue blockingFairQueue = redisUtils.getRedisson().getBlockingQueue(queueName);\r\n> > redisUtils.getRedisson().getDelayedQueue(blockingFairQueue);\r\n> > task = blockingFairQueue.poll(1,TimeUnit.MINUTES);\r\n> \r\n> 出现这个问题现象的原理是什么？是发送端延迟没有发送，还是接受方的问题？\r\n\r\nredis里面有数据，接收方监听断了。但是还没有抛出任何异常。就是一直都在监听，但是接收不到数据。等发送端再发送新的数据的时候，接受方就能接受之前的数据。但是时间已经超时了。"
      },
      {
        "user": "huangwenyi10",
        "created_at": "2021-05-12T02:24:37Z",
        "body": "delayedQueue.destroy();   注释掉这句，应该就没问题了"
      }
    ]
  },
  {
    "number": 2719,
    "title": "Storing UUID objects is impossible ?",
    "created_at": "2020-04-22T20:15:36Z",
    "closed_at": "2020-04-23T07:27:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2719",
    "body": "Hey !\r\n\r\nEverytime I try to store UUIDs on redis (with a List, a Set, a bucket) and I wish to compare them or use them as a keys to get elements in a hashmap for example, this error occurs, UUID is considered as a string, here is the format in redis : \r\n\r\n`\"\\\"88a10822-c3e4-47e8-8f53-1069858fedc4\\\"\"`\r\n\r\n`Caused by: java.lang.ClassCastException: java.lang.String cannot be cast to java.util.UUID`\r\n\r\nMaybe JsonJackson can't serialize correctly uuids, I sadly didn't find anything interesting about that :/\r\n\r\nThanks in advance for your answer, and sorry for disturbing with weird questions ^^",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2719/comments",
    "author": "Aurelien30000",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-04-23T07:27:12Z",
        "body": "Try another codec or change UUID type to string"
      },
      {
        "user": "Sovietaced",
        "created_at": "2021-01-11T05:49:17Z",
        "body": "Why can't we use UUIDs with Redis? My issue is that I can use UUIDs in objects but once I use a UUID as a key to a map it always comes back as a String."
      },
      {
        "user": "mrniko",
        "created_at": "2021-01-11T05:57:57Z",
        "body": "you can do it with MarshallingCodec or SerializationCodec"
      },
      {
        "user": "Sovietaced",
        "created_at": "2021-01-11T06:09:38Z",
        "body": "Hmm. I will just resort to representing a UUID as a String when I need to use it as a Map key. I was just wondering what is the reason for this behavior as I mentioned, I can use UUIDs as types for fields in objects that are stored as map values. I have tested that the serialization/deserialization works. \r\n\r\nI am using `JsonJacksonCodec` by the way. "
      },
      {
        "user": "mrniko",
        "created_at": "2021-01-11T07:56:08Z",
        "body": "this is how JsonJacksonCodec handles UUID - converts it into string. MarshallingCodec is now used by default."
      }
    ]
  },
  {
    "number": 2718,
    "title": "RedissonReactiveClient getLock and getLexSortedSet is executing on different thread.",
    "created_at": "2020-04-22T17:06:50Z",
    "closed_at": "2020-04-23T07:29:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2718",
    "body": "`return lock.tryLock(100,10,TimeUnit.SECONDS).flatMap(lockk -> {\r\n                   System.out.println(lockk);\r\n                   System.out.println(Thread.currentThread().toString());\r\n                    return redissonReactiveClient.getLexSortedSet(redisKey)\r\n                            .readAll()\r\n                            .flatMap(strings -> { //some map operation using result\r\n                            })\r\n                            .onErrorResume(throwable -> {\r\n                                System.out.println(Thread.currentThread().toString());\r\n`\r\nprint result - \r\ntrue\r\nThread[redisson-netty-2-6,5,main]\r\nThread[redisson-timer-4-1,5,main]\r\nSo here lockk is printed as true, but redissonReactiveClient.getLexSortedSet(redisKey) cannot execute and directly goes to onErrorResume as it is executing in different thread than lock.tryLock(). I'm new to this reactive style of programming, I don't know what I'm doing wrong maybe there is a better way to lock and get the sortedset? please help.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2718/comments",
    "author": "bharti-himanshu",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-04-23T07:29:23Z",
        "body": "you need to pass threadId to `tryLock` method and then the same to `unlock` method, so it would work in different threads."
      }
    ]
  },
  {
    "number": 2717,
    "title": "tomcat8集成redission后，AAP运行后生成很多FastThreadLocalThread对象，不久OOM",
    "created_at": "2020-04-22T14:11:14Z",
    "closed_at": "2020-08-01T17:58:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2717",
    "body": "\r\n请教个问题，tomcat8集成redission后，AAP运行后生成很多FastThreadLocalThread对象，不久OOM。\r\n\r\n33 instances of \"io.netty.util.concurrent.FastThreadLocalThread\", loaded by \"java.net.URLClassLoader @ 0x6c1ae3398\" occupy 817,977,408 (68.17%) bytes. \r\n\r\nBiggest instances:\r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2499ac8 redisson-netty-2-23 - 41,760,720 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c26866e0 redisson-netty-2-29 - 41,759,680 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2b846a8 redisson-netty-2-7 - 41,759,552 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2af2778 redisson-netty-2-9 - 41,759,488 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2dde1e0 redisson-netty-2-6 - 41,759,432 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2b11718 redisson-netty-2-1 - 41,759,288 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c268f208 redisson-netty-2-28 - 41,759,240 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2579748 redisson-netty-2-4 - 41,759,144 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2c4d858 redisson-netty-2-22 - 41,758,760 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2ca50c0 redisson-netty-2-18 - 41,758,752 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c25689e0 redisson-netty-2-2 - 41,758,448 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c29213a0 redisson-netty-2-15 - 41,741,384 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2664de8 redisson-netty-2-21 - 41,741,200 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c25de460 redisson-netty-2-24 - 41,740,304 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c267d890 redisson-netty-2-32 - 41,740,200 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2994798 redisson-netty-2-27 - 41,740,024 (3.48%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2a35a90 redisson-netty-2-25 - 17,913,472 (1.49%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2799e98 redisson-netty-2-26 - 17,379,360 (1.45%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2cfa1c0 redisson-netty-2-11 - 17,375,328 (1.45%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2e46c58 redisson-netty-2-19 - 17,360,160 (1.45%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2498428 redisson-netty-2-3 - 17,356,816 (1.45%) bytes. \r\n•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c27a7df0 redisson-netty-2-20 - 17,355,424 (1.45%) bytes. \r\n\r\n\r\nKeywords\r\nio.netty.util.concurrent.FastThreadLocalThread\r\njava.net.URLClassLoader @ 0x6c1ae3398\r\n\r\n如下是我们的版本及配置信息\r\nredis version 5.0.3\r\n\r\nredisson version 3.12.4\r\n\r\ntomcat version 8.0.39\r\n-----------server.xml------------\r\n <GlobalNamingResources>\r\n    <Resource name=\"bean/redisson\"\r\n              auth=\"Container\"\r\n              factory=\"org.redisson.JndiRedissonFactory\"\r\n              configPath=\"${catalina.base}/conf/redisson.yaml\"\r\n              closeMethod=\"shutdown\"/>\r\n  </GlobalNamingResources>\r\n-----------context.xml------------\r\n<ResourceLink name=\"bean/redisson\"\r\n                  global=\"bean/redisson\"\r\n\t\t  type=\"org.redisson.api.RedissonClient\" />\r\n\r\n<Manager className=\"org.redisson.tomcat.JndiRedissonSessionManager\"\r\n         readMode=\"REDIS\"\r\n         jndiName=\"bean/redisson\" />\r\n\t\t \r\n-----------redisson.yaml-----------\r\n---\r\nsentinelServersConfig:\r\n  idleConnectionTimeout: 10000\r\n  connectTimeout: 10000\r\n  timeout: 6000\r\n  retryAttempts: 3\r\n  retryInterval: 1500\r\n  failedSlaveReconnectionInterval: 3000\r\n  failedSlaveCheckInterval: 60000\r\n  password: \"xxxx\"\r\n  subscriptionsPerConnection: 5\r\n  clientName: null\r\n  loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}\r\n  subscriptionConnectionMinimumIdleSize: 1\r\n  subscriptionConnectionPoolSize: 50\r\n  slaveConnectionMinimumIdleSize: 24\r\n  slaveConnectionPoolSize: 64\r\n  masterConnectionMinimumIdleSize: 24\r\n  masterConnectionPoolSize: 64\r\n  readMode: \"SLAVE\"\r\n  subscriptionMode: \"SLAVE\"\r\n  sentinelAddresses:\r\n  - \"redis://\"\r\n  - \"redis://\"\r\n  - \"redis://\"\r\n  masterName: \"xxxx\"\r\n  database: 0\r\nthreads: 16\r\nnettyThreads: 32\r\ncodec: !<org.redisson.codec.FstCodec> {}\r\ntransportMode: \"NIO\"\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2717/comments",
    "author": "aonf",
    "comments": [
      {
        "user": "aonf",
        "created_at": "2020-04-22T14:18:52Z",
        "body": "\r\ntomcat version 8.0.39\r\n-----------server.xml------------\r\n\r\n-  <GlobalNamingResources>\r\n-     <Resource name=\"bean/redisson\"\r\n-               auth=\"Container\"\r\n-               factory=\"org.redisson.JndiRedissonFactory\"\r\n-               configPath=\"${catalina.base}/conf/redisson.yaml\"\r\n-               closeMethod=\"shutdown\"/>\r\n-   </GlobalNamingResources>\r\n\r\n-----------context.xml------------\r\n\r\n- <ResourceLink name=\"bean/redisson\"\r\n-                   global=\"bean/redisson\"\r\n- \t\t  type=\"org.redisson.api.RedissonClient\" />\r\n- \r\n- <Manager className=\"org.redisson.tomcat.JndiRedissonSessionManager\"\r\n-          readMode=\"REDIS\"\r\n-          jndiName=\"bean/redisson\" />"
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-22T14:22:50Z",
        "body": "Try to switch to `MarshallingCodec` instead of current `FstCodec`\r\n\r\nadd dependency below:\r\n```xml\r\n<dependency>\r\n        <groupId>org.jboss.marshalling</groupId>\r\n        <artifactId>jboss-marshalling-river</artifactId>\r\n        <version>2.0.9.Final</version>\r\n</dependency>\r\n```"
      }
    ]
  },
  {
    "number": 2716,
    "title": "Rbatch String values pre append \\x00\\",
    "created_at": "2020-04-22T08:45:21Z",
    "closed_at": "2020-04-22T08:53:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2716",
    "body": "Hi,\r\nI am using the below code:\r\nRBatch batch = redisson.createBatch(BatchOptions.defaults());\r\nRMapCacheAsync<String, String> map = batch.getMapCache(cdrKey);\r\nmap.putAllAsync(batchRequest);\r\nconfig.setCodec(StringCodec.INSTANCE);\r\n\r\nWhy are my values appending \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\ before the XYZ string which is my real value?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2716/comments",
    "author": "majidshaikh16",
    "comments": [
      {
        "user": "majidshaikh16",
        "created_at": "2020-04-22T08:48:32Z",
        "body": "For example, my value is a JSON string let take this as an example:\r\n\"{'name':Alex'}\"\r\nAfter submitting it to Redis the values become:\r\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x18\\x00\\x00\\x00\\x00\\x00\\x00\\x00{'name':Alex'}\""
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-22T08:53:09Z",
        "body": "default codec is FSTCodec, try to use StringCodec"
      },
      {
        "user": "majidshaikh16",
        "created_at": "2020-04-22T09:13:23Z",
        "body": "I am already using it in my Redisson config\r\n config.setCodec(StringCodec.INSTANCE);\r\nI had also tried RMapCacheAsync<String, String> map = batch.getMapCache(cdrKey,StringCodec.INSTANCE);\r\n\r\nStill the same result."
      },
      {
        "user": "majidshaikh16",
        "created_at": "2020-04-22T09:14:34Z",
        "body": "> Hi,\r\n> I am using the below code:\r\n> RBatch batch = redisson.createBatch(BatchOptions.defaults());\r\n> RMapCacheAsync<String, String> map = batch.getMapCache(cdrKey);\r\n> map.putAllAsync(batchRequest);\r\n> config.setCodec(StringCodec.INSTANCE);\r\n> \r\n> Why are my values appending \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\ before the XYZ string which is my real value?\r\n\r\nIf you see I had already done this."
      },
      {
        "user": "majidshaikh16",
        "created_at": "2020-04-22T09:32:09Z",
        "body": "@mrniko Am I missing something?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-22T09:33:45Z",
        "body": "Could you share complete code example? try it on clean redis"
      },
      {
        "user": "majidshaikh16",
        "created_at": "2020-04-22T09:46:43Z",
        "body": "@mrniko \r\npublic void addBatch(Map<String, String> batchRequest) {\r\n\t\tRBatch batch = redisson.createBatch(BatchOptions.defaults());\r\n\t\tRMapCacheAsync<String, String> map = batch.getMapCache(cdrKey);\r\n\t\tmap.putAllAsync(batchRequest);\r\n\t\tmap.expireAsync(keyExpiry, TimeUnit.MILLISECONDS);\r\n\t\tRFuture<BatchResult<?>> result = batch.executeAsync();\r\n\t\tresult.whenCompleteAsync((res, exp) -> {\r\n\t\t\tboolean success = (boolean) res.getResponses().get(1);\r\n\t\t\tif (success)\r\n\t\t\t\tConstant.REDIS_REQ_BATCH_COUNT.getAndIncrement();\r\n\t\t\telse\r\n\t\t\t\tConstant.REDIS_REQ_BATCH_FAILURE_COUNT.getAndIncrement();\r\n\t\t});\r\n\t}\r\n\r\nIn Redisson config file \r\nconfig.setCodec(StringCodec.INSTANCE);"
      },
      {
        "user": "majidshaikh16",
        "created_at": "2020-04-22T09:48:54Z",
        "body": "What I notice is:\r\nif change \r\nRMapCacheAsync<String, String> map = batch.getMapCache(cdrKey);\r\nto\r\nRMapAsync<String, String> map = batch.getMap(cdrKey);\r\nit works! It gives me the clean json string in value."
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-22T10:01:52Z",
        "body": "MapCached object stores additional info per map entry"
      },
      {
        "user": "majidshaikh16",
        "created_at": "2020-04-22T10:11:51Z",
        "body": "But does that affect resulting in different values(one pre appended \\X00\\ and another a clean as expected string)? "
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-23T09:13:18Z",
        "body": "No, because RMap structure is not compatible with RMapCache"
      }
    ]
  },
  {
    "number": 2713,
    "title": "Redisson fastRemove not working in AWS Lambda",
    "created_at": "2020-04-21T09:55:20Z",
    "closed_at": "2020-04-27T06:30:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2713",
    "body": "Hi,\r\n\r\nWe use redisson library pom dependency for an AWS lambda code. The lambda job is to evict a cache entry from the AWS Redis cache. The Lambda has stopped working since we have upgraded the redisson version from 3.3.1 to 3.12.3. Looking at the Lambda cloudwatch logs, we can see the following in logs\r\n\r\n> DEBUG RedisExecutor:acquired connection for command (HDEL)\r\n> DEBUG RedisExecutor:released connection for command (HDEL)\r\n> \r\n\r\nbut the entry in the cache is not deleted. There is no exception/error in the logs. Is there any known issue related to it or are we missing any configuration in the latest version to make the deletes happen.\r\n\r\nWe use the following code \r\n\r\n`redissonClient.getMap(cacheKey).fastRemove(cacheKeyId)\r\n`",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2713/comments",
    "author": "bizjuned",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-04-21T10:01:15Z",
        "body": "set TRACE logging level for `org.redisson` package to see Redis command invocation"
      },
      {
        "user": "bizjuned",
        "created_at": "2020-04-21T10:18:23Z",
        "body": "@mrniko does the below debug helps? Stil trying to figure out how to set the log level to TRACE in lambda\r\n\r\n2020-04-21 10:13:29 <09e04a34-2372-4f64-9729-40509f5b3d27> DEBUG RedisExecutor:acquired connection for command (HDEL) and params [jsonBeansV3, PooledUnsafeDirectByteBuf(ridx: 0, widx: 11, cap: 256)] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=23, freeConnectionsCounter=value:63:queue:0, freezed=false, freezeReason=null, client=[addr=redis://redisDNS:6379], nodeType=MASTER, firstFail=0]]] using node redishHost/10.20.12.1:6379... RedisConnection@1912494701 [redisClient=[addr=redis://redisHost:6379], channel=[id: 0x8e541df9, L:/169.254.76.1:46730 - R:redisHost/10.14.11.165:6379], currentCommand=null]\r\n\r\nThe DNS and the IPs are changed for security\r\n\r\n2020-04-21 10:13:29 <09e04a34-2372-4f64-9729-40509f5b3d27> DEBUG RedisExecutor:connection released for command (HDEL) and params [jsonBeansV3, PooledUnsafeDirectByteBuf(ridx: 0, widx: 11, cap: 256)] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=24, freeConnectionsCounter=value:64:queue:0, freezed=false, freezeReason=null, client=[addr=redis://redisDNS:6379], nodeType=MASTER, firstFail=0]]] using connection RedisConnection@1912494701 [redisClient=[addr=redis://redisDNS:6379], channel=[id: 0x8e541df9, L:/169.254.76.1:46730 - R:redisDNS/10.140.20.199:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@664e2909(success: 0)], command=(HDEL), params=[jsonBeansV3, PooledUnsafeDirectByteBuf(ridx: 0, widx: 11, cap: 256)], codec=org.redisson.codec.FstCodec]]\r\na\r\n\r\n\r\n\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-21T10:20:49Z",
        "body": "please note default codec has changed"
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-21T10:21:26Z",
        "body": "Also make sure that there are no different versions of Redisson in classpath"
      },
      {
        "user": "bizjuned",
        "created_at": "2020-04-21T10:22:16Z",
        "body": "I saw that codec part. Would the codec have an impact on the fastRemove method ? I doubted it so thats why didnt pursue much in that direction\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-21T10:22:17Z",
        "body": "> Stil trying to figure out how to set the log level to TRACE in lambda\r\n\r\nYou need to set it to logger used by your application."
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-21T10:22:40Z",
        "body": "> Would the codec have an impact on the fastRemove method ?\r\n\r\nNo, just for your information"
      },
      {
        "user": "bizjuned",
        "created_at": "2020-04-21T10:26:30Z",
        "body": "> Also make sure that there are no different versions of Redisson in classpath\r\n\r\n\r\nNo there is only one version of redisson i.e.  3.12.3"
      },
      {
        "user": "bizjuned",
        "created_at": "2020-04-27T00:04:20Z",
        "body": " The issue was related to the default codec i.e. FstCodec. The code that writes to the AWS Redis uses JsonJacksonCodec. I didn't imagine the Codec will create a problem for remove methods in an AWS Lambda. Eventually tried setting the codec in Redisson config and it worked. Thought to let you know @mrniko "
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-27T06:30:17Z",
        "body": "Thanks for clarifying!"
      }
    ]
  },
  {
    "number": 2695,
    "title": "Spring session timeout",
    "created_at": "2020-04-14T17:38:14Z",
    "closed_at": "2020-04-16T10:02:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2695",
    "body": "The spring session documentation has two spring boot ways of configuring session timeout (spring.session.timeout, server.servlet.session.timeout) Redisson does not make use of either of these, instead you have to set it on the EnableRedissonHttpSession annotation which is not configurable.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2695/comments",
    "author": "chrisgolle",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-04-16T09:57:43Z",
        "body": "you need to define follow properties in spring-boot settings:\r\n\r\n```\r\nspring.redis.redisson.config=classpath:redisson.yaml\r\nspring.session.store-type=redis\r\nspring.session.timeout.seconds=900\r\n```\r\nnext add `spring-session-data-redis` and `redisson-spring-data-22` dependencies."
      }
    ]
  },
  {
    "number": 2688,
    "title": "Best method to zero-out Bloomfilter",
    "created_at": "2020-04-11T23:56:59Z",
    "closed_at": "2020-04-13T08:01:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2688",
    "body": "I'm wondering what the best approach would be using Redisson to zero-out (remove all entries) residing in the bloomfilter entry generated by Redisson's `RedissonBloomFilter.tryInit()` and `.add` commands?\r\n ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2688/comments",
    "author": "champloo11",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-04-13T07:52:09Z",
        "body": "You can do it with `RBloomFilter.delete` method."
      },
      {
        "user": "champloo11",
        "created_at": "2020-04-13T19:30:50Z",
        "body": "From my understanding `.delete()` will delete the keys associated with the object, not reset the values within it. Causing `RedissonBloomFilter.add()` and `RedissonBloomFilter.exists()` commands to fail. Meaning that there will be downtime for services that are already running that rely on that particular instances. Is that correct?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-14T05:40:18Z",
        "body": "`RedissonBloomFilter.add()` and `RedissonBloomFilter.exists()` commands will work."
      }
    ]
  },
  {
    "number": 2687,
    "title": "publish  message  throw exception",
    "created_at": "2020-04-11T10:23:39Z",
    "closed_at": "2020-04-11T11:47:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2687",
    "body": "\r\nrtopic  can  receive message,  but throw exception on publish message  every time.\r\n\r\n```bash\r\nspring-boot: 2.1.2.RELEASE\r\nredisson-spring-boot-starter: 3.11.5\r\n```\r\n\r\n\r\n```java\r\n RTopic rTopic = redissonClient.getTopic(\"xxx\");\r\n        rTopic.addListener(Long.class, (channel, msg) -> {\r\n            log.info(\"收到消息: {}\", msg);\r\n        });\r\n\r\n\r\n-------------------\r\n\r\n RTopic rTopic = redissonClient.getTopic(\"xxx\");\r\nrTopic.publishAsync(System.currentTimeMillis());\r\n\r\n```\r\n\r\n\r\n```java\r\nException in thread \"redisson-3-11\" java.lang.IllegalStateException: org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@71f5bc7c has been closed already\r\n        at org.springframework.context.support.AbstractApplicationContext.assertBeanFactoryActive(AbstractApplicationContext.java:1067)\r\n        at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1100)\r\n        at group.xxxx.SpringUtil.getBean(SpringUtil.java:51)\r\n        at group.xxxx.handleMsg(RedissonMq.java:73)\r\n        at org.redisson.PubSubMessageListener.onMessage(PubSubMessageListener.java:79)\r\n        at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:78)\r\n        at org.redisson.client.handler.CommandPubSubDecoder.lambda$enqueueMessage$0(CommandPubSubDecoder.java:184)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.lang.Thread.run(Thread.java:748)\r\nException in thread \"redisson-3-17\" Exception in thread \"redisson-3-3\" java.lang.IllegalStateException: org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@1c08adcb has been closed already\r\n        at org.springframework.context.support.AbstractApplicationContext.assertBeanFactoryActive(AbstractApplicationContext.java:1067)\r\n        at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1100)\r\n        at group.xxx.SpringUtil.getBean(SpringUtil.java:51)\r\n        at group.xxx.handleMsg(RedissonMq.java:73)\r\n        at org.redisson.PubSubMessageListener.onMessage(PubSubMessageListener.java:79)\r\n        at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:78)\r\n        at org.redisson.client.handler.CommandPubSubDecoder.lambda$enqueueMessage$0(CommandPubSubDecoder.java:184)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.lang.Thread.run(Thread.java:748)\r\njava.lang.NoClassDefFoundError: io/netty/buffer/PoolArena$1\r\n        at io.netty.buffer.PoolArena.freeChunk(PoolArena.java:293)\r\nException in thread \"redisson-3-7\"      at io.netty.buffer.PoolThreadCache$MemoryRegionCache.freeEntry(PoolThreadCache.java:460)\r\n        at io.netty.buffer.PoolThreadCache$MemoryRegionCache.free(PoolThreadCache.java:430)\r\n        at io.netty.buffer.PoolThreadCache$MemoryRegionCache.free(PoolThreadCache.java:422)\r\n        at io.netty.buffer.PoolThreadCache.free(PoolThreadCache.java:279)\r\n        at io.netty.buffer.PoolThreadCache.free(PoolThreadCache.java:270)\r\n        at io.netty.buffer.PoolThreadCache.free(PoolThreadCache.java:241)\r\n        at io.netty.buffer.PooledByteBufAllocator$PoolThreadLocalCache.onRemoval(PooledByteBufAllocator.java:450)\r\n        at io.netty.buffer.PooledByteBufAllocator$PoolThreadLocalCache.onRemoval(PooledByteBufAllocator.java:426)\r\n        at io.netty.util.concurrent.FastThreadLocal.remove(FastThreadLocal.java:271)\r\n        at io.netty.util.concurrent.FastThreadLocal.removeAll(FastThreadLocal.java:67)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:32)\r\n        at java.lang.Thread.run(Thread.java:748)\r\njava.lang.IllegalStateException: org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@55d9ff04 has been closed already\r\n        at org.springframework.context.support.AbstractApplicationContext.assertBeanFactoryActive(AbstractApplicationContext.java:1067)\r\n        at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1100)\r\n        at group.xxx.SpringUtil.getBean(SpringUtil.java:51)\r\n        at group.xxxx.handleMsg(RedissonMq.java:73)\r\n        at org.redisson.PubSubMessageListener.onMessage(PubSubMessageListener.java:79)\r\n        at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:78)\r\n        at org.redisson.client.handler.CommandPubSubDecoder.lambda$enqueueMessage$0(CommandPubSubDecoder.java:184)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.lang.Thread.run(Thread.java:748)\r\nException in thread \"redisson-3-1\" java.lang.IllegalStateException: org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@1dc92408 has been closed already\r\n        at org.springframework.context.support.AbstractApplicationContext.assertBeanFactoryActive(AbstractApplicationContext.java:1067)\r\n        at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1100)\r\n        at group.xxx.SpringUtil.getBean(SpringUtil.java:51)\r\n        at group.xxx.handleMsg(xxx.java:73)\r\n        at org.redisson.PubSubMessageListener.onMessage(PubSubMessageListener.java:79)\r\n        at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:78)\r\n        at org.redisson.client.handler.CommandPubSubDecoder.lambda$enqueueMessage$0(CommandPubSubDecoder.java:184)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.lang.Thread.run(Thread.java:748)\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2687/comments",
    "author": "boot-vue",
    "comments": [
      {
        "user": "boot-vue",
        "created_at": "2020-04-11T10:35:45Z",
        "body": "if message  Object  is basic class  such as  integer , long.....,  no exception.\r\n\r\nbut  other class it throw exception. shuch  as: \r\n\r\n```java\r\npublic class CustMsg implements Serializable {\r\n\r\n    private static final long serialVersionUID = 9134649686694856723L;\r\n\r\n    private Long id;\r\n    private s String name;\r\n    private String key; \r\n\r\n....getter settter\r\n}\r\n```\r\n\r\n\r\n\r\npublish( CustMsg  )  ---> throw  exception"
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-11T11:45:21Z",
        "body": "> org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@71f5bc7c has been closed already\r\n\r\nSeems problem in a closed application context"
      },
      {
        "user": "boot-vue",
        "created_at": "2020-04-11T11:47:41Z",
        "body": "throgh  this  way,  it  can  run  normal  and   don't  throw  exception.\r\n\r\nI guess the problem  is  exist  two different  way  to  seriaize object  in my  code\r\n\r\nredistemplate I use fastjson  to  serialize object,  and  redissonClient I used default jsckson serialize.\r\n\r\n```java\r\n rTopic.addListener(String.class, (channel, msg) -> {\r\n            XXX message = JSON.parseObject(msg, XXX.class);\r\n            log.info(\"收到消息: {}\", message);\r\n        });\r\n\r\n\r\n\r\n      XXX message = new XXX(....);\r\n      rTopic.publishAsync(JSON.toJSONString(message));\r\n```"
      }
    ]
  },
  {
    "number": 2684,
    "title": "Elasticache and Clustered Redis, question about Configuration Endpoint",
    "created_at": "2020-04-10T18:42:05Z",
    "closed_at": "2020-04-13T08:00:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2684",
    "body": "Is there a example of how to correctly connect to a Redis Cluster using Configuration Endpoint? It seems like you must add all the nodes to Redisson configuration?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2684/comments",
    "author": "dk8996",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-04-13T08:00:27Z",
        "body": "As stated in wiki `At least one node from Redis Cluster should be specified.` In your case you need to just define Configuration Endpoint"
      }
    ]
  },
  {
    "number": 2683,
    "title": "Error: java.lang.ClassCastException: class org.redisson.api.BatchResult cannot be cast to class java.util.List",
    "created_at": "2020-04-10T14:52:55Z",
    "closed_at": "2020-04-10T19:37:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2683",
    "body": "Hi, I really want to start migrating to JDK14. \r\nSo my question is about JDK14 support estimates? \r\nSince bloomfilter doesn't work right now (which is pretty logical):\r\n```\r\njava.lang.ClassCastException: class org.redisson.api.BatchResult cannot be cast to class java.util.List (org.redisson.api.BatchResult is in unnamed module of loader 'app'; java.util.List is in module java.base of loader 'bootstrap')\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2683/comments",
    "author": "maistrovyi",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-04-11T05:39:42Z",
        "body": "It's fixed in upcoming version"
      }
    ]
  },
  {
    "number": 2667,
    "title": "about reading from replicas",
    "created_at": "2020-04-01T15:28:09Z",
    "closed_at": "2020-04-03T10:41:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2667",
    "body": "**Configuring only few maps for strong consistency:**\r\n\r\nCan i configure that few maps are read from the replicas and for others where i need strong consistency are read from the master only?\r\nIn this way i get strong consistency and also performance for other maps.\r\n\r\nIf not, can i have  to have two redisson instances with different configurations (one with read from replicas and other w/o )  for doing this?\r\n\r\n**Preventing data loss for map.**\r\n1. have a copy of map and write to it every time when the primary map changes\r\n2. name the map in such way that slot# is on different redis master \r\n3. when there is a node crash, start using other map as primary map\r\n( we are planning to use elastic cache ,hopefully there is a way to get notified which master failed)\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2667/comments",
    "author": "thesreyas",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-04-02T06:48:32Z",
        "body": "> Can i configure that few maps are read from the replicas and for others where i need strong consistency are read from the master only?\r\n\r\nYou can do it if you create two Redisson instances which share the same `Config.eventLoopGroup` and `Config.executor` objects.\r\n\r\n> when there is a node crash, start using other map as primary map\r\n( we are planning to use elastic cache ,hopefully there is a way to get notified which master failed)\r\n\r\nDon't invent a wheel. For strong consistency you can use Redis slave nodes and Batch with syncSlaves settings:\r\n\r\n```java\r\n// Map insert finishes only when Redis Slave timeout has reached or Slave sync has completed\r\n\r\nRBatch batch = redisson.createBatch(BatchOptions.defaults().syncSlaves(1, 1, TimeUnit.SECONDS));\r\nfor (int i = 0; i < 100; i++) {\r\n    RMapAsync<String, String> map = batch.getMap(\"test\");\r\n    map.putAsync(\"\" + i, \"\" + i);\r\n}\r\n\r\nBatchResult<?> result = batch.execute();\r\n```\r\n"
      },
      {
        "user": "thesreyas",
        "created_at": "2020-04-03T06:36:09Z",
        "body": "Thanks @mrniko for pointing about RBatch.\r\nJava Doc talks about leveraging it for pipelining multiple requests.\r\n\r\nIn our usecase, at a time, i only may have single map operation, say map.put().\r\nSo to leverage this I need to below 4 operations every time.\r\nIs that correct?\r\n\r\nWhat will be extra cost compared to map.put() w/o RBatch?\r\nIs it simply cost of map.put() and wait() or more.\r\n\r\n1. create RBatch\r\n 2. do getMap \r\n3. do map.put()\r\n 4.batch.execute(()"
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-03T06:38:28Z",
        "body": "> So to leverage this I need to below 4 operations every time.\r\nIs that correct?\r\n\r\nuse BatchOptions.executionMode = IN_MEMORY_ATOMIC to send them as a single request to Redis during `batch.execute()` method execution."
      },
      {
        "user": "thesreyas",
        "created_at": "2020-04-03T08:12:35Z",
        "body": "Thanks for your quick response @mrniko \r\n\r\nI was looking to ensure that each map operation is synchronously written to replica as well.\r\nSo basically using wait command after every write.\r\n\r\nRBatch looks great, it gives provision to sync with replicas.\r\nQuestion is can if i leverage RBatch like in (Approach 1) or i have to do as in Approach-2\r\nPlease take a look at MyRedissonMap.put()\r\n\r\nIn case of Approach 2, i am doing creation, gettingMap every time.  How much overhead does it had?\r\n\r\nIs there any other approach?\r\n<<<<<<Approach 1>>>>>>\r\n\r\n`public class MyRedissonMap {\r\nRBatch mBatch = null;\r\nRMap mMap = null;\r\n\r\nMyRedissonMap(Redisson redisson, String mapName){\r\n \r\n BatchOptions options = BatchOptions.defaults()\r\n .executionMode(ExecutionMode.IN_MEMORY_ATOMIC)\r\n .syncSlaves(2, 1, TimeUnit.SECONDS);\r\n \r\n mBatch = redisson.createBatch(options);\r\n mMap = batch.getMap(mapName);\r\n\r\n}\r\n\r\nvoid put(String aKey , String aValue){\r\n   mMap.put(aKey,aValue);\r\n   BatchResult result = batch.execute();\r\n   assert result.getSyncedSlaves() ==2;\r\n }\r\n\r\n}\r\n`\r\n<<<<<<<Approach 2>>>>\r\n\r\n`public class MyRedissonMap2 {\r\n\r\nRedisson redisson = null;\r\nString mapName = null;\r\n\r\nMyRedissonMap(Redisson aRedisson, String aMapName){\r\n redisson = aRedisson;\r\n mapName=aMapName;\r\n}\r\n\r\nvoid put(String aKey , String aValue){\r\n\tBatchOptions options = BatchOptions.defaults()\r\n\t .executionMode(ExecutionMode.IN_MEMORY_ATOMIC)\r\n\t .syncSlaves(2, 1, TimeUnit.SECONDS);\r\n\tRBatch batch = redisson.createBatch(options);\r\n\tmMap = batch.getMap(mapName);\r\n\tmMap.put(aKey,aValue);\r\n\tBatchResult result = batch.execute();\r\n\tassert result.getSyncedSlaves() ==2;\r\n }\r\n \r\n}`\r\n\r\n\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2020-04-03T10:40:16Z",
        "body": "If you use only single command in batch then `ExecutionMode.IN_MEMORY` could be used instead. Approach 2 looks fine."
      }
    ]
  },
  {
    "number": 2662,
    "title": "Redisson error when create client",
    "created_at": "2020-03-28T16:31:56Z",
    "closed_at": "2020-03-30T06:28:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2662",
    "body": "Hello, when I create a client I have an error with netty...\r\n`java.lang.NoSuchMethodError: io.netty.util.NetUtil.isIpV4StackPreferred()Z\r\n        at io.netty.resolver.dns.DnsNameResolver.<clinit>(DnsNameResolver.java:119) ~[?:?]\r\n        at io.netty.resolver.dns.DnsNameResolverBuilder.<init>(DnsNameResolverBuilder.java:52) ~[?:?]\r\n        at io.netty.resolver.dns.DnsAddressResolverGroup.<init>(DnsAddressResolverGroup.java:56) ~[?:?]\r\n        at org.redisson.connection.DnsAddressResolverGroupFactory.create(DnsAddressResolverGroupFactory.java:33) ~[?:?]\r\n        at org.redisson.connection.DnsAddressResolverGroupFactory.create(DnsAddressResolverGroupFactory.java:28) ~[?:?]\r\n        at org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:211) ~[?:?]\r\n        at org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:163) ~[?:?]\r\n        at org.redisson.connection.SingleConnectionManager.<init>(SingleConnectionManager.java:34) ~[?:?]\r\n        at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:195) ~[?:?]\r\n        at org.redisson.Redisson.<init>(Redisson.java:59) ~[?:?]\r\n        at org.redisson.Redisson.create(Redisson.java:99) ~[?:?]`\r\n\r\nThe code:\r\n`private void redis(){\r\n        Config config = new Config();\r\n        config.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");\r\n        RedissonClient redisson = Redisson.create(config);\r\n}`\r\nI use the last version of redisson",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2662/comments",
    "author": "Vlekzander",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-03-29T06:16:44Z",
        "body": "Check netty version in classpath. Seems you have old one or two different versions"
      }
    ]
  },
  {
    "number": 2648,
    "title": "Distlock Mutual exclusion problem ？",
    "created_at": "2020-03-23T01:50:50Z",
    "closed_at": "2020-03-23T05:20:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2648",
    "body": "1、assume a Redis cluster has a 5 master node; A , B, C ,D ,E representative node name.\r\n2、Client A  lock to A,B,C three node. lock success.\r\n3、This time B，C Node happen Network partition。\r\n4、Client B lock to D,E tow node, lock success，Satisfy N/2 + 1 ，because have A，D，E three node。\r\n5、Violation of mutual exclusion。",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2648/comments",
    "author": "lengrongfu",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-03-23T05:20:33Z",
        "body": "I can only suggest to use RedissonMultiLock."
      }
    ]
  },
  {
    "number": 2643,
    "title": "java.io.IOException: Failed to read the next byte",
    "created_at": "2020-03-19T19:16:08Z",
    "closed_at": "2020-03-31T06:39:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2643",
    "body": "Hi,\r\n\r\nI've run into the following exception and searching online does not yield any useful information. This is a Springboot app and the following is the config:\r\n\r\n`private RedissonClient getElastiCacheClient() {\r\n        if (redissonClient == null) {\r\n            log.info(\"Creating Redisson client, connecting to Redis: {}\", redisEndpoint);\r\n            Config config = new Config();\r\n            config.useReplicatedServers()\r\n                    .setScanInterval(2000)\r\n                    .addNodeAddress(redisEndpoint)\r\n                    .setReadMode(ReadMode.SLAVE);\r\n            redissonClient = Redisson.create(config);\r\n        }\r\n\r\n        return redissonClient;\r\n    }\r\n\r\n    @Bean\r\n    @Qualifier(\"tableOne\")\r\n    public RMapCache<String, String> tableOne() {\r\n        log.info(\"Intializing tableOne...\");\r\n        return getElastiCacheClient().getMapCache(\"tableOne\");\r\n    }\r\n\r\n    @Bean\r\n    @Qualifier(\"tableTwo\")\r\n    public RMapCache<String, MyAppRequest> tableTwo() {\r\n        log.info(\"Intializing tableTwo...\");\r\n        return getElastiCacheClient().getMapCache(\"tableTwo\");\r\n    }`\r\n\r\nWe have multiple apps that are using tableOne and tableTwo, some writes some reads/writes. Each app has multiple instances.\r\n\r\nThis exception happens after the initialization of tableTwo. TableOne has always been fine. We are able to circumvent this by doing tableTwo().clear() during startup but the following error returns when it is being used. Has anyone run into this issue before or have any guess/insight of what's going on?\r\n\r\nERROR 2020-03-19 14:11:13,346 [redisson-netty-2-17] org.redisson.client.handler.CommandDecoder app=myApp version=2.0.1.0 : Unable to decode data. channel: [id: 0x110ba4d5, L:/172.31.57.100:38648 - R:my-app.eq0m8j.ng.0001.use1.cache.amazonaws.com/172.31.50.140:6379], reply: ReplayingDecoderByteBuf(ridx=165, widx=165), command: (EVAL), params: [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, MyAppTable, redisson__timeout__set:{MyAppTable}, redisson__idle__set:{MyAppTable}, redisson__map_cache__last_access__set:{MyAppTable}, {MyAppTable}:redisson_options, 1584627073343, PooledUnsafeDirectByteBuf(ridx: 0, widx: 11, cap: 256)]\r\njava.io.IOException: java.io.IOException: java.io.IOException: Failed to read the next byte\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247) ~[fst-2.57.jar!/:?]\r\n\tat org.redisson.codec.FstCodec$1.decode(FstCodec.java:228) ~[redisson-3.11.0.jar!/:?]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:384) ~[redisson-3.11.0.jar!/:?]\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:215) ~[redisson-3.11.0.jar!/:?]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:153) ~[redisson-3.11.0.jar!/:?]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122) ~[redisson-3.11.0.jar!/:?]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) ~[netty-codec-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) ~[netty-codec-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) ~[netty-transport-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) ~[netty-transport-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) ~[netty-transport-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) ~[netty-transport-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) ~[netty-transport-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) ~[netty-transport-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) ~[netty-transport-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:682) ~[netty-transport-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:617) ~[netty-transport-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:534) ~[netty-transport-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496) ~[netty-transport-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) ~[netty-common-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.36.Final.jar!/:4.1.36.Final]\r\n\tat java.lang.Thread.run(Thread.java:748) [?:1.8.0_242]\r\nCaused by: java.io.IOException: java.io.IOException: Failed to read the next byte\r\n\tat org.redisson.codec.FstCodec$FSTDefaultStreamCoderFactory$1.readStringUTF(FstCodec.java:145) ~[redisson-3.11.0.jar!/:?]\r\n\tat org.nustaq.serialization.FSTClazzNameRegistry.decodeClass(FSTClazzNameRegistry.java:168) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.coders.FSTStreamDecoder.readClass(FSTStreamDecoder.java:478) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readClass(FSTObjectInput.java:939) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:347) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:713) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:566) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245) ~[fst-2.57.jar!/:?]\r\n\t... 24 more\r\nCaused by: java.io.IOException: Failed to read the next byte\r\n\tat org.nustaq.serialization.coders.FSTStreamDecoder.readFByte(FSTStreamDecoder.java:294) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.coders.FSTStreamDecoder.readFInt(FSTStreamDecoder.java:252) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.coders.FSTStreamDecoder.readStringUTF(FSTStreamDecoder.java:77) ~[fst-2.57.jar!/:?]\r\n\tat org.redisson.codec.FstCodec$FSTDefaultStreamCoderFactory$1.readStringUTF(FstCodec.java:141) ~[redisson-3.11.0.jar!/:?]\r\n\tat org.nustaq.serialization.FSTClazzNameRegistry.decodeClass(FSTClazzNameRegistry.java:168) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.coders.FSTStreamDecoder.readClass(FSTStreamDecoder.java:478) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readClass(FSTObjectInput.java:939) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:347) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:713) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:566) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311) ~[fst-2.57.jar!/:?]\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245) ~[fst-2.57.jar!/:?]\r\n\t... 24 more",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2643/comments",
    "author": "jansonlow",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-03-20T04:23:29Z",
        "body": "Hi,\r\n\r\nmake shure you don't share the same name with different type of objects. Is there any code sample to reproduce it?"
      },
      {
        "user": "jansonlow",
        "created_at": "2020-03-20T15:21:16Z",
        "body": "Do you mean using the same table to store different type of objects? It was in test tableTwo started off storing <String,String> and later on <String,Object>. We did flushall and also did table.clear() though. The code I included was it. interacting with tableTwo triggers the exception. Most of the time right after initialization we see the exception."
      },
      {
        "user": "mrniko",
        "created_at": "2020-03-20T15:24:37Z",
        "body": "I mean to check if the same name shared with any different Redisson object. Also try to use different codec"
      }
    ]
  },
  {
    "number": 2642,
    "title": "RMapCache adds some special characters before",
    "created_at": "2020-03-19T09:10:50Z",
    "closed_at": "2020-03-31T06:38:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2642",
    "body": "Redisson version - 3.12.3\r\nJava version - 11\r\n\r\n```\r\nfinal TypedJsonJacksonCodec codec = new TypedJsonJacksonCodec(String.class, JSONObject.class, new ObjectMapper());\r\nJSONObject value = new JSONObject(new HashMap<String, String>() {{\r\n    put(\"a\", \"b\");\r\n}});\r\nRMapCache<Object, JSONObject> myMapCache = redissonClient.getMapCache(\"myMapCache\", codec);\r\nmyMapCache.put(\"key\", value, 14, TimeUnit.DAYS);\r\nRLocalCachedMap<Object, JSONObject> myLocalCachedMap = redissonClient.getLocalCachedMap(\"myLocalCachedMap\", codec, LocalCachedMapOptions.defaults());\r\nmyLocalCachedMap.put(\"key\", value);\r\n```\r\n\r\nWith use of codec:\r\nRMapCache HGETALL returns \r\n1) \"\\\"key\\\"\"\r\n2) \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\x00\\x00\\x00\\x00\\x00\\x00\\x00{\\\"a\\\":\\\"b\\\"}\" \r\nfrom redis-cli.\r\n\r\nRLocalCachedMap returns \r\n1) \"\\\"key\\\"\"\r\n2) \"{\\\"a\\\":\\\"b\\\"}\"\r\nfrom redis-cli.\r\n\r\nMy question - what is the special characters in RMapCache.\r\nAnd how can i read json without this characters by call HGET on raw Redis?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2642/comments",
    "author": "Slava96",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-03-19T10:00:19Z",
        "body": "it's maxIdleTime + value length + value"
      },
      {
        "user": "Slava96",
        "created_at": "2020-03-19T10:12:45Z",
        "body": "I understand - that it's not limited length - so we cannot simply parse this value.\r\nIs i understand correct?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-03-19T12:06:37Z",
        "body": "maxIdletime and length values have fixed size"
      },
      {
        "user": "asarkar",
        "created_at": "2021-08-13T21:02:59Z",
        "body": "@Slava96 I'm seeing the same behavior. What did you end up doing?"
      },
      {
        "user": "jagansankara",
        "created_at": "2022-04-19T13:46:15Z",
        "body": "I'm also facing same issue but for different scenario. Key which inserted through Redission library have additional characters and works fine if I read it again through Redission but not with other platform like Python library or redis-cli.\r\n\r\nOur requirement is to read/write same key from different application (here it is SpringBoot & Django)."
      }
    ]
  },
  {
    "number": 2639,
    "title": "question with RBlockingQueue.poll(timeout, TimeUnit.SECONDS)",
    "created_at": "2020-03-18T05:27:59Z",
    "closed_at": "2020-04-30T06:00:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2639",
    "body": "Redisson version: 3.12.1\r\nJava version: 1.8\r\n\r\nHi, in one of our environments BLPOP doesn't pop the elements, though there are elements in the queue when queried via redis-cli with LRANGE command. The issue happens only in one of the environments, are there any known issues with `RBlockingQueue.poll(timeout, TimeUnit.SECONDS)` where the timeout is `zero`? This method is called from a while(true) loop, the functionality works for 3-4 hours and then stops popping the elements. As I couldn't reproduce locally I couldn't attach the reproducible code.  \r\n\r\n```\r\n          RBlockingQueue<String> queue = redissonClient.getBlockingQueue(queueName);\r\n\t\ttry {\r\n                         // some calling methods pass timeout as zero.\r\n\t\t\treturn queue.poll(timeout, TimeUnit.SECONDS); \r\n\t\t} catch (InterruptedException e) {\r\n\t\t\tLOG.error(ex.message);\r\n\t\t}\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2639/comments",
    "author": "rgampa",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-03-18T05:37:56Z",
        "body": "Hi,\r\n\r\nThere are no known issues with BLPOP command. Which Redis vendor do you use?"
      },
      {
        "user": "rgampa",
        "created_at": "2020-03-18T05:45:49Z",
        "body": "HI @mrniko It's open source installation. All environments have same infrastructure. My question was if we use `0` timeout will it cause any issue? I will be changing it to `queue.poll()` as there is no point in using BLOP with `0` timeout. But I am curious are there are any known issues?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-03-18T05:48:33Z",
        "body": "> My question was if we use 0 timeout will it cause any issue?\r\n\r\nNo. It's good idea to try to change it with limited timeout. Please let me know if it fix the issue."
      },
      {
        "user": "tigernitw",
        "created_at": "2023-07-12T11:57:08Z",
        "body": "@rgampa : Even I am facing same issue in production. Can you please suggest if there is anything you have done to fix it."
      },
      {
        "user": "rgampa",
        "created_at": "2023-07-12T14:45:23Z",
        "body": "Hi @tigernitw , as far as I remember we have replaced the `0` (infinite) timeout with max 5 sec timeout that time. Currently we don't see this behavior in our environments. Over the time we upgraded Redisson version in our code, currently it's at `3.19.2`. "
      }
    ]
  },
  {
    "number": 2629,
    "title": "Does entrySet with count support sorting?",
    "created_at": "2020-03-10T16:14:05Z",
    "closed_at": "2020-03-16T08:25:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2629",
    "body": "**Redisson version:**\r\n3.12.3\r\n\r\n**Redis version**\r\n5.0.4\r\n\r\nI have RMapCache on my program, and store values with TTL. \r\nThen, I want to get 100 entries that saved first on this map.\r\n\r\nSo, i have a question - entrySet with 'count' parameter returns values that saved first or last?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2629/comments",
    "author": "Slava96",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-03-10T17:55:49Z",
        "body": "RMapCache doesn't maintain order as well as Redis hash object."
      }
    ]
  },
  {
    "number": 2619,
    "title": "RMapCache Cache expiration on a cluster of Redisson clients",
    "created_at": "2020-02-29T23:29:51Z",
    "closed_at": "2020-03-16T08:29:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2619",
    "body": "Hi @mrniko ,\r\n\r\nI have a query regarding RMapCache expiration events . I have the following use case\r\n\r\nI have a backend API which will push data to redis on an API call from a third party system . I am setting a ttl to the key because I want to initiate a process in the background when the key expires. \r\nThe process to listen to key expiration events sits in a microservice. \r\n\r\nI read in the documentation there is a EntryExpiredListener for RMapCache. \r\n\r\nNow if the microservice sits in a cluster and if I am subscribing to key expiration events on RMapCache through EntryExpiredListener in each of my microservice instance then \r\n\r\na) if the key is \"123\" for example , on ttl expiry would all the instances get the key expiration notification ? \r\n\r\nb) if yes , is it possible to shard the key expiration events of RMapCache lets say in 100 expiration events , 50 events go to instance 1 and 50 got to instance 2 ?\r\n\r\nc) Whats the performance of key expiration listener if  I have 100000 expiration events to process , if there is only one instance ?  Is there a hard limit in terms of throttling the no of expired events per poll inside redis/redisson?\r\n\r\nRegards,\r\nHarish \r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2619/comments",
    "author": "harry9111985",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-03-16T08:29:54Z",
        "body": "> a) if the key is \"123\" for example , on ttl expiry would all the instances get the key expiration notification ?\r\n\r\nAll the instances get notification\r\n\r\n> b) if yes , is it possible to shard the key expiration events of RMapCache lets say in 100 expiration events , 50 events go to instance 1 and 50 got to instance 2 ?\r\n\r\nNo\r\n\r\n> c) Whats the performance of key expiration listener if I have 100000 expiration events to process , if there is only one instance ? Is there a hard limit in terms of throttling the no of expired events per poll inside redis/redisson?\r\n\r\nPerformance depends on available system resources. There is no throttling since PUB/SUB is used for notification."
      },
      {
        "user": "OS-ramamurtisubramanian",
        "created_at": "2024-02-13T10:57:45Z",
        "body": "Hi @mrniko,\r\n\r\nWe are using AWS ElastiCache 7.0.7 with cluster mode enabled. We have 2 master and 2 slave nodes.\r\n\r\nWe have a similar use case where we have 4 instances of the microservice running and all of them are adding an expiry listener to a mapCache. \r\n\r\nAccording to the above comment, we expect all 4 instances to receive the same expiry events, but only 2 of the instances get them.\r\n\r\nIs this a bug or are we missing some configuration?\r\n\r\n[EDIT]\r\n\r\nAfter running the pods, I connected to the Redis cluster using cli and ran the following command\r\n\r\nPUBSUB SHARDNUMSUB redisson_map_cache_expired:{cacheName}\r\n\r\nWhich returned 2 instead of 4. \r\n\r\nI tried restarting the pods multiple times and some times it went to 3 and 4, but it's not consistent. \r\n\r\nI assume there is some problem in ssubscribe of the expiry topic."
      }
    ]
  },
  {
    "number": 2613,
    "title": "In a frequent job , sometime lock.tryLock() can not get lock",
    "created_at": "2020-02-25T15:10:58Z",
    "closed_at": "2020-02-28T05:28:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2613",
    "body": "\t\t<dependency>\r\n\t\t\t<groupId>org.redisson</groupId>\r\n\t\t\t<artifactId>redisson-spring-boot-starter</artifactId>\r\n\t\t\t<version>2.15.2</version>\r\n\t\t</dependency>\r\nIn a spring boot 1.5.6 application , We have a new job which is running every 30 seconds and try to acquire lock to do something . In recent days the job has tried to acquire one specific lock cause of business , We found from 00:13 on Feb 24  the job can not get the lock but after 15:03 the job can get the lock again . The operation on this lock only in this job . \r\nthe code on the lock as below :\r\n\r\n        boolean res = lock.tryLock();\r\n        if (res) {\r\n            try {\r\n                ...\r\n            } finally {\r\n                if (lock.isHeldByCurrentThread())\r\n                    lock.unlock();\r\n            }\r\n        } else {\r\n            LockUtils.logLockError(lockName, amount, null, \"consume balance\");\r\n            msg = String.format(\"acquire merchant account lock (%s)failed\", lockName);\r\n        }\r\n\r\nThanks\r\n\r\n\r\n\r\n\r\n ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2613/comments",
    "author": "mi13chael",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-02-25T15:13:50Z",
        "body": "I would recommend to remove `if (lock.isHeldByCurrentThread())` this check since unlock should be invoked in any case."
      },
      {
        "user": "mi13chael",
        "created_at": "2020-02-25T15:17:55Z",
        "body": "I think if the lock acquired in another thread , unlock should be invoked in that thread .\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2020-02-25T15:46:19Z",
        "body": "I don't see any other reason except dealy in code execution between braces."
      },
      {
        "user": "mrniko",
        "created_at": "2020-02-25T15:47:33Z",
        "body": "> I think if the lock acquired in another thread , unlock should be invoked in that thread .\r\n\r\nall the more you don't need to add this check."
      },
      {
        "user": "mi13chael",
        "created_at": "2020-02-26T02:10:47Z",
        "body": "Thanks , I already had this update in the job , will see what happened in the future. \r\n"
      },
      {
        "user": "mi13chael",
        "created_at": "2020-02-26T02:12:33Z",
        "body": "That is a point to catch who is operating the lock in the meantime."
      },
      {
        "user": "mi13chael",
        "created_at": "2020-02-28T05:28:28Z",
        "body": "the situation have not happened again . "
      }
    ]
  },
  {
    "number": 2609,
    "title": "Does any form of visibility / metrics / eventing require Redisson Pro",
    "created_at": "2020-02-23T01:51:22Z",
    "closed_at": "2020-02-23T07:40:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2609",
    "body": "From what I can tell it does. I don't think this is justified. No one should be using a library - casually or otherwise - without metrics and a basic eventing system.\r\n\r\nThere's many fine features of this product that I'd be HAPPY with as commercial only, including most of its task scheduling, but metrics is an absolute no-go.\r\n\r\nOf course my needs may be different from others, but I ask you to reconsider this. Even providing a basic eventing system that OSS could build metrics from would be great.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2609/comments",
    "author": "mikebell90",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-02-23T06:02:23Z",
        "body": "Thanks for sharing your opinion. Unfortunately, this feature can't be part of OSS project. My apologies, if you have to choose the other solution in this case."
      }
    ]
  },
  {
    "number": 2608,
    "title": "Auto-Reconnect to a Modifed Elasticache Cluster",
    "created_at": "2020-02-21T13:00:21Z",
    "closed_at": "2020-04-23T09:51:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2608",
    "body": "I am trying to optimize an elasticache cluster clustered mode disabled in productive use by downscaling to a smaller instance type. As we all know, AWS will migrate to new nodes with different IP addresses and the client will need to reconnect.  I would like to configure my redisson client to reconnect fast to the master node so we minimize the downtime as much as possible. What are the best practices to reduce downtime and to connect to new master nodes and slaves as fast as possible? Note that I am using ReplicatedServers to connect to the cluster.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2608/comments",
    "author": "eltalkarim",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-04-23T09:51:39Z",
        "body": "It depends on how fast AWS update topology info returned by `INFO REPLICATION` command. Increase `retryAttempts` and `retryInterval` parameters for exceptionless transition."
      }
    ]
  },
  {
    "number": 2596,
    "title": "tryLock()，Machines are not evenly distributed, and one server never gets the lock",
    "created_at": "2020-02-19T08:26:19Z",
    "closed_at": "2020-02-20T07:44:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2596",
    "body": "Machines are not evenly distributed, and one server never gets the lock.It's going to last forever\r\nredisson 3.12.2",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2596/comments",
    "author": "wangqingfan",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-02-19T09:13:46Z",
        "body": "Use `RFairLock` object in this case"
      },
      {
        "user": "wangqingfan",
        "created_at": "2020-02-19T09:16:15Z",
        "body": "> Use `RFairLock` object in this case\r\n\r\nSo if you have two machines executing alternately, you still can't do about 1:1"
      },
      {
        "user": "mrniko",
        "created_at": "2020-02-19T09:17:05Z",
        "body": "You will with `RFairLock`"
      },
      {
        "user": "wangqingfan",
        "created_at": "2020-02-19T09:18:43Z",
        "body": "> You will with `RFairLock`\r\n\r\nSo if you have two machines executing alternately, you still can't do about 1:1"
      }
    ]
  },
  {
    "number": 2592,
    "title": "Is it possible to destroy session on deserialization issue?",
    "created_at": "2020-02-18T05:27:52Z",
    "closed_at": "2022-10-05T14:06:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2592",
    "body": "Redisson version: 3.12.1\r\n\r\nWe have the next situation:\r\n\r\nSometimes we update some of our entities that stored in a session.\r\n\r\nAfter that we get a lot of exceptions in log:\r\n\r\n```\r\norg.redisson.client.RedisException: Unexpected exception while processing command\r\n--\r\nat org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:401)\r\nat org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:205)\r\nat org.redisson.RedissonObject.get(RedissonObject.java:94)\r\nat org.redisson.RedissonMap.readAllMap(RedissonMap.java:507)\r\nat org.redisson.tomcat.RedissonSession.getAttribute(RedissonSession.java:111)\r\n...\r\nCaused by: java.io.InvalidClassException: com.SomeEntity; local class incompatible: stream classdesc serialVersionUID = 123, local class serialVersionUID = 321\r\n```\r\n\r\nWe catch this exception when we trying to get some client session parameters.\r\n\r\nAnd it looks strange because the client already in the authorized zone and have a session, but actually session is invalid, so is it possible to invalidate session on deserialization?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2592/comments",
    "author": "sibmaks",
    "comments": [
      {
        "user": "sibmaks",
        "created_at": "2020-02-18T05:30:11Z",
        "body": "Yes, I forgot to notice, we use org.redisson.codec.SerializationCodec and can't use JSON-like codes, because we have some recursion links. "
      },
      {
        "user": "mrniko",
        "created_at": "2020-03-27T09:11:27Z",
        "body": "Please do it with Valve object rather than suggesting patch"
      },
      {
        "user": "sibmaks",
        "created_at": "2020-03-27T09:15:49Z",
        "body": "@mrniko hi, we can do it. So currently we built own wrapper above your session manager with these changes."
      },
      {
        "user": "mrniko",
        "created_at": "2020-03-27T09:17:24Z",
        "body": "You could add one Valve object and invalidete session in org.redisson.tomcat.Valve#invoke method"
      },
      {
        "user": "sibmaks",
        "created_at": "2020-03-27T09:38:01Z",
        "body": "I think that org.apache.catalina.valves.RequestFilterValve looks better in this case. But the whole solution looks like a crutch because we just have to request any attribute and deny the request on any exception.\r\nAlso, in this case, we have to integrate redisson with our app, currently, we don't use redisson in it. Except for the tiny library that fixed this issue. "
      }
    ]
  },
  {
    "number": 2591,
    "title": "onConnect, onDisconnect seem doesn't work as expected",
    "created_at": "2020-02-16T05:26:38Z",
    "closed_at": "2021-04-29T09:05:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2591",
    "body": "We're using the Redis provided by AWS ElastiCache, Cluster mode and we need to handle some logic once losing connections with Redis, so we implement these 2 methods.\r\n\r\nI shutdown the Redis manually in order to test these methods. However, it doesn't work as expected.\r\n\r\nonDisconnect() is trigged successfully while onConnect() is also trigged unexpectly. Is there anything wrong inside?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2591/comments",
    "author": "ieiayaobb",
    "comments": [
      {
        "user": "willy23martin",
        "created_at": "2021-04-28T14:41:18Z",
        "body": "Hi @ieiayaobb \r\n\r\nMaybe you could check if you have the ConnectionListener configured before creating the RedissonClient. \r\n\r\nI understood and also tested that you need first load the Config YAML file (for example) and then add your custom ConnectionListener to the Config object. In my case, once I had those steps completed, I was able to create the RedissonClient by using the Config object and it is working as I expected. \r\n\r\nI hope it can help you."
      },
      {
        "user": "mrniko",
        "created_at": "2021-04-29T09:05:40Z",
        "body": "connectionListener setting was moved to Config object and works properly."
      }
    ]
  },
  {
    "number": 2585,
    "title": "RPermitExpirableSemaphore and RSemaphore",
    "created_at": "2020-02-12T15:29:43Z",
    "closed_at": "2020-02-12T15:30:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2585",
    "body": "Does Redisson allows to release the semaphore  (RPermitExpirableSemaphore and RSemaphore) on different redisson client (different jvm) than the one on which permit was acquired ?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2585/comments",
    "author": "shashanka981",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-02-12T15:30:19Z",
        "body": "Sure"
      }
    ]
  },
  {
    "number": 2583,
    "title": "spring data redis to redisson api",
    "created_at": "2020-02-12T08:10:07Z",
    "closed_at": "2020-02-26T09:24:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2583",
    "body": "I've recently used spring-data redis and planning to move to redisson without spring.\r\n\r\nHow do I migrate this snippet of codes to redisson without flushing / reinserting my previous data.\r\n\r\n`@RedisHash(\"client\")\r\npublic class Client implements Serializable {\r\n\r\n\t@Id\r\n\t@Indexed\r\n\tprivate String id;\r\n\t@Indexed\r\n\tprivate String computerName;\r\n\t@Indexed\r\n\tprivate String ipAddress;\r\n\r\n}`\r\n\r\n\r\n`\r\nPagingAndSortingRepository.findAll()\r\n`\r\n\r\nI tried using RSet but it throws an NPE\r\n\r\n`\r\nRSet<Client> rSet = client.getSet(\"client\");\r\n     rSet.forEach(c -> {\r\n          System.out.println(c.toString());\r\n});`\r\n\r\n\r\nUnable to decode data. channel: [id: 0x5ea156f1, L:/127.0.0.1:62502 - R:localhost/127.0.0.1:6379], reply: ReplayingDecoderByteBuf(ridx=58, widx=58), command: (SSCAN), params: [client, 0, COUNT, 10]\r\n\r\njava.io.IOException: java.lang.NullPointerException\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247)\r\n\tat org.redisson.codec.FstCodec$1.decode(FstCodec.java:250)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:368)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:412)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:377)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:412)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:377)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:196)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104)\r\n\tat \r\n`\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2583/comments",
    "author": "mrguamos",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-02-12T08:37:16Z",
        "body": "Redisson uses FSTCodec by default and I assume you used different codec for object stored with spring data. Try to use StringCodec or BinaryCodec."
      },
      {
        "user": "mrguamos",
        "created_at": "2020-02-12T09:56:58Z",
        "body": "> \r\n> \r\n> Redisson uses FSTCodec by default and I assume you used different codec for object stored with spring data. Try to use StringCodec or BinaryCodec.\r\n\r\nThanks for the reply, but I didn't set any codec so I think it's safe to say that I used the default codec of spring data.\r\n\r\nI tried all the available codecs for Redisson but none of them work.\r\nIt either throws Parse or Cast Class Exception"
      },
      {
        "user": "mrniko",
        "created_at": "2020-02-12T13:16:15Z",
        "body": "I'm afraid reinserting is the only way then."
      }
    ]
  },
  {
    "number": 2576,
    "title": "How to know if RedissonMap is created at redis end ",
    "created_at": "2020-02-07T09:29:53Z",
    "closed_at": "2020-02-07T09:32:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2576",
    "body": "Is there a way to know if a map with given name is created at redis end. As per understanding, org.redisson.api.RedissonClient.getMap(java.lang.String name) always gives new RedissonMap and only creates interacts with redis when one does any map operations like get/put. \r\nWhich means Using org.redisson.api.RedissonClient.getMap(java.lang.String name) will not send any request to redis ?\r\nSo how can i know that if a map with given name already exists at redis end using any of the redisson apis? ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2576/comments",
    "author": "SushmaReddyLoka",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-02-07T09:32:08Z",
        "body": "use `RMap.isExists` method"
      },
      {
        "user": "SushmaReddyLoka",
        "created_at": "2020-02-07T09:34:45Z",
        "body": "Thanks for the response. Along with it can you confirm if my understanding about getMap api is correct ? "
      },
      {
        "user": "mrniko",
        "created_at": "2020-02-07T13:33:49Z",
        "body": "> gives new RedissonMap and only creates interacts with redis when one does any map operations like get/put.\r\n\r\nYes, RMap is fully stateless on Redisson side."
      }
    ]
  },
  {
    "number": 2570,
    "title": "How do i specify default permits when creating semaphore object with RMap",
    "created_at": "2020-02-05T17:00:07Z",
    "closed_at": "2020-02-06T13:46:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2570",
    "body": "i am trying to create semaphore using below method from RMap interface. \r\n\r\n**RSemaphore getSemaphore(K key);**\r\n\r\nWhat is the default permits associated with this semaphore ?  i wanted to use Semaphore as an alternate to RLock , so i need a default max permit of 1. I see trySetPermits() method in RSemaphore class.. But is there a way to set default number of permits while creating Semaphore object without having to call trySetPermits() method.\r\nWithout a provision to set a default number of permits, how would we achieve the scenario where multiple threads are trying to create a semaphore with same key ? Developer is forced to ensure that everytime a semaphore object is created for a given key,  trySetPermits() method need to be called exactly once in the entire lifecycle of application. Is my understanding right ? what happens in below scenario assuming events happen in same sequence as listed\r\n\r\nthread 1 calls rmap.getsemaphore(key1);\r\nthread 1 calls trySetPermits(1); // number of availble permits is 1 \r\nthread 1 calls acquire();  // number of available permits to 0\r\n\r\nthread 2 calls rmap.getsemaphore(key1);\r\nthread 2 calls trySetPermits(1); // Will this call sets the available permits to 1 again ? What would happen here?\r\nthread 2 calls acquire() // ideally thread 2 should not acquire permit.  What would happen here?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2570/comments",
    "author": "shashanka981",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-02-06T05:15:04Z",
        "body": "> how would we achieve the scenario where multiple threads are trying to create a semaphore with same key ?\r\n\r\nall RSemaphore methods are thread safe. `trySetPermits` method will set permits only once. Once you called it in any thread or JVM you don't need to call it again since it will return `false`."
      },
      {
        "user": "mrniko",
        "created_at": "2020-02-06T05:18:55Z",
        "body": "right, second call of acquire method will wait for permit."
      }
    ]
  },
  {
    "number": 2562,
    "title": "Dynamically setting TTL",
    "created_at": "2020-01-28T00:56:27Z",
    "closed_at": "2020-01-31T06:37:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2562",
    "body": "we set TTL into CacheConfig when the cache is initially created. Is there a way to change that AFTER creation? \r\n\r\nwe are caching an api endpoint and would like to return stale objects even after expiry. \r\none way to achieve this is to check the downstream api and if not responding then extend ttl to use the existing stale object.\r\n\r\n\r\n\r\n> @Bean(\"xxCacheManager\")\r\n>     CacheManager getCM(RedissonClient redissonClient) {\r\n>         CacheConfig cacheConf = new CacheConfig();\r\n>         cacheConf.setTTL(...);\r\n>         Map<String, CacheConfig> configs = new HashMap<String, CacheConfig>() {{ put(\"xxCacheManager\", cacheConf); }};\r\n>         return new RedissonSpringCacheManager(redissonClient,configs);\r\n>     }",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2562/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-01-31T06:35:02Z",
        "body": "It's not possible at the moment."
      }
    ]
  },
  {
    "number": 2558,
    "title": "java.lang.NoClassDefFoundError: org.redisson.misc.RedissonPromise",
    "created_at": "2020-01-23T12:01:42Z",
    "closed_at": "2021-06-29T07:25:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2558",
    "body": "Working with replicaof server. \r\nReturning data when using RedisDesktopManager. But when I tried to create client following exception occurs with RedissonPromise\r\n\r\n`01-23 19:52:03.408 20281-20281/com.example.uhf E/AndroidRuntime: FATAL EXCEPTION: main\r\n    Process: com.example.uhf, PID: 20281\r\n    java.lang.NoClassDefFoundError: org.redisson.misc.RedissonPromise\r\n        at org.redisson.connection.MasterSlaveConnectionManager.shutdown(MasterSlaveConnectionManager.java:663)\r\n        at org.redisson.connection.MasterSlaveConnectionManager.shutdown(MasterSlaveConnectionManager.java:643)\r\n        at org.redisson.connection.MasterSlaveConnectionManager.stopThreads(MasterSlaveConnectionManager.java:727)\r\n        at org.redisson.connection.MasterSlaveConnectionManager.initSingleEntry(MasterSlaveConnectionManager.java:363)\r\n        at org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:167)\r\n        at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:191)\r\n        at org.redisson.Redisson.<init>(Redisson.java:120)\r\n        at org.redisson.Redisson.create(Redisson.java:160)\r\n`\r\nI am using\r\n` implementation 'org.redisson:redisson:3.12.6'`\r\n\r\nusing config\r\n`config.useMasterSlaveServers()\r\n                .setMasterAddress(\"redis://<master ip> <master port>\")\r\n                .setReadMode(ReadMode.SLAVE)\r\n                .addSlaveAddress(\"redis://<replica ip> <replica port>\");\r\n        config.setCodec(JsonJacksonCodec.INSTANCE);`\r\nsame exception occurs using `config.useSingleServer()`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2558/comments",
    "author": "sharmad1205",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-01-23T13:13:24Z",
        "body": "seems there is a some problem with classloading in your application. Is there complete example to reproduce?"
      },
      {
        "user": "sharmad1205",
        "created_at": "2020-01-24T04:24:06Z",
        "body": "@mrniko  \r\nMy Server is a replica of main server like\r\n`configs.putString(\"bind\", \"0.0.0.0\");`\r\n`configs.putString(\"maxmemory\", \"1GB\");`\r\n`configs.putString(\"port\", \"10000\");`\r\n`configs.putString(\"protected-mode\", \"no\");`\r\n`configs.putString(\"masterauth\", \"XXX);`\r\n`configs.putString(\"requirepass\", \"XXX\");`\r\n`configs.putString(\"replicaof\", \"XXX.XXX.XXX.XXX 6379\");`\r\n\r\nAlso tried with redisson config like\r\n`Config config = new Config();`\r\n`config.useSingleServer()`\r\n`.setAddress(\"redis://<myreplicaserver>:10000\")`\r\n`.setPassword(\"XXXXXX\");`\r\n`client = Redisson.create(config);`\r\n\r\nHowever I can connect to my replica through third party desktop application RedisDesktopManager\r\nBut this crash come on line `Redisson.create(config)`\r\n\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2020-01-24T06:22:42Z",
        "body": "`org.redisson.misc.RedissonPromise` is in jar. You need to fix this classpath issue."
      },
      {
        "user": "sharmad1205",
        "created_at": "2020-01-24T06:27:39Z",
        "body": "@mrniko Thanks for replying, I am using in android with gradle implementation\r\n`implementation 'org.redisson:redisson:3.12.6'`\r\n\r\nWhile importing the RedissonPromise is there. But `Redisson.Create()` method didn't find the class path."
      }
    ]
  },
  {
    "number": 2552,
    "title": "Master/Slave mode with master only writer and slaves as reader",
    "created_at": "2020-01-21T05:51:55Z",
    "closed_at": "2020-03-05T06:53:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2552",
    "body": "I tried Master Slave configuration for redission-mybatis. I want to set 'master' only for writer and 'slave' for read only. But when is set master slave configuration i can see master is also used for reading purpose. \r\n\r\nCan i set configuration in which 'master' work only as writer not reader?  ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2552/comments",
    "author": "nitinparetha",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-01-21T06:17:53Z",
        "body": "`RMapCache.get` method uses write operation executed on master node to update idleTime of read map entry."
      },
      {
        "user": "nitinparetha",
        "created_at": "2020-01-21T13:57:33Z",
        "body": "I checked redis commands using redis-cli. Master node is getting 'hget' command but i want only to use it as writer. So, I think master should not get 'hget', all 'hget' command should be executed on 'slave/reader' only. \r\n\r\nHow can I configure Master/Slave configuration in which master work as writer (no 'hget' command on master) and Slave work as reader only (slave are set for read-only)."
      },
      {
        "user": "mrniko",
        "created_at": "2020-01-22T06:05:53Z",
        "body": "did you set `readMode = SLAVE` in config?"
      },
      {
        "user": "nitinparetha",
        "created_at": "2020-01-23T06:03:44Z",
        "body": "My configuration is as below:\r\nmasterSlaveServersConfig:\r\n  idleConnectionTimeout: 10000\r\n  connectTimeout: 10000\r\n  timeout: 3000\r\n  retryAttempts: 3\r\n  retryInterval: 1500\r\n  failedSlaveReconnectionInterval: 3000\r\n  failedSlaveCheckInterval: 60000\r\n  password: null\r\n  subscriptionsPerConnection: 5\r\n  clientName: null\r\n  loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}\r\n  subscriptionConnectionMinimumIdleSize: 1\r\n  subscriptionConnectionPoolSize: 50\r\n  slaveConnectionMinimumIdleSize: 24\r\n  slaveConnectionPoolSize: 64\r\n  masterConnectionMinimumIdleSize: 24\r\n  masterConnectionPoolSize: 64\r\n  readMode: \"SLAVE\"\r\n  subscriptionMode: \"SLAVE\"\r\n  slaveAddresses:\r\n  - \"redis://<SLAVE_ADDRESS>\"\r\n  masterAddress: \"redis://<MASTER_ADDRESS>\"\r\n  database: 0\r\nthreads: 16\r\nnettyThreads: 32\r\ncodec: !<org.redisson.codec.FstCodec> {}\r\ntransportMode: \"NIO\"\r\nuseScriptCache: false\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2020-01-23T06:21:11Z",
        "body": "> Master node is getting 'hget' command but i want only to use it as writer. \r\n\r\nI think it was listed as part of lua-script which executed on master due to presence of write operation."
      }
    ]
  },
  {
    "number": 2544,
    "title": "lock.isHeldByCurrentThread() verification  before unlocking Exception",
    "created_at": "2020-01-17T09:50:20Z",
    "closed_at": "2020-03-05T06:53:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2544",
    "body": " RLock \r\nlock.isHeldByCurrentThread() verification  before unlocking\r\nbut sometimes exception\r\n\r\norg.redisson.client.RedisException: Unexpected exception while processing command\r\n        at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:400)\r\n        at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:204)\r\n        at org.redisson.RedissonObject.get(RedissonObject.java:94)\r\n        at org.redisson.RedissonLock.isHeldByThread(RedissonLock.java:521)\r\n        at org.redisson.RedissonLock.isHeldByCurrentThread(RedissonLock.java:515)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2544/comments",
    "author": "hulvyou",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-01-17T09:51:48Z",
        "body": "could you provide full stacktrace?"
      },
      {
        "user": "hulvyou",
        "created_at": "2020-01-17T10:11:32Z",
        "body": " ```\r\npublic <V> V get(RFuture<V> future) {\r\n        if (!future.isDone()) {\r\n            CountDownLatch l = new CountDownLatch(1);\r\n            future.onComplete((res, e) -> {\r\n                l.countDown();\r\n            });\r\n\r\n            boolean interrupted = false;\r\n            while (!future.isDone()) {\r\n                try {\r\n                    l.await();\r\n                } catch (InterruptedException e) {\r\n                    interrupted = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (interrupted) {\r\n                Thread.currentThread().interrupt();\r\n            }\r\n        }\r\n\r\n        // commented out due to blocking issues up to 200 ms per minute for each thread\r\n        // future.awaitUninterruptibly();\r\n        if (future.isSuccess()) {\r\n            return future.getNow();\r\n        }\r\n\r\n        throw convertException(future);\r\n    }\r\n No more stacktrace，May be the log level is high\r\n You can tell me under what circumstances throw convertException(future) ？"
      },
      {
        "user": "mrniko",
        "created_at": "2020-01-21T08:00:06Z",
        "body": "> You can tell me under what circumstances throw convertException(future) ？\r\n\r\nWhen `future.isSuccess()` returns false value."
      }
    ]
  },
  {
    "number": 2542,
    "title": "Does the Redisson（BLPOP） support multily key？",
    "created_at": "2020-01-14T15:03:08Z",
    "closed_at": "2020-01-14T16:47:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2542",
    "body": "Does the Redisson（BLPOP） support multily key？ \r\nJust like BLPOP key [key …]，When multiple key parameters are given, check each list in order of parameter key, and the first non empty list header element will pop up",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2542/comments",
    "author": "longveeshaw",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-01-14T16:47:09Z",
        "body": "Yes it does, use `RBlockingQueue.pollFromAny` method"
      }
    ]
  },
  {
    "number": 2538,
    "title": "数据类型问题",
    "created_at": "2020-01-13T07:40:33Z",
    "closed_at": "2020-01-13T08:12:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2538",
    "body": "我用spring中的@cacheable时，从数据库中取出来准备序列化存到redis中的数据是Byte类型，但是再从redis中查出来返回的却是Integer，这个是需要修改redisson的数据序列化方式吗？我试了一下包装类Short、Byte都会变成Integer，Character会变成String，Float会变成Double。",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2538/comments",
    "author": "MarionSong",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-01-13T08:06:07Z",
        "body": "Which codec do you use?"
      },
      {
        "user": "MarionSong",
        "created_at": "2020-01-13T08:10:45Z",
        "body": "JsonJacksonCodec"
      },
      {
        "user": "mrniko",
        "created_at": "2020-01-13T08:12:31Z",
        "body": "Switch to FST, KryoCodec or SerializationCodec"
      },
      {
        "user": "MarionSong",
        "created_at": "2020-01-13T09:01:23Z",
        "body": "thank you ，I switch to SerializationCodec"
      }
    ]
  },
  {
    "number": 2532,
    "title": "关于redisson的watchdog重连机制",
    "created_at": "2020-01-09T09:03:59Z",
    "closed_at": "2020-01-10T08:44:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2532",
    "body": "最近将redisson版本升到了3.11.5，然后测试了一下redisson的重连机制，然后出现了一个奇怪的现象。在Linux上部署redis集群，然后在本地Windows上进行连接测试。如果使用在Linux上使用iptables切断连接，在连接恢复后不可用连接会重连；但如果在Windows上使用IP安全策略来切断连接，在连接恢复后，不可用连接没有重连。请问一下，这两种方式之间有什么不一样的地方吗？",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2532/comments",
    "author": "ShosinnFuYW",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-01-10T07:08:24Z",
        "body": "Did you try to set `setPingConnectionInterval` setting to handle such cases?"
      },
      {
        "user": "ShosinnFuYW",
        "created_at": "2020-01-10T08:44:37Z",
        "body": "> \r\n> \r\n> Did you try to set `setPingConnectionInterval` setting to handle such cases?\r\nThank you,it works fine!\r\n"
      }
    ]
  },
  {
    "number": 2527,
    "title": "How to build from source and package as single jar without all optional dependency?",
    "created_at": "2020-01-08T10:04:47Z",
    "closed_at": "2020-01-21T08:14:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2527",
    "body": "**Is your feature request related to a problem? Please describe.**\r\nRedission collection is used in my application (single jar) and want to package needed classes without all optional dependencies to reduce app size.\r\n\r\n**Describe the solution you'd like**\r\nSplit feature (optional dependencies are used) as sub module.\r\n**Describe alternatives you've considered**\r\nRemove all optional dependencies java classes from my jar (Follow dependency document in wiki). But I don't think it is right approach and whether have potential problems.  ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2527/comments",
    "author": "kitepad",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-01-08T13:40:50Z",
        "body": "there is redisson.jar already built from sources. Why can't you use it?"
      },
      {
        "user": "kitepad",
        "created_at": "2020-01-08T14:10:34Z",
        "body": "Do you mean redission-all.jar?  \r\nI don't use spring, hibernate and other additional features. And I want to package redission classes with all must have dependencies into single jar. When I trying build redission by maven shade plugin, I got a single jar file which includes all optional dependencies, for example javax.cache.*, org.jodd, net.bytebuddy, io.projectreactor,io.reactivex.rxjava2. I want to remove them to reduce file size. But I cann't do this through maven build."
      },
      {
        "user": "kitepad",
        "created_at": "2020-01-08T14:38:43Z",
        "body": "If I don't use liveobject service, how to remove them? I tried to remove theme from src tree, but I get compile error, some classes are used by others, such as RedissonObjectBuilder. Even I keep them, if we don't include org.jodd/net.bytebuddy, I cann't build successfully. Can I remove these dependencies without errors?"
      },
      {
        "user": "kitepad",
        "created_at": "2020-01-08T15:32:58Z",
        "body": "Finally, I want to to use redission distributed collections by sync way/async way. Reactive way/ Rx way will be removed and two ways dependencies will removed at same time. "
      },
      {
        "user": "mrniko",
        "created_at": "2020-01-21T08:14:47Z",
        "body": "> Can I remove these dependencies without errors?\r\n\r\nNo."
      }
    ]
  },
  {
    "number": 2524,
    "title": "Deserialization the object from redis to RList throws InvocationTargetException",
    "created_at": "2020-01-07T09:19:40Z",
    "closed_at": "2020-01-07T09:21:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2524",
    "body": "Deserialization the object from redis to RList throws InvocationTargetException\r\n\r\nredisson:3.12.0\r\nfst:2.56\r\n1.8.0_152\r\n\r\nstacktrace:\r\n\r\n`\r\nCaused by: java.lang.reflect.InvocationTargetException: null\r\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\r\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\r\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\r\n\tat org.redisson.command.RedisExecutor.getCodec(RedisExecutor.java:681)\r\n\t... 109 common frames omitted\r\nCaused by: java.lang.NoSuchMethodError: org.nustaq.serialization.FSTConfiguration.getJsonFieldNames()Lorg/nustaq/serialization/coders/FSTJsonFieldNames;\r\n\tat org.redisson.codec.FstCodec.copy(FstCodec.java:201)\r\n\tat org.redisson.codec.FstCodec.<init>(FstCodec.java:190)\r\n\t... 114 common frames omitted\r\n`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2524/comments",
    "author": "fengzhenxing",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-01-07T09:21:26Z",
        "body": "`java.lang.NoSuchMethodError: org.nustaq.serialization.FSTConfiguration.getJsonFieldNames`\r\n\r\nmake sure you have latest version of fst codec in classpath"
      },
      {
        "user": "fengzhenxing",
        "created_at": "2020-01-07T09:26:47Z",
        "body": "@mrniko yes. The lastest fst codec version is 2.57.Thanks"
      },
      {
        "user": "mrniko",
        "created_at": "2020-01-07T09:28:20Z",
        "body": "Unable to reproduce it."
      },
      {
        "user": "fengzhenxing",
        "created_at": "2020-01-07T09:29:40Z",
        "body": "@mrniko I add the lastest fst codec version,then throws NPE.\r\n\r\nstacktrace:\r\n\r\n`\r\njava.io.IOException: java.lang.NullPointerException\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247)\r\n\tat org.redisson.codec.FstCodec$1.decode(FstCodec.java:250)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:368)\r\n\tat org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:196)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134)\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:493)\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:271)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.lang.NullPointerException: null\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:357)\r\n\tat org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331)\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311)\r\n\tat org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245)\r\n\t... 24 common frames omitted\r\n`"
      },
      {
        "user": "mrniko",
        "created_at": "2020-01-07T09:30:35Z",
        "body": "is there code example to reproduce it?"
      },
      {
        "user": "fengzhenxing",
        "created_at": "2020-01-07T09:35:01Z",
        "body": "Here is some example code:\r\n\r\n`\r\nRList<ExampleObject> serviceUserList = redisson.getList(key);\r\n`\r\nif I add  new properties in ExampleObject,then throws NPE. The properties of exampleObject stored in redis is not equals"
      },
      {
        "user": "mrniko",
        "created_at": "2020-01-07T09:36:56Z",
        "body": "> if I add new properties in ExampleObject,then throws NPE. The properties of exampleObject stored in redis is not equals\r\n\r\nConsider to use JacksonCodec for this purpose."
      },
      {
        "user": "fengzhenxing",
        "created_at": "2020-01-07T09:38:19Z",
        "body": "yes,I replace the type of codec so it works.\r\n\r\n"
      }
    ]
  },
  {
    "number": 2523,
    "title": "Deserialization the object from redis to RList throws InvocationTargetException",
    "created_at": "2020-01-07T09:19:40Z",
    "closed_at": "2020-02-11T11:26:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2523",
    "body": "Deserialization the object from redis to RList throws InvocationTargetException",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2523/comments",
    "author": "fengzhenxing",
    "comments": [
      {
        "user": "jackygurui",
        "created_at": "2020-01-21T11:34:39Z",
        "body": "Can you show some code as well as the full exceptions please?"
      }
    ]
  },
  {
    "number": 2520,
    "title": "How can i merge redisson.yml and spring-application.yml",
    "created_at": "2020-01-06T08:59:07Z",
    "closed_at": "2020-01-21T08:21:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2520",
    "body": "Hi, i just want to change the codec from `org.redisson.codec.FstCodec` to `org.redisson.codec.JsonJacksonCodec`,so i write the `redisson.yml`:\r\n```yaml\r\ncodec: !<org.redisson.codec.JsonJacksonCodec> {}\r\n```\r\nbut when i run the application, it calls exception:\r\n```\r\nCaused by: java.lang.IllegalArgumentException: server(s) address(es) not defined!\r\n...\r\n```\r\n\r\nmy `spring-application.yml` is\r\n```yaml\r\nspring:\r\n  redis:\r\n    database: 0\r\n    port: 6379\r\n    host: 127.0.0.1\r\n    redisson:\r\n      config: 'classpath:/redisson.yml'\r\n```\r\n\r\nin `org.redisson.spring.starter.RedissonAutoConfiguration#redisson`,i find code\r\n```java\r\nif (redissonProperties.getConfig() != null) {\r\n\t// read config from redisson.yml\r\n\t...\r\n} else if (redisProperties.getSentinel() != null) {\r\n\t// read config from spring-application.yml\r\n\t...\r\n} else if (clusterMethod != null && ReflectionUtils.invokeMethod(clusterMethod, redisProperties) != null) {\r\n\t// read config from redisProperties using cluster server\r\n\t...\r\n} else {\r\n\t// read config from redisProperties using single server\r\n\t...\r\n}\r\n```\r\n\r\nso, i must write server config in `redisson.yml` again.\r\n\r\n```yml\r\nsingleServerConfig:\r\n  address: 'redis://127.0.0.1:6379'\r\n  database: 0\r\ncodec: !<org.redisson.codec.JsonJacksonCodec> {}\r\n```\r\n\r\nIs there anyway to merge  `redisson.yml` and ` spring-application.yml`?\r\n\r\nredisson version is:\r\n```gradle\r\nredissonVersion = '3.11.6'\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2520/comments",
    "author": "gcdd1993",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-01-21T08:21:21Z",
        "body": "> Is there anyway to merge redisson.yml and spring-application.yml?\r\n\r\nNo"
      }
    ]
  },
  {
    "number": 2516,
    "title": "With spring boot application redisson by default connect to local host even after providing configuration",
    "created_at": "2020-01-04T06:46:05Z",
    "closed_at": "2020-01-07T06:45:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2516",
    "body": "\r\n I am creating tiny redis cache library for all running java based microservices using redisson. This library will be used by all spring boot and and non spring boot microservices.\r\n \r\nI am using below maven dependency for redission:\r\n   ```\r\n<dependency>\r\n\t\t   <groupId>org.redisson</groupId>\r\n\t\t   <artifactId>redisson</artifactId>\r\n\t\t   <version>3.12.0</version>\r\n\t</dependency>\r\n```\r\n   \r\n\r\nAnd using below implementation for redisson bean creation\r\n\r\n```\r\n@Configuration\r\npublic class RedissionClient {\r\n\r\n\t@Bean\r\n\tpublic RedissonClient init(@Value(\"${redishostname}\") String host, @Value(\"${redisport}\") String port) {\r\n\t\tConfig config = new Config();\r\n\t\tString url = \"redis://\"+ host + \":\" + port;\r\n        config.useSingleServer().setAddress(url);\r\n        return Redisson.create(config);\r\n\t}\r\n}\r\n```\r\n\r\n Above configuration works well when I use this library with non spring boot based application. \r\n \r\nBut it fails with spring boot based application. I saw that redissonClient try to connect to local redis instance instead of configuration provided by me in application.properties.\r\n It works when I used below configration in application.properties\r\n\t_spring.redis.host=${redis_host:172.28.221.76}\r\n\tspring.redis.port=${redis_port:6379}_\r\n\t\r\nBut being a common library I can not use above configuration for non spring boot based application.\r\n\r\n Is there a way where I can force redissonClient to be created with custom configuration instead of default configuration ?\r\n ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2516/comments",
    "author": "manojbsw",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-01-04T06:49:53Z",
        "body": "Did you try to define `spring.redis.redisson.config` setting instead? Path to config.yaml file"
      },
      {
        "user": "manojbsw",
        "created_at": "2020-01-04T09:43:06Z",
        "body": "I tried but no success. Being a common library I don't want to use spring boot specific properties here.  All the required configuration of redis instance will be available as env. variable. So I am expecting redissonClient should be created as below. \r\n\r\n```\r\n@Bean\r\n\tpublic RedissonClient init(@Value(\"${redishostname}\") String host, @Value(\"${redisport}\") String port) {\r\n\t\tConfig config = new Config();\r\n\t\tString url = \"redis://\"+ host + \":\" + port;\r\n        config.useSingleServer().setAddress(url);\r\n        return Redisson.create(config);\r\n\t}\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2020-01-04T09:57:18Z",
        "body": "add `@AutoConfigureBefore(RedissonAutoConfiguration.class) ` annotation to your configuration"
      }
    ]
  },
  {
    "number": 2514,
    "title": "要多次用到RMap时可以直接用还是每次都需要通过redissonClient获取？",
    "created_at": "2020-01-03T09:43:58Z",
    "closed_at": "2020-01-16T16:34:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2514",
    "body": "有一个工具类可能多条线程都要同时调用的，大概这么写的\r\n\r\n```java\r\nprivate static RedissonClient client;\r\n\r\n@Autowired\r\npublic 构造方法(RedissonClient redissonClient){\r\nclient=redissonClient;\r\n}\r\n\r\npublic static put(String key,String value){\r\n    client.getMap(\"固定的name\").put(key,value);\r\n}\r\n```\r\n\r\n而我看里面每一次getMap都是一次new RedissonMap()。\r\n由于name固定的，那我能不能将静态redissonClient直接换成静态RMap，就不用每次调用时都实例化一次RedissonMap：\r\n```java\r\n//private static RedissonClient client;\r\nprivate static RMap<String,String> map;\r\n\r\n@Autowired\r\npublic 构造方法(RedissonClient redissonClient){\r\n    //client=redissonClient;\r\n    map=redissonClient.getMap(\"固定的name\");\r\n}\r\n\r\npublic static put(String key,String value){\r\n    //client.getMap(\"固定的name\").put(key,value);\r\n    map.put(key,value);\r\n}\r\n```\r\n\r\n这样修改的话有没有问题，效率上会变快吗，有没有线程安全之类的问题可能会出现？",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2514/comments",
    "author": "arkfancy",
    "comments": [
      {
        "user": "xiaoyifang",
        "created_at": "2020-01-16T14:49:03Z",
        "body": "相比多线程，分布式会有问题，考虑程序同时运行多个副本的情况，比如运行在多台机器。"
      },
      {
        "user": "jackygurui",
        "created_at": "2020-01-16T16:34:34Z",
        "body": "`RedissonClient`和`RMap`都是线程安全的，可以被多个线程同时使用。"
      }
    ]
  },
  {
    "number": 2513,
    "title": "并发使用lock.lock出错",
    "created_at": "2020-01-03T06:19:24Z",
    "closed_at": "2020-01-03T06:41:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2513",
    "body": "org.redisson.client.RedisException,ERR Error running script (call to f_762bfafa6be221431a0b668685dd15c926483619): @user_script:1: user_script:1: attempt to compare nil with number . channel: [id: 0xc180c731, L:/172.31.0.110:52122 - R:xx-api.tflohd.0001.cnn1.cache.amazonaws.com.cn/172.31.25.58:6379] command: (EVAL), params: [while true do local firstThreadId2 = redis.call('lindex', KEYS[2], 0);if firstThreadId2 == false the..., 3, lock:charge:pre:5de9b5bd1b92990740f5114d, redisson_lock_queue:{lock:charge:pre:5de9b5bd1b92990740f5114d}, redisson_lock_timeout:{lock:charge:pre:5de9b5bd1b92990740f5114d}, 500, 371bc7b9-7504-4614-a4e5-747c37fb9580:14401, 5000, 1578030638778]",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2513/comments",
    "author": "wudongqiang",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-01-03T06:41:35Z",
        "body": "check that you don't share same name across different objects."
      },
      {
        "user": "wudongqiang",
        "created_at": "2020-01-03T08:27:36Z",
        "body": "一开始没有什么问题,  并发运行一段时间后,才出现的这个错"
      },
      {
        "user": "xiaxingit",
        "created_at": "2020-12-30T07:56:56Z",
        "body": "@wudongqiang 请问解决了吗？目前我遇到同样的问题"
      }
    ]
  },
  {
    "number": 2510,
    "title": "请问如何动态切换服务器地址",
    "created_at": "2020-01-02T09:45:17Z",
    "closed_at": "2020-01-03T06:40:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2510",
    "body": "```\r\n@Value(\"${spring.redis.addresses}\")\r\nprivate String addresses;\r\n\r\n@Bean\r\npublic RedissonClient redissonClient() {\r\n            Config config = new Config();\r\n            String[] addressList = addresses.split(\",\");\r\n            config.useClusterServers().addNodeAddress(addressList);\r\n            return Redisson.create(config);\r\n}\r\n```\r\n\r\naddresses地址发生变化,redisson如何感知到?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2510/comments",
    "author": "laomolaomo",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-01-03T06:40:51Z",
        "body": "This feature is not supported. Redisson config is immutable."
      },
      {
        "user": "laomolaomo",
        "created_at": "2020-01-03T07:19:56Z",
        "body": "thank you very much"
      }
    ]
  },
  {
    "number": 2495,
    "title": "为什么RedissonMapCache  清理缓存的定时任务，采用这种策略？",
    "created_at": "2019-12-23T01:21:10Z",
    "closed_at": "2020-01-21T08:21:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2495",
    "body": "最近使用RedissonSpringCacheManager，缓存清理延迟，看wiki有了说明，但是不明白为什么一次最多清理100条，而且时间有递增，这是出于什么考虑呢？望解惑！",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2495/comments",
    "author": "KinaZhen",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2019-12-23T06:00:17Z",
        "body": "You can control delay between cleanup actions with `minCleanUpDelay` and `maxCleanUpDelay` settings"
      },
      {
        "user": "KinaZhen",
        "created_at": "2019-12-23T06:12:40Z",
        "body": "> You can control delay between cleanup actions with `minCleanUpDelay` and `maxCleanUpDelay` settings\r\n\r\n我是想问为什么这么设计呢，是出于性能考虑呢，还是为减少redis请求？比如说一直维持5秒一次，而不去采用这种策略会有什么影响？"
      },
      {
        "user": "mrniko",
        "created_at": "2019-12-23T06:26:01Z",
        "body": "These settings are common. They need to be tuned depending on use case."
      }
    ]
  },
  {
    "number": 2490,
    "title": "MapReduce 执行没有反应，卡主不动也不报错！",
    "created_at": "2019-12-19T06:37:25Z",
    "closed_at": "2019-12-26T12:26:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2490",
    "body": "redisson 版本：2.15.2\r\njdk: 1.7\r\nredis: 3.0.504\r\n执行环境就是在main函数里面测试了一下。不是分布式环境\r\n```\r\nConfig config = new Config();\r\n\t\tconfig.useSentinelServers()\r\n\t\t    .setMasterName(\"redis-master\")\r\n\t\t    .addSentinelAddress(\"redis://127.0.0.1:27000\",\"redis://127.0.0.1:27001\",\"redis://127.0.0.1:27002\");\r\n\t\tRedissonClient redissonClient = Redisson.create(config);\r\n\t\tRSet<String> set = redissonClient.getSet(\"test_reduce\");\r\n\t    set.add(\"gdxxw_123\");\r\n\t    set.add(\"gdxxw_1234\");\r\n\t    set.add(\"gdxxw_1235\");\r\n\t    set.add(\"guizhou_123\");\r\n\t    set.add(\"guizhou_124\");\r\n\r\n\t    RCollectionMapReduce<String, String, Integer> mapReduce\r\n        = set.<String, Integer>mapReduce()\r\n              .mapper(new OnlineSiteRCollectionMapper())\r\n            .reducer(new OnlineSiteRReducer());\r\n\r\n\t\t\r\n\t\tMap<String, Integer> mapToNumber = mapReduce.execute();\r\n\t\tSystem.out.println(mapToNumber.toString());\r\n```\r\n```\r\npublic class OnlineSiteRCollectionMapper implements\r\n\t\tRCollectionMapper<String, String, Integer> {\r\n\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate static final long serialVersionUID = 1L;\r\n\r\n\t@Override\r\n\tpublic void map(String value, RCollector<String, Integer> collector) {\r\n\t\tif(value!=null){\r\n\t\t\tString[] s = value.split(\"_\");\r\n\t\t\tcollector.emit(s[0], 1);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n```\r\n```\r\npublic class OnlineSiteRReducer implements RReducer<String, Integer> {\r\n\tprivate static final long serialVersionUID = 1L;\r\n\t@Override\r\n\tpublic Integer reduce(String reducedKey, Iterator<Integer> iter) {\r\n\t\tSystem.out.println(reducedKey);\r\n\t\tint sum=0;\r\n\t\twhile(iter.hasNext()){\r\n\t\t\tsum++;\r\n\t\t}\r\n\t\treturn sum;\r\n\t}\r\n}\r\n```\r\n卡在mapReduce.execute();那没有任何反应，阻塞在那里也不报错！",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2490/comments",
    "author": "swit1983",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2019-12-26T12:26:25Z",
        "body": "You need to define timeout:\r\n\r\n```java\r\n\t    RCollectionMapReduce<String, String, Integer> mapReduce\r\n        = set.<String, Integer>mapReduce()\r\n              .mapper(new OnlineSiteRCollectionMapper())\r\n            .reducer(new OnlineSiteRReducer())\r\n                .timeout(30, TimeUnit.SECONDS);\r\n```\r\n\r\nThe issue is in OnlineSiteRReducer. It doesn't invoke `iter.next()` method, so while block is in infinity loop."
      }
    ]
  },
  {
    "number": 2488,
    "title": "java.lang.ClassNotFoundException: org.springframework.data.redis.connection.RedisStreamCommands ",
    "created_at": "2019-12-18T02:04:35Z",
    "closed_at": "2019-12-18T07:28:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2488",
    "body": "Hello \r\n         I just submitted two questions that didn't work. The reason is that I pressed the wrong key(ctrl + enter on windows). I'm sorry to be embarrassed. My problem is that I use springboot version 2.1.11.RELEASE and the redisson-spring-boot-starter version is 3.11.  .6, the error is the same as the title. I checked issue 2478 and suggested that he downgrade to redisson-spring-data-21. If it is redisson-spring-boot-starter, what version should he downgrade to?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2488/comments",
    "author": "LayJustDoIt",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2019-12-18T07:27:57Z",
        "body": "You need to downgrade to redisson-spring-data-21 only"
      },
      {
        "user": "LayJustDoIt",
        "created_at": "2019-12-19T11:30:55Z",
        "body": "> You need to downgrade to redisson-spring-data-21 only\r\n\r\nYes, I tried to downgrade to this version and the program runs normally, thank you for your suggestions"
      }
    ]
  },
  {
    "number": 2478,
    "title": "upgrade 3.11.6",
    "created_at": "2019-12-16T03:14:48Z",
    "closed_at": "2019-12-16T06:55:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2478",
    "body": "springboot version 2.1.11.RELEASE,upgrdate 3.11.5to 3.11.6,error\r\njava.lang.NoClassDefFoundError: org/springframework/data/redis/connection/RedisStreamCommands\r\n3.11.6 Can it only support springboot verison 2.2",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2478/comments",
    "author": "sjk009",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2019-12-16T06:55:11Z",
        "body": "you need to downgrade to `redisson-spring-data-21` dependency"
      }
    ]
  },
  {
    "number": 2474,
    "title": "tomcat7.0.56启动报错",
    "created_at": "2019-12-13T04:02:35Z",
    "closed_at": "2019-12-13T06:17:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2474",
    "body": "redisson version: 2.15.2\r\njdk:1.7\r\n严重: Unable to process Jar entry [META-INF/versions/9/module-info.class] from Jar [jar:file:/F:/server/apache-tomcat-7.0.56/webapps/edu-gateway/WEB-INF/lib/byte-buddy-1.9.6.jar!/] for annotations\r\norg.apache.tomcat.util.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 19\r\n\tat org.apache.tomcat.util.bcel.classfile.Constant.readConstant(Constant.java:97)\r\n\tat org.apache.tomcat.util.bcel.classfile.ConstantPool.<init>(ConstantPool.java:55)\r\n\tat org.apache.tomcat.util.bcel.classfile.ClassParser.readConstantPool(ClassParser.java:175)\r\n\tat org.apache.tomcat.util.bcel.classfile.ClassParser.parse(ClassParser.java:83)\r\n\tat org.apache.catalina.startup.ContextConfig.processAnnotationsStream(ContextConfig.java:2071)\r\n\tat org.apache.catalina.startup.ContextConfig.processAnnotationsJar(ContextConfig.java:1947)\r\n\tat org.apache.catalina.startup.ContextConfig.processAnnotationsUrl(ContextConfig.java:1913)\r\n\tat org.apache.catalina.startup.ContextConfig.processAnnotations(ContextConfig.java:1898)\r\n\tat org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1330)\r\n\tat org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:889)\r\n\tat org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:386)\r\n\tat org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:117)\r\n\tat org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90)\r\n\tat org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5380)\r\n\tat org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\r\n\tat org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1575)\r\n\tat org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1565)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\n3.x版本是不是最低要求java8 ？",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2474/comments",
    "author": "swit1983",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2019-12-13T06:17:29Z",
        "body": "Change byte-buddy version to 1.8.17"
      }
    ]
  },
  {
    "number": 2470,
    "title": "Multiple tomcat instance behind a load balancer",
    "created_at": "2019-12-11T13:14:25Z",
    "closed_at": "2020-02-13T12:28:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2470",
    "body": "Redisson version: \r\n\r\nredisson-tomcat-8-3.11.6.jar\r\nredisson-all-3.11.6.jar\r\n\r\nHi, We are trying to host the application in 2 tomcat instance hosted behind a application gateway(load balancer in AWS). In both tomcat instance we have configured redisson session manager with required jars in tomcat/lib. \r\n\r\nBelow is the context xml entry:\r\n\r\n<Manager className=\"org.redisson.tomcat.RedissonSessionManager\" configPath=\"${catalina.base}/redisson.yaml\" readMode=\"MEMORY\" updateMode=\"AFTER_REQUEST\" broadcastSessionEvents=\"true\"/>\r\n\r\nScenario:\r\n\r\n1) Bring up instance 1 and login to app, go to a screen and do some changes and don't save yet. This ensures we have logged in to instance 1.\r\n\r\n2) Bring up instance 2 now. Bring down the instance 1. Try to do save on the application now and app throws below error.\r\n\r\n[redisson-netty-5-14] ERROR org.redisson.client.handler.CommandDecoder - Unable to decode data. channel: [id: 0x621c0852, L:/172.31.4.234:47394 - R:172.31.5.89/172.31.5.89:6379], reply: ReplayingDecoderByteBuf(ridx=138706, widx=138838), command: (HGETALL), params: [redisson:tomcat_session:24BFE948F528FB8C7035901297D535D2]\r\njava.io.IOException: java.lang.NullPointerException\r\n        at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247)\r\n        at org.redisson.codec.FstCodec$1.decode(FstCodec.java:250)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:378)\r\n        at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:422)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:387)\r\n        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:209)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:147)\r\n        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:503)\r\n        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:281)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1422)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)\r\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:931)\r\n        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:700)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:635)\r\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:552)\r\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:514)\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1050)\r\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n        at java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.lang.NullPointerException\r\n        at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:357)\r\n        at org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:713)\r\n        at org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:566)\r\n        at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374)\r\n        at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331)\r\n        at org.nustaq.serialization.serializers.FSTMapSerializer.instantiate(FSTMapSerializer.java:78)\r\n        at org.nustaq.serialization.FSTObjectInput.instantiateAndReadWithSer(FSTObjectInput.java:501)\r\n        at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:370)\r\n        at org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:713)\r\n        at org.nustaq.serialization.FSTObjectInput.readObjectCompatibleRecursive(FSTObjectInput.java:635)\r\n         at org.nustaq.serialization.FSTObjectInput.readObjectCompatible(FSTObjectInput.java:574)\r\n        at org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:559)\r\n        at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374)\r\n        at org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:713)\r\n        at org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:566)\r\n        at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374)\r\n        at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331)\r\n        at org.nustaq.serialization.FST\r\n\r\nObjectInput.readObject(FSTObjectInput.java:311)\r\n        at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245)\r\n        ... 26 more\r\n\r\n\r\nBasically we are trying to aim for zero downtime with these 2 instances, so that if one instance goes down, other instance should be able to pick up the application state and continue the execution without user needing to re-login.\r\n\r\nPlease help us with the above error.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2470/comments",
    "author": "seenu5788",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2019-12-11T14:58:07Z",
        "body": "try to use `org.redisson.codec.SerializationCodec`"
      }
    ]
  },
  {
    "number": 2468,
    "title": "java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id when sleep and Aspect",
    "created_at": "2019-12-11T00:32:37Z",
    "closed_at": "2019-12-11T05:58:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2468",
    "body": "I am a beginner of Redission.\r\n**this error happens in 3.11.6.\r\nThis is situation1:**\r\n> Due to my poor english. Here is the Chinese explain: 我尝试在业务代码中执行sleep，但是，只要有sleep，等待业务代码执行完毕之后，redission解锁就会报解锁失败，不是当前线程的锁的错误：\r\n```\r\n\r\n    public static void main(String[] args) {\r\n        Config config = new Config();\r\n        SingleServerConfig singleServerConfig = config.useSingleServer();\r\n        singleServerConfig.setAddress(\"redis://10.16.1.150:6379\");\r\n        singleServerConfig.setDatabase(0);\r\n        singleServerConfig.setConnectionMinimumIdleSize(20);\r\n\r\n        System.out.println(\"lock\");\r\n        final RedissonClient redissonClient = Redisson.create(config);\r\n        final RLock lock = redissonClient.getLock(\"lock\");\r\n        lock.lock(10,TimeUnit.SECONDS);\r\n        try{\r\n            try {\r\n                Thread.sleep(10000);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }finally {\r\n            System.out.println(\"unlock\");\r\n            lock.unlock();\r\n        }\r\n    }\r\n```\r\nEverytime I **Sleep** in the middle of the **Lock**  And I got the error:\r\n```\r\njava.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: ...\r\n```\r\n\r\n\r\n\r\n\r\n\r\n----\r\n**And below the situation2:**\r\nI write a **timmer** use **Aspect**\r\n> Due to my poor english. Here is the Chinese explain: 这里的情况是：当我在业务代码里面的方法，添加了切面，那么，等待业务代码执行完毕之后，redission解锁就会报解锁失败，不是当前线程的锁的错误：\r\n```\r\npackage com.tg.lottery.annotation;\r\n\r\nimport org.aspectj.lang.JoinPoint;\r\nimport org.aspectj.lang.annotation.After;\r\nimport org.aspectj.lang.annotation.Aspect;\r\nimport org.aspectj.lang.annotation.Before;\r\nimport org.aspectj.lang.annotation.Pointcut;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.stereotype.Component;\r\n\r\n/**\r\n * timmer\r\n *\r\n */\r\n@Aspect\r\n@Component\r\npublic class UseTimeRecordAspect {\r\n    \r\n    private static final Logger logger = LoggerFactory.getLogger(UseTimeRecordAspect.class);\r\n    ThreadLocal<Long> useTime = new ThreadLocal<>();\r\n    \r\n    @Pointcut(\"@annotation(useTimeRecord)\")\r\n    public void calTime(UseTimeRecord useTimeRecord) {\r\n    }\r\n    \r\n    @Before(\"calTime(useTimeRecord)\")\r\n    public void before(JoinPoint joinPoint, UseTimeRecord useTimeRecord) {\r\n        useTime.set(System.currentTimeMillis());\r\n        logger.info(useTimeRecord.name() + \" timmer start\");\r\n    }\r\n    \r\n    @After(\"calTime(useTimeRecord)\")\r\n    public void after(JoinPoint joinPoint, UseTimeRecord useTimeRecord) {\r\n        float second = (System.currentTimeMillis() - useTime.get()) * 1.0F / 1000;\r\n        logger.info(useTimeRecord.name() + \"  all time \" + second + \" second\");\r\n    }\r\n    \r\n}\r\n\r\n```\r\n\r\nBelow the lock process\r\n\r\n```\r\npublic void processWithLock(Lottery lottery) throws LotteryException {\r\n        RLock redissonLock = redisson.getLock(lottery.getId());\r\n        redissonLock.lock(5, TimeUnit.SECONDS);\r\n        try{\r\n            dosomething();\r\n        } finally {\r\n            redissonLock.unlock();\r\n        }\r\n    }\r\n\r\n@UseTimeRecord(name = \"dosomethingTimmer\")\r\npublic void dosomething(){\r\n  .....\r\n}\r\n```\r\nEverytime I **use the Aspect** in the middle of the **Lock**  And I got the error:\r\n```\r\njava.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: ...\r\n```\r\nThanks !!!!\r\n> 先多谢各位大佬!小弟抓破脑袋都想不到是为什么\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2468/comments",
    "author": "shihua-guo",
    "comments": [
      {
        "user": "yinjihuan",
        "created_at": "2019-12-11T04:05:56Z",
        "body": "Has it been solved"
      },
      {
        "user": "mrniko",
        "created_at": "2019-12-11T05:58:33Z",
        "body": "You defined 10 seconds as lease parameter. Increase this value or decrease sleep timeout."
      },
      {
        "user": "shihua-guo",
        "created_at": "2019-12-11T14:02:59Z",
        "body": "> Has it been solved\r\n\r\n不知道呀。我不知道啥回事。上面的不明白上面哥们说啥。"
      }
    ]
  },
  {
    "number": 2467,
    "title": "java.io.IOException: 连接超时",
    "created_at": "2019-12-10T11:36:39Z",
    "closed_at": "2019-12-23T11:34:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2467",
    "body": "单节点，参数都是默认参数，偶尔会出现这个异常\r\n\r\njava.io.IOException: 连接超时\r\n\tat sun.nio.ch.FileDispatcherImpl.read0(Native Method)\r\n\tat sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:39)\r\n\tat sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)\r\n\tat sun.nio.ch.IOUtil.read(IOUtil.java:192)\r\n\tat sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:379)\r\n\tat io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)\r\n\tat io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1106)\r\n\tat io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:373)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)\r\n\tat io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)\r\n\tat java.lang.Thread.run(Thread.java:745)",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2467/comments",
    "author": "zpczpczpc",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2019-12-23T11:34:29Z",
        "body": "Check your network"
      }
    ]
  },
  {
    "number": 2447,
    "title": "select database  ",
    "created_at": "2019-12-03T02:17:34Z",
    "closed_at": "2020-01-15T08:07:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2447",
    "body": "    Config config = new Config();        \r\n    config.useSingleServer().\r\n                setAddress(\"redis://\").\r\n                setPassword();\r\n    config.useSingleServer().setDatabase(0).   \r\n\t\t..........\r\n\r\n\r\n   RedissonClient redissonClient2 = Redisson.create(config);\r\n\r\n\r\n.....................\r\n\r\n\r\n\r\n    RBucket<String> test = redissonClient2.getBucket(\"test\");\r\n    test.set(\"testv\",60, TimeUnit.SECONDS);\r\n    System.out.println(test.get());//testv\r\n      \r\n\r\n    RBucket<String> test2 = this.redissonClient.getBucket(\"test2\");\r\n        test2.set(\"test2v\",160, TimeUnit.SECONDS);\r\n        test2.move(9);\r\n\r\n        System.out.println(test2.get());//null\r\n\r\n我如何获取test2的value",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2447/comments",
    "author": "vagrantBottle",
    "comments": [
      {
        "user": "vagrantBottle",
        "created_at": "2019-12-03T02:20:36Z",
        "body": "test这个key是要放在0库,test2这个key 放在9库,单机版 "
      },
      {
        "user": "mrniko",
        "created_at": "2020-01-15T08:07:49Z",
        "body": "Since you set database = 0 in Redisson config it can't be used to read data from any other database."
      }
    ]
  },
  {
    "number": 2443,
    "title": "setIdleConnectionTimeout参数不生效",
    "created_at": "2019-11-30T03:55:07Z",
    "closed_at": "2020-01-15T08:14:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2443",
    "body": "redisson json配置\r\n{\r\n  \"masterSlaveServersConfig\":{\r\n    \"idleConnectionTimeout\":10,\r\n    \"connectTimeout\":10000,\r\n    \"timeout\":10000,\r\n    \"retryAttempts\":3,\r\n    \"retryInterval\":1500,\r\n    \"failedSlaveReconnectionInterval\":3000,\r\n    \"failedSlaveCheckInterval\":60000,\r\n    \"password\":null,\r\n    \"subscriptionsPerConnection\":5,\r\n    \"clientName\":null,\r\n    \"loadBalancer\":{\r\n      \"class\":\"org.redisson.connection.balancer.RoundRobinLoadBalancer\"\r\n    },\r\n    \"subscriptionConnectionMinimumIdleSize\":1,\r\n    \"subscriptionConnectionPoolSize\":1,\r\n    \"slaveConnectionMinimumIdleSize\":10,\r\n    \"slaveConnectionPoolSize\":15,\r\n    \"masterConnectionMinimumIdleSize\":10,\r\n    \"masterConnectionPoolSize\":15,\r\n    \"readMode\":\"SLAVE\",\r\n    \"subscriptionMode\":\"SLAVE\",\r\n    \"database\":0,\r\n    \"keepAlive\": false\r\n  },\r\n  \"threads\":16,\r\n  \"nettyThreads\":32,\r\n  \"codec\":{\r\n    \"class\":\"org.redisson.codec.FstCodec\"\r\n  },\r\n  \"transportMode\":\"NIO\"\r\n}\r\n\r\n\r\n public RedissonCluster(List<RedisPair> redises) {\r\n        this.redises = redises;\r\n        redisClients = new ArrayList<>(redises.size());\r\n        redises.forEach(redisPair -> {\r\n            try {\r\n                System.out.println(\"start\");\r\n                Config config = Config.fromJSON(new File(\"redisson.json\"));\r\n                config.useMasterSlaveServers().setIdleConnectionTimeout(1000);\r\n                config.setAddressResolverGroupFactory(new DnsAddressResolverGroupFactory());\r\n                config.useMasterSlaveServers().setMasterAddress(redisPair.master).addSlaveAddress(redisPair.slave);\r\n                config.setCodec(StringCodec.INSTANCE);\r\n                RedissonClient redisClient = Redisson.create(config);\r\n                redisClients.add(redisClient);\r\n          } catch (Exception e) {\r\n                System.out.println(e);\r\n            }\r\n\r\n        });\r\n        batchOptions = BatchOptions.defaults().executionMode(ExecutionMode.IN_MEMORY)\r\n                .responseTimeout(10, TimeUnit.SECONDS).retryInterval(10, TimeUnit.SECONDS).retryAttempts(2);\r\n\r\n\r\n    }\r\n\r\n现象是不断的DNS检测，重新进行初始化，之前建立的连接并没有释放掉，导致redis连接数过多，引起崩溃",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2443/comments",
    "author": "weifei7544",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-01-15T08:14:01Z",
        "body": "You should invoke `config.useMasterSlaveServers()` only once.\r\n```java\r\nconfig.useMasterSlaveServers().setMasterAddress(redisPair.master).addSlaveAddress(redisPair.slave).setIdleConnectionTimeout(1000);\r\n```"
      }
    ]
  },
  {
    "number": 1860,
    "title": "Why does RMapCache is designed to use Hash instead of simple key-value structure?",
    "created_at": "2019-01-16T02:58:44Z",
    "closed_at": "2019-01-17T11:58:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/1860",
    "body": "\r\nI am curious why RMapCache is designed to use Hash instead of simple key-value structure? Simple key-value can use TTL while Hash cannot. What benefit does RMapCache get when using Hash compared with using key-value?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/1860/comments",
    "author": "a2232189",
    "comments": [
      {
        "user": "jackygurui",
        "created_at": "2019-01-16T22:32:35Z",
        "body": "`Simple key-value can use TTL while Hash cannot.` I think you have just answered your own question here. \r\n\r\nThere are use cases where string structure would be more suitable than hash and vice versa, RMapCache is here to bridge the gap between them. "
      },
      {
        "user": "a2232189",
        "created_at": "2019-01-17T02:36:11Z",
        "body": "Some want to save the data in redis with TTL and some want to save the data in redis forever, so you choose to use a never-out-ouf-date strcture `HASH` to save all data, and run a schedule task to delete those data that are set with TTL. Am my understand right?\r\n\r\nIf my conclusion above is right, I think that you choose to use `hash` instead of simple key-value is because the maintainability. Since it's easier to maintain the code if the data structure is only `hash`, compared with the thought that when user choose to save data with TTL, Redisson use `simple key-value` and when ser choose to save data forever (without TTL), Redisson use `Hash`."
      },
      {
        "user": "a2232189",
        "created_at": "2019-01-17T02:44:40Z",
        "body": "> I think that you choose to use `hash` instead of simple key-value is because the maintainability. Since it's easier to maintain the code if the data structure is only `hash`, compared with the thought that when user choose to save data with TTL, Redisson use `simple key-value` and when ser choose to save data forever (without TTL), Redisson use `Hash`.\r\n\r\nAm my conclusion right here?"
      },
      {
        "user": "jackygurui",
        "created_at": "2019-01-17T11:27:21Z",
        "body": "Redisson doesn't choose data types between string and hash on user's behalf. If the user wants to use string, he/she can use RBucket, if he/she wants to use hash, then there is RMap for the job. Other map objects Redisson offers are complementary to provide extra functionalities that vanila hash doesn't do. \r\n\r\nUsers decide which data type they need, Redisson provides every possibilities for them. I hope I have answered your question."
      },
      {
        "user": "a2232189",
        "created_at": "2019-01-17T11:58:34Z",
        "body": "Didn't know `RBucket`  before. thanks."
      }
    ]
  },
  {
    "number": 1706,
    "title": "What is the best practice for setting local caches ttl against Redis caches?",
    "created_at": "2018-10-30T07:35:33Z",
    "closed_at": "2018-10-31T12:15:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/1706",
    "body": "Is it correct if Redis cache ttl is the same as timeToLiveInMillis for local cache?\r\n\r\nMY_CACHE: \r\n ttl: 300000\r\n maxIdleTime: 300000\r\n maxSize: 1000\r\n \r\n localCacheOptions:\r\n    evictionPolicy: \"LRU\"\r\n    reconnectionStrategy: \"CLEAR\"\r\n    syncStrategy: \"INVALIDATE\"\r\n    writeMode: \"WRITE_THROUGH\"\r\n    cacheSize: 1000\r\n    timeToLiveInMillis: 300000\r\n    maxIdleInMillis: 300000",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/1706/comments",
    "author": "bkoroliuk-amplify",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2018-10-30T08:12:59Z",
        "body": "Do you use RMapCache and RLocalCachedMapCache under the same name?"
      },
      {
        "user": "bkoroliuk-amplify",
        "created_at": "2018-10-30T08:54:09Z",
        "body": "> Do you use RMapCache and RLocalCachedMapCache under the same name?\r\n\r\nyes"
      },
      {
        "user": "mrniko",
        "created_at": "2018-10-30T08:55:39Z",
        "body": "That's a bad idea, since compatibility between these objects is not guaranteed."
      },
      {
        "user": "bkoroliuk-amplify",
        "created_at": "2018-10-30T08:58:34Z",
        "body": "What about this setup? (max ttl for local caches)\r\n```\r\nMY_CACHE:\r\nttl: 300000\r\nmaxIdleTime: 300000\r\nmaxSize: 1000\r\n\r\nlocalCacheOptions:\r\nevictionPolicy: \"LRU\"\r\nreconnectionStrategy: \"CLEAR\"\r\nsyncStrategy: \"INVALIDATE\"\r\nwriteMode: \"WRITE_THROUGH\"\r\ncacheSize: 1000\r\ntimeToLiveInMillis: 0\r\nmaxIdleInMillis: 0\r\n```\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2018-10-30T09:04:48Z",
        "body": "That config looks correct. What is your concerns about it?"
      },
      {
        "user": "bkoroliuk-amplify",
        "created_at": "2018-10-31T12:15:57Z",
        "body": "@mrniko No concerns, thank you"
      },
      {
        "user": "mrniko",
        "created_at": "2018-10-31T12:16:26Z",
        "body": "@bkoroliuk-amplify \r\n\r\nYou're welcome!"
      }
    ]
  },
  {
    "number": 1687,
    "title": "Default values for local cache in RedissonSpringLocalCachedCacheManager",
    "created_at": "2018-10-23T14:46:37Z",
    "closed_at": "2018-10-24T17:45:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/1687",
    "body": "What are default values for the mentioned below properties?\r\nAre these values from LocalCachedMapOptions::defaults()?\r\nI see that local caches work, but only ttl, idle and maxSize are defined.\r\n```\r\n localCacheOptions:\r\n    evictionPolicy: \"LRU\"\r\n    reconnectionStrategy: \"CLEAR\"\r\n    syncStrategy: \"UPDATE\"\r\n    writeMode: \"WRITE_THROUGH\"\r\n    cacheSize: 1000\r\n    timeToLiveInMillis: 300000\r\n    maxIdleInMillis: 300000\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/1687/comments",
    "author": "bkoroliuk-amplify",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2018-10-24T14:39:26Z",
        "body": "> What are default values for the mentioned below properties?\r\n\r\nevictionPolicy = NONE,\r\nreconnectionStrategy = NONE,\r\nsyncStrategy = INVALIDATE\r\nwriteMode = WRITE_THROUGH\r\ncacheSize = 0\r\ntimeToLiveInMillis = 0\r\nmaxIdleInMillis = 0\r\n\r\n> Are these values from LocalCachedMapOptions::defaults()?\r\n\r\nNo, seems config instance had been changed further in code."
      },
      {
        "user": "bkoroliuk-amplify",
        "created_at": "2018-10-24T17:45:39Z",
        "body": "Oh, I see, thanks for help"
      }
    ]
  },
  {
    "number": 1660,
    "title": "Which readMode to use? ",
    "created_at": "2018-10-03T16:37:44Z",
    "closed_at": "2018-12-27T03:48:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/1660",
    "body": "We have Redis cluster with 6 nodes (3 masters and 3 slaves), and using redisson 3.6.5. In redisson cluster setting, we applied default value (SLAVE ) on readMode. \r\n\r\nHere are some questions on this setting:\r\n\r\n1. What will happen if one of slave node fails? Will redisson detect the error and switch to master on Read, or it will try to connect to Slave only and throw exception?\r\n\r\n2. If we use MASTER_SLAVE, read operation will go to master/slave randomly or it has a way to go to slave first, and then master when slave fails? \r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/1660/comments",
    "author": "lying1234",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2018-10-25T09:30:13Z",
        "body": "1. Redisson uses MASTER if no SLAVES are available.\r\n\r\n2. Load balancer is used defined through `loadBalancer` setting"
      }
    ]
  },
  {
    "number": 1597,
    "title": "questions about redisson ",
    "created_at": "2018-08-20T13:28:22Z",
    "closed_at": "2018-11-05T17:28:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/1597",
    "body": "These are questions about redissons rather than issues. \r\n\r\nI plan to use redisson in our company project, Use RLocalCachedMap to cache some business orders, but still have some questions about RLocalCachedMap since I can't get them from Wiki, API, Issue discussion in GitHub. \r\n\r\n1. read from map of RLocalCachedMap will always return the NEWEST data in real-time. \r\n\r\n2. clearLocalCache just clear the local data in JVM, it will not clear the data in Redis server, next read of clearLocalCache will sync the data from redis server to local JVM, right?\r\n\r\n3. How to get a Pro version of redisson, please send a email to haiyang.pan@gmail.com",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/1597/comments",
    "author": "gmailisgone",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2018-08-20T13:40:34Z",
        "body": "> 1. read from map of RLocalCachedMap will always return the NEWEST data in real-time.\r\n\r\nYes. If you want transactional updates use `RTransaction.getLocalCachedMap`\r\n\r\n> 2. clearLocalCache just clear the local data in JVM, it will not clear the data in Redis server, next read of clearLocalCache will sync the data from redis server to local JVM, right?\r\n\r\nRight, read operation will load map entry to local cache.\r\n\r\n> 3. How to get a Pro version of redisson, please send a email to haiyang.pan@gmail.com\r\n\r\nPlease check your mail"
      }
    ]
  },
  {
    "number": 1353,
    "title": "Fair lock vs regular lock",
    "created_at": "2018-03-22T16:43:33Z",
    "closed_at": "2018-11-01T09:46:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/1353",
    "body": "Hi,\r\nRight now we are using regular lock in our system. I found out in the documentation there is also fair lock option.\r\nI am trying to find in the documentation any explanation about performance of fair lock vs regular lock.\r\nIs there any performance penalty? I mean is there a reason not so use fair lock always by default?\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/1353/comments",
    "author": "archmisha",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2018-11-01T09:46:31Z",
        "body": "I would recommend to use fair lock only if lock acquisition order is really required. All waiting threads are queued and if some thread has died then Redisson waits its return for 5 seconds. For example, if 5 threads are died for some reason then delay will be 25 seconds."
      },
      {
        "user": "xixiuxiu",
        "created_at": "2020-05-30T05:09:40Z",
        "body": "> I would recommend to use fair lock only if lock acquisition order is really required. All waiting threads are queued and if some thread has died then Redisson waits its return for 5 seconds. For example, if 5 threads are died for some reason then delay will be 25 seconds.\r\n\r\nGreat tips !"
      },
      {
        "user": "mrglint",
        "created_at": "2020-05-30T05:23:30Z",
        "body": "> > I would recommend to use fair lock only if lock acquisition order is really required. All waiting threads are queued and if some thread has died then Redisson waits its return for 5 seconds. For example, if 5 threads are died for some reason then delay will be 25 seconds.\r\n> \r\n> Great tips !\r\n\r\nExcellence"
      }
    ]
  },
  {
    "number": 202,
    "title": "Infinispan redis integration",
    "created_at": "2015-07-31T09:16:44Z",
    "closed_at": "2015-08-05T10:55:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/202",
    "body": "I'm contributing a redis integration to infinispan and am investigating the use of Redisson to use as the client.\n\nI need an efficient way to retrieve a list of all keys and iterate over them for processing, but because Redis can store millions of records, I wanted to avoid a list/queue of data pulled from the Redis server and held in memory on the client as this could wind up exhausting resources on the client.\n\nWill getBuckets, findKeysByPattern or findKeysByPatternAsync retrieve the keys in an efficient manor, like a database cursor stepping over each record, or is there another approach that is recommended to efficiently cater for this?\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/202/comments",
    "author": "spaulg",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2015-07-31T11:00:29Z",
        "body": "There is no cursor for keys iteration. But if you find the way, please tell me\n"
      },
      {
        "user": "spaulg",
        "created_at": "2015-08-03T08:21:18Z",
        "body": "The only way I've seen is that in the Lettuce client. It has a method whereby keys can be streamed; a callback is triggered for each key received. \n\nI haven't tested to see how effective it is. I presume it blocks the connection at a low level until the callback processes items in a fixed sized queue on the client, making more space to resume the connection.\n"
      },
      {
        "user": "mrniko",
        "created_at": "2015-08-03T08:23:24Z",
        "body": "> I presume it blocks the connection at a low level until the callback processes items in a fixed sized queue on the client\n\nBut it's not atomic way. I mean there is a new keys could be created while you iterate your old keys.\n"
      },
      {
        "user": "spaulg",
        "created_at": "2015-08-03T12:18:16Z",
        "body": "Though I'm by no means any expert in Netty or Redis, and I'm assuming both clients make the call to Redis using the same command, as I see it, once the command is issued to the server and the server has responded, the 'atomicity' of the command has already passed. How the client handles processing of the response, be it a stream or buffered response to a list, makes no difference if its all transferred over a network in the same way.\n\nEven if the key list is buffered to a list on the client, the keys on the Redis server have probably changed by then anyway.\n"
      },
      {
        "user": "spaulg",
        "created_at": "2015-08-03T12:48:50Z",
        "body": "Looking at the Redis documentation, I should be using scan, not keys, which is a cursor like implementation that allows batches of keys to be sent from the Redis server for production use.\n"
      },
      {
        "user": "mrniko",
        "created_at": "2015-08-03T13:18:27Z",
        "body": "scan - nice command, i'll add support of it\n"
      },
      {
        "user": "mrniko",
        "created_at": "2015-08-05T10:55:57Z",
        "body": "SCAN support added\n"
      }
    ]
  },
  {
    "number": 153,
    "title": "[Question] What if I don't call Redission#shutdown()?",
    "created_at": "2015-05-07T11:28:51Z",
    "closed_at": "2015-07-22T17:00:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/153",
    "body": "Hi,\nI'm using this library together with Storm. Since the connection should essentially be alive during streaming to be able to read/write continuously, I don't want to call `Redission#shutdown()`. I wonder what would happen to the connection? What if a node that uses the connection fails in the middle of a stream?\nThank you.\nHuy\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/153/comments",
    "author": "huylv",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2015-05-07T12:20:01Z",
        "body": "You will have an open connections in ConnectionManager and live netty-threads.\n"
      },
      {
        "user": "huylv",
        "created_at": "2015-05-07T12:23:32Z",
        "body": "How do I overcome this?\n"
      },
      {
        "user": "mrniko",
        "created_at": "2015-07-22T16:59:25Z",
        "body": "> What if a node that uses the connection fails in the middle of a stream?\n\nif connection drops it will be reconnected by ConnectionWatchdog handler. So Redisson will handle long-live connection for you so long as you need.\n"
      }
    ]
  },
  {
    "number": 149,
    "title": "Get/Set strings",
    "created_at": "2015-04-26T11:01:27Z",
    "closed_at": "2015-07-22T16:56:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/149",
    "body": "How do I get/set a simple string with Redisson?\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/149/comments",
    "author": "espiegel",
    "comments": [
      {
        "user": "ahmedaswai",
        "created_at": "2015-04-27T16:05:46Z",
        "body": " Redisson redisson = Redisson.create();\n\n RBucket<byte[]> bucket = redisson.getBucket(\"YourKey\");\n\n   bucket.setAsync(obj); or    bucket.set(obj);\n"
      },
      {
        "user": "jlguenego",
        "created_at": "2023-03-20T19:23:14Z",
        "body": "May be this is what you need ?\r\n\r\n```java\r\npackage org.example;\r\n\r\nimport org.redisson.Redisson;\r\nimport org.redisson.api.RBucket;\r\nimport org.redisson.api.RedissonClient;\r\nimport org.redisson.client.codec.StringCodec;\r\nimport org.redisson.config.Config;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n\r\n        try {\r\n            Config config = new Config();\r\n            config.useSingleServer().setAddress(\"redis://localhost:6379\");\r\n            config.setCodec(new StringCodec());\r\n            RedissonClient redisson = Redisson.create(config);\r\n            RBucket<String> bucket = redisson.getBucket(\"clientName\");\r\n            String objValue = bucket.get();\r\n            System.out.println(\"The object value is: \" + objValue);\r\n            redisson.shutdown();\r\n        } catch (Exception e) {\r\n            System.out.println(\"e = \" + e);\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 130,
    "title": "Redisson and multiple like inserts",
    "created_at": "2015-03-02T15:38:31Z",
    "closed_at": "2015-07-22T16:56:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/130",
    "body": "Lets suppose I have a list of some students - the current list has students with ids: 3,5,8. As I understand I don't need to use redis list here as I don't need to keep order. The order I don't need as it's clear it's just SOME of students. However I want to cache them.\nI think I need to use here redis type string and do something like db:stundents:{id}. My question - how can I do multiple insert of these three stundents? To insert one I use Bucket.set().\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/130/comments",
    "author": "PavelTurk",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2015-07-22T16:56:13Z",
        "body": "With Redisson 2.0 you could use batches. Example:\n\n``` java\nRBatch batch = redisson.createBatch();\n// all those commands will be executed as one\nbatch.getBucket('id1').setAsync('student1');\nbatch.getBucket('id2').setAsync('student2');\nbatch.getBucket('id3').setAsync('student3');\n// execute all async operations in batch\nbatch.execute();\n```\n"
      }
    ]
  }
]