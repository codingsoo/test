[
  {
    "number": 1536,
    "title": "Hikari connection adder taking 3-4 seconds for preparing and adding each connection",
    "created_at": "2020-02-06T14:04:06Z",
    "closed_at": "2020-02-28T14:20:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/1536",
    "body": "`\r\n2020-02-06 16:36:49.505 DEBUG 8298 --- [onnection adder] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@2fdf814b\r\n2020-02-06 16:36:53.465 DEBUG 8298 --- [onnection adder] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@6ee28b70\r\n2020-02-06 16:36:57.153 DEBUG 8298 --- [onnection adder] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@5fc66015\r\n2020-02-06 16:37:00.444 DEBUG 8298 --- [onnection adder] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@ecd743f\r\n2020-02-06 16:37:04.231 DEBUG 8298 --- [onnection adder] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@6d40469c\r\n2020-02-06 16:37:08.227 DEBUG 8298 --- [onnection adder] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@a838e53\r\n2020-02-06 16:37:13.839 DEBUG 8298 --- [onnection adder] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@1c2bcee8\r\n2020-02-06 16:37:15.106 DEBUG 8298 --- [l-1 housekeeper] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Pool stats (total=8, active=1, idle=7, waiting=0)\r\n2020-02-06 16:37:17.237 DEBUG 8298 --- [onnection adder] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@2dc97e2f\r\n2020-02-06 16:37:21.432 DEBUG 8298 --- [onnection adder] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@437a249\r\n2020-02-06 16:37:21.433 DEBUG 8298 --- [onnection adder] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - After adding stats (total=10, active=1, idle=9, waiting=0)\r\n2020-02-06 16:37:45.107 DEBUG 8298 --- [l-1 housekeeper] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Pool stats (total=10, active=1, idle=9, waiting=0)\r\n2020-02-06 16:38:15.108 DEBUG 8298 --- [l-1 housekeeper] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Pool stats (total=10, active=1, idle=9, waiting=0)\r\n`\r\nHence, for 10 connections it takes 10x40 = 40 seconds more\r\nMy database is located remotely DC and I am accessing it via VPN. If i run my application within same DC it takes around 11 seconds.\r\n\r\n**Other observation**\r\n1. If same application run locally with VPN connection to a database located in other DC, but with Spring Boot 1.5.4 (Connection Pool is tomcatCP), application bootstraps in 84 seconds\r\n2. But, when the same application is upgraded to Spring Boot 2.2.4 (Hikari will be default CP) it takes 200 seconds. The application started locally pointing to a database located in another DC. The application uses a VPN connection.\r\n3. My Application has 2 data sources. Hence, it takes 80 more seconds (40 for Hikari Pool1 + 40 for Hikari Pool 2)\r\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/1536/comments",
    "author": "ShriprasadM",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2020-02-28T14:20:06Z",
        "body": "@ShriprasadM Is the issue that it is slow to startup?  Adding connections should occur asynchronously and not block the startup of your application.\r\n\r\nIf you wish to fill up the pool more quickly during startup, and you are on a recent version of the pool, you can define the system property ``com.zaxxer.hikari.blockUntilFilled`` as ``true``.  If this is done, HikariCP *will* block your application during startup, but it will use _multiple threads_ to add connections simultaneously.  Specifically, it will use core-count number of threads.\r\n"
      },
      {
        "user": "ShriprasadM",
        "created_at": "2020-04-11T11:55:35Z",
        "body": "Thanks @brettwooldridge  for the update!\r\nI will check with `com.zaxxer.hikari.blockUntilFilled` option. Does this option available as a part of standard documentation? Can you point me to that link?"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2020-04-11T16:08:22Z",
        "body": "It is neither documented nor officially supported.  At the same time, I do not anticipate its removal.\r\n"
      }
    ]
  },
  {
    "number": 1385,
    "title": "Does the getIdleConnections() method under HikariPoolMXBean class brings the idle connections that are still valid connections?",
    "created_at": "2019-05-30T13:21:14Z",
    "closed_at": "2019-05-30T15:08:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/1385",
    "body": "#### Environment\r\n```\r\nHikariCP version: 3.2.0\r\nJDK version     : 1.8.0_102\r\nDatabase        : AS400\r\nDriver version  : jt400-jdk8 v9.8\r\n```\r\nI am trying to switch the datasources from a primary AS400 to a secondary AS400 in case the primary AS400 is not online. To do this I am looking at the idle connections in the pool. Idle connections are still valid connections to the DB, correct?",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/1385/comments",
    "author": "amitbhanot",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2019-05-30T15:08:49Z",
        "body": "@amitbhanot The idle count available through the MXBean may include connections that are not valid.  Connections are tested upon borrow, and therefore connections \"sitting\" in the pool may or may not be valid.\r\n\r\nIf, however, you have an ``idleTImeout`` configured, and a ``minimumIdle`` setting that is less than ``maximumPoolSize ``, you can be reasonable sure that the connections are alive.\r\n\r\nIf you are trying to detect that the primary AS400 has gone down, I suggest looking primarily at the total pool size.  When a database fails, the pool will quickly exhaust all of the connections.  When a new connection is requested, one will be selected, then tested, and upon failing, evicted from the pool -- and the process repeated very quickly for the remaining connections in the pool.\r\n"
      },
      {
        "user": "amitbhanot",
        "created_at": "2019-05-30T17:40:19Z",
        "body": "@brettwooldridge That is in fact what I am doing. I am querying the DB which uses an available invalid connection from the pool. Since the connection is invalid, the query fails and I switch it to the secondary AS400 datasource. Thank you for that explanation."
      }
    ]
  },
  {
    "number": 1300,
    "title": "Support Java 11",
    "created_at": "2018-12-21T04:08:22Z",
    "closed_at": "2018-12-21T09:09:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/1300",
    "body": "When will be HikariCP support Java 11?\r\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/1300/comments",
    "author": "leonardwoo",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2018-12-21T09:09:36Z",
        "body": "@leonardwu HikariCP runs on Java 11 now.  My company uses it running under Java 11."
      }
    ]
  },
  {
    "number": 1221,
    "title": "Disable HikariCP Log",
    "created_at": "2018-08-12T01:36:23Z",
    "closed_at": "2018-08-22T19:18:32Z",
    "labels": [
      "question",
      "not-a-bug"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/1221",
    "body": "I have search about \"Howto Disable HikariCP Debug\" but i can't find solution, so i want to ask about is there are function howto disable hikariCP Debug log?",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/1221/comments",
    "author": "devzonetrack",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2018-08-22T19:18:32Z",
        "body": "@devzonetrack The logging level is controlled by your logging framework (``log4j``, ``logback``, ``java.util.loggin``, etc.).  See the documentation for the logging framework about how to control logging levels."
      }
    ]
  },
  {
    "number": 1207,
    "title": "Hikari CP maxLifetime / idleTimeout",
    "created_at": "2018-07-23T16:00:57Z",
    "closed_at": "2018-07-25T14:28:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/1207",
    "body": "Hikari CP Version : 2.7.4\r\n\r\nThis is actually not an issue but some doubts.\r\na) maxLifetime : retires the connection after 30 mins. Will it also create a new connection automatically at the time of killing it or it waits for a new request and then creates a new connectios? considering pool has more than minIdle.\r\n\r\nb) idleTimeout : it will drop after 10 mins of inactivity? but 10mins is too high. is it ok if i mark it as 10s(10 is min as seen from code) as otherwise there will always be connections higher than min-connections?",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/1207/comments",
    "author": "ban1989ban",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2018-07-25T14:28:55Z",
        "body": "@banank1989 \r\n\r\na) Whenever there are more than ``minimumIdle`` connections, if a connection is retired, it will not automatically be replaced.  If the pool is configured as fixed-size, or if there are fewer than ``minimumIdle`` connections after the connection is closed, then the connection will be replaced automatically, immediately.\r\n\r\nb) It is a little hard to explain and to visualize how it works, but I will try...\r\n\r\nThe pool behaves like a LIFO queue (i.e. stack), rather than a FIFO queue.\r\n\r\nSo, imagine that your pool has ``minimumIdle=3`` and ``maximumPoolSize=10``.  If you have a load demand that requires five (5) connections, then the pool grows to five.  After that, if the load decreases, and only requires one, two, or three connections at a time, then those one, two, or three connections will be continuously reused.  The two additional connections (of the original five), are at the tail of the queue, or bottom of the stack, depending on how you visualize it, and will never be touched.  And so, after the ``idleTimeout``, those two connections will be closed.\r\n\r\nNow, depending on the dynamics of your load demand, it may be that spikes above ``minimumIdle`` are rare.  In that case, you may wish to retire connections more quickly than the 10 minute default.  However, I would suggest that 10 seconds is probably \"too quick\", almost regardless of dynamics.  But something like 1 minute may be perfectly reasonable.\r\n\r\nWhat you want to avoid is getting into a pattern of needlessly closing and then almost immediately re-opening connections.  This creates unnecessary load on your database.\r\n\r\nI strongly suggest setting up (enabling) metrics collection, and studying the histogram of *active* connections to determine what a correct ``minimumIdle`` value is, and also what is a reasonable value for ``idleTimeout``.  Unless the application is trivial, and performance not so important, it is always better to base pool tuning decisions on empirical data.\r\n"
      },
      {
        "user": "namjitharavind",
        "created_at": "2019-11-04T11:56:49Z",
        "body": "Is there any configuration to always keep some connections open?"
      }
    ]
  },
  {
    "number": 1206,
    "title": "Information on hikari spring branch",
    "created_at": "2018-07-23T15:27:19Z",
    "closed_at": "2018-07-25T13:51:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/1206",
    "body": "#### Environment\r\n```\r\nHikariCP version: 2.7.6\r\nDatabase        : Oracle\r\nDriver version  : ojdbc8.jar\r\n```\r\nI am using the version from the spring branch and was wondering if there was some wiki info on this specific branch. What are the differences with this branch and is there any reason i might want to try the 3.x dev branch ? \r\n\r\nAny response is greatly appreciated. I have been searching around for a couple of days and could not locate any significant information. (Please forgive me if i missed something in my search)",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/1206/comments",
    "author": "benduke",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2018-07-25T13:51:52Z",
        "body": "@benduke The only difference between the Spring v2.7.9 release and v2.7.8 is the upgrade of Micrometer support from the 1.0.0.RC (release candidate) to the final v1.0.0 release.\r\n\r\nOriginally, this change was only on HikariCP v3.0.0, but it came too late in the Spring release cycle, and according to their release rules, they could not pick-up a major revision change so late.  So, the support for Micrometers v1.0.0 was cherry-picked from HikariCP v3.0.0 into a special v2.7.9 build to accomodate their release schedule.\r\n"
      }
    ]
  },
  {
    "number": 1205,
    "title": "connectionTimeout not working properly",
    "created_at": "2018-07-23T03:41:26Z",
    "closed_at": "2018-07-23T11:42:47Z",
    "labels": [
      "question",
      "not-a-bug"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/1205",
    "body": "#### Environment\r\n```\r\nHikariCP version: 2.3.7\r\nJDK version     : 1.8.0_172\r\nDatabase        : SQL Server/ JTDS\r\nDriver version  :  1.3.1\r\nPlay version: 2.4.6\r\n\r\n-----------------------------------------------------------------------------------------\r\nWe use HikariCP with Play! 2.4.6. The application ran fine before, but throw SQLTimeoutException due to increase load. \r\nA request timed out after 23607ms , but the Hikari connectionTimeout is set to 10000ms.\r\nShouldn't the connection acquire timeout after 10000ms?  \r\nI haven't been able to reproduce this problem locally. And ConnectionTimeout is set to HikariCP correctly I confirm.\r\n\r\n**Play's HikariCP config**\r\nplay.db.pool=hikaricp\r\ndb.default.url=${database.jdbc.url}\r\ndb.default.driver=\"net.sourceforge.jtds.jdbc.Driver\"\r\ndb.default.hikaricp.autocommit=true\r\ndb.default.hikaricp.maximumPoolSize=25\r\ndb.default.hikaricp.minimumIdle=10\r\ndb.default.username=${username}\r\ndb.default.password=${password}\r\ndb.default.hikaricp.connectionTimeout = 10000\r\ndb.default.hikaricp.connectionTestQuery=\"select 1\"\r\ndb.default.hikaricp.readOnly = true\r\ndb.default.hikaricp.poolName = current\r\ndb.default.hikaricp.disableJMX = false\r\ndb.default.hikaricp.registerMbeans= true\r\n\r\ndb.central.url=${database.jdbc.url}\r\ndb.central.driver=\"net.sourceforge.jtds.jdbc.Driver\"\r\ndb.central.hikaricp.autocommit=true\r\ndb.central.hikaricp.maximumPoolSize=15\r\ndb.central.hikaricp.minimumIdle=10\r\ndb.central.username=${username}\r\ndb.central.password=${password}\r\ndb.central.hikaricp.connectionTimeout = 10000\r\ndb.central.hikaricp.connectionTestQuery=\"select 1\"\r\ndb.central.hikaricp.readOnly = true\r\ndb.central.hikaricp.poolName = central\r\ndb.central.hikaricp.disableJMX = false\r\ndb.central.hikaricp.registerMbeans= true\r\n\r\n\r\nBelow Log :\r\njava.sql.SQLTimeoutException: Timeout after 23607ms of waiting for a connection.\r\n        at com.zaxxer.hikari.pool.BaseHikariPool.getConnection(BaseHikariPool.java:227) ~[com.zaxxer.HikariCP-2.3.7.jar:na]\r\n        at com.zaxxer.hikari.pool.BaseHikariPool.getConnection(BaseHikariPool.java:182) ~[com.zaxxer.HikariCP-2.3.7.jar:na]\r\n        at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:93) ~[com.zaxxer.HikariCP-2.3.7.jar:na]\r\n        at play.api.db.DefaultDatabase.getConnection(Databases.scala:143) ~[com.typesafe.play.play-jdbc_2.11-2.4.6.jar:2.4.6\r\n]\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/1205/comments",
    "author": "DamilyLi",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2018-07-23T11:42:47Z",
        "body": "Typically, HikariCP has extremely accurate timeouts, +/-2ms.  However, HikariCP threads, like all Java threads, are subject to the OS scheduler.  \r\n\r\nUnder sufficient load all threads will begin to experience CPU starvation.  In this case, approximately 13ms delay.  If, as you say, this timeout occurs due to increasing load, it is hardly surprising.\r\n\r\nHaving said that, I would be remiss if I did not also mention that running the latest version of HikariCP is always recommended. v2.3.7 is very old, and many fixes and improvements have been made since.\r\n\r\n\r\n"
      },
      {
        "user": "DamilyLi",
        "created_at": "2018-07-24T08:56:08Z",
        "body": "@brettwooldridge  Thanks for your response.  We will update the version later. \r\n\r\nBut I have a confusion for this SQLTimeoutException. \r\n\r\nIf delay, my understand is that timeouts should be accurate timeouts, +13ms.  But it is amazing for exception Timeout 23607ms, it is much larger than connectionTimeout config.  \r\n\r\nCould you give me some advice for finding the cause?  Thanks. \r\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2018-07-25T14:34:35Z",
        "body": "@DamilyLi There can only be one cause, as far as I am concerned: over-committed CPU.\r\n\r\nI strong suggest enabling monitoring for the pool and collecting metrics.  Additionally, also collect metrics from the application server itself.  If you graph a histogram if CPU usage, and compare it with the timestamps of timeouts in the logs, as well as the histogram of *active* connections in the pool, you will almost certainly find that the timeouts occur when the CPU usage is max'ed out at 100%.\r\n"
      }
    ]
  },
  {
    "number": 1080,
    "title": "BoneCP also tested???",
    "created_at": "2018-02-08T15:52:28Z",
    "closed_at": "2018-02-08T17:46:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/1080",
    "body": "I wonder who is responsible for the output of:\r\n`04:49:427 [Timer-3] INFO DbDownTest - BoneCPDataSource got a connection.`\r\n?\r\n\r\nI thought you only tested C3P0, Tomcat DBCP2, Vibur and Hikari.\r\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/1080/comments",
    "author": "du-it",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2018-02-08T17:46:17Z",
        "body": "Bone was removed from the final evaluation because the author stopped development of the pool, and I wanted to focus on active projects.\r\n"
      },
      {
        "user": "du-it",
        "created_at": "2018-02-09T08:27:22Z",
        "body": "I see. Thank you. So maybe it would be a good hint to remove the line in the log or to annotate it in the article what you told me."
      }
    ]
  },
  {
    "number": 1052,
    "title": "Java 9 status",
    "created_at": "2017-12-30T23:11:27Z",
    "closed_at": "2018-01-10T13:39:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/1052",
    "body": "Hi\r\n\r\nCurrently there are two versions of HikariCP displayed on the site main page:\r\n\r\n1) Java 8 maven artifact:\r\n2) Java 9 Early Access maven artifact:\r\n\r\nHowever it is not clear the difference between them? Java 9 Early Access version was last released on April, 2017. So now when JDK 9 is released what version should we use? Is it safe to use Java 8 artifact or Java 9 is preferred?\r\n\r\nPlease, give more detail. Thanks.",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/1052/comments",
    "author": "sergey-morenets",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2018-01-10T13:39:49Z",
        "body": "@sergey-morenets I just released v2.7.5, which contains a fix for Java 9 compatibility with respect to the Java 8 library.\r\n\r\nThe Java 8 artifact would be the preferred artifact at this point.\r\n"
      },
      {
        "user": "sergey-morenets",
        "created_at": "2018-01-10T14:41:47Z",
        "body": "@brettwooldridge Thank you. So you propose using version 2.7.5 if I have JDK 9.0.1 ?"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2018-01-11T23:53:59Z",
        "body": "Correct."
      }
    ]
  },
  {
    "number": 1051,
    "title": "Why is executeQuery marking the connection as dirty?",
    "created_at": "2017-12-28T17:21:56Z",
    "closed_at": "2018-01-09T13:47:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/1051",
    "body": "#### Environment\r\n```\r\nHikariCP version: 2.6.1\r\nJDK version     : 1.8.0_101\r\nDatabase        : MySQL|Vertica\r\nDriver version  : x.x.x\r\n```\r\n-----------------------------------------------------------------------------------------\r\n\r\nLooking at the ProxyStatement code I see it marks the connection as dirt on every possible execution - even for query statements (e.g. event at ResultSet executeQuery(String sql)). why?\r\n\r\nIn certain isolation levels a read statement could dirty a connection (e.g. repeated read in mysql), BUT, the fact this can't be configured in any way means EVERY (used) connection would result in a rollback.\r\nI would've hacked my way in, but all classes are final and nothing here is pluggable...\r\nWhy not add a config per datasource that would allow some means of control?\r\n\r\nThanks!\r\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/1051/comments",
    "author": "sternr",
    "comments": [
      {
        "user": "winflex",
        "created_at": "2018-01-08T09:37:05Z",
        "body": "\"EVERY (used) connection would result in a rollback\"\r\nI think this is not true, the isCommitStateDirty is set to false when you invoke Connection.commit(), and rollback will not be invoke when isCommitStateDirty is false\r\n  "
      },
      {
        "user": "sternr",
        "created_at": "2018-01-08T10:29:21Z",
        "body": "You are correct, I meant every connection that we don't explicitly call either rollback or commit would result in rolllback."
      },
      {
        "user": "brettwooldridge",
        "created_at": "2018-01-09T13:47:51Z",
        "body": "@sternr Databases are tricky things.  JDBC is a fairly high-level API and in some ways ignorant of the actual transaction boundaries of the underlying database.\r\n\r\nConsider the following SQL (PostgreSQL):\r\n```sql\r\nUPDATE products SET price = price * 1.10\r\n  WHERE price <= 99.99\r\n  RETURNING name, price AS new_price;\r\n```\r\nEven though this is an ``UPDATE`` it returns columns (i.e. a ``ResultSet``).  This query, in JDBC-land, can be executed by either ``stmt.execute()`` *or* ``stmt.executeQuery()``.  JDBC is blissfully unaware that data was modified.\r\n\r\nMoral of the story, if ``autoCommit=false`` you absolutely *must* call ``commit()`` or ``rollback()`` in order to ensure correctness.  On MySQL you *might* avoid a roundtrip to the database if ``useLocalTransactionState=true``, but I'm not sure of that.  Better to explicitly commit/rollback yourself; if you do not, HikariCP *will* rollback the transaction to ensure correctness.\r\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2018-01-10T12:15:07Z",
        "body": "@sternr Just one more example that occurred to me today:\r\n```java\r\nStatement stmt = conn.createStatement();\r\nstmt.execute(\"INSERT INTO products(name, price) VALUES ('broom', 2.99);\" +\r\n             \"SELECT * FROM products WHERE name='broom';\" +\r\n             \"SELECT * FROM orders;\");\r\n// process products\r\nResultSet rs = stmt.getResultSet();\r\n...\r\n// process orders\r\nif (stmt.getMoreResults()) {\r\n   rs = stmt.getResultSet();\r\n   ...\r\n}\r\n```\r\nThe point, as above, being that multiple statements can be executed in a single call, one of which may initiate a transaction (which HikariCP has no way of knowing about), and therefore HikariCP *must* assume that the commit state is dirty after *any* SQL execution.\r\n"
      }
    ]
  },
  {
    "number": 1028,
    "title": "Decreasing of pool size in runtime",
    "created_at": "2017-11-27T18:01:21Z",
    "closed_at": "2017-11-28T13:41:10Z",
    "labels": [
      "question",
      "not-a-bug"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/1028",
    "body": "#### Environment\r\n```\r\nHikariCP version: 2.2.5\r\nJDK version       : 1.8.0_144\r\nDatabase           : MySQL\r\nDriver version    : 5.1.43\r\nHibernate           : 4.3.6\r\n```\r\n-----------------------------------------------------------------------------------------\r\nI'm trying to investigate problem:\r\n\r\n`org.springframework.transaction.CannotCreateTransactionException: Could not open JPA EntityManager for transaction; nested exception is javax.persistence.PersistenceException: org.hibernate.exception.GenericJDBCException: Could not open connection \r\n    at org.springframework.orm.jpa.JpaTransactionManager.doBegin(JpaTransactionManager.java:431) \r\n    at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:373) \r\n    at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:427) \r\n    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:276) \r\n    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96) \r\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) \r\n    at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:655) \r\n    at de.bcg.xchange.requests.rest.RequestResource$$EnhancerBySpringCGLIB$$3bf285f1.fetchConversationByRequest(<generated>) \r\n    at sun.reflect.GeneratedMethodAccessor554.invoke(Unknown Source) \r\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) \r\n    at java.lang.reflect.Method.invoke(Method.java:498) \r\n    at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:221) \r\n    at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:136) \r\n    at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110) \r\n    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:817) \r\n    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:731) \r\n    at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) \r\n    at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:959) \r\n    at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:893) \r\n    at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:968) \r\n    at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:859) \r\n    at javax.servlet.http.HttpServlet.service(HttpServlet.java:624) \r\n    at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:844) \r\n    at javax.servlet.http.HttpServlet.service(HttpServlet.java:731) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at de.bcg.xchange.platform.filters.gzip.GZipServletFilter.doFilter(GZipServletFilter.java:46) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at de.bcg.xchange.platform.filters.MDCUserInfoServletFilter.doFilter(MDCUserInfoServletFilter.java:52) \r\n    at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346) \r\n    at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:262) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at ch.qos.logback.classic.helpers.MDCInsertingServletFilter.doFilter(MDCInsertingServletFilter.java:51) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at de.bcg.xchange.platform.filters.MDCInvocationFilter.doFilter(MDCInvocationFilter.java:25) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at com.codahale.metrics.servlet.AbstractInstrumentedFilter.doFilter(AbstractInstrumentedFilter.java:104) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration$ApplicationContextHeaderFilter.doFilterInternal(EndpointWebMvcAutoConfiguration.java:237) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at de.bcg.xchange.platform.filters.MDCUserInfoServletFilter.doFilter(MDCUserInfoServletFilter.java:52) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:112) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:316) \r\n    at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126) \r\n    at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:114) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:122) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:169) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:48) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at de.bcg.xchange.platform.filters.AcceptedTermsOfUseFilter.doFilterInternal(AcceptedTermsOfUseFilter.java:45) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at de.bcg.xchange.platform.filters.AgentLoginFilter.doFilterInternal(AgentLoginFilter.java:94) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at de.bcg.xchange.platform.filters.ImpersonateUserFilter.doFilterInternal(ImpersonateUserFilter.java:78) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.oauth2.provider.authentication.OAuth2AuthenticationProcessingFilter.doFilter(OAuth2AuthenticationProcessingFilter.java:140) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:120) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:64) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:91) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:53) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:213) \r\n    at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:176) \r\n    at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346) \r\n    at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:262) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:87) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:77) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:121) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:218) \r\n    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:110) \r\n    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:506) \r\n    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:169) \r\n    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103) \r\n    at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:962) \r\n    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116) \r\n    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:445) \r\n    at org.apache.coyote.ajp.AjpProcessor.process(AjpProcessor.java:190) \r\n    at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:637) \r\n    at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:316) \r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) \r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) \r\n    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) \r\n    at java.lang.Thread.run(Thread.java:748) \r\nCaused by: javax.persistence.PersistenceException: org.hibernate.exception.GenericJDBCException: Could not open connection \r\n    at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1763) \r\n    at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1677) \r\n    at org.hibernate.jpa.spi.AbstractEntityManagerImpl.throwPersistenceException(AbstractEntityManagerImpl.java:1771) \r\n    at org.hibernate.jpa.internal.TransactionImpl.begin(TransactionImpl.java:64) \r\n    at org.springframework.orm.jpa.vendor.HibernateJpaDialect.beginTransaction(HibernateJpaDialect.java:170) \r\n    at org.springframework.orm.jpa.JpaTransactionManager.doBegin(JpaTransactionManager.java:380) \r\n     ... 126 common frames omitted \r\nCaused by: org.hibernate.exception.GenericJDBCException: Could not open connection \r\n    at org.hibernate.exception.internal.StandardSQLExceptionConverter.convert(StandardSQLExceptionConverter.java:54) \r\n    at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:126) \r\n    at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:112) \r\n    at org.hibernate.engine.jdbc.internal.LogicalConnectionImpl.obtainConnection(LogicalConnectionImpl.java:235) \r\n    at org.hibernate.engine.jdbc.internal.LogicalConnectionImpl.getConnection(LogicalConnectionImpl.java:171) \r\n    at org.hibernate.engine.transaction.internal.jdbc.JdbcTransaction.doBegin(JdbcTransaction.java:67) \r\n    at org.hibernate.engine.transaction.spi.AbstractTransactionImpl.begin(AbstractTransactionImpl.java:162) \r\n    at org.hibernate.internal.SessionImpl.beginTransaction(SessionImpl.java:1435) \r\n    at org.hibernate.jpa.internal.TransactionImpl.begin(TransactionImpl.java:61) \r\n     ... 128 common frames omitted \r\nCaused by: java.sql.SQLException: Timeout after 34877ms of waiting for a connection. \r\n    at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:205) \r\n    at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:91) \r\n    at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:139) \r\n    at org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection(AbstractSessionImpl.java:380) \r\n    at org.hibernate.engine.jdbc.internal.LogicalConnectionImpl.obtainConnection(LogicalConnectionImpl.java:228) \r\n     ... 133 common frames omitted`\r\n\r\nI've enabled logging and found out one strange thing, could you please help to understand that:\r\nI'm using default maxPoolSize and minimumIdle and typical state of connections is:\r\n\r\n2017-11-27 15:27:00,352 [DEBUG] com.zaxxer.hikari.pool.HikariPool - Before cleanup pool stats HikariPool-0 (**total=10**, inUse=3, avail=7, waiting=0)\r\n2017-11-27 15:27:00,353 [DEBUG] com.zaxxer.hikari.pool.HikariPool - After cleanup pool stats HikariPool-0 (**total=10**, inUse=3, avail=7, waiting=0)\r\n\r\nAs I get from the documentation for minimumIdle \"we recommend not setting this value and instead allowing HikariCP to act as a **fixed size connection pool**\", so I expect that total connections should always be equal to maxPoolSize.\r\nBut I see sometimes such cases:\r\n\r\n2017-11-27 15:35:30,351 [DEBUG] com.zaxxer.hikari.pool.HikariPool - Before cleanup pool stats HikariPool-0 (total=10, inUse=4, avail=6, waiting=0)\r\n2017-11-27 15:35:30,353 [DEBUG] com.zaxxer.hikari.pool.HikariPool - After cleanup pool stats HikariPool-0 (**total=5**, inUse=4, avail=1, waiting=0)\r\n\r\n2017-11-27 16:11:07,255 [DEBUG] com.zaxxer.hikari.pool.HikariPool - Before cleanup pool stats HikariPool-0 (total=10, inUse=3, avail=7, waiting=0)\r\n2017-11-27 16:11:07,259 [DEBUG] com.zaxxer.hikari.pool.HikariPool - After cleanup pool stats HikariPool-0 (**total=3**, inUse=3, avail=0, waiting=0)\r\n\r\nAnd thinking why it's changing and could it be a reason for the problem with java.sql.SQLException: Timeout after 34877ms of waiting for a connection that time-to-time there's fewer connections in the pool that is needed (this error appears pretty rarely)? Can minimumIdle help with the problem?",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/1028/comments",
    "author": "OksanaMykhalets",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2017-11-28T11:51:31Z",
        "body": "Before trying to diagnose what is happening, I strongly recommend updating HikariCP to v2.7.4.  Version 2.2.5 is *extremely* old and many bugs have been fixed since then, including bugs related to connection retirement and pool repopulation.\r\n\r\nIf you still encounter these errors on the latest version, let us know (and provide v2.7.4 logs).\r\n"
      },
      {
        "user": "OksanaMykhalets",
        "created_at": "2017-11-28T12:15:24Z",
        "body": "Thanks a lot for a fast response. I'll try to upgrade."
      },
      {
        "user": "brettwooldridge",
        "created_at": "2017-11-28T13:42:26Z",
        "body": "@OksanaMykhalets I assume it worked?  If so, great! 🎉 \r\n"
      },
      {
        "user": "OksanaMykhalets",
        "created_at": "2017-11-28T13:49:45Z",
        "body": "@brettwooldridge I don't see anymore those decreasing of pool size after upgrade, so I think this issue can be closed. \r\n\r\nCan't say if it also will help with:\r\n`java.sql.SQLException: Timeout after 34877ms of waiting for a connection. at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:205)`\r\ncause I'm facing this issue once in a week or so, but I've also enabled leakDetectionThreshold, so it should be easy to find the cause of the problem if it'll appear again.\r\n\r\nThanks a lot for your help and incredibly cool library!"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2017-11-28T14:08:22Z",
        "body": "@OksanaMykhalets You're very welcome.  My guess is that the pool exhaustion issue in v2.2.5 was the cause of the timeout that you observed, so hopefully it will not appear again.\r\n"
      }
    ]
  },
  {
    "number": 1014,
    "title": "setMinimumIdle and setMaximumPoolSize break pool connection on startup",
    "created_at": "2017-11-10T02:08:01Z",
    "closed_at": "2017-11-10T12:57:37Z",
    "labels": [
      "more-information-needed",
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/1014",
    "body": "#### Environment\r\n```\r\nHikariCP version: 2.7.2\r\nJDK version     : 1.8.0_131-b11\r\nDatabase        :  Percona\r\nDriver version  : mysql-connector-java-8.0.8-dmr-bin.jar\r\n```\r\n-----------------------------------------------------------------------------------------\r\n\r\nAre there any known issue with setMinimumIdle and setMaximumPoolSize? All of the other methods work just find, however when I include either of these I can't get a pool connection upon startup. I have them commented out in the code below.\r\n\r\n\r\n\t/* GET AND SET SIZE AND TIMEOUTS */\r\n\t\r\n\tpublic long getConnectionTimeout() {\r\n\t\treturn dsource.getHikariConfigMXBean().getConnectionTimeout();\r\n\t}\r\n\t\r\n\tpublic void setConnectionTimeout(long timeout) {\r\n\t\tdsource.getHikariConfigMXBean().setConnectionTimeout(timeout);\r\n\t}\r\n\t\r\n\tpublic long getIdleTimeout() {\r\n\t\treturn dsource.getHikariConfigMXBean().getIdleTimeout();\r\n\t}\r\n\t\r\n\tpublic void setIdleTimeout(long timeout) {\r\n\t\tdsource.getHikariConfigMXBean().setIdleTimeout(timeout);\r\n\t}\r\n\t\r\n\tpublic long getMaxLifetime() {\r\n\t\treturn dsource.getHikariConfigMXBean().getMaxLifetime();\r\n\t}\r\n\t\r\n\tpublic void setMaxLifetime(long lifetime) {\r\n\t\tdsource.getHikariConfigMXBean().setMaxLifetime(lifetime);\r\n\t}\r\n\t\r\n\tpublic long getMinimumIdle() {\r\n\t\treturn dsource.getHikariConfigMXBean().getMinimumIdle();\r\n\t}\r\n\t\r\n//\tpublic void setMinimumIdle(int idletime) {\r\n//\t\tdsource.getHikariConfigMXBean().setMinimumIdle(idletime);\r\n//\t}\t\r\n\t\r\n\tpublic long getMaximumPoolSize() {\r\n\t\treturn dsource.getHikariConfigMXBean().getMaximumPoolSize();\r\n\t}\r\n\t\r\n//\tpublic void setMaximumPoolSize(int poolsize) {\r\n//\t\tdsource.getHikariConfigMXBean().setMaximumPoolSize(poolsize);\r\n//\t}",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/1014/comments",
    "author": "obperryo",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2017-11-10T04:39:31Z",
        "body": "@obperryo There are no known issue related to that.  Looking at the code, nothing appears to be incorrect.  What error are you getting?  Can you enable DEBUG logging, and attach a section of the log showing the pool status?\r\n"
      },
      {
        "user": "obperryo",
        "created_at": "2017-11-10T12:57:37Z",
        "body": "Got it... thanks!  I had longs instead of int for the getters.\r\n\r\n`exception name=\"Getter and setter for MaximumPoolSize have inconsistent types\"`"
      }
    ]
  },
  {
    "number": 907,
    "title": "Does HikariCP supports connection retries ?",
    "created_at": "2017-06-03T22:47:21Z",
    "closed_at": "2017-06-10T16:31:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/907",
    "body": "Hi, I'm using HikariCP together with JPA/Hibernate and jetty server, running on the cloud and I'm noticing sometimes the app is getting timeouts connecting to the database.  Is there any built-in features in Hikari to try to reconnect automatically in those cases ?\r\n\r\nthanks\r\n------------------------------------------------\r\n#### Environment\r\n```\r\nHikariCP version: 2.6.1\r\nJDK version     : 1.8.0_111\r\nDatabase        : DB2\r\nHibernate       :  5.1.0.Final\r\nDriver version  : jdbc type 4\r\n```\r\n-----------------------------------------------------------------------------------------\r\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/907/comments",
    "author": "rvillane",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2017-06-04T11:45:40Z",
        "body": "@marodriguez-llbean HikariCP *continually* tries reconnection in the background in the case of failures, with a slight time back-off if it keeps failing -- dropping down to once every 2 seconds or so.\r\n"
      },
      {
        "user": "rvillane",
        "created_at": "2017-06-05T01:01:04Z",
        "body": "in a case like the one described on this stacktrace, the app becomes unusable due to the error, do I need to add any HikariCP settings to keep retrying?\r\n\r\n`\r\nException in thread \"Thread-24\" org.hibernate.QueryTimeoutException: Unable to acquire JDBC Connection\r\n\tat org.hibernate.exception.internal.SQLExceptionTypeDelegate.convert(SQLExceptionTypeDelegate.java:66)\r\n\tat org.hibernate.exception.internal.StandardSQLExceptionConverter.convert(StandardSQLExceptionConverter.java:42)\r\n\tat org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:111)\r\n\tat org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:97)\r\n\tat org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded(LogicalConnectionManagedImpl.java:87)\r\n\tat org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getPhysicalConnection(LogicalConnectionManagedImpl.java:109)\r\n\tat org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection(StatementPreparerImpl.java:47)\r\n\tat org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare(StatementPreparerImpl.java:87)\r\n\tat org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate.prepareStatement(StatementPreparerImpl.java:172)\r\n\tat org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(StatementPreparerImpl.java:78)\r\n\tat org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl.buildBatchStatement(AbstractBatchImpl.java:136)\r\n\tat org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl.getBatchStatement(AbstractBatchImpl.java:125)\r\n\tat org.hibernate.persister.entity.AbstractEntityPersister.update(AbstractEntityPersister.java:3049)\r\n\tat org.hibernate.persister.entity.AbstractEntityPersister.updateOrInsert(AbstractEntityPersister.java:2985)\r\n\tat org.hibernate.persister.entity.AbstractEntityPersister.update(AbstractEntityPersister.java:3365)\r\n\tat org.hibernate.internal.StatelessSessionImpl.update(StatelessSessionImpl.java:208)\r\n\tat org.hibernate.internal.StatelessSessionImpl.update(StatelessSessionImpl.java:189)\r\n\tat com.llbean.purchase.history.consumer.batches.BatchesManager.saveBatch(BatchesManager.java:88)\r\n\tat com.google.inject.persist.jpa.JpaLocalTxnInterceptor.invoke(JpaLocalTxnInterceptor.java:70)\r\n\tat com.llbean.purchase.history.consumer.migration.direct.DirectOrderWorkConsumer.setWorkStatus(DirectOrderWorkConsumer.java:57)\r\n\tat com.llbean.purchase.history.consumer.migration.direct.DirectOrderWorkConsumer.updateBatchStatus(DirectOrderWorkConsumer.java:127)\r\n\tat com.llbean.purchase.history.consumer.migration.direct.DirectOrderWorkConsumer.executeWorkers(DirectOrderWorkConsumer.java:107)\r\n\tat com.llbean.purchase.history.consumer.migration.direct.DirectOrderWorkConsumer.runExtractionLoop(DirectOrderWorkConsumer.java:77)\r\n\tat com.llbean.purchase.history.consumer.core.PurchaseHistoryContextListener.lambda$withInjector$0(PurchaseHistoryContextListener.java:58)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\nCaused by: java.sql.SQLTimeoutException: Timeout after 30001ms of waiting for a connection.\r\n\tat com.zaxxer.hikari.pool.BaseHikariPool.getConnection(BaseHikariPool.java:233)\r\n\tat com.zaxxer.hikari.pool.BaseHikariPool.getConnection(BaseHikariPool.java:183)\r\n\tat com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:93)\r\n\tat org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122)\r\n\tat org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection(AbstractSessionImpl.java:386)\r\n\tat org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded(LogicalConnectionManagedImpl.java:84)\r\n\t... 20 more\r\n`\r\n"
      }
    ]
  },
  {
    "number": 877,
    "title": "HikariCP has been closed occured when change the properties",
    "created_at": "2017-04-27T02:16:24Z",
    "closed_at": "2017-04-27T05:25:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/877",
    "body": "#### Environment\r\n```\r\nHikariCP version: 2.5.1\r\nJDK version     : 1.8.0_111\r\nDatabase        :MySQL\r\nDriver version  : mysql-connector-java.jar 5.1.40\r\n```\r\n-----------------------------------------------------------------------------------------\r\n\r\nHi,\r\nwhen i write code like : \r\n`hikariDataSource.setJdbcUrl(dataSourceInfo.connUrl);\r\n            hikariDataSource.setUsername(dataSourceInfo.userName);\r\n            hikariDataSource.setPassword(dataSourceInfo.password);\r\n`\r\nthen i use jdbcTemplate todo some sql \r\nthe  exception -\"HikariCP has been closed\" occured \r\nhow can i fix it ? \r\n\r\n\r\nerror like \r\n\r\n\r\n`org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get\r\nJDBC Connection; nested exception is java.sql.SQLException:\r\nHikariDataSource HikariDataSource (HikariPool-7) has been closed.\r\n   at\r\norg.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:80)\r\n   at\r\norg.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:394)\r\n   at\r\norg.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:474)\r\n   at\r\norg.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:484)\r\n   at\r\norg.springframework.jdbc.core.JdbcTemplate.queryForObject(JdbcTemplate.java:494)\r\n   at\r\norg.springframework.jdbc.core.JdbcTemplate.queryForMap(JdbcTemplate.java:489)\r\n   \r\nCaused by: java.sql.SQLException: HikariDataSource HikariDataSource\r\n(HikariPool-7) has been closed.\r\n   at\r\ncom.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:79)\r\n   at\r\norg.springframework.jdbc.datasource.DataSourceUtils.doGetConnection(DataSourceUtils.java:111)\r\n   at\r\norg.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:77)\r\n   ... 10 more`",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/877/comments",
    "author": "calmking",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2017-04-27T05:25:31Z",
        "body": "Something about your spring configuration is destroying/closing the pool.  You might try to enable DEBUG logging for the package ``com.zaxxer.hikari`` to see if it provides more diagnostic information.  Other than that, I recommend asking on the Spring forums or stackoverflow.com.\r\n"
      },
      {
        "user": "calmking",
        "created_at": "2017-04-27T05:55:32Z",
        "body": "Thanks ,I will check the debug logging."
      },
      {
        "user": "prithvirajv",
        "created_at": "2018-04-15T20:14:01Z",
        "body": "@calmking  Any solution? i am facing the same issue"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2018-04-16T11:20:05Z",
        "body": "What version of HikariCP are you using?"
      }
    ]
  },
  {
    "number": 859,
    "title": "Will the pool offer invalid connection to users and will it automatically reconnect?",
    "created_at": "2017-04-06T01:39:25Z",
    "closed_at": "2017-04-06T05:54:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/859",
    "body": "In my project I always receive a \"Connection is not available, request timed out after\" error,I'm not sure if it is because the pool offered me a invalid connection even after the check. And I am also not sure what the pool will do with an invalid connection",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/859/comments",
    "author": "gggllm",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2017-04-06T05:54:36Z",
        "body": "@gggllm The *\"Connection is not available, request timed out after...\"* error indicates that the pool is at maximum capacity, and all connections are in-use, at the time that a thread called ``getConnection()``.  Not only that, it indicates that the thread waited in ``getConnection()`` for the ``connectionTimeout`` period, hoping that a connection would be returned to the pool, but no connection became available.\r\n\r\n It does not indicate that HikariCP offered you an invalid connection; that should be nearly impossible for HikariCP to do.\r\n\r\nThere are two common conditions that are responsible for that error:\r\n\r\nOne is a connection leak.  In that case, connections are being borrowed but never returned.  Eventually the pool will run out of connections and your application will be stuck forever.  I recommend enabling the ``leakDetectionThreshold`` and setting it to 2x the value of ``connectionTimeout``.  If you see leak warnings in your log, it should provide a stacktrace pointing to the source of the leak.\r\n\r\nThe other common cause of that error is simply long-running queries -- queries that execute for longer than the ``connectionTimeout`` period.  In that case, it is possible to have all connections occupied with such queries, preventing a new thread from acquiring a connection from the pool before ``connectionTimeout`` is reached.\r\n"
      },
      {
        "user": "gggllm",
        "created_at": "2017-04-06T05:56:21Z",
        "body": "Thank you very much！"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2017-04-06T05:58:30Z",
        "body": "@gggllm You're welcome."
      }
    ]
  },
  {
    "number": 855,
    "title": "NoClassDefFoundError PGSQL",
    "created_at": "2017-03-29T22:11:35Z",
    "closed_at": "2017-03-31T09:43:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/855",
    "body": "#### Environment\r\n```\r\nHikariCP version: 2.6.1\r\nJDK version     : 1.8.0_111\r\nDatabase        : PostgreSQL|MySQL|...\r\nDriver version  : 9.4.1212\r\n```\r\n\r\nCaught this exception once during normal operations, was unable to reproduce it again by the same chain of calls\r\n-----------------------------------------------------------------------------------------\r\n\r\n```\r\njava.lang.NoClassDefFoundError: org/postgresql/core/EncodingPredictor$DecodeResult\r\n  at org.postgresql.core.PGStream.receiveErrorString(PGStream.java:350)\r\n  at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2448)\r\n  at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:2155)\r\n  at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:288)\r\n  at org.postgresql.jdbc.PgStatement.executeInternal(PgStatement.java:430)\r\n  at org.postgresql.jdbc.PgStatement.execute(PgStatement.java:356)\r\n  at org.postgresql.jdbc.PgStatement.executeWithFlags(PgStatement.java:303)\r\n  at org.postgresql.jdbc.PgStatement.executeCachedSql(PgStatement.java:289)\r\n  at org.postgresql.jdbc.PgStatement.executeWithFlags(PgStatement.java:266)\r\n  at org.postgresql.jdbc.PgStatement.executeQuery(PgStatement.java:233)\r\n  at com.zaxxer.hikari.pool.ProxyStatement.executeQuery(ProxyStatement.java:108)\r\n  at com.zaxxer.hikari.pool.HikariProxyStatement.executeQuery(HikariProxyStatement.java)\r\n```",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/855/comments",
    "author": "dd1337",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2017-03-31T09:43:39Z",
        "body": "Doesn't make much sense, but could be caused by two versions of the PostgreSQL driver in your path.\r\n"
      }
    ]
  },
  {
    "number": 852,
    "title": "How to catch and report \"Apparent connection leak detected\"",
    "created_at": "2017-03-27T07:49:14Z",
    "closed_at": "2017-03-27T12:07:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/852",
    "body": "I would like to report that exceptions to our error reporting system.\r\n\r\nHow can I add a handler for it?\r\n```\r\nConnection leak detection triggered for com.mysql.cj.jdbc.ConnectionImpl@73b44161, stack trace follows\r\n java.lang.Exception: Apparent connection leak detected\r\n\tat org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122) ~[garuda-payments-1.3-all.jar:?]\r\n\tat org.hibernate.internal.NonContextualJdbcConnectionAccess.obtainConnection(NonContextualJdbcConnectionAccess.java:35) ~[garuda-payments-1.3-all.jar:?]\r\n\tat org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded(LogicalConnectionManagedImpl.java:99) ~[garuda-payments-1.3-all.jar:?]\r\n....\r\n```",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/852/comments",
    "author": "Paxa",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2017-03-27T12:07:45Z",
        "body": "@Paxa There is no inherent handler capability for this.  Most of the logging frameworks, like log4j, have appenders that can send events to syslog (``SyslogAppender``) or perform HTTP post operations.  You might consider one of those.  Alternatively, there are frameworks like LogStash that can monitor ordinary log files and send various kinds of notifications.\r\n"
      },
      {
        "user": "Paxa",
        "created_at": "2017-03-27T17:59:33Z",
        "body": "Thank you"
      }
    ]
  },
  {
    "number": 841,
    "title": "Is there a way to limit number of statements per connection?",
    "created_at": "2017-03-17T19:23:36Z",
    "closed_at": "2017-03-18T03:14:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/841",
    "body": "i haven't seen any post about the limit.",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/841/comments",
    "author": "qinfchen",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2017-03-18T03:14:24Z",
        "body": "There is no limit in the JDBC specification, so there is no limit in HikariCP."
      }
    ]
  },
  {
    "number": 820,
    "title": "2.3.9 to 2.4.11 - 25% Degradation of Performance",
    "created_at": "2017-02-08T22:33:00Z",
    "closed_at": "2017-02-13T22:55:43Z",
    "labels": [
      "more-information-needed",
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/820",
    "body": "First of all, I want to thank you for your timely response to issue #600. The latest \"*-java7\" artifact (2.4.11) is functional on Java 7. Unfortunately, after upgrading from 2.3.9, we've seen about a 25% degradation of performance, measured in \"transactions\" per second with our software.\r\n\r\nOur automated performance tests were run against our product using the commits immediately preceding / following the HikariCP dependency change in the POM.\r\n\r\nI am in the process of digging for more information, but I was wondering if you would be able to either:\r\n\r\n1) Perform your benchmarks using the two aforementioned versions to corroborate the issue we're seeing\r\n2) Explain any legitimate reason why the performance would have degraded (e.g. it's performing additional work that is necessary for the stability and reliability of the connection pool)\r\n3) Tell us that everything is fine, nothing is broken, and the issue is solely our fault\r\n\r\nThis presents once the service is under load (~100 concurrent Tomcat threads). Aside from a change from HikariCP 2.3.9:*-java6 to 2.4.11:*-java7, the performance testing environment remained exactly the same. I've double and triple checked many of the fine details with them, and I requested the pertinent configuration files from both runs to verify that nothing had changed. I've explained to them that our default configuration of a minimum pool size of 5 and a maximum pool size of 90 is not ideal for a box with 8 physical (16 logical) cores and an SSD, but those settings were consistent across all of their test runs. After rolling back to 2.3.9:*-java6, performance returned to normal.\r\n\r\nFor now, we are okay with rolling back to 2.3.9:*-java6, but would like to benefit from the many changes that have taken place since. I've read through the documentation for any significant configuration changes, but didn't see anything that I perceived to be pertinent.\r\n\r\nIf more details come to light, I will make sure to share them here.\r\n\r\nThank you!",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/820/comments",
    "author": "andysenn",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2017-02-09T03:03:06Z",
        "body": "@andysenn \r\n\r\nJust as a level set I ran our standard benchmark on 2.3.9:\r\n```\r\nBenchmark                       (jdbcUrl)  (maxPoolSize)  Mode  Cnt      Score      Error   Units\r\nConnectionBench.cycleCnnection  jdbc:stub             32  thrpt   16   9749.378 ±  201.532  ops/ms\r\nStatementBench.cycleStatement   jdbc:stub             32  thrpt   16  57119.593 ± 4468.053  ops/ms\r\n```\r\nAnd on 2.4.11:\r\n```\r\nBenchmark                       (jdbcUrl)  (maxPoolSize)  Mode  Cnt      Score       Error   Units\r\nConnectionBench.cycleCnnection  jdbc:stub             32  thrpt   16  43880.048 ±  3210.205  ops/ms\r\nStatementBench.cycleStatement   jdbc:stub             32  thrpt   16  94296.275 ± 10887.648  ops/ms\r\n```\r\nSo, at a high-level, at least at the application→pool layer, things should be faster.  It is going to take some more investigation to see what is occurring at the pool→DB layer that could be affecting performance.\r\n\r\nCan you tell me what JVM version you guys are running (e.g. 1.7.0_55-b13)?  And the exact pool configuration (excluding passwords, of course)?\r\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2017-02-09T03:09:44Z",
        "body": "@andysenn Also, is it possible to run the pool with debug logging enabled for the ``com.zaxxer.hikari`` package and collect some of the logs from the run?\r\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2017-02-09T08:31:01Z",
        "body": "@andysenn It would still like to see the configuration, and debug log, but having looked at the differences between 2.3.9 and 2.4.11 I did spot one difference.\r\n\r\n#### Alive Bypass Window\r\nHikariCP (all versions) contains an optimization that basically says, \"If a connection was used within the last X milliseconds, skip the connection validation check because we assume it is still valid.\"  We call this the \"alive bypass window\".\r\n\r\nIn v2.3.9, the bypass window size was 1000ms.  In v2.4.11, the bypass window is 500ms.  And in v2.6.0, which you are not using, the bypass window is now 250ms.\r\n\r\nSo, Hypothesis One is that in under load, probably due to OS thread scheduling (if there are indeed 100 threads), connections are sitting in the pool beyond the 500ms v2.4.11 bypass cutoff.  For example, under v2.3.9, if a connection was returned by not borrowed for 700ms, it still fell under the 1000ms bypass cutoff and would not be validated.  But under v2.4.11, the same connection *would* be validated.\r\n\r\nWhile validation is typically not that expensive, it is still a roundtrip to the database, and if it were occurring with higher frequency you would observe a difference.\r\n\r\nIf you want to test Hypothesis One, in **v2.4.11** you can set a system property that controls the bypass window size to the same as v2.3.9, then run your load test again:\r\n```\r\n-Dcom.zaxxer.hikari.aliveBypassWindowMs=1000\r\n```\r\nConversely, if you want to run **v2.3.9** and bump the bypass window *down* to the same as v2.4.11, you could do that as well.  Note that the property name changed slightly, so if you want to set it for v2.3.9 then use:\r\n```\r\n-Dcom.zaxxer.hikari.aliveBypassWindow=500\r\n```\r\nIf the load test still shows a discrepancy between v2.3.9 ad v2.4.11, we'll need to dig further (\\*cough\\* logs).\r\n"
      },
      {
        "user": "andysenn",
        "created_at": "2017-02-13T22:55:43Z",
        "body": "I'm going to go ahead and close this for now. I don't feel good about the current state of this issue. I feel like something is amiss in our performance testing environment, but my team doesn't have full visibility into it. I'm working on doing some testing of my own, and I'm not seeing the results they're seeing. I will re-open this if I find anything groundbreaking.\r\n\r\nI apologize for the inconvenience. I am shamed, sir. :)"
      }
    ]
  },
  {
    "number": 818,
    "title": "Mysql connection keep on increasing even after maxpoolsize",
    "created_at": "2017-01-28T13:40:29Z",
    "closed_at": "2017-02-13T14:40:54Z",
    "labels": [
      "more-information-needed",
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/818",
    "body": "Hi\r\nI have below configuration for Hikari for mysql server using from Java:\r\nmaxPoolSize = 5\r\nidleTimeout = 600000\r\ncheckConnection = Select 1\r\n\r\nBut still mysql connection keep on increasing and not just limiting to defined maxPoolSize.\r\nI have stopped all the processes on the server and just my application is running to make sure it connections are not been created from somewhere else.\r\nCan you please help me out here.",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/818/comments",
    "author": "AnshulJain1985",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2017-01-28T15:51:55Z",
        "body": "@AnshulJain1985 Please enable debug logging for the package ``com.zaxxer.hikari``, you should see a log entry for every created connection.\r\n\r\nIf HikariCP was so broken as to exceed the maxPoolSize limit then nobody would use it; something else is going on in your application.\r\n\r\nAlso, ``checkConnection`` is not a valid property, I don't know where you got that from.\r\n"
      },
      {
        "user": "AnshulJain1985",
        "created_at": "2017-01-28T15:56:32Z",
        "body": "Sorry its connectionInitSql. We have named it checkConnection.\r\nI will enable debug logs and provide you the details. I was also wondering the same but I was trying to debug since morning but not able to find anything.\r\nThanks for your response.\r\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2017-02-13T11:43:44Z",
        "body": "@AnshulJain1985 Can you provide an update on this issue?\r\n"
      },
      {
        "user": "AnshulJain1985",
        "created_at": "2017-02-13T14:40:54Z",
        "body": "You can close this issue. I am not able to find the issue even after digging for a week. Atlast I recreate my server and yesterday and now it is working fine. I have even compare the mysql parameters its exactly same. Thanks for followup."
      }
    ]
  },
  {
    "number": 807,
    "title": "How to configure Play to being able to configure HikariCP via the hikaricp.properties file",
    "created_at": "2017-01-09T14:34:30Z",
    "closed_at": "2017-01-10T00:30:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/807",
    "body": "Hello,\r\n\r\nI ported our application using play to the newest version and learned that it now uses the HikariCP. We have been configuring jdbc in a specific manner and I see that HikariCP can configure jdbc via a properties file. It seems that for a certain old Hikari plugin for play it was possible to set the file using the following setting in the application.conf:\r\n\r\n       db.default.hikaricp.file=\"conf/hikaricp.properties\"\r\n\r\nHow can this be achieved now that HikariCP is the default connection pool and the plugin is not necessary anymore?",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/807/comments",
    "author": "benelot",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2017-01-10T00:30:16Z",
        "body": "@benelot This is a question for Play, we have no idea."
      },
      {
        "user": "benelot",
        "created_at": "2017-01-10T07:44:54Z",
        "body": "Thanks for the quick answer. I thought you would probably know since I expected that they asked you how to do it best. Good work, keep it up!"
      }
    ]
  },
  {
    "number": 733,
    "title": "Probably connection leak on HikariCP 2.3.7",
    "created_at": "2016-09-27T03:26:06Z",
    "closed_at": "2016-09-27T04:02:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/733",
    "body": "Hi, \nI've been experiencing a strange behaviour of HikariCP: after some time the maximum available is reduced under the assigned value and never when back to the assigned value.\n\n```\nSep 25 20:44:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:44:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:44:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:45:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:45:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:45:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:45:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:45:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:45:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:46:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:46:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:46:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:46:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:46:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:46:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:47:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:47:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:47:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:47:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:47:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:47:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 at 8:48 PM\nSep 25 20:48:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:48:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:48:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:48:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:48:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:48:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=3, inUse=0, avail=3, waiting=0)\nSep 25 20:48:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] c.zaxxer.hikari.pool.PoolUtilities: Closing connection com.mysql.jdbc.JDBC4Connection@3d605089\nSep 25 20:48:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] c.zaxxer.hikari.pool.PoolUtilities: Closing connection com.mysql.jdbc.JDBC4Connection@33a7a955\nSep 25 20:48:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] c.zaxxer.hikari.pool.PoolUtilities: Closing connection com.mysql.jdbc.JDBC4Connection@37983bf9\nSep 25 20:49:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=0, inUse=0, avail=0, waiting=0)\nSep 25 20:49:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=0, inUse=0, avail=0, waiting=0)\nSep 25 20:49:27 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] c.zaxxer.hikari.pool.PoolUtilities: Closing connection null\nSep 25 20:49:27 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:49:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:49:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:49:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:50:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:50:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:50:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:50:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:50:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:50:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:51:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:51:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:51:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:51:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:51:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:51:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:52:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:52:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:52:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:52:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:52:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:52:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:53:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:53:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:53:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:53:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:53:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:53:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:54:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:54:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:54:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:54:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:54:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:54:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:55:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:55:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:55:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:55:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:55:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:55:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:56:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:56:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:56:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:56:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:56:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:56:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:57:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:57:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:57:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:57:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:57:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:57:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:58:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:58:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:58:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:58:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:58:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:58:55 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:59:24 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: Before cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:59:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After cleanup pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:59:25 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] com.zaxxer.hikari.pool.HikariPool: After fill pool stats HikariPool-0 (total=2, inUse=0, avail=2, waiting=0)\nSep 25 20:59:27 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] c.zaxxer.hikari.pool.PoolUtilities: Closing connection com.mysql.jdbc.JDBC4Connection@45900988\nSep 25 20:59:28 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec-4cd2-8618-ea41766ad53e - [DEBUG] c.zaxxer.hikari.pool.PoolUtilities: Closing connection com.mysql.jdbc.JDBC4Connection@4b57ff4a\nSep 25 20:59:54 wms-qc-staging wms-api-stag-70-wms-qc-rc-i04au:  ReqID c8644e88-8fec\n\n```\n\nFirst I thought I had a connection leak somewhere because my code, so I activated the leak detection but the log shows nothing. \nI also reduced the connection lifetime from the default value: 30 minutes to 10 minutes. This has been a temporary solution, with this the phenomenon reduced from occurring on daily basis to around almost weekly basis.  \n\nNotes:\nI'm using a play 2.4.6 with HikariCP 2.3.7.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/733/comments",
    "author": "burungbangkai",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-09-27T04:02:19Z",
        "body": "@burungbangkai Thank you for using HikariCP.  Unfortunately, we do not provide support for back-level versions.  There have been dozens of significant reliability improvements and stability bugs fixed since 2.3.7 was released 18 months ago.\n\nI recommend that you upgrade to HikariCP 2.5.1 (or 2.4.9 on Java7).  If you still encounter the error after upgrading, please add a comment here.\n"
      }
    ]
  },
  {
    "number": 728,
    "title": "HikariCP as JNDI resource in Tomcat",
    "created_at": "2016-09-22T06:37:44Z",
    "closed_at": "2016-09-23T02:41:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/728",
    "body": "Hi, please could you help me with this problem, i tried many approaches to fix my problem but with no success so far. When i run my app i have set DEBUG mode fir HikariCP and see this exception\n\n`2016-09-22 06:19:34,808 DEBUG HikariPool.?               HikariPool-2 - Pool stats (total=1, active=0, idle=1, waiting=0)\n2016-09-22 06:19:44,818 DEBUG HikariPool.?               HikariPool-2 - Cannot acquire connection from data source\njava.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 40000ms.\n    at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:196) [HikariCP-2.4.6.jar:na]\n    at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:147) [HikariCP-2.4.6.jar:na]\n    at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:83) ~[HikariCP-2.4.6.jar:na]\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_65]\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_65]\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_65]\n    at java.lang.reflect.Method.invoke(Method.java:497) ~[na:1.8.0_65]\n    at net.bull.javamelody.JdbcWrapper$3.invoke(JdbcWrapper.java:805) ~[javamelody-core-1.60.0.jar:1.60.0]\n    at net.bull.javamelody.JdbcWrapper$DelegatingInvocationHandler.invoke(JdbcWrapper.java:286) ~[javamelody-core-1.60.0.jar:1.60.0]\n    at com.sun.proxy.$Proxy7.getConnection(Unknown Source) ~[na:na]\n    at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:316) ~[HikariCP-2.4.6.jar:na]\n    at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:173) ~[HikariCP-2.4.6.jar:na]\n    at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:443) [HikariCP-2.4.6.jar:na]\n    at com.zaxxer.hikari.pool.HikariPool.access$500(HikariPool.java:66) [HikariCP-2.4.6.jar:na]\n    at com.zaxxer.hikari.pool.HikariPool$PoolEntryCreator.call(HikariPool.java:568) [HikariCP-2.4.6.jar:na]\n    at com.zaxxer.hikari.pool.HikariPool$PoolEntryCreator.call(HikariPool.java:561) [HikariCP-2.4.6.jar:na]\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266) [na:1.8.0_65]\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_65]\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_65]\n    at java.lang.Thread.run(Thread.java:745) [na:1.8.0_65]\n`\n\nand in case od restart my app im tomcat manager HikariCP is not releasing conncetions from Psql DB.\nThis is my Hikari config:\n\n`<Resource name=\"jdbc/PsqlHikari\" auth=\"Container\"\n        factory=\"com.zaxxer.hikari.HikariJNDIFactory\"\n        type=\"javax.sql.DataSource\"\n        maximumPoolSize=\"1\"\n        cachePrepStmts=\"true\"\n        prepStmtCacheSize=\"250\"\n        prepStmtCacheSqlLimit=\"2048\"\n        useServerPrepStmts=\"true\"\n    connectionTestQuery=\"select 1\"\n    connectionTimeout=\"40000\"\n        ssl=\"true\"\n        sslfactory=\"org.postgresql.ssl.NonValidatingFactory\"\n        dataSourceClassName=\"org.postgresql.ds.PGPoolingDataSource\"\n        dataSource.url=\"jdbc:postgresql://localhost:5433/mytest\"\n        dataSource.user=\"myuser\"\n        dataSource.password=\"pass\" />\n`\n\nand i am using postgresql-9.3-1103.jdbc3.jar and HikariCP-2.4.6.jar. I also tried various version of psql driver and HikariCP.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/728/comments",
    "author": "stockstatus",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-09-23T02:41:45Z",
        "body": "@stockstatus This is a tomcat question, of which we know very little about, please ask this question on stackoverflow.\n"
      }
    ]
  },
  {
    "number": 722,
    "title": "My player are kicked very often.",
    "created_at": "2016-09-16T13:56:06Z",
    "closed_at": "2016-09-20T17:52:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/722",
    "body": "Hi my players are kicked very often.\nGot this in console:\n\n[15:05:07] [Craft Scheduler Thread - 414/WARN]: [AuthMe] Error during SQL operation: [SQLTransientConnectionException]: AuthMeMYSQLPool - Connection is not available, request timed out after 30000ms.\n[15:05:07] [Craft Scheduler Thread - 411/WARN]: [AuthMe] Error during SQL operation: [SQLTransientConnectionException]: AuthMeMYSQLPool - Connection is not available, request timed out after 30000ms.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/722/comments",
    "author": "dadee971",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-09-17T08:29:37Z",
        "body": "@dadee971 You might try enabling `leakDetectionThreshold` and enabling debug logging for the `com.zaxxer.hikari` package.\n"
      }
    ]
  },
  {
    "number": 711,
    "title": "Reconnect on io exceptions",
    "created_at": "2016-09-01T14:03:44Z",
    "closed_at": "2016-09-13T18:59:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/711",
    "body": "Is it possible to configure HikariCP to reconnect to DB in case of IO exceptions (e.g. db server was not available for few seconds/minutes) (repeats count / timeout)? \n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/711/comments",
    "author": "fedotxxl",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-09-01T15:48:30Z",
        "body": "@fedotxxl It should do so already.\n\nIf it did not close and re-open connections, can you enable debug logging for the `com.zaxxer.hikari` package and simulate the failure again?  We would like to know what the SQLState code was in the SQLException thrown by the driver.\n"
      },
      {
        "user": "fedotxxl",
        "created_at": "2016-09-02T09:02:52Z",
        "body": "We've got an exception\n\n```\nWARN  c.z.hikari.proxy.ConnectionProxy - Connection org.postgresql.jdbc4.Jdbc4Connection@778ded48 (HikariPool-0) marked as broken because of SQLSTATE(57P01), ErrorCode(\n0).\norg.postgresql.util.PSQLException: FATAL: terminating connection due to administrator command\n```\n\nIs it possible to configure how many times HikariCP will try to reconnect / delay between tries (in millis)?\n"
      },
      {
        "user": "fedotxxl",
        "created_at": "2016-09-13T08:56:39Z",
        "body": "@brettwooldridge Can you comment it? Is it possible to configure repeats count / delays between tries?\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2016-09-13T18:58:53Z",
        "body": "@fedotxxl HikariCP is designed to retry forever (in an independent thread).  The delay between retries will slowly increase from 250ms up to `connectionTimeout` (30 seconds by default).\n"
      }
    ]
  },
  {
    "number": 708,
    "title": "Can't catch Exception on call \"new HikariDataSource()\"",
    "created_at": "2016-08-30T15:55:48Z",
    "closed_at": "2016-08-31T13:50:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/708",
    "body": "Hi,\n\nI have a problem with catching an exception. \n\nFirst i show you my code:\n\n```\ntry\n{\n    ....\n    final HikariConfig databaseconfig = new HikariConfig();\n    ....\n    hikari = new HikariDataSource(databaseconfig);    <<--- ther is the problem\n    ....\n}\ncatch(Exception e)\n{\n    e.printStackTrace();\n}\n```\n\nnow, if i use the wrong Login dates(for testing dumbest assumable user), i get this exception:\n\n```\n30.08 17:26:10 [Server] INFO [MySQL] Enabling MySQL v1.0.1-SNAPSHOT\n30.08 17:26:11 [Server] WARN com.zaxxer.hikari.pool.HikariPool$PoolInitializationException: Failed to initialize pool: Communications link failure\n30.08 17:26:11 [Server] INFO The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.\n30.08 17:26:11 [Server] WARN at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:516)\n30.08 17:26:11 [Server] WARN at com.zaxxer.hikari.pool.HikariPool.<init>(HikariPool.java:118)\n30.08 17:26:11 [Server] WARN at com.zaxxer.hikari.HikariDataSource.<init>(HikariDataSource.java:71)\n30.08 17:26:11 [Server] WARN at de.derspielpirat.mysql.MySQL.configureConnPool(MySQL.java:151)\n30.08 17:26:11 [Server] WARN at de.derspielpirat.mysql.MySQL.onEnableSetup(MySQL.java:64)\n30.08 17:26:11 [Server] WARN at de.derspielpirat.origin.DSPJavaPlugin.onEnable(DSPJavaPlugin.java:34)\n30.08 17:26:11 [Server] WARN at org.bukkit.plugin.java.JavaPlugin.setEnabled(JavaPlugin.java:292)\n30.08 17:26:11 [Server] WARN at org.bukkit.plugin.java.JavaPluginLoader.enablePlugin(JavaPluginLoader.java:340)\n30.08 17:26:11 [Server] WARN at org.bukkit.plugin.SimplePluginManager.enablePlugin(SimplePluginManager.java:405)\n30.08 17:26:11 [Server] WARN at org.bukkit.craftbukkit.v1_10_R1.CraftServer.enablePlugin(CraftServer.java:373)\n30.08 17:26:11 [Server] WARN at org.bukkit.craftbukkit.v1_10_R1.CraftServer.enablePlugins(CraftServer.java:323)\n30.08 17:26:11 [Server] WARN at net.minecraft.server.v1_10_R1.MinecraftServer.t(MinecraftServer.java:412)\n30.08 17:26:11 [Server] WARN at net.minecraft.server.v1_10_R1.MinecraftServer.l(MinecraftServer.java:377)\n30.08 17:26:11 [Server] WARN at net.minecraft.server.v1_10_R1.MinecraftServer.a(MinecraftServer.java:332)\n30.08 17:26:11 [Server] WARN at net.minecraft.server.v1_10_R1.DedicatedServer.init(DedicatedServer.java:271)\n30.08 17:26:11 [Server] WARN at net.minecraft.server.v1_10_R1.MinecraftServer.run(MinecraftServer.java:535)\n30.08 17:26:11 [Server] WARN at java.lang.Thread.run(Thread.java:745)\n30.08 17:26:11 [Server] WARN Caused by: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure\n30.08 17:26:11 [Server] INFO The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.\n30.08 17:26:11 [Server] WARN at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n30.08 17:26:11 [Server] WARN at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n30.08 17:26:11 [Server] WARN at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n30.08 17:26:11 [Server] WARN at java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n30.08 17:26:11 [Server] WARN at com.mysql.jdbc.Util.handleNewInstance(Util.java:404)\n30.08 17:26:11 [Server] WARN at com.mysql.jdbc.SQLError.createCommunicationsException(SQLError.java:983)\n30.08 17:26:11 [Server] WARN at com.mysql.jdbc.MysqlIO.<init>(MysqlIO.java:339)\n```\n\nso i looked for the exception and i find this peace of code in HikariCP:\n\n```\n/**\n    * Fill the pool up to the minimum size.\n    */\n   private void checkFailFast()\n   {\n      if (config.isInitializationFailFast()) {\n         try {\n            newConnection().close();\n         }\n         catch (Throwable e) {\n            try {\n               shutdown();\n            }\n            catch (Throwable ex) {\n               e.addSuppressed(ex);\n            }\n\n            throw new PoolInitializationException(e);        <<--- right there\n         }\n      }\n   }\n```\n\nthere is thrown an exception but the method does not have an \"throws PoolInitializationException\" or handle the exception on an other way. So i cant realy do something against this exception or catch them.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/708/comments",
    "author": "Wolf2323",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-08-31T13:50:15Z",
        "body": "@Wolf2323 `PoolInitializationException` is a `RuntimeException`, and your example try-catch code will surely catch it.  It is likely that `e.printStackTrace()` is not going to show anything visible if a logging framework is present.  But if you run the code under a debugger, and set a breakpoint in that `catch` you'll see that the exception is indeed caught.\n"
      },
      {
        "user": "kailashpandey0101",
        "created_at": "2018-12-25T18:39:03Z",
        "body": "@brettwooldridge  in above case , it did caught the exception like you said. But when i change the db password while the application is running, it will eventually throw java.sql.SQLException: but the try block won't catch it afterwards. I am trying to figure out how to catch whenever password get changed and this exception get's thrown."
      },
      {
        "user": "brettwooldridge",
        "created_at": "2018-12-29T06:57:17Z",
        "body": "The above discussion and exception are only related to pool initialization at startup.  If you change the password at runtime, the pool is already started.\r\n\r\nIf the password is incorrect, you will eventually get timeout exceptions when calling getConnection().  Calling getNextException() on *that* SQLException should give you the native driver’s SQLException."
      },
      {
        "user": "anujocpdba431",
        "created_at": "2019-01-05T19:33:48Z",
        "body": "Hey brettwooldridge,\r\n\r\nwe are getting same issue our platform. please help from the logs.\r\n\r\n[app.services][ERROR][2019-01-03T13:17:34.750+04:00]:[]:[]:[]:[Timer-5]:[com.kony.rdbms.connection.AnnotatedJDBCConnectionManager:intialize:70]:Failed to create connection pool: Failed to initialize pool: Communications link failure\r\n\r\nThe last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.\r\ncom.zaxxer.hikari.pool.HikariPool$PoolInitializationException: Failed to initialize pool: Communications link failure\r\n\r\nThe last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.\r\n\tat com.zaxxer.hikari.pool.HikariPool.throwPoolInitializationException(HikariPool.java:568) ~[HikariCP-2.7.4.jar:?]\r\n\tat com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:554) ~[HikariCP-2.7.4.jar:?]\r\n\tat com.zaxxer.hikari.pool.HikariPool.<init>(HikariPool.java:114) ~[HikariCP-2.7.4.jar:?]\r\n\tat com.zaxxer.hikari.HikariDataSource.<init>(HikariDataSource.java:72) ~[HikariCP-2.7.4.jar:?]\r\n\tat com.kony.rdbms.connection.HikariCpConnectionPool.<init>(HikariCpConnectionPool.java:57) ~[RDBMSDataAdapter-8.2.0.10.jar:?]\r\n\tat com.kony.rdbms.connection.RDBMSConnectionPoolFactory.getRdbmsConnectionPool(RDBMSConnectionPoolFactory.java:11) ~[RDBMSDataAdapter-8.2.0.10.jar:?]\r\n\tat com.kony.rdbms.connection.AnnotatedJDBCConnectionManager.intialize(AnnotatedJDBCConnectionManager.java:68) [RDBMSDataAdapter-8.2.0.10.jar:?]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_181]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_181]\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_181]\r\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_181]\r\n\tat org.apache.commons.beanutils.MethodUtils.invokeExactMethod(MethodUtils.java:402) [commons-beanutils-1.9.2.jar:1.9.2]\r\n\tat org.apache.commons.beanutils.MethodUtils.invokeExactMethod(MethodUtils.java:352) [commons-beanutils-1.9.2.jar:1.9.2]\r\n\tat com.kony.dataadapter.annotations.utilities.ReflectionUtil.invokeMethod(ReflectionUtil.java:60) [DataAdapterEngine-8.2.0.10.jar:?]\r\n\tat com.kony.dataadapter.annotations.utilities.ReflectionUtil.invokeMethod(ReflectionUtil.java:76) [DataAdapterEngine-8.2.0.10.jar:?]\r\n\tat com.kony.dataadapter.annotations.utilities.MethodUtil.executeOperation(MethodUtil.java:38) [DataAdapterEngine-8.2.0.10.jar:?]\r\n\tat com.kony.dataadapter.connection.InitializeCommand.execute(InitializeCommand.java:91) [DataAdapterEngine-8.2.0.10.jar:?]\r\n\tat com.kony.dataadapter.connection.InitializeCommand.performInitialize(InitializeCommand.java:34) [DataAdapterEngine-8.2.0.10.jar:?]\r\n\tat com.kony.dataadapter.annotations.adapter.AnnotationAdapter.initialize(AnnotationAdapter.java:144) [DataAdapterEngine-8.2.0.10.jar:?]\r\n\tat com.konylabs.middleware.connectors.dataadapter.DataAdapterTask.newOperationInitializeWithNewConnProps(DataAdapterTask.java:357) [middleware-8.2.1.1.jar:?]\r\n\tat com.konylabs.middleware.connectors.dataadapter.DataAdapterTask.newOperationInitialize(DataAdapterTask.java:326) [middleware-8.2.1.1.jar:?]\r\n\tat com.konylabs.middleware.connectors.dataadapter.DataAdapterTask.initializeService(DataAdapterTask.java:171) [middleware-8.2.1.1.jar:?]\r\n\tat com.konylabs.middleware.connectors.dataadapter.DataAdapterTask.initializeDataAdapter(DataAdapterTask.java:141) [middleware-8.2.1.1.jar:?]\r\n\tat com.konylabs.middleware.connectors.dataadapter.DataAdapterTask.servicesIntializationTask(DataAdapterTask.java:83) [middleware-8.2.1.1.jar:?]\r\n\tat com.konylabs.middleware.connectors.dataadapter.DataAdapterUtil.performAdapterIntialization(DataAdapterUtil.java:199) [middleware-8.2.1.1.jar:?]\r\n\tat com.konylabs.middleware.timer.AbstractKonyTimer.initializeAdapterAndClearDataAdapterCache(AbstractKonyTimer.java:341) [middleware-8.2.1.1.jar:?]\r\n\tat com.konylabs.middleware.timer.KonyIntegrationServiceTimerImpl.performTimerUpdateTask(KonyIntegrationServiceTimerImpl.java:116) [middleware-8.2.1.1.jar:?]\r\n\tat com.konylabs.middleware.timer.AbstractKonyTimer.run(AbstractKonyTimer.java:91) [middleware-8.2.1.1.jar:?]\r\n\tat java.util.TimerThread.mainLoop(Timer.java:555) [?:1.8.0_181]\r\n\tat java.util.TimerThread.run(Timer.java:505) [?:1.8.0_181]\r\nCaused by: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure\r\n\r\nThe last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.\r\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[?:1.8.0_181]\r\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[?:1.8.0_181]\r\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[?:1.8.0_181]\r\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423) ~[?:1.8.0_181]\r\n\tat com.mysql.jdbc.Util.handleNewInstance(Util.java:425) ~[mysql-connector-java-5.1.44.jar:5.1.44]\r\n"
      }
    ]
  },
  {
    "number": 686,
    "title": "Connection remains active and active connection count gradually increasing till the maxConnection",
    "created_at": "2016-07-27T11:08:13Z",
    "closed_at": "2016-09-13T18:51:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/686",
    "body": "Recently I made decision to move to HikariCP.  I have done the following set configuration for the pooling.\n\n```\n    HikariConfig config = new HikariConfig();\n    Properties properties = new Properties();\n    properties.put(\"MYConnectionMetaData\", connectionProperties);\n    config.setDataSourceProperties(properties);\n\n    if(Integer.parseInt(name) == 0 || Integer.parseInt(name) == -1){\n        config.setConnectionTestQuery(getTestQuery()+name);\n    }\n\n    config.setPoolName(name);\n\n    config.setDataSourceClassName(MyDataSource.class.getName());\n    config.setAutoCommit(false);\n    config.setMinimumIdle(1);\n    config.setMaximumPoolSize(100);\n    config.setInitializationFailFast(true);\n    config.setConnectionTimeout(0);//client request\n    config.setMaxLifetime(9000);//timeout connection evicted\n\n    config.setIdleTimeout(9000);// idle time`\n    config.setRegisterMbeans(true);\n    config.setReadOnly(false);\n    config.setValidationTimeout(1200000);\n    config.setDataSourceClassName(MyDataSource.class.getName());\n\n    setMXBeanContext(config);\n\n    helthCheckRegistry(config);\n\n    config.validate();\n    return new HikariDataSource(config);\n```\n\nAfter start connection pooling I do nothing with the connection still active connection count gradually increasing till the maxConnection. And the every thing get stuck in between.\n\nHealth[Connection Pool= 1,  Healthy Pool, Idle Connection = 4, Active Connection = 0, Total Connection = 4]\nHealth[Connection Pool= 0,  Healthy Pool, Idle Connection = 1, Active Connection = 56, Total Connection = 57]\n....\nHealth[Connection Pool= -1,  Healthy Pool, Idle Connection = 1, Active Connection = 0, Total Connection = 1]\nHealth[Connection Pool= 1,  Healthy Pool, Idle Connection = 4, Active Connection = 0, Total Connection = 4]\nHealth[Connection Pool= 0,  Healthy Pool, Idle Connection = 1, Active Connection = 60, Total Connection = 61]\n....\nHealth[Connection Pool= -1,  Healthy Pool, Idle Connection = 1, Active Connection = 0, Total Connection = 1]\nHealth[Connection Pool = 1,  Healthy Pool, Idle Connection = 4, Active Connection = 0, Total Connection = 4]\nHealth[Connection Pool= 0,  Healthy Pool, Idle Connection = 1, Active Connection = 100, Total Connection = 100]\n\nSee the connection ConnectionPool 0.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/686/comments",
    "author": "sandeep27st",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-07-29T20:38:16Z",
        "body": "This look like a connection leak.  Can you enable the `leakDetectionThreshold`?\n\nPlus, this looks weird:\n\n``` java\nsetMaxLifetime(9000);//timeout connection evicted\n```\n\nThis is not \"timeout connection evicted\", this is the maximum lifetime of a connection in the pool -- which you have set to 9 seconds.  That is an extraordinarily short lifetime.\n"
      }
    ]
  },
  {
    "number": 682,
    "title": "How to enable debug?",
    "created_at": "2016-07-20T02:13:57Z",
    "closed_at": "2016-07-20T02:24:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/682",
    "body": "I compiled my plugin with slf4j-simple and added -Dorg.slf4j.simpleLogger.defaultLogLevel=debug to startup arguments, but the debug messages are not shown?\n\nAm I doing it wrong?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/682/comments",
    "author": "ItsHarry",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-07-20T02:24:37Z",
        "body": "@ItsHarry There is nothing intrinsically wrong with that, if logging is not occurring you are likely running into a separate issue (eg. runtime classpath).  Either way this is a slf4j question, so please check stackoverflow.com.\n"
      }
    ]
  },
  {
    "number": 660,
    "title": "[Postgresql] relation \"xxx\" does not exist",
    "created_at": "2016-07-01T08:09:14Z",
    "closed_at": "2016-07-05T14:00:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/660",
    "body": "org.postgresql.ds.PGSimpleDataSource was used in my project.\n\nThe query always fail with the following exception:\n\n> org.springframework.jdbc.BadSqlGrammarException: StatementCallback; bad SQL grammar [SELECT \\* FROM xxxxxx]; nested exception is org.postgresql.util.PSQLException: ERROR: relation \"xxxxxx\" does not exist\n\nBut it works correctly with bonecp.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/660/comments",
    "author": "Sel8616",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-07-05T14:00:06Z",
        "body": "That makes no sense.  HikariCP does not parse SQL grammar in any way.\n"
      },
      {
        "user": "Sel8616",
        "created_at": "2016-07-07T04:04:44Z",
        "body": "Thank you for reply.\n\nMaybe that exception was caused by PGAdmin3.\n"
      }
    ]
  },
  {
    "number": 659,
    "title": "Request for idle threads to either be validated or recycled given a configured timeout",
    "created_at": "2016-06-29T11:59:43Z",
    "closed_at": "2016-07-05T14:04:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/659",
    "body": "As things stand the idleTimeout config does not guarantee to close the connection, i.e. if that would cause the total idle connections in the pool to drop below that specified in minimumIdle.\n\nWould it be possible to alter the behaviour so that it will guarantee to either close or recycle (close and reopen) those idle connections that have timed out?\n\nIf that is not possible then could we have a testWhenIdle config, which would run the validation query periodically on idle connections.   This would prevent network devices, or the DB from killing idle connections.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/659/comments",
    "author": "stottpaul",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-07-05T14:04:37Z",
        "body": "I would suggest setting a lower `maxLifetime` in that case.  Both the `idleTimeout` and `maxLifetime` should be set to a time lower than the database's native timeouts.  If properly configured in that way, HikariCP should never encounter a timed-out connection.\n"
      }
    ]
  },
  {
    "number": 655,
    "title": "Is 'dirtyBits & DIRTY_BIT_AUTOCOMMIT) != 0' useless in PoolBase.resetConnectionState method",
    "created_at": "2016-06-23T03:13:04Z",
    "closed_at": "2016-06-29T15:17:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/655",
    "body": "```\n    if ((dirtyBits & DIRTY_BIT_AUTOCOMMIT) != 0 && proxyConnection.getAutoCommitState() != isAutoCommit) {\n        connection.setAutoCommit(isAutoCommit);\n        resetBits |= DIRTY_BIT_AUTOCOMMIT;\n    }\n```\n\nBecause the autocommit state has been checked by 'proxyConnection.getAutoCommitState() != isAutoCommit', why is the 'dirtyBits & DIRTY_BIT_AUTOCOMMIT) != 0 ' statement still used?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/655/comments",
    "author": "kenny319",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-06-29T15:17:57Z",
        "body": "@kenny319 It is checked because `ProxyConnection.getAutoCommit()` unconditionally sets `dirtyBits |= DIRTY_BIT_AUTOCOMMIT`.  However, the user may start at `autoCommit=true`, set it to `autoCommit=false`, and then reset it to `autoCommit=true`.  In this case, `dirtyBits & DIRTY_BIT_AUTOCOMMIT) != 0` is true, however the actual autocommit state has returned to the default, in which case the extra check avoids the `setAutoCommit()` call.\n"
      },
      {
        "user": "kenny319",
        "created_at": "2016-06-30T03:15:31Z",
        "body": "@brettwooldridge Just use your scenario as the example,  whether the setAutoCommit() can be avoided still totally depends on the result of 'proxyConnection.getAutoCommitState() != isAutoCommit'. Is there any case can explain '(dirtyBits & DIRTY_BIT_AUTOCOMMIT) != 0' is useful?\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2016-06-30T10:20:14Z",
        "body": "Sure, if for example the transaction isolation was dirtied, the resetConnectionState() will be called.  If the autoCommit was _not_ dirty, the bit check avoids a call to connection.getAutoCommit(), which is a round trip for many databases.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2016-06-30T10:22:01Z",
        "body": "In other words, getAutoCommit() can be just as expensive as setAutoCommit().\n"
      }
    ]
  },
  {
    "number": 648,
    "title": "Mysql Inserts really slow",
    "created_at": "2016-06-13T01:27:26Z",
    "closed_at": "2016-06-29T14:58:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/648",
    "body": "I'm trying to insert about 40 thousant inserts using mysql but the time is really high.\nUsing the normal method without pool it execute in 50 seconds.\nUsing the pool it takes around 5 minutes.\n\nThats how i'm using the pool:\n\n```\nHikariConfig config = new HikariConfig();\nHikariDataSource dataSource;\nconfig.setJdbcUrl(\"jdbc:mysql://localhost:3306/test\");\nconfig.setUsername(\"root\");\nconfig.setPassword(\"root\");\nconfig.addDataSourceProperty(\"cachePrepStmts\", \"true\");\nconfig.addDataSourceProperty(\"prepStmtCacheSize\", \"250\");\nconfig.addDataSourceProperty(\"prepStmtCacheSqlLimit\", \"2048\");\nconfig.setMaximumPoolSize(10); // I have tried 10, 50, 100;\ndataSource = new HikariDataSource(config); \n```\n\n```\nConnection con = dataSource.getConnection();\n            for (int x = 1; x < 5000; x++) {\n                database.Insert(con, \"Insert 1\", null);\n                database.Insert(con, \"Insert 2\", null);\n                database.Insert(con, \"Insert 3\", null);\n                database.Insert(con, \"Insert 4\", null);\n        database.Insert(con, \"Insert 5\", null);\n        database.Insert(con, \"Insert 6\", null);\n        database.Insert(con, \"Insert 7\", null);\n        database.Insert(con, \"Insert 8\", null);\n            }\ncon.close();\n```\n\nI also tried the code below with the same result:\n\n```\n            for (int x = 1; x < 5000; x++) {\n                Connection con = dataSource.getConnection();\n                database.Insert(con, \"Insert 1\", null);\n                database.Insert(con, \"Insert 2\", null);\n                database.Insert(con, \"Insert 3\", null);\n                database.Insert(con, \"Insert 4\", null);\n        database.Insert(con, \"Insert 5\", null);\n        database.Insert(con, \"Insert 6\", null);\n        database.Insert(con, \"Insert 7\", null);\n        database.Insert(con, \"Insert 8\", null);\n                con.close();\n            }\n```\n\nWhats wrong???\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/648/comments",
    "author": "GitDov",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-06-13T13:12:24Z",
        "body": "@GitDov You might try this pattern:\n\n``` java\n...\nconfig.setAutoCommit(false);\nconfig.addDataSourceProperty(\"rewriteBatchedStatements\", \"true\");\ndataSource = new HikariDataSource(config); \n\n\ntry (Connection con = dataSource.getConnection()) {\n   for (int x = 1; x < 5000; x++) {\n      database.Insert(con, \"Insert 1\", null);\n      ...\n      database.Insert(con, \"Insert 8\", null);\n      if (x % 500 == 0) {\n         con.commit();\n      }\n   }\n}\n```\n\n_(The try-with-resources will automatically close the connection)_\n"
      },
      {
        "user": "ruixiangTan",
        "created_at": "2016-06-20T23:09:25Z",
        "body": "nice.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2016-06-20T23:41:30Z",
        "body": "@ruixiangTan Does that mean the above pattern worked for you?\n"
      }
    ]
  },
  {
    "number": 646,
    "title": "HikariCP PoolInitializationException missing method",
    "created_at": "2016-06-11T08:03:29Z",
    "closed_at": "2016-06-11T14:05:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/646",
    "body": "When try to connect to database i pass current server IP, user, pass\n`public final void connect()\n    {\n        config.setJdbcUrl(\"jdbc:mysql://\" + SERVER + \":3306/\" + DATA_BASE);\n        config.setUsername(USER);\n        config.setPassword(PASS);\n        try\n        {\n            ds = new HikariDataSource(config);\n        }\n`\nProblem here is if connection fail constructor throw PoolInitializationException but that class don't contains \"getErrorCode()\" in that case need to parse strings to see what happen what is not so cool.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/646/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-06-11T14:05:22Z",
        "body": "If you call `getCause()` on the `PoolInitializationException` it should give you the SQLException that caused the failure.\n"
      }
    ]
  },
  {
    "number": 645,
    "title": "MariaDB setConnectionTimeout not working",
    "created_at": "2016-06-11T07:58:22Z",
    "closed_at": "2016-06-11T14:01:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/645",
    "body": "DB : 5.5.5-10.1.13-MariaDB-1~trusty\nOS  : Ubuntu\nDriver : mariadb-java-client-1.4.5\n\nI try to configure when application attempt to connect database wait 1.5 sec stop if server is not found.\nI try follow\nconfig = new HikariConfig();\nconfig.setConnectionTimeout(1500);\nis not working so switch to\nconfig.addDataSourceProperty(\"connectionTimeout\", \"1500\");\nstill not working then do follow\nconfig.addDataSourceProperty(\"connectTimeout\", \"1500\");\nAnd now working perfect. But still \"config.setConnectionTimeout(1500);\" look better way to do it.\nGuess is need support for different variable name.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/645/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-06-11T14:01:53Z",
        "body": "`config.setConnectionTimeout(1500)` will set how long you _application_ will wait for a connection _from the pool_.\n\n`config.addDataSourceProperty(\"connectTimeout\", \"1500\")` will set how long the _pool_ will wait for a connection _to the database_ before the MariaDB driver throw an exception.\n\nBoth are valid for different purposes.\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-06-11T21:23:47Z",
        "body": "Thx for clear it out. Can you add it on wiki configuration page?\n"
      }
    ]
  },
  {
    "number": 639,
    "title": "Getting error while including HikariCP as a JNDI DataSource Factory on Tomcat.",
    "created_at": "2016-06-07T10:34:07Z",
    "closed_at": "2016-09-23T18:32:51Z",
    "labels": [
      "question",
      "not-a-bug"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/639",
    "body": "I am trying to setup Hikari as a JNDI DataSource Factory on my tomcat 7. But Not sure that i have to add Hikari.jar inside tomcat lib or simply adding as maven dependency for using it as a JNDI \nDataSource. \n\nAnyway, Here are following steps which i did so far.\n1. Added Maven dependency into my POM.xml\n   \n   `<dependency>\n         <groupId>com.zaxxer</groupId>\n         <artifactId>HikariCP</artifactId>\n         <version>2.4.6</version>\n     </dependency>`\n2. Added following resource inside context.xml\n   <Resource name=\"jdbc/MysqlHikari\" auth=\"Container\"\n     factory=\"com.zaxxer.hikari.HikariJNDIFactory\"\n     type=\"javax.sql.DataSource\"\n     minimumIdle=\"5\" \n     maximumPoolSize=\"10\"\n     connectionTimeout=\"300000\"\n     dataSourceClassName=\"com.mysql.jdbc.jdbc2.optional.MysqlDataSource\"\n     dataSource.user=\"root\"\n     dataSource.password=\"\"\n     dataSource.url=\"jdbc:mysql://localhost:3306/coesi?useUnicode=true&amp;characterEncoding=utf-8\"/>  \n3. Added a Bean inside my persistance Config\n\n@Bean\n    public DataSource dataSource() {\n        Context ctx;\n        try {\n            ctx = new InitialContext();\n            return (DataSource) ctx.lookup(\"java:comp/env/jdbc/MysqlHikari\");\n        } catch (NamingException e) {\n            LOGGER.info(\"Error loockup to the database : \\\"java:comp/env/jdbc/MysqlHikari\\\".\");\n        }\n        return null;\n    }\n\nI am getting this following error \"DataSource must not be null\".\n\nFull Stack\n\nCaused by: org.springframework.beans.factory.BeanDefinitionStoreException: Factory method [public org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean com.ftprod.fappi.gc.config.PersistanceConfig.entityManagerFactoryBean()] threw exception; nested exception is java.lang.IllegalArgumentException: DataSource must not be null\n    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:188)\n    at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:586)\n    ... 83 more\nCaused by: java.lang.IllegalArgumentException: DataSource must not be null\n    at org.springframework.util.Assert.notNull(Assert.java:112)\n    at org.springframework.jdbc.datasource.lookup.SingleDataSourceLookup.<init>(SingleDataSourceLookup.java:40)\n    at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.setDataSource(LocalContainerEntityManagerFactoryBean.java:231)\n    at com.ftprod.fappi.gc.config.PersistanceConfig.entityManagerFactoryBean(PersistanceConfig.java:59)\n    at com.ftprod.fappi.gc.config.PersistanceConfig$$EnhancerBySpringCGLIB$$238d1829.CGLIB$entityManagerFactoryBean$1(<generated>)\n    at com.ftprod.fappi.gc.config.PersistanceConfig$$EnhancerBySpringCGLIB$$238d1829$$FastClassBySpringCGLIB$$f799cb05.invoke(<generated>)\n    at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228)\n    at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:312)\n    at com.ftprod.fappi.gc.config.PersistanceConfig$$EnhancerBySpringCGLIB$$238d1829.entityManagerFactoryBean(<generated>)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:166)\n    ... 84 more\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/639/comments",
    "author": "coexia",
    "comments": [
      {
        "user": "nitincchauhan",
        "created_at": "2016-06-07T14:46:33Z",
        "body": "error message is very clear. you are passing 'driver' class name instead of 'dataSource' class name ! change it to: dataSourceClassName=com.mysql.jdbc.jdbc2.optional.MysqlDataSource\n"
      },
      {
        "user": "coexia",
        "created_at": "2016-06-07T14:50:25Z",
        "body": "I already added this line dataSourceClassName=\"com.mysql.jdbc.jdbc2.optional.MysqlDataSource\" but still getting this  \"DataSource must not be null\" error.\n"
      },
      {
        "user": "wesoos",
        "created_at": "2016-06-20T13:09:57Z",
        "body": "I have it like this and it's working.  Make sure Hikari jar file is in tomcat lib folder.\n\n```\n<Resource name=\"jdbc/datasource\" \n        auth=\"Container\" \n        factory=\"com.zaxxer.hikari.HikariJNDIFactory\" \n        type=\"javax.sql.DataSource\" \n        maximumPoolSize=\"10\"\n        connectionTimeout=\"300000\" \n        dataSourceClassName=\"com.mysql.jdbc.jdbc2.optional.MysqlDataSource\"\n        dataSource.url=\"jdbc:mysql://server/database\"\n        dataSource.user=\"user\" \n        dataSource.password=\"pwd\" \n/>\n```\n"
      },
      {
        "user": "coexia",
        "created_at": "2016-06-21T10:06:04Z",
        "body": "@wesoos : your suggested code doesnt work to me..\n"
      },
      {
        "user": "nitincchauhan",
        "created_at": "2016-06-21T11:21:34Z",
        "body": "@coexia It is 'specific' configuration issue, you may get answer on stack overflow instead.\n"
      }
    ]
  },
  {
    "number": 637,
    "title": "Can we add multiple DS in hikari",
    "created_at": "2016-06-03T09:20:06Z",
    "closed_at": "2016-06-04T09:23:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/637",
    "body": "possible use will be that, If I want to use two database instances for failover purpose\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/637/comments",
    "author": "sandeepan",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-06-04T09:23:01Z",
        "body": "@sandeepan HikariCP itself does not support two datasources.  If you are using MySQL it has support for failover configuration in the MySQL driver itself.  If you are using PostgreSQL, there are high availablity drivers available as well.\n"
      },
      {
        "user": "sandeepan",
        "created_at": "2016-06-04T09:42:28Z",
        "body": "Thank you Brent. There are middlewares like pgpool and pgbouncer. But I wanted to avoid another layer because you have one more system to monitor.\n\nAnyways, thanks. Huge Fan. Started using hikari and it's already kicking butt :+1: \n"
      }
    ]
  },
  {
    "number": 618,
    "title": "Can't unregistered jdbc driver when application closed",
    "created_at": "2016-04-26T07:37:39Z",
    "closed_at": "2016-04-29T07:36:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/618",
    "body": "I'm using Tomcat, and while stopping I get message : unregistered jdbc driver when application \nI have close and shutdown the datasource\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/618/comments",
    "author": "rizagp",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-04-29T07:36:55Z",
        "body": "@rizagp This is a frequently asked Tomcat question.  I recommend searching stack overflow and reading the Tomcat FAQs.  There are several ways to fix it: moving the jdbc driver jar, configuring using the datasource rather than by URL or driver class name, etc.\n"
      }
    ]
  },
  {
    "number": 598,
    "title": "Could not integrate Spark-Streaming with HikariCP",
    "created_at": "2016-03-22T11:13:23Z",
    "closed_at": "2016-04-12T14:14:53Z",
    "labels": [
      "question",
      "wontfix"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/598",
    "body": "Hi ,\n\nI am trying to use HikariCP with spark Streaming to perform CRUD operations since spark sql just support part of it. I had come across errors like HikariDataSource is not serializable. Is it possible to extend HikariDataSource with Serializable in order to integrate with Spark Streaming?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/598/comments",
    "author": "Deric1111",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-04-06T15:50:59Z",
        "body": "@Deric1111 Unfortunately, it is likely not possible to serialize the datasource.  I'm not even sure what that would mean.  Connections certainly aren't Serializable.  We would have to mark so many members transient, it wouldn't have any meaning.\n"
      }
    ]
  },
  {
    "number": 583,
    "title": "Question: Is it possible to not log whole stack trace when connection leak is detected?",
    "created_at": "2016-02-18T10:36:35Z",
    "closed_at": "2016-03-21T11:01:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/583",
    "body": "When connection leak is detected i get about hundred lines of stack trace. \nIs it posible to log only one line like this:\n2016-02-18 07:34:47.344  WARN 9335 --- [l HikariPool-0)] com.zaxxer.hikari.pool.ProxyLeakTask     : Connection leak detection triggered for connection com.mysql.jdbc.JDBC4Connection@6a39819e\n?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/583/comments",
    "author": "vonweird",
    "comments": [
      {
        "user": "nitincchauhan",
        "created_at": "2016-02-18T10:45:46Z",
        "body": "no. the purpose of leak detection threshold parameter is to help you find and fix connection leaks.\nstack trace helps to go to root of call.\nyou should tweak leak detection threshold to max time it takes to execute sql in your app.\n"
      }
    ]
  },
  {
    "number": 582,
    "title": "connection getting closed ",
    "created_at": "2016-02-16T14:41:28Z",
    "closed_at": "2016-02-16T17:16:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/582",
    "body": "stacktrace ->\n\n```\n11:48:51.357 [ProvisioningClusteredScheduler_Worker-1] WARN  c.z.hikari.proxy.ConnectionProxy - iam--provisioning - Connection org.postgresql.jdbc42.Jdbc42Connection@6c0c4a6e, created Feb 16, 07:17:49.967, last release 16261389ms ago, IN_USE marked as broken because of SQLSTATE(08003), ErrorCode(0)\norg.postgresql.util.PSQLException: This connection has been closed.\n        at org.postgresql.jdbc2.AbstractJdbc2Connection.checkClosed(AbstractJdbc2Connection.java:853) ~[lib.jar:1.0-SNAPSHOT]\n        at org.postgresql.jdbc3.AbstractJdbc3Connection.prepareStatement(AbstractJdbc3Connection.java:281) ~[lib.jar:1.0-SNAPSHOT]\n        at org.postgresql.jdbc2.AbstractJdbc2Connection.prepareStatement(AbstractJdbc2Connection.java:326) ~[lib.jar:1.0-SNAPSHOT]\n        at com.zaxxer.hikari.proxy.ConnectionProxy.prepareStatement(ConnectionProxy.java:265) ~[lib.jar:1.0-SNAPSHOT]\n        at com.zaxxer.hikari.proxy.HikariConnectionProxy.prepareStatement(HikariConnectionProxy.java) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.engine.jdbc.internal.StatementPreparerImpl$5.doPrepare(StatementPreparerImpl.java:146) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate.prepareStatement(StatementPreparerImpl.java:172) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareQueryStatement(StatementPreparerImpl.java:148) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.loader.Loader.prepareQueryStatement(Loader.java:1928) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.loader.Loader.executeQueryStatement(Loader.java:1897) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.loader.Loader.executeQueryStatement(Loader.java:1875) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.loader.Loader.doQuery(Loader.java:919) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.loader.Loader.doQueryAndInitializeNonLazyCollections(Loader.java:336) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.loader.Loader.doList(Loader.java:2611) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.loader.Loader.doList(Loader.java:2594) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.loader.Loader.listIgnoreQueryCache(Loader.java:2423) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.loader.Loader.list(Loader.java:2418) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.loader.hql.QueryLoader.list(QueryLoader.java:501) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.hql.internal.ast.QueryTranslatorImpl.list(QueryTranslatorImpl.java:371) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.engine.query.spi.HQLQueryPlan.performList(HQLQueryPlan.java:220) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.internal.SessionImpl.list(SessionImpl.java:1268) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.internal.QueryImpl.list(QueryImpl.java:87) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.jpa.internal.QueryImpl.list(QueryImpl.java:567) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.jpa.internal.QueryImpl.getResultList(QueryImpl.java:436) [lib.jar:1.0-SNAPSHOT]\n        at org.hibernate.jpa.criteria.compile.CriteriaQueryTypeQueryAdapter.getResultList(CriteriaQueryTypeQueryAdapter.java:50) [lib.jar:1.0-SNAPSHOT]\n        at com.xyz.nmon.provisioning.jobs.amsaccount.dao.AmsAccountDao.readItem(AmsAccountDao.java:41) [lib.jar:1.0-SNAPSHOT]\n        at com.xyz.nmon.provisioning.jobs.amsaccount.reader.AmsAccountSource.readItem(AmsAccountSource.java:25) [lib.jar:1.0-SNAPSHOT]\n        at com.xyz.nmon.provisioning.jobs.amsaccount.job.AmsAccountProducerJob.lambda$execute$29(AmsAccountProducerJob.java:91) [lib.jar:1.0-SNAPSHOT]\n        at com.xyz.nmon.provisioning.jobs.amsaccount.job.AmsAccountProducerJob$$Lambda$17/1816821542.call(Unknown Source) [lib.jar:1.0-SNAPSHOT]\n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55) [lib.jar:1.0-SNAPSHOT]\n        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:43) [lib.jar:1.0-SNAPSHOT]\n        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:32) [lib.jar:1.0-SNAPSHOT]\n        at rx.Observable$1.call(Observable.java:144) [lib.jar:1.0-SNAPSHOT]\n        at rx.Observable$1.call(Observable.java:136) [lib.jar:1.0-SNAPSHOT]\n        at rx.Observable$1.call(Observable.java:144) [lib.jar:1.0-SNAPSHOT]\n        at rx.Observable$1.call(Observable.java:136) [lib.jar:1.0-SNAPSHOT]\n        at rx.Observable$1.call(Observable.java:144) [lib.jar:1.0-SNAPSHOT]\n        at rx.Observable$1.call(Observable.java:136) [lib.jar:1.0-SNAPSHOT]\n        at rx.Observable$1.call(Observable.java:144) [lib.jar:1.0-SNAPSHOT]\n        at rx.Observable$1.call(Observable.java:136) [lib.jar:1.0-SNAPSHOT]\n        at rx.Observable.subscribe(Observable.java:7597) [lib.jar:1.0-SNAPSHOT]\n        at rx.Observable.subscribe(Observable.java:7373) [lib.jar:1.0-SNAPSHOT]\n        at com.xyz.nmon.provisioning.jobs.amsaccount.job.AmsAccountProducerJob.execute(AmsAccountProducerJob.java:104) [lib.jar:1.0-SNAPSHOT]\n        at com.xyz.nmon.provisioning.jobs.amsaccount.job.AmsAccountProducerJob$$EnhancerByGuice$$1ff991c8.CGLIB$execute$0(<generated>) [lib.jar:1.0-SNAPSHOT]\n        at com.xyz.nmon.provisioning.jobs.amsaccount.job.AmsAccountProducerJob$$EnhancerByGuice$$1ff991c8$$FastClassByGuice$$40006e9b.invoke(<generated>) [lib.jar:1.0-SNAPSHOT]\n        at com.google.inject.internal.cglib.proxy.$MethodProxy.invokeSuper(MethodProxy.java:228) [lib.jar:1.0-SNAPSHOT]\n        at com.google.inject.internal.InterceptorStackCallback$InterceptedMethodInvocation.proceed(InterceptorStackCallback.java:75) [lib.jar:1.0-SNAPSHOT]\n        at com.xyz.indis.metrics.listener.TimedInterceptor.invoke(TimedInterceptor.java:56) [lib.jar:1.0-SNAPSHOT]\n        at com.google.inject.internal.InterceptorStackCallback$InterceptedMethodInvocation.proceed(InterceptorStackCallback.java:75) [lib.jar:1.0-SNAPSHOT]\n        at com.palominolabs.metrics.guice.TimedInterceptor.invoke(TimedInterceptor.java:26) [lib.jar:1.0-SNAPSHOT]\n        at com.google.inject.internal.InterceptorStackCallback$InterceptedMethodInvocation.proceed(InterceptorStackCallback.java:75) [lib.jar:1.0-SNAPSHOT]\n        at com.google.inject.internal.InterceptorStackCallback.intercept(InterceptorStackCallback.java:55) [lib.jar:1.0-SNAPSHOT]\n        at com.xyz.nmon.provisioning.jobs.amsaccount.job.AmsAccountProducerJob$$EnhancerByGuice$$1ff991c8.execute(<generated>) [lib.jar:1.0-SNAPSHOT]\n        at org.quartz.core.JobRunShell.run(JobRunShell.java:202) [lib.jar:1.0-SNAPSHOT]\n        at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573) [lib.jar:1.0-SNAPSHOT]\n```\n\nrelevant dependencies ->\n\n```\n            <dependency>\n                <groupId>org.hibernate</groupId>\n                <artifactId>hibernate-core</artifactId>\n                <version>5.0.1.Final</version>\n            </dependency>\n\n\n            <dependency>\n                <groupId>com.zaxxer</groupId>\n                <artifactId>HikariCP</artifactId>\n                <version>2.4.1</version>\n            </dependency>\n\n\n            <dependency>\n                <groupId>org.postgresql</groupId>\n                <artifactId>postgresql</artifactId>\n                <version>9.4-1205-jdbc42</version>\n            </dependency>\n```\n\nWhy hikari is closing the connections?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/582/comments",
    "author": "abhishekparwal",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-02-16T17:16:55Z",
        "body": "@abhishekparwal The error log indicates that the connection was \"last released\" 4.5 hours before this error, and created ~6.5 hours before.  There is no easy way to tell how long the connection was out of the pool before this error occurred, but it seems probable that it was out of the pool for a long time.  HikariCP tests the connection when it is borrowed from the pool, but once it is out of the pool there is nothing it can do to \"keep it alive\".\n\nI recommend turning on leak detection, by setting the `leakDetectionThreshold`.  If you set the threshold to 5 or 10 minutes (600000ms), you might find that this connection is being held out of the pool for too long.\n\nEven settings like `maxLifetime` (which defaults to 30 minutes), will not be effective for connection that are borrowed from the pool, because HikariCP will never interrupt an \"in-use\" connection.\n"
      },
      {
        "user": "abhishekparwal",
        "created_at": "2016-02-17T02:05:14Z",
        "body": "After this error comes,  Hikari is not able to create a connection again.  \n"
      }
    ]
  },
  {
    "number": 576,
    "title": "relax lastAccess setting",
    "created_at": "2016-02-08T11:21:26Z",
    "closed_at": "2016-02-13T04:40:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/576",
    "body": "With narrower escape validation window and many refactor / updates later, I think it is time to revisit decision to have overhead (in case of read-only or auto-commit connections) of initializing lastAccess in markCommitStateDirty(). earlier it was always set in close() only.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/576/comments",
    "author": "nitincchauhan",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-02-13T04:40:02Z",
        "body": "If we _always_ set `lastAccess` to `CloseSource.currentTime()` in `close()`, as we used to, then the connection can be immediately borrowed without a validation check (bc of the alive-bypass window).  This lead to a rare error where a connection that was borrowed, but never used, was returned to the pool in a disconnected state.  Because we set `lastAccess` to `currentTime()` in `close()`, the connection was borrowed without testing, resulting in an error at the application level.\n\nIt is important that `lastAccess` reflect the last known time that we _know_ that the connection was valid.  \n"
      }
    ]
  },
  {
    "number": 562,
    "title": "Incorrect housekeeper reports",
    "created_at": "2016-01-27T16:29:25Z",
    "closed_at": "2016-04-12T14:16:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/562",
    "body": "Hi,\n\nI'm looking into Hikari logs and comparing them to actual DB connections i am seeing false information reported, i.e: \n\nHikari reports:\n\n2016-01-27 11:21:18,969 [Hikari housekeeper (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - After cleanup        pool HikariPool-0 stats (total=90, active=90, idle=0, waiting=1)\n\nBut actual DB connections during that time specific time are 67.\n\n[~]# date\nWed Jan 27 11:21:21 EST 2016\n[~]# mysql -BNe \"show processlist\" | | wc -l\n67\n\nI'm using MySQL and Hikari 2.4.2, as you can see Hikari reports its out of connections yet MySQL has only 67 connections open.\n\nAny idea what could be wrong ? my configuration is:\n\nmaximumPoolSize=90\nminimumIdle=10\nidleTimeout=60000\nmaxLifetime=1800000\nleakDetectionThreshold=220000\n\nBy the way, this seems to happen only after a few days of running, after a restart all the stats are reported correctly...\n\nThanks.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/562/comments",
    "author": "dannygu",
    "comments": [
      {
        "user": "nitincchauhan",
        "created_at": "2016-01-28T09:31:16Z",
        "body": "@dannygu make sure wait_timeout defined in my.cnf or in url is few seconds MORE than maxLifetime you defined for hikaricp. ie. 1800+15\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2016-01-28T13:53:16Z",
        "body": "@dannygu Do what @nitincchauhan said, additionally this will give you better information.\n\n```\nmysql> show status like '%onn%';\n+--------------------------+-------+\n| Variable_name            | Value |\n+--------------------------+-------+\n| Aborted_connects         | 0     | \n| Connections              | 8     | \n| Max_used_connections     | 4     | \n| Ssl_client_connects      | 0     | \n| Ssl_connect_renegotiates | 0     | \n| Ssl_finished_connects    | 0     | \n| Threads_connected        | 4     | \n+--------------------------+-------+\n7 rows in set (0.00 sec)\n```\n\nFinally, `leakDetectionThreshold` should be less than `maxLifetime`, and should typically be said 30-50% longer than your longest running query.\n"
      },
      {
        "user": "dannygu",
        "created_at": "2016-01-28T14:17:36Z",
        "body": "Hi,\n\nI verified our settings again, our wait_timeout is in indeed higher then maxLifetime, also looking into Aborted_connects shows 0.\n\n| Aborted_connects                              | 0       |\n| Connection_errors_accept                      | 0       |\n| Connection_errors_internal                    | 0       |\n| Connection_errors_max_connections             | 0       |\n| Connection_errors_peer_address                | 0       |\n| Connection_errors_select                      | 0       |\n| Connection_errors_tcpwrap                     | 0       |\n| Connections                                   | 3344329 |\n| Max_used_connections                          | 409     |\n| Performance_schema_session_connect_attrs_lost | 0       |\n| Ssl_client_connects                           | 0       |\n| Ssl_connect_renegotiates                      | 0       |\n| Ssl_finished_connects                         | 0       |\n| Threads_connected                             | 112     |\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2016-02-03T15:28:41Z",
        "body": "@dannygu Can you enable debug logging?  You should be able to count the number of added connections, minus the number of retired connections.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2016-02-03T15:31:56Z",
        "body": "@dannygu You can also run this command on the MySQL server to determine the number of open connections from the host where HikariCP is running:\n\n```\nnetstat -a | grep ESTABLISHED | grep <ip address>\n```\n\nwhere &lt;ip address> is the address of the HikariCP host.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2016-02-04T14:45:15Z",
        "body": "@dannygu I just ran across a post I made 2 years ago.  Basically, I said then `Threads_connected` is the value you want to be watching.\n"
      },
      {
        "user": "dannygu",
        "created_at": "2016-03-17T11:42:32Z",
        "body": "Sorry for my delayed response, but I've only now had the chance to dig into this manner again, it seems this issue only occurs when a leak is detected and terminated HikariCP, i.e only after a leak was detected Hikari starts reporting incorrect stats for total/active/idle.\n\nIf it makes any difference we are using HAProxy in the middle i.e Tomat > HaProxy > MySQL.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2016-03-17T14:09:28Z",
        "body": "@dannygu That is indeed strange, because while HikariCP will log a leaked connection, it does not terminate leaked connections.  Do you have any debug-level logs you can share (attach)?\n"
      },
      {
        "user": "dannygu",
        "created_at": "2016-03-17T16:00:58Z",
        "body": "now it makes sense, even though its closed on MySQL due to wait_timeout since my code had a leak and it was never returned back to Hikari the stats are reported incorrectly, though they actually aren't , a connection was taken and never returned to Hikari so its thinking its still 'alive' but it really isn't.\n\nObviously i have to fix my code.\n\nOne last question - \"We strongly recommend setting this value, and it should be at least 30 seconds less than any database-level connection timeout. \" you mean wait_timeout on MySQL and not idletimeout in Hikari , correct ? \n\nThanks!\n"
      },
      {
        "user": "nitincchauhan",
        "created_at": "2016-03-17T18:41:15Z",
        "body": "@dannygu\nIdeally, wait_timeout > maxLifetime > leakDetectionThreshold\neg:\nwait_timeout =  maxLifetime + 30 seconds\n\nleakDetectionThreshold should be less than maxLifetime and about 50% more than the task that uses connection and takes longest time\n\nidleTimeout: controls the maximum amount of time that a connection is allowed to sit idle in the pool.\n\nafter you fix connection leaks, you should remove or set leakDetectionThreshold to zero using monitoring tool\n"
      }
    ]
  },
  {
    "number": 561,
    "title": "2 Questions Only",
    "created_at": "2016-01-27T08:22:21Z",
    "closed_at": "2016-01-28T03:35:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/561",
    "body": "1. Does hikari takes care of the connections {in the connection pool} when cpu {About machine} max out to 100% ?\n2. In-relation to question 1, If no then will it issue a log that there is a connection leak?\n\nthanks,\nDave\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/561/comments",
    "author": "DavidMont",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-01-27T10:43:22Z",
        "body": "I don't understand question #1.  If a connection is out of the pool for longer than the leak detection threshold it will be logged, regardless of _why_ it was out of the pool.  If the CPU is pegged at 100% the timer thread that logs the leak might itself be starved, and therefore be delayed from reporting the leak.\n"
      },
      {
        "user": "DavidMont",
        "created_at": "2016-01-28T03:35:29Z",
        "body": "Ah i see, thanks for your time.\n"
      }
    ]
  },
  {
    "number": 557,
    "title": "Connection.setNetworkTimeout() is not supported (Redshift)",
    "created_at": "2016-01-25T22:16:36Z",
    "closed_at": "2016-01-26T15:35:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/557",
    "body": "Hello Brett.\n\nIs there a config to avoid making this call?  Its preventing Hikari from init'ing a data source to a Redshift backend.  We're using HikariCP 2.4.0.\n\nThanks.\n\n```\n2016-01-25 21:19:59.124  INFO 1653 [WrapperJarAppMain] --- com.zaxxer.hikari.HikariDataSource       : Hikari pool HikariPool-7 is starting.\n2016-01-25 21:19:59.202 DEBUG 1653 [WrapperJarAppMain] --- com.zaxxer.hikari.pool.PoolElf           : HikariPool-7 - Connection.setNetworkTimeout() is not supported ([Amazon][JDBC](10220) Driver not capable.)\n2016-01-25 21:19:59.215 DEBUG 1653 [WrapperJarAppMain] --- com.zaxxer.hikari.pool.HikariPool        : HikariPool-7 - Connection attempt to database failed\n\njava.sql.SQLException: [JDBC Driver]String index out of range: 0\n        at java.lang.String.charAt(String.java:658)\n        at com.amazon.redshift.core.PGJDBCConnection.toNativeSQL(Unknown Source)\n        at com.amazon.jdbc.common.SConnection.nativeSQL(Unknown Source)\n        at com.amazon.jdbc.common.SStatement.executeNoParams(Unknown Source)\n        at com.amazon.jdbc.common.SStatement.execute(Unknown Source)\n        at com.zaxxer.hikari.pool.PoolElf.executeSql(PoolElf.java:441)\n        at com.zaxxer.hikari.pool.PoolElf.setupConnection(PoolElf.java:183)\n        at com.zaxxer.hikari.pool.HikariPool.addConnection(HikariPool.java:496)\n        at com.zaxxer.hikari.pool.HikariPool.initializeConnections(HikariPool.java:564)\n        at com.zaxxer.hikari.pool.HikariPool.<init>(HikariPool.java:150)\n        at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:96)\n        at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:139)\n        at org.hibernate.engine.jdbc.internal.JdbcServicesImpl$ConnectionProviderJdbcConnectionAccess.obtainConnection(JdbcServicesImpl.java:279)\n        at org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(JdbcServicesImpl.java:124)\n        at org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.configureService(StandardServiceRegistryImpl.java:111)\n        at org.hibernate.service.internal.AbstractServiceRegistryImpl.initializeService(AbstractServiceRegistryImpl.java:234)\n        at org.hibernate.service.internal.AbstractServiceRegistryImpl.getService(AbstractServiceRegistryImpl.java:206)\n        at org.hibernate.cfg.Configuration.buildTypeRegistrations(Configuration.java:1887)\n        at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1845)\n        at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl$4.perform(EntityManagerFactoryBuilderImpl.java:852)\n        at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl$4.perform(EntityManagerFactoryBuilderImpl.java:845)\n        at org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl.withTccl(ClassLoaderServiceImpl.java:398)\n        at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:844)\n```\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/557/comments",
    "author": "vmorales",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-01-25T23:51:43Z",
        "body": "Which call?  The redshift driver is failing in _Statement.execute()_.  HikariCP is calling this because your configuration defines _connectionInitSql_ .  Whatever that SQL is, it appears to be causing the problem.\n"
      },
      {
        "user": "vmorales",
        "created_at": "2016-01-26T14:38:47Z",
        "body": "Brett....thank you SO much.  That was it.  Things are working awesomely.\n"
      },
      {
        "user": "Danilo-Araujo-Silva",
        "created_at": "2018-04-30T17:13:51Z",
        "body": "I'm having the same problem. Can you share how did you solve it?"
      }
    ]
  },
  {
    "number": 554,
    "title": "After query broken, generate new ID for an existing record",
    "created_at": "2016-01-20T17:14:23Z",
    "closed_at": "2016-01-21T10:31:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/554",
    "body": "After broken SQL query, generate new records after edit.\n\nExample:\n\n``` json\n// One record in table USER:\n{\n  \"id\": 1,\n  \"name\": \"userx\",\n  \"email\": \"userx@mail.com\",\n  \"age\": 30,\n  \"username\": \"userx\",\n  \"password\": \"xxxxxxxx\"\n}\n```\n\nAfter edit:\n\n``` json\n// One record in table USER:\n{\n  \"id\": 2,\n  \"name\": \"userx\",\n  \"email\": \"userx@mail.com\",\n  \"age\": 30,\n  \"username\": \"userx\",\n  \"password\": \"xxxxxxxx\"\n}\n```\n\nServer is:\n- JBOSS 6.2 EAP\n- Hibernate 4.2 Final\n- Spring framework 4.x\n- Oracle 11g \n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/554/comments",
    "author": "elesdoar",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-01-20T23:43:36Z",
        "body": "What does this have to do with HikariCP?\n"
      },
      {
        "user": "elesdoar",
        "created_at": "2016-01-21T00:13:44Z",
        "body": "Create a copy of the record when it's edited, generating a new id for it. Solve changing HikariCP datasource for standard spring datasource.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2016-01-21T10:31:50Z",
        "body": "I still have no idea what that means.  The sounds like an issue of the connection not being committed or rolled back.\n\nThe difference with the standard Spring DataSource is that two sets of getConnection()/close() calls are likely to get two separate Connections.  HikariCP is likely to give the same (previously used) connection to the thread.\n\nI suggest asking this question on stackoverflow.com.\n"
      },
      {
        "user": "elesdoar",
        "created_at": "2016-01-21T15:53:53Z",
        "body": "@brettwooldridge thanks,\n\nI think that the problem is with HikariCP datasource, I have some entities mapped with auto generated ID, while there is no SQL errors, all is alright, but, after SQL errors, when edit some entity, HikariCP datasource duplicates the editing record in a new record with new generated ID, only happens with HikariCP datasource. Somehow send null ID to database, generating a new record.\n"
      }
    ]
  },
  {
    "number": 549,
    "title": "Get pgconnection from pool",
    "created_at": "2016-01-15T21:57:37Z",
    "closed_at": "2016-01-16T04:25:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/549",
    "body": "I have an application using HikariCP, it's currently running version 2.4.1 and everything is working fine, but I would like to upgrade to the current version (2.4.3).\n\nI use the Postgres LISTEN / NOTIFY system in my app, so I need to get the base PGConnection object from the connection returned by HikariCP.\nI was previously doing: this.pgConnection = PGConnection.class.cast(ConnectionProxy.class.cast(connection).getPoolBagEntry().connection);\nThis no longer works as of 2.4.1, as you renamed that class ProxyConnection, and made the getPoolEntry() method package local.\n\nWhat alternative methods do I have to get the PGConnection so I can get all of my notifications from the connection?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/549/comments",
    "author": "Tostino",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-01-16T04:25:28Z",
        "body": "@Tostino Use `PGConnection pgConn = connection.unwrap(PGConnection.class)`.  That is the official JDBC way to get a wrapped connection.\n"
      }
    ]
  },
  {
    "number": 545,
    "title": "Only one active connection?",
    "created_at": "2016-01-13T21:19:03Z",
    "closed_at": "2016-01-14T20:57:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/545",
    "body": "We're testing HikariCP at the client and have had great initial success - an application loading 1 million records over multiple HTTP threads and putting them in the DB had it's run time cut by 70% after moving from Tomcat CP to Hikari CP!\n\nNow we are having an issue with a new application.  The application is a batch process that launches N threads.  Each thread starts a transaction and ETLs some data from a few tables to some other tables.  This application slowed down markedly after changing the connection pool to Hikari from Tomcat.\n\nLooking in JMX Metrics, it appears that only one active connection is ever requested out of a maximumPoolSize=10.  The pool is a fixed-size pool.  Changing the connection pool back to TomcatCP seems to speed up the application several times.\n\nPerhaps someone has seen this before?  Any suggestions?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/545/comments",
    "author": "maudewest",
    "comments": [
      {
        "user": "maudewest",
        "created_at": "2016-01-13T21:20:28Z",
        "body": "Oracle 11g, running Groovy 2.3 on Java 8.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2016-01-14T14:05:45Z",
        "body": "Can you get a thread dump when you think all threads should be running but think they aren't?  If they're running, they must be blocked _somewhere_.\n\nEDIT: also check the obvious, like forgetting to set auto-commit to `false` etc.  Post the config (as output by debug level logging), as well as a relavent thread dump.\n"
      },
      {
        "user": "maudewest",
        "created_at": "2016-01-14T20:57:22Z",
        "body": "This was a bug in our side, using some unrelated non-threadsafe code.  No issue.\n\nAfter fixing the bug, the code runs about 2x faster using HikariCP than Tomcat CP.\n"
      }
    ]
  },
  {
    "number": 544,
    "title": "Embedded Firebird ??",
    "created_at": "2016-01-13T19:05:06Z",
    "closed_at": "2016-01-14T10:24:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/544",
    "body": "Hi,\n\nDoes HikariCP works with embedded Firebird? As much as I know (mentioned in Jaybird Documentation) \"only one jvm\" can connect to embedded database. Does this mean that one jvm can create any count of connections to embedded database? If yes, is there any configuration for setup.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/544/comments",
    "author": "tJeyhun",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-01-14T10:24:04Z",
        "body": "Should work fine.  Configuration should be as simple as the correct connection URL.\n"
      }
    ]
  },
  {
    "number": 543,
    "title": "HikariCP as JNDI Datasource in Weblogic",
    "created_at": "2016-01-13T10:13:03Z",
    "closed_at": "2016-01-13T10:20:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/543",
    "body": "HikariCP as JNDI Datasource #8\n\nI have trying to test HikariCP as jndi datasource, but i cannot find the way to add it as jndi datasource in weblogic.\nIf it's possible can you provide the configuration or if not can you add this feature ?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/543/comments",
    "author": "psyuhen",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-01-13T10:20:04Z",
        "body": "Please ask this question on stackoverflow.  HikariCP supports JNDI deployment, but we have no experience with WebLogic configuration.\n"
      }
    ]
  },
  {
    "number": 541,
    "title": "QUESTION: connectionTimeout, idleTimeout, and maxLifetime",
    "created_at": "2016-01-08T16:07:25Z",
    "closed_at": "2016-01-22T08:36:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/541",
    "body": "maxLifetime says that \"An in-use connection will never be retired, only when it is closed will it then be removed\"  Does this mean that a long running query will always be allowed to complete?  In other words, is there a knob I need to tweak to ensure that my long running queries complete or not?  Thanks!\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/541/comments",
    "author": "victropolis",
    "comments": [
      {
        "user": "nitincchauhan",
        "created_at": "2016-01-09T07:22:21Z",
        "body": "correct. no knob required, just close connection 'properly' when done.\n"
      },
      {
        "user": "victropolis",
        "created_at": "2016-01-09T14:36:38Z",
        "body": "so HikariCP sill never kill a running query.  the only possibility is the database itself killing it or network connectivity issues.  correct?\n"
      },
      {
        "user": "jnehlmeier",
        "created_at": "2016-01-09T15:43:07Z",
        "body": "Your JDBC driver most likely have connection configuration properties to define a query timeout or more general a read timeout from the database. Check your JDBC driver documentation. For PostgreSQL its \"socketTimeout\" which defines the read timeout from the DB (and thus can also act as a global query timeout).\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2016-01-22T08:36:14Z",
        "body": "@victropolis HikariCP will never kill an in-use Connection unless the pool itself is shutting down.\n"
      }
    ]
  },
  {
    "number": 540,
    "title": "Unable to get driver instance",
    "created_at": "2016-01-07T16:02:06Z",
    "closed_at": "2016-01-22T08:29:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/540",
    "body": "Brett, getting this error.  Doesn't automatic driver detection work for postresql?\n\nUnable to get driver instance for jdbcUrl=jdbc:postgresql://iu00gcsdbs003:5434/dgcs\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/540/comments",
    "author": "victropolis",
    "comments": [
      {
        "user": "nitincchauhan",
        "created_at": "2016-01-08T15:10:56Z",
        "body": "iu00gcsdbs003 is that host id? is this working without pool or other pool?\n"
      },
      {
        "user": "victropolis",
        "created_at": "2016-01-08T15:50:20Z",
        "body": "that's a hostname.  I read that \"HikariCP will attempt to resolve a driver through the DriverManager based solely on the jdbcUrl, but for some older drivers the driverClassName must also be specified. Omit this property unless you get an obvious error message indicating that the driver was not found\" so I tried omitting the driverClassName and then I started getting the error above.  Everything works fine with the driverClassName provided.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2016-01-22T08:29:40Z",
        "body": "@victropolis I don't know whether the postgresql driver self-registers.  If you look inside the JAR for a file, `META-INF/services/java.sql.Driver`.  If it is there, the DriverManager is supposed to interrogate it.  However, some containers have classloaders that can thwart the process, in which case you end up needing to specify the driverClassName.\n"
      },
      {
        "user": "mleonhard",
        "created_at": "2019-10-03T02:56:47Z",
        "body": "I solved this by calling `HikariConfig.setDriverClassName()`:\r\n```java\r\nHikariConfig config = new HikariConfig();\r\nconfig.setDriverClassName(org.postgresql.Driver.class.getName());\r\nconfig.setJdbcUrl(jdbcUrl);\r\nconfig.setUsername(username);\r\nconfig.setPassword(password);\r\nthis.hikariDataSource = new HikariDataSource(config);\r\n```\r\n\r\nMy `build.gradle` file has:\r\n```gradle\r\nrepositories { mavenCentral() }\r\ndependencies {\r\n  compile 'org.postgresql:postgresql:42.2.5'\r\n  ...\r\n}\r\n```"
      },
      {
        "user": "unschikov",
        "created_at": "2023-10-08T10:16:04Z",
        "body": "this it helped me\r\nconfig.setDriverClassName(org.postgresql.Driver.class.getName());"
      }
    ]
  },
  {
    "number": 531,
    "title": "How to integrate HikariCP into wildfly?",
    "created_at": "2015-12-29T07:01:25Z",
    "closed_at": "2015-12-29T09:54:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/531",
    "body": "What can you do?  Thanks!\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/531/comments",
    "author": "slieer",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-12-29T09:54:06Z",
        "body": "@slieer Please ask this question on stackoverflow.com, and check for relevant posts there.\n"
      }
    ]
  },
  {
    "number": 527,
    "title": "2.4.3 error using hsqldb",
    "created_at": "2015-12-22T16:34:10Z",
    "closed_at": "2015-12-22T21:28:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/527",
    "body": "using HikariCP 2.4.3, 2.4.2  (not 2.4.1)\n\nhsqldb connection error like this (other database all success)\n\n2015-12-23 01:30:46,179 DEBUG [ol HikariPool-5)] com.zaxxer.hikari.pool.HikariPool.createPoolEntry: HikariPool-5 - Cannot acquire connection from data source\njava.sql.SQLSyntaxErrorException: unexpected token: ;\n    at org.hsqldb.jdbc.JDBCUtil.sqlException(Unknown Source) ~[hsqldb-2.3.3.jar:2.3.3]\n    at org.hsqldb.jdbc.JDBCUtil.sqlException(Unknown Source) ~[hsqldb-2.3.3.jar:2.3.3]\n    at org.hsqldb.jdbc.JDBCStatement.fetchResult(Unknown Source) ~[hsqldb-2.3.3.jar:2.3.3]\n    at org.hsqldb.jdbc.JDBCStatement.execute(Unknown Source) ~[hsqldb-2.3.3.jar:2.3.3]\n    at com.zaxxer.hikari.pool.PoolBase.executeSql(PoolBase.java:467) ~[HikariCP-2.4.2.jar:na]\n    at com.zaxxer.hikari.pool.PoolBase.checkValidationMode(PoolBase.java:377) ~[HikariCP-2.4.2.jar:na]\n    at com.zaxxer.hikari.pool.PoolBase.setupConnection(PoolBase.java:336) ~[HikariCP-2.4.2.jar:na]\n    at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:315) ~[HikariCP-2.4.2.jar:na]\n    at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:171) ~[HikariCP-2.4.2.jar:na]\n    at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:441) [HikariCP-2.4.2.jar:na]\n    at com.zaxxer.hikari.pool.HikariPool.access$300(HikariPool.java:66) [HikariCP-2.4.2.jar:na]\n    at com.zaxxer.hikari.pool.HikariPool$PoolEntryCreator.call(HikariPool.java:576) [HikariCP-2.4.2.jar:na]\n    at com.zaxxer.hikari.pool.HikariPool$PoolEntryCreator.call(HikariPool.java:569) [HikariCP-2.4.2.jar:na]\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266) [na:1.8.0_66]\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_66]\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_66]\n    at java.lang.Thread.run(Thread.java:745) [na:1.8.0_66]\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/527/comments",
    "author": "debop",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-12-22T21:28:00Z",
        "body": "@debop HikariCP did not used to test validation queries during startup, now it does.  It looks like your `connectionTestQuery` contains an unnecessary trailing semi-colon.  Remove it and the error should go away.\n"
      }
    ]
  },
  {
    "number": 521,
    "title": "release/close active oracle connection after broken query",
    "created_at": "2015-12-15T09:34:20Z",
    "closed_at": "2016-07-06T11:58:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/521",
    "body": "Hi, i've the following problem.\n\nIn my application i have to use the following code:\nEntityManagerFactory emf = Persistence.createEntityManagerFactory(\"persistenceUnit\");\nEntityManager em = emf.createEntityManager();\nSession  session = em.unwrap(Session.class);\nSessionFactoryImplementor sfi = (SessionFactoryImplementor) session.getSessionFactory();\nConnectionProvider cp = sfi.getConnectionProvider();\nConnection connection = cp.getConnection();\n\nWhen i execute an invalid sql-statement an exception is thrown.\nso far so good.\n\nBut after executing\nconnection.close();\nsession.close();\n\nthe connection still remains active in the pool and will never been cleaned up.\n\nWhen i use\nsession.doWork(new Work\n{\nexecute(Connection connection)\n{\n// some code\n}\n}\n);\nsession.close();\n\neverything works fine. but in this special case i can't go this way.\n\ní'm using hikaricp 2.4.2 ,spring 4.0.7, hibernate 4.3.11 final\nAny ideas?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/521/comments",
    "author": "guidobonerz",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-12-15T10:48:28Z",
        "body": "@guidobonerz Can you enable debug logging and post the section of the log here?  This sounds like a Hibernate setting issue to me.  I also recommend asking this on stackoverflow.com, you'll probably get a faster solution.  Trust me, HikariCP doesn't have such trivial bugs, so it is almost certainly a Hibernate configuration issue.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2016-02-13T05:04:03Z",
        "body": "@guidobonerz Any update on this issue?\n"
      }
    ]
  },
  {
    "number": 515,
    "title": "How to disable any data source resource during startup in tomcat or tcServer",
    "created_at": "2015-12-07T06:28:22Z",
    "closed_at": "2016-01-28T13:59:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/515",
    "body": "In TcServer or Tomcat, The resources which we create are loaded during started. is there any way to stop any resource during startup.\nActually i have two data source resources with two different connection pooling.\nwant to enable one at a time. please help.\n\nThanks in advance.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/515/comments",
    "author": "mahendya",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-01-28T13:59:04Z",
        "body": "@mahendya This is a question better asked on stackoverflow.com\n"
      },
      {
        "user": "ozkanpakdil",
        "created_at": "2022-07-19T19:38:16Z",
        "body": "@mahendya did you ask it in SO ? I am also looking for same thing."
      }
    ]
  },
  {
    "number": 510,
    "title": "Connection not available for jdbc ResultSetMetaData",
    "created_at": "2015-11-27T15:37:14Z",
    "closed_at": "2015-11-28T03:59:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/510",
    "body": "I am using the Hikari connection pool in my application. Some collections I used are loaded from the resultset metada (the column names of some tables). Here the Hikari datasource fails in releasing the connection for other services to use it. \nExample:\n\n``` java\npublic List<String> getColumnsOfTable(final String table) throws AppException {\n        final List<String> retval = new ArrayList<String>();\n        final String sql = \"SELECT * FROM \" + table + \" WHERE 1=2\";\n        try (Connection con = getConnection();\n                PreparedStatement stm = con.prepareStatement(sql);\n                ResultSet rs = stm.executeQuery()) {\n            final ResultSetMetaData rsMeta = rs.getMetaData();\n            for (int i = 1; i <= rsMeta.getColumnCount(); i++) {\n                retval.add(rsMeta.getColumnName(i));\n            }\n        } catch (final Exception e) {\n            throw new AppException(e);\n        }\n        return retval;\n    }\n```\n\n``` xml\n<dependency>\n    <groupId>com.zaxxer</groupId>\n    <artifactId>HikariCP</artifactId>\n    <version>2.4.1</version>\n</dependency>\n```\n\nI've tried this code with BoneCP with the same ojdbc driver and this seems to work there, so I guess it's not a driver issue.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/510/comments",
    "author": "danjee",
    "comments": [
      {
        "user": "danjee",
        "created_at": "2015-11-27T16:42:33Z",
        "body": "The strange thing is that this happens when I use `dataSource.setMaximumPoolSize(1);` property. If I set it to 2 the sql runs OK and it runs many times not just once. Also I still see the connection as active even after one minute of idle time. `dataSource.setIdleTimeout(60000);`\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-11-28T03:59:29Z",
        "body": "If `minimumIdle` is not set, then it defaults to `maximumPoolSize`.   So, even if `idleTimeout` is set to 1 minute, as soon as the connection is closed it will be replaced in the pool.\n\nIf you want the pool to shrink, you need to set `minimumIdle` to something below `maximumPoolSize`.\n\nI recommend turning on DEBUG level logging, so you can see exactly what is happening in the pool regarding connections.\n"
      }
    ]
  },
  {
    "number": 509,
    "title": "HikariCP throws exceptions when multiple threads try to get and update at the same time",
    "created_at": "2015-11-26T15:35:02Z",
    "closed_at": "2015-12-03T14:20:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/509",
    "body": "the code:\nOrder order = this.hibernateTemplate.get(Order.class, id);\norder.setDescription(String.valueOf(System.currentTimeMillis()));\nthis.hibernateTemplate.update(order);\n\nif you run the above code in multiple threads, you probably will get the following exception:\nand this is not happening for org.apache.commons.dbcp2.BasicDataSource\n\ncom.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: No operations allowed after statement closed.\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:1.8.0_05]\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[na:1.8.0_05]\n    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:1.8.0_05]\n    at java.lang.reflect.Constructor.newInstance(Constructor.java:408) ~[na:1.8.0_05]\n    at com.mysql.jdbc.Util.handleNewInstance(Util.java:409) ~[mysql-connector-java-5.1.30.jar:na]\n    at com.mysql.jdbc.Util.getInstance(Util.java:384) ~[mysql-connector-java-5.1.30.jar:na]\n    at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1013) ~[mysql-connector-java-5.1.30.jar:na]\n    at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:987) ~[mysql-connector-java-5.1.30.jar:na]\n    at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:973) ~[mysql-connector-java-5.1.30.jar:na]\n    at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:918) ~[mysql-connector-java-5.1.30.jar:na]\n    at com.mysql.jdbc.StatementImpl.checkClosed(StatementImpl.java:463) ~[mysql-connector-java-5.1.30.jar:na]\n    at com.mysql.jdbc.StatementImpl.getMaxRows(StatementImpl.java:2155) ~[mysql-connector-java-5.1.30.jar:na]\n    at com.zaxxer.hikari.pool.HikariProxyPreparedStatement.getMaxRows(HikariProxyPreparedStatement.java) [HikariCP-2.4.2.jar:na]\n    at org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl.close(ResourceRegistryStandardImpl.java:154) [hibernate-core-5.0.2.Final.jar:5.0.2.Final]\n    at org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl.release(ResourceRegistryStandardImpl.java:82) [hibernate-core-5.0.2.Final.jar:5.0.2.Final]\n    at org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl.releaseStatements(AbstractBatchImpl.java:157) [hibernate-core-5.0.2.Final.jar:5.0.2.Final]\n    at org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl.release(AbstractBatchImpl.java:195) [hibernate-core-5.0.2.Final.jar:5.0.2.Final]\n    at org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.close(JdbcCoordinatorImpl.java:190) [hibernate-core-5.0.2.Final.jar:5.0.2.Final]\n    at org.hibernate.internal.SessionImpl.close(SessionImpl.java:420) [hibernate-core-5.0.2.Final.jar:5.0.2.Final]\n    at org.springframework.orm.hibernate5.SessionFactoryUtils.closeSession(SessionFactoryUtils.java:122) [spring-orm-4.2.2.RELEASE.jar:4.2.2.RELEASE]\n    at org.springframework.orm.hibernate5.HibernateTransactionManager.doCleanupAfterCompletion(HibernateTransactionManager.java:668) [spring-orm-4.2.2.RELEASE.jar:4.2.2.RELEASE]\n    at org.springframework.transaction.support.AbstractPlatformTransactionManager.cleanupAfterCompletion(AbstractPlatformTransactionManager.java:1016) [spring-tx-4.2.2.RELEASE.jar:4.2.2.RELEASE]\n    at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:811) [spring-tx-4.2.2.RELEASE.jar:4.2.2.RELEASE]\n    at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:730) [spring-tx-4.2.2.RELEASE.jar:4.2.2.RELEASE]\n    at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:485) [spring-tx-4.2.2.RELEASE.jar:4.2.2.RELEASE]\n    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:291) [spring-tx-4.2.2.RELEASE.jar:4.2.2.RELEASE]\n    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96) [spring-tx-4.2.2.RELEASE.jar:4.2.2.RELEASE]\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) [spring-aop-4.2.2.RELEASE.jar:4.2.2.RELEASE]\n    at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:653) [spring-aop-4.2.2.RELEASE.jar:4.2.2.RELEASE]\n    at com.ke.db.hibernate.repo.OrderDao$$EnhancerBySpringCGLIB$$55c00ebb.readAndUpdate(<generated>) [spring-core-4.2.2.RELEASE.jar:na]\n    at com.ke.db.hibernate.KeDbMain$1.run(KeDbMain.java:22) [bin/:na]\nException in thread \"Thread-1\" org.springframework.orm.hibernate5.HibernateOptimisticLockingFailureException: Batch update returned unexpected row count from update [0]; actual row count: 0; expected: 1; nested exception is org.hibernate.StaleStateException: Batch update returned unexpected row count from update [0]; actual row count: 0; expected: 1\n    at org.springframework.orm.hibernate5.SessionFactoryUtils.convertHibernateAccessException(SessionFactoryUtils.java:206)\n    at org.springframework.orm.hibernate5.HibernateTransactionManager.convertHibernateAccessException(HibernateTransactionManager.java:741)\n    at org.springframework.orm.hibernate5.HibernateTransactionManager.doCommit(HibernateTransactionManager.java:589)\n    at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:761)\n    at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:730)\n    at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:485)\n    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:291)\n    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n    at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:653)\n    at com.ke.db.hibernate.repo.OrderDao$$EnhancerBySpringCGLIB$$55c00ebb.readAndUpdate(<generated>)\n    at com.ke.db.hibernate.KeDbMain$1.run(KeDbMain.java:22)\nCaused by: org.hibernate.StaleStateException: Batch update returned unexpected row count from update [0]; actual row count: 0; expected: 1\n    at org.hibernate.jdbc.Expectations$BasicExpectation.checkBatched(Expectations.java:67)\n    at org.hibernate.jdbc.Expectations$BasicExpectation.verifyOutcome(Expectations.java:54)\n    at org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch.addToBatch(NonBatchingBatch.java:46)\n    at org.hibernate.persister.entity.AbstractEntityPersister.update(AbstractEntityPersister.java:3069)\n    at org.hibernate.persister.entity.AbstractEntityPersister.updateOrInsert(AbstractEntityPersister.java:2948)\n    at org.hibernate.persister.entity.AbstractEntityPersister.update(AbstractEntityPersister.java:3328)\n    at org.hibernate.action.internal.EntityUpdateAction.execute(EntityUpdateAction.java:145)\n    at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:447)\n    at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:333)\n    at org.hibernate.event.internal.AbstractFlushingEventListener.performExecutions(AbstractFlushingEventListener.java:335)\n    at org.hibernate.event.internal.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:39)\n    at org.hibernate.internal.SessionImpl.flush(SessionImpl.java:1224)\n    at org.hibernate.internal.SessionImpl.managedFlush(SessionImpl.java:464)\n    at org.hibernate.internal.SessionImpl.flushBeforeTransactionCompletion(SessionImpl.java:2894)\n    at org.hibernate.internal.SessionImpl.beforeTransactionCompletion(SessionImpl.java:2270)\n    at org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.beforeTransactionCompletion(JdbcCoordinatorImpl.java:485)\n    at org.hibernate.resource.transaction.backend.jdbc.internal.JdbcResourceLocalTransactionCoordinatorImpl.beforeCompletionCallback(JdbcResourceLocalTransactionCoordinatorImpl.java:146)\n    at org.hibernate.resource.transaction.backend.jdbc.internal.JdbcResourceLocalTransactionCoordinatorImpl.access$100(JdbcResourceLocalTransactionCoordinatorImpl.java:38)\n    at org.hibernate.resource.transaction.backend.jdbc.internal.JdbcResourceLocalTransactionCoordinatorImpl$TransactionDriverControlImpl.commit(JdbcResourceLocalTransactionCoordinatorImpl.java:230)\n    at org.hibernate.engine.transaction.internal.TransactionImpl.commit(TransactionImpl.java:65)\n    at org.springframework.orm.hibernate5.HibernateTransactionManager.doCommit(HibernateTransactionManager.java:581)\n    ... 9 more\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/509/comments",
    "author": "kewangie",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-11-26T15:53:26Z",
        "body": "This is because dbcp is not tracking Statements and closing them when the connection is closed (in violation of the JDBC specification).  I suspect if you run the same code without any pool, just a bare MySQL DataSource, you will get the same exception.\n"
      },
      {
        "user": "kewangie",
        "created_at": "2015-11-26T15:57:06Z",
        "body": "Cool. I was just wondering how HikariCP handles multi threading in this case?\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-12-03T14:20:19Z",
        "body": "@kewangie It is generally a bad idea to access a single Connection from multiple threads at the same time.  The JDBC specification used to allow it, but it was removed, and it not reliable on many drivers.  HikariCP _should_ work, but also makes no guarantees.\n"
      }
    ]
  },
  {
    "number": 505,
    "title": "turn off logging",
    "created_at": "2015-11-21T00:32:07Z",
    "closed_at": "2016-06-16T11:46:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/505",
    "body": "Hi, the default is to log a lot. \nHow do I make it less?\nSomething like:\nlog4j.logger.com.zaxxer.hikari=ERROR\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/505/comments",
    "author": "vicApakau",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-12-03T14:36:03Z",
        "body": "@vicApakau Are you saying even at INFO level HikariCP is logging too much?\n"
      },
      {
        "user": "awildturtok",
        "created_at": "2016-06-16T11:09:34Z",
        "body": "I'm facing a similar problem currently, as any logging by HikariCP interfers with data parsing in R. And I don't seem to manage to deactivate it, neither with a properties file, nor by forcing it in code.\n\nIs there any other way around that?\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2016-06-16T11:46:33Z",
        "body": "How you configure logging has nothing to do with HikariCP.  Some users use java.util.logging, some log4j, some log4j2, some logback, etc.  Each as a different way of configuring log levels.  If for some reason you cannot suppress HikariCP logs, it is absolulely a logging configuration issue, not a HikariCP issue.\n"
      }
    ]
  },
  {
    "number": 504,
    "title": "how to view connection statistics programmtically",
    "created_at": "2015-11-20T10:44:04Z",
    "closed_at": "2016-01-28T13:58:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/504",
    "body": "how to view connection statistics like in bonecp i can get Statistics of the connection\nFree, Lease and Total\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/504/comments",
    "author": "DavidMont",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-01-28T13:58:13Z",
        "body": "@DavidMont Check the wiki for JMX.\n"
      }
    ]
  },
  {
    "number": 486,
    "title": "Tomcat JNDI Configuration",
    "created_at": "2015-11-02T17:03:14Z",
    "closed_at": "2015-11-03T01:23:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/486",
    "body": "Hi, I'm trying to set this up using jndi, but getting an error on startup.  Here is my configuration in context.xml\n\n<Resource name=\"jdbc/name\" \n        auth=\"Container\" \n    factory=\"com.zaxxer.hikari.HikariJNDIFactory\" \n        type=\"javax.sql.DataSource\" \n        maximumPoolSize=\"10\"\n        connectionTimeout=\"300000\"\n        dataSourceClassName=\"com.mysql.jdbc.jdbc2.optional.MysqlDataSource\"\n        dataSource.url=\"jdbc:mysql://host:port/database?useUnicode=true&amp;characterEncoding=UTF-8&amp;useOldAliasMetadataBehavior=true\"\n        dataSource.user=\"root\" \n        dataSource.password=\"password\" \n    dataSource.implicitCachingEnabled=\"true\"\n/>\n\nAnd here is the stack trace\n\nWARNING: Unexpected exception resolving reference\njava.lang.RuntimeException: java.beans.IntrospectionException: Method not found: setImplicitCachingEnabled\n        at com.zaxxer.hikari.util.PropertyElf.setProperty(PropertyElf.java:141)\n        at com.zaxxer.hikari.util.PropertyElf.setTargetFromProperties(PropertyElf.java:64)\n        at com.zaxxer.hikari.pool.PoolElf.initializeDataSource(PoolElf.java:154)\n        at com.zaxxer.hikari.pool.HikariPool.<init>(HikariPool.java:113)\n        at com.zaxxer.hikari.HikariDataSource.<init>(HikariDataSource.java:73)\n        at com.zaxxer.hikari.HikariJNDIFactory.createDataSource(HikariJNDIFactory.java:76)\n        at com.zaxxer.hikari.HikariJNDIFactory.getObjectInstance(HikariJNDIFactory.java:67)\n        at org.apache.naming.factory.ResourceFactory.getObjectInstance(ResourceFactory.java:143)\n        at javax.naming.spi.NamingManager.getObjectInstance(NamingManager.java:321)\n        at org.apache.naming.NamingContext.lookup(NamingContext.java:843)\n        at org.apache.naming.NamingContext.lookup(NamingContext.java:154)\n        at org.apache.naming.NamingContext.lookup(NamingContext.java:831)\n        at org.apache.naming.NamingContext.lookup(NamingContext.java:168)\n        at org.apache.catalina.core.NamingContextListener.addResource(NamingContextListener.java:1061)\n        at org.apache.catalina.core.NamingContextListener.createNamingContext(NamingContextListener.java:671)\n        at org.apache.catalina.core.NamingContextListener.lifecycleEvent(NamingContextListener.java:270)\n        at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119)\n        at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90)\n        at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5161)\n        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\n        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:895)\n        at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:871)\n        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:615)\n        at org.apache.catalina.startup.HostConfig.deployDirectory(HostConfig.java:1099)\n        at org.apache.catalina.startup.HostConfig$DeployDirectory.run(HostConfig.java:1621)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:262)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n        at java.lang.Thread.run(Thread.java:745)\nCaused by: java.beans.IntrospectionException: Method not found: setImplicitCachingEnabled\n        at java.beans.PropertyDescriptor.<init>(PropertyDescriptor.java:110)\n        at com.zaxxer.hikari.util.PropertyElf.setProperty(PropertyElf.java:132)\n        ... 29 more\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/486/comments",
    "author": "wesoos",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-11-03T01:23:17Z",
        "body": "@wesoos Try the latest version of HikariCP.  The use of `java.beans` was removed several releases ago.\n"
      }
    ]
  },
  {
    "number": 479,
    "title": "About Pool Sizing",
    "created_at": "2015-10-29T22:24:50Z",
    "closed_at": "2015-10-31T06:42:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/479",
    "body": "I have a quick question about the part on Pool Sizing. \n\nSomething i do not understand, is that it seems that there is no difference made between the client side of the application and the database Server. \n\nWhen you give the formula on the PoolSize and the number of Core, this seems to concerns, the client side only. But the way it is explained, such as taking into account Disk access, this seems to be database related. Hence i wonder how the two connect because this seems to be confusing here. \n\nHow you Poolsize affect the perform of your application ? On the client size ? Does one connection correspond to one thread ? How does it affect the behavior of your database. \n\nAre your explanation only concerning the client side ? how does it relate to Blocking API vs Asynchronous API (database access). \n\nMany thanks\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/479/comments",
    "author": "Maatary",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-10-31T06:42:54Z",
        "body": "@Maatary The formula is used to determine how many concurrent connections _the database server_ is capable of handling before performance starts to decrease.  Because the query performance starts to decline when the number of _client connections_ exceeds that number, then that same number should be used to determine the maximum size of the pool _on the client_ (HikariCP).\n\nIn other words, there is a direct relation between the size of the pool (number of connections to the database) and the performance of the database.  If the peak transactions per second (TPS) performance of the database occurs at 16 concurrent queries, for example, then the pool should be set to allow 16 connections maximum.\n\nIf peak DB TPS performance occurs at 16 concurrent queries, then allowing 32 connections from the pool would likely result in _more than_ 2x decrease in TPS due to thread context switching overhead.\n"
      }
    ]
  },
  {
    "number": 474,
    "title": "com.zaxxer.hikari.pool.PoolInitializationException: Exception during pool initialization: Communications link failure",
    "created_at": "2015-10-28T07:25:12Z",
    "closed_at": "2015-10-28T07:37:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/474",
    "body": "Hi brettwooldridge, I'm using HikariCP as MySQL'dataSource with Spring Boot recently, but found some problems.\nThis is my hikari config in application.yml:\n\n```\nhikari:\n    poolName: HikariCP\n    minimumIdle: 5\n    maximumPoolSize: 25\n    connectionTimeout: 30000\n    idleTimeout: 30000\n    connectionTestQuery: SELECT 1\n    dataSourceClassName: com.mysql.jdbc.jdbc2.optional.MysqlDataSource\n    dataSourceProperties:\n        url: jdbc:mysql://127.0.0.1:13206/reactive?characterEncoding=UTF-8\n        user: test\n        password: test1234\n        ## Only for mysql\n        cachePrepStmts: true\n        prepStmtCacheSize: 300\n        prepStmtCacheSqlLimit: 2048\n```\n\nAnd the corresponding Java Bean is:\n\n```\n/**\n * provide url, user, password by calling addDataSourceProperty method\n */\n@Bean\n    public DataSource dataSource() {\n        HikariConfig configuration = new HikariConfig();\n        configuration.setPoolName(poolName);\n        configuration.setMinimumIdle(minimumIdle);\n        configuration.setMaximumPoolSize(maximumPoolSize);\n        configuration.setConnectionTimeout(connectionTimeout);\n        configuration.setIdleTimeout(idleTimeout);\n        configuration.setConnectionTestQuery(connectionTestQuery);\n        configuration.setDataSourceClassName(dataSourceClassName);\n\n        configuration.addDataSourceProperty(\"url\", url);\n        configuration.addDataSourceProperty(\"user\", user);\n        configuration.addDataSourceProperty(\"password\", password);\n        configuration.addDataSourceProperty(\"cachePrepStmts\", cachePrepStmts);\n        configuration.addDataSourceProperty(\"prepStmtCacheSize\", prepStmtCacheSize);\n        configuration.addDataSourceProperty(\"prepStmtCacheSqlLimit\", prepStmtCacheSqlLimit);\n\n        return new HikariDataSource(configuration);\n    }\n```\n\nIn this case, the connection pool works fine. When I use other configuration, exception occurred, as following:\n\n```\nhikari:\n    poolName: HikariCP\n    jdbcUrl: jdbc:mysql://127.0.0.1:13206/reactive?characterEncoding=UTF-8\n    username: test\n    password: test1234\n    minimumIdle: 5\n    maximumPoolSize: 25\n    connectionTimeout: 30000\n    idleTimeout: 30000\n    connectionTestQuery: SELECT 1\n    dataSourceClassName: com.mysql.jdbc.jdbc2.optional.MysqlDataSource\n    dataSourceProperties:\n        ## Only for mysql\n        cachePrepStmts: true\n        prepStmtCacheSize: 300\n        prepStmtCacheSqlLimit: 2048\n\n/**\n * provide jdbcUrl, username, password instead of calling addDataSourceProperty method\n */\n@Bean\n    public DataSource dataSource() {\n        HikariConfig configuration = new HikariConfig();\n        configuration.setPoolName(poolName);\n        configuration.setJdbcUrl(jdbcUrl);\n        configuration.setUsername(username);\n        configuration.setPassword(password);\n        configuration.setMinimumIdle(minimumIdle);\n        configuration.setMaximumPoolSize(maximumPoolSize);\n        configuration.setConnectionTimeout(connectionTimeout);\n        configuration.setIdleTimeout(idleTimeout);\n        configuration.setConnectionTestQuery(connectionTestQuery);\n        configuration.setDataSourceClassName(dataSourceClassName);\n\n        configuration.addDataSourceProperty(\"cachePrepStmts\", cachePrepStmts);\n        configuration.addDataSourceProperty(\"prepStmtCacheSize\", prepStmtCacheSize);\n        configuration.addDataSourceProperty(\"prepStmtCacheSqlLimit\", prepStmtCacheSqlLimit);\n\n        return new HikariDataSource(configuration);\n    }\n```\n\nThe **exception** information is:\n\n```\nThe last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:571)\n    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88)\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:331)\n    ... 30 more\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSource' defined in class path resource [com/github/dolphineor/springboot/configure/JpaConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [javax.sql.DataSource]: Factory method 'dataSource' threw exception; nested exception is com.zaxxer.hikari.pool.PoolInitializationException: Exception during pool initialization: Communications link failure\n\nThe last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.\n    at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:599)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1123)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1018)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:510)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)\n    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:305)\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:301)\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:196)\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1192)\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1116)\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1014)\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:543)\n    ... 32 more\nCaused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [javax.sql.DataSource]: Factory method 'dataSource' threw exception; nested exception is com.zaxxer.hikari.pool.PoolInitializationException: Exception during pool initialization: Communications link failure\n\nThe last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.\n    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:189)\n    at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:588)\n    ... 44 more\nCaused by: com.zaxxer.hikari.pool.PoolInitializationException: Exception during pool initialization: Communications link failure\n\nThe last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.\n    at com.zaxxer.hikari.pool.HikariPool.initializeConnections(HikariPool.java:581)\n    at com.zaxxer.hikari.pool.HikariPool.<init>(HikariPool.java:152)\n    at com.zaxxer.hikari.HikariDataSource.<init>(HikariDataSource.java:73)\n    at com.github.dolphineor.springboot.configure.JpaConfig.dataSource(JpaConfig.java:80)\n    at com.github.dolphineor.springboot.configure.JpaConfig$$EnhancerBySpringCGLIB$$20918aa0.CGLIB$dataSource$1(<generated>)\n    at com.github.dolphineor.springboot.configure.JpaConfig$$EnhancerBySpringCGLIB$$20918aa0$$FastClassBySpringCGLIB$$cf46bcfb.invoke(<generated>)\n    at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228)\n    at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:318)\n    at com.github.dolphineor.springboot.configure.JpaConfig$$EnhancerBySpringCGLIB$$20918aa0.dataSource(<generated>)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162)\n    ... 45 more\nCaused by: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure\n\nThe last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n    at java.lang.reflect.Constructor.newInstance(Constructor.java:422)\n    at com.mysql.jdbc.Util.handleNewInstance(Util.java:404)\n    at com.mysql.jdbc.SQLError.createCommunicationsException(SQLError.java:983)\n    at com.mysql.jdbc.MysqlIO.<init>(MysqlIO.java:339)\n    at com.mysql.jdbc.ConnectionImpl.coreConnect(ConnectionImpl.java:2252)\n    at com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2285)\n    at com.mysql.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:2084)\n    at com.mysql.jdbc.ConnectionImpl.<init>(ConnectionImpl.java:795)\n    at com.mysql.jdbc.JDBC4Connection.<init>(JDBC4Connection.java:44)\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n    at java.lang.reflect.Constructor.newInstance(Constructor.java:422)\n    at com.mysql.jdbc.Util.handleNewInstance(Util.java:404)\n    at com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:400)\n    at com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:327)\n    at com.mysql.jdbc.jdbc2.optional.MysqlDataSource.getConnection(MysqlDataSource.java:422)\n    at com.mysql.jdbc.jdbc2.optional.MysqlDataSource.getConnection(MysqlDataSource.java:134)\n    at com.zaxxer.hikari.pool.HikariPool.addConnection(HikariPool.java:496)\n    at com.zaxxer.hikari.pool.HikariPool.initializeConnections(HikariPool.java:565)\n    ... 58 more\nCaused by: java.net.ConnectException: connection refused\n    at java.net.PlainSocketImpl.socketConnect(Native Method)\n    at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n    at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n    at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n    at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)\n    at java.net.Socket.connect(Socket.java:589)\n    at com.mysql.jdbc.StandardSocketFactory.connect(StandardSocketFactory.java:214)\n    at com.mysql.jdbc.MysqlIO.<init>(MysqlIO.java:298)\n    ... 74 more\n```\n\nThe network's solution is setting MySQL's wait_timeout and interactive_timeout, but it doesn't work.\n\ndolphineor.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/474/comments",
    "author": "conchz",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-10-28T07:30:21Z",
        "body": "@dolphineor In the second case, you don't need:\n\n```\ndataSourceClassName: com.mysql.jdbc.jdbc2.optional.MysqlDataSource\n```\n\nThe `jdbcUrl` entry alone is sufficient.  If you get a driver not found error, you can add `driverClassName`, but it shouldn't be necessary.\n\nNOTE: you can still use `dataSourceProperties` even without a `dataSourceClassName`.\n"
      },
      {
        "user": "conchz",
        "created_at": "2015-10-28T07:37:22Z",
        "body": "^_^Thanks a lot, it works.\n"
      }
    ]
  },
  {
    "number": 471,
    "title": "Code requires Java 8 instead of the documented Java 7",
    "created_at": "2015-10-26T09:29:35Z",
    "closed_at": "2015-10-26T10:05:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/471",
    "body": "Although it's written on the main page (under requirements): ⇒ Java 7 and above, once I start my Play 2.3.8 application with HikariCP 2.3.7 and HikariCP Plugin for Play 2.3.x v.2.0.5 with Java 7 I get the following error:\n\n```\nCaused by: java.lang.UnsupportedClassVersionError: com/zaxxer/hikari/HikariConfig : Unsupported major.minor version 52.0\n```\n\nPlease clarify if HikariCP supports only Java 8 (and update the documentation) or it should support Java 7 (and fix the release bundles accordingly). I have checked the code and \n\nFull startup error log below:\n\n``````\nPlay server process ID is 24679\n[08:52:20.076] [info] [application] [main] - Creating Pool for datasource 'default'\nOops, cannot start the server.\n@6o0aaicfb: Cannot load plugin\n    at play.api.WithDefaultPlugins$$anonfun$plugins$1$$anonfun$apply$9.apply(Application.scala:154)\n    at play.api.WithDefaultPlugins$$anonfun$plugins$1$$anonfun$apply$9.apply(Application.scala:130)\n    at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:244)\n    at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:244)\n    at scala.collection.immutable.List.foreach(List.scala:318)\n    at scala.collection.TraversableLike$class.map(TraversableLike.scala:244)\n    at scala.collection.AbstractTraversable.map(Traversable.scala:105)\n    at play.api.WithDefaultPlugins$$anonfun$plugins$1.apply(Application.scala:130)\n    at play.api.WithDefaultPlugins$$anonfun$plugins$1.apply(Application.scala:166)\n    at play.utils.Threads$.withContextClassLoader(Threads.scala:21)\n    at play.api.WithDefaultPlugins$class.plugins(Application.scala:128)\n    at play.api.DefaultApplication.plugins$lzycompute(Application.scala:402)\n    at play.api.DefaultApplication.plugins(Application.scala:402)\n    at play.api.Play$$anonfun$start$1.apply$mcV$sp(Play.scala:91)\n    at play.api.Play$$anonfun$start$1.apply(Play.scala:91)\n    at play.api.Play$$anonfun$start$1.apply(Play.scala:91)\n    at play.utils.Threads$.withContextClassLoader(Threads.scala:21)\n    at play.api.Play$.start(Play.scala:90)\n    at play.core.StaticApplication.<init>(ApplicationProvider.scala:55)\n    at play.core.server.NettyServer$.createServer(NettyServer.scala:253)\n    at play.core.server.NettyServer$$anonfun$main$3.apply(NettyServer.scala:289)\n    at play.core.server.NettyServer$$anonfun$main$3.apply(NettyServer.scala:284)\n    at scala.Option.map(Option.scala:145)\n    at play.core.server.NettyServer$.main(NettyServer.scala:284)\n    at play.core.server.NettyServer.main(NettyServer.scala)\nCaused by: java.lang.UnsupportedClassVersionError: com/zaxxer/hikari/HikariConfig : Unsupported major.minor version 52.0\n    at java.lang.ClassLoader.defineClass1(Native Method)\n    at java.lang.ClassLoader.defineClass(ClassLoader.java:800)\n    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n    at java.net.URLClassLoader.defineClass(URLClassLoader.java:449)\n    at java.net.URLClassLoader.access$100(URLClassLoader.java:71)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:361)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:355)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at java.net.URLClassLoader.findClass(URLClassLoader.java:354)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:425)\n    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:358)\n    at com.edulify.play.hikaricp.HikariCPConfig$.toHikariConfig(HikariCPConfig.scala:25)\n    at com.edulify.play.hikaricp.HikariCPDBApi$$anonfun$2$$anonfun$3.apply(HikariCPDBApi.scala:49)\n    at com.edulify.play.hikaricp.HikariCPDBApi$$anonfun$2$$anonfun$3.apply(HikariCPDBApi.scala:46)\n    at scala.util.Try$.apply(Try.scala:161)\n    at com.edulify.play.hikaricp.HikariCPDBApi$$anonfun$2.apply(HikariCPDBApi.scala:46)\n    at com.edulify.play.hikaricp.HikariCPDBApi$$anonfun$2.apply(HikariCPDBApi.scala:44)\n    at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:244)\n    at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:244)\n    at scala.collection.immutable.Set$Set1.foreach(Set.scala:74)\n    at scala.collection.TraversableLike$class.map(TraversableLike.scala:244)\n    at scala.collection.AbstractSet.scala$collection$SetLike$$super$map(Set.scala:47)\n    at scala.collection.SetLike$class.map(SetLike.scala:93)\n    at scala.collection.AbstractSet.map(Set.scala:47)\n    at com.edulify.play.hikaricp.HikariCPDBApi.<init>(HikariCPDBApi.scala:44)\n    at com.edulify.play.hikaricp.HikariCPPlugin.<init>(HikariCPPlugin.scala:29)\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)\n    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n    at java.lang.reflect.Constructor.newInstance(Constructor.java:526)\n    at play.api.WithDefaultPlugins$$anonfun$plugins$1$$anonfun$apply$9.apply(Application.scala:132)\n    ... 24 more````\n``````\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/471/comments",
    "author": "daniel-anjos-zeroturnaround",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-10-26T10:05:50Z",
        "body": "This is fixed in 2.3.12.\n"
      }
    ]
  },
  {
    "number": 470,
    "title": "How to get MySQL Percona Mariadb concrete version?",
    "created_at": "2015-10-24T09:20:48Z",
    "closed_at": "2015-11-04T13:59:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/470",
    "body": "Do distinguish among them of all branches. \n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/470/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-11-01T04:09:34Z",
        "body": "@fjjiaboming I don't understand the question.  This sounds more like a question for Percona, or on stackoverflow Re: MySQL.\n"
      },
      {
        "user": "ghost",
        "created_at": "2015-11-02T05:35:06Z",
        "body": "I want to know which the app runs on MySQL by programming way .\nIs it mysql-community , percona  or  mariadb ? \n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-11-04T13:59:43Z",
        "body": "@fjjiaboming You're probably looking for the `Connection.getMetadata()` method.\n"
      },
      {
        "user": "ghost",
        "created_at": "2015-11-12T15:40:14Z",
        "body": "Tomorrow, I will have a try.  `Connection.getMetadata()`\n"
      }
    ]
  },
  {
    "number": 462,
    "title": "FastList.add method optimization",
    "created_at": "2015-10-18T15:20:59Z",
    "closed_at": "2015-10-18T23:49:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/462",
    "body": "Here is code in HikariCP\n\n```\n   /**\n    * Add an element to the tail of the FastList.\n    *\n    * @param element the element to add\n    */\n   @Override\n   public boolean add(T element)\n   {\n      try {\n         elementData[size++] = element;\n      }\n      catch (ArrayIndexOutOfBoundsException e) {\n         // overflow-conscious code\n         final int oldCapacity = elementData.length;\n         final int newCapacity = oldCapacity << 1;\n         @SuppressWarnings(\"unchecked\")\n         final T[] newElementData = (T[]) Array.newInstance(clazz, newCapacity);\n         System.arraycopy(elementData, 0, newElementData, 0, oldCapacity);\n         newElementData[size - 1] = element;\n         elementData = newElementData;\n      }\n\n      return true;\n   }\n```\n\nBut I wonder - throwing exception is pretty expensive. So why not usual if statement is used here for checking elementData.length?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/462/comments",
    "author": "doom369",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-10-18T23:49:24Z",
        "body": "I benchmarked both ways when the code was written.  This is faster 95% of the time.  It only incurs overhead when the list is expanded -- but that is a slow path anyway because of the memory copy.\n"
      }
    ]
  },
  {
    "number": 447,
    "title": "Why does Hikari depend on hibernate-core?",
    "created_at": "2015-10-07T20:20:28Z",
    "closed_at": "2015-10-08T13:02:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/447",
    "body": "That's a heavy dependency to pull in when a project just wants to use JDBC with a pooling impl. I'm curious why it is necessary. If it's only there to aid Hibernate projects, couldn't it be split into a separate library?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/447/comments",
    "author": "donaldquixote",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-10-08T13:02:56Z",
        "body": "I just built a project that depends on HikariCP and it did not pull in Hibernate as a dependency.  The dependency in the HikariCP _pom.xml_ is declared as:\n\n``` xml\n      <dependency>\n         <groupId>org.hibernate</groupId>\n         <artifactId>hibernate-core</artifactId>\n         <version>${hibernate.version}</version>\n         <scope>provided</scope>\n         <optional>true</optional>\n      </dependency>\n```\n\nWhich should not result in it being pulled in, unless you are building HikariCP itself.\n"
      },
      {
        "user": "donaldquixote",
        "created_at": "2015-10-08T14:49:47Z",
        "body": "Apologies for the noise, missed the scope piece. Thanks for your reply.\n"
      }
    ]
  },
  {
    "number": 441,
    "title": "Cannot resolve reference to bean 'hikariConfig' while setting constructor argument",
    "created_at": "2015-10-02T03:31:51Z",
    "closed_at": "2015-10-02T14:53:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/441",
    "body": "I am trying to switch from c3p0 to HikariCP after hearing great reviews from many people. I am stuck with one error. I couldn't figure out what exactly i am doing wrong.\nTech used: Spring 4, Hibernate 4.3.7, HikariCP 2.4.1, Oracle 11g and hibernate-hikaricp:5.0.2.Final\n\nSpring configuration file: config.xml\n\n```\n<bean id=\"dataSource\" class=\"com.zaxxer.hikari.HikariDataSource\"\n        destroy-method=\"close\">\n        <constructor-arg ref=\"hikariConfig\" />\n    </bean>\n    <bean id=\"hikariConfig\" class=\"com.zaxxer.hikari.HikariConfig\">\n        <property name=\"poolName\" value=\"springHikariCP\" />\n        <property name=\"connectionTestQuery\" value=\"SELECT 1\"/>\n        <property name=\"dataSourceClassName\" value=\"oracle.jdbc.pool.OracleDataSource\" />\n        <property name=\"dataSourceProperties\">\n            <props>\n                <prop key=\"url\">jdbc:oracle:thin:@ip-address:1521:xe</prop>\n                <prop key=\"user\">{username}</prop>\n                <prop key=\"password\">{password}</prop>\n            </props>\n        </property>\n    </bean>\n    <bean id=\"hibernate4SessionFactory\"\n        class=\"org.springframework.orm.hibernate4.LocalSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\" />\n        <property name=\"annotatedClasses\">\n     ......\n```\n\njava file:AccountsController.java\n\n```\n@RequestMapping(value = \"/web/validate\", method = RequestMethod.POST, produces = \"application/json\", consumes = \"application/json\")\n    public @ResponseBody ResponseEntity<String> webRequestValidate(@RequestBody String jsonData) throws AccountNotFoundException {\n\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"improvonia.xml\");\n        try {\n            UsersDAO usersDAO = context.getBean(UsersDAO.class);\n                         String result = usersDAO.validate(jsonData);\n                        ....\n```\n\nError message: \n\n```\n2015-10-01 19:23:51 INFO  XmlBeanDefinitionReader:317 - Loading XML bean definitions from class path resource [config.xml]\n2015-10-01 19:23:51 WARN  ClassPathXmlApplicationContext:487 - Exception encountered during context initialization - cancelling refresh attempt\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSource' defined in class path resource [config.xml]: Cannot resolve reference to bean 'hikariConfig' while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'hikariConfig' defined in class path resource [config.xml]: Instantiation of bean failed; nested exception is java.lang.ExceptionInInitializerError\n    at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:359)\n    at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:108)\n    at org.springframework.beans.factory.support.ConstructorResolver.resolveConstructorArguments(ConstructorResolver.java:648)\n    at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:140)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1131)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1034)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:504)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:476)\n    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:303)\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:299)\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:194)\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:762)\n    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:757)\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:480)\n    at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:139)\n    at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:83)\n    at com.improvonia.app.api.AccountsController.webRequestValidate(AccountsController.java:126)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:221)\n    at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137)\n    at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110)\n    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:777)\n    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:706)\n    at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85)\n    at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943)\n    at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877)\n    at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966)\n    at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:868)\n    at javax.servlet.http.HttpServlet.service(HttpServlet.java:648)\n    at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842)\n    at javax.servlet.http.HttpServlet.service(HttpServlet.java:729)\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:291)\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\n    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\n    at org.apache.catalina.filters.CorsFilter.handleNonCORS(CorsFilter.java:438)\n    at org.apache.catalina.filters.CorsFilter.doFilter(CorsFilter.java:179)\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\n    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:219)\n    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106)\n    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:502)\n    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:142)\n    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79)\n    at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:617)\n    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88)\n    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:518)\n    at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1091)\n    at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:668)\n    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1521)\n    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1478)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n```\n\nAny pointers will be greatly appreciated!\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/441/comments",
    "author": "naveentammineni",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-10-02T14:53:34Z",
        "body": "Sorry, though we welcome HikariCP questions here, we are not Spring gurus.  You'll likely get faster help in the Spring support groups.\n\nGood luck.\n\nEDIT: You can try asking in the HikariCP Google Group, as there are some Spring/Hibernate users there...\n"
      }
    ]
  },
  {
    "number": 436,
    "title": "HikariCP 2.3.10",
    "created_at": "2015-09-30T10:43:16Z",
    "closed_at": "2015-10-01T05:54:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/436",
    "body": "Hi,\n\nI recently upgraded to 2.3.10 since then i keep seeing the following in my logs:\n\n2015-09-30 06:41:54,164 [http-apr-11910-exec-33] DEBUG com.zaxxer.hikari.proxy.ConnectionProxy - HikariPool-0 Resetting dirty on com.mysql.jdbc.JDBC4Connection@7487fd38 (readOnlyDirty=false,autoCommitDirty=false,isolationDirty=false,catalogDirty=true)\n2015-09-30 06:41:54,283 [http-apr-11910-exec-9] DEBUG com.zaxxer.hikari.proxy.ConnectionProxy - HikariPool-0 Resetting dirty on com.mysql.jdbc.JDBC4Connection@5b019393 (readOnlyDirty=false,autoCommitDirty=false,isolationDirty=false,catalogDirty=true)\n2015-09-30 06:41:54,284 [http-apr-11910-exec-9] DEBUG com.zaxxer.hikari.proxy.ConnectionProxy - HikariPool-0 Resetting dirty on com.mysql.jdbc.JDBC4Connection@5b019393 (readOnlyDirty=false,autoCommitDirty=false,isolationDirty=false,catalogDirty=true)\n2015-09-30 06:41:54,284 [http-apr-11910-exec-9] DEBUG com.zaxxer.hikari.proxy.ConnectionProxy - HikariPool-0 Resetting dirty on com.mysql.jdbc.JDBC4Connection@5b019393 (readOnlyDirty=false,autoCommitDirty=false,isolationDirty=false,catalogDirty=true)\n2015-09-30 06:41:54,547 [http-apr-11910-exec-30] DEBUG com.zaxxer.hikari.proxy.ConnectionProxy - HikariPool-0 Resetting dirty on com.mysql.jdbc.JDBC4Connection@b380b2 (readOnlyDirty=false,autoCommitDirty=false,isolationDirty=false,catalogDirty=true)\n\nCan you please explain what is this about ? not sure this is actually an error ? \n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/436/comments",
    "author": "dannygu",
    "comments": [
      {
        "user": "dannygu",
        "created_at": "2015-09-30T10:54:33Z",
        "body": "FYI - 2.4.1 gives me the folllwing:\n\n2015-09-30 06:53:35,139 [http-apr-11920-exec-31] DEBUG com.zaxxer.hikari.pool.PoolElf - HikariPool-0 - Reset (nothing) on connection com.mysql.jdbc.JDBC4Connection@2c9335cb\n2015-09-30 06:53:35,140 [http-apr-11920-exec-31] DEBUG com.zaxxer.hikari.pool.PoolElf - HikariPool-0 - Reset (nothing) on connection com.mysql.jdbc.JDBC4Connection@2c9335cb\n2015-09-30 06:53:35,140 [http-apr-11920-exec-31] DEBUG com.zaxxer.hikari.pool.PoolElf - HikariPool-0 - Reset (nothing) on connection com.mysql.jdbc.JDBC4Connection@2c9335cb\n2015-09-30 06:53:35,150 [http-apr-11920-exec-31] DEBUG com.zaxxer.hikari.pool.PoolElf - HikariPool-0 - Reset (catalog) on connection com.mysql.jdbc.JDBC4Connection@2c9335cb\n2015-09-30 06:53:35,911 [http-apr-11920-exec-4] DEBUG com.zaxxer.hikari.pool.PoolElf - HikariPool-0 - Reset (nothing) on connection com.mysql.jdbc.JDBC4Connection@d38e31b\n\nis this the same as above ? \n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-09-30T14:41:48Z",
        "body": "@dannygu Yes, the second is the same as the first.\n\nThis would be triggered by a framework (Hibernate, etc.) or your application itself, for example, calling `connection.setAutoCommit(false)` when the pool is already configured as autoCommit=false.\n\nWhy is this logged?  Well, many drivers (for example MySQL) will by default perform a roundtrip to the database whenever `setAutoCommit()` is called.  Even if the driver could know that it is a _no-op_ it will do so.  For example:\n\n``` java\nconnection.setAutoCommit(true);\nconnection.setAutoCommit(true);\n```\n\nwill result in two roundtrips to the database, even though the second is obviously unnecessary.  In the case of MySQL, the driver can be configured to cache connection state and ignore the second call, but that is not the default behavior.\n\nIn a nutshell, this log is saying something called `setReadOnly()`, `setAutoCommit()`, `setTransactionIsolation()`, and `setCatalog()`, but the values were actually the same as the pool connection defaults (_\"Reset (nothing) on connection ...\"_) -- so this resulted in 4 wasted roundtrips to the database.\n"
      }
    ]
  },
  {
    "number": 434,
    "title": "Pooled connection couldn't be reused.",
    "created_at": "2015-09-28T14:51:14Z",
    "closed_at": "2015-09-28T15:59:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/434",
    "body": "Failed to test reusing the pooled connection on `HikariCP 2.4.1` below,\n\n``` java\n\nimport java.sql.Connection;\nimport com.zaxxer.hikari.HikariDataSource;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n\n        HikariDataSource ds = new HikariDataSource();\n        ds.setJdbcUrl(\"jdbc:mysql:///test\");\n        ds.setAutoCommit(false);\n        ds.setMaximumPoolSize(1);\n\n        Connection conn = ds.getConnection();\n        conn.createStatement().executeQuery(\"select 1\");\n\n        new Thread(() -> {\n            try {\n/*   \n  The following line caused java.sql.SQLTransientConnectionException: \n  HikariPool-0 - Connection is not available, request timed out after 30000ms.\n*/\n                Connection conn2 = ds.getConnection(); \n                conn2.createStatement().executeQuery(\"select 2\");\n                conn2.commit();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        conn.commit();\n    }\n}\n\n```\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/434/comments",
    "author": "fansgit",
    "comments": [
      {
        "user": "chrisvest",
        "created_at": "2015-09-28T15:09:48Z",
        "body": "You never close the first connection you grab, so it never returns to the pool.\n"
      },
      {
        "user": "fansgit",
        "created_at": "2015-09-28T15:22:54Z",
        "body": "@chrisvest How to check if the connection returns to the pool after it's closed?\n"
      },
      {
        "user": "chrisvest",
        "created_at": "2015-09-28T15:31:16Z",
        "body": "It returns to the pool if you can `ds.getConnection()` again. But first, you have to `conn.close()` it.\n"
      },
      {
        "user": "fansgit",
        "created_at": "2015-09-28T15:35:03Z",
        "body": "Connection conn = ds.getConnection();\nconn.close();\nassertEqual(conn, ds.getConnection()); // Why does it fail if the connection returns to the pool?\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-09-28T15:59:42Z",
        "body": "@fansgit That assert fails because the proxy object returned by each call to `getConnection()` is unique.\n\nThis would work:\n\n``` java\nConnection connection = ds.getConnection();\nConnection unwrap = connection.unwrap(Connection.class);\nAssert.assertNotNull(connection);\n\nconnection.close();\nconnection =  ds.getConnection();\nConnection unwrap2 = connection.unwrap(Connection.class);\n\nassertEqual(unwrap, unwrap2);\n```\n\nThe `unwrap()` call gets the underlying actual Connection object to the DB which the proxy (delegator) class returned by `getConnection()` is wrapping.\n"
      },
      {
        "user": "fansgit",
        "created_at": "2015-09-28T16:15:21Z",
        "body": "@brettwooldridge thanks. I overlooked `unwrap`. Proxy makes perfect sense here. The `close` only destroys the connection wrapper but releases the underlying connection to the pool. How is this related to `active` or `idle` connection status?\n"
      }
    ]
  },
  {
    "number": 417,
    "title": "NPE in setLoginTimeout with 2.4.1 release",
    "created_at": "2015-09-14T18:29:44Z",
    "closed_at": "2015-09-17T03:35:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/417",
    "body": "Hi,\n\nI was using 2.3.7 and upgraded to 2.4.1 and ran into an NPE.\nIt appears there is a circular dependency ( not necessarily a bad thing ) in the HikariDataSource class.\nMaybe some null checks are needed for the \"pool\" reference.\n\nHere is the relevant trace:\nCaused by: java.lang.NullPointerException\n    at com.zaxxer.hikari.HikariDataSource.setLoginTimeout(HikariDataSource.java:131)\n    at org.springframework.jdbc.datasource.DelegatingDataSource.setLoginTimeout(DelegatingDataSource.java:104)\n    at com.zaxxer.hikari.pool.PoolElf.setLoginTimeout(PoolElf.java:504)\n    at com.zaxxer.hikari.pool.PoolElf.initializeDataSource(PoolElf.java:161)\n    at com.zaxxer.hikari.pool.HikariPool.<init>(HikariPool.java:113)\n    at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:96)\n\nIn 2.3.7, the HikariDataSource uses a map in the setLoginTimeout() and so does not encounter this problem. ( 2.3.7 implementation below ).\n\n   public void setLoginTimeout(int seconds) throws SQLException\n   {\n      for (HikariPool hikariPool : multiPool.values()) {\n         hikariPool.getDataSource().setLoginTimeout(seconds);\n      }\n   }\n\nThanks,\nPrakash\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/417/comments",
    "author": "prakashgs",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-09-15T04:22:54Z",
        "body": "... wait, what?  How is it that `HikariDataSource` is wrapping a `DelegatingDataSource` that itself wraps a `HikariDataSource`?\n\nThat seems like a configuration issue to me.  I understand that it used to succeed, but that was just by luck, not by design.\n"
      },
      {
        "user": "prakashgs",
        "created_at": "2015-09-17T03:35:32Z",
        "body": "Brett, I think you are right about this being a Spring config issue. I will investigate more. Will close this for now.\n"
      },
      {
        "user": "danjee",
        "created_at": "2016-05-11T11:37:34Z",
        "body": "I got the same error with 2.4.1 and the following xml configuration:\n\n``` xml\n<bean id=\"hikariConfig\" class=\"com.zaxxer.hikari.HikariConfig\">\n        <property name=\"poolName\" value=\"springHikariCP\" />\n        <property name=\"dataSourceClassName\" value=\"com.zaxxer.hikari.HikariDataSource\" />\n        <property name=\"maximumPoolSize\" value=\"2\" />\n        <property name=\"idleTimeout\" value=\"600000\" />\n        <property name=\"connectionTimeout\" value=\"20000\" />\n        <property name=\"dataSourceProperties\">\n            <props>\n                <prop key=\"jdbcUrl\">jdbc:oracle:thin:@vs1706.intranet.asf.ro:1521:CAPONE</prop>\n                <prop key=\"username\">capagency</prop>\n                <prop key=\"password\">capone</prop>\n            </props>\n        </property>\n</bean>\n\n    <!-- HikariCP configuration -->\n<bean id=\"dataSource\" class=\"com.zaxxer.hikari.HikariDataSource\" destroy-method=\"close\">\n        <constructor-arg ref=\"hikariConfig\" />\n</bean>\n```\n\nWhen downgrading to 2.3.7 it worked well.\n\nThe configuration from java code works well:\n\n``` java\n    @Bean(destroyMethod = \"close\")\n    public DataSource dataSource() {\n        final HikariDataSource dataSource = new HikariDataSource();\n        dataSource.setDriverClassName(\"oracle.jdbc.driver.OracleDriver\");\n        dataSource.setJdbcUrl(\"jdbc:oracle:thin:@vs1706.intranet.asf.ro:1521:CAPONE\");\n        dataSource.setUsername(\"capagency\");\n        dataSource.setPassword(\"capone\");\n        dataSource.setIdleTimeout(600000);\n        dataSource.setMinimumIdle(0);\n        dataSource.setMaximumPoolSize(2);\n        dataSource.setConnectionTimeout(180000);\n        return dataSource;\n    }\n```\n\nI think the issue should be reopened.\n\nThank you\n"
      },
      {
        "user": "nitincchauhan",
        "created_at": "2016-05-11T12:25:02Z",
        "body": "@danjee try latest 2.4.6 and if it does not work, please post more info like stack trace if any exception or 'debug' logs.\n"
      }
    ]
  },
  {
    "number": 409,
    "title": "Connecting Redshift fails.",
    "created_at": "2015-09-03T09:14:25Z",
    "closed_at": "2015-09-03T13:10:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/409",
    "body": "Hi @brettwooldridge \n\nI am trying the following configuration in my hibernate.cfg.xml \n\n<property name=\"connection.driver_class\">com.amazon.redshift.jdbc41.Driver</property>\n        <property name=\"connection.url\">jdbc:redshift://host:5439/databasename</property>\n        <property name=\"connection.username\">username</property>\n        <property name=\"connection.password\">password</property>\n        <property name=\"hibernate.connection.provider_class\">com.zaxxer.hikari.hibernate.HikariConnectionProvider</property>\n        <property name=\"hibernate.hikari.dataSourceClassName\">com.amazon.redshift.jdbc41.DataSource</property>\n        <property name=\"hibernate.hikari.minimumIdle\">5</property>\n        <property name=\"hibernate.hikari.maximumPoolSize\">10</property>\n        <property name=\"hibernate.hikari.idleTimeout\">30000</property> \n\nBut it gives me Null pointer \n\njava.lang.NullPointerException: null\n    at org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(JdbcServicesImpl.java:244) ~[stormjar.jar:na]\n    at org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.configureService(StandardServiceRegistryImpl.java:111) ~[stormjar.jar:na]\n    at org.hibernate.service.internal.AbstractServiceRegistryImpl.initializeService(AbstractServiceRegistryImpl.java:234) ~[stormjar.jar:na]\n    at org.hibernate.service.internal.AbstractServiceRegistryImpl.getService(AbstractServiceRegistryImpl.java:206) ~[stormjar.jar:na]\n    at org.hibernate.cfg.Configuration.buildTypeRegistrations(Configuration.java:1887) ~[stormjar.jar:na]\n    at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1845) ~[stormjar.jar:na]\n\nCan you please help me out of this I think I have done something wrong in the configuration ?\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/409/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-09-03T13:10:15Z",
        "body": "I don't see HikariCP in this stacktrace, I suspect a misconfiguration elsewhere.  However, you do not need both the _driverClassName_ and _jdbcUrl_ **and** _dataSourceClassName_.  Likely, the driver class and JDBC url are all you need, get rid of the dataSourceClassName.\n"
      }
    ]
  },
  {
    "number": 394,
    "title": "Separate pools for reading and writing to SQL database",
    "created_at": "2015-08-24T11:19:32Z",
    "closed_at": "2015-08-24T11:34:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/394",
    "body": "I'm working on an spring-boot web application application using spring-boot-jpa (Spring Data JPA) to store and retrieve data in a relational database.\nI have a brief idea about HikariCP and using it to manage multiple connection pools. But, I want to perform read operations (DQL) and write operations (DML) on the same database using separate connection pools respectively.\n\nIs there a way to achieve the same??\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/394/comments",
    "author": "themoonraker13",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-08-24T11:34:41Z",
        "body": "This is primarily a Spring Data question.  HikariCP has not limitation that would prevent you from creating two pools in one application pointing to the same DB.  It's no different than many application servers connected to the same DB.  I suggesting asking on stackoverflow.com or over on the Spring Data forums.\n"
      }
    ]
  },
  {
    "number": 391,
    "title": "Impossible to pass connection specific properties",
    "created_at": "2015-08-20T16:38:01Z",
    "closed_at": "2015-08-20T21:28:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/391",
    "body": "On my particular Oracle CP on HikariCP (ds) theres no way to pass specific Connection parameters:\n\n```\n    HikariConfig conf = new HikariConfig(\"testCpConnection.properties\");\n    HikariDataSource ds = new HikariDataSource(conf);\n    Properties pp = new Properties();\n    pp.put(\"connectionProperties.defaultRowPrefetch\", \"10000\");\n    ds.setDataSourceProperties(pp);\n```\n\nwith Orcle DataSource is possible to do this:\n\n```\n    OracleDataSource ds = new OracleDataSource();\n    ds.setURL(\"jdbc:oracle:thin:@xxxxxxxxx\");\n    ds.setUser(\"user\");\n    ds.setPassword(\"password\");\n\n    Properties pp = new Properties();\n    pp.put(\"defaultRowPrefetch\", \"10000\");\n\n    ds.setConnectionProperties(pp);\n```\n\nperhaps I'm wrong also because in some previous version was possible to implement an IConnectionCustomizer that isn't supported anymore.\n\nRegards\n    Antonio\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/391/comments",
    "author": "aconte76",
    "comments": [
      {
        "user": "jnehlmeier",
        "created_at": "2015-08-20T19:20:22Z",
        "body": "I guess you can use \n\n``` java\nOracleDataSource oracleDs = new OracleDataSource();\nProperties pp = new Properties();\npp.put(\"defaultRowPrefetch\", \"10000\");\noracleDs.setConnectionProperties(pp);\n\nHikariConfig conf = new HikariConfig(\"testCpConnection.properties\");\nconf.setDatasource(oracleDs);\nHikariDataSource ds = new HikariDataSource(conf);\n```\n\nThen HikariCP should use the OracleDataSource for creating connections to fill the Hikari pool.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-08-20T21:28:41Z",
        "body": "@jnehlmeier That is correct.\n"
      },
      {
        "user": "aconte76",
        "created_at": "2015-08-21T09:20:14Z",
        "body": "Right, it works correctly, sorry for my mistake.\n\nThx a lot\n   Antonio\n"
      }
    ]
  },
  {
    "number": 381,
    "title": "Timeout after 20005ms of waiting for a connection",
    "created_at": "2015-08-13T16:38:38Z",
    "closed_at": "2015-08-14T13:46:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/381",
    "body": "My project has been working well, but recently I changed the queueSize config variable to -1 (unlimited) to resolve a previous error, and I upgraded to java8. I am not sure why I am getting this timeout error recently, as it did not appear to be an immediate consequence of the changes I made.  Sometimes the timeout error resolves itself if I restart SBT.\n\nPlease let me know any further information I can provide for solving this issue.\n\nMy Configuration:\n\n```\ndefault_db {\n  url = \"jdbc:mysql://\"${MYHOST}\"/myproj\"\n  user = ...\n  password = ...\n  queueSize = -1\n  numThreads = 16\n  connectionPool = HikariCP\n  connectionTimeout = 20000\n  maxConnections = 40\n}\n```\n\n```\n\"err\":{\"message\":\"Timeout after 20005ms of waiting for a connection.\",\"stackTrace\":[{\"file\":\"BaseHikariPool.java\",\"line\":228,\"className\":\"com.zaxxer.hikari.pool.BaseHikariPool\",\"method\":\"getConnection\"},{\"file\":\"BaseHikariPool.java\",\"line\":183,\"className\":\"com.zaxxer.hikari.pool.BaseHikariPool\",\"method\":\"getConnection\"},{\"file\":\"HikariDataSource.java\",\"line\":91,\"className\":\"com.zaxxer.hikari.HikariDataSource\",\"method\":\"getConnection\"},{\"file\":\"JdbcDataSource.scala\",\"line\":131,\"className\":\"scala.slick.jdbc.HikariCPJdbcDataSource\",\"method\":\"createConnection\"},{\"file\":\"JdbcBackend.scala\",\"line\":362,\"className\":\"scala.slick.jdbc.JdbcBackend$BaseSession\",\"method\":\"conn$lzycompute\"},{\"file\":\"JdbcBackend.scala\",\"line\":362,\"className\":\"scala.slick.jdbc.JdbcBackend$BaseSession\",\"method\":\"conn\"},{\"file\":\"JdbcBackend.scala\",\"line\":241,\"className\":\"scala.slick.jdbc.JdbcBackend$SessionDef$class\",\"method\":\"prepareStatement\"},{\"file\":\"JdbcBackend.scala\",\"line\":354,\"className\":\"scala.slick.jdbc.JdbcBackend$BaseSession\",\"method\":\"prepareStatement\"},{\"file\":\"StatementInvoker.scala\",\"line\":32,\"className\":\"scala.slick.jdbc.StatementInvoker\",\"method\":\"results\"},{\"file\":\"StatementInvoker.scala\",\"line\":22,\"className\":\"scala.slick.jdbc.StatementInvoker\",\"method\":\"iteratorTo\"},{\"file\":\"Invoker.scala\",\"line\":15,\"className\":\"scala.slick.jdbc.Invoker$class\",\"method\":\"iterator\"},{\"file\":\"StatementInvoker.scala\",\"line\":16,\"className\":\"scala.slick.jdbc.StatementInvoker\",\"method\":\"iterator\"},{\"file\":\"Invoker.scala\",\"line\":57,\"className\":\"scala.slick.jdbc.Invoker$class\",\"method\":\"foreach\"},{\"file\":\"StatementInvoker.scala\",\"line\":16,\"className\":\"scala.slick.jdbc.StatementInvoker\",\"method\":\"foreach\"},{\"file\":\"JdbcActionComponent.scala\",\"line\":109,\"className\":\"scala.slick.driver.JdbcActionComponent$StreamingResultAction\",\"method\":\"run\"},{\"file\":\"DatabaseComponent.scala\",\"line\":193,\"className\":\"scala.slick.backend.DatabaseComponent$DatabaseDef$$anon$2\",\"method\":\"liftedTree1$1\"},{\"file\":\"DatabaseComponent.scala\",\"line\":193,\"className\":\"scala.slick.backend.DatabaseComponent$DatabaseDef$$anon$2\",\"method\":\"run\"},{\"file\":\"ThreadPoolExecutor.java\",\"line\":1142,\"className\":\"java.util.concurrent.ThreadPoolExecutor\",\"method\":\"runWorker\"},{\"file\":\"ThreadPoolExecutor.java\",\"line\":617,\"className\":\"java.util.concurrent.ThreadPoolExecutor$Worker\",\"method\":\"run\"},{\"file\":\"Thread.java\",\"line\":745,\"className\":\"java.lang.Thread\",\"method\":\"run\"}]},\"status\":200}\n```\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/381/comments",
    "author": "richfwebb",
    "comments": [
      {
        "user": "jnehlmeier",
        "created_at": "2015-08-13T21:06:49Z",
        "body": "Usually it means that maxConnections has been reached and no one returned a connection to the pool within 20 seconds. Thus the pool can not hand out a connection within 20 seconds and the exception is thrown. Its either a connection leak (enable leak detection in Hikari) or you simply throw too much work at your pool / database.\n\nTo understand what is going on in your app you have to collect metrics and analyze them. Maybe changing queueSize had more consequences than you thought. But you can only know that if you have metrics.\n"
      },
      {
        "user": "richfwebb",
        "created_at": "2015-08-13T21:13:49Z",
        "body": "After more inspection, the connections continue to increase and it appears they are not being closed properly. I will close the issue.\n"
      },
      {
        "user": "richfwebb",
        "created_at": "2015-08-13T21:22:59Z",
        "body": "Is it better practice to explicitly call db.close each time you instantiate a db variable, or would it be equally correct to set an idleTimeout in the config (with idleTimeout < connectionTimeout, so that the threads are returned or removed from the pool, before connectionTimeout throws an error). Is that correct?\n"
      },
      {
        "user": "jnehlmeier",
        "created_at": "2015-08-13T21:39:48Z",
        "body": "You **must** call Connection.close(). Your \"idleTimeout trick\" would not work at all, because connections that you have retrieved from the pool/datasource are considered active and not idle. They will only be considered idle again if you call connection.close(). So if you never call it then you end up with 40 active connections, 0 idle connections and finally you get the exception above.\n"
      },
      {
        "user": "richfwebb",
        "created_at": "2015-08-14T13:46:28Z",
        "body": "Thanks!\n"
      }
    ]
  },
  {
    "number": 367,
    "title": "HikariCP 2.4.0 HikariDataSource.getConnection(string, string) is not supported now",
    "created_at": "2015-08-05T07:53:02Z",
    "closed_at": "2015-08-05T10:50:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/367",
    "body": "Spring's (version 4.0.2) UserCredentialsDataSourceAdapter fails to getConnection(username, password) now, but works with HikariCP 2.2.5\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/367/comments",
    "author": "Yaro77",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-08-05T10:50:12Z",
        "body": "Support for this method was removed in 2.4.0.  You can read the drama here #231.\n"
      },
      {
        "user": "nevot",
        "created_at": "2015-10-01T11:05:26Z",
        "body": "So , how can we pass user login credentials now ?\n"
      }
    ]
  },
  {
    "number": 366,
    "title": "java.sql.SQLTimeoutException: Timeout after 30002ms of waiting for a connection.",
    "created_at": "2015-08-04T08:11:30Z",
    "closed_at": "2015-08-04T09:57:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/366",
    "body": "2015-08-04 13:59:10.735 [pool-6-thread-16] DEBUG com.zaxxer.hikari.pool.HikariPool - Timeout failure pool HikariPool-0 stats (total=10, active=10, idle=0, waiting=1)\n2015-08-04 13:59:10.736 [pool-6-thread-16] ERROR  - \njava.sql.SQLTimeoutException: Timeout after 30002ms of waiting for a connection.\n    at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:211) ~[HikariCP-2.4.0.jar:?]\n    at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:161) ~[HikariCP-2.4.0.jar:?]\n    at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:85) ~[HikariCP-2.4.0.jar:?]\n    at com.flhx.core.db.memory.Memory.getConnection(Memory.java:453) ~[core-0.1.1.jar:0.1.1]\n    at com.flhx.core.db.memory.Memory.query(Memory.java:44) ~[core-0.1.1.jar:0.1.1]\n    at com.flhx.gs.role.dao.RoleBaseDao.readRoleIdByUid(RoleBaseDao.java:57) ~[gs-0.1.1.jar:0.1.1]\n    at com.flhx.gs.role.service.RoleBaseService.readRoleIdByUidFormDb(RoleBaseService.java:794) ~[gs-0.1.1.jar:0.1.1]\n    at com.flhx.gs.role.service.RoleBaseService.loginGame(RoleBaseService.java:189) ~[gs-0.1.1.jar:0.1.1]\n    at com.flhx.gs.role.handler.LoginGameHandler.execute(LoginGameHandler.java:34) ~[gs-0.1.1.jar:0.1.1]\n    at com.flhx.core.net.handler.GameHandler.action(GameHandler.java:19) ~[core-0.1.1.jar:0.1.1]\n    at com.flhx.core.net.dispatcher.HandlerDispatcher$MessageWorker.handMessageQueue(HandlerDispatcher.java:225) [core-0.1.1.jar:0.1.1]\n    at com.flhx.core.net.dispatcher.HandlerDispatcher$MessageWorker.run(HandlerDispatcher.java:194) [core-0.1.1.jar:0.1.1]\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [?:1.8.0_45]\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [?:1.8.0_45]\n    at java.lang.Thread.run(Thread.java:745) [?:1.8.0_45]\n\nonly a client connection test\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/366/comments",
    "author": "maoxianfly",
    "comments": [
      {
        "user": "maoxianfly",
        "created_at": "2015-08-04T08:42:36Z",
        "body": "Hi Brett,\n\nThe active connection pool is not recycled ?\n\n# \n\n2015-08-04 15:56:23.591 [Hikari housekeeper (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - After cleanup pool HikariPool-0 stats (total=10, active=2, idle=8, waiting=0)\n2015-08-04 15:56:53.594 [Hikari housekeeper (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - Before cleanup pool HikariPool-0 stats (total=10, active=2, idle=8, waiting=0)\n2015-08-04 15:56:53.594 [Hikari housekeeper (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - After cleanup pool HikariPool-0 stats (total=10, active=2, idle=8, waiting=0\n\n2015-08-04 16:34:23.591 [Hikari housekeeper (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - Before cleanup pool HikariPool-0 stats (total=10, active=2, idle=8, waiting=0)\n2015-08-04 16:34:23.591 [Hikari housekeeper (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - After cleanup pool HikariPool-0 stats (total=10, active=2, idle=8, waiting=0)\n2015-08-04 16:34:53.591 [Hikari housekeeper (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - Before cleanup pool HikariPool-0 stats (total=10, active=2, idle=8, waiting=0)\n2015-08-04 16:34:53.594 [Hikari housekeeper (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.PoolElf - HikariPool-0 - Closing connection com.mysql.jdbc.JDBC4Connection@e36894: (connection passed idleTimeout)\n2015-08-04 16:34:53.601 [Hikari housekeeper (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.PoolElf - HikariPool-0 - Closing connection com.mysql.jdbc.JDBC4Connection@157d523: (connection passed idleTimeout)\n2015-08-04 16:34:53.602 [Hikari housekeeper (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - After cleanup pool HikariPool-0 stats (total=3, active=2, idle=1, waiting=0)\n2015-08-04 16:34:53.603 [Hikari connection closer (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.PoolElf - HikariPool-0 - Closing connection com.mysql.jdbc.JDBC4Connection@f5408a: (connection passed idleTimeout)\n2015-08-04 16:34:53.604 [Hikari connection closer (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.PoolElf - HikariPool-0 - Closing connection com.mysql.jdbc.JDBC4Connection@1a8ac6e: (connection passed idleTimeout)\n2015-08-04 16:34:53.605 [Hikari connection closer (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.PoolElf - HikariPool-0 - Closing connection com.mysql.jdbc.JDBC4Connection@1e529e8: (connection passed idleTimeout)\n2015-08-04 16:34:53.605 [Hikari connection closer (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.PoolElf - HikariPool-0 - Closing connection com.mysql.jdbc.JDBC4Connection@a756e5: (connection passed idleTimeout)\n2015-08-04 16:34:53.606 [Hikari connection closer (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.PoolElf - HikariPool-0 - Closing connection com.mysql.jdbc.JDBC4Connection@fe2a44: (connection passed idleTimeout)\n2015-08-04 16:34:53.616 [Hikari connection filler (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - HikariPool-0 - Connection com.mysql.jdbc.JDBC4Connection@45eee9 added to pool\n2015-08-04 16:34:53.623 [Hikari connection filler (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - HikariPool-0 - Connection com.mysql.jdbc.JDBC4Connection@666f73 added to pool\n2015-08-04 16:34:53.630 [Hikari connection filler (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - HikariPool-0 - Connection com.mysql.jdbc.JDBC4Connection@19adea3 added to pool\n2015-08-04 16:34:53.637 [Hikari connection filler (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - HikariPool-0 - Connection com.mysql.jdbc.JDBC4Connection@13773a added to pool\n2015-08-04 16:34:53.643 [Hikari connection filler (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - HikariPool-0 - Connection com.mysql.jdbc.JDBC4Connection@e3244a added to pool\n2015-08-04 16:34:53.648 [Hikari connection filler (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - HikariPool-0 - Connection com.mysql.jdbc.JDBC4Connection@c25630 added to pool\n2015-08-04 16:34:53.652 [Hikari connection filler (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - HikariPool-0 - Connection com.mysql.jdbc.JDBC4Connection@153d1c added to pool\n2015-08-04 16:34:53.652 [Hikari connection filler (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - After fill pool HikariPool-0 stats (total=10, active=2, idle=8, waiting=0)\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-08-04T09:57:29Z",
        "body": "This looks like a connection leak.  Some thread allocated 2 connections and did not release them.  Set leakDetectionThreshold to some reasonable value, like 20000.  You'll find the leak.\n"
      }
    ]
  },
  {
    "number": 364,
    "title": "Any possibility of seeing a java-6/7 port for v 2.4.0 ",
    "created_at": "2015-08-03T13:17:07Z",
    "closed_at": "2015-08-03T13:31:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/364",
    "body": "Hi Brett, \n $subject. I only see 2.4.0 for java 8. \n- Ramith\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/364/comments",
    "author": "ramith",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-08-03T13:31:39Z",
        "body": "The 2.4.0 JAR supports both Java 7 and Java 8.  Java 6 has entered maintenance mode and will continue to receive bug fixes and releases from the 2.3.x branch.\n"
      },
      {
        "user": "ramith",
        "created_at": "2015-08-03T13:34:42Z",
        "body": "Excellent ! thanks for the info.\n"
      }
    ]
  },
  {
    "number": 358,
    "title": "forcing connections to die after a connection timeout",
    "created_at": "2015-07-30T20:50:20Z",
    "closed_at": "2015-07-30T23:27:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/358",
    "body": "Brett,\n\nWe are running a Play 2.4 app that utilizes HikariCP. One of the mechanisms of our production environment is a db failover where if our primary database goes down, a secondary read-only database is promoted to the master position and then made both read and write available. A side effect of this is that sometimes what was previously the primary database comes back up very quickly (or it's connection becomes available again) and it gets changed over to be the new secondary database and made readonly. The way that this is seamless for our application is that we have a single dns entry that gets updated to the IP of the new master database when this failover situation happens.\n\nOur problem right now is that any existing connections in the pool hang onto the old db IP that they had resolved our dns entry at the time of the connections creation. This means that if the primary db goes down and then comes back up again as a readonly secondary database quickly (within a minute or two) then the connections in the pool recover and keep hitting it.\n\nWhat we WANT is for the connections to die off quickly in a situation where they fail to connect after retrying so that even if the database they were connecting to recovers quickly, they will still die out and allow new connections that can resolve to the new IP to be created. I've spent some time trying to figure out a reasonable configuration that will indicate this without any success. Do you have any suggestions/advice on what sort of configuration would make it so the hikari pool would behave this way?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/358/comments",
    "author": "elennick",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-07-30T23:27:21Z",
        "body": "It's easy, call softEvictConnections() through the JMX bean.  Better actually would be to suspend the pool, evict, and then resume.\n"
      }
    ]
  },
  {
    "number": 351,
    "title": "How do I import the source to IntelliJ IDEA?",
    "created_at": "2015-07-22T04:53:57Z",
    "closed_at": "2015-07-22T05:30:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/351",
    "body": "I import the source to IntelliJ IDEA as maven project. But,  **`hikaricp-java6` module can not refer to the sources of  `hikaricp-common`.**\n\nHow do I import the source to IntelliJ IDEA and compile the source?\n\nThanks a lot.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/351/comments",
    "author": "diguage",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-07-22T05:30:05Z",
        "body": "It's a huge pain in the ass.  I recommend using the `dev` branch, it's much cleaner -- a single module.\n"
      },
      {
        "user": "diguage",
        "created_at": "2015-07-22T06:19:07Z",
        "body": "@brettwooldridge Thanks again.\n"
      }
    ]
  },
  {
    "number": 337,
    "title": "Network problems - No answer on query",
    "created_at": "2015-06-30T07:44:21Z",
    "closed_at": "2015-06-30T08:45:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/337",
    "body": "Hi. I had a problem tonight with network problems which may appear.\nAt the time when the problems appeared i was sending a SELECT query but never received an answer - after 90 minutes i restarted the application.\nThis is my Config:\n\n```\n    config.setConnectionTimeout(3 * 60 * 1000);\n    config.setAutoCommit(false);\n    config.setIdleTimeout(30 * 1000);\n    config.setConnectionTestQuery(\"SELECT 1\");\n    config.setMaximumPoolSize(10);\n```\n\nI didn't set a query timeout on the statement.\nJDBC String had these options:\n\n```\n?rewriteBatchedStatements=true&autoReconnect=true&zeroDateTimeBehavior=convertToNull&dumpQueriesOnException=true\n```\n\nCould `setConnectionTimeout` have caused this?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/337/comments",
    "author": "stefnats",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-06-30T08:45:31Z",
        "body": "I would recommend not using `autoReconnect`.  As the MySQL documentation states:\n\n```\nThe use of this feature is not recommended, because it has side effects related to\nsession state and data consistency when applications don't handle SQLExceptions\nproperly, and is only designed to be used when you are unable to configure your \napplication to handle SQLExceptions resulting from dead and stale connections properly.\n```\n\nHikariCP can't help you once the connection as left the pool (been given to your application).  You should either set query timeouts on your `Statement` objects, or set the MySQL `socketTimeout` driver property to the maximum time you expect a query to take.\n\n`socketTimeout` is rather a blunt instrument, and will apply to all socket I/O for the connection but if setting query timeouts on all of your SQL statements is not an option it can be used.\n\n If, for example, you never expect a query to take longer than 2 minutes, setting `socketTimeout` to `120000`(ms) should be safe.\n\nAdditionally, `socketTimeout` may be the only way to handle network partition events like you experienced.\n"
      }
    ]
  },
  {
    "number": 327,
    "title": "I configurate the `poolName`, but throw Exception",
    "created_at": "2015-06-17T06:46:43Z",
    "closed_at": "2015-06-17T06:50:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/327",
    "body": "I first use HikariCP. And my configuration file is as follows:\n\n```\ndataSourceClassName=com.mysql.jdbc.jdbc2.optional.MysqlDataSource\ndataSource.url=${dataSource.url}\ndataSource.user=${dataSource.user}\ndataSource.password=${dataSource.password}\ndataSource.poolName=${dataSource.poolName}\ndataSource.cachePrepStmts=${dataSource.cachePrepStmts}\ndataSource.prepStmtCacheSize=${dataSource.prepStmtCacheSize}\ndataSource.prepStmtCacheSqlLimit=${dataSource.prepStmtCacheSqlLimit}\n```\n\nBut the code throws exception as follows:\n\n```\nException in thread \"main\" java.lang.RuntimeException: java.beans.IntrospectionException: Method not found: setPoolName\n    at com.zaxxer.hikari.util.PropertyBeanSetter.setProperty(PropertyBeanSetter.java:134)\n    at com.zaxxer.hikari.util.PropertyBeanSetter.setTargetFromProperties(PropertyBeanSetter.java:63)\n    at com.zaxxer.hikari.pool.PoolUtilities.initializeDataSource(PoolUtilities.java:103)\n    at com.zaxxer.hikari.pool.BaseHikariPool.<init>(BaseHikariPool.java:156)\n    at com.zaxxer.hikari.pool.HikariPool.<init>(HikariPool.java:60)\n    at com.zaxxer.hikari.pool.HikariPool.<init>(HikariPool.java:48)\n    at com.zaxxer.hikari.HikariDataSource.<init>(HikariDataSource.java:80)\n    at com.abc.main(DataAddressServer.java:40)\nCaused by: java.beans.IntrospectionException: Method not found: setPoolName\n    at java.beans.PropertyDescriptor.<init>(PropertyDescriptor.java:110)\n    at com.zaxxer.hikari.util.PropertyBeanSetter.setProperty(PropertyBeanSetter.java:125)\n    ... 7 more\n\n```\n\nThen I configurate it in the code as follows:\n\n``` java\nHikariConfig hikariConfig = new HikariConfig(\"/database.properties\");\nhikariConfig.setMetricRegistry(MetricUtils.METRICS);\nHikariDataSource dataSource = new HikariDataSource(hikariConfig);\ndataSource.setPoolName(\"MyPool\");\n\n```\n\nBad luck. It do not work.\n\nThe option `maxLifetime` is as the `poolName`.\n\nHow do I configurate it ?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/327/comments",
    "author": "diguage",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-06-17T06:50:55Z",
        "body": "`poolName` and `maxLifetime` are not DataSource properties, they are HikariCP properties.  So this:\n\n``` ini\ndataSourceClassName=com.mysql.jdbc.jdbc2.optional.MysqlDataSource\npoolName=${dataSource.poolName}\nmaxLifetime=900000\ndataSource.url=${dataSource.url}\ndataSource.user=${dataSource.user}\ndataSource.password=${dataSource.password}\n...\n```\n"
      },
      {
        "user": "diguage",
        "created_at": "2015-06-17T09:43:20Z",
        "body": "Thanks.\n"
      }
    ]
  },
  {
    "number": 325,
    "title": "Why hikaricp connection pool dies in Idle state ? Is it configurable ?",
    "created_at": "2015-06-11T09:58:00Z",
    "closed_at": "2015-06-11T10:03:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/325",
    "body": "I am using HikariCp with my play application in Java. After few mins of idle state, it seems hikarcp connection pool dies, and when it gets new request it starts again. Sometime I have also seen Db persistence error with message that sessionfactory not available, which I believe is side-effect of this issue. Why hikaricp dies in idle state, and can I some how configure it to not do so ?\n\nI get following logs, after every new requests in few mins of idle time -\n\n[info] application - Application shutdown...\n[info] application - Stopping HikariCP connection pool...\n[info] application - Starting HikariCP connection pool...\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/325/comments",
    "author": "ankit-iiita2006",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-06-11T10:03:13Z",
        "body": "This is a question for the Play forum.  HikariCP never stops all by itself.  Something is stopping and re-starting HikariCP.  And it seems from the messages above, something is shutting down your application.\n"
      }
    ]
  },
  {
    "number": 319,
    "title": "HikariJNDIFactory Tomcat7 java version 1.7.0.80",
    "created_at": "2015-05-20T14:44:50Z",
    "closed_at": "2015-05-20T16:06:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/319",
    "body": "Ubuntu 14.04.2 LTS\n\n/var/lib/tomcat7/conf/server.xml (basing off sample JNDI DataSource on wiki)\n\n`<GlobalNamingResources>\n<Resource name=\"jdbc/CORS\" auth=\"Container\" factory=\"com.zaxxer.hikari.HikariJNDIFactory\" type=\"javax.sql.DataSource\" \n              minimumIdle=\"2\" maximumIdle=\"5\" maximumPoolSize=\"40\" connectionTimeout=\"300000\" \n              jdbcUrl=\"jdbc:mysql://localhost:3306/CORS?zeroDateTimeBehaviour=convertToNull\" dataSource.implicitCachingEnabled=\"true\"\n              dataSource.user=\"\" dataSource.password=\"\" /\n</GlobalNamingResources>`\n\njars put in /usr/share/tomcat7/lib/ as want access globally.\n\nTried using Hikari 2.3.7 and got:\n\n`Caused by: java.lang.NoClassDefFoundError: org/slf4j/LoggerFactory\n        at com.zaxxer.hikari.util.PropertyBeanSetter.<clinit>(PropertyBeanSetter.java:41)\n        at com.zaxxer.hikari.HikariJNDIFactory.getObjectInstance(HikariJNDIFactory.java:55)`\n\nadded slf4j-api-1.7.10.jar and got:\n\n`Caused by: java.lang.NoClassDefFoundError: javassist/ClassPath\n        at com.zaxxer.hikari.HikariConfig.<clinit>(HikariConfig.java:31)\n        at com.zaxxer.hikari.HikariJNDIFactory.createDataSource(HikariJNDIFactory.java:76)\n        at com.zaxxer.hikari.HikariJNDIFactory.getObjectInstance(HikariJNDIFactory.java:67)\n        at org.apache.naming.factory.ResourceFactory.getObjectInstance(ResourceFactory.java:141)`\n\nadded javassist-3.12.1.GA.jar and got:\n\nsame error as before.\n\nTomcat7 has only the ROOT app under webapps.\n\nTried using Hikari 2.3.8 - no change.\n\nSearched the issues (and Google) and tried suggestions or added libraries to match - no change. Asking here as it 'appears' it is HikariConfig that is causing the issue...\n\nThank you,\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/319/comments",
    "author": "pgtips",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-05-20T14:46:53Z",
        "body": "@pgtips Have you tried javassist-3.18.2-GA?\n"
      },
      {
        "user": "pgtips",
        "created_at": "2015-05-20T15:24:33Z",
        "body": "Thank you for the prompt reply. I thought I had grabbed a recent version.\n\nI just tried replacing with 3.18.2-GA - no change to error. (Tried 3.19.0 while I was at).\n"
      },
      {
        "user": "pgtips",
        "created_at": "2015-05-20T15:25:09Z",
        "body": "Sorry - closed by mistake.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-05-20T15:38:16Z",
        "body": "Coming up on 1am here in Tokyo, I'll have to take a look tomorrow.\n"
      },
      {
        "user": "pgtips",
        "created_at": "2015-05-20T15:42:06Z",
        "body": "Understand - appreciate it. \n\nWill keep digging and see if I can help at all.\n"
      },
      {
        "user": "pgtips",
        "created_at": "2015-05-20T16:06:46Z",
        "body": "I am an idiot - I hadn't checked permissions during transfer to /usr/share/java.\n\n(No doubt I still needed 3.18.2-GA)\n\nThanks!\n"
      }
    ]
  },
  {
    "number": 313,
    "title": "Waiting connections",
    "created_at": "2015-04-29T08:18:23Z",
    "closed_at": "2015-05-14T04:20:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/313",
    "body": "Hi,\n\nWe've recently switched over from Tomcat JDBC to HikariCP, at the moment i'm trying to find the correct configuration/pool size for our applications as we wish to use a static pool instead of constantly growing/shrinking. \n\nThe problem we see at the moment with HikariCP is somewhat strange, I've added debug log and this is what i see.\n\n2015-04-29 00:22:15,617 [Hikari Housekeeping Timer (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - Before cleanup pool stats HikariPool-0 (total=20, inUse=20, avail=0, waiting=1)\n2015-04-29 00:22:15,617 [Hikari Housekeeping Timer (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - After cleanup pool stats HikariPool-0 (total=20, inUse=20, avail=0, waiting=1)\n2015-04-29 00:22:15,618 [HikariCP connection filler (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - After fill pool stats HikariPool-0 (total=20, inUse=20, avail=0, waiting=1)\n2015-04-29 00:22:22,848 [http-bio-1027-exec-10] DEBUG com.zaxxer.hikari.pool.HikariPool - Timeout failure pool stats HikariPool-0 (total=20, inUse=20, avail=0, waiting=0)\n2015-04-29 00:22:45,617 [Hikari Housekeeping Timer (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - Before cleanup pool stats HikariPool-0 (total=20, inUse=20, avail=0, waiting=1)\n2015-04-29 00:22:45,617 [Hikari Housekeeping Timer (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - After cleanup pool stats HikariPool-0 (total=20, inUse=20, avail=0, waiting=1)\n2015-04-29 00:22:45,626 [HikariCP connection filler (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - After fill pool stats HikariPool-0 (total=20, inUse=20, avail=0, waiting=1)\n2015-04-29 00:22:52,885 [http-bio-1027-exec-6] DEBUG com.zaxxer.hikari.pool.HikariPool - Timeout failure pool stats HikariPool-0 (total=20, inUse=20, avail=0, waiting=0)\n2015-04-29 00:23:15,617 [Hikari Housekeeping Timer (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - Before cleanup pool stats HikariPool-0 (total=20, inUse=20, avail=0, waiting=1)\n2015-04-29 00:23:15,617 [Hikari Housekeeping Timer (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - After cleanup pool stats HikariPool-0 (total=20, inUse=20, avail=0, waiting=1)\n2015-04-29 00:23:15,617 [HikariCP connection filler (pool HikariPool-0)] DEBUG com.zaxxer.hikari.pool.HikariPool - After fill pool stats HikariPool-0 (total=20, inUse=20, avail=0, waiting=1)\n\nAs you can see HikariCP states the pool is full which i assume is correct but i know for a fact we have more then 1 thread waiting for a connection yet Hikari always says only 1 is waiting, why is this  ? i do believe we have more then 1 thread/function waiting for a connections (at least this is what i see from my logs), am i missing something ?\n\nit seems if as our application does not recover well from this as multiple threads are waiting to get served and the thread pool grows bigger and bigger till we end up crashing, increasing the pool would solve our issues but still i'd like to get some 'real' stats as to how many threads are waiting to get served from Hikari.\n\nHere is our configuration:\n\nmaximumPoolSize=20\nidleTimeout=120000\nmaxLifetime=900000\nleakDetectionThreshold=180000\n\nWe are using the latest version HikariCP-java6-2.3.6.jar.\n\nThanks.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/313/comments",
    "author": "dannygu",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-04-30T12:42:49Z",
        "body": "I agree the \"waiting\" value in the debug pool stats is misleading.  It represents the number of threads parked at the instant of that log, but in an active pool, waiting threads are frequently notified (unparked) and compete for a returned connection.  As a result, under these conditions threads spend more of their time unparked, as opposed to parked, and the \"waiting\" stat ends up being not very meaningful.\n\nWhat I can recommend at this point is enabling Dropwizard Metrics and watching the \"Wait\" and \"Usage\" metrics.  \"Wait\" is a histogram of how long threads spend waiting, and \"Usage\" is a histogram of how long connections remain out of the pool.  Watching these two, while playing with the maximumPoolSize, might give a better picture of pool dynamics.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-05-14T04:20:49Z",
        "body": "@dannygu The upcoming 2.4.0 (currently 2.4.0-SNAPSHOT on the `dev` branch) typically reports more accurate \"waiting\" counts in the debug logs.\n"
      }
    ]
  },
  {
    "number": 309,
    "title": "Missing dependency in junit test",
    "created_at": "2015-04-16T14:08:10Z",
    "closed_at": "2015-04-25T08:38:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/309",
    "body": "Hello\n     I'm using version 2.2.5 in a springboot 1.2.3.RELEASE application.\nI have defined:\n- unit tests\n- integration (rest) tests\n\nThe integration tests fire: \n\n```\nCaused by: java.lang.RuntimeException: HikariCP Codahale shim says: Codahale metrics library is required but was not found in the classpath\n```\n\nAs a workaround I've added in pom.xml:\n\n```\n    <dependency>\n        <groupId>com.codahale.metrics</groupId>\n        <artifactId>metrics-core</artifactId>\n        <version>3.0.2</version>\n        <scope>test</scope>\n    </dependency>\n```\n\nBTW This error happens if I run all the test; running only integration tests works fine (?!).\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/309/comments",
    "author": "lrkwz",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-04-16T14:39:41Z",
        "body": "@lrkwz the next release after 2.2.5 was 2.3.0, the CHANGES file indicates:\n- Fixed bug when using the HikariJNDIFactory that required the presence of Codahale metrics.\n\nIt is possible your tests are accessing HikariCP through JNDI?  If so, upgrading to 2.3.0 should fix it.\n"
      }
    ]
  },
  {
    "number": 306,
    "title": "HikariCP does not respect minimumIdle ",
    "created_at": "2015-04-13T16:37:46Z",
    "closed_at": "2015-04-14T00:44:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/306",
    "body": "Hello,\nWe are using v2.3.5 with PGSimpleDataSource; The pool is configured programmatically. \n\nI have noticed that around each 9 minutes the HouseKeeper closes most of the connections (the minimum idle number of connections) due to IdleTimeout. This doesn't make sense - why would the pool close connections if the minimumIdle is reached ? Note that the maxLifetime is set to 0 (zero). \n\n```\n        config.setRegisterMbeans(true); // Default false\n        config.setConnectionTimeout(60000); // default 30000 ms = 30s\n        config.setIdleTimeout(60000); // Default: 600000 (10 minutes)\n        config.setMaxLifetime(0); // Default: 1800000 (30 minutes)\n        config.setMinimumIdle(10); // Default: same as maximumPoolSize (10)\n        config.setMaximumPoolSize(100); // Default: 10\n        config.setValidationTimeout(50000); // Default: 5000 ms = 5s\n```\n\nReading the HikariCP code I just don't see why in this check below, the minIdle number is not respected (not checked anywhere) - this makes using a pool meaningless ? :   \n\n```\n           if (bagEntry.evicted || (idleTimeout > 0L && now > bagEntry.lastAccess + idleTimeout)) {\n              closeConnection(bagEntry);\n           }\n```\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/306/comments",
    "author": "repo-2017",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-04-14T00:44:31Z",
        "body": "@yosstef From the `minimumIdle` documentation:\n\n\"This property controls the minimum number of idle connections that HikariCP **tries** to maintain in the pool. **If the idle connections dip below this value**_, HikariCP will make a best effort to add additional connections quickly and efficiently._\"\n\nGenerally speaking, in an application that is even _just a little_ active, connections very quickly obtain _lastAccess_ timestamps that are different than each other.  When this occurs, idle connections will start expiring at different times, rather than all at once.\n\nExpiring connections that reach timeout is considered a higher priority than maintaining a constant number of minimum connections.  Having said that, what you omitted from you code fragment above, is this:\n\n```\nfillPool(); // Try to maintain minimum connections\n```\n\nAfter expiring connections, HikariCP will immediately (within tens of milliseconds) replace them in the pool with new connections until minimumIdle is reached.  If you find that this is not occurring, please let us know.\n"
      },
      {
        "user": "ghost",
        "created_at": "2015-11-02T05:32:58Z",
        "body": "I meet one question in 2.4.1 .\nDo I need to open one new issue? \n"
      }
    ]
  },
  {
    "number": 303,
    "title": "Setting MetricRegistry at runtime",
    "created_at": "2015-04-10T14:28:11Z",
    "closed_at": "2015-04-10T19:59:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/303",
    "body": "Hi @brettwooldridge, \n\nFirst of all thanks for the great library. \n\nI would like to set CodaHale MetricRegistry at runtime. This is required because I am not configuring datasource. But it seems that I am little bid late for setting it. Is it possible to propagate a change in HikariDataSource to track metrics?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/303/comments",
    "author": "cemo",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-04-10T16:22:14Z",
        "body": "You should be able to set it once, on the HikariDataSource, after the pool is started.  You'll need HikariCP 2.3.6.\n"
      },
      {
        "user": "cemo",
        "created_at": "2015-04-10T19:56:39Z",
        "body": "Thanks for answer. It seems that I have taken some connections from pool and then setting MetricRegistry. In this case some of connections in pool don't have a MetricsContext with MetricRegistry. Do you think that setting a MetricRegistry should update existing connections as well?\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-04-10T19:59:33Z",
        "body": "Metrics will not be recorded for connections already taken from the pool, but very quickly whatever stats those connections would have provided will become statistical noise.  As soon as they are returned to the pool, they will start participating in metrics.\n"
      },
      {
        "user": "cemo",
        "created_at": "2015-04-10T20:37:41Z",
        "body": "I am sorry @brettwooldridge. I somehow used an old dependency before and after your comment regarding 2.3.6 I have mischecked my configuration. It is working as expected.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-04-10T20:38:55Z",
        "body": "Great.\n"
      }
    ]
  },
  {
    "number": 283,
    "title": "Why is setConnectionInitSql deprecated?",
    "created_at": "2015-03-13T10:11:35Z",
    "closed_at": "2015-03-13T10:20:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/283",
    "body": "We are using this setting to change Oracle's default sorting behavior for a certain application:\n\nALTER SESSION SET NLS_SORT = XGERMAN_DIN\n\nShouldn't such use cases be supported in future, too?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/283/comments",
    "author": "fdummert",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-03-13T10:20:26Z",
        "body": "The _connectionInit_ property will be un-@deprecated in the next release.  You can read the thread in the Google Group if you want to.\n"
      },
      {
        "user": "fdummert",
        "created_at": "2015-03-13T10:30:48Z",
        "body": "Thanks for the info and sorry, I should have checked the discussion before...\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-03-13T12:19:35Z",
        "body": "@fdummert No problem, I don't expect such a deep search.  Perfectly valid issue to open (and close :smile: )\n"
      }
    ]
  },
  {
    "number": 278,
    "title": "Method like checkout(C3P0 connectionCustomizer) in HikariCp",
    "created_at": "2015-03-08T04:17:26Z",
    "closed_at": "2015-03-09T13:27:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/278",
    "body": "I want a method that can be executed before a connection is given to the client. But there is only method called customize() in IConnectionCustomizer . Is there any thing that I can have\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/278/comments",
    "author": "jayashsam",
    "comments": [
      {
        "user": "jnehlmeier",
        "created_at": "2015-03-08T14:09:29Z",
        "body": "As a workaround you could wrap the Hikari Datasource with your own, e.g.\n\n``` java\nclass DataSourceWithCallback implements DataSource {\n\n  DataSourceWithCallbacks(DataSource delegate, Callback callback) {\n    // store in fields\n  }\n\n  Connection getConnection() {\n    Connection con = delegate.getConnection();\n    callback.exec(); // alternatively move before delegate.getConnection()\n    return con;\n  }\n\n  // add remaining delegate methods \n}\n\n// Somewhere in your code:\nCallback onBeforeConnectionObtained = new Callback() {\n   void exec() {\n     // callback code\n   }\n}\nDataSource ds = new DataSourceWithCallback(new HikariDataSource(config), onBeforeConnectionObtained);\n```\n"
      },
      {
        "user": "jayashsam",
        "created_at": "2015-03-09T04:04:03Z",
        "body": "Then in this case I have to write whole HikariDataSource class on my own. Right?\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-03-09T13:27:04Z",
        "body": "If you just need to execute statements on-borrow from the pool, the simplest way of doing this is with a _helper_ rather than a _wrapper_.  For example:\n\n``` java\nclass DbHelper {\n   private DataSource delegate;\n\n   Connection getConnection() throws SQLException {\n      Connection con = delegate.getConnection();\n      con.execute(...);  // your code here\n      return con;\n   }\n}\n```\n\nHowever, if you are constructing a DataSource to pass into another framework (for example, Hibernate), a _wrapper_ class would be necessary.\n\nThe question is, what are you trying to achieve, and how does that fit with the standard model of DataSources?  Using hooks, like that provided by C3P0, can be useful but it also locks your application to C3P0.  A similar hook would lock your application to HikariCP.\n\nA good general goal should be an application that is portable across pool implementations.  A _helper_ class or _wrapper_ class will give you that.  A pool-specific _interface_ hook will not.\n"
      }
    ]
  },
  {
    "number": 271,
    "title": "Nothing to say",
    "created_at": "2015-03-01T21:07:54Z",
    "closed_at": "2015-03-01T23:08:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/271",
    "body": "except... thanks for HikariCP :-)\n\nExcelent work!\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/271/comments",
    "author": "manolodd",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-03-01T23:08:26Z",
        "body": "You're welcome. thanks.\n"
      }
    ]
  },
  {
    "number": 257,
    "title": "SQLTimeoutException at  BaseHikariPool.getConnection(BaseHikariPool.java:228)",
    "created_at": "2015-02-09T17:08:58Z",
    "closed_at": "2015-02-10T14:13:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/257",
    "body": "Hi,\n\nam little new to web programming, am developing a mobile app for which I needed a small scale rest enabled web app with mysql db support.\n\nafter reading lots of review, I went configuring HikariCP for managing connection pool database, however even after spending couple of days with it, am not yet able to make it work.\n\nThis is where am doing all my initialization.\n\n// Init servlet\n\npublic class CPInit extends HttpServlet implements ServletContextListener{\n\n```\n/**\n * \n */\nprivate static final long serialVersionUID = 1L;\n\nprivate final static String TAG = CPInit.class.getSimpleName();\nprivate static HikariConfig mConfig;\nprivate static HikariDataSource mDataSource;\n\npublic static String POOL_NAME = \"MyPool\";\npublic static int POOL_SIZE = 50;\npublic static int TIME_OUT = 2*30*1000;\npublic static int MIN_IDLE_SIZE = 5;\npublic static boolean isDebuggable;\n\nprivate static String PASSWORD = \"PASSWORD\";\n\n\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp)\n        throws ServletException, IOException {\n    super.doGet(req, resp);\n    resp.getWriter()\n    .write(\"Not supported\");\n\n}\n\npublic CPInit(){\n    initPool();\n}\n\npublic static void initPool(){\n\n\n    TLog.info(TAG, \"Password = \" + string);\n    mConfig = new HikariConfig();\n    mConfig.setDataSourceClassName(\"com.mysql.jdbc.jdbc2.optional.MysqlDataSource\");\n    mConfig.addDataSourceProperty(\"url\", \"jdbc:mysql://127.0.0.1:3306/mydb\");\n    mConfig.addDataSourceProperty(\"cachePrepStmts\", \"true\");\n    mConfig.addDataSourceProperty(\"prepStmtCacheSize\", \"250\");\n    mConfig.addDataSourceProperty(\"prepStmtCacheSqlLimit\", \"2048\");\n    mConfig.addDataSourceProperty(\"useServerPrepStmts\", \"true\");\n    mConfig.addDataSourceProperty(\"user\", \"root\");\n    mConfig.addDataSourceProperty(\"password\", PASSWORD);\n    mConfig.setMaximumPoolSize(POOL_SIZE);\n    mConfig.setMinimumIdle(MIN_IDLE_SIZE);\n\n    mConfig.setPoolName(POOL_NAME);\n    mConfig.setConnectionTimeout(TIME_OUT);\n    mConfig.setAutoCommit(true);\n    mConfig.setInitializationFailFast(true);\n    mConfig.setConnectionTestQuery(\"show tables\");\n    mDataSource = new HikariDataSource(mConfig);\n\n}\n\n@Override\npublic void contextDestroyed(ServletContextEvent arg0) {\n    TLog.info(TAG, \"CP has being destroyed\");\n    mDataSource.close();\n    mDataSource.shutdown();\n\n}\n\n\npublic static Connection getConnection() throws SQLException{\n    TLog.info(TAG, \"get data connection\");\n\n\n\n    Connection mConnection =  mDataSource.getConnection();\n\n    if(mConnection == null || mConnection.isClosed()){\n        initPool();\n        mConnection =  mDataSource.getConnection();\n    }\n\n    return mConnection;\n\n}\n\n@Override\npublic void contextInitialized(ServletContextEvent arg0) {\n    TLog.info(TAG, \"CP has been initilizing\");\n    String parm = arg0.getServletContext().getInitParameter(\"debugging\");\n    isDebuggable = Boolean.valueOf(parm);\n}\n```\n\n}\n\n// This is how am taking connection, and closing it in a data manager class\n\nclass DataManager{\n\n```\nprivate Connection getConnection(){\n    try{\n        return CPInit.getConnection();\n    }catch(SQLException e){\n        TLog.error(TAG, \"Connection is null\");\n        e.printStackTrace();\n        TLog.error(TAG, e.getMessage());\n        TLog.error(TAG, e.getMessage());\n        return null;\n    }\n}\npublic int getServiceId(String number) throws SQLException{\n\n    Connection mConn = getConnection();\n    if(mConn == null){\n        throw new SQLException(\"Connection cannot be Initialized\");\n    }\n    TLog.info(TAG, \"Looking up service id for = \" + number);\n    PreparedStatement selectStmt = mConn.prepareStatement(SELECT_DEVICE_BY_NUMBER_ONLY);\n    selectStmt.setString(1, number);\n    ResultSet set  = selectStmt.executeQuery();\n    if(set != null){\n        if(set.next()){\n            int serviceId = set.getInt(Devices._ID);\n            set.close();\n            selectStmt.close();\n            if(mConn != null){\n                mConn.close();\n            }\n            TLog.info(TAG, \"service id found for = \" + number + \", service id = \" + serviceId);\n            return serviceId;\n        }\n        set.close();\n    }\n    selectStmt.close();\n    if(mConn != null){\n        mConn.close();\n    }\n\n    TLog.info(TAG, \"service id not found for = \" + number);\n    return -1;\n}\n```\n\n}\n\nNow when am running query in bulk, after first few queries this is all am getting from connection call.\n\n[INFO ] 2015-02-09 22:24:17.243 [http-nio-8080-exec-5] TLog - CPInit--get data connection\n[ERROR] 2015-02-09 22:25:17.245 [http-nio-8080-exec-5] TLog - [DatabaseManager] --Connection is null\njava.sql.SQLTimeoutException: Timeout after 60001ms of waiting for a connection.\n    at com.zaxxer.hikari.pool.BaseHikariPool.getConnection(BaseHikariPool.java:228)\n    at com.zaxxer.hikari.pool.BaseHikariPool.getConnection(BaseHikariPool.java:183)\n    at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:91)\n    at com.mkgcorp.travelweb.controller.CPInit.getConnection(CPInit.java:90)\n    at com.mkgcorp.travelweb.data.Database.getConnection(Database.java:18)\n    at com.mkgcorp.travelweb.data.DataManager.getConnection(DataManager.java:100)\n    at com.mkgcorp.travelweb.data.DataManager.getServiceId(DataManager.java:200)\n    at com.mkgcorp.travelweb.webservices.SyncResource.syncContacts(SyncResource.java:146)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n    at java.lang.reflect.Method.invoke(Unknown Source)\n    at com.sun.jersey.spi.container.JavaMethodInvokerFactory$1.invoke(JavaMethodInvokerFactory.java:60)\n    at com.sun.jersey.server.impl.model.method.dispatch.AbstractResourceMethodDispatchProvider$ResponseOutInvoker._dispatch(AbstractResourceMethodDispatchProvider.java:205)\n    at com.sun.jersey.server.impl.model.method.dispatch.ResourceJavaMethodDispatcher.dispatch(ResourceJavaMethodDispatcher.java:75)\n    at com.sun.jersey.server.impl.uri.rules.HttpMethodRule.accept(HttpMethodRule.java:302)\n    at com.sun.jersey.server.impl.uri.rules.ResourceClassRule.accept(ResourceClassRule.java:108)\n    at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:147)\n    at com.sun.jersey.server.impl.uri.rules.RootResourceClassesRule.accept(RootResourceClassesRule.java:84)\n    at com.sun.jersey.server.impl.application.WebApplicationImpl._handleRequest(WebApplicationImpl.java:1542)\n    at com.sun.jersey.server.impl.application.WebApplicationImpl._handleRequest(WebApplicationImpl.java:1473)\n    at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:1419)\n    at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:1409)\n    at com.sun.jersey.spi.container.servlet.WebComponent.service(WebComponent.java:409)\n    at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:540)\n    at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:715)\n    at javax.servlet.http.HttpServlet.service(HttpServlet.java:725)\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:291)\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\n    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\n    at org.apache.logging.log4j.web.Log4jServletFilter.doFilter(Log4jServletFilter.java:71)\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\n    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:219)\n    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106)\n    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:501)\n    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:142)\n    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79)\n    at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:610)\n    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88)\n    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:537)\n    at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1085)\n    at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:658)\n    at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:222)\n    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1556)\n    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1513)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)\n    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n    at java.lang.Thread.run(Unknown Source)\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/257/comments",
    "author": "nucleartip",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-02-10T14:13:45Z",
        "body": "I suggest enabling leak detection (see the documentation) -- your \"early return\" that does `return serviceId;` is leaking a `Connection`.\n\nCode that obtains a resource (like a `Connection`) should _always_ close it in a _finally_ block:\n\n``` java\npublic int getServiceId(String number) throws SQLException {\n   Connection mConn = getConnection();\n   if (mConn == null) {\n      throw new SQLException(\"Connection cannot be Initialized\");\n   }\n\n   try {\n      ... // all your current logic here\n   }\n   finally {\n      mConn.close();  // null check is unnecessary here, you already checked it above\n   }\n\n   return -1;\n}\n```\n"
      }
    ]
  },
  {
    "number": 251,
    "title": "javassist.NotFoundException: com.zaxxer.hikari.proxy.ConnectionProxy for HikariCP configured as JNDI datasource in Tomcat 8",
    "created_at": "2015-02-03T18:34:42Z",
    "closed_at": "2015-02-04T00:30:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/251",
    "body": "I configured HikariCP as JNDI datasource for Tomcat 8.0.18, and when I start Tomcat I'm gettting the following exception in Catalina log:\n\nCaused by: java.lang.RuntimeException: Fatal exception during proxy generation\n        at com.zaxxer.hikari.proxy.JavassistProxyFactory.<clinit>(JavassistProxyFactory.java:61)\n        ... 26 more\nCaused by: javassist.NotFoundException: com.zaxxer.hikari.proxy.ConnectionProxy\n        at javassist.ClassPool.get(ClassPool.java:450)\n        at javassist.ClassPool.getCtClass(ClassPool.java:515)\n        at com.zaxxer.hikari.proxy.JavassistProxyFactory.generateProxyClass(JavassistProxyFactory.java:130)\n        at com.zaxxer.hikari.proxy.JavassistProxyFactory.<init>(JavassistProxyFactory.java:85)\n        at com.zaxxer.hikari.proxy.JavassistProxyFactory.<clinit>(JavassistProxyFactory.java:57)\n\nExtra jars in \"endorsed\" directory for tomcat:\n\nHikariCP-2.3.2.jar\njavassist-3.19.0-GA.jar\nlog4j-1.2.16.jar\nslf4j-api-1.7.2.jar\nslf4j-log4j12-1.7.2.jar\nojdbc-6.jar\n\nJava version\n$ java -version\njava version \"1.8.0_05\"\nJava HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)\n\nResource definition in context.xml:\n\n```\n<Resource name=\"jdbc/oracle\"\n        auth=\"Container\"\n        type=\"javax.sql.DataSource\"\n        registerMbeans=\"true\"\n        factory=\"com.zaxxer.hikari.HikariJNDIFactory\"\n        username=\"hidden\"\n        password=\"hidden\"\n        dataSourceClassName=\"oracle.jdbc.pool.OracleDataSource\"\n        poolName=\"dbpool\"\n        maximumPoolSize=\"20\"\n        leakDetectionThreshold=\"10000\"\n        dataSource.url=\"jdbc:oracle:thin:@hidden:1521/hidden\"\n        dataSource.implicitCachingEnabled=\"true\"\n        dataSource.statementCacheSize=\"512\"\n        />\n```\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/251/comments",
    "author": "vlad-aleksandrov",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-02-04T00:01:42Z",
        "body": "Can you try moving the jars to the WAR's lib directory?\n"
      },
      {
        "user": "vlad-aleksandrov",
        "created_at": "2015-02-04T00:30:32Z",
        "body": "Not really, because I want to configure database connection on webapp container (Tomcat) level and jars won't be visible there for tomcat classloader. Anyway, I think I figured out the reason and solution that works. \n\nSince I have HikariCP jars in `tomcat/endorsed` directory, they are loaded by bootstrap classloader. The `com.zaxxer.hikari.proxy.JavassistProxyFactory` class is trying to get it's classloader in line 55 to configure classpool in constructor (line 81):\n\n``` java\n55: Thread.currentThread().setContextClassLoader(JavassistProxyFactory.class.getClassLoader());\n...\n81 : classPool.appendClassPath(new LoaderClassPath(this.getClass().getClassLoader()));\n```\n\n`JavassistProxyFactory.class.getClassLoader()` returns `null` to represent bootstrap classloader and it breaks all proxy classes installations later on.\n\nAs a workaround, I moving HikariCP jars in `tomcat/lib` directory.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-02-04T03:40:18Z",
        "body": "Thanks for the update.  Can you think of a better way to get the classloader that would allow the jars to run in the endorsed directory?\n"
      },
      {
        "user": "vlad-aleksandrov",
        "created_at": "2015-02-04T18:41:06Z",
        "body": "No prob. \n\nI would use thread context classloader directly in current line 81 like this\n\n```\nclassPool.appendClassPath(new LoaderClassPath(Thread.currentThread().getContextClassLoader()));\n```\n\nremoved static block completely and call `modifyProxyFactory()` in constructor.\n"
      }
    ]
  },
  {
    "number": 250,
    "title": "Exception",
    "created_at": "2015-02-03T13:19:01Z",
    "closed_at": "2015-02-03T13:38:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/250",
    "body": "Hi \nI have use 2.3.1 version of HikariCP in RESTful service\n\n```\n2015-02-03 15:02:14.905:WARN:oejs.HttpChannel:qtp1642360923-177: Could not send response error 500: javax.servlet.ServletException: javax.servlet.ServletException: A MultiException has 1 exceptions.  They are:|1. java.lang.IllegalStateException: ServiceLocatorImpl(__HK2_Generated_0,0,604644889) has been shut down|\n2015-02-03 15:02:14.905:WARN:oejs.HttpChannel:qtp1642360923-57: /jaxrs/driver-coordinates\njavax.servlet.ServletException: javax.servlet.ServletException: A MultiException has 1 exceptions.  They are:|1. java.lang.IllegalStateException: ServiceLocatorImpl(__HK2_Generated_0,0,604644889) has been shut down|\n    at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:130)\n    at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97)\n    at org.eclipse.jetty.server.Server.handle(Server.java:497)\n    at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:311)\n    at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:248)\n    at org.eclipse.jetty.io.AbstractConnection$2.run(AbstractConnection.java:540)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:610)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:539)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: \njavax.servlet.ServletException: A MultiException has 1 exceptions.  They are:|1. java.lang.IllegalStateException: ServiceLocatorImpl(__HK2_Generated_0,0,604644889) has been shut down|\n    at org.glassfish.jersey.servlet.WebComponent.service(WebComponent.java:397)\n    at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:381)\n    at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:344)\n    at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:221)\n    at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:769)\n    at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1667)\n    at org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter.doFilter(WebSocketUpgradeFilter.java:172)\n    at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1650)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330)\n    at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118)\n    at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:113)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:154)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilter(BasicAuthenticationFilter.java:201)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilter(BasicAuthenticationFilter.java:201)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:50)\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192)\n    at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160)\n    at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:344)\n    at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:261)\n    at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1650)\n    at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:583)\n    at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143)\n    at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:577)\n    at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:223)\n    at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1125)\n    at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:515)\n    at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:185)\n    at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1059)\n    at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)\n    at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:215)\n    at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:110)\n    at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97)\n    at org.eclipse.jetty.server.Server.handle(Server.java:497)\n    at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:311)\n    at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:248)\n    at org.eclipse.jetty.io.AbstractConnection$2.run(AbstractConnection.java:540)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:610)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:539)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: \nA MultiException has 1 exceptions.  They are:|1. java.lang.IllegalStateException: ServiceLocatorImpl(__HK2_Generated_0,0,604644889) has been shut down|\n    at org.jvnet.hk2.internal.FactoryCreator.getFactoryHandle(FactoryCreator.java:90)\n    at org.jvnet.hk2.internal.FactoryCreator.dispose(FactoryCreator.java:138)\n    at org.jvnet.hk2.internal.SystemDescriptor.dispose(SystemDescriptor.java:526)\n    at org.glassfish.jersey.process.internal.RequestScope$Instance.remove(RequestScope.java:531)\n    at org.glassfish.jersey.process.internal.RequestScope$Instance.release(RequestScope.java:548)\n    at org.glassfish.jersey.process.internal.RequestScope.runInScope(RequestScope.java:318)\n    at org.glassfish.jersey.server.ServerRuntime.process(ServerRuntime.java:286)\n    at org.glassfish.jersey.server.ApplicationHandler.handle(ApplicationHandler.java:1073)\n    at org.glassfish.jersey.servlet.WebComponent.service(WebComponent.java:377)\n    at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:381)\n    at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:344)\n    at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:221)\n    at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:769)\n    at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1667)\n    at org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter.doFilter(WebSocketUpgradeFilter.java:172)\n    at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1650)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330)\n    at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118)\n    at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:113)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:154)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilter(BasicAuthenticationFilter.java:201)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilter(BasicAuthenticationFilter.java:201)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:50)\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192)\n    at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160)\n    at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:344)\n    at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:261)\n    at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1650)\n    at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:583)\n    at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143)\n    at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:577)\n    at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:223)\n    at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1125)\n    at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:515)\n    at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:185)\n    at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1059)\n    at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)\n    at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:215)\n    at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:110)\n    at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97)\n    at org.eclipse.jetty.server.Server.handle(Server.java:497)\n    at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:311)\n    at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:248)\n    at org.eclipse.jetty.io.AbstractConnection$2.run(AbstractConnection.java:540)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:610)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:539)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: \njava.lang.IllegalStateException: ServiceLocatorImpl(__HK2_Generated_0,0,604644889) has been shut down\n    at org.jvnet.hk2.internal.ServiceLocatorImpl.checkState(ServiceLocatorImpl.java:2205)\n    at org.jvnet.hk2.internal.ServiceLocatorImpl.getServiceHandleImpl(ServiceLocatorImpl.java:588)\n    at org.jvnet.hk2.internal.ServiceLocatorImpl.getServiceHandle(ServiceLocatorImpl.java:581)\n    at org.jvnet.hk2.internal.ServiceLocatorImpl.getServiceHandle(ServiceLocatorImpl.java:599)\n    at org.jvnet.hk2.internal.FactoryCreator.getFactoryHandle(FactoryCreator.java:87)\n    at org.jvnet.hk2.internal.FactoryCreator.dispose(FactoryCreator.java:138)\n    at org.jvnet.hk2.internal.SystemDescriptor.dispose(SystemDescriptor.java:526)\n    at org.glassfish.jersey.process.internal.RequestScope$Instance.remove(RequestScope.java:531)\n    at org.glassfish.jersey.process.internal.RequestScope$Instance.release(RequestScope.java:548)\n    at org.glassfish.jersey.process.internal.RequestScope.runInScope(RequestScope.java:318)\n    at org.glassfish.jersey.server.ServerRuntime.process(ServerRuntime.java:286)\n    at org.glassfish.jersey.server.ApplicationHandler.handle(ApplicationHandler.java:1073)\n    at org.glassfish.jersey.servlet.WebComponent.service(WebComponent.java:377)\n    at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:381)\n    at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:344)\n    at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:221)\n    at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:769)\n    at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1667)\n    at org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter.doFilter(WebSocketUpgradeFilter.java:172)\n    at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1650)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330)\n    at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118)\n    at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:113)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:154)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilter(BasicAuthenticationFilter.java:201)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilter(BasicAuthenticationFilter.java:201)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:50)\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n    at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192)\n    at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160)\n    at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:344)\n    at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:261)\n    at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1650)\n    at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:583)\n    at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143)\n    at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:577)\n    at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:223)\n    at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1125)\n    at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:515)\n    at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:185)\n    at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1059)\n    at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)\n    at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:215)\n    at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:110)\n    at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97)\n    at org.eclipse.jetty.server.Server.handle(Server.java:497)\n    at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:311)\n    at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:248)\n    at org.eclipse.jetty.io.AbstractConnection$2.run(AbstractConnection.java:540)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:610)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:539)\n    at java.lang.Thread.run(Thread.java:745)\n```\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/250/comments",
    "author": "sytolk",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-02-03T13:23:16Z",
        "body": "@sytolk I don't see HikariCP anywhere in that stacktrace, what makes you think it is a HikariCP problem?\n"
      },
      {
        "user": "sytolk",
        "created_at": "2015-02-03T13:38:36Z",
        "body": "you are right this is not HikariCP problem I was see hk2 package.. sorry\n"
      }
    ]
  },
  {
    "number": 249,
    "title": "javassist.NotFoundException: com.zaxxer.hikari.proxy.ConnectionProxy",
    "created_at": "2015-02-01T17:44:23Z",
    "closed_at": "2015-02-02T01:37:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/249",
    "body": "I downloaded the latest hikariCP 2.3.2 .jar, javassist 3.19.0 .jar and sl4j-api-1.7.10.jar, and when I start an application with hikaricp in Eclipse I get the following exception:\n javassist.NotFoundException: com.zaxxer.hikari.proxy.ConnectionProxy\nat javassist.ClassPool.get(ClassPool.java:450)\nat javassist.ClassPool.getCtClass(ClassPool.java:515)\nat com.zaxxer.hikari.proxy.JavassistProxyFactory.generateProxyClass(JavassistProxyFactory.java:130)\netc.\n\nIs there anything I can do to fix this?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/249/comments",
    "author": "Traubenfuchs",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-02-02T01:37:14Z",
        "body": "Running in Eclipse can be tricky due to how Eclipse manages the classpath.  I suggest checking the launch configuration for whatever application you are trying to launch to make sure that all jars are included.  If you're not using a dependency management tool like maven, you will have to chase down the dependencies yourself.  For example, Javassist depends on asm.\n\nAlso sl4j-api-1.7.10.jar is not enough by itself, you need a logging implementation like slf4j-log4j12.jar.  There are many logging implementations available, check the slf4j website.\n"
      }
    ]
  },
  {
    "number": 210,
    "title": "Is it essential to call `shutdown()` on HikariDataSource?",
    "created_at": "2014-11-28T11:53:48Z",
    "closed_at": "2014-11-28T13:55:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/210",
    "body": "",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/210/comments",
    "author": "timmolter",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-11-28T13:55:04Z",
        "body": "`shutdown()` or `close()` is essential at application termination, otherwise you will leave database resources in use.  Most IoC containers (Spring, JBoss, Hibernate, Tomcat) have a way to invoke a \"destroy\" method.\n\nSomewhat riskier, but still workable, is to set `minimumIdle` connections to 0, set the actual database to timeout connections after, for example, 5 minutes, and set the `idleTimeout` and `maxLifetime` in HikariCP to 4 minutes.  This way, if the application aborts \"uncleanly\", the database itself will terminate and cleanup the connections after 5 minutes.\n\nActually, even when `minimumIdle` is non-zero, is it not a bad idea to configure the native database timeouts to between 5-20 minutes, and the HikariCP `maxLifetime` about two minutes shorter than that.  There will be little discernable impact on performance for your application, but you can actually avoid some memory leaks present in databases due to long-held connections.\n"
      },
      {
        "user": "timmolter",
        "created_at": "2014-11-28T14:03:40Z",
        "body": "Thanks for the explanation. Very helpful.\n\nWhat if I have `DataSource ds = new HikariDataSource();`. How would you recommend closing `ds` since `DataSource` does not have a `close()` method? I noticed `HikariDataSource` implements `Closable`, but I'm not sure if that helps in my case.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2014-11-28T14:16:39Z",
        "body": "`Closeable` will help if you have raw `DataSource` and you are sure it is a `HikariDataSource`, you can simply cast to `Closeable` and call close (and possibly have to suppress a casting warning in your IDE).\n\nIssue #208 just before this one, when fixed, will allow you to call `ds.unwrap(HikariDataSource.class).close()`.\n"
      },
      {
        "user": "timmolter",
        "created_at": "2014-11-28T14:37:29Z",
        "body": "Is it just me or is it odd that `DataSource` does not have a `cleanup` method? It seems like every `DataSource` impl needs to implement some clean up. My particular problem is that I don't know if the `Datasource` is a `HikariDataSource` or something else.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2014-11-28T14:40:25Z",
        "body": "I agree, it is odd.  It is even stranger that (at a minimum) the `DataSource` (or at least `PooledDataSource`), in Java 8 still does not implement `Closeable`.  Would have been nice.\n"
      },
      {
        "user": "sundhr",
        "created_at": "2018-11-05T23:40:26Z",
        "body": "When the OS takes care of cleaning up the resources when the process exits, why should I take care of closing it during termination of the program?"
      }
    ]
  },
  {
    "number": 171,
    "title": "add new constructor for com.zaxxer.hikari.HikariConfig",
    "created_at": "2014-10-29T21:29:28Z",
    "closed_at": "2014-10-29T22:51:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/171",
    "body": "It might be useful to have a com.zaxxer.hikari.HikariConfig(Properties props) constructor in case one needs to add properties via a class loader instead of a file system path:\n\n// Scala code\n  val cfgFile = \"mysql.hikari.properties\"\n  val cfgStream: InputStream = this.getClass().getResourceAsStream(cfgFile)\n  val cfgProperties = (new java.util.Properties()).load(cfgStream)\n  val hcfg = new HikariConfig(cfgProperties)\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/171/comments",
    "author": "maxpsq",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-10-29T22:51:05Z",
        "body": "HikariCP already supports this in two ways.  First, there is a `HikariConfig(Properties)` constructor.  Second, the `HikariConfig(String propertyFileName)` has special behavior:\n\n``` java\n   /**\n    * Construct a HikariConfig from the specified property file name.  <code>propertyFileName</code>\n    * will first be treated as a path in the file-system, and if that fails the \n    * ClassLoader.getResourceAsStream(propertyFileName) will be tried.\n    *\n    * @param propertyFileName the name of the property file\n    */\n   public HikariConfig(String propertyFileName)\n```\n\nwith implementation:\n\n``` java\n   private void loadProperties(String propertyFileName)\n   {\n      final File propFile = new File(propertyFileName);\n      try (final InputStream is = propFile.isFile() ? new FileInputStream(propFile) : this.getClass().getResourceAsStream(propertyFileName)) {\n         if (is != null) {\n            Properties props = new Properties();\n            props.load(is);\n            PropertyBeanSetter.setTargetFromProperties(this, props);\n         }\n         else {\n            throw new IllegalArgumentException(\"Property file \" + propertyFileName + \" was not found.\");\n         }\n      }\n      catch (IOException io) {\n         throw new RuntimeException(\"Error loading properties file\", io);\n      }\n   }\n```\n"
      }
    ]
  },
  {
    "number": 162,
    "title": "Problems with Multiple HikariCP instances in same JVM",
    "created_at": "2014-10-15T06:02:42Z",
    "closed_at": "2014-10-15T07:23:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/162",
    "body": "Spring3.2 + HikariCP-java6 2.0.1  \nwhen 1 HikariCP instances,I config like this \n\napplication.properties\n\n```\njdbc.url=jdbc:mysql://127.0.0.1:3306/fiuc?zeroDateTimeBehavior\\=round&useUnicode\\=true&characterEncoding\\=UTF-8\njdbc.username=root\njdbc.password=root\n```\n\napplication.xml\n\n```\n    <context:property-placeholder \n                                  location=\"classpath*:application.properties\"/>\n    <bean id=\"hikariConfig\" class=\"com.zaxxer.hikari.HikariConfig\">\n        <property name=\"poolName\" value=\"springHikariCP\"/>\n        <property name=\"connectionTestQuery\" value=\"SELECT 1\"/>\n        <property name=\"dataSourceClassName\" value=\"com.mysql.jdbc.jdbc2.optional.MysqlDataSource\"/>\n        <property name=\"dataSourceProperties\">\n            <props>\n                <prop key=\"url\">${jdbc.url}</prop>\n                <prop key=\"user\">${jdbc.username}</prop>\n                <prop key=\"password\">${jdbc.password}</prop>\n                <prop key=\"cachePrepStmts\">true</prop>\n                <prop key=\"prepStmtCacheSize\">250</prop>\n                <prop key=\"prepStmtCacheSqlLimit\">2048</prop>\n                <prop key=\"useServerPrepStmts\">true</prop>\n            </props>\n        </property>\n    </bean>\n\n    <bean id=\"dataSource\" class=\"com.zaxxer.hikari.HikariDataSource\"\n          destroy-method=\"shutdown\">\n            <constructor-arg ref=\"hikariConfig\"/>\n    </bean>\n```\n\nlog like this\n\n```\n13:33:24.849 [http-apr-8080-exec-4] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceJNDI..................\n13:33:24.849 [http-apr-8080-exec-4] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceProperties............{user=root, url=jdbc:mysql://127.0.0.1:3306/fiuc?zeroDateTimeBehavior=round&useUnicode=true&characterEncoding=UTF-8, password=<masked>, prepStmtCacheSqlLimit=2048, useServerPrepStmts=true, cachePrepStmts=true, prepStmtCacheSize=250}\n```\n\nbut I need connect multiple database,so i config Multiple HikariCP instances,like this \n\n```\njdbc.url=jdbc:mysql://127.0.0.1:3306/fiuc?zeroDateTimeBehavior\\=round&useUnicode\\=true&characterEncoding\\=UTF-8\njdbc.username=root\njdbc.password=root\n\nwjuser.jdbc.url=jdbc:mysql://10.154.250.19:3306/wjuser?zeroDateTimeBehavior\\=round&useUnicode\\=true&characterEncoding\\=UTF-8\nwjuser.jdbc.username=wangjiu\nwjuser.jdbc.password=wangjiu\n```\n\n```\n    <bean id=\"hikariConfig\" class=\"com.zaxxer.hikari.HikariConfig\">\n        <property name=\"poolName\" value=\"springHikariCP\"/>\n        <property name=\"connectionTestQuery\" value=\"SELECT 1\"/>\n        <property name=\"dataSourceClassName\" value=\"com.mysql.jdbc.jdbc2.optional.MysqlDataSource\"/>\n        <property name=\"dataSourceProperties\">\n            <props>\n                <prop key=\"url\">${jdbc.url}</prop>\n                <prop key=\"user\">${jdbc.username}</prop>\n                <prop key=\"password\">${jdbc.password}</prop>\n                <prop key=\"cachePrepStmts\">true</prop>\n                <prop key=\"prepStmtCacheSize\">250</prop>\n                <prop key=\"prepStmtCacheSqlLimit\">2048</prop>\n                <prop key=\"useServerPrepStmts\">true</prop>\n            </props>\n        </property>\n    </bean>\n\n    <bean id=\"dataSource\" class=\"com.zaxxer.hikari.HikariDataSource\"\n          destroy-method=\"shutdown\">\n            <constructor-arg ref=\"hikariConfig\"/>\n    </bean>\n    <bean id=\"hikariConfig_wjuser\" class=\"com.zaxxer.hikari.HikariConfig\">\n        <property name=\"poolName\" value=\"springHikariCP_wjuser\"/>\n        <property name=\"connectionTestQuery\" value=\"SELECT 1\"/>\n        <property name=\"dataSourceClassName\" value=\"com.mysql.jdbc.jdbc2.optional.MysqlDataSource\"/>\n        <property name=\"maximumPoolSize\" value=\"2\"/>\n        <property name=\"dataSourceProperties\">\n            <props>\n                <prop key=\"url\">\n                    ${wjuser.jdbc.url}\n                </prop>\n                <prop key=\"user\">${wjuser.jdbc.username}</prop>\n                <prop key=\"password\">${wjuser.jdbc.password}</prop>\n                <prop key=\"cachePrepStmts\">true</prop>\n            </props>\n        </property>\n    </bean>\n\n    <bean id=\"dataSource_wjuser\" class=\"com.zaxxer.hikari.HikariDataSource\"\n          destroy-method=\"shutdown\">\n        <constructor-arg ref=\"hikariConfig_wjuser\"/>\n    </bean>\n```\n\nlog \n\n```\n13:33:11.820 [http-apr-8080-exec-4] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceClassName.............com.mysql.jdbc.jdbc2.optional.MysqlDataSource\n13:33:11.822 [http-apr-8080-exec-4] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceJNDI..................\n*13:33:11.823 [http-apr-8080-exec-4] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceProperties............{user=${wjuser.jdbc.username}, url=${wjuser.jdbc.url}, password=<masked>, cachePrepStmts=true}*\n13:33:11.825 [http-apr-8080-exec-4] DEBUG com.zaxxer.hikari.HikariConfig - driverClassName.................\n13:33:11.827 [http-apr-8080-exec-4] DEBUG com.zaxxer.hikari.HikariConfig - idleTimeout.....................600000\n....................\n13:33:24.437 [http-apr-8080-exec-4] INFO  org.springframework.context.support.PropertySourcesPlaceholderConfigurer - Loading properties file from URL [file:/D:/WorkTool/apache-tomcat-7.0.55/webapps/fiuc/WEB-INF/classes/application.properties]\n13:33:24.438 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.MutablePropertySources - Adding [localProperties] PropertySource with lowest search precedence\n13:33:24.443 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Searching for key 'wjuser.jdbc.url' in [environmentProperties]\n13:33:24.444 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Searching for key 'wjuser.jdbc.url' in [servletConfigInitParams]\n13:33:24.444 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Searching for key 'wjuser.jdbc.url' in [servletContextInitParams]\n13:33:24.444 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Searching for key 'wjuser.jdbc.url' in [jndiProperties]\n13:33:24.445 [http-apr-8080-exec-4] DEBUG org.springframework.jndi.JndiTemplate - Looking up JNDI object with name [java:comp/env/wjuser.jdbc.url]\n13:33:24.447 [http-apr-8080-exec-4] DEBUG org.springframework.jndi.JndiLocatorDelegate - Converted JNDI name [java:comp/env/wjuser.jdbc.url] not found - trying original name [wjuser.jdbc.url]. javax.naming.NameNotFoundException: Name [wjuser.jdbc.url] is not bound in this Context. Unable to find [wjuser.jdbc.url].\n13:33:24.447 [http-apr-8080-exec-4] DEBUG org.springframework.jndi.JndiTemplate - Looking up JNDI object with name [wjuser.jdbc.url]\n13:33:24.449 [http-apr-8080-exec-4] DEBUG org.springframework.jndi.JndiPropertySource - JNDI lookup for name [wjuser.jdbc.url] threw NamingException with message: Name [wjuser.jdbc.url] is not bound in this Context. Unable to find [wjuser.jdbc.url].. Returning null.\n13:33:24.450 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Searching for key 'wjuser.jdbc.url' in [systemProperties]\n13:33:24.451 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Searching for key 'wjuser.jdbc.url' in [systemEnvironment]\n13:33:24.451 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Could not find key 'wjuser.jdbc.url' in any property source. Returning [null]\n13:33:24.451 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Searching for key 'wjuser.jdbc.url' in [localProperties]\n*13:33:24.452 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Found key 'wjuser.jdbc.url' in [localProperties] with type [String] and value 'jdbc:mysql://10.154.250.19:3306/wjuser?zeroDateTimeBehavior=round&useUnicode=true&characterEncoding=UTF-8'*\n13:33:24.462 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Searching for key 'jdbc.url' in [environmentProperties]\n13:33:24.462 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Searching for key 'jdbc.url' in [servletConfigInitParams]\n13:33:24.462 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Searching for key 'jdbc.url' in [servletContextInitParams]\n13:33:24.463 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Searching for key 'jdbc.url' in [jndiProperties]\n13:33:24.463 [http-apr-8080-exec-4] DEBUG org.springframework.jndi.JndiTemplate - Looking up JNDI object with name [java:comp/env/jdbc.url]\n13:33:24.463 [http-apr-8080-exec-4] DEBUG org.springframework.jndi.JndiLocatorDelegate - Converted JNDI name [java:comp/env/jdbc.url] not found - trying original name [jdbc.url]. javax.naming.NameNotFoundException: Name [jdbc.url] is not bound in this Context. Unable to find [jdbc.url].\n13:33:24.463 [http-apr-8080-exec-4] DEBUG org.springframework.jndi.JndiTemplate - Looking up JNDI object with name [jdbc.url]\n13:33:24.464 [http-apr-8080-exec-4] DEBUG org.springframework.jndi.JndiPropertySource - JNDI lookup for name [jdbc.url] threw NamingException with message: Name [jdbc.url] is not bound in this Context. Unable to find [jdbc.url].. Returning null.\n13:33:24.464 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Searching for key 'jdbc.url' in [systemProperties]\n13:33:24.464 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Searching for key 'jdbc.url' in [systemEnvironment]\n13:33:24.464 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Could not find key 'jdbc.url' in any property source. Returning [null]\n13:33:24.464 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Searching for key 'jdbc.url' in [localProperties]\n13:33:24.465 [http-apr-8080-exec-4] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Found key 'jdbc.url' in [localProperties] with type [String] and value 'jdbc:mysql://127.0.0.1:3306/fiuc?zeroDateTimeBehavior=round&useUnicode=true&characterEncoding=UTF-8'\n13:33:24.849 [http-apr-8080-exec-4] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceClassName.............com.mysql.jdbc.jdbc2.optional.MysqlDataSource\n13:33:24.849 [http-apr-8080-exec-4] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceJNDI..................\n*13:33:24.849 [http-apr-8080-exec-4] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceProperties............{user=root, url=jdbc:mysql://127.0.0.1:3306/fiuc?zeroDateTimeBehavior=round&useUnicode=true&characterEncoding=UTF-8, password=<masked>, prepStmtCacheSqlLimit=2048, useServerPrepStmts=true, cachePrepStmts=true, prepStmtCacheSize=250}*\n13:33:24.849 [http-apr-8080-exec-4] DEBUG com.zaxxer.hikari.HikariConfig - driverClassName.................\n13:33:24.850 [http-apr-8080-exec-4] DEBUG com.zaxxer.hikari.HikariConfig - idleTimeout.....................600000\n```\n\nI think Because\nthe first instance create before PropertySourcesPropertyResolver created, but the second instance  after 。\nso how can i do  let the first instance after the PropertySourcesPropertyResolver  created? \nis this spring bug or Hikari 's? \n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/162/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-10-15T07:23:28Z",
        "body": "This is a spring issue.  You need to set the `order` property on the `context:property-placeholder`.  You  can also use the `depends-on` property on the beans to make one bean initialize after the second.  Either way, this problem can be solved with proper Spring configuration.\n"
      }
    ]
  },
  {
    "number": 157,
    "title": "HikariCP not releasing connections after idleTimeout should have elapsed",
    "created_at": "2014-10-08T03:34:22Z",
    "closed_at": "2014-10-08T03:51:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/157",
    "body": "Hello,\n\nI'm running HikariCP on Play v2.3.4 via the HikariCP Play plugin and the following config file:\ndataSource.cachePrepStmts=true\ndataSource.prepStmtCacheSize=250\ndataSource.prepStmtCacheSqlLimit=2048\ndataSource.useServerPrepStmts=true\nmaximumPoolSize=30\nidleTimeout=60000\nleakDetectionThreshold=30000\n\nBased on this config, I expect any Java Connection handlers to be closed after 60 sec, but it apparently is not the case.\n\nHere's an example of some code we found today:\n\nConnection conn = DB.getConnection();\n// Run queries\n// A line that produces a NullPointerException\nDB.closeConnection(conn);\n\nIn this example, the user hit this block of code > 30 times, which caused all the available connections in our pool to be used up. This caused the entire web application to hang and lots of Timeout errors were thrown in the log. I would expect functionality to return to normal within 60 seconds, because the connections that weren't closed by the Java code would be killed by HikariCP. This did not happen - I had to manually restart the server for the connections to be released and the app to be functional.\n\nAm I understanding the point of idleTimeout correctly? If not, is there a different config option I can set so that HikariCP watches over Connected but Idle connections, and kills off those who were not closed properly after X amount of seconds?\n\nThanks so much.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/157/comments",
    "author": "maxzats",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-10-08T03:51:02Z",
        "body": "Idle connections are those that are _in_ the pool and not being used.  In your case, these connections are _out_ of the pool.  HikariCP provides no means to kill connections that are out of the pool, and will probably never do so.  This is a conscious design decision, not an oversight.  Code that leaks connections is a bug (in the application), and HikariCP will not cover-up or remediate bugs in the underlying application.\n\nConnections obtained from the pool should _always_ be returned in a `finally` clause (or the Scala equivalent):\n\n``` java\nConnection conn = DB.getConnection();\ntry {\n   // Run queries\n   // A line that produces a NullPointerException\n}\nfinally {\n   DB.closeConnection(conn);\n}\n```\n"
      }
    ]
  },
  {
    "number": 155,
    "title": "Passing useLegacyDatetimeCode without using jdbcUrl",
    "created_at": "2014-10-04T12:19:40Z",
    "closed_at": "2014-10-04T13:28:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/155",
    "body": "When using bonecp I passed with jdbc url ...:3306/DBNAME?useLegacyDatetimeCode=false\n\nHow can I pass it using the new HikariCP DataSource?\n\nIs this ok?\nconfig.addDataSourceProperty(\"useLegacyDatetimeCode\", \"false\");\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/155/comments",
    "author": "chook",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-10-04T13:28:49Z",
        "body": "Set Hikari's initializationFailFast=true, If it doesn't throw an Exception, it's working.  The best way to check what is available is to look at the JavaDoc for the MySQL DataSource.  If there is a setter like setUseLegacyDatetimeCode() then that will work fine.\n"
      },
      {
        "user": "chook",
        "created_at": "2014-10-05T07:06:16Z",
        "body": "Thanks!\n"
      }
    ]
  },
  {
    "number": 152,
    "title": "connectionInitSql does not allow multiple statements",
    "created_at": "2014-09-29T20:14:17Z",
    "closed_at": "2014-09-29T22:59:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/152",
    "body": "connectionInitSql allows to set a single initialization statement. However, there is no way at the moment to issue more than one statements.\n\nIt would be good if several such statements could be configured, or for maximum flexibility if a callback can be set\n\nThis is how I do it in Bonecp:\n\n```\nconfig.setConnectionHook(new AbstractConnectionHook() {\n    @Override\n    public void onAcquire(ConnectionHandle con) {\n                con.setReadOnly(false);\n                con.setAutoCommit(false);\n                if (type==TYPE.ORACLE) {\n                    // -- make oracle non case sensitive\n                    try (Statement s = con.createStatement()) {\n                        s.addBatch(\"alter session set NLS_COMP=ANSI\");\n                        s.addBatch(\"alter session set NLS_SORT=BINARY_CI\");\n                        s.executeBatch();\n                        con.commit();\n                    }\n                }\n        }\n    });\n```\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/152/comments",
    "author": "baumeister",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-09-29T22:59:04Z",
        "body": "If you build the project, you can read the JavaDocs.  There is a property, currently undocumented on the web page, called `connectionCustomizerClassName`.  It specifies a class that implements IConnectionCustomizer, which is passed the Connection after creation to do whatever it wants before it is added to the pool.\n"
      },
      {
        "user": "Menthalion",
        "created_at": "2015-03-09T12:54:21Z",
        "body": "This can be done with the current connectionInitSql and adjusting your SQL.\n\nWith Microsoft SQL and most other databases, simply concatenate your SQL commands into one statement, separated with the database's query separator (usually `;`).\n\nWith Oracle you need to go one further step by wrapping these commands in a `BEGIN;...;END` block. \nSome SQL commands that cannot be performed transactionally in such a block (like `ALTER SESSION`) might need to be prepended with `EXECUTE IMMEDIATE` followed by the quoted SQL.\n\nExample\n\n```\nBEGIN;\nEXECUTE IMMEDIATE q'ALTER SESSION SET NLS_SORT='BINARY_AI'';\nEXECUTE IMMEDIATE q'ALTER SESSION SET NLS_COMP='LINGUISTIC'';\nEND\n```\n\nOracle also has specific `DBMS_SESSION.SET` functions that allows them to be set immediately in a `BEGIN;...;END` block, without any need for escaping\n\n```\nBEGIN;\nDBMS_SESSION.SET_NLS('NLS_SORT', 'BINARY_AI');\nDBMS_SESSION.SET_NLS('NLS_COMP', 'LINGUISTIC');\nEND\n```\n"
      },
      {
        "user": "eidottermihi",
        "created_at": "2020-08-18T09:30:21Z",
        "body": "@Menthalion\r\nthanks for sharing your solution, I had to alter your solution to support altering other NLS parameters (`nls_date_format` and `nls_timestamp_format`):\r\n\r\n```\r\nBEGIN \r\nDBMS_SESSION.SET_NLS('nls_date_format', '''YYYY-MM-DD HH24:MI:SS''');\r\nDBMS_SESSION.SET_NLS('nls_timestamp_format', '''YYYY-MM-DD HH24:MI:SS'''); \r\nEND;\r\n```"
      }
    ]
  },
  {
    "number": 151,
    "title": "HikariConfig username property?",
    "created_at": "2014-09-29T16:48:10Z",
    "closed_at": "2014-10-03T09:23:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/151",
    "body": "HikariConfig has a property which represents  the default authentication username.\nHowever, what's the property name: username or user?\nThe home page's introduction is conflict.\nI'm from China. Sorry for my terrible English.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/151/comments",
    "author": "CodePlayer",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-09-30T13:35:28Z",
        "body": "If you use a DataSource-class, HikariCP will call dataSource.getConnection(username, password).  If you use a Driver-class and JDBC URL, HikariCP will set a `user` property from the HikariConfig username, like this:\n\n``` java\nif (username != null) {\n   driverProperties.put(\"user\", driverProperties.getProperty(\"user\", username));\n}\n...\nreturn DriverManager.getConnection(jdbcUrl, driverProperties);\n```\n\nIf your driver expects a `username` property instead of `user`, then ignore the `HikariConfig.setUsername()` method and call `HikariCP.addDataSourceProperty(\"username\", ...)` instead.  Or put the username in the JDBC URL (eg. `jdbc:mysql://localhost/db?username=...`).\n"
      },
      {
        "user": "CodePlayer",
        "created_at": "2014-10-03T09:23:57Z",
        "body": "Oh, I see! It's pretty clear. Many thanks!\n"
      }
    ]
  },
  {
    "number": 142,
    "title": "Support XA Transactions/Connection",
    "created_at": "2014-09-15T09:03:06Z",
    "closed_at": "2014-09-15T22:44:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/142",
    "body": "Does HikariCP currently support XA Transactions/Connections?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/142/comments",
    "author": "jeichhorn",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-09-15T22:44:26Z",
        "body": "Currently it does not.  It may in the future.\n"
      }
    ]
  },
  {
    "number": 141,
    "title": "Allow to listen for connection open/release events",
    "created_at": "2014-09-12T13:39:33Z",
    "closed_at": "2014-09-12T13:59:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/141",
    "body": "Hello.\n\nWe need to run some audit SQL everytime a connection is retrieved and released.\n\nCurrently we solve this by using a wrapper Connection object to intercept open/close calls.\n\nDo you have plans to integrate some listener function to HikariCP, or do you see some other way to handle this on Hikari?\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/141/comments",
    "author": "lucianogreiner",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-09-12T13:59:10Z",
        "body": "Thank you for evaluating HikariCP.  We do not have any immediate plans to integrate listener type functionality.  Using a Connection and/or DataSource wrapper is probably the best way to solve this.  I believe some other pools, such as Tomcat DBCP may offer listener functionality.\n"
      }
    ]
  },
  {
    "number": 132,
    "title": "Lying logs?",
    "created_at": "2014-08-07T18:39:48Z",
    "closed_at": "2014-08-07T23:57:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/132",
    "body": "I'm using HikariCP 2.0.1 and have been seeing the following log messages:\n\n```\n2014-08-07 14:33:45,045 [Hikari Housekeeping Timer (pool HikariPool-0)] DEBUG (HikariPool.java:528) - Before cleanup pool stats HikariPool-0 (total=20, inUse=4, avail=16, waiting=0)\n2014-08-07 14:33:45,045 [Hikari Housekeeping Timer (pool HikariPool-0)] DEBUG (HikariPool.java:528) - After cleanup pool stats HikariPool-0 (total=20, inUse=4, avail=16, waiting=0)\n2014-08-07 14:34:15,046 [Hikari Housekeeping Timer (pool HikariPool-0)] DEBUG (HikariPool.java:528) - Before cleanup pool stats HikariPool-0 (total=20, inUse=4, avail=16, waiting=0)\n2014-08-07 14:34:15,046 [Hikari Housekeeping Timer (pool HikariPool-0)] DEBUG (HikariPool.java:528) - After cleanup pool stats HikariPool-0 (total=20, inUse=4, avail=16, waiting=0)\n2014-08-07 14:34:45,046 [Hikari Housekeeping Timer (pool HikariPool-0)] DEBUG (HikariPool.java:528) - Before cleanup pool stats HikariPool-0 (total=20, inUse=4, avail=16, waiting=0)\n2014-08-07 14:34:45,063 [Hikari Housekeeping Timer (pool HikariPool-0)] DEBUG (HikariPool.java:528) - After cleanup pool stats HikariPool-0 (total=4, inUse=4, avail=0, waiting=0)\n```\n\nMy `maximumPoolSize` is set to 20 but for whatever reason the last log message is reporting a total of only 4. Is this normal?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/132/comments",
    "author": "siklosg",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-08-07T23:57:26Z",
        "body": "What did the _next_ log say?  The way the housekeeping threads works is essentially this:\n\n``` java\n{\n   logPoolState(\"Before cleanup \");\n\n   // Close expired idle and maxLifetime connections\n\n   logPoolState(\"After cleanup \");\n\n   // Kick-off asynchronous refilling of idle connections\n}\n```\n\nSo it is possible for the housekeeping thread to retire a whole bunch of connections at once, especially if they were created at nearly the same time, if they have reached their maxLifetime.  The \"After cleanup\" immediately after that would show what you saw.  In all likelihood, the pool connections were replaced within a second or so by the asynchronous fill.\n"
      }
    ]
  },
  {
    "number": 120,
    "title": "HikariCP API?",
    "created_at": "2014-07-25T20:34:59Z",
    "closed_at": "2014-07-26T01:18:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/120",
    "body": "HikariCP is my first experience with connection pooling for MySQL. Is there any kind of documentation that details the API for HikariCP usage? Or should I just read through the source?\n\nThank you!\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/120/comments",
    "author": "vagupta",
    "comments": [
      {
        "user": "vagupta",
        "created_at": "2014-07-25T20:43:02Z",
        "body": "I understand how to configure and set up the data source, but I'm just wondering how I should properly manage a connection. \n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2014-07-26T01:18:10Z",
        "body": "Generally, you want to get a connection from the pool, use it for a query or queries and then close() the connection (returning it to the pool).  For most applications, such as web applications, the typically out-of-pool time for a connection is typically on the order of milliseconds or maybe a few seconds.  So, for highly-available applications, you want to get a connection, use it, and close() it as quickly as possible so that it becomes available to other threads in the system.\n\nIn the case of a data warehouse application, where reports and queries may run for hours, obviously the connection is out of the pool for as long as it takes a query to run.\n"
      },
      {
        "user": "vagupta",
        "created_at": "2014-07-28T17:02:37Z",
        "body": "Thanks for the response!\n\nOne follow-up question: If I have a Connection connection, do I call connection.close() to close() that connection and return it to the connection pool?\n\nIf so, why? I was under the impression that calling close() on a Connection actually deletes the underlying resources for that Connection. How does the connection pool know when I call close() on a pooled Connection? Is that where the delegation comes into play? What does isClosed() check?\n\nI hope my question makes sense. I'm really trying to understand the difference between closing a Connection and returning it the connection pool.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2014-07-30T05:06:55Z",
        "body": "You are correct.  HikariCP (and all JDBC connection pools) wrap the _real_ `Connection` in a _delegating proxy_.  This proxy intercepts (overrides) calls to `close()`, and instead of closing the underlying `Connection` instead returns it to the pool.  In terms of the JDBC specification, this proxy is called a _Logical Connection_ and the real connection to the database is called a _Physical Connection_.\n\nMostly, the application code should not need to know whether it is running against a pooled connections or real connections.  The access pattern is the same; call `DataSource.getConnection()` and after executing queries call `Connection.close()`.\n\nIf you obtain a `Connection` from the pool, then call `close()`, if you then call `isClosed()` you will receive a value of `true`.  From the perspective of the application, the `Connection` _is_ closed.  If you try to call methods on the `Connection` after closing, you will receive a `SQLException` (just like a non-pooled `Connection`).  In reality, however, the _Physical Connection_ is _not_ closed, but the _Logical Connection_ _is_ closed.\n\nAgain, the goal of every pool (and in accordance with the JDBC specification) is to provide identical API behavior from the perspective of an application.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2014-07-30T05:10:39Z",
        "body": "Just to add a little more detail.  There is no way for an application to force a close of the _Physical Connection_.  The pool controls the life-cycle of the _Physical Connection_.  By setting the `maximumPoolSize`, `idleTimeout`, and `maxLifetime` properties you can control the life-cycle of _Physical Connections_ in a very general way.\n"
      },
      {
        "user": "vagupta",
        "created_at": "2014-07-30T17:33:08Z",
        "body": "Wow, okay. I appreciate your explanation. Now, I've got a much better idea of how the pooling works. I just realized that \"Connection\" is an interface and not the actual object. \n\nThank you for your help, and thank you for making HikariCP.\n"
      }
    ]
  },
  {
    "number": 108,
    "title": "HikariCP and exiting a program",
    "created_at": "2014-07-10T15:32:18Z",
    "closed_at": "2014-07-10T22:57:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/108",
    "body": "I am wondering if I need to call System.exit(1) in my program, do I need to perform any kind of cleanup with HikariCP, kind of like flushing a buffer with files or running shutdown with executorservice? Currently, when I call getConnection() on HikariDataSource, I have a finally block that closes the statement, result and connection (actually I assume the connection is returned to the pool):\n\n```\n        if (stmt != null)  \n            {  \n                stmt.close();\n            }  \n\n            if (result != null)  \n            {  \n                result.close();  \n            }  \n\n            if (conn != null)  \n            {  \n                conn.close();  \n            } \n```\n\nI would like to know if I need to do anything else when I exit my program. \n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/108/comments",
    "author": "JohnMerlino1",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-07-10T22:57:12Z",
        "body": "You should call `close()` or `shutdown()` on the `HikariDataSource` before you exit.  This will ensure that all connections to the database in the pool are closed.\n"
      }
    ]
  },
  {
    "number": 94,
    "title": "Unexpected behaviour when setting connectionTimeout = 0",
    "created_at": "2014-06-25T16:13:35Z",
    "closed_at": "2014-06-27T06:42:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/94",
    "body": "Setting connectionTimeout to 0 in HikariConfig actually stores the value as Integer.MAX_VALUE, which signifies 'no timeout'.  This is mandatory for some Drivers (e.g. some versions of PostgreSQL).\n\nThis value is later used correctly by HikariPool.isConnectionAlive() to signify that a timeout of zero is required - however, HikariPool.getConnection() does not seem to be aware of this, and literally uses Integer.MAX_VALUE as the timeout.\n\nI'm sure this is not the desired behaviour.\nWhen a connection cannot be created, the following occurs:\n\nThe 'do...while (timeout > 0L)' in the getConnection() method seems to run a few times (not enough for timeout to reach zero) before the call to ConcurrentBag.borrow() stalls at 'synchronizer.tryAcquireSharedNanos(startScan, timeout)'.  I'm not sure what the factor is that makes this happen after a few iterations.\n\nI do not understand this code enough to explain why this happens.  I think there is an underlying issue here, that the same timeout value is used for both the queryTimeout on Statements and by HikariCP itself when deciding if it should timeout when connecting.\n\nIdeally, in the situation described above, although the Statement queryTimeout is (logically) zero, the getConnection() call should be able to timeout and throw an exception.\n\nI'm sure I have explained this poorly - please feel free to ask for clarification.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/94/comments",
    "author": "MuzuMatt",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-06-27T06:42:57Z",
        "body": "A timeout of \"0\" literally means never timeout when calling `getConnection()`.  By setting `connectionTimeout` to 0, the user is saying \"I'm willing to wait until the Sun burns out to get a connection\".  The `isConnectionAlive()` uses 0 in this case, which the JavaDoc for Statement states \"zero means there is no limit\".\n\nIt is normal and appropriate for `getConnection()` to block in `ConcurrentBag.barrow()`.  This means there are no available connections in the pool.  The calling thread is waiting for one to be created or returned by another thread.  When this condition occurs, `ConcurrentBag` invokes the `IBagStateListener.addBagItem()` callback before waiting.  The implementation of this callback in the pool starts a background thread that keeps trying to add connections to the pool until it succeeds.\n"
      }
    ]
  },
  {
    "number": 70,
    "title": "Suppress warning message on connection death",
    "created_at": "2014-04-30T05:24:24Z",
    "closed_at": "2014-04-30T05:30:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/70",
    "body": "So I had a connection die and HikariCP threw two huge warning messages into my log. Can I either suppress these or replace them with my own message? I don't really care if a connection sitting idle in the pool died, since a new one will just take its place. The first two lines from the two stack traces are below:\n\n```\n2014-04-30 01:00:11 [WARN] Connection com.amshulman.insight.lib.mysql.MySQLConnection@cf5011b (HikariPool-0) marked as broken because of SQLSTATE(08), ErrorCode(-1).\njava.sql.SQLNonTransientConnectionException: Could not ping: unexpected end of stream, read 0bytes from 4\n\n2014-04-30 01:00:11 [WARN] Exception during keep alive check, that means the connection must be dead.\njava.sql.SQLNonTransientConnectionException: Could not ping: unexpected end of stream, read 0bytes from 4\n```\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/70/comments",
    "author": "ams2990",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-04-30T05:30:05Z",
        "body": "You can suppress these if you want.  But you might not get these with the latest version (1.3.8), because the isConnectionAlive() test was allowing some dead connection through, when they should have been terminated before returning them to the user.  But you might also want to make sure your `maxLifetime` in the pool is set to something slightly shorter than the idle timeout configured in your database.\n"
      },
      {
        "user": "ams2990",
        "created_at": "2014-04-30T05:43:30Z",
        "body": "How do I suppress the warning messages? I didn't see a configuration setting.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2014-04-30T05:48:01Z",
        "body": "You would do it through your logging framework.  For example, in log4j (property file):\n\n``` ini\nlog4j.logger.com.zaxxer.hikari.proxy=ERROR\n```\n\nthat will suppress logs that are less than ERROR (eg. WARN, INFO, DEBUG) for the classes in package `com.zaxxer.hikari.proxy`.  Most other logging frameworks (java.util.logging) have similar configuration options.\n"
      },
      {
        "user": "ams2990",
        "created_at": "2014-04-30T05:50:16Z",
        "body": "Is a dead connection the only warning HikariCP will throw?\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2014-04-30T05:54:12Z",
        "body": "The only other one is if you are using the leak detection feature.  So, if you want to specifically target that message as much as possible, use:\n\n``` ini\nlog4j.logger.com.zaxxer.hikari.proxy.ConnectionProxy=ERROR\n```\n\nThe leak detection is logged from another class, so would not be suppressed by that configuration.\n"
      }
    ]
  },
  {
    "number": 56,
    "title": "Javassist to ASM",
    "created_at": "2014-04-03T07:55:00Z",
    "closed_at": "2014-04-07T05:20:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/56",
    "body": "What does you think about migration from Javassist to ASM? I can help You to rewrite bytecode generation procedures.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/56/comments",
    "author": "dimzon",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-04-03T17:48:34Z",
        "body": "What is the advantage?\n"
      },
      {
        "user": "dimzon",
        "created_at": "2014-04-03T18:11:24Z",
        "body": "1. less dependency size\n2. faster initialization (javassist need to parse string containing java code)\n\nanyway it's just proposal\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2014-04-07T05:20:14Z",
        "body": "While I agree it requires a small dependency, the level at which bytecode generation occurs is simply too low for me.  I don't think generating code at the bytecode level such as this:\n\n``` java\nMethodNode mn = new MethodNode(...);\nInsnList il = mn.instructions;\nil.add(new VarInsnNode(ILOAD, 1));\nLabelNode label = new LabelNode();\nil.add(new JumpInsnNode(IFLT, label));\nil.add(new VarInsnNode(ALOAD, 0));\nil.add(new VarInsnNode(ILOAD, 1));\nil.add(new FieldInsnNode(PUTFIELD, \"pkg/Bean\", \"f\", \"I\"));\nLabelNode end = new LabelNode();\nil.add(new JumpInsnNode(GOTO, end));\nil.add(label);\nil.add(new FrameNode(F_SAME, 0, null, 0, null));\nil.add(new TypeInsnNode(NEW, \"java/lang/IllegalArgumentException\"));\nil.add(new InsnNode(DUP));\nil.add(new MethodInsnNode(INVOKESPECIAL,\n          \"java/lang/IllegalArgumentException\", \"<init>\", \"()V\"));\nil.add(new InsnNode(ATHROW));\nil.add(end);\nil.add(new FrameNode(F_SAME, 0, null, 0, null));\nil.add(new InsnNode(RETURN));\nmn.maxStack = 2;\nmn.maxLocals = 2;\n```\n\n... leads to particularly readable or maintainable code.  I'm sure ASM has its place, for example when writing bytecode compilers, but I don't think it is a particularly good for the code generation needs of HikariCP.\n"
      }
    ]
  },
  {
    "number": 38,
    "title": "[Question] Handling Connections",
    "created_at": "2014-02-28T20:45:37Z",
    "closed_at": "2014-03-01T03:01:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/38",
    "body": "Hey brettwooldridge,\n\nI haven't worked with connectionpools a lot, and I stumbled upon the question what I have to do in the finally-block of queries. So without a connection-pool I closed the PreparedStatement, the ResultSet and the Connection. Which of them do I have to close in the finally-block while using HikariCP as ConnectionPool?\n\nThanks in Advance!\nScrayos\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/38/comments",
    "author": "scrayos",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-03-01T03:01:52Z",
        "body": "In general it is always a good practice to release resources like Statements and ResultSets quickly by explicitly closing them.  Having said that, the contract of JDBC states that closing a Statement will automatically close open ResultSets, and that closing a Connection will automatically close open Statements.  So in theory you only ever need to close the Connection in the finally, and it will close open Statements which will close open ResultSets.\n\nIn a Connection pool, even though closing a Connection does not truly close it, and instead returns it to the pool, a properly implemented connection pool should close open Statements in just the same way as standard JDBC when the connection is returned to the pool.\n\nYou can basically leave your code just as it is.  One of the contracts of a connection pool is that changing from a standard DataSource to a pooled DataSource should require no changes to the code that uses it.\n"
      }
    ]
  },
  {
    "number": 32,
    "title": "Question: how to fail fast on bad DB password",
    "created_at": "2014-02-03T23:22:44Z",
    "closed_at": "2014-02-12T14:04:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/32",
    "body": "Hi,\nIf my HikariCP config has the wrong database credentials, I'd like my server to fail fast.\n\nSeems like the only way is to wait for acquireRetries \\* acquireRetryDelay milliseconds, then try to call getConnection(), catch the SQLException and then exit.\n\nDo I have that right?\n\nThanks,\nMark\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/32/comments",
    "author": "mbucc",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-02-03T23:39:44Z",
        "body": "That is correct.\n\nSent from my iPhone\n\n> On Feb 4, 2014, at 8:22 AM, mbucc notifications@github.com wrote:\n> \n> Hi,\n> If my HikariCP config has the wrong database credentials, I'd like my server to fail fast.\n> \n> Seems like the only way is to wait for the acquireRetries \\* acquireRetryDelay milliseconds, then try to call getConnection(), catch the SQLException and then exit.\n> \n> Do I have that right?\n> \n> Thanks,\n> Mark\n> \n> \\\n> Reply to this email directly or view it on GitHub.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2014-02-04T11:51:17Z",
        "body": "I'll investigate a way to fail the pool fast.  Likely it will be via a RuntimeException thrown from the constructor ... but will require that the minimum pool size is non-zero.\n"
      },
      {
        "user": "zimmi",
        "created_at": "2014-02-04T19:27:45Z",
        "body": "If you instantiate your DataSource programmatically, you could use the raw driver DataSource to do the getConnection() check. e.g.:\n\n```\nPGSimpleDataSource dataSource = new PGSimpleDataSource();\ndataSource.setUser(\"username\");\ndataSource.setPassword(\"password\");\n\n// check raw data source, e.g. dataSource.getConnection();\n\nHikariConfig config = new HikariConfig();\nconfig.setDataSource(dataSource);\n\nHikariDataSource connectionPool = new HikariDataSource(config);\n```\n\nBut I guess that won't help if you do this the declarative way.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2014-02-12T14:04:40Z",
        "body": "The recently released HikariCP 1.2.9 has a new property `initializationFailFast` that is not yet documented.  If you set this to `true`, there will be a `RuntimeException` thrown when a `HikariDataSource` is constructed, providing that the `minimumPoolSize` is > 0.\n"
      }
    ]
  }
]