[
  {
    "number": 1002,
    "title": "Still has the issue about creating Window in Sierra 10.12.4",
    "created_at": "2017-05-04T03:04:16Z",
    "closed_at": "2017-05-05T11:12:11Z",
    "labels": [
      "question",
      "macOS"
    ],
    "url": "https://github.com/glfw/glfw/issues/1002",
    "body": "Just run the simple code provided on the official site\r\n\r\nI have tried download the latest version from GitHub, and compiled locally, but seems still has the same problem. I run the code on Xcode:\r\n\r\n```\r\n#include <GLFW/glfw3.h>\r\n\r\nint main(void)\r\n{\r\n    GLFWwindow* window;\r\n    \r\n    /* Initialize the library */\r\n    if (!glfwInit())\r\n        return -1;\r\n    \r\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\r\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);\r\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\r\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\r\n    \r\n    /* Create a windowed mode window and its OpenGL context */\r\n    window = glfwCreateWindow(640, 480, \"Hello World\", NULL, NULL);\r\n    if (!window)\r\n    {\r\n        glfwTerminate();\r\n        return -1;\r\n    }\r\n    \r\n    /* Make the window's context current */\r\n    glfwMakeContextCurrent(window);\r\n    \r\n    /* Loop until the user closes the window */\r\n    while (!glfwWindowShouldClose(window))\r\n    {\r\n        /* Render here */\r\n        glClear(GL_COLOR_BUFFER_BIT);\r\n        \r\n        /* Swap front and back buffers */\r\n        glfwSwapBuffers(window);\r\n        \r\n        /* Poll for and process events */\r\n        glfwPollEvents();\r\n    }\r\n    \r\n    glfwTerminate();\r\n    return 0;\r\n}\r\n```\r\n\r\nThe results shows:\r\n```\r\n2017-05-03 19:52:39.874168-0700 learnOpenGL[5286:355180] [General] ERROR: Setting <GLFWContentView: 0x10060b640> as the first responder for window <GLFWWindow: 0x100418110>, but it is in a different window ((null))! This would eventually crash when the view is freed. The first responder will be set to nil.\r\n(\r\n\t0   AppKit                              0x00007fffa7d65a3f -[NSWindow _validateFirstResponder:] + 557\r\n\t1   AppKit                              0x00007fffa74e0b1c -[NSWindow _setFirstResponder:] + 31\r\n\t2   AppKit                              0x00007fffa7588d9e -[NSWindow _realMakeFirstResponder:] + 406\r\n\t3   AppKit                              0x00007fffa7588bb4 -[NSWindow makeFirstResponder:] + 123\r\n\t4   libglfw.3.dylib                     0x00000001000bd86e createNativeWindow + 1230\r\n\t5   libglfw.3.dylib                     0x00000001000bd14f _glfwPlatformCreateWindow + 63\r\n\t6   libglfw.3.dylib                     0x00000001000b59c7 glfwCreateWindow + 887\r\n\t7   learnOpenGL                         0x0000000100000e87 main + 135\r\n\t8   libdyld.dylib                       0x00007fffbf134235 start + 1\r\n)\r\n```",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/1002/comments",
    "author": "kesperado",
    "comments": [
      {
        "user": "kesperado",
        "created_at": "2017-05-04T05:14:17Z",
        "body": "I used glfwGetVersionString()\r\nand got:\r\n`3.2.1 Cocoa NSGL chdir menubar retina dynamic`\r\n\r\nI did downloaded the latest code from GitHub, and use cmake, make, and sudo make install to compile it. But why it is still 3.2.1? instead of 3.3 which seems possible to solve the problem"
      },
      {
        "user": "kesperado",
        "created_at": "2017-05-04T05:17:21Z",
        "body": "Would anyone please tell me how to compile the latest version from GitHub? I think I did missed some command"
      },
      {
        "user": "elmindreda",
        "created_at": "2017-05-04T11:29:47Z",
        "body": "If you didn't install GLFW 3.2.1 the same way as 3.3 then it may be in a another directory with a higher priority in the linker's list of directories. If you installed it with a package manager then uninstall it using that tool. If not, just search your system for anything `\"libglfw*\"`."
      },
      {
        "user": "kesperado",
        "created_at": "2017-05-05T02:21:36Z",
        "body": "Sorry I got it!\r\nI have fixed it!\r\nThanks a lot!"
      },
      {
        "user": "elmindreda",
        "created_at": "2017-05-05T11:12:11Z",
        "body": "@kesperado Yay! Closing this now then."
      }
    ]
  },
  {
    "number": 942,
    "title": "Support for UWP apps",
    "created_at": "2017-02-06T16:24:23Z",
    "closed_at": "2017-02-27T16:22:02Z",
    "labels": [
      "question",
      "Windows"
    ],
    "url": "https://github.com/glfw/glfw/issues/942",
    "body": "Hi. \r\nDoes GLFW support UWP apps (Windows 10 )?\r\nI tried to use precompiled glfw3dll.lib and get an error when trying to launch app (though it builds without errors)\r\n\r\n`The program 'App1.exe' has exited with code -1073741515 (0xc0000135) 'A dependent dll was not found'.`",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/942/comments",
    "author": "jboich",
    "comments": [
      {
        "user": "elmindreda",
        "created_at": "2017-02-06T17:04:37Z",
        "body": "GLFW does not currently support UWP. I believe UWP doesn't currently provide sane access to OpenGL or Vulkan."
      },
      {
        "user": "jboich",
        "created_at": "2017-02-06T17:07:27Z",
        "body": "ok. thanks for the quick response!"
      },
      {
        "user": "elmindreda",
        "created_at": "2017-02-07T15:58:23Z",
        "body": "What rendering API were you planning to use on UWP?"
      },
      {
        "user": "jboich",
        "created_at": "2017-02-07T16:05:07Z",
        "body": "We would like to use all basic API of OpenGL 3.2, 3.3 at least. We are also interested in having multiple render targets feature."
      },
      {
        "user": "elmindreda",
        "created_at": "2017-02-07T16:11:06Z",
        "body": "Right. As far as I know, Microsoft has not made that available on UWP."
      },
      {
        "user": "elmindreda",
        "created_at": "2017-02-07T16:14:16Z",
        "body": "For a similar library that does support WinRT/UWP, check out SDL2. You will need to use Microsoft rendering APIs or ANGLE, though."
      },
      {
        "user": "linkmauve",
        "created_at": "2017-02-07T16:24:42Z",
        "body": "If you limit yourself to GLES 2.0 or 3.0, wouldn’t it be transparent to use ANGLE’s libEGL and libGLESv2 with GLFW? (Note that I never tried this configuration, this is pure speculation.)"
      }
    ]
  },
  {
    "number": 929,
    "title": "mac port cmake find_package(glfw3 REQUIRED) does not init INCLUDE_DIR or LIBRARY_DIR variables",
    "created_at": "2017-01-06T03:21:04Z",
    "closed_at": "2017-01-06T13:48:36Z",
    "labels": [
      "question",
      "build"
    ],
    "url": "https://github.com/glfw/glfw/issues/929",
    "body": "I'm trying to use glfw3 3.2.1 and when I run the following cmake init it successfully finds the glfw3 package but does not seem to initialize the expected include or library variables.\r\n```\r\ncmake_minimum_required(VERSION 3.7)\r\nPROJECT(test)\r\nfind_package(glfw3 REQUIRED)\r\nADD_EXECUTABLE(test test.cpp)\r\n```\r\nRunning make leads to\r\n```\r\nfatal error: 'GLFW/glfw3.h' file not found\r\n```\r\nWhat am I missing?",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/929/comments",
    "author": "gentili",
    "comments": [
      {
        "user": "gentili",
        "created_at": "2017-01-06T03:23:16Z",
        "body": "OSX Sierra 10.12.2\r\nMacPorts 2.3.5\r\ncmake 3.7.1\r\nglfw3 3.2.1 "
      },
      {
        "user": "zao",
        "created_at": "2017-01-06T06:56:52Z",
        "body": "In short: `target_link_libraries(your_target PRIVATE glfw)`\r\n\r\nExported targets like the ones defined by the GLFW3 CMake files expose the include paths and the libraries to link as properties on the imported `glfw` target. In modern CMake, such things are defined on a per-target basis instead of polluting the scoped global compiler and linker parameters.\r\n\r\nAs a side note, `test` is a reserved target name by CMake, you should probably name your sample ones something less conflicting."
      },
      {
        "user": "gentili",
        "created_at": "2017-01-06T13:48:36Z",
        "body": "Worked like a charm.  I had tried target_link_libraries(thing glfw3) without success.\r\n\r\nSide note: Yes I just inserted 'test' in the example; it's not the actual project name.\r\n\r\nThank you very much for the assistance!"
      }
    ]
  },
  {
    "number": 761,
    "title": "dimensional sizes are not unsigned",
    "created_at": "2016-05-17T15:03:19Z",
    "closed_at": "2016-05-22T14:02:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/glfw/glfw/issues/761",
    "body": "I just wondered: attributes like window size, framebuffer size (width and height and possibly bit-depth) seem to be passed and returned as signed integers. Why would they? Attributes that describe a length can (at least should) never be negative, so why not represent it properly?\n",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/761/comments",
    "author": "salbeira",
    "comments": [
      {
        "user": "elmindreda",
        "created_at": "2016-05-17T19:20:56Z",
        "body": "They will be unsigned in 4.0, but it really makes very little difference in practice.\n"
      }
    ]
  },
  {
    "number": 759,
    "title": "GLFW_CURSOR_DISABLED produces large deltas",
    "created_at": "2016-05-11T21:51:22Z",
    "closed_at": "2016-05-12T06:56:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/glfw/glfw/issues/759",
    "body": "I am testing GLFW on an Ubuntu Desktop 16.04 LTS x64 on Oracle VirtualBox 5.0.20 with a Windows 7 x64 host.\n\nThere, when I use `glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);` the callback registered via `glfwSetCursorPosCallback` receives very large position deltas. For example, when I move the mouse only one pixel to the right, the xpos delta sometimes is -400.0, other times -110.0 and then sometimes even -1000.0, also somtimes positive and sometimes negative.\nI know that the xpos and ypos coordinates can have arbitrary large values since the mouse cursor is unrestricted. But I am talking about the delta (the changes between successive xpos and ypos values for successive calls of the callback). I am getting very large deltas here.\nOn Windows everything is fine. It's just weird on Ubuntu Desktop 16.04 LTS. I don't know whether it is a thing with Oracle VirtualBox.\n\nHere is the example app I use to test this:\n\n``` C\n#include <GLFW/glfw3.h>\n#include <stdlib.h>\n#include <stdio.h>\nstatic void error_callback(int error, const char* description) {\n    fprintf(stderr, \"Error: %s\\n\", description);\n}\nstatic void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods) {\n    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)\n        glfwSetWindowShouldClose(window, GLFW_TRUE);\n}\nstatic void cp_callback(GLFWwindow* window, double xpos, double ypos) {\n  fprintf(stderr, \"%f , %f\\n\", (float)xpos, (float)ypos);\n  fflush(stderr);\n}\nint main(void) {\n    GLFWwindow* window;\n    glfwSetErrorCallback(error_callback);\n    if (!glfwInit())\n        exit(EXIT_FAILURE);\n    window = glfwCreateWindow(640, 480, \"\", NULL, NULL);\n    if (!window) {\n        glfwTerminate();\n        exit(EXIT_FAILURE);\n    }\n    glfwSetKeyCallback(window, key_callback);\n    glfwSetCursorPosCallback(window, cp_callback);\n    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n    while (!glfwWindowShouldClose(window)) {\n        glfwPollEvents();\n    }\n    glfwDestroyWindow(window);\n    glfwTerminate();\n    exit(EXIT_SUCCESS);\n}\n```\n\nAnd here is the output I get from moving the mouse cursor very very slightly (should be just one pixel each) to the right:\n\n```\n639.000000 , 479.000000\n958.000000 , 479.000000\n1277.000000 , 479.000000\n1596.000000 , 479.000000\n1915.000000 , 479.000000\n2234.000000 , 479.000000\n2553.000000 , 479.000000\n2872.000000 , 479.000000\n3191.000000 , 479.000000\n3510.000000 , 479.000000\n```\n\nIn this run, the delta happens to be around +319.0'ish.\nI do not have a HighDPI monitor or HighDPI mouse.\n\nThe issue does not happen when using GLFW_CURSOR_HIDDEN or GLFW_CURSOR_NORMAL. In those two settings, I get correct pixel values.\n",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/759/comments",
    "author": "httpdigest",
    "comments": [
      {
        "user": "elmindreda",
        "created_at": "2016-05-11T22:47:36Z",
        "body": "Have you disabled cursor integration in VirtualBox?\n"
      },
      {
        "user": "httpdigest",
        "created_at": "2016-05-11T22:51:24Z",
        "body": "Hm... if, then not consciously (meaning: I don't know how to do that or what it is exactly :)). This is a very off the shelves installation with absolutely no customization of settings or stuff. The only thing I did was to install the Guest Additions which compiled and built successfully.\n\nEDIT: There is a little icon in the VirtualMachine status bar to the right bottom which says (translated) \"Mouse cursor integration (MI) is on/enabled\" with a little blue mouse and a green arrow on it.\n"
      },
      {
        "user": "httpdigest",
        "created_at": "2016-05-11T23:03:42Z",
        "body": "Interesting. When I disable mouse cursor integration (leaving that mouse in the status bar blue with a _yellow_ arrow) the readings of the cursor position are correct now.\nThe bad thing however now is that I do not see the mouse cursor anymore in the guest operating system. I mean, the mouse cursor is completely invisible (not just in the application). I also restarted the VM multiple times, but the cursor remains invisible.\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2016-05-12T00:28:06Z",
        "body": "This is not a bug, it's just GLFW and VirtualBox fighting over where the cursor should be. Leave cursor integration off while you're working with disabled cursor mode and it'll be fine.\n"
      },
      {
        "user": "httpdigest",
        "created_at": "2016-05-12T06:56:30Z",
        "body": "Thank you! Will do.\n"
      }
    ]
  },
  {
    "number": 625,
    "title": "glfwSetFramebufferSize",
    "created_at": "2015-10-27T12:51:58Z",
    "closed_at": "2016-04-04T11:16:55Z",
    "labels": [
      "question",
      "High DPI"
    ],
    "url": "https://github.com/glfw/glfw/issues/625",
    "body": "There is no glfwSetFramebufferSize but there is support for glfwSetWindowSize and the somewhat related glfwSetFramebufferSizeCallback.\n\nIs there a reason for this? My framework works with the size of back-buffers directly, not being able to directly set the frame buffer size is an issue for me.\n",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/625/comments",
    "author": "xanather",
    "comments": [
      {
        "user": "elmindreda",
        "created_at": "2015-10-27T18:04:04Z",
        "body": "The reason is that it's a tricky thing to do in a predictable way.\n\nOn OS X the ratio between window size and framebuffer size depends on which monitor the system considers your window to \"be on\". Resizing the window may shift the midpoint to another monitor and thus change the ratio. If we are talking about full screen, well, resolutions are listed in points, not pixels. The system also lists resolutions where pixels and points map 1:1 but doesn't provide any method to find out in advance which these are.\n\nOn Windows 8.1 and later the window and framebuffer sizes are 1:1 but the per-monitor DPI system suggests new window sizes also based on what monitor the window is considered to \"be on\".\n\nX11 is the only system I know where this would be a sane operation, but 1/5 doesn't make for a good GLFW function.\n"
      },
      {
        "user": "xanather",
        "created_at": "2015-10-28T05:46:39Z",
        "body": "Okay, thanks for that info. I guess I will just attempt to set the resolution with glfwSetWindowSize and notify the user if they got a resolution they didn't select for now.\n\nMaybe something will pop up in the future? Anyway I'll leave this issue open but feel free to close it.\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2015-10-28T12:23:49Z",
        "body": "Is this specifically about full screen or do you need a general solution?\n"
      },
      {
        "user": "xanather",
        "created_at": "2015-10-28T14:57:30Z",
        "body": "General solution. Its both for inside and outside full-screen. I allow users to set their resolution from within a settings panel from within the program.\n"
      },
      {
        "user": "xanather",
        "created_at": "2015-10-28T15:08:35Z",
        "body": "I really need an OS to properly test this on where screen coordinates != pixel coordinates, is there an option to somehow enable it on Ubuntu? I don't have any retina displays.\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2015-11-01T16:51:58Z",
        "body": "No, you need OS X for that.\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2016-04-04T11:17:31Z",
        "body": "I'm closing this but I'm aware of the problem and will keep a look out for a more user-friendly solution.\n"
      }
    ]
  },
  {
    "number": 557,
    "title": "Add an option to link against libepoxy",
    "created_at": "2015-07-16T20:30:27Z",
    "closed_at": "2015-07-28T15:06:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/glfw/glfw/pull/557",
    "body": "This allows glfw to defer the choice between libGL, libGLESv1_CM or libGLESv2 to runtime, while supporting every function and define from all three of those.\n",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/557/comments",
    "author": "linkmauve",
    "comments": [
      {
        "user": "elmindreda",
        "created_at": "2015-07-16T21:02:00Z",
        "body": "I'm currently moving that choice to runtime without external dependencies, as well as the choice between native and EGL.\n"
      },
      {
        "user": "linkmauve",
        "created_at": "2015-07-16T21:07:35Z",
        "body": "libepoxy also helps in supporting multiple versions of a same symbol by aliasing the *KHR, *ARB, *EXT, *NV, etc. version of a same symbol.\n\nBut if you already have that, I guess libepoxy support is superfluous, or at least not _that_ useful.\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2015-07-16T21:14:51Z",
        "body": "It does not, but libepoxy should be on top of GLFW, not the other way around.\n\n**Edit:** That doesn't mean it should _depend_ on GLFW, and considering the scope of its auto-detection it's the only loader that won't need to.\n"
      },
      {
        "user": "linkmauve",
        "created_at": "2015-07-16T21:47:37Z",
        "body": "The idea was to prevent libglfw.so from linking against libGL or libGLES*, as it still needs a library providing the various glGetInteger() or glGetString() and libepoxy is exactly that.\n\nI will use libepoxy in Citra to let the user select either GL or GLES, and it is currently doing weird things when using the one that glfw isn’t compiled against.\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2015-07-16T23:55:02Z",
        "body": "Yes, I understand, but GLFW must already know which library is appropriate or it won't be able to create contexts or provide `glfwExtensionSupported` and `glfwGetProcAddress`.\n\n**Edit:** The version of GLFW that does this dynamically won't have any link-time dependencies on client API libraries. It will load them very much like libepoxy does.\n"
      }
    ]
  },
  {
    "number": 552,
    "title": "Swap Interval cannot be increased with glfwSwapInterval(swap_interval);",
    "created_at": "2015-07-10T13:26:52Z",
    "closed_at": "2015-07-14T17:51:41Z",
    "labels": [
      "question",
      "Windows"
    ],
    "url": "https://github.com/glfw/glfw/issues/552",
    "body": "Win 8 x64: Once the swap interval is set to 0 it cannot be increased any more. I confirmed that with adding an FPS counter to the \"accuracy\" example ( but tested only with interval setting 0 and 1). Is this related to bug #1867804? I cannot find anything about such a bug.\n\nI Added these lines of code to accuracy.c:\n\n```\n// Top\nstatic int swap_interval = 1;\ndouble glfwTime = 0.0;\ndouble glfwFrame = 0.0;\nstatic char title[256];\n\nstatic void set_swap_interval(GLFWwindow* window, int interval)\n{\n    //char title[256];\n...\n\n// Bottom in main loop\n        glfwPollEvents();\n\n        glfwFrame = glfwTime;\n        glfwTime = glfwGetTime();\n        glfwFrame = glfwTime - glfwFrame;\n\n        sprintf(title, \"Cursor Inaccuracy Detector (Interval: %i, FPS: %f)\", swap_interval, 1.0/glfwFrame );\n        glfwSetWindowTitle(window, title);\n    }\n```\n\nNotice the title bar, even though the interval gets switched, the frame rate does not go back down to 60 fps.\n",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/552/comments",
    "author": "ParticlePeter",
    "comments": [
      {
        "user": "elmindreda",
        "created_at": "2015-07-10T15:41:19Z",
        "body": "The `tearing` test already does this.\n\nWhat GPU do you have?\n"
      },
      {
        "user": "ParticlePeter",
        "created_at": "2015-07-11T19:09:26Z",
        "body": "Yes, I noticed that right after my post, but github was too busy to let me correct it. Sorry for the delay.\nAt work I have a GeForce 970. Right know I don't know the vendor and driver version version, can tell on Monday. At home I use a Kaveri APU A7800, also Win8 x64, but there swap interval doesn't work at all, its allays maximum fps ( approx 4000 Hz with the tearing example ). I asked about the last one at the glfw IRC channel and was told that its most probably an usual driver bug, so I let it go. On my Kaveri I noticed this bug since the latest stable and the last two beta drivers ( currently Catalyst 14.502.1014.1001 ).\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2015-07-11T22:39:45Z",
        "body": "What version of GLFW are you using?\n\nOh, and that bug number is from ancient times when GLFW lived on SourceForge.\n"
      },
      {
        "user": "ParticlePeter",
        "created_at": "2015-07-14T08:38:23Z",
        "body": "Current master head on both machines. Sou you cannot reproduce this issue ?\nOne more question about the fps of the tearing example. Is the frame rate supposed to change with swap interval higher than 1 ? Anything higher than 1 is always 60 Hz. on the GTX ( when setting the value at compile time, tearing.c, line 173 ).\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2015-07-14T09:20:18Z",
        "body": "What about when setting it at run-time?\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2015-07-14T09:20:45Z",
        "body": "See if 3.1.1 works any different.\n"
      },
      {
        "user": "ParticlePeter",
        "created_at": "2015-07-14T10:31:29Z",
        "body": "Setting at runtime is basically my issue. By default the tearing.c swap interval is set to 0, and the fps are around 4000 Hz. Using up and down arrow does change the window title swap interval number but not the fps. Setting the value higher than 0 at compile time shows an fps pretty close to 60 Hz.. Once reduced to 0 at runtime the fps go up to 4000 and do not change anymore when using the arrow keys to increase the interval.\n"
      },
      {
        "user": "ParticlePeter",
        "created_at": "2015-07-14T10:43:02Z",
        "body": "Tested with 3.1.1 tag, same behavior. Tearing example swap interval is set to 0 by default. At runtime fps is again around 4000 Hz and does not change when using the space bar, but the interval number does. Setting the swap interval to 1 at compile time does display fps 60 Hz. Using the space bar to switch to 0 interval does change the fps to about 4000 Hz, and this does not change any more if setting back to an interval of 1.\nJust to clarify, the frame rate in the title bar is constantly updated, small fluctuations are visible, but there is no jump from around 4000 fps to 60 fps when interval is set from 0 to more than 0 at runtime.\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2015-07-14T12:14:52Z",
        "body": "What is the output of `glfwinfo -l`?\n"
      },
      {
        "user": "ParticlePeter",
        "created_at": "2015-07-14T13:55:44Z",
        "body": "I am back on master head. I can produce this for 3.1.1 if you like. Are you interested in all extensions? Guess WGL_EXT_swap_control is the interesting one.\nDon't know where the warning comes from, I am just building from source.\n\n```\n*** WARNING: GLFW version mismatch! ***\nGLFW header version: 3.1.2\nGLFW library version: 3.1.0\nGLFW library version string: \"3.1.0 Win32 WGL VisualC DLL\"\nOpenGL context version string: \"4.5.0 NVIDIA 353.06\"\nOpenGL context version parsed by GLFW: 4.5.0\nOpenGL context flags (0x00000000):\nOpenGL context flags parsed by GLFW:\nOpenGL profile mask (0x00000000): unknown\nOpenGL profile mask parsed by GLFW: compat\nOpenGL robustness strategy (0x00008261): none\nOpenGL robustness strategy parsed by GLFW: none\nOpenGL context renderer string: \"GeForce GTX 970/PCIe/SSE2\"\nOpenGL context vendor string: \"NVIDIA Corporation\"\nOpenGL context shading language version: \"4.50 NVIDIA\"\nFramebuffer:\n red: 8 green: 8 blue: 8 alpha: 8 depth: 24 stencil: 8\n samples: 0 sample buffers: 0\n accum red: 16 accum green: 16 accum blue: 16 accum alpha: 16 aux buffers: 4\nOpenGL context supported extensions:\nGL_AMD_multi_draw_indirect\nGL_AMD_seamless_cubemap_per_texture\nGL_AMD_vertex_shader_viewport_index\nGL_AMD_vertex_shader_layer\nGL_ARB_arrays_of_arrays\nGL_ARB_base_instance\nGL_ARB_bindless_texture\nGL_ARB_blend_func_extended\nGL_ARB_buffer_storage\nGL_ARB_clear_buffer_object\nGL_ARB_clear_texture\nGL_ARB_clip_control\nGL_ARB_color_buffer_float\nGL_ARB_compatibility\nGL_ARB_compressed_texture_pixel_storage\nGL_ARB_conservative_depth\nGL_ARB_compute_shader\nGL_ARB_compute_variable_group_size\nGL_ARB_conditional_render_inverted\nGL_ARB_copy_buffer\nGL_ARB_copy_image\nGL_ARB_cull_distance\nGL_ARB_debug_output\nGL_ARB_depth_buffer_float\nGL_ARB_depth_clamp\nGL_ARB_depth_texture\nGL_ARB_derivative_control\nGL_ARB_direct_state_access\nGL_ARB_draw_buffers\nGL_ARB_draw_buffers_blend\nGL_ARB_draw_indirect\nGL_ARB_draw_elements_base_vertex\nGL_ARB_draw_instanced\nGL_ARB_enhanced_layouts\nGL_ARB_ES2_compatibility\nGL_ARB_ES3_compatibility\nGL_ARB_ES3_1_compatibility\nGL_ARB_explicit_attrib_location\nGL_ARB_explicit_uniform_location\nGL_ARB_fragment_coord_conventions\nGL_ARB_fragment_layer_viewport\nGL_ARB_fragment_program\nGL_ARB_fragment_program_shadow\nGL_ARB_fragment_shader\nGL_ARB_framebuffer_no_attachments\nGL_ARB_framebuffer_object\nGL_ARB_framebuffer_sRGB\nGL_ARB_geometry_shader4\nGL_ARB_get_program_binary\nGL_ARB_get_texture_sub_image\nGL_ARB_gpu_shader5\nGL_ARB_gpu_shader_fp64\nGL_ARB_half_float_pixel\nGL_ARB_half_float_vertex\nGL_ARB_imaging\nGL_ARB_indirect_parameters\nGL_ARB_instanced_arrays\nGL_ARB_internalformat_query\nGL_ARB_internalformat_query2\nGL_NV_internalformat_sample_query\nGL_ARB_invalidate_subdata\nGL_ARB_map_buffer_alignment\nGL_ARB_map_buffer_range\nGL_ARB_multi_bind\nGL_ARB_multi_draw_indirect\nGL_ARB_multisample\nGL_ARB_multitexture\nGL_ARB_occlusion_query\nGL_ARB_occlusion_query2\nGL_ARB_pipeline_statistics_query\nGL_ARB_pixel_buffer_object\nGL_ARB_point_parameters\nGL_ARB_point_sprite\nGL_ARB_program_interface_query\nGL_ARB_provoking_vertex\nGL_ARB_robust_buffer_access_behavior\nGL_ARB_robustness\nGL_ARB_sample_shading\nGL_ARB_sampler_objects\nGL_ARB_seamless_cube_map\nGL_ARB_seamless_cubemap_per_texture\nGL_ARB_separate_shader_objects\nGL_ARB_shader_atomic_counters\nGL_ARB_shader_bit_encoding\nGL_ARB_shader_draw_parameters\nGL_ARB_shader_group_vote\nGL_ARB_shader_image_load_store\nGL_ARB_shader_image_size\nGL_ARB_shader_objects\nGL_ARB_shader_precision\nGL_ARB_query_buffer_object\nGL_ARB_shader_storage_buffer_object\nGL_ARB_shader_subroutine\nGL_ARB_shader_texture_image_samples\nGL_ARB_shader_texture_lod\nGL_ARB_shading_language_100\nGL_ARB_shading_language_420pack\nGL_ARB_shading_language_include\nGL_ARB_shading_language_packing\nGL_ARB_shadow\nGL_ARB_sparse_buffer\nGL_ARB_sparse_texture\nGL_ARB_stencil_texturing\nGL_ARB_sync\nGL_ARB_tessellation_shader\nGL_ARB_texture_barrier\nGL_ARB_texture_border_clamp\nGL_ARB_texture_buffer_object\nGL_ARB_texture_buffer_object_rgb32\nGL_ARB_texture_buffer_range\nGL_ARB_texture_compression\nGL_ARB_texture_compression_bptc\nGL_ARB_texture_compression_rgtc\nGL_ARB_texture_cube_map\nGL_ARB_texture_cube_map_array\nGL_ARB_texture_env_add\nGL_ARB_texture_env_combine\nGL_ARB_texture_env_crossbar\nGL_ARB_texture_env_dot3\nGL_ARB_texture_float\nGL_ARB_texture_gather\nGL_ARB_texture_mirror_clamp_to_edge\nGL_ARB_texture_mirrored_repeat\nGL_ARB_texture_multisample\nGL_ARB_texture_non_power_of_two\nGL_ARB_texture_query_levels\nGL_ARB_texture_query_lod\nGL_ARB_texture_rectangle\nGL_ARB_texture_rg\nGL_ARB_texture_rgb10_a2ui\nGL_ARB_texture_stencil8\nGL_ARB_texture_storage\nGL_ARB_texture_storage_multisample\nGL_ARB_texture_swizzle\nGL_ARB_texture_view\nGL_ARB_timer_query\nGL_ARB_transform_feedback2\nGL_ARB_transform_feedback3\nGL_ARB_transform_feedback_instanced\nGL_ARB_transform_feedback_overflow_query\nGL_ARB_transpose_matrix\nGL_ARB_uniform_buffer_object\nGL_ARB_vertex_array_bgra\nGL_ARB_vertex_array_object\nGL_ARB_vertex_attrib_64bit\nGL_ARB_vertex_attrib_binding\nGL_ARB_vertex_buffer_object\nGL_ARB_vertex_program\nGL_ARB_vertex_shader\nGL_ARB_vertex_type_10f_11f_11f_rev\nGL_ARB_vertex_type_2_10_10_10_rev\nGL_ARB_viewport_array\nGL_ARB_window_pos\nGL_ATI_draw_buffers\nGL_ATI_texture_float\nGL_ATI_texture_mirror_once\nGL_S3_s3tc\nGL_EXT_texture_env_add\nGL_EXT_abgr\nGL_EXT_bgra\nGL_EXT_bindable_uniform\nGL_EXT_blend_color\nGL_EXT_blend_equation_separate\nGL_EXT_blend_func_separate\nGL_EXT_blend_minmax\nGL_EXT_blend_subtract\nGL_EXT_compiled_vertex_array\nGL_EXT_Cg_shader\nGL_EXT_depth_bounds_test\nGL_EXT_direct_state_access\nGL_EXT_draw_buffers2\nGL_EXT_draw_instanced\nGL_EXT_draw_range_elements\nGL_EXT_fog_coord\nGL_EXT_framebuffer_blit\nGL_EXT_framebuffer_multisample\nGL_EXTX_framebuffer_mixed_formats\nGL_EXT_framebuffer_multisample_blit_scaled\nGL_EXT_framebuffer_object\nGL_EXT_framebuffer_sRGB\nGL_EXT_geometry_shader4\nGL_EXT_gpu_program_parameters\nGL_EXT_gpu_shader4\nGL_EXT_multi_draw_arrays\nGL_EXT_packed_depth_stencil\nGL_EXT_packed_float\nGL_EXT_packed_pixels\nGL_EXT_pixel_buffer_object\nGL_EXT_point_parameters\nGL_EXT_polygon_offset_clamp\nGL_EXT_post_depth_coverage\nGL_EXT_provoking_vertex\nGL_EXT_raster_multisample\nGL_EXT_rescale_normal\nGL_EXT_secondary_color\nGL_EXT_separate_shader_objects\nGL_EXT_separate_specular_color\nGL_EXT_shader_image_load_formatted\nGL_EXT_shader_image_load_store\nGL_EXT_shader_integer_mix\nGL_EXT_shadow_funcs\nGL_EXT_sparse_texture2\nGL_EXT_stencil_two_side\nGL_EXT_stencil_wrap\nGL_EXT_texture3D\nGL_EXT_texture_array\nGL_EXT_texture_buffer_object\nGL_EXT_texture_compression_dxt1\nGL_EXT_texture_compression_latc\nGL_EXT_texture_compression_rgtc\nGL_EXT_texture_compression_s3tc\nGL_EXT_texture_cube_map\nGL_EXT_texture_edge_clamp\nGL_EXT_texture_env_combine\nGL_EXT_texture_env_dot3\nGL_EXT_texture_filter_anisotropic\nGL_EXT_texture_filter_minmax\nGL_EXT_texture_integer\nGL_EXT_texture_lod\nGL_EXT_texture_lod_bias\nGL_EXT_texture_mirror_clamp\nGL_EXT_texture_object\nGL_EXT_texture_shared_exponent\nGL_EXT_texture_sRGB\nGL_EXT_texture_sRGB_decode\nGL_EXT_texture_storage\nGL_EXT_texture_swizzle\nGL_EXT_timer_query\nGL_EXT_transform_feedback2\nGL_EXT_vertex_array\nGL_EXT_vertex_array_bgra\nGL_EXT_vertex_attrib_64bit\nGL_EXT_import_sync_object\nGL_IBM_rasterpos_clip\nGL_IBM_texture_mirrored_repeat\nGL_KHR_context_flush_control\nGL_KHR_debug\nGL_KHR_robust_buffer_access_behavior\nGL_KHR_robustness\nGL_KTX_buffer_region\nGL_NV_bindless_multi_draw_indirect\nGL_NV_bindless_multi_draw_indirect_count\nGL_NV_bindless_texture\nGL_NV_blend_equation_advanced\nGL_NV_blend_equation_advanced_coherent\nGL_NV_blend_square\nGL_NV_command_list\nGL_NV_compute_program5\nGL_NV_conditional_render\nGL_NV_conservative_raster\nGL_NV_conservative_raster_dilate\nGL_NV_copy_depth_to_color\nGL_NV_copy_image\nGL_NV_depth_buffer_float\nGL_NV_depth_clamp\nGL_NV_draw_texture\nGL_NV_ES1_1_compatibility\nGL_NV_ES3_1_compatibility\nGL_NV_explicit_multisample\nGL_NV_fence\nGL_NV_fill_rectangle\nGL_NV_float_buffer\nGL_NV_fog_distance\nGL_NV_fragment_coverage_to_color\nGL_NV_fragment_program\nGL_NV_fragment_program_option\nGL_NV_fragment_program2\nGL_NV_fragment_shader_interlock\nGL_NV_framebuffer_mixed_samples\nGL_NV_framebuffer_multisample_coverage\nGL_NV_geometry_shader4\nGL_NV_geometry_shader_passthrough\nGL_NV_gpu_program4\nGL_NV_gpu_program4_1\nGL_NV_gpu_program5\nGL_NV_gpu_program5_mem_extended\nGL_NV_gpu_program_fp64\nGL_NV_gpu_shader5\nGL_NV_half_float\nGL_NV_light_max_exponent\nGL_NV_multisample_coverage\nGL_NV_multisample_filter_hint\nGL_NV_occlusion_query\nGL_NV_packed_depth_stencil\nGL_NV_parameter_buffer_object\nGL_NV_parameter_buffer_object2\nGL_NV_path_rendering\nGL_NV_path_rendering_shared_edge\nGL_NV_pixel_data_range\nGL_NV_point_sprite\nGL_NV_primitive_restart\nGL_NV_register_combiners\nGL_NV_register_combiners2\nGL_NV_sample_locations\nGL_NV_sample_mask_override_coverage\nGL_NV_shader_atomic_counters\nGL_NV_shader_atomic_float\nGL_NV_shader_atomic_fp16_vector\nGL_NV_shader_atomic_int64\nGL_NV_shader_buffer_load\nGL_NV_shader_storage_buffer_object\nGL_NV_texgen_reflection\nGL_NV_texture_barrier\nGL_NV_texture_compression_vtc\nGL_NV_texture_env_combine4\nGL_NV_texture_multisample\nGL_NV_texture_rectangle\nGL_NV_texture_shader\nGL_NV_texture_shader2\nGL_NV_texture_shader3\nGL_NV_transform_feedback\nGL_NV_transform_feedback2\nGL_NV_uniform_buffer_unified_memory\nGL_NV_vertex_array_range\nGL_NV_vertex_array_range2\nGL_NV_vertex_attrib_integer_64bit\nGL_NV_vertex_buffer_unified_memory\nGL_NV_vertex_program\nGL_NV_vertex_program1_1\nGL_NV_vertex_program2\nGL_NV_vertex_program2_option\nGL_NV_vertex_program3\nGL_NV_viewport_array2\nGL_NVX_conditional_render\nGL_NVX_gpu_memory_info\nGL_NVX_nvenc_interop\nGL_NV_shader_thread_group\nGL_NV_shader_thread_shuffle\nGL_KHR_blend_equation_advanced\nGL_KHR_blend_equation_advanced_coherent\nGL_SGIS_generate_mipmap\nGL_SGIS_texture_lod\nGL_SGIX_depth_texture\nGL_SGIX_shadow\nGL_SUN_slice_accum\nGL_WIN_swap_hint\nWGL_EXT_swap_control\n```\n"
      },
      {
        "user": "ParticlePeter",
        "created_at": "2015-07-14T14:41:16Z",
        "body": "I have to apologize, there is no issue, it was my fault. I had the 3.1 binary download glfw.dll in my path, and the examples were using this one instead of the freshly build. The tearing test now works correctly.\nInterval 0: 4000 fps\nInterval 1: 60 fps\nInterval 2: 30 fps\netc.\n\nIt is possible to use the up and down arrows down to zero and up again.\nI am really sorry for any headache I might have produced. \n"
      },
      {
        "user": "elmindreda",
        "created_at": "2015-07-14T17:51:29Z",
        "body": "I'm glad this was sorted out.\n\nYou can see `glfwinfo` warning about a library/header mismatch in the output above.\n"
      },
      {
        "user": "ParticlePeter",
        "created_at": "2015-07-14T18:08:01Z",
        "body": "Lesson learned, will keep that in mind. Never tried glfwinfo but see its benefit now.\n"
      }
    ]
  },
  {
    "number": 535,
    "title": "key codes on non-us keyboards",
    "created_at": "2015-06-19T08:14:30Z",
    "closed_at": "2015-06-28T18:09:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/glfw/glfw/issues/535",
    "body": "Not sure if this is new to glfw3, but I'm getting reports that the key codes no longer map to correct keys on non-us keyboards. The keyboard docs confirm this, but this is different from glfw2, isn't it?\n\nHow do I deal with this? My game framework needs to send key codes to apps in glfw2 (ie: 'localized') format, but there doesn't seem to be an easy way to do this.\n\nedit: OK, I'm not sure glfw2 didn't do this too now, but I still need a way to work out the key hit.\n",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/535/comments",
    "author": "blitz-research",
    "comments": [
      {
        "user": "elmindreda",
        "created_at": "2015-06-19T12:08:44Z",
        "body": "See #464.\n"
      }
    ]
  },
  {
    "number": 515,
    "title": "Q: GLFW CMake version",
    "created_at": "2015-05-15T15:32:02Z",
    "closed_at": "2015-05-15T16:11:45Z",
    "labels": [
      "question",
      "build"
    ],
    "url": "https://github.com/glfw/glfw/issues/515",
    "body": "Recently my Travis CI builds that use GLFW broke because of a CMake version requirement bump:\n\n```\nCMake Error at CMakeLists.txt:3 (cmake_minimum_required):\n  CMake 2.8.12 or higher is required.  You are running version 2.8.11.2\n```\n\nWould it be possible to relax this restriction? It makes builds not work on Ubuntu 12.04 LTS. If not, I can go to using a commit number before the CMake change, but that's not ideal.\n",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/515/comments",
    "author": "larsoner",
    "comments": [
      {
        "user": "elmindreda",
        "created_at": "2015-05-15T15:42:48Z",
        "body": "Yep, I know I broke Travis builds for the moment but I cannot wait any longer. 2.8.12 brought important features that I'll be using in the coming weeks. The current version is 3.2.2, so it's not exactly bleeding edge. That Travis runs such ancient software is frankly on them at this point.\n\nThere are also rumors (travis-ci/travis-ci#3480) that there's a PPA that might work while we wait for them to update to 14.04. When time permits I'll push a container-based Travis setup to master.\n"
      },
      {
        "user": "larsoner",
        "created_at": "2015-05-15T15:47:56Z",
        "body": "Fair enough, we'll use an older commit for the time being. Thanks for the quick response (and of course the great software!).\n"
      }
    ]
  },
  {
    "number": 357,
    "title": "When clik left button of mouse，will call KeyCallback GLFW_KEY_C",
    "created_at": "2014-09-28T09:23:42Z",
    "closed_at": "2014-09-29T09:06:22Z",
    "labels": [
      "question",
      "Windows"
    ],
    "url": "https://github.com/glfw/glfw/issues/357",
    "body": "when i clik  left button of mouse on the window in some area ,it will call KeyCallback GLFW_KEY_C, and the action is GLFW_PRESS or GLFW_RELEASE.  and i test other keys, it did not appeared\n",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/357/comments",
    "author": "cwq",
    "comments": [
      {
        "user": "elmindreda",
        "created_at": "2014-09-28T10:57:53Z",
        "body": "What version of GLFW are you using, on what platform?\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2014-09-28T11:01:20Z",
        "body": "Also, are any of the mods bits set?\n"
      },
      {
        "user": "cwq",
        "created_at": "2014-09-29T02:06:58Z",
        "body": "i am sorry, i did not save the code yesterday. i use glfw-3.0.4.bin.WIN32.zip, and glew to use opengl,  create window 1024x768, glfwSetMouseButtonCallback and glfwSetKeyCallback. the bug appeared yesterday, but it do not reappear (i try to write the code like yesterday)!!!  mabey some state cause this situation. so i am very sorry. \n"
      }
    ]
  },
  {
    "number": 298,
    "title": "GLFWimage const correctness",
    "created_at": "2014-05-21T21:07:17Z",
    "closed_at": "2014-05-25T08:44:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/glfw/glfw/issues/298",
    "body": "Could the member pixels be marked as const? \n\n`const unsigned char* pixels;` instead of `unsigned char* pixels;`\n",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/298/comments",
    "author": "BryceMehring",
    "comments": [
      {
        "user": "elmindreda",
        "created_at": "2014-05-22T01:15:34Z",
        "body": "It could, but then you'd have to cast away the const whenever you wanted to write a pixel or free the buffer.\n"
      }
    ]
  },
  {
    "number": 150,
    "title": "Cursor position callback stops working",
    "created_at": "2013-10-04T22:10:44Z",
    "closed_at": "2013-10-10T17:08:10Z",
    "labels": [
      "question",
      "Windows"
    ],
    "url": "https://github.com/glfw/glfw/issues/150",
    "body": "The way I reproduce this is to create two windows. Then close one. The focus goes to the other window, but the CursorPosCallback is not working, while other callbacks like mouse button and the keyboard are working fine.\n",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/150/comments",
    "author": "mariojmartin",
    "comments": [
      {
        "user": "elmindreda",
        "created_at": "2013-10-05T18:48:44Z",
        "body": "Which operating system is this on?\n"
      },
      {
        "user": "mariojmartin",
        "created_at": "2013-10-07T18:31:10Z",
        "body": "I am using Windows 7\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2013-10-07T19:56:49Z",
        "body": "Unable to reproduce on Windows 7.\n"
      },
      {
        "user": "mariojmartin",
        "created_at": "2013-10-08T06:35:09Z",
        "body": "Give me a couple of days and I try to make a small code that reproduce the problem.\n"
      },
      {
        "user": "mariojmartin",
        "created_at": "2013-10-10T16:21:47Z",
        "body": "You are right. I have tested with this example and it seems ok. Probably I am meshing somewhere in my code trying to identify the window in the callback.\n\n```\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <chrono>\n#include <string.h>\n#include <stdio.h>\n\n#include \"GLFW/glfw3.h\"\n\n#define MAX_NUMBER_WINDOWS 8\n#define OPEN_WINDOW 1\n#define CLOSE_WINDOW 2\n#define FREEZE_WINDOW 3\n#define FRAMERATE_MILISECONDS 20\n\nstruct WindowHandler\n{\n    GLFWwindow* window;\n    int left_mouse_is_pressed;\n    int status;\n};\n\nWindowHandler g_window_handler[MAX_NUMBER_WINDOWS] = {{NULL, 0, 0}};\n\nstatic int getWindow( GLFWwindow* window )\n{\n    for (int i = 0; i < MAX_NUMBER_WINDOWS; i++){\n        if (window == g_window_handler[i].window){\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n/* GLFW error callback, when an error is reported */\nstatic void error_callback( int error, const char* description )\n{\n    printf( \"%s\\n\", description );\n}\n\n\n/* Callback that is triggered everytime the keyboard inputs */\nstatic void callback_keyboard( GLFWwindow* window, int key, int scancode, int action, int mods )\n{\n    const int window_number = getWindow( window );\n    if (window_number < 0){\n        return;\n    }\n\n    printf(\"%i KEYCALL\\n\", window_number);\n}\n\n\n/* Called everytime the window resizes */\nstatic void callback_mouse_move( GLFWwindow* window, double xpos, double ypos )\n{\n    const int window_number = getWindow( window );\n    if (window_number < 0){\n        return;\n    }\n\n    if (g_window_handler[window_number].left_mouse_is_pressed == 1){\n        printf(\"%i MOUSE_MOVE\\n\", window_number);\n    }\n}\n\n\n/* Called everytime the window resizes */\nstatic void callback_mouse_button( GLFWwindow* window, int button, int action, int mods )\n{\n    const int window_number = getWindow( window );\n    if (window_number < 0){\n        return;\n    }\n\n    printf(\"%i MOUSE_BUTTON\\n\", window_number);\n\n    if (button == GLFW_MOUSE_BUTTON_LEFT){\n        if (action == GLFW_PRESS){\n            g_window_handler[window_number].left_mouse_is_pressed = 1;\n        }\n        else{\n            g_window_handler[window_number].left_mouse_is_pressed = 0;\n        }\n    }\n}\n\n\nstatic void callback_refresh( GLFWwindow* window )\n{\n    const int window_number = getWindow( window );\n    if (window_number < 0){\n        return;\n    }\n\n    printf(\"%i REFRESH\\n\", window_number);\n}\n\n\nstatic void callback_minimized( GLFWwindow* window, int iconified )\n{\n    const int window_number = getWindow( window );\n    if (window_number < 0){\n        return;\n    }\n\n    printf(\"%i ICONIFY\\n\", window_number);\n\n    if (iconified == GL_TRUE){\n        g_window_handler[window_number].status = FREEZE_WINDOW;\n    }\n    else{\n        g_window_handler[window_number].status = 0;\n    }\n}\n\n\nstatic GLFWwindow* create_window( const int window_number )\n{\n    /* Create the render context */\n    char title[32];\n    sprintf( title, \"Window %i\", window_number );\n    GLFWwindow* window = glfwCreateWindow(640, 640, title, NULL, NULL);\n\n    if ( window == NULL ){\n        return NULL;\n    }\n\n    glfwMakeContextCurrent( window );\n\n    glfwSetKeyCallback( window, callback_keyboard );\n    glfwSetCursorPosCallback( window, callback_mouse_move );\n    glfwSetMouseButtonCallback( window, callback_mouse_button );\n    glfwSetWindowIconifyCallback( window, callback_minimized );\n    glfwSetWindowRefreshCallback( window, callback_refresh );\n\n    return window;\n}\n\n\nstatic void ow_glfw_render_loop()\n{\n    std::mutex mutex;\n\n    glfwSetErrorCallback(error_callback);\n\n    if (glfwInit() == GL_FALSE){\n        return;\n    }\n\n    while(1)\n    {\n        clock_t start_clock = clock();\n\n        for (int slot = 0; slot < MAX_NUMBER_WINDOWS; slot++)\n        {\n            WindowHandler* handler = &(g_window_handler[slot]);\n\n            if (handler->status == OPEN_WINDOW){\n                /* Creates a new render context */ \n                mutex.lock();\n                handler->window = create_window( slot );\n                handler->status = 0;\n                mutex.unlock();\n            }\n\n            if (handler->status == CLOSE_WINDOW)\n            {\n                /* Destroys the render context */\n                mutex.lock();\n                glfwDestroyWindow( handler->window );\n                handler->window = NULL;\n                handler->status = 0;\n                mutex.unlock();\n            }\n\n            if (handler->window != NULL && handler->status == 0)\n            {\n                glfwMakeContextCurrent( handler->window );\n\n                /* Display goes here */\n\n                glfwSwapBuffers( handler->window );\n\n                if (glfwWindowShouldClose( handler->window ) == GL_TRUE){\n                    mutex.lock();\n                    handler->status = CLOSE_WINDOW;\n                    mutex.unlock();\n                }\n            }\n        }\n\n        glfwPollEvents();\n\n        clock_t end_clock = clock();\n        clock_t sleep_time = FRAMERATE_MILISECONDS \n            + ((start_clock - end_clock)* 1000)/CLOCKS_PER_SEC;\n\n        if (sleep_time > 0){\n            std::this_thread::sleep_for\n                ( std::chrono::milliseconds( sleep_time ));\n        }\n    }\n\n    glfwTerminate();\n}\n\n\nint main(int argc, char *argv[])\n{\n    /* Launch the main loop in a thread */\n    std::thread render_thread_loop(ow_glfw_render_loop);\n    render_thread_loop.detach();\n\n    std::mutex mutex;\n    mutex.lock();\n    g_window_handler[0].status = OPEN_WINDOW;\n    mutex.unlock();\n\n    mutex.lock();\n    g_window_handler[1].status = OPEN_WINDOW;\n    mutex.unlock();\n\n    mutex.lock();\n    g_window_handler[2].status = OPEN_WINDOW;\n    mutex.unlock();\n\n    getchar();\n}\n\n```\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2013-10-10T17:08:10Z",
        "body": "All right. Thanks for following up on it.\n"
      }
    ]
  },
  {
    "number": 148,
    "title": "glfwSwapInterval disabled on systems using DWM",
    "created_at": "2013-10-03T20:03:28Z",
    "closed_at": "2013-10-07T14:15:12Z",
    "labels": [
      "question",
      "Windows"
    ],
    "url": "https://github.com/glfw/glfw/issues/148",
    "body": "Using the function doesn't work in any way, even going fullscreen and/or setting the fullscreen refresh rate hint. So i tried to swap its call, for example, in the simple.c test, with (after the call to ):\n\n```\n//glfwSwapInterval(1);\n\nGLenum err = glewInit();\nif (GLEW_OK != err) {\n    exit( 1 ); // error\n};\n\nwglSwapIntervalEXT(1);\n```\n\nand now it works, in windowed and fullscreen mode without having to set any hint or else. My settings:\n\nGLFW 3.0.3 \nWindows 7 64bit\nRadeon 7850 with Catalyst 13.9\n32 bit compilation\n",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/148/comments",
    "author": "elvencode",
    "comments": [
      {
        "user": "elmindreda",
        "created_at": "2013-10-04T11:09:16Z",
        "body": "Swap interval was disabled on Windows systems using DWM (Aero), as on some of those systems it led to severe jitter. You can disable this test by setting the CMake option `GLFW_USE_DWM_SWAP_INTERVAL`.\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2015-05-21T23:47:49Z",
        "body": "This has received what may be a more appropriate fix with 8309e0ecb09fe5cf670dff5df1e7ca71821c27bd.\n"
      }
    ]
  },
  {
    "number": 122,
    "title": "Swap interval ignored by default on DWM",
    "created_at": "2013-09-01T15:27:34Z",
    "closed_at": "2013-09-19T20:25:06Z",
    "labels": [
      "question",
      "Windows"
    ],
    "url": "https://github.com/glfw/glfw/issues/122",
    "body": "Without calling glfwSwapInterval at all, vsync is enabled by default and attempting to disable vsync via glfwSwapInterval(0) does nothing. \n\nI was able to build GLFW with GLFW_USE_DWM_SWAP_INTERVAL set, and glfwSwapInterval(0) worked as expected. \n\nThis seems counter intuitive. I would expect the default behavior to honor the call to glfwSwapInterval. \n\nPerhaps (wgl_context.c:600)\n\n``` c\n#if !defined(_GLFW_USE_DWM_SWAP_INTERVAL)\n```\n\nShould actually be\n\n``` c\n#if defined(_GLFW_USE_DWM_SWAP_INTERVAL)\n```\n\nWin7 64bit\nNvidia GeForce GTX 560\nDriver version: 311.06\n",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/122/comments",
    "author": "aloucks",
    "comments": [
      {
        "user": "elmindreda",
        "created_at": "2013-09-01T18:31:01Z",
        "body": "I hadn't thought of that interpretation. Poor choice of name on my part. The name is meant as \"use swap interval _even on_ DWM\".\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2013-09-19T20:25:06Z",
        "body": "This has been addressed with 6af51e049f243fa0abcc0c94382f4b971cdf4bd0.\n"
      }
    ]
  },
  {
    "number": 104,
    "title": "OpenCL shared context support",
    "created_at": "2013-07-27T01:26:57Z",
    "closed_at": "2013-07-30T18:32:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/glfw/glfw/issues/104",
    "body": "Currently, no method exists for creating an OpenGL/CL shared context in a cross platform fashion without using glfw3native.h.  Are there plans to include this?\n",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/104/comments",
    "author": "Outurnate",
    "comments": [
      {
        "user": "mourogurt",
        "created_at": "2013-07-27T16:16:12Z",
        "body": "firstly load platforms and devices \nthen create window\nafter that\n#ifdef **linux**\n        cl_context_properties properties[] = { \n            CL_GL_CONTEXT_KHR, (cl_context_properties) glXGetCurrentContext(),\n            CL_GLX_DISPLAY_KHR, (cl_context_properties) glXGetCurrentDisplay(), \n            CL_CONTEXT_PLATFORM, (cl_context_properties) platform, \n        0};\n    #elif defined _WIN32\n        cl_context_properties properties[] = {\n            CL_GL_CONTEXT_KHR, (cl_context_properties) wglGetCurrentContext(), \n            CL_WGL_HDC_KHR, (cl_context_properties) wglGetCurrentDC(), \n            CL_CONTEXT_PLATFORM, (cl_context_properties) platform, \n        0};\n    #elif defined TARGET_OS_MAC\n        CGLContextObj glContext = CGLGetCurrentContext();\n        CGLShareGroupObj shareGroup = CGLGetShareGroup(glContext);\n        cl_context_properties properties[] = {\n            CL_CONTEXT_PROPERTY_USE_CGL_SHAREGROUP_APPLE,\n            (cl_context_properties)shareGroup,\n        0};\n    #endif\n\ncontext = clCreateContext(properties,numDevices,devices,func,usr_data,&err);\n"
      },
      {
        "user": "Outurnate",
        "created_at": "2013-07-27T18:21:41Z",
        "body": "I'm aware of this method, however, I was inquiring as to whether there would be a set of built in functions, similar to the window hint system, that could be used to easily define a shared context\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2013-07-30T13:05:28Z",
        "body": "There are no current plans, as it would tie the GLFW library to OpenCL.\n"
      },
      {
        "user": "Outurnate",
        "created_at": "2013-07-30T18:32:12Z",
        "body": "Ok, good to know.\n"
      }
    ]
  },
  {
    "number": 79,
    "title": "Swap interval sporadically ignored for covered windows",
    "created_at": "2013-07-01T12:22:33Z",
    "closed_at": "2013-07-30T13:15:40Z",
    "labels": [
      "question",
      "macOS"
    ],
    "url": "https://github.com/glfw/glfw/issues/79",
    "body": "When a GLFW window is minimised, or if a window is moved over it, my draw loop is no longer sync blocked, indicating that the swap interval is no longer being used.\n\nThis does not _always_ happen when the window is covered. Oddly, if the GLFW window is covered by a Google Chrome window, the swap interval is honoured.\n\nThis is my draw loop:\n\n```\ndouble last = glfwGetTime(), now, delta;\n\ndo { \n\n    glfwSwapBuffers( _win );\n    glfwPollEvents();\n\n    now   = glfwGetTime();\n    delta =    now - last;\n    last  =           now;\n\n} \nwhile( glfwGetKey( _win, GLFW_KEY_ESCAPE ) != GLFW_PRESS && \n       !glfwWindowShouldClose( _win )\n     );\n```\n\nWhen the window is in view, the process takes about 0.9% CPU load, but when covered, this shoots up to 60%.\n\nSystem: OS X 10.8.4, Macbook Pro 13\" Late 2011, Intel HD 3000, i7 @ 2.8GHz (2 Cores).\n",
    "comments_url": "https://api.github.com/repos/glfw/glfw/issues/79/comments",
    "author": "amnn",
    "comments": [
      {
        "user": "elmindreda",
        "created_at": "2013-07-04T10:53:58Z",
        "body": "I have no idea what GLFW can do about this. The implementation of `glfwSwapInterval` on all platforms is simply a call to the system-specific swap interval function. The actual implementation is within the OS and/or the driver.\n"
      },
      {
        "user": "amnn",
        "created_at": "2013-07-04T11:02:41Z",
        "body": "Mmm, it does seem to be quite odd behaviour though. One would expect the swap interval to increase, not decrease for a covered or minimised window.\n"
      },
      {
        "user": "elmindreda",
        "created_at": "2013-07-04T11:10:22Z",
        "body": "My _guess_ is it's window system logic; it tries to figure out on which monitor the window is visible (to know which beam to sync to), but the visibility function says it isn't visible on any monitor, so the window system just gives up and lets the application run wild.\n"
      }
    ]
  }
]