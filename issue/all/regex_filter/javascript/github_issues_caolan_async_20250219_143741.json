[
  {
    "number": 2012,
    "title": "The async auto function behaves oddly when wrapped in try/catch/finally",
    "created_at": "2025-01-11T14:34:04Z",
    "closed_at": "2025-01-11T22:56:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/2012",
    "body": "I'm using async version 3.2.4 in node version 20.12.1. There's no compiler in my tool chain.\r\n\r\n```js\r\n// below code applies two approaches to running async.auto, the first in plain and the second wrapped in try/catch/finally\r\n\r\n// the first approach runs as expected, both with and without injecting an error in the handler\r\n\r\n// the intend of the second approach is to catch all unhandled handler errors and pass them thru the callback\r\n// when injecting an error for keys a or b, the second approach seems to work well, it catches and passes the error well\r\n// when injecting an error for keys c, d, or e, the second approach fails, it hits finally first and throws an uncaught error later\r\n// I expected the same behavior for error injections on all keys a, b, c, d, and e, to be caught BEFORE finally.\r\n\r\nconst async = require('async');\r\n\r\nfunction handler(key, value, next) {\r\n    console.log(`${new Date()}`.substring(16, 24), key);\r\n    if (key == 'c') throw new Error('injected error') // try injecting error for all of keys a, b, c, d, and e\r\n    setTimeout(() => next(null, value), 1000);\r\n}\r\n\r\nconst work = {\r\n    a: function(next) {\r\n        handler('a', 1, next);\r\n    },\r\n    b: function(next) {\r\n        handler('b', 2, next);\r\n    },\r\n    c: [ 'a', 'b', function(results, next) {\r\n        handler('c', 3, next);\r\n    }],\r\n    d: [ 'c', function(results, next) {\r\n        handler('d', 4, next);\r\n    }],\r\n    e: [ 'c', function(results, next) {\r\n        handler('e', 5, next);\r\n    }],\r\n}\r\n\r\nif (false) { // approach 1 without try/catch/finally\r\n    async.auto(work, function(err, res) {\r\n        console.log('DONE 1', err, res);\r\n    });\r\n} else { // approach 2 with try/catch/finally\r\n    let _err;\r\n    let _res;\r\n    try {\r\n        async.auto(work, function(err, res) {\r\n            _err = err;\r\n            _res = res;\r\n        });\r\n    } catch(err) {\r\n        _err = err;\r\n    } finally {\r\n        console.log('DONE 2', _err, _res); \r\n    }\r\n}\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/2012/comments",
    "author": "pjbrinck",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2025-01-11T22:56:38Z",
        "body": "You are running into the limitations of `try`/`catch` and callback-based async tasks.  `try`/`catch` can only catch errors thrown on the same tick of the event loop.  When you throw an error for tasks a and b, those happen to be the same tick.  When it is thrown on task c, it is a later tick due to the `setTimeout`.  That cannot be caught by the try/catch.  It's recommended to not throw errors with callback-based async.\r\n\r\nYou can only catch async errors in this manner if you are using `async`/`await`, rather than callbacks.  It will convert a thrown error into a rejected promise and handle it properly with try/catch if the task is `await`ed. `async.auto` supports using `async` functions for tasks, and can be `await`able if a final callback is omitted."
      }
    ]
  },
  {
    "number": 1816,
    "title": "what time should i to use this?",
    "created_at": "2022-02-05T14:08:53Z",
    "closed_at": "2022-02-21T03:05:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1816",
    "body": "<!--\r\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\r\n-->\r\n\r\n**What version of async are you using?**\r\n\r\n**Which environment did the issue occur in (Node/browser/Babel/Typescript version)**\r\n\r\n**What did you do? Please include a minimal reproducible case illustrating issue.**\r\n\r\n**What did you expect to happen?**\r\n\r\n**What was the actual result?**\r\n\r\nThe JavaScript is support async/await/promise now.Sometimes,i don't know what time should i to use this library.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1816/comments",
    "author": "chenbimo",
    "comments": [
      {
        "user": "Peroconino",
        "created_at": "2022-02-16T12:52:33Z",
        "body": "Thats something that i would like to know too."
      },
      {
        "user": "aearly",
        "created_at": "2022-02-20T04:22:39Z",
        "body": "This library was built for a different time, and I will admit that most of the control flow methods are pretty obsolete: `waterfall`, `parallel`, `series`, etc...  `auto` and `queue` have their uses, especially the concurrency-limiting features.  The collection methods can be useful, though, since they work with both callbacks and `async` functions (and they also have limit features)."
      },
      {
        "user": "chenbimo",
        "created_at": "2022-02-21T03:05:39Z",
        "body": "> \r\n\r\nthinks a lot!very useful answer for me."
      }
    ]
  },
  {
    "number": 1778,
    "title": "async.queue sometime not end task",
    "created_at": "2021-12-09T10:28:42Z",
    "closed_at": "2022-01-28T20:58:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1778",
    "body": "What version of async are you using?\r\n^3.2.2\r\nWhich environment did the issue occur in (Node version/browser version)\r\nNode: >=12\r\nnpm: 6.14.11\r\n\r\nHi ,\r\nI have problem with async.queue.\r\n\r\nmy example:\r\n```\r\nvar queue = async.queue((infos, callback) => {\r\n      var task = new MyTask(infos);\r\n      task.on('task_done', (error) => {\r\n           console.log('Finish processing task: ', infos.ID);\r\n           callback();\r\n      });\r\n  \r\n     tart.start();\r\n}, 5);\r\n```\r\n\r\n- sometimes task doesn't remove from the queue when finished.\r\n  I see ''Finish processing task: 12345' is printed in console, \r\n   but when I check the items in queue.workersList() I see item.data.ID = 12345 still exists, and never remove from queue.\r\n\r\nAnybody help me?\r\n\r\nThanks!\r\n\r\nps: sorry for my english. \r\n  \r\n\r\n\r\n  \r\n\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1778/comments",
    "author": "vtlong",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2022-01-10T00:16:09Z",
        "body": "Need more info on the implementation of `MyTask`."
      }
    ]
  },
  {
    "number": 1760,
    "title": "async.mapLimit() finishes but wont trigger last callback.",
    "created_at": "2021-07-29T23:51:10Z",
    "closed_at": "2021-12-02T18:32:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1760",
    "body": "<!--\r\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\r\n-->\r\n\r\n**What version of async are you using?**\r\n3.2.0\r\n\r\n**Which environment did the issue occur in (Node/browser/Babel/Typescript version)**\r\nNode\r\n\r\n**What did you do? Please include a minimal reproducible case illustrating issue.**\r\nI'm trying to do work on ~10k items through a Promise chain whereas the work is done in 50 async iterations at the same time. \r\n\r\nThe code snippet is just meant to illustrate the code flow and does not include all original code. The promise chain is designed in a way that *catch()* at the end is always called so the callback function (*cb*) for the current async iteration gets called.\r\n```js\r\nlet asyncIterationsDoneCount = 0; // used for logging the async process\r\nasync.mapLimit(urlList, 50, (url, cb) => { \r\n    asyncIterationsDoneCount++;\r\n   \r\n    // promise chain\r\n    DoRequest(url) \r\n        .then(r => DoMoreWithUrl())\r\n        .then(r => {\r\n             throw new Error('done'); // terminates the chain and triggers catch()\r\n            \r\n        }).catch(err => { \r\n            console.log('async op finished, results/err: ', err);\r\n            console.log(urlList.length - asyncIterationsDoneCount, ' async iterations left');\r\n            cb(null, err); // end current async iteration\r\n        }\r\n}, (err, results) => {\r\n        if(err)\r\n          thow new Error(err);\r\n\r\n        console.log('All async operations finished, results: ', results);\r\n});\r\n```\r\n\r\n**What did you expect to happen?**\r\nThe last callback in `async.mapLimit` function to fire, to signal it's done with all async iterations. It fires when `urlList` is below ~3000 in length, but above this, no.\r\n\r\n**What was the actual result?**\r\nThe log from the program outputs this while hanging forever: `0 async iterations left`. When i run the program in the terminal (`node program.js`) it's impossible to exit the node program with `ctrl + c` in the terminal (linux), so i must kill the process eventually.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1760/comments",
    "author": "abobakrd",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2021-08-05T23:07:37Z",
        "body": "Going to need an executable code example here.\r\n\r\nHowever, I will say that throwing an error and using `.catch()` to signal the end of a promise chain is a bit odd.  Why doesn't `.then()` work?"
      },
      {
        "user": "abobakrd",
        "created_at": "2021-09-18T01:12:12Z",
        "body": "The source code that uses the promise chain is pretty large, so I just included a pseudo example that replicates the exact same source code algorithm. The chain works well on lists with length of items under ~5000, but above this it starts to hang. Regarding the chain terminator method, I've used `catch()` for faster processing of a failed chain, otherwise I'd have to conditionally check every result within each `then()` to be eligible for ending the current async operation with firing the `cb` callback function. It works, but may be a bit odd-looking from a design perspective.\r\n\r\nNot sure what happened but the code works sometimes now with items length over ~10k.\r\n\r\n"
      }
    ]
  },
  {
    "number": 1759,
    "title": "Contributing Help",
    "created_at": "2021-07-29T19:12:39Z",
    "closed_at": "2021-12-02T18:32:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1759",
    "body": "Hey guys, I'm working on a pr to work around some of the throttling issues with `setImmediate` which becomes `setTimeout` in the browser. I'm having a hard time building the lib for testing though, even from a vanilla repo. What I've done:\r\n* Checkout the repo\r\n* install deps\r\n* run `make`\r\nThat results in the following:\r\n```\r\nmake: *** No rule to make target `build/all.js', needed by `build-modules'.  Stop.\r\n```\r\nI didn't see a contributing guide or anything like that, am I missing some setup steps?\r\nI'm on MacOS if that makes a difference.\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1759/comments",
    "author": "jensengar",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2021-08-05T22:55:30Z",
        "body": "Which platform?  You might need an updated Make.  "
      }
    ]
  },
  {
    "number": 1737,
    "title": "How 'async.each' is used in recursive structures?",
    "created_at": "2020-12-02T03:32:29Z",
    "closed_at": "2020-12-02T23:40:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1737",
    "body": "I am using async version 3.2.\r\nI am in the process of downloading a zip file of objects in the folder structure from 'typescript'.\r\nThis is the file object to be used.\r\n\r\n```\r\nexport class FileItem {\r\n  name: string;\r\n  isDirectory: boolean;\r\n  dateModified? : string;\r\n  fullName? : string;\r\n  size? : number;\r\n  items? : FileItem[];\r\n}\r\n```\r\nAll files should be explored in this directory structure.\r\n\r\nI used 'async module' to proceed with the work after the foreach loop is finished.\r\n\r\nUse recursive function because folders or files may exist within a folder.\r\n\r\nI want to call 'zip.generateAsync' only once after all 'zip.file' courses, but it calls 'zip.generateAsync' as 'eachCallback' is called... What is the problem?\r\n\r\n```\r\n  getZipFileDownload(item: FileItem, rootName: string) {\r\n    let zip = new JSZip();\r\n\r\n    this.makeZipFile(item, zip, rootName);\r\n  }\r\n\r\n  makeZipFile(Item: FileItem, zip: JSZip, rootName: string) {\r\n    async.each(Item.items, (item: FileItem, eachCallback) => {\r\n      if (item.isDirectory) {\r\n        this.makeZipFile(item, zip, rootName);\r\n      } else {\r\n        this.http.get(this.rootURL + item.fullName, { responseType: 'text' }).subscribe((res) => {\r\n          zip.file(item.fullName.split(rootName)[1], res);\r\n          eachCallback();\r\n        });\r\n      }\r\n    }, (err) => {\r\n      if (err) console.log(err);\r\n      zip.generateAsync({ type: 'blob' }).then((resolve) => {\r\n        let url = window.URL.createObjectURL(resolve);\r\n        let anchor = document.createElement(\"a\");\r\n        anchor.download = rootName;\r\n        anchor.href = url;\r\n        anchor.click();\r\n      });\r\n    });\r\n  }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1737/comments",
    "author": "ljg0230",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2020-12-02T23:40:34Z",
        "body": "`makeZipFile` has no callback, when it really should have one.\r\n\r\nDecouple `generateAsync` from the process of recursion."
      },
      {
        "user": "ljg0230",
        "created_at": "2020-12-03T00:16:01Z",
        "body": "> `makeZipFile` has no callback, when it really should have one.\r\n> \r\n> Decouple `generateAsync` from the process of recursion.\r\n\r\nThank you for your answer.\r\nI'm sorry, but is there a way to separate 'generateAsync' in the recursive process and call it after all of Async.each's processes are over?"
      },
      {
        "user": "ljg0230",
        "created_at": "2020-12-03T01:45:11Z",
        "body": "> `makeZipFile` has no callback, when it really should have one.\r\n> \r\n> Decouple `generateAsync` from the process of recursion.\r\n\r\nIs there any problem with using Async module as it is in Typescript?"
      }
    ]
  },
  {
    "number": 1724,
    "title": "help converting old async 2.6.2 callback to new async/await 3.2.0",
    "created_at": "2020-08-28T04:20:37Z",
    "closed_at": "2020-08-28T13:27:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1724",
    "body": "I am trying to convert old async 2.6.2 codebase (node v8) which is written with callbacks to new async/await 3.2.0 with node v12\r\n\r\nAs examples with async/await for 3.2.0 are unavailable I am having hard time converting the old codebase, can somebody help me convert below example code to newer version?\r\n\r\n```\r\n//2.6.2\r\nvar async = require('async'); \r\nvar fs = require('fs');\r\n\r\nvar taskObj = {\r\n    task1: \"test1\",\r\n    task2: \"test2\"\r\n};\r\n\r\nasync.series([\r\n    function (cb) {\r\n        async.eachOf(taskObj, function (item, key, cbe) {\r\n            console.log(\"working on key: \" + key);\r\n            someAsyncFunction1(item, key, cbe);\r\n        }, cb);\r\n    },\r\n    function (cb) {\r\n        async.parallel([\r\n            function(cbp){\r\n                console.log(\"working on sp1 in parallel\");\r\n                someAsyncFunction2(taskObj, \"sp1\", cbp);\r\n            },\r\n            function(cbp){\r\n                console.log(\"working on sp2 in parallel\");\r\n                someAsyncFunction3(taskObj, \"sp2\", cbp);\r\n            }\r\n        ], cb);\r\n    }\r\n], function (error) {\r\n    console.log('done');\r\n});\r\n\r\nfunction someAsyncFunction1(item, key, callback) {\r\n    fs.writeFile( key + \"-sAF1.txt\", JSON.stringify(item), callback);\r\n}\r\n\r\nfunction someAsyncFunction2(item, key, callback) {\r\n    fs.writeFile( key + \"-sAF2.txt\", JSON.stringify(item), callback);\r\n}\r\n\r\nfunction someAsyncFunction3(item, key, callback) {\r\n    fs.writeFile( key + \"-sAF3.txt\", JSON.stringify(item), callback);\r\n}\r\n```\r\n\r\nBelow note is taken from async v3 docs but I am not sure, do we need to use ```async.asyncify()```  for converting above code?\r\n\r\n> We can only detect native async functions, not transpiled versions (e.g. with Babel). Otherwise, you can wrap async functions in async.asyncify().\r\n\r\nNot sure how to write this without callbacks\r\n\r\n```\r\n//3.2.0\r\nvar async = require('async'); \r\nvar fs = require('fs');\r\n\r\nvar taskObj = {\r\n    task1: \"test1\",\r\n    task2: \"test2\"\r\n};\r\n\r\nawait async.series([\r\n    await async.eachOf(taskObj, async (item, key) => {\r\n        someAsyncFunction1(item, key, ?)\r\n    }),\r\n    await async.parallel([\r\n    await someAsyncFunction1(item, key, ?),\r\n    await someAsyncFunction1(item, key, ?)\r\n    ])\r\n], function(error){\r\n    console.log('done');\r\n});\r\n\r\nfunction someAsyncFunction1(item, key, ?) {\r\n    fs.writeFile( key + \"-sAF1.txt\", JSON.stringify(item), ?);\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1724/comments",
    "author": "viyatgandhi",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2020-08-28T06:29:16Z",
        "body": "A lot of this is native JS now:\r\n\r\n```js\r\nvar async = require('async');\r\nvar fs = require('fs/promises'); // note the promises\r\n\r\nasync function main() { // top-level await coming in node 14\r\n  await async.eachOf(itemObj, async (item, key) => {\r\n    return someAsyncFunction(item, key)\r\n  }))\r\n  await Promise.all([\r\n    someAsyncFunction1(item, key),\r\n    someAsyncFunction1(item, key)\r\n  ]}\r\n}\r\n\r\nmain();\r\n\r\nasync function someAsyncFunction1(item, key) {\r\n    return fs.writeFile( key + \"-sAF1.txt\", JSON.stringify(item), ?);\r\n}\r\n```"
      },
      {
        "user": "viyatgandhi",
        "created_at": "2020-08-28T13:27:12Z",
        "body": "thanks @aearly "
      }
    ]
  },
  {
    "number": 1721,
    "title": "It should push data even it is paused?",
    "created_at": "2020-07-27T15:27:05Z",
    "closed_at": "2020-10-31T20:57:04Z",
    "labels": [
      "question",
      "queue"
    ],
    "url": "https://github.com/caolan/async/issues/1721",
    "body": "<!--\r\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\r\n-->\r\n\r\n**What version of async are you using?**\r\n3.2.0\r\n\r\n**Which environment did the issue occur in (Node version/browser version)**\r\nv11.6.0\r\n\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\nI have a queue:\r\n```javascript \r\nconst queue = async.queue(async (task, callback) => {\r\n  console.log('task name: ' + JSON.stringify(task.value.toString()));\r\n  // call callback\r\n}, 10)\r\n\r\n// when queue is drain I want to pause it to let it load more data from kafka consumer\r\nqueue.drain(() => {\r\n  queue.pause()\r\n  consumer.consume(20)\r\n})\r\n\r\n//when queue has reached limit start to process\r\nqueue.saturated(() => {\r\n  queue.resume()\r\n})\r\n\r\n// I give queue to kafka consumer to push data to it\r\nconsumer.on('data', async function (m) {\r\n  console.log('message taken')\r\n//flow get stuck here because a paused queue stops push data, it never get saturated to call queue.resume()\r\n  queue.push(m, (error, result) => {\r\n    console.log('message pushed')\r\n    if (error) {\r\n      // console.log('error pushing: '+ JSON.stringify(error))\r\n    }\r\n  })\r\n})\r\n```\r\n\r\n**What did you expect to happen?**\r\nI expect use resume() and pause() as control structure. I try to take message from kafka with a rate based on queue limitation and prevent it collapse.\r\n\r\n**What was the actual result?**\r\nThe actual result does not let the queue push message to itself while it is stopped. I understand paused mode could refer to worker process. However, the behavior let the queue load one more message and dispatch it calling drain() again, which it is no efficient, because it starts calling drain per message.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1721/comments",
    "author": "mherrera05",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2020-08-18T22:57:48Z",
        "body": "There's no need to pause the queue once it drains.  It'd be empty and nothing processing to pause."
      },
      {
        "user": "mherrera05",
        "created_at": "2020-08-21T16:15:31Z",
        "body": "Related with the example after the first drain when consumer start to consume events and it has pushed one event to the queue it is quickly handle by task (because queue is not in pause) and it calls drain again with just one event, and this calls again to consume. For this reason I expressed the need to pause the queue to let it load again and have control over events."
      }
    ]
  },
  {
    "number": 1719,
    "title": "What to use to asyncify a for loop (and limiting the concurrent operations)?",
    "created_at": "2020-06-15T20:29:29Z",
    "closed_at": "2020-08-18T23:01:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1719",
    "body": "I am trying to do an async version of a for loop which is looping through pixels (so lots of iterations), and skipping 3 each time (as pixels each have 4 values).\r\n\r\n`for (var i - 0; i < pixels.length; i+=4) {}`\r\n\r\neachOfLimit almost works, but if I input the pixels array as the collection, it does i++ each time rather than i+=4.\r\n\r\nI tried using timesLimit, which was perfect as it ran the right number of times (pixels.length/4), and limited how many ran at once, except that it accumulates the results (even when the result is undefined / null), and I need the result from the last loop.\r\n\r\nSo then I tried doing it with doUntil, which is perfect even at the end as it just returns the last result, except now I'm exceeding the maximum call stack size (which makes sense because it can be potentially millions of iterations). \r\n\r\nAm I missing a method that can do this, or does anyone have an idea of how to impliment it?",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1719/comments",
    "author": "skeddles",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2020-08-18T23:01:47Z",
        "body": "I'd avoid doing an async for loop over a pixel array -- it's going to be unusably slow.\r\n\r\n`doUntil` seems like it would work, keeping track of the index yourself, but the call stack exception leads me to believe your processing is actually synchronous, in which case a basic for loop would work (and be way faster)."
      }
    ]
  },
  {
    "number": 1718,
    "title": "callback function of asyn.each iteration is undefined",
    "created_at": "2020-06-02T13:15:30Z",
    "closed_at": "2020-08-18T23:02:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1718",
    "body": "my code is as follow.\r\n\r\n```js\r\nvar transactions = [\"1\", \"2\", \"3\"]\r\nasync.each(transactions, async function(tx, callback) {\r\n  console.dir(tx);\r\n  console.dir(callback)\r\n}, function(err) {})\r\n```\r\n\r\nthe callback function is undefined\r\n\r\n\r\nnode v14.3.0\r\nnpm 6.14.5\r\nubuntu 18.04\r\n\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1718/comments",
    "author": "landoyjx",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2020-08-18T23:02:54Z",
        "body": "`async` functions don't get passed a `callback` -- return a value, or throw an exception."
      }
    ]
  },
  {
    "number": 1716,
    "title": "Await async.each with async function as parameter",
    "created_at": "2020-05-18T17:44:01Z",
    "closed_at": "2020-05-20T04:16:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1716",
    "body": "I can't await async.each with async function as parameter.\r\nIs there a way to achieve this?\r\n\r\n**What version of async are you using?**\r\n\r\n3.1.0\r\n\r\n**Which environment did the issue occur in (Node version/browser version)**\r\n\r\nNode v10.16.0\r\n\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\n\r\n```\r\nconsole.log('Hello');\r\n\r\nawait async.each(array, async(item) => {\r\n    await asyncFunction1(item);\r\n    await asyncFunction2(item);\r\n});\r\n\r\nconsole.log('Hello 2')\r\n```\r\n\r\n\r\n**What did you expect to happen?**\r\n\r\n```\r\nHello\r\nHello2\r\n```\r\n\r\n**What was the actual result?**\r\n\r\n```\r\nHello\r\n```",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1716/comments",
    "author": "Crodaycat",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2020-05-18T18:23:40Z",
        "body": "Are you using any sort of compiler, e.g. Babel, Typescript?"
      },
      {
        "user": "Crodaycat",
        "created_at": "2020-05-18T18:28:55Z",
        "body": "Yes, i'm using react native with Expo, so i'm using Babel."
      },
      {
        "user": "aearly",
        "created_at": "2020-05-18T20:17:33Z",
        "body": "Make sure it's targeting at least ES2017 for the server code, and keeping `async` functions as-is."
      },
      {
        "user": "Crodaycat",
        "created_at": "2020-05-20T04:16:03Z",
        "body": "It seems to by a bad error catching. Thanks"
      }
    ]
  },
  {
    "number": 1713,
    "title": "Network request timed out, other requests did not continue, why is this",
    "created_at": "2020-04-25T13:29:55Z",
    "closed_at": "2020-08-18T23:05:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1713",
    "body": "```js\r\n        async.mapLimit(wrss, 10, async function(rss) {\r\n            const response = await parser.parseURL(rss.key)\r\n            return response\r\n        }, (err, results) => {\r\n            if (err){\r\n                console.log(err.toString())\r\n                // return\r\n            }\r\n            // results is now an array of the response bodies\r\n            \r\n        })\r\n```",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1713/comments",
    "author": "SemperChen",
    "comments": [
      {
        "user": "YealZoy",
        "created_at": "2020-05-12T02:56:07Z",
        "body": "I got the same problem,Have you solved this？"
      },
      {
        "user": "KMethod",
        "created_at": "2020-06-01T08:05:43Z",
        "body": "same issue"
      },
      {
        "user": "ChrisWiles",
        "created_at": "2020-06-05T21:25:22Z",
        "body": "Here is a working example using mapLimit and async/await\r\n\r\n```javascript\r\nconst async = require('async');\r\n\r\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\r\n\r\nconst processItem = async (item) => {\r\n  console.log(`start processItem: ${item}`);\r\n  const num = Math.floor(Math.random() * 11);\r\n  await sleep(num * 1000);\r\n  console.log(`finish processItem: ${item}`);\r\n  return item * 2;\r\n};\r\n\r\nasync function processItems() {\r\n  console.log('Called processItems');\r\n  try {\r\n    const items = [1, 2, 3, 4, 5, 6, 7, 8, 9];\r\n    const results = await async.mapLimit(items, 10, processItem);\r\n    console.log(results);\r\n    return results;\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n}\r\n\r\nprocessItems();\r\n\r\n```"
      }
    ]
  },
  {
    "number": 1698,
    "title": "Async Queue has issue and become slow after long run of tasks",
    "created_at": "2019-12-20T12:59:58Z",
    "closed_at": "2020-03-07T03:14:37Z",
    "labels": [
      "question",
      "performance"
    ],
    "url": "https://github.com/caolan/async/issues/1698",
    "body": "<!--\r\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\r\n-->\r\n\r\n**What version of async are you using?**\r\nLatest\r\n\r\n**Which environment did the issue occur in (Node version/browser version)**\r\nNode Version\r\n\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\nGenerate huge task into Async Queue, with async type process function.\r\nit somehow become slow down when processing.\r\n1. running for 1440 job for first time, 20 minutes, reboot\r\n2. running for 1440 job for second time, 20 minutes, no reboot\r\n3. running for 1440 job for third time, 2 hours\r\n\r\n**What did you expect to happen?**\r\nit should took 20 minutes for 1440 jobs constantly\r\n\r\n**What was the actual result?**\r\n1. running for 1440 job for first time, 20 minutes, reboot\r\n2. running for 1440 job for second time, 20 minutes, no reboot\r\n3. running for 1440 job for third time, 2 hours\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1698/comments",
    "author": "lordlaw",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2020-02-24T01:32:01Z",
        "body": "Is this using the same queue object, or are you calling `async.queue()` multiple times?  Really hard to diagnose with the info given here.\r\n\r\nTBH, I'd recommend a different system if you need a durable, long-running queue system."
      }
    ]
  },
  {
    "number": 1694,
    "title": "applyEachSeries is not working since 3.0.0",
    "created_at": "2019-11-13T09:28:29Z",
    "closed_at": "2019-11-19T17:52:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1694",
    "body": "**What version of async are you using?**\r\n3.1.0\r\n**Which environment did the issue occur in (Node version/browser version)**\r\nv8.16.2\r\nv10.15.3\r\nv10.15.1\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\n```js\r\nconst async = require('async');\r\nfunction one(arg1, arg2, callback) {\r\n  console.log('one');\r\n  return callback();\r\n}\r\nfunction two(arg1, arg2, callback) {\r\n  console.log('two');\r\n  return callback();\r\n}\r\nasync.applyEachSeries([one, two], 'argument 1', 'argument 2', function finalCallback(err) {\r\n  console.log('done');\r\n});\r\n```\r\n**What did you expect to happen?**\r\nOutput should be:\r\n```\r\none\r\ntwo\r\ndone\r\n```\r\n**What was the actual result?**\r\nNo output\r\n\r\nVersions that did not work:\r\nv3.1.0\r\nv3.0.1\r\nv3.0.0\r\n\r\nDid work in:\r\nv2.6.3\r\nv2.6.2\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1694/comments",
    "author": "axi92",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2019-11-13T19:12:12Z",
        "body": "The signature for `applyEach` changed a bit in v3.  Now you need to:\r\n\r\n```js\r\nasync.applyEachSeries([one, two], 'argument 1', 'argument 2')(function finalCallback(err) {\r\n  console.log('done');\r\n});\r\n```"
      },
      {
        "user": "docteurzoidberg",
        "created_at": "2021-04-28T09:59:58Z",
        "body": "> \r\n> \r\n> The signature for `applyEach` changed a bit in v3. Now you need to:\r\n> \r\n> ```js\r\n> async.applyEachSeries([one, two], 'argument 1', 'argument 2')(function finalCallback(err) {\r\n>   console.log('done');\r\n> });\r\n> ```\r\n\r\nexemple code doesn't work either witch current 3.2.0. callback undefined\r\ncool my stuff not work anymore and i don't find why"
      }
    ]
  },
  {
    "number": 1693,
    "title": "Missed callback detection",
    "created_at": "2019-10-21T17:03:24Z",
    "closed_at": "2019-10-25T21:15:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1693",
    "body": "This is a general question about methods to diagnose scenarios in which an async based waterfall or other control flow does not complete. \r\n\r\nBackground is that we have a Job framework periodically running job definitions, which are just AMD modules exposing a method that executes an async based control flow, and over time we're noticing that some of these jobs sometimes do not complete - they do not crash or otherwise fail - they simply never report success or failure - and the circumstances are not directly repeatable but seem to depend on external factors like network or database load etc. \r\n\r\nOur working hypothesis is that there is some error pathway in our job definition in which a callback is never called etc, and I'm looking for techniques or any built in facilities that might help diagnose these scenarios, ie is there anything like a waterfall or other control flow timeout option etc? ",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1693/comments",
    "author": "gregory-h",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2019-10-21T20:35:51Z",
        "body": "The only way I've found to diagnose things like this is to use a timeout -- there is `async.timeout` which you can use to wrap steps that might never call callbacks."
      },
      {
        "user": "gregory-h",
        "created_at": "2019-10-25T21:15:30Z",
        "body": "ah I wasn't aware of async.timeout but that sounds like exactly what I need - thx. "
      }
    ]
  },
  {
    "number": 1691,
    "title": "Export variable in async.call functions",
    "created_at": "2019-10-05T11:03:54Z",
    "closed_at": "2020-02-24T02:09:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1691",
    "body": "<!--\r\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\r\n-->\r\n\r\n**What version of async are you using?**\r\n3.1.0\r\n\r\n**Which environment did the issue occur in (Node version/browser version)**\r\nnode 10.16.3\r\n\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\n```js\r\n// file_a.js\r\nvar a = require('file_b.js');\r\nconsole.log('str = ', a.str);\r\n// file_b.js\r\nconst async = require('async');\r\nasync.waterfall([\r\n...\r\n], function(err, result) {\r\n  exports.str = result;\r\n});\r\n```\r\n\r\n**What did you expect to happen?**\r\n\r\nI expect the output is `str = hello world`\r\n\r\n**What was the actual result?**\r\nIt is `str = undefined`\r\n\r\nI searched for so many solutions. But I could not find one workable.\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1691/comments",
    "author": "Wsine",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2019-10-05T19:30:27Z",
        "body": "This wouldn't work because require is synchronous.  `exports.str` isn't assigned until a later tick in the event loop."
      },
      {
        "user": "Wsine",
        "created_at": "2019-10-06T10:52:15Z",
        "body": "yep, i know that now. but sometimes we need a common module to export shared variables to other modules. how could we do that with async package?\r\n\r\nOr the problem could be \r\n\r\n```js\r\nasync.waterfall([\r\n...\r\n], function(err, result) {\r\n...\r\n});\r\n\r\nconsole.log('hello world');\r\n```\r\n\r\nhow could we make sure that the console log will be executed after any async.call? except that all the code need to be put into async.call functions."
      },
      {
        "user": "aearly",
        "created_at": "2020-02-24T02:09:15Z",
        "body": "Look up how `async`/`await` works in JS.  You can't do that with a synchronous function, but you can with promises and async/await."
      }
    ]
  },
  {
    "number": 1684,
    "title": "How to change the limite of loop?",
    "created_at": "2019-09-10T10:20:53Z",
    "closed_at": "2019-09-17T09:26:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1684",
    "body": "Version: ^2.6\r\n\r\nNode version: 10\r\n\r\nIssues:\r\nI hope to be able to dynamically adjust the limite of loop in the program to suit the needs. Is there a ready-made method? Or can it be a future?\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1684/comments",
    "author": "zhengyongtao",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2019-09-10T17:27:04Z",
        "body": "The only construct where you can change the concurrency on the fly is `queue`.  "
      },
      {
        "user": "zhengyongtao",
        "created_at": "2019-09-17T09:26:29Z",
        "body": "Thank you for your answer！"
      }
    ]
  },
  {
    "number": 1677,
    "title": "Same JSDoc theme name but multiple templates",
    "created_at": "2019-07-27T01:51:22Z",
    "closed_at": "2019-08-01T18:29:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1677",
    "body": "I wanted this template which is used in async docs but when I install this I get a different layout and apparently there exists another theme with same install instructions. What should I do to get your layout theme",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1677/comments",
    "author": "amruta-pani",
    "comments": [
      {
        "user": "amruta-pani",
        "created_at": "2019-07-27T01:59:31Z",
        "body": "I guess I need to clone this and install it?"
      },
      {
        "user": "aearly",
        "created_at": "2019-08-01T18:29:29Z",
        "body": "Our JSDoc theme is heavily customized -- you'd need to clone it and run the script that combines the generated output into one page."
      }
    ]
  },
  {
    "number": 1674,
    "title": "v3.1.0 queue.push does nothing after no. of tasks are complete(defined concurrency) ",
    "created_at": "2019-07-12T15:19:52Z",
    "closed_at": "2019-07-18T03:36:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1674",
    "body": "```\r\nvar que = async.queue(async function({id}) {   \r\n  const res = await fetchData(id);\r\n  return res;\r\n}, 2);\r\n```\r\n\r\n```\r\nque.push({id}, function (err, res) {\r\nconsole.log('handle res');\r\n});\r\n```\r\n\r\nHere concurrency is set as 2. so after first two tasks are done and if I push a new task in the queue. nothing happens. No err, even the task in also not pushed.\r\n\r\nIf I update concurrency to 5, it will perform the first 5 tasks and then it fails for the 6th task.\r\n\r\nDo we have to clear the queue after each task is done?\r\n\r\nEDIT: This is working correctly when i run my react project locally. But when I create the build and deploy it to production it does not move forward after defined concurrency tasks are completed.",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1674/comments",
    "author": "TOPSinfo",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2019-07-14T23:35:52Z",
        "body": "I would bet your `async` functions are being compiled away in production mode.  We can't detect `async` functions that have been transpiled -- wrap them with `asyncify` to prevent this."
      },
      {
        "user": "TOPSinfo",
        "created_at": "2019-07-15T05:49:39Z",
        "body": "Thanks for the help.\r\nYes wrapping them with asyncify solved the issue but now the tasks run one after the other. provided concurrency does not matter now.\r\n\r\n```\r\nvar que = async.queue(asyncify(async function({id}) {   \r\n  const res = await fetchData(id);\r\n  return res;\r\n}, 2));\r\n```"
      },
      {
        "user": "afladmark",
        "created_at": "2019-07-17T22:56:20Z",
        "body": "It looks like you have the second to last `)` in the wrong place. I believe it should be:\r\n\r\n```\r\nvar que = async.queue(asyncify(async function({id}) {   \r\n  const res = await fetchData(id);\r\n  return res;\r\n}), 2);\r\n```\r\n\r\nThat way the `2` is part of the `queue` call and not the `asyncify` call."
      },
      {
        "user": "aearly",
        "created_at": "2019-07-18T03:36:09Z",
        "body": ":point_up: "
      },
      {
        "user": "TOPSinfo",
        "created_at": "2019-07-19T05:29:38Z",
        "body": "@afladmark The concurrency issue gets fixed with your solution. Thanks for that.\r\nBut it again starts the initial issue.\r\nAfter the first 2(provided concurrency)  tasks are complete, it does not start the next task.\r\nCallback to any of the completed task is not called.\r\n\r\n@aearly Can you please reopen this issue.\r\n"
      },
      {
        "user": "aearly",
        "created_at": "2019-07-20T21:02:32Z",
        "body": "`async` functions shouldn't use callbacks."
      },
      {
        "user": "TOPSinfo",
        "created_at": "2019-07-23T06:50:33Z",
        "body": "@aearly Even if I don't rely on the callback. If the concurrency is 2 then the third push doesn't work. It only happens in the React production build. The local environment works all good.\r\n\r\n"
      },
      {
        "user": "TOPSinfo",
        "created_at": "2019-07-25T11:29:43Z",
        "body": "Ok. This is works for me now.\r\nThe issue was the fetchData method was not returning any value in one of the many possible cases."
      }
    ]
  },
  {
    "number": 1671,
    "title": "async.queue callback is called before the async task is complete.",
    "created_at": "2019-06-27T05:27:51Z",
    "closed_at": "2019-06-29T23:28:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1671",
    "body": "```js\r\nvar que = async.queue(async function({id}, callback) {\r\n   \r\n  const res = await fetchData(id);\r\n  callback(res);\r\n\r\n}, 2);\r\n```\r\n\r\n`let res = await que.push({id});\r\n// res is undefined here\r\n\r\nWith the latest update async@3.0.1 How this will work? Can you please provide some example for this?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1671/comments",
    "author": "TOPSinfo",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2019-06-29T23:28:58Z",
        "body": "You can't use callbacks with `async` functions  passed into Async.  Just return a value:\r\n\r\n```js\r\nvar que = async.queue(async function({id}) {\r\n   \r\n  const res = await fetchData(id);\r\n  return res;\r\n\r\n}, 2);\r\n```"
      }
    ]
  },
  {
    "number": 1670,
    "title": "not working with es6 async/await",
    "created_at": "2019-06-27T03:33:10Z",
    "closed_at": "2019-06-29T23:29:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1670",
    "body": "    async.series([\r\n      function(cb){\r\n        cb(null,1)\r\n      },\r\n      \r\n      async.asyncify(async function(){\r\n        let a = await this.f1();\r\n        console.log(5);\r\n        return 5;\r\n      }),\r\n    ],(err,result)=>{\r\n      console.log(result)\r\n    });\r\n  }\r\n\r\n  async f1() {\r\n    return \"1\"\r\n  }",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1670/comments",
    "author": "michael2043",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2019-06-27T04:40:29Z",
        "body": "What version of Node?"
      }
    ]
  },
  {
    "number": 1667,
    "title": "How to use await with retry ?",
    "created_at": "2019-06-19T10:58:53Z",
    "closed_at": "2019-06-23T01:27:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1667",
    "body": "Is it possible to use `async.retry` in the following manner\r\n\r\n ```\r\nawait retry(times: 3,interval: 3 * 1000},apiCall);\r\n```",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1667/comments",
    "author": "agarwalkartik",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2019-06-23T01:27:59Z",
        "body": "Yes."
      }
    ]
  },
  {
    "number": 1647,
    "title": "v3.0 and eachSeries async/await",
    "created_at": "2019-05-25T13:25:45Z",
    "closed_at": "2019-05-27T01:22:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1647",
    "body": "Hey,\r\n\r\nv3.0 doesn't bring async/await support for eachSeries yet? Is there a full list, which async functions now support Promise?\r\n\r\nExpected with this update:\r\n```\r\nasync.eachSeries(items, async (item, callback) => {\r\n            const itemStats = await someFunc(item);\r\n           callback();\r\n});\r\n```\r\n\r\nCurrently in usage:\r\n```\r\nasync.eachSeries(items, (item, callback) => {\r\n         (async () => {\r\n            const itemStats = await someFunc(item);\r\n            callback();\r\n          })();\r\n});\r\n```",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1647/comments",
    "author": "endze1t",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2019-05-25T19:56:04Z",
        "body": "Async doesn't pass callbacks to `async`  functions.  Simply `return`!\r\n\r\n```js\r\nasync.eachSeries(items, async (item) => {\r\n            const itemStats = await someFunc(item);\r\n});\r\n```"
      },
      {
        "user": "endze1t",
        "created_at": "2019-05-25T22:06:46Z",
        "body": "Sorry, my question wasn't that good.\r\n\r\nWithout callback() i'm not able to handle the error after:\r\n\r\n```js\r\nasync.eachSeries(items, async (item) => {\r\n            const itemStats = await someFunc(item);\r\n             \r\n            if(!itemStats) throw new Error('no stats found');\r\n\r\n}, (err) => {\r\n       if(err) return res.status(500);\r\n\r\n       return res.status(200).json({success: true})\r\n});\r\n```\r\n\r\nThis won't work without callback or?"
      },
      {
        "user": "aearly",
        "created_at": "2019-05-26T19:08:44Z",
        "body": "The idiomatic way to handle this with `async`/`await` would be: \r\n\r\n```js\r\ntry {\r\n    await async.eachSeries(items, async (item) => {\r\n            const itemStats = await someFunc(item);\r\n             \r\n            if(!itemStats) throw new Error('no stats found');\r\n    })\r\n} catch (err)  {\r\n   return res.status(500);\r\n}\r\nreturn res.status(200).json({success: true})\r\n\r\n```"
      }
    ]
  },
  {
    "number": 1637,
    "title": "what is a good pattern to wait for all iterations of  async.eachLimit to finish before moving on?",
    "created_at": "2019-04-17T04:32:16Z",
    "closed_at": "2019-04-17T04:56:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1637",
    "body": "question: bit new to async and have following code to download lots of files, 2 at about the same time\r\n```                       \r\nasync.eachLimit(files, 2, async (file, callback) => {\r\n     reportStep(\"downloading\");\r\n     console.log(\"async start: \" + file.path);\r\n     await addFile(file.path, file.size);\r\n     console.log(\"async end: \" + file.path);    \r\n     callback();\r\n }) \r\nreportStep(\"completed\")\r\n```\r\nOf course, \"completed\" quickly get's fired while async.eachLimit continues executing funcs.\r\n\r\nWhat is a good way to wait for all the iterations to be done? \r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1637/comments",
    "author": "avieru",
    "comments": [
      {
        "user": "avieru",
        "created_at": "2019-04-17T04:56:31Z",
        "body": "nvm, didn't read the docs close enough.\r\n\r\nthere is yet another callback  param, ended up wrapping it up all up in a promise that i can await\r\n```\r\nfunction download(files) {\r\n    return new Promise((resolve, reject) => {\r\nasync.eachLimit(files, 2, async (file, callback) => {\r\n     reportStep(\"downloading\");\r\n     console.log(\"async start: \" + file.path);\r\n     await addFile(file.path, file.size);\r\n     console.log(\"async end: \" + file.path);    \r\n     callback();\r\n         }, (error) => {\r\n            if (error){\r\n                reject(error);\r\n            } else {\r\n                resolve();\r\n            }\r\n        })\r\n    });\r\n}\r\n\r\nawait download(files)\r\n```"
      },
      {
        "user": "hargasinski",
        "created_at": "2019-04-17T20:51:28Z",
        "body": "Side note, if you are using the prerelease of `v3`, you don't need the wrapper. `eachLimit` will return a promise if you don't pass the final callback."
      },
      {
        "user": "avieru",
        "created_at": "2019-04-17T21:00:35Z",
        "body": "hmm, I tried awaiting async.eachLimit but it wasn't working for some reason or another. Thats what prompted me to post here. I'll have to give it another shot."
      },
      {
        "user": "avalanche1",
        "created_at": "2019-11-18T20:53:23Z",
        "body": "Did you suceed? I'm facing the same - it simply doesnt wait for all iterations's promises to finish."
      }
    ]
  },
  {
    "number": 1629,
    "title": "Error and results handling on async.series and async.parallel",
    "created_at": "2019-03-02T14:10:57Z",
    "closed_at": "2019-03-09T21:38:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1629",
    "body": "Beforehand, thanks a lot for the great module\r\n\r\nI use often and basically only `async.series` and `async.parallel`.\r\n\r\nI just want to be sure that I'm using it correctly regarding error and results handling.\r\n\r\nIs this ok and following the best practises?\r\n\r\n```js\r\nconst mysql = require('mysql') \r\nconst async = require('async')\r\n\r\nasync.series([\r\n  function (next) {\r\n    db = mysql.createConnection(DB_INFO)\r\n    db.connect(function(err) {\r\n      if (err) {\r\n        // this callback/next function takes 2 optional parameters: \r\n        // (error, results)\r\n        next(Error('Error connecting: ' + err.message))\r\n      } else {\r\n        next() // no error parameter filled => no error\r\n      }\r\n    })\r\n  },\r\n  function (next) {\r\n     var myQuery = ....\r\n     db.query(myQuery, function (err, results, fields) {\r\n       if (err) {\r\n         next(Error('error making the query: ' + err.message))\r\n         return // this must be here to be sure it's the last statement in case of error\r\n       }\r\n       // do something with results\r\n       // ...\r\n       next(null, results) // send the results\r\n     })\r\n   },\r\n   function (next) {\r\n     db.close()\r\n   }], \r\n   //done after all functions were executed, except if it was an error \r\n   function(err, results) {\r\n     if (err) {\r\n       console.log('There was an error: ', err)\r\n     }\r\n     else {\r\n       //read the results after everything went well\r\n       ... results ....\r\n     }\r\n   }\r\n)\r\n```\r\n\r\nThank you\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1629/comments",
    "author": "jfoclpf",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2019-03-09T21:38:13Z",
        "body": "Yep, looks good to me, nothing jumping out as wrong.  Could be made more concise with arrow funcs, but this is fine."
      },
      {
        "user": "jfoclpf",
        "created_at": "2019-03-10T01:01:56Z",
        "body": "Thank you"
      }
    ]
  },
  {
    "number": 1619,
    "title": "saturated doesn't get called with queue?",
    "created_at": "2019-02-03T08:49:44Z",
    "closed_at": "2019-02-03T09:39:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1619",
    "body": "I have this:\r\n\r\n```js\r\nconst q = async.queue((task,cb) => task(cb),3);\r\n\r\nq.saturated = function(){\r\n console.log('saturated');\r\n};\r\n\r\nq.unsaturated = function(){\r\n  console.log('unsaturated');\r\n};\r\n\r\nq.push(cb => {\r\n  console.log('called 1.');\r\n  cb(null);\r\n});\r\n\r\nq.push(cb => {\r\n  console.log('called 2.');\r\n  cb(null);\r\n});\r\n\r\nq.push(cb => {\r\n  console.log('called 3.');\r\n  cb(null);\r\n});\r\n\r\n```\r\n\r\nI get:\r\n\r\n```\r\ncalled 1.\r\nunsaturated\r\ncalled 2.\r\nunsaturated\r\ncalled 3.\r\nunsaturated\r\n\r\n```\r\n\r\nbut if I change concurrency from 3 to 1, then I get:\r\n\r\n\r\n```\r\nsaturated\r\ncalled 1.\r\nunsaturated\r\nsaturated\r\ncalled 2.\r\nunsaturated\r\nsaturated\r\ncalled 3.\r\nunsaturated\r\n````\r\n\r\nI guess I am confused - I would expect a saturated call to come before unsaturated, but maybe that's not always the case.",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1619/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2019-02-03T09:39:42Z",
        "body": "The queue never saturates at `concurrency: 3` because the tasks complete immediately.  "
      },
      {
        "user": "ORESoftware",
        "created_at": "2019-02-04T04:08:52Z",
        "body": "Yeah as an aside it's weird that unsaturated gets called 3 times when concurrency is 1. I would expect unsaturated to only be called once no more tasks are queued."
      }
    ]
  },
  {
    "number": 1612,
    "title": "Create a pool that asynchronously watches pool for changes, then executes through eachlimit",
    "created_at": "2019-01-27T11:22:27Z",
    "closed_at": "2019-02-11T22:07:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1612",
    "body": "I am trying to have it so that there is a pool, that sits on the server always waiting for a request from a client. Then when the client performs an action, add that action to the array pool and do the processing on the server and remove it from the pool once the processing has completed. Something like this:\r\n\r\nlet tasksPool = [];\r\n\r\nlet processTask = async function(task) {\r\n  // await etc\r\n}\r\n\r\neachLimit(tasksPool, 5, function(task, callback) {\r\n  processTask(task).then(() => {\r\n    callback();\r\n  });\r\n});\r\n\r\napp.get('/some-url', (req, res) => {\r\n  tasksPool.push(req.body.task);\r\n});\r\n\r\nBut it does not re-fire the eachLimit process when I add something to the array. I want eachLimit to effectively watch the array for changes. I wished I could understand what was going on with your example enough to solve this on my own, though have not seen a lot of the syntax before. Any suggestions appreciated greatly?",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1612/comments",
    "author": "rockyhuber",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2019-01-28T21:05:45Z",
        "body": "`async.queue` is what you want to use here.  `eachLimit` wont iterate past the initial length of the array at the time it is passed to `eachLimit`."
      },
      {
        "user": "rockyhuber",
        "created_at": "2019-01-29T06:29:52Z",
        "body": "Thank you for your comment. Yes I found that last night and was experimenting with it throughout the day. Thank you for the awesome library."
      }
    ]
  },
  {
    "number": 1608,
    "title": "How to replicate minification and build process?",
    "created_at": "2019-01-11T01:25:34Z",
    "closed_at": "2019-01-29T00:13:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1608",
    "body": "Hi,\r\n\r\nWhat is the process to build this project to get the `dist` directory? I wanted to replicate the build process but didn't find instructions in the README or any scripts with obvious names. Can you point me to the process for doing that?\r\n\r\nThanks for your help.",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1608/comments",
    "author": "boompig",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2019-01-11T02:53:25Z",
        "body": "`make build` should do what you want (if you're on a Mac or Linux)."
      }
    ]
  },
  {
    "number": 1565,
    "title": " How to Create a Parameter Query with many arrays? (multiple INSERT statements)",
    "created_at": "2018-07-27T19:22:42Z",
    "closed_at": "2018-07-29T23:46:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1565",
    "body": "Hi my name is Marco.\r\nI use mysql and I have the parameters  in different arrays , and my question is \r\nwhat is the right async collection to use in this case?\r\n(all the arrays have the same length)\r\n\r\n                for (let i = 0; i < cbo.length; i++) {\r\n                    let upd = \"insert into table (id, id_detail ,score, note) values (?,?,?,?)\"\r\n                    con.query(upd, [idcliente, detail[i], score[i], nore[i]], (err, rows) => {\r\n                        callback(err, rows);\r\n               }\r\nMay you help me? Thanks",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1565/comments",
    "author": "mzambo",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2018-07-29T23:46:08Z",
        "body": "`eachOf` over any of the arrays should work."
      }
    ]
  },
  {
    "number": 1559,
    "title": "Can not catch error with sequelize",
    "created_at": "2018-07-10T05:09:33Z",
    "closed_at": "2018-07-12T04:59:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1559",
    "body": "I use Async module with sequelize module to store to db (Postgres).\r\nBu i cant catch an error. Below is my code\r\n```\r\nexport function update(req) {   \r\n    return new Promise((resolve, reject) => {\r\n        var msg = req.body;\r\n\r\n        async.series([\r\n            function(cb) {\r\n                db.messages.create(msg).then(function(m) {\r\n                    cb(null, m);\r\n                }).catch(function(err) {\r\n                \t// cant catch error here\r\n                    cb(err);\r\n                });\r\n            }\r\n\r\n        ], function(err, results) {\r\n            if (err) reject({\r\n                status: 403,\r\n                message: err\r\n            });\r\n\r\n\r\n            resolve({\r\n                status: 200,\r\n                message: 'Added'\r\n            });\r\n        });\r\n\r\n    });\r\n}\r\n\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1559/comments",
    "author": "thinhnk",
    "comments": [
      {
        "user": "JohnLelii-CMCST",
        "created_at": "2018-07-10T18:25:45Z",
        "body": "Add an else statement to ensure only ``reject()`` or ``resolve()`` is called in your async callback function.  if ``db.messages.create()`` is indeed returning a rejection, the async callback should handle it.\r\n\r\n``\r\n         function(err, results) {\r\n            if (err) reject({\r\n                status: 403,\r\n                message: err\r\n            });\r\n            else\r\n            resolve({\r\n                status: 200,\r\n                message: 'Added'\r\n            });\r\n        });\r\n``"
      }
    ]
  },
  {
    "number": 1545,
    "title": "Separate async methods (to use with Lambda functions)",
    "created_at": "2018-06-20T09:00:54Z",
    "closed_at": "2018-07-01T23:40:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1545",
    "body": "First of all thank you for maintaining this project. \r\nRecently I start using AWS nodejs lambda functions for my applications. I use the serverless framework to deploy multiple functions.\r\nI don't use the async package as its to big for my project. Deploying lambda functions has a max package size at AWS.\r\n\r\n**Question**  \r\nIs it possible to also deploy the methods separate on npm? I don't want to introduce webpack to my small projects just to include some packages.\r\n\r\n**Package example**\r\n@caolanAsync/retry\r\n@caolanAsync/series\r\n@caolanAsync/parallel\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1545/comments",
    "author": "efortes",
    "comments": [
      {
        "user": "hargasinski",
        "created_at": "2018-06-28T03:11:31Z",
        "body": "I believe this option was explored in #984, but it was decided that it is best to keep everything in one package for simplicity. We'll be dropping `lodash` in `v3` (the PR is already merged, see #1528), which should decrease the package size quiet a bit. Will that solve the issue? "
      },
      {
        "user": "efortes",
        "created_at": "2018-06-29T11:13:05Z",
        "body": "@hargasinski thank you for the answer. For the case I had I solved the problem without using async. \r\nBut if I really want this I could use webpack to minimize the size. \r\nThank you."
      }
    ]
  },
  {
    "number": 1543,
    "title": "transform processes input in parallel",
    "created_at": "2018-06-10T05:00:06Z",
    "closed_at": "2018-07-02T01:29:40Z",
    "labels": [
      "question",
      "wont fix"
    ],
    "url": "https://github.com/caolan/async/issues/1543",
    "body": "<!--\r\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\r\n-->\r\n\r\n**What version of async are you using?**\r\nasync 2.6.1.\r\n\r\n**Which environment did the issue occur in (Node version/browser version)**\r\nNode.js v8.11.2.\r\n\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\n\r\n```js\r\nconst async = require('async');\r\n\r\nfunction delay(cb) {\r\n  setTimeout(cb, Math.floor(Math.random() * 20));\r\n}\r\n\r\nfunction exerciseTransform(times, cb) {\r\n  console.info(`Running transform ${times} times...`);\r\n  async.times(times, (n, nextTime) =>\r\n    async.transform([1, 2, 3, 4, 5], [], (acc, item, index, next) =>\r\n      delay(() => { acc.push(item); next(); }), nextTime),\r\n    (err, results) => { console.info(results); cb(); });\r\n}\r\n\r\nfunction exerciseReduce(times, cb) {\r\n  console.info(`Running reduce ${times} times...`);\r\n  async.times(times, (n, nextTime) =>\r\n    async.reduce([1, 2, 3, 4, 5], [], (memo, item, next) =>\r\n      delay(() => { memo.push(item); next(null, memo); }), nextTime),\r\n    (err, results) => { console.info(results); cb(); });\r\n}\r\n\r\nasync.series([\r\n  async.apply(exerciseTransform, 5),\r\n  async.apply(exerciseReduce, 5),\r\n], () => {});\r\n```\r\n\r\n**What did you expect to happen?**\r\nBecause transform is a relative of reduce, I would expect it to process the input array serially.\r\n\r\n**What was the actual result?**\r\nTransform processes the input array in parallel.\r\n\r\n```\r\nRunning transform 5 times...\r\n[ [ 3, 1, 5, 4, 2 ],\r\n  [ 1, 3, 4, 2, 5 ],\r\n  [ 2, 4, 5, 3, 1 ],\r\n  [ 1, 4, 5, 3, 2 ],\r\n  [ 4, 5, 2, 1, 3 ] ]\r\nRunning reduce 5 times...\r\n[ [ 1, 2, 3, 4, 5 ],\r\n  [ 1, 2, 3, 4, 5 ],\r\n  [ 1, 2, 3, 4, 5 ],\r\n  [ 1, 2, 3, 4, 5 ],\r\n  [ 1, 2, 3, 4, 5 ] ]\r\n```\r\n\r\nI'm not sure if anyone might depend on the current behavior, so maybe this is really a request for a transformSeries function.",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1543/comments",
    "author": "uusdfg",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2018-07-02T01:29:40Z",
        "body": "`transform` was created mainly as a way to process objects, where key ordering doesn't matter, and also to be the parallel cousin of `reduce`.\r\n\r\nMaintaining order in the accumulator is the job of the `iteratee` function.  Your example would work as expected if you did:\r\n\r\n```js\r\nfunction exerciseTransform(times, cb) {\r\n  console.info(`Running transform ${times} times...`);\r\n  async.times(times, (n, nextTime) =>\r\n    async.transform([1, 2, 3, 4, 5], [], (acc, item, index, next) =>\r\n      delay(() => { acc[index] = item; next(); }), nextTime), // <--\r\n    (err, results) => { console.info(results); cb(); });\r\n}\r\n```"
      },
      {
        "user": "uusdfg",
        "created_at": "2018-07-02T04:59:39Z",
        "body": "I'm sorry, I didn't realize that `transform` was intended to run in parallel. I had expected the same left-to-right semantics as `reduce`.\r\n\r\nI think it would help if the documentation for `transform` called out this distinction explicitly. The documentation currently says that `transform`, \"iterates over each element in series,\" which suggests that it's supposed to be serial."
      }
    ]
  },
  {
    "number": 1524,
    "title": "callback undefined error when switching from es6 to es2017",
    "created_at": "2018-04-08T18:54:16Z",
    "closed_at": "2018-05-21T04:43:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1524",
    "body": "just putting this here as a landing page for all the inevitable bugs caused by the bad decision to have magic behavior when using async/await\r\n\r\nwhen using typescript/babel and compiling to es6 or lower, this code works.\r\nwhen updating to es2017, it breaks because callback is undefined.\r\n\r\n```js\r\nasync.each(['a','b','c'], async (item, callback) => {\r\n  await Promise.resolve()\r\n  callback()\r\n}, (err) => {\r\n  err // ? TypeError: callback is not a function\r\n})\r\n```\r\n\r\n1. you should not check `fn.constructor.name === 'AsyncFunction'`, because any function that returns a promise is an async function.\r\n2. you should not magically decide to not give a callback function\r\n\r\n*sorry i may be a bit frustrated after trying to debug this*",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1524/comments",
    "author": "farzher",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2018-04-15T19:57:59Z",
        "body": "If you're using an `async` function, simply return a value, rather than use a callback.\r\n\r\nIf you're also transpiling, wrap the function with `asyncify`, because otherwise we won't be able to know beforehand if the function returns a Promise or not."
      }
    ]
  },
  {
    "number": 1518,
    "title": "async.mapLimit  support cancel?",
    "created_at": "2018-03-09T10:11:10Z",
    "closed_at": "2018-03-12T08:32:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1518",
    "body": "if async.mapLimit is running,  support cancel?\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1518/comments",
    "author": "binghaiwang",
    "comments": [
      {
        "user": "hargasinski",
        "created_at": "2018-03-09T17:05:48Z",
        "body": "Hi @binghaiwang, thanks for the question!\r\n\r\nYou cannot cancel a running task (see #1353, #1487). However, we do have plans for exiting early, i.e. exiting out of a method, such as `mapLimit`, before the running tasks finish (ignoring their result), and without starting any of remaining tasks. See #1064 for information about that. "
      }
    ]
  },
  {
    "number": 1513,
    "title": "Async.waterfall is super slow. How I can optimize it?",
    "created_at": "2018-02-08T16:44:33Z",
    "closed_at": "2018-02-15T04:11:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1513",
    "body": "I am trying to implement serverless lambda function that writes text on image. However the whole function is taking on average 5 secs and sometimes up to 10 seconds to implement. I can't understand how to optimise code. \r\n\r\nHere is the editImage function which implements async.waterfall, where source image from s3 bucket is downloaded. And then it puts text on downloaded image and then uploads result to destination key.\r\n\r\n\r\n    exports.editImage = function(event, context, callback) {\r\n     // init and assign vars\r\n     async.waterfall([\r\n       async.apply(download, srcBucket, srcKey),\r\n       async.apply(editAsset, text),\r\n       async.apply(upload, dstBucket, dstKey)\r\n     ], function (err) {\r\n          if (err) console.log('Unable to transform image');\r\n         \r\n          callback(null, {statusCode: 200, body: JSON.stringify({ key: dstKey})\r\n           });\r\n         }\r\n       );\r\n    };\r\n\r\n    function download(srcBucket, srcKey, callback) {\r\n      var params = {Bucket: srcBucket, Key: srcKey};  \r\n      s3.getObject(params, callback);\r\n    };\r\n\r\n    function editAsset(text, response, callback) {\r\n       var img = gm(response.Body);\r\n       img.size(function (err, { height }){\r\n          img.drawText(0, height / 2 - 40, text.toUpperCase(), 'center');\r\n          img.toBuffer('png', function (err, buffer) {\r\n          if (err) console.log(err);\r\n          callback(null, response, buffer);\r\n       });\r\n     });\r\n    }\r\n\r\n    function upload(dstBucket, dstKey, response, buffer, callback) {\r\n      s3.putObject({\r\n          Bucket: dstBucket,\r\n          Key: dstKey,\r\n          Body: buffer,\r\n          ContentType: response.ContentType\r\n      }, function(err, data) {\r\n      if (err) {\r\n          console.log(err, err.stack);\r\n      }else{\r\n          callback(null, response, buffer);\r\n      }\r\n     });\r\n    }\r\n\r\n\r\nThe code works. But I can't understand what is causing more delays. async.waterfall or graphicsmagic operations. Can I get any advice on how to improve performance\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1513/comments",
    "author": "jzm5",
    "comments": [
      {
        "user": "harry1064",
        "created_at": "2018-02-08T18:42:02Z",
        "body": "From my point of view, all your function take their respective time like downloading image, edition image using graphics magic and upload image which add to give you total time to complete your whole task. \r\n\r\nI think variation in time only depend in downloading and uploading image."
      },
      {
        "user": "ecasilla",
        "created_at": "2018-02-08T21:21:59Z",
        "body": "use `console.time` to trace which one of your function is causing the latency"
      }
    ]
  },
  {
    "number": 1509,
    "title": "Execute _subtasks_ in a shared execution queue?",
    "created_at": "2018-01-05T18:33:33Z",
    "closed_at": "2018-07-02T00:10:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1509",
    "body": "Is there a way to execute _subtasks_ in a _shared_ execution queue and get a notification (callback) when all the subtasks are completed?\r\n\r\nConcrete example: a function computing the size of a directory, with the constraint to limit file IO to maximum 2 parallel operations.\r\nFew considerations:\r\n\r\n1- Without the constraint, the function can simply `fs.readdir` the target directory and `fs.stat` individual files, however this will in theory lead to many parallel IOs (note: I am aware the VM will also put a limit on the number of parallel IOs, however I would like this limit to be explict in JS). (code below)\r\n2- One mitigation is to use async.eachLimit to set a maximum number of parallel IOs. However if the directory contains subdirectories, there will be multiple calls to async.eachLimit at each subdirectory so overall the number of parallel IOs will not be in check.\r\n3- Ideally the function would queue individual `fs.stat` in a shared queue that controls the parallelism. Is there such a facility available in async?\r\n\r\n\r\n```javascript\r\nconst fs = require('fs')\r\nconst async = require('async')\r\n\r\nvar dirsize = function(path, cb) {\r\n\tvar sizesum = 0;\r\n\tfs.readdir(path, function(err, files) {\r\n\t\tasync.each(files,\r\n\t\t\tfunction(file, cb) {\r\n\t\t\t\tfs.stat(path + \"/\" + file, function(err, stats) {\r\n\t\t\t\t\tif (stats.isDirectory()) {\r\n\t\t\t\t\t\tdirsize(path + \"/\" + file, function(err, size) {\r\n\t\t\t\t\t\t\tsizesum += size;\r\n\t\t\t\t\t\t\tcb(null);\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tsizesum += stats.size\r\n\t\t\t\t\t\tcb(null);\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tfunction() {\r\n\t\t\t\treturn cb(null, sizesum);\r\n\t\t\t}\r\n\t\t)\r\n\t})\r\n}\r\n\r\ndirsize(\".\", function(err, size) {\r\n\tconsole.log(\"dirsize = \" + size);\r\n})\r\n```",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1509/comments",
    "author": "sergiogiogio",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2018-01-05T22:37:27Z",
        "body": "`async.queue` is what you want  here.  As you process a directory, push any sub-directories to the queue.   You can easily control the concurrency of a queue."
      },
      {
        "user": "sergiogiogio",
        "created_at": "2018-01-08T15:13:33Z",
        "body": "Thanks - the concurrency should ideally be at the level of \"stat\" command. Here's a version with a queue (stat_queue can here be shared by multiple functions and will always only execute 2 operations at the same time). It works - but it is tedious and feels like essentially implementing a queue within a queue, which is why I wanted to check whether there exist better solutions.\r\n\r\nEssentially I am looking for a feature that would enable me to 1) execute a set of tasks on a queue and 2) notify me when the set of tasks has completed. 1) is addressed by Async/queue but 2) does not seem to have a canonical solution.\r\n\r\n```javascript\r\nvar stat_queue = async.queue( function(path, cb) { fs.stat(path, cb) }, 2 ); \r\n\r\nvar dirsize2 = function(path, cb) {\r\n\tvar sizesum = 0;\r\n\tfs.readdir(path, function(err, files) {\r\n\t\tvar pending = files.length;\r\n\t\tvar ret_err = null;\r\n\t\tfor(var i = 0; i < files.length ; ++i) { (function(i) {\r\n\t\t\tstat_queue.push(path + \"/\" + files[i], function(err, stats) {\r\n\t\t\t\tret_err = ret_err || err;\r\n\t\t\t\tif(err) console.log(err);\r\n\t\t\t\tif(!ret_err) {\r\n\t\t\t\t\tif (stats.isDirectory()) {\r\n\t\t\t\t\t\tdirsize2(path + \"/\" + files[i], function(err, size) {\r\n\t\t\t\t\t\t\tsizesum += size;\r\n\t\t\t\t\t\t\tif(--pending == 0) {\r\n\t\t\t\t\t\t\t\tcb(ret_err, sizesum);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tsizesum += stats.size\r\n\t\t\t\t\t\tif(--pending == 0) {\r\n\t\t\t\t\t\t\tcb(ret_err, sizesum);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})(i) }\r\n\t})\r\n}\r\n\r\ndirsize2(\".\", function(err, size) {\r\n\tconsole.log(\"dirsize2 = \" + size);\r\n})\r\n```\r\n\r\nFor completeness' sake - here is a variation with a Joiner class intended to \"hide\" the counter. Is such a facility already available in async?\r\n\r\n``` javascript\r\nvar Joiner = function(count) {\r\n\tthis.count = count;\r\n\tthis.cbCalled = false;\r\n\tthis.err = null;\r\n}\r\nJoiner.prototype.then = function(cb) {\r\n\tthis.cb = cb\r\n}\r\nJoiner.prototype.fun = function(err) {\r\n\tif(err) if(!this.err) this.err = err;\r\n\tif(this.err) {\r\n\t\tif(!this.cbCalled) { this.cbCalled = true; return this.cb(this.err) }\r\n\t}\r\n\tif(--this.count === 0) if(!this.cbCalled) { this.cbCalled = true; return this.cb(this.err) }\r\n}\r\n\r\nvar dirsize3 = function(path, cb) {\r\n\tvar sizesum = 0;\r\n\tfs.readdir(path, function(err, files) {\r\n\t\tvar join = new Joiner(files.length);\r\n\t\tfor(var i = 0; i < files.length ; ++i) { (function(i) {\r\n\t\t\tstat_queue.push(path + \"/\" + files[i], function(err, stats) {\r\n\t\t\t\tif (err) join.fun(err);\r\n\t\t\t\tif (join.err) return;\r\n\t\t\t\tif (stats.isDirectory()) {\r\n\t\t\t\t\tdirsize3(path + \"/\" + files[i], function(err, size) {\r\n\t\t\t\t\t\tsizesum += size;\r\n\t\t\t\t\t\tjoin.fun(null);\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsizesum += stats.size\r\n\t\t\t\t\tjoin.fun(null);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})(i) }\r\n\t\tjoin.then( function(err) { cb(err, sizesum) });\r\n\t})\r\n}\r\n\r\ndirsize3(\".\", function(err, size) {\r\n\tconsole.log(\"dirsize3 = \" + size);\r\n})\r\n\r\n```"
      },
      {
        "user": "aearly",
        "created_at": "2018-01-08T19:14:07Z",
        "body": "The `drain` callback of a `queue` will tell you `2)`.  It's called when a task completes and the queue is empty -- typically when the queue is done."
      },
      {
        "user": "sergiogiogio",
        "created_at": "2018-01-10T10:57:03Z",
        "body": "I can't use queue.drain because the queue is shared between multiple tasks/processes. I would need a way to explicitly designate a number of _subtasks_ and have the queue tell me when the specific set of subtasks has completed."
      },
      {
        "user": "aearly",
        "created_at": "2018-07-02T00:10:22Z",
        "body": "I misunderstood what you were attempting to do in your code.  I think you were using queue in the wrong way, trying to use it as an accessory to control flow, rather than the main source of control flow.  Here's a simpler way to accomplish what you want:\r\n\r\n```js\r\nfunction dirsize (dir, cb) {\r\n  let size = 0\r\n  const q = async.queue((file, taskCb) => {\r\n    fs.stat(file, (err, stats) => {\r\n      if (stats.isDirectory()) {\r\n        fs.readdir(file, (err, files) => {\r\n          q.push(files.map(f => path.join(file, f)))\r\n          taskCb()\r\n        })\r\n      }\r\n      size += stats.size\r\n      taskCb()\r\n    })\r\n  }, 2)\r\n\r\n  q.push(dir)\r\n\r\n  q.drain = () => {\r\n    cb(null, size)\r\n  }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 1508,
    "title": "When should i use ensureAsync",
    "created_at": "2017-12-27T05:09:56Z",
    "closed_at": "2018-05-21T04:39:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1508",
    "body": "Hi,\r\n\r\nSometimes i received \"Stack overflow\", after looking for answers i see the function \"ensureAsync\", it solved my problem.\r\n\r\nI'd like to know where this should be used, I have many asynchronous functions and sometimes I still get this error, so, which asynchronous function should I use \"ensureAsync\"?\r\n\r\nExample:\r\n`async.whilst(\r\n                () => {  return true; },\r\n                async.ensureAsync((callback) => {  callback(); }),\r\n                (err) => { callback(err, this.result()); }\r\n            );`",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1508/comments",
    "author": "FeeFelipe",
    "comments": [
      {
        "user": "Themayu",
        "created_at": "2018-04-10T03:43:15Z",
        "body": "`async.ensureAsync` is a wrapper for synchronous functions to convert them to asynchronous functions that can then be passed to other methods. The \"Stack Overflow\" error is caused by passing synchronous callbacks to the `async` library's functions, as JavaScript can only run so many operations per tick of the event loop — asynchronous functions are executed during the next tick of the loop, meaning that they don't bog down a single tick with their functions; useful for a) performing a task when certain data is retrieved and you don't know when it will be retrieved, and b) ensuring that executing a function possibly hundreds of times does not result in the script becoming extremely slow.\r\n\r\n\\* This is all based off of my own knowledge, of course, but the part about `async.ensureAsync` is correct to the documentation's description."
      },
      {
        "user": "Themayu",
        "created_at": "2018-04-10T03:44:06Z",
        "body": "TL;DR use `async.ensureAsync` when passing a synchronous function to the `async` library's functions."
      },
      {
        "user": "rajiff",
        "created_at": "2021-05-16T13:09:32Z",
        "body": "I think this should be documented in async documentation, especially on doWhilst, which takes test method in synchronous mode, but called on async lib"
      }
    ]
  },
  {
    "number": 1497,
    "title": "recursive call of callback says : Callback was already called",
    "created_at": "2017-11-16T14:27:45Z",
    "closed_at": "2017-11-20T02:16:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1497",
    "body": "Hi people , I use waterfall method for a series of async functions . Inside the first function I want to repeat the process after all process reaches end. So I pass a finalCallback from the first function to each one to be called in the end. It goes well for the first loop , but it throws an exception of : Callback was already called.\r\nHowever, I need to recall it with new input data . How can I do?\r\n\r\n**What version of async are you using?**\r\nnewest\r\n**Which environment did the issue occur in (Node version/browser version)**\r\nnode\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\nrecursive calling a function containing callback function\r\n**What did you expect to happen?**\r\nto repeat the callback with new data\r\n**What was the actual result?**\r\nCallback was already called\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1497/comments",
    "author": "ahadyekta",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-11-18T20:14:37Z",
        "body": "We don't support calling callbacks multiple times -- it leads to bugs and confusing control flow. If you need to run through part of a waterfall multiple times, break out that part into another function, and then use something like `eachSeries` or `doWhilst` to run it multiple times."
      }
    ]
  },
  {
    "number": 1493,
    "title": "How can I remove a task from the queue after a certain time?",
    "created_at": "2017-11-06T22:29:27Z",
    "closed_at": "2017-11-07T15:36:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1493",
    "body": "Hi,\r\n\r\nI'd like to remove a task from the queue after a certain time, but for some reason the `remove` method of the `Queue` object is never called. Here's my code:\r\n\r\n```js\r\nconst Queue = require('async/queue');\r\n\r\nconst q = new Queue((data, callback) => {\r\n    setTimeout(() => {\r\n        console.log('working');\r\n        callback();\r\n    }, 3000);\r\n}, 1);\r\n\r\nlet data = {id: 1};\r\n\r\nq.push(data, () => {\r\n    console.log('inside callback');\r\n});\r\n\r\n// works -- the task is removed from the queue\r\n// q.remove((worker) => {\r\n//     console.log('inside worker test', worker.data.id);\r\n//     if (worker.data.id == 1) {\r\n//         console.log('removing 1');\r\n//         return true;\r\n//     }\r\n//     return false;\r\n// });\r\n\r\n// doesn't work -- the test function never gets executed\r\nsetTimeout(() => {\r\n    console.log('inside setTimeout');\r\n    q.remove((worker) => {\r\n        console.log('inside worker test', worker.data.id);\r\n        if (worker.data.id == 1) {\r\n            console.log('removing 1');\r\n            return true;\r\n        }\r\n        return false;\r\n    });\r\n}, 1);\r\n```\r\n\r\nAs you can see above, `q.remove` is never called when it's inside a timeout, but works fine when it's outside. Is it because the worker has already started and cannot be removed even though the callback hasn't been called yet?\r\n\r\nMy node version is 8.8.1 and async version is 2.5.0.",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1493/comments",
    "author": "kodchi",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-11-07T06:44:36Z",
        "body": "`q.remove()` only works for items that are in the queue, not items that are running.  In this example, your item would have been shifted off and be processing after the delay -- the queue is checked for processing on the next tick after a `q.push()`.  After the timeout, the queue is empty, with one task running."
      },
      {
        "user": "kodchi",
        "created_at": "2017-11-07T15:36:36Z",
        "body": "OK, thank you!"
      }
    ]
  },
  {
    "number": 1485,
    "title": "get error using async/await in async.series callback",
    "created_at": "2017-10-23T07:59:19Z",
    "closed_at": "2017-10-29T00:03:10Z",
    "labels": [
      "docs",
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1485",
    "body": "<!--\r\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\r\n-->\r\n\r\n**What version of async are you using?**\r\n2.5\r\n**Which environment did the issue occur in (Node version/browser version)**\r\nnode V8.4.0  windows 10\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\n```\r\nasync.series([\r\n    async function(callback) {\r\n        // do some stuff ...\r\n        console.log('one')\r\n        await doSomething() //this line executed as desired\r\n        callback(null, 'one');\r\n    },\r\n    function(callback) {\r\n        // do some more stuff ...\r\n        console.log('two')\r\n        callback(null, 'two');\r\n    }\r\n],\r\n// optional callback\r\nfunction(err, results) {\r\n    if(err)\r\n    console.log(err)\r\n    // results is now equal to ['one', 'two']\r\n});\r\n```\r\n->\r\none\r\nTypeError: callback is not a function\r\n\r\n**What did you expect to happen?**\r\ncodes run as async/await mechanism\r\n**What was the actual result?**\r\nget \"TypeError: callback is not a function\"\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1485/comments",
    "author": "goyzhang",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-10-23T18:42:38Z",
        "body": "`async` functions do not get passed a callback.  Instead, simply return a value.\r\n\r\n```js\r\nasync.series([\r\n    async function() {\r\n        // do some stuff ...\r\n        console.log('one')\r\n        await doSomething() //this line executed as desired\r\n        return 'one'  //<---\r\n    },\r\n    //...\r\n```"
      }
    ]
  },
  {
    "number": 1482,
    "title": "Which difference?",
    "created_at": "2017-10-11T18:54:25Z",
    "closed_at": "2017-10-16T02:28:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1482",
    "body": "Which difference?\r\n\r\n```\r\ntasks = [ fn, fn, ... ]\r\nasync.parallel(tasks)\r\n```\r\n\r\nor\r\n```\r\nasync test () {\r\ntasks = [ fn, fn, ... ]\r\nawait tasks\r\n}\r\n```\r\nI do not understand, why I should use async.js instead simple async/await?\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1482/comments",
    "author": "aleks63",
    "comments": [
      {
        "user": "wartab",
        "created_at": "2017-10-13T08:37:46Z",
        "body": "Support for roughly 25% of browsers?"
      },
      {
        "user": "aleks63",
        "created_at": "2017-10-14T00:09:29Z",
        "body": "No, for node.js only"
      },
      {
        "user": "aearly",
        "created_at": "2017-10-16T02:28:25Z",
        "body": "One uses callbacks, the other uses promises.  It comes down to personal preference and what type of libraries you'll be interfacing with.\r\n\r\nAlso note it should be:\r\n\r\n```js\r\nasync test () {\r\n  tasks = [ fn, fn, ... ]\r\n  await Promise.all(tasks)\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 1480,
    "title": "async.waterfall breaks when given an async function (node 8)",
    "created_at": "2017-10-05T00:37:56Z",
    "closed_at": "2017-10-30T01:15:14Z",
    "labels": [
      "docs",
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1480",
    "body": "**What version of async are you using?**\r\n2.5.0\r\n\r\n**Which environment did the issue occur in (Node version/browser version)**\r\nNode 8\r\n\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\n```\r\nasync=require('async')\r\n\r\nasync function myFirstFunction(callback) {\r\n     callback(null, 'one', 'two');\r\n}\r\n\r\nfunction mySecondFunction(arg1, arg2, callback) {\r\n     // arg1 now equals 'one' and arg2 now equals 'two'\r\n     callback(null, 'three');\r\n}\r\n\r\nasync function myLastFunction(arg1, callback) {\r\n     // arg1 now equals 'three'\r\n     callback(null, 'done');\r\n}\r\n \r\nasync.waterfall([\r\n     myFirstFunction,\r\n     mySecondFunction,\r\n     myLastFunction,\r\n], function (err, result) {\r\n     // result now equals 'done'\r\n     console.log(err, result)\r\n});\r\n```\r\n\r\n**What did you expect to happen?**\r\nto not have an exception\r\n\r\n**What was the actual result?**\r\n```\r\n> TypeError: callback is not a function\r\n    at myFirstFunction (repl:2:5)\r\n    at /Users/scott/node_modules/async/dist/async.js:143:27\r\n    at /Users/scott/node_modules/async/dist/async.js:21:12\r\n    at nextTask (/Users/scott/node_modules/async/dist/async.js:5297:14)\r\n    at Object.waterfall (/Users/scott/node_modules/async/dist/async.js:5307:5)\r\n    at repl:1:7\r\n    at ContextifyScript.Script.runInThisContext (vm.js:44:33)\r\n    at REPLServer.defaultEval (repl.js:239:29)\r\n    at bound (domain.js:301:14)\r\n    at REPLServer.runBound [as eval] (domain.js:314:12) undefined\r\n```",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1480/comments",
    "author": "sjungwirth",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-10-05T00:53:26Z",
        "body": "Callbacks are not passed to `async` functions, instead, simply return a value."
      },
      {
        "user": "sjungwirth",
        "created_at": "2017-10-05T00:58:06Z",
        "body": "In the case of the first function above, where more than one argument is passed to `callback` in `myFirstFunction`, should we instead return an array?\r\n"
      },
      {
        "user": "aearly",
        "created_at": "2017-10-05T01:00:57Z",
        "body": "Yeah, you could do something like:\r\n\r\n```js\r\nasync.waterfall([\r\n  // ...\r\n  async function (arg1, arg2) {\r\n    //...\r\n    const arg3 = await foo()\r\n    return [arg1, arg2, arg3]\r\n  },\r\n  function ([arg1, arg2, arg3], callback) {\r\n    //...\r\n  }\r\n```"
      },
      {
        "user": "chak774",
        "created_at": "2019-01-04T02:40:38Z",
        "body": "Then how to return error? Just using throw?"
      },
      {
        "user": "josefanostylus",
        "created_at": "2019-12-05T22:42:04Z",
        "body": "Any answers to the above question? I believe to bail when encountered an error in a async function , you still need to call the \"next\" callback"
      },
      {
        "user": "pravynandas",
        "created_at": "2020-04-09T13:54:29Z",
        "body": "How about this? \r\n```javascript\r\nasync.waterfall([\r\n  // ...\r\n  async function (arg1, arg2, callback) {\r\n    //...\r\n    try {\r\n      const arg3 = await foo()\r\n      return [arg1, arg2, arg3]\r\n    } catch (err) {\r\n      callback('An error occured:' + err.message);\r\n    }\r\n  },\r\n  function ([arg1, arg2, arg3], callback) {\r\n    //...\r\n  }\r\n```"
      },
      {
        "user": "aearly",
        "created_at": "2020-04-09T17:51:18Z",
        "body": "`async` functions don't get passed callbacks.  Just `throw` an error."
      },
      {
        "user": "pravynandas",
        "created_at": "2020-04-09T18:07:57Z",
        "body": "Thanks."
      },
      {
        "user": "kindacoder",
        "created_at": "2022-06-07T09:25:22Z",
        "body": "IIFE can be helpful here.\r\nHere is how i used it.\r\n\r\n```\r\nfunction doSomethingAsynchronously(_callback) {\r\n    ;(async () => {\r\n        await callAnAsyncFunction();\r\n    })()\r\n    _callback(null)\r\n  }\r\n```\r\n\r\n"
      },
      {
        "user": "aearly",
        "created_at": "2022-06-07T17:08:08Z",
        "body": "> IIFE can be helpful here. Here is how i used it.\r\n> \r\n> ```\r\n> function doSomethingAsynchronously(_callback) {\r\n>     ;(async () => {\r\n>         await callAnAsyncFunction();\r\n>     })()\r\n>     _callback(null)\r\n>   }\r\n> ```\r\n\r\nThis wont do what you expect.  The `_callback` will be called before the async function returns.  Moving the callback inside the async IIFE will work, though."
      },
      {
        "user": "kindacoder",
        "created_at": "2022-06-07T17:50:12Z",
        "body": "a"
      },
      {
        "user": "theshubhamjoshi",
        "created_at": "2022-07-26T11:50:42Z",
        "body": "b"
      },
      {
        "user": "haayhappen",
        "created_at": "2022-11-11T18:35:49Z",
        "body": "c"
      }
    ]
  },
  {
    "number": 1479,
    "title": "Node Js socket.io not found",
    "created_at": "2017-10-02T19:17:57Z",
    "closed_at": "2017-10-07T23:23:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1479",
    "body": "<!--\r\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\r\n-->\r\n\r\n**What version of async are you using?**\r\n\r\n**Which environment did the issue occur in (Node version/browser version)**\r\nnode version\r\n\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\n\r\n**What did you expect to happen?**\r\nrun of server\r\n\r\n**What was the actual result?**\r\nError: Cannot find module 'socket.io'\r\n    at Function.Module._resolveFilename (module.js:325:15)\r\n    at Function.Module._load (module.js:276:25)\r\n    at Module.require (module.js:353:17)\r\n    at require (internal/module.js:12:17)\r\n    at Object.<anonymous> (C:\\xampp\\htdocs\\quechno\\index.js:3:10)\r\n    at Module._compile (module.js:409:26)\r\n    at Object.Module._extensions..js (module.js:416:10)\r\n    at Module.load (module.js:343:32)\r\n    at Function.Module._load (module.js:300:12)\r\n    at Function.Module.runMain (module.js:441:10)\r\n\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1479/comments",
    "author": "sanjayrajpurohit36",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-10-02T20:19:32Z",
        "body": "Sounds like you need to `npm install socket.io`"
      }
    ]
  },
  {
    "number": 1478,
    "title": "Support question - read remaining number of tasks in async.queue",
    "created_at": "2017-09-30T18:59:23Z",
    "closed_at": "2017-10-01T20:49:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1478",
    "body": "I am using async.queue like so:\r\n\r\n```js\r\nconst q = async.queue((task, cb => task(cb));\r\n```\r\n\r\nHow can I find out during debugging how many tasks remain on the queue (and maybe how many have completed?)?\r\n\r\nI used `util.inspect()` to get the properties on the queue\r\n\r\n```\r\n { _tasks: DLL { tail: null, head: null, length: 0 },\r\n  concurrency: 3,\r\n  payload: 1,\r\n  saturated: [Function: noop],\r\n  unsaturated: [Function: noop],\r\n  buffer: 0.75,\r\n  empty: [Function: noop],\r\n  drain: [Function],\r\n  error: [Function: noop],\r\n  started: false,\r\n  paused: false,\r\n  push: [Function: push],\r\n  kill: [Function: kill],\r\n  unshift: [Function: unshift],\r\n  remove: [Function: remove],\r\n  process: [Function: process],\r\n  length: [Function: length],\r\n  running: [Function: running],\r\n  workersList: [Function: workersList],\r\n  idle: [Function: idle],\r\n  pause: [Function: pause],\r\n  resume: [Function: resume] }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1478/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "ORESoftware",
        "created_at": "2017-09-30T19:10:43Z",
        "body": "also, as an aside, curious about how to remove the drain callback, maybe like so?\r\n\r\n```js\r\nq.drain = function(){\r\n   q.drain = null; // this doesn't seem quite right?\r\n};\r\n```\r\nalso wondering if there is a way to use multiple drain callbacks.\r\n\r\nthanks\r\n"
      },
      {
        "user": "aearly",
        "created_at": "2017-10-01T20:49:52Z",
        "body": "`q.length()` will return the length of the queue. `q._tasks.toArray()` will give you a list of tasks in the queue.  There's no way to tell how many have completed, unless you track that yourself.\r\n\r\nTo remove the drain callback:  \r\n\r\n```js\r\nq.drain = function () {}\r\n```\r\n\r\nNo way to use multiple drain callbacks, but you can call multiple functions in the single drain callback."
      },
      {
        "user": "ORESoftware",
        "created_at": "2017-10-01T21:26:26Z",
        "body": "@aearly thanks, got it, except:\r\n\r\nq.length() will return the length of the queue. q._tasks.toArray()\r\n\r\nwhat's the difference between those two? the length and the number of tasks? aren't they the same?"
      },
      {
        "user": "aearly",
        "created_at": "2017-10-01T21:32:51Z",
        "body": "They are the same.  Length of the queue = number of tasks in the queue."
      },
      {
        "user": "ORESoftware",
        "created_at": "2017-10-01T23:44:33Z",
        "body": "got it, thank you...I think the docs could be improved here, how can we improve them with a PR?"
      },
      {
        "user": "ORESoftware",
        "created_at": "2019-07-28T02:23:59Z",
        "body": "Still don't know what the diff is between q.length() and q.running()"
      }
    ]
  },
  {
    "number": 1477,
    "title": "document and best practice request",
    "created_at": "2017-09-29T23:25:54Z",
    "closed_at": "2017-10-01T20:37:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1477",
    "body": "First of all, thanks so much for this great library.  I use this all over the place in my node applications mainly for flow control but the queue and limiters get used a lot as well. \r\n\r\nMy issue is that I have a few files with 10-20 series methods and the entire file is just way to long.  I'd like to modularize the code a little bit and have each series entry in a separate file.  Hopefully you can point me to some examples like this with industry standard best practices.  \r\n\r\nMost basic example is something like below.  This works but I'm just wondering if this is how it _should_ be done.  Should I handle the errors within the modules (like module one) or should the modules pass callback(err) (like module two) if it encounters an error?  I'm thinking the later to keep everything the callback way.  \r\n\r\nThanks!\r\n\r\nFile oneModule.js\r\n```\r\nmodule.exports =  function one(callback) {\r\n    console.log('one!');\r\n    /*\r\n        do stuff\r\n    */\r\n    if (err) {\r\n        throw new Error('Error from doing stuff');\r\n    }\r\n    callback();        \r\n};\r\n```\r\nFile twoModule.js\r\n```\r\nmodule.exports =  function two(callback) {\r\n    console.log('two!');\r\n    /*\r\n        do stuff\r\n    */\r\n    if (err) {\r\n        return callback('Error doing some stuff');\r\n    }\r\n    callback();\r\n         \r\n};\r\n```\r\nFile main.js\r\n```\r\nvar oneRequired = require('./one');\r\nvar twoRequired = require('./two');\r\n\r\nasync.series([oneRequired, twoRequired], function done(err, results) {\r\n    console.log('done!', err, results);\r\n});\r\n```",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1477/comments",
    "author": "ktravelet",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-10-01T20:37:54Z",
        "body": "If your `series` flows are getting too complicated, I recommend looking at `waterfall` or `auto`.\r\n\r\nAlso, a function passed to `series` could also use `series` itself, could help in breaking down a flow into logical chunks.\r\n\r\nAs far as how to separate functions across source files, there really is no \"best practice\" there -- it's entirely up to you. I like to break things up when theres more than ~200 lines in a file, some function will be re-used in several places, the function will be likely be changed or swapped out with something else, or I want to be able to test a function in isolation. "
      }
    ]
  },
  {
    "number": 1474,
    "title": "async.reflect -> error.message is undefined",
    "created_at": "2017-09-22T20:11:35Z",
    "closed_at": "2017-09-23T08:25:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1474",
    "body": "<!--\r\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\r\n-->\r\n\r\n**What version of async are you using?**\r\n2.5.0\r\n\r\n**Which environment did the issue occur in (Node version/browser version)**\r\nNode 6.11.1\r\n\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\n```\r\nasync.series([\r\n    async.reflect(callback => callback(null, 'one')),\r\n    async.reflect(callback => callback(new Error('bad stuff happened'))),\r\n    async.reflect(callback => callback(null, 'two'))\r\n  ],\r\n  (err, results) => {\r\n    console.log(results[1].message)\r\n  });\r\n```\r\n\r\n**What did you expect to happen?**\r\noutput should be `bad stuff happened`\r\n\r\n**What was the actual result?**\r\noutput is `undefined`\r\n\r\nasync without `async.reflect`:\r\n\r\n```\r\nasync.series([\r\n    callback => callback(null, 'one'),\r\n    callback => callback(new Error('bad stuff happened')),\r\n    callback => callback(null, 'two')\r\n  ],\r\n  (err, results) => {\r\n    console.log(err.message)\r\n  });\r\n```\r\nOutput contains `bad stuff happened`",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1474/comments",
    "author": "AlexZeitler",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-09-22T21:50:23Z",
        "body": "You should be looking for `results[1].error.message`, not `results[1].message`.  `reflect` makes the wrapped function callback with `{ error: error }` or `{ value: value }`"
      },
      {
        "user": "AlexZeitler",
        "created_at": "2017-09-23T08:25:08Z",
        "body": "Thanks, `results[1].error.message` did the trick."
      }
    ]
  },
  {
    "number": 1458,
    "title": "async.auto & the curious case of try ... catch",
    "created_at": "2017-07-26T20:08:39Z",
    "closed_at": "2017-07-26T21:23:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1458",
    "body": "<!--\r\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\r\n-->\r\n\r\n**What version of async are you using?**\r\nv2.5.0\r\n**Which environment did the issue occur in (Node version/browser version)**\r\nv6.10.3\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\n```javascript\r\nasync.auto({\r\n  returnOne: (callback) => callback(null, 1),\r\n  tryCatch: [\"returnOne\", (results, callback) => {\r\n    try {\r\n      assert(results.returnOne === 1);\r\n      return callback(null);\r\n    } catch (err) {\r\n      console.log(`Caught an error: ${err.message}`);\r\n      return callback(err);\r\n    }\r\n  }],\r\n}, (err, results) => {\r\n  assert(results.returnOne !== 1);\r\n  console.log(`All Done!`);\r\n});\r\n```\r\n**What did you expect to happen?**\r\nThe assert inside the final aync.auto callback fails and throws an error which is not caught and stops the Node.js process. In my real world example of this, we are testing a block of code within Mocha, which handles the error and reports that the test failed with information about the assertion that caused the failure.\r\n\r\n**What was the actual result?**\r\nTry / Catch from the previous auto step catches the error and calls the tryCatch callback a second time, resulting in a different error:\r\n```\r\nasync/dist/async.js:903\r\n        if (fn === null) throw new Error(\"Callback was already called.\");\r\n                         ^\r\nError: Callback was already called.\r\n```",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1458/comments",
    "author": "trvra",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-07-26T21:06:02Z",
        "body": "```js\r\ntry {\r\n  //...\r\n  return callback(null, result)\r\n} catch (e) {\r\n  //..\r\n  return callback(e)\r\n}\r\n```\r\n\r\nIs a huge anti-pattern because if something throws later in the callback chain (e.g. your assert), it will be caught in the `try` block, causing a double callback in the `catch`.  Correct way:\r\n\r\n```js\r\nlet err, result\r\ntry {\r\n  result = doSomething()\r\n} catch (e) {\r\n  err = e\r\n}\r\ncallback(err, result)\r\n```"
      },
      {
        "user": "trvra",
        "created_at": "2017-07-26T21:23:22Z",
        "body": "@aearly Makes sense, thanks for the tip!\r\n\r\n(Also, hello! 👋)"
      },
      {
        "user": "aearly",
        "created_at": "2017-07-26T21:49:12Z",
        "body": "👋😊"
      }
    ]
  },
  {
    "number": 1442,
    "title": "Canceling an `async.retry`",
    "created_at": "2017-06-26T22:40:05Z",
    "closed_at": "2017-07-02T21:27:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1442",
    "body": "There doesn't seem to be a way to cancel an outstanding `async.retry` task:\r\n\r\n```js\r\nvar _task = wrapAsync(task);\r\nvar attempt = 1;\r\nfunction retryAttempt() {\r\n        _task(function(err) {\r\n            if (err && attempt++ < options.times &&\r\n                (typeof options.errorFilter != 'function' ||\r\n                    options.errorFilter(err))) {\r\n                \r\n                // not returned to caller, so no way to `clearTimeout`\r\n                setTimeout(retryAttempt, options.intervalFunc(attempt));\r\n\r\n            } else {\r\n                callback.apply(null, arguments);\r\n            }\r\n        });\r\n}\r\nretryAttempt();\r\n```\r\n\r\nInstead, you have to add logic to an `errorFilter` function to check if the task has been canceled. But that's not the same since you have to wait for the timeout to expire before your `errorFilter` will run. ",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1442/comments",
    "author": "gabegorelick",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-06-27T20:48:25Z",
        "body": "Doing this at in the `errorFilter` will be as good as it gets.  There is no agreed-upon way to cancel an async request. Every Async method cannot be canceled -- all you can do is ignore the result."
      },
      {
        "user": "gabegorelick",
        "created_at": "2017-06-27T23:09:35Z",
        "body": "Totally understand if you don't want to implement this since there's no consensus in the community for how to do this, but one way would be to use an EventEmitter to output the timeout IDs. Something like\r\n```js\r\nexport default function retry(opts, task, callback) {\r\n   // ...snip\r\n\r\n   const emitter = new EventEmitter(); \r\n\r\n    var _task = wrapAsync(task);\r\n\r\n    var attempt = 1;\r\n    function retryAttempt() {\r\n        _task(function(err) {\r\n            if (err && attempt++ < options.times &&\r\n                (typeof options.errorFilter != 'function' ||\r\n                    options.errorFilter(err))) {\r\n                const timeoutID = setTimeout(retryAttempt, options.intervalFunc(attempt));\r\n                emitter.emit('retry', timeoutID);\r\n            } else {\r\n                callback.apply(null, arguments);\r\n            }\r\n        });\r\n    }\r\n\r\n    // would have to ensure this is called on nextTick if wrapAsync doesn't already do that\r\n    retryAttempt();\r\n    \r\n    return emitter;\r\n}\r\n```"
      },
      {
        "user": "aearly",
        "created_at": "2017-07-02T21:27:46Z",
        "body": "The event emitter is a clever solution to your use-case.  It's a bit un-Async-ey though.  Mixing event emitters and callbacks always tends to get confusing control-flow wise.\r\n\r\nAlso, we have Plans™ for the currently-unused/implemented return value for Async functions..."
      }
    ]
  },
  {
    "number": 1433,
    "title": "TypeError: wrapAsync(...) is not a function with node 8.0.0",
    "created_at": "2017-06-11T03:21:56Z",
    "closed_at": "2017-06-11T03:40:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1433",
    "body": "<!--\r\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\r\n-->\r\n\r\n**What version of async are you using?**\r\n\r\n2.4.1\r\n\r\n**Which environment did the issue occur in (Node version/browser version)**\r\n\r\nnode 8.0.0\r\n\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\n\r\n```javascript\r\nasync=require('async')\r\n_=require('underscore')\r\nasync.parallel(_.range(10), function(iter, cb) { cb(null); }, function(err) { console.log(err); })\r\n```\r\n\r\n**What did you expect to happen?**\r\n\r\nshould print null.\r\n\r\n**What was the actual result?**\r\n```\r\nTypeError: wrapAsync(...) is not a function\r\n    at /usr/local/lib/node_modules/async/dist/async.js:3830:24\r\n    at eachOfArrayLike (/usr/local/lib/node_modules/async/dist/async.js:1003:9)\r\n    at eachOf (/usr/local/lib/node_modules/async/dist/async.js:1051:5)\r\n    at _parallel (/usr/local/lib/node_modules/async/dist/async.js:3829:5)\r\n    at Object.parallelLimit [as parallel] (/usr/local/lib/node_modules/async/dist/async.js:3912:5)\r\n    at repl:1:7\r\n    at ContextifyScript.Script.runInThisContext (vm.js:44:33)\r\n    at REPLServer.defaultEval (repl.js:239:29)\r\n    at bound (domain.js:301:14)\r\n    at REPLServer.runBound [as eval] (domain.js:314:12)\r\n```",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1433/comments",
    "author": "tlbtlbtlb",
    "comments": [
      {
        "user": "tlbtlbtlb",
        "created_at": "2017-06-11T03:40:49Z",
        "body": "Oops, my mistake."
      },
      {
        "user": "andre0799",
        "created_at": "2017-07-26T18:20:31Z",
        "body": "Could you please share your mistake @tlbtlbtlb ? That would be helpful to others that get the same error."
      },
      {
        "user": "ghost",
        "created_at": "2017-07-27T15:13:49Z",
        "body": "@tlbtlbtlb What was the solution to this error?  I am getting the same error.  Thanks. "
      },
      {
        "user": "TheRationalizer",
        "created_at": "2017-08-27T11:33:43Z",
        "body": "\"Oops, my mistake\" - That helped me solve the problem too, thanks for elaborating."
      },
      {
        "user": "samhmills",
        "created_at": "2017-09-01T11:27:05Z",
        "body": "@tlbtlbtlb would you still care to elaborate? Thanks\r\n\r\nEdit: I solved my problem by wrapping my async function within an anonymous function:\r\n```js\r\nasync.parallel([ function(callback) {\r\n    self.queues[\"genetic\"].destroy(callback);\r\n}\r\n```\r\nMay not solve your specific issue but it solved mine!"
      },
      {
        "user": "tlbtlbtlb",
        "created_at": "2017-09-01T15:08:16Z",
        "body": "`async.parallel` takes an array of functions. I was calling it like `async.each`."
      },
      {
        "user": "TheRationalizer",
        "created_at": "2017-09-01T15:11:15Z",
        "body": "Thanks 👍 "
      },
      {
        "user": "likping",
        "created_at": "2019-04-13T06:41:48Z",
        "body": "How to solve TypeError: wrapAsync(...) is not a function"
      },
      {
        "user": "aearly",
        "created_at": "2019-04-13T22:51:13Z",
        "body": "You're passing an undefined function as an iteratee, e.g. `async.map(array, undefined, callback)`.  Check your code in the call stack."
      }
    ]
  },
  {
    "number": 1431,
    "title": "Final callback not executed!!",
    "created_at": "2017-06-08T12:44:22Z",
    "closed_at": "2017-06-08T16:54:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1431",
    "body": "\r\nVersion: 2.4.1\r\n\r\nEnvironment: Browser\r\n\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\n```ts\r\nasync.each(seriesArray, (series1: SeriesConfig) => {\r\n                    this.dataStore.series[series1.name] = this.setSerieData(series1);               \r\n            }, (error?: Error) => {\r\n                if(error) console.error(error.message);\r\n                this.setState({ dataStore: this.dataStore, isLoaded: true });\r\n            });\r\n```\r\nThe final callback is not executed!\r\n``` ts\r\n           (error?: Error) => {\r\n                // tslint:disable-next-line no-console\r\n                if(error) console.error(error.message);\r\n                this.setState({ dataStore: this.dataStore, isLoaded: true });\r\n            });\r\n```\r\n\r\n**What did you expect to happen?**\r\nI expected the state to be updated with new dataStore\r\n**What was the actual result?**\r\nThe final callback is never executed",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1431/comments",
    "author": "djkwagala",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-06-08T16:44:01Z",
        "body": "You're missing a callback in your iteratee function."
      },
      {
        "user": "djkwagala",
        "created_at": "2017-06-08T16:53:33Z",
        "body": "Thanks, this can be closed. you need to indicate this clearly on the documentation. \r\nI had thought that the callback on the iterator is the one executed for each and every item. and the 3rd Parameter( finalCallback) would be auto executed without needing to indicate callback() in the iterator.\r\nThanks once again."
      }
    ]
  },
  {
    "number": 1421,
    "title": "Queue not execute when length hight",
    "created_at": "2017-05-23T09:27:12Z",
    "closed_at": "2017-05-30T16:16:49Z",
    "labels": [
      "question",
      "queue"
    ],
    "url": "https://github.com/caolan/async/issues/1421",
    "body": "I use async version 2.4.0: \r\n\r\nI have a issues with push 1000 task to queue concurency 100,\r\n\r\nhere this is code: \r\n```js\r\nlet index = 0;\r\nlet consumerGroup = new ConsumerGroup(consumerOptions, config.topic);\r\nconsumerGroup.on('error', onError);\r\n\r\nlet queue = async.queue((task, callback) => {\r\n  parse(task).then(() => {\r\n    debug('------>>>> Done task: ');\r\n    callback();\r\n  }).catch((e) => {\r\n    debug('---Have error task!!', e);\r\n    callback();\r\n  });\r\n}, 100);\r\nlet state = false;\r\nqueue.drain = function () {\r\n  if (state) {\r\n    state = false;\r\n    debug('Resume consumer');\r\n    consumerGroup.resume();\r\n  }\r\n};\r\nqueue.error = function(e){\r\n\r\n}\r\nconsumerGroup.on('message', (message) => {\r\n  if (!state && message) {\r\n    debug('Pause consmer')\r\n    consumerGroup.pause();\r\n    state = true;\r\n  }\r\n  queue.push(message, (e) => {\r\n    if (e) {\r\n      debug('==> Have error', e);\r\n    }\r\n    if (state && queue.length() == 0) {\r\n      state = false;\r\n      debug('Resume consumer');\r\n      consumerGroup.resume();\r\n    } else {\r\n      debug('Finished! ' + queue.length());\r\n    }\r\n  });\r\n});\r\nsetInterval(() => {\r\n  if (state && queue.length() == 0) {\r\n    state = false;\r\n    debug('Resume consumer');\r\n    consumerGroup.resume();\r\n  } else {\r\n    debug('Finished! ' + queue.length());\r\n  }\r\n}, 10 * 60 * 1000);\r\n```\r\nand debug is:\r\n```shell\r\n\r\n27|consume | Tue, 23 May 2017 07:29:52 GMT Consumer:index Finished! 1006\r\n27|consume | Tue, 23 May 2017 07:39:52 GMT Consumer:index Finished! 1006\r\n27|consume | Tue, 23 May 2017 07:49:52 GMT Consumer:index Finished! 1006\r\n27|consume | Tue, 23 May 2017 07:59:52 GMT Consumer:index Finished! 1006\r\n27|consume | Tue, 23 May 2017 08:09:52 GMT Consumer:index Finished! 1006\r\n27|consume | Tue, 23 May 2017 08:19:52 GMT Consumer:index Finished! 1006\r\nđásd27|consume | Tue, 23 May 2017 08:29:52 GMT Consumer:index Finished! 1006\r\n27|consume | Tue, 23 May 2017 08:39:52 GMT Consumer:index Finished! 1006\r\n27|consume | Tue, 23 May 2017 08:49:52 GMT Consumer:index Finished! 1006\r\n27|consume | Tue, 23 May 2017 08:59:52 GMT Consumer:index Finished! 1006\r\n\r\n```\r\nconsumerGroup is kafka-node module, this is module working with kafka, and message event received is a block messages. \r\n\r\nThe queue length is big and not execute. Please help me debug this.\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1421/comments",
    "author": "hieuit7",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-05-23T21:02:38Z",
        "body": "Sounds like you have an issue with multiple callbacks:\r\n\r\n```js\r\n  parse(task).then(() => {\r\n    debug('------>>>> Done task: ');\r\n    callback();\r\n  }).catch((e) => {\r\n    debug('---Have error task!!', e);\r\n    callback();\r\n  });\r\n```\r\n\r\nThis code is vulnerable to multiple callbacks if an error is thrown later on in the `callback()` chain.  You can `asyncify` the `parse` function -- that will protect against this:\r\n\r\n```js\r\n  async.asyncify(parse)(task, (err) => {\r\n    if(err) {\r\n      debug('---Have error task!!', e);\r\n      return callback();\r\n    }\r\n    debug('------>>>> Done task: ');\r\n    callback();\r\n  });\r\n```\r\n\r\nor just:\r\n\r\n```js\r\nlet  queue = async.queue(async.asyncify(parse), 100)\r\n```"
      },
      {
        "user": "hieuit7",
        "created_at": "2017-05-24T03:22:50Z",
        "body": "I use Promise for parse function. Only then or catch error occur.\r\n\r\nOn log debug, haven't debug error through out!"
      },
      {
        "user": "alasdairhurst",
        "created_at": "2017-05-30T13:46:08Z",
        "body": "@hieuit7 if it's a promise then you can call the callback after the promise chain. at the moment, if it's inside the promise chain and it throws, then it will get caught by the catch. Try using finally.\r\n\r\n```\r\n  parse(task).then(() => {\r\n    debug('------>>>> Done task: ');\r\n  }).catch((e) => {\r\n    debug('---Have error task!!', e);\r\n  })\r\n  .finally(callback);\r\n```"
      },
      {
        "user": "hieuit7",
        "created_at": "2017-05-30T16:16:49Z",
        "body": "I'm sorry, this is my wrong.\r\n\r\nThe parse function has been return without resolve or reject call back by logic bussiness. I will close this thread.\r\nThank you for help!"
      }
    ]
  },
  {
    "number": 1410,
    "title": "Question - async.series / async.parallel - but no data accumulation",
    "created_at": "2017-04-19T19:56:00Z",
    "closed_at": "2017-04-19T20:17:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1410",
    "body": "Are there equivalents to async.series / async.parallel, but which do not accumulate data\r\n\r\ne.g., we have\r\n\r\n`async.series([] | {}, function(err, results){});`\r\n\r\nI am looking for\r\n\r\n`async.seriesX([] | {}, function(err){});`\r\n\r\nI assume this might save a small amount of memory, by avoiding creating an object in the async library behind the scenes.",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1410/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "ex1st",
        "created_at": "2017-04-19T20:00:06Z",
        "body": "```javascript\r\nasync.eachSeries(arr, (fn, cb) => { fn(cb); }, function(err){});\r\n```"
      },
      {
        "user": "aearly",
        "created_at": "2017-04-19T20:17:45Z",
        "body": "Yep, `each` and family work with objects, too.  `series` uses `eachOfSeries`  in its implementation."
      },
      {
        "user": "ORESoftware",
        "created_at": "2017-04-19T20:29:10Z",
        "body": "Ummm, async.eachSeries does not have the same signature as async.series. Y'all have confused me. @ex1st's solution is not right for my needs.\r\n\r\n\r\n```js\r\nasync.series([\r\n\r\n\r\n], function(err,results){\r\n\r\n});\r\n```\r\nand\r\n\r\n```js\r\nasync.eachSeries([], function(item,cb){\r\n\r\n}, function(err){\r\n\r\n});\r\n```\r\n\r\nI am looking for\r\n\r\n```js\r\nasync.seriesX([\r\n\r\n\r\n], function(err){   // <<< no results passed\r\n\r\n});\r\n```"
      },
      {
        "user": "ex1st",
        "created_at": "2017-04-19T20:34:59Z",
        "body": "@ORESoftware \r\nNope, eachSeries is best solution. Just try."
      },
      {
        "user": "ORESoftware",
        "created_at": "2017-04-19T21:14:07Z",
        "body": "I don't think it will work, because I have this style:\r\n\r\n```js\r\nasync.series([\r\n   function(cb){\r\n\r\n  },\r\n  function(cb){\r\n\r\n  },\r\n  function(cb}{\r\n\r\n }\r\n], function(err,results){\r\n\r\n\r\n});\r\n```\r\n\r\nI don't need to map the functions, I just need to run the functions in series. Can you explain how that would work with eachSeries instead?  Could I omit the mapping function?"
      },
      {
        "user": "ex1st",
        "created_at": "2017-04-19T21:19:42Z",
        "body": "You can add your method:\r\n```javascript\r\nasync.seriesX = function (fns, cb) {\r\n  async.eachOfSeries(fns, (fn, key, cb) => { fn(cb); }, cb);\r\n}\r\n\r\nasync.parallelX = function (fns, cb) {\r\n  async.eachOf(fns, (fn, key, cb) => { fn(cb); }, cb);\r\n}\r\n\r\nasync.seriesX([] | {}, function(err){});\r\n```"
      },
      {
        "user": "ORESoftware",
        "created_at": "2017-04-19T21:38:01Z",
        "body": "Ok let me give it a shot, thanks"
      }
    ]
  },
  {
    "number": 1387,
    "title": "How can use implicit args in auto and autoinject ",
    "created_at": "2017-03-18T06:47:22Z",
    "closed_at": "2017-03-19T11:23:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1387",
    "body": "\r\nHi,\r\nHow can i use implicit args list for auto and autoinject.\r\nI use async 2.1.5 and nodeJs 4.2.6\r\n\r\neg:\r\n\r\nvar args = [ 'arg1', 'arg2', 'arg3' ] ,\r\n      funcList = {\r\n                 arg1: function(cb){ cb(null,'xyz')  },\r\n                 arg2: function(cb){ cb(null,'xyz')  },\r\n                 arg3: function(cb){ cb(null,'xyz')  }\r\n            }\r\n\r\nfuncList[ 'arg4' ] = [args, function( r, cb ){\r\n     // use or change  r[ args[0] ] or r[ args[1] ] ...\r\n}]\r\n\r\nasync.auto(funcList, callback);\r\n\r\nat the run time i get Error: async.auto task `arg4` has a non-existent dependency `arg1, arg2, arg3` in arg1, arg2, arg3",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1387/comments",
    "author": "mjafarpour",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-03-18T08:59:10Z",
        "body": "Change it to:\r\n\r\n```js\r\nfuncList[ 'arg4' ] = args.concat(function( r, cb ){\r\n  // use or change r[ args[0] ] or r[ args[1] ] ...\r\n})\r\n```"
      },
      {
        "user": "mjafarpour",
        "created_at": "2017-03-18T12:32:03Z",
        "body": "Thanks, it's worked with auto method but how can use it for autoinject?"
      },
      {
        "user": "aearly",
        "created_at": "2017-03-18T19:09:19Z",
        "body": "You can't have dynamic args in autoInject.  All args have to be explicit in the function definitions."
      }
    ]
  },
  {
    "number": 1374,
    "title": "es7 await with async",
    "created_at": "2017-02-22T07:05:34Z",
    "closed_at": "2017-02-25T22:12:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1374",
    "body": "can I use this following syntax if final callback not provide?\r\n\r\n```\r\nlet result = await async.waterfall([\r\n    async.apply(fs.readFile, filename, \"utf8\"),\r\n    async.asyncify(function (contents) {\r\n        return db.model.create(contents);\r\n    }),\r\n    function (model, next) {\r\n        // `model` is the instantiated model object.\r\n        // If there was an error, this function would be skipped.\r\n    }\r\n]);\r\n```",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1374/comments",
    "author": "TangMonk",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-02-25T22:12:59Z",
        "body": "You could `promisify` or `pify` `async.waterfall` and it would then be converted to a promise-returning function that could be `await`ed.\r\n\r\nHowever, you could `pify` the rest of your functions in the waterfall, and not need `waterfall` at all, e.g.:\r\n\r\n```js\r\nlet contents = await pify(fs.readFile)(filename, 'utf8');\r\nlet model = await db.model.create(contents);\r\n// `model` is the instantiated model object.\r\nlet result = // do something with `model`...\r\n```"
      }
    ]
  },
  {
    "number": 1371,
    "title": "What is happening to eachOfLimit and eachOfSeries",
    "created_at": "2017-02-17T19:46:21Z",
    "closed_at": "2017-02-22T08:57:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1371",
    "body": "\r\nI tried using both eachOf and eachOfLimit, but there is a problem, it repeats the requests after completing the iteration over object too. Here is my code:-\r\n\r\n```js\r\nrouter.post('/bulkhostimageondropbox', function (req, res, next) {\r\n    var fullurl = req.protocol + '://' + req.get('host') + '/';\r\n    var userid = req.user.id;\r\n    if (req.body.host === 'default') {\r\n        var host = fullurl;\r\n    } else {\r\n        var host = req.body.host;\r\n    }\r\n\r\n    var errors_arr = [];\r\n    var success_arr = [];\r\n    var test_arr = [];\r\n    ids = JSON.parse(req.body.id);\r\n   cases.findOne({\r\n        _id: ids[0],\r\n        //user_id: user_id\r\n    }, function (err, data) {\r\n        var images = data.images;\r\n        var hostedimages = {};\r\n        var ta = [];\r\n        var i = 1;\r\n        var dropboxheaders = {\r\n            'Content-Type': 'application/json',\r\n\r\n        }\r\n     \r\n        var sku = data.sku;\r\n        async.forEachOfSeries(images, function (value, key, cb2) {\r\n            setTimeout(function () {\r\n                value = value.replace('\\\\', '/');\r\n                value = value.replace('\\\\', '/');\r\n                value = value.replace('\\\\', '/');\r\n                var url = host + value;\r\n                var v = value.replace(/\\\\/g, '/');\r\n                v = v.split('/');\r\n                v = _.last(v);\r\n                console.log(url)\r\n                var dbx = new dropbox({\r\n                    accessToken: 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\r\n                });\r\n\r\n\r\n                dbx.filesSaveUrl({\r\n                        path: '/'+sku+'/' + v,\r\n                        url: url\r\n                    })\r\n                    .then(function (response) {\r\n                        dbx.filesSaveUrlCheckJobStatus({\r\n                            async_job_id: response.async_job_id\r\n                        }).then(function (resp1) {\r\n                            console.log(resp1);\r\n                            cb2();\r\n                        }).catch(function (e1) {\r\n                            console.log(e1);\r\n                            cb2();\r\n\r\n                        })\r\n                    }).catch(function (e2) {\r\n                        console.log(e2)\r\n                        cb2();\r\n                    })\r\n            }, 10000)\r\n        }, function () {\r\n            res.end()\r\n        })\r\n\r\n\r\n    });\r\n\r\n\r\n});\r\n```\r\n\r\nwhat happens is image uploads and then again uploads, it repeats several time.\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1371/comments",
    "author": "devthedeveloper",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-02-20T02:40:04Z",
        "body": "Are you sure your endpoint is onyy being called once?  Does `cases.findOne` only call its callback once?"
      },
      {
        "user": "devthedeveloper",
        "created_at": "2017-02-21T09:04:55Z",
        "body": "yes it only called once."
      }
    ]
  },
  {
    "number": 1363,
    "title": "release 2.1.5?",
    "created_at": "2017-02-03T12:14:16Z",
    "closed_at": "2017-02-04T17:48:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1363",
    "body": "Just wondering if there's a planned date for releasing 2.1.5?\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1363/comments",
    "author": "autopulated",
    "comments": [
      {
        "user": "megawac",
        "created_at": "2017-02-04T17:48:04Z",
        "body": "We'll be pushing out a version shortly. Just getting a couple minor updates in first"
      }
    ]
  },
  {
    "number": 1343,
    "title": "Error: Callback was already called.",
    "created_at": "2016-12-22T16:53:26Z",
    "closed_at": "2016-12-24T23:42:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1343",
    "body": "async version: 2.1.4\r\n\r\nI'm trying to import data from one database to another database.\r\n1. Getting data from DB2 using jt400\r\n2. Inserting data into mysql (not mentioned in code for now)\r\n\r\nThe query to select data is mentioned in `var reports` which has the data:\r\n```js\r\n[{\r\n  \"id\": 101,\r\n  \"query\": \"SELECT * FROM BI001CV1  \",\r\n  \"columns\": [\"ACCTYPE\",\"COUNT\",\"TOTAL\",\"DATE\"],\r\n  \"table\": \"ORDER101\"\r\n},\r\n{\r\n  \"id\": 102,\r\n  \"query\": \"SELECT *  FROM BI001CV1 \",\r\n  \"columns\": [\"ACCTYPE\",\"COUNT\",\"TOTAL\",\"DATE\"],\r\n  \"table\": \"ORDER101\"\r\n}]\r\n```\r\n\r\nThe code is working fine till first iteration. But on second iteration getting `Error: Callback was already called.`\r\nMy code is:\r\n\r\n ```js\r\nvar myData;\r\n\r\nfunction ReportJS(data) {\r\n    this.id = data.id;\r\n    this.name = data.name;\r\n    this.type = data.type;\r\n    this.description = data.description;\r\n    this.query = data.query.replace('TDATE', date);\r\n    this.columns = data.columns;\r\n    this.table = data.table;\r\n}\r\n\r\nvar getData = function(row, callback) {\r\n    myData = new ReportJS(row);\r\n    console.log('Fetching Data For Report ID: ' + myData.id);\r\n\r\n    var select = function(fn) {\r\n        console.log('calling select ... ' + myData.id);\r\n\r\n        database.execute(myData.query);\r\n        database.on('execute', function(error, data) {\r\n            console.log('DB2 exe... ' + myData.id);\r\n\t    var feilds = myData.columns;\r\n\t    var cols = [];\r\n            if (error) return callback(error, null);\r\n            async.each(data, function(key, value) {\r\n                var subcols = [];\r\n                feilds.forEach(function(index, pair) {\r\n                    subcols.push(key[feilds[pair]]);\r\n                });\r\n                cols.push(subcols);\r\n            });\r\n            console.log('select ended... ' + myData.id);\r\n            return fn(cols);\r\n        });\r\n    };\r\n\r\n    var insert = function(data, cb) {\r\n        console.log('calling insert ... ' + myData.id);       \r\n\r\n        setTimeout(function() { \r\n\t\treturn cb(null, data.length + ' success'); \r\n        }, 1000);\r\n\r\n    };\r\n\r\n    select(function(result) {\r\n        insert(result, function(err, data) {\r\n            console.log(data);   \r\n            return callback();  //Line No. 71\r\n        });\r\n    });\r\n}\r\nasync.eachSeries(reports, getData, function(err) {\r\n    if (err) console.log(err);\r\n    connection.end();\r\n});\r\n```\r\nOutput:\r\n\r\n```\r\nFetching Data For Report ID: 101\r\ncalling select ... 101\r\nDB2 exe... 101\r\nselect ended... 101\r\ncalling insert ... 101\r\n17 success\r\nFetching Data For Report ID: 102\r\ncalling select ... 102\r\nDB2 exe... 102\r\nselect ended... 102\r\ncalling insert ... 102\r\nDB2 exe... 102\r\nselect ended... 102\r\ncalling insert ... 102\r\n17 success\r\n/home/sridhal/node/node_modules/async/dist/async.js:837\r\n        if (fn === null) throw new Error(\"Callback was already called.\");\r\n                               ^\r\nError: Callback was already called.\r\n    at /home/sridhal/node/node_modules/async/dist/async.js:837:32\r\n    at /home/sridhal/node/jt400/db2mySQL.js:71:20\r\n    at null._onTimeout (/home/sridhal/node/jt400/db2mySQL.js:63:10)\r\n    at Timer.listOnTimeout (timers.js:110:15)\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1343/comments",
    "author": "sumitridhal",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-12-22T21:02:39Z",
        "body": "You aren't removing the event listener for `database.on('execute', ...`"
      }
    ]
  },
  {
    "number": 1337,
    "title": "Control Flow times - RangeError: Maximum call stack size exceeded",
    "created_at": "2016-12-06T10:24:25Z",
    "closed_at": "2016-12-06T18:41:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1337",
    "body": "Async v2.1.4 / Node v4.1.1\r\n\r\nRunning the code from the documentation with a large n (1500) for **times(n, iteratee, callback)**:\r\n\r\n```javascript\r\nvar async = require('async');\r\n\r\n// Pretend this is some complicated async factory\r\nvar createUser = function(id, callback) {\r\n    callback(null, {\r\n        id: 'user' + id\r\n    });\r\n};\r\n\r\n// generate 5 users\r\nasync.times(1500, function(n, next) {\r\n    createUser(n, function(err, user) {\r\n        next(err, user);\r\n    });\r\n}, function(err, users) {\r\n    console.log(users.length)\r\n});\r\n```\r\n\r\nI get:\r\n\r\n```bash\r\nRangeError: Maximum call stack size exceeded\r\n      at forEach (test/disk-test.js:49:7)\r\n      at node_modules/async/dist/async.js:1008:9\r\n      at replenish (node_modules/async/dist/async.js:882:17)\r\n      at iterateeCallback (node_modules/async/dist/async.js:867:17)\r\n      at node_modules/async/dist/async.js:840:16\r\n      at node_modules/async/dist/async.js:1010:13\r\n```\r\n\r\nBefore in version v1.5.x, I was able to create testing arrays of 250K but with this version I can only create max 1400.\r\n\r\nIs there a better way to do it?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1337/comments",
    "author": "mcmartins",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-12-06T18:41:37Z",
        "body": "That error happens when you don't defer your callback.  Either use something like `setImmediate`, or perhaps Lodash's `_.times`.  It appears you don't need Async at all."
      },
      {
        "user": "mcmartins",
        "created_at": "2016-12-06T22:38:39Z",
        "body": "Thank you for looking into this.\r\n\r\nI'll just use setImmediate which fixes it, don't want to include more dependencies in the project.\r\n\r\nThanks."
      }
    ]
  },
  {
    "number": 1336,
    "title": "async.each callback not called when long process.",
    "created_at": "2016-12-03T09:44:14Z",
    "closed_at": "2016-12-05T17:16:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1336",
    "body": "Hi all,\r\nI have a list of files need to download and I used async.each to loop the array as below:\r\n\r\n```js\r\nasync.each(urls, function(url, callbackEach) {\r\n            console.log('Starting download :  ' + url )\r\n            download(url, url.substring(url.lastIndexOf('/'), url.length), function () {\r\n              console.log('Download completed:  ' + url )\r\n             callbackEach();\r\n            })\r\n    }, function(err) {\r\n        if( err ) {\r\n          console.log('A file failed to process');\r\n        } else {\r\n          console.log('Download Slide completed ---------------------')\r\n        }\r\n    })\r\n```\r\n\r\nIt worked perfectly for all image files. However, if has a video file in list and download process take a long time then function callback never called.\r\n\r\nAnyone can help me? I'm using Async version 2.1.2\r\nThanks,\r\n\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1336/comments",
    "author": "namtn",
    "comments": [
      {
        "user": "megawac",
        "created_at": "2016-12-03T19:23:23Z",
        "body": "Are you sure the download isn't erring? What happens if the download fails?"
      },
      {
        "user": "namtn",
        "created_at": "2016-12-04T03:24:18Z",
        "body": "Hi @megawac \r\nI'm sure all file downloaded without any error because the line code:\r\n `console.log('Download completed:  ' + url )\r\n` always run correctly and if any error occur this line will execute:\r\n`          console.log('A file failed to process');\r\n`\r\n\r\nThanks,"
      },
      {
        "user": "megawac",
        "created_at": "2016-12-04T03:40:14Z",
        "body": "You're not calling the `callbackEach` callback in the case where the download errs"
      },
      {
        "user": "namtn",
        "created_at": "2016-12-04T14:49:01Z",
        "body": "Hi @megawac ,\r\nI have update code for error handling as below:\r\nDownload function:\r\n\r\n```js \r\nvar download = function (uri, filename, callback) {\r\n  request.head(uri, function (err, res, body) {\r\n    console.log('content-type:', res.headers['content-type'])\r\n    console.log('content-length:', res.headers['content-length'])\r\n    request(uri).on('error', function (err) {\r\n      callback(err)\r\n    }).pipe(fs.createWriteStream(__dirname + '/public/download/' + filename))\r\n      .on('close', callback)\r\n  })\r\n} \r\n\r\nAnd call download function inside async.each:\r\n\r\n async.each(urls, function (url, callbackEach) {\r\n      var url = url.replace(');', '')\r\n        console.log('Starting download :  ' + url)\r\n        download(url, url.substring(url.lastIndexOf('/'), url.length), function (error) {\r\n          console.log('Download completed:  ' + url)\r\n          if (error) {\r\n            callbackEach(error)\r\n          } else {\r\n            callbackEach()\r\n          }\r\n        })\r\n    }, function (err) {\r\n      if (err) {\r\n        console.log('A file failed to process')\r\n      } else {\r\n        console.log('Download completed ---------------------')\r\n        res.send('OK!')\r\n      }\r\n    })\r\n```\r\nIf has a video file ~ 20Mb and view the console log, just log for download completed and downloaded file already in my computer but callback function not call.\r\n\r\nThanks,\r\n\r\n\r\n"
      },
      {
        "user": "megawac",
        "created_at": "2016-12-05T16:48:43Z",
        "body": "Is there a set of urls (or an ssh endpoint I can connect to) I can test this with to try and repro? I can't really offer advice without a repro case"
      },
      {
        "user": "namtn",
        "created_at": "2016-12-05T17:15:27Z",
        "body": "Hi @megawac ,\r\n\r\nProblem solved.\r\nActually, There is a one file in the list never downloaded so the callback function not complete call for all elements.\r\nMy mistake.\r\n\r\nThanks @megawac."
      }
    ]
  },
  {
    "number": 1323,
    "title": "First callback of two nested Async.map() doesn't work",
    "created_at": "2016-11-13T10:00:13Z",
    "closed_at": "2016-11-14T06:56:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1323",
    "body": "I have used two Async methods as below in my class so I need to pass the result inside `ASync.map` to `Async.mapValues` but it doesn't work.\r\n```javascript\r\n  request_async (testCase, bodies, method, url, cb) {    \r\n    Async.map(bodies, (item, request_cb) => {\r\n      if(item.values !== undefined ) {\r\n        const _this = this\r\n        const data = {\r\n          method: method,\r\n          uri: url,\r\n          formData: item.values,\r\n          jar: this.jar\r\n        }\r\n        Request(data, (err, response, body) => {\r\n          this.tests_count--\r\n          if (err)\r\n            throw(err)\r\n          const _this = this\r\n          testCase.compare(response.statusCode, body, item, url, function(message) {\r\n            console.log(message)\r\n            if (!message)\r\n              console.log(null, message)\r\n            else {\r\n              request_cb(message)\r\n              if (_this.first_error) {\r\n                request_cb(message, false)\r\n              }\r\n              else {\r\n                _this.errors.push(message)\r\n                request_cb(false)\r\n              }\r\n            }\r\n          })\r\n        });       \r\n      }\r\n    }, (err, result) => {\r\n      console.log('Parent callback', cb)\r\n      cb(false, result)\r\n    })\r\n  }\r\n  make_bodies_async (testCase, method, uri) {\r\n    Async.mapValues(this.schemas, (item, key, cb) => {\r\n      let schemas\r\n      if (item.query)\r\n        schemas = Joi.describe(item.query)\r\n      else\r\n        schemas = Joi.describe(item.payload)\r\n\r\n      const bodies = testCase.make_bodies(schemas, item.defaults, key)\r\n      const parts   = _.split(key, '/')\r\n      const method  = parts[0].toUpperCase()\r\n      const url     = this.baseUrl + '/' + _.join(parts.slice(1),'/')\r\n\r\n      this.request_async(testCase, bodies, method, url, cb)\r\n\r\n    }, (err, result) => {\r\n      //console.logs won't work\r\n      console.log('bodies async')\r\n      console.log(err, result)\r\n    })\r\n  }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1323/comments",
    "author": "saeidalidadi",
    "comments": [
      {
        "user": "megawac",
        "created_at": "2016-11-14T03:17:13Z",
        "body": "> result inside ASync.map to Async.mapValues but it doesn't work\n\nThat's not very specific and not helping me give advice\n\nOne thing I notice\n\n``` js\nelse {\n      _this.errors.push(message)\n      request_cb(false)\n}\n```\n\nthis doesn't work `request_cb(false)` doens't get registered as an error. Consider `request_cb(error_msg)`\n"
      },
      {
        "user": "hargasinski",
        "created_at": "2016-11-14T05:02:10Z",
        "body": "In addition to what @megawac said, just something to consider. You have:\n\n``` js\nif(item.values !== undefined ) {\n    // your function\n}\n```\n\nbut you never handle the `item.values === undefined` case (or have code to call `request_cb` in that case). `map` will never invoke it's final callback (the one where you log `Parent callback`) if one of the iterations never calls it's callback (in this case `request_cb`). Could that be what's causing the issue here?\n"
      },
      {
        "user": "saeidalidadi",
        "created_at": "2016-11-14T06:27:34Z",
        "body": "Thanks to @hargasinski my issue has been solved.\n"
      },
      {
        "user": "hargasinski",
        "created_at": "2016-11-14T06:56:51Z",
        "body": "Glad to hear that\n"
      }
    ]
  },
  {
    "number": 1313,
    "title": "Setting up Event Handlers using Async",
    "created_at": "2016-10-24T23:39:21Z",
    "closed_at": "2016-10-27T20:44:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1313",
    "body": "I'm having trouble using async in one of my integration tests that involves event handlers. The problem is that the event handler needs to be set up (with a reference to an async provided callback) before the event is emitted. However the event handler code needs an extra callback right away. \n\nHere is a simplified example showing the problem:\n\n``` javascript\nasync.auto({\n  // This needs to run first, but it will finish second\n  event: [(next) => {\n    emitter.once('awesome', next);\n  }],\n\n  // This needs to finish near the end\n  checkResults: ['event', (results, next) => {\n    assert(results.event.status == 200);\n    assert(results.event.msg == 'cool');\n\n    // Do other async stuff...\n    somethingAsync(next);\n  }],\n\n  // This has to start second, but before the first one finishes\n  emit: ['event', (results, next) => {\n    event.emit('awesome', {msg: 'cool'}, next);\n  }],\n\n  checkEmit: ['emit', (results, next) => {\n    // some sort of check that can be async\n  },\n], done);\n```\n\n`event` has to start first, but won't finish until the `emit` occurs. `emit` needs to wait for `event` to start, but not finish (aka just set up the handler). Thus this won't finish.\n\nIs there a way to do this with the current async library? (in a clean manner)\n\nHeres a solution I would like, assuming this could be implemented in async\n\n``` javascript\nasync.auto({\n  listen: [(next, done) => {\n    client.on(done);\n    return next();\n  },\n\n  ...\n}, callback);\n```\n\nI could use parallel, running the emitters and the listeners (of which there can be multiple in a test) as an array of tasks. Taking the results, and running the checks as a second part. However, technically parallel isn't required to kick-off the tasks in order (though it likely will). Also, the code becomes less flat, especially in more complicated setups.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1313/comments",
    "author": "Saevon",
    "comments": [
      {
        "user": "hargasinski",
        "created_at": "2016-10-25T19:39:03Z",
        "body": "Hi @Saevon, thanks for the question!\n\nA quick, clean way of doing that would be:\n\n``` js\nasync.auto({\n    // This needs to finish near the end\n  checkResults: [(next) => {\n    return next(null, (results, next) => {\n      assert(results.event.status == 200);\n      assert(results.event.msg == 'cool');\n\n      // Do other async stuff...\n      // somethingAsync(next);\n    });\n  }],\n\n  // This needs to run first, but it will finish second\n  event: ['checkResults', (handler, next) => {\n    emitter.once('awesome', handler.checkResults);\n    return next();\n  }],\n\n  // This has to start second, but before the first one finishes\n  emit: ['event', (results, next) => {\n    // Should this be emitter.emit instead of event.emit?\n    event.emit('awesome', {msg: 'cool'}, next);\n  }],\n\n  checkEmit: ['emit', (results, next) => {\n    // the results of `checkResults` will be in `results.emit`\n    // as the handler on 'awesome' was passed the `next`\n    // callback from `emit`\n\n    // some sort of check that can be async\n    yourChecks(next);\n  }]\n}, function done(err) {\n    // everything finished running, unless `err` !== `null`\n});\n```\n\nEssentially, you're just swapping the `event` and `checkResults` dependency, which actually might be a little cleaner, as `event` depends on the handler in `checkResults`. `checkResults` is now just passing the handler to `event`.\n\nThe execution order would be:\n`checkResults --> event --> emit --> handler (passed to event from checkResults) --> checkEmit --> done`.\n\nLet me know if anything's unclear.\n"
      },
      {
        "user": "Saevon",
        "created_at": "2016-10-27T22:50:24Z",
        "body": "yeah, that solves the issue. Thanks!\n"
      },
      {
        "user": "megawac",
        "created_at": "2016-10-27T23:45:50Z",
        "body": "I think that is the craziest auto use case I've seen by the way :building_construction: \n"
      },
      {
        "user": "aearly",
        "created_at": "2016-10-29T22:52:58Z",
        "body": "Agreed.  Usually async callbacks and event emitters don't mix well...\n"
      }
    ]
  },
  {
    "number": 1310,
    "title": "Async debug timeout",
    "created_at": "2016-10-19T18:55:30Z",
    "closed_at": "2016-10-20T18:15:49Z",
    "labels": [
      "question",
      "enhancement",
      "wont fix"
    ],
    "url": "https://github.com/caolan/async/issues/1310",
    "body": "It would be very helpful for debugging and testing purposes if async had a timeout that could be set be set on all async operators. \n\nUse case would be \n\n```\nasync._debug({timeout: 2000})\n\nasync.waterfall([\n (next) => next(),\n (next) => 'bad function'\n], (err, res) => {\n   if(err){\n     throw err;\n   } \n})\n\n\n// Debug timeout of 2000ms occurred  at {stack} \n```\n\nOr something like that\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1310/comments",
    "author": "KamalAman",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-10-20T00:10:40Z",
        "body": "We already offer a `timeout` wrapper.\n\nYou could do something like:\n\n``` js\nlet debugWrap = process.env.DEBUG ? async.timeout : _.identity;\nlet waterfall = debugWrap(async.waterfall);\n\nwaterfall([\n  (next) => {...}\n  (next) => 'bad function'\n], (err, res) => {\n   if(err){\n     throw err;\n   } \n})\n```\n\nI'd be disinclined to build this in to the lib, though.\n"
      },
      {
        "user": "megawac",
        "created_at": "2016-10-20T18:15:40Z",
        "body": "Yep, @aearly solution is definitely the way to go\n"
      }
    ]
  },
  {
    "number": 1308,
    "title": "how to write this code in async/callbacks in nodejs?",
    "created_at": "2016-10-19T05:38:15Z",
    "closed_at": "2016-10-19T14:38:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1308",
    "body": "i wrote the code but it is not handling errors and not performing one after another .so please provide some information how to write this code by using async series or waterfall in nodejs. so i i am getting the details in data={}\n\n```\n hp_property_sell_request.findAndCountAll({\n            where:{\n                unit_price_id:data.unit_price_id\n        }}).then(function(result){\n            console.log(JSON.stringify(result)+\".....\");\n            if(result.count==0){\n                return  hp_property_sell_request.create(data)\n             }\n        else if(result.count>0){\n                return hp_unit_price.findAll({\n                    where:{\n                        unit_price_id:data.unit_price_id,\n                        hp_property_id:data.property_id,\n                        hp_unit_details_id:data.unit_details_id\n                      }\n                })\n           }\n        }).then(function (result){\n            var  result = JSON.parse(JSON.stringify(result));\n                if(result.request_id){\n               return hp_unit_price.findAll({\n                    where:{\n                        unit_price_id:result.unit_price_id,\n                        hp_property_id:result.property_id,\n                        hp_unit_details_id:result.unit_details_id\n                    }\n                }).then(function (result){\n\n                    if(result.is_resale_unit==0 && result.sold_out==0){\n                        return Sequelize.query('UPDATE hp_unit_price SET resale_unit_status=1 WHERE hp_unit_details_id='+result.unit_details_id+' and  hp_property_id='+result.property_id)\n                    }\n\n                })\n            }\n            else if(result[0].unit_price_id){\n                if(result[0].is_resale_unit==0 && result[0].sold_out==0){\n                    return {\n                        message:\"already request submitted\"\n                    }\n                }\n                else if(result[0].is_resale_unit==1 && result[0].sold_out==0){\n                   return {\n                      message:\"admin will contact u\"\n                       }\n                   }\n                else if(result[0].is_resale_unit==1 && result[0].sold_out==1){\n\n                    hp_property_sell_request.update(data,{\n                        where: {\n                            unit_price_id:result[0].unit_price_id\n                        }\n                    }).then(function (result) {\n                        var  result = JSON.parse(JSON.stringify(result));\n                        return Sequelize.query('UPDATE hp_unit_price SET is_resale_unit=0,sold_out=0,resale_unit_status=1 WHERE hp_unit_details_id='+result.unit_details_id+' and  hp_property_id='+result.property_id)\n\n                        });\n                    }\n            }\n\n        }).then(function (result) {\n           if(result.hasOwnProperty('message')){\n               res.status(200).json({\n                   statusCode: 200,\n                   data:result.message\n               });\n           }\n\n\n\n        });\n```\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1308/comments",
    "author": "SIMHACHALAM1001",
    "comments": [
      {
        "user": "megawac",
        "created_at": "2016-10-19T14:38:58Z",
        "body": "I'm not going to write code for you, but essentially you want `waterfall` for these promise chains. You can also consider using `asyncify` to convert promises to an async compatible handler which properly calls the error/success states.\n\nIf you try to write the code yourself and run into issues you can consider posting it here or on stack overflow\n"
      }
    ]
  },
  {
    "number": 1305,
    "title": "Pass parameters to called function in async.retry",
    "created_at": "2016-10-14T11:21:19Z",
    "closed_at": "2016-10-14T22:12:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1305",
    "body": "I am trying to pass parameters to the function that retry calls but i get \n\n**Error: Invalid arguments for async.retry**\n\nMy code:\n\n``` js\n\n    async.waterfall([\n        async.apply(queryGenerator.generateQuery, user),\n      **//  async.retry(5, async.apply(googleOperations.reportingRequest, user)),\n        async.retry(5, googleOperations.reportingRequest(user)),**\n        googleOperations.parseGoogleResponse,\n        async.apply(slackOperations.postMessage, user.slack.token, '#general')\n    ]\n```\n\nI tried both but none works. Any clue?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1305/comments",
    "author": "mKontakis",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-10-14T17:56:35Z",
        "body": "Looks like you want `retryable` instead of `retry`.  The commented-out line should work otherwise.\n"
      },
      {
        "user": "mKontakis",
        "created_at": "2016-10-14T22:11:58Z",
        "body": "Worked thanks\n"
      }
    ]
  },
  {
    "number": 1299,
    "title": "Nested Async Functions Not Firing Parent Done Function",
    "created_at": "2016-10-06T12:40:46Z",
    "closed_at": "2016-10-06T12:49:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1299",
    "body": "<!--\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\n-->\n\n**What version of async are you using?**\n2.0.1\n**Which environment did the issue occur in (Node version/browser version)**\n5.12\n**What did you do? Please include a minimal reproducable case illustrating issue.**\n\n```\nvar runLogic = function() {\n  var deferred = Q.defer()\n\n  async.eachOf(obj, function(arr, key, cb) {\n\n    var group = [1,2,3]\n    async.each(group, function(item, innerCbOne) {\n\n      async.each(arr, function(innerItem, innerCbTwo) {\n\n        ajaxRequest().then(function() {\n          return innerCbTwo()\n        }).catch(function(err) {\n            return innerCbTwo()\n        })\n\n      }, function() {\n        return innerCbOne()\n      })\n    }, function() {\n      // This is the last place it prints before hanging\n      return cb()\n    })\n\n  }, function() {\n    // I'm not getting here sometimes!\n    return deferred.resolve()\n  })\n  return deferred.promise  \n}\n```\n\n**What did you expect to happen?**\nI expected the deferred.resolve to fire \n**What was the actual result?**\nScript hangs :(\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1299/comments",
    "author": "adamrabie",
    "comments": [
      {
        "user": "megawac",
        "created_at": "2016-10-06T12:49:16Z",
        "body": "It works for me (on the asyncjs site). Ran this code\n\n``` js\nvar obj = {\n  x: [[1]]\n}\n\nvar deferred = $.Deferred()\n\nasync.eachOf(obj, function(val, key, cb) {\n\n  async.each(val, function(arr, innerCbOne) {\n\n    async.each(arr, function(item, innerCbTwo) {\n\n      innerCbTwo();\n\n    }, function() {\n      return innerCbOne()\n    })\n  }, function() {\n    // This is the last place it prints before hanging\n    return cb()\n  })\n\n}, function() {\n  // I'm not getting here sometimes!\n  return deferred.resolve()\n})\n\ndeferred.then(function() {\n  console.log('done');\n})\n```\n\nMake sure you're not getting an ajax error or something\n"
      },
      {
        "user": "adamrabie",
        "created_at": "2016-10-06T12:55:33Z",
        "body": "@megawac \n\nThanks for quick reply. I updated my example slightly in a couple places as i noticed i wasn't reflecting exactly what I was doing.\n\nIn any case I do call the callback in the catch function of the ajax req and that's not where it is hanging. Both the inner .each function are completing and i'm getting a hang just before the line cb(). I can even console.log(cb) and it prints [Function] but that is the last thing I see.\n"
      },
      {
        "user": "megawac",
        "created_at": "2016-10-06T13:12:55Z",
        "body": "Does the code example I gave above work for you @adamrabie?\n"
      },
      {
        "user": "adamrabie",
        "created_at": "2016-10-06T14:14:50Z",
        "body": "@megawac \n\nIt does.\n\nI can't fathom what might be happening though in my fuller code. I know the ajax request seems like the culprit but it's direct parent async callbacks and done function is firing, its only the main parent cb() that isn't firing through to the done function and there is no request behaviour inside other than the dependency on its inner async functions, both of which are completing. Hope this makes sense.\n"
      },
      {
        "user": "megawac",
        "created_at": "2016-10-06T14:19:38Z",
        "body": "It's really hard for me to suggest anything without a reproducible case I can run... If details are sensitive you can email me with further details.\n"
      }
    ]
  },
  {
    "number": 1298,
    "title": "Odd result from waterfall",
    "created_at": "2016-10-06T06:20:23Z",
    "closed_at": "2016-10-06T07:29:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1298",
    "body": "**What version of async are you using?**\n2.0.1\n\n**Which environment did the issue occur in (Node version/browser version)**\nNode 6.7.0\n\n**What did you do? Please include a minimal reproducable case illustrating issue.**\n\n``` javascript\nrequire(\"async\").waterfall([\n    (callback) => callback()\n], (error) => console.log(error));\n```\n\n**What did you expect to happen?**\nIn `async@1.5.2`, in the above case `error` is undefined. \n\n**What was the actual result?**\nIn `async@2.0.1`, in the above case `error` is `null`. The final callback is somehow called with `callback(null)` which probably should have been `callback()`.\n\nThis may be working as indended, but its just something I noticed had changed recently.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1298/comments",
    "author": "ath88",
    "comments": [
      {
        "user": "hargasinski",
        "created_at": "2016-10-06T07:29:09Z",
        "body": "Thanks for the report @ath88! This is working as expected. The reason for this change was to standardise the value of `error` passed to the final callback, if an error was not detected during execution. Many of the other functions in `v1.5.x` that ran tasks in series, similar to `waterfall`, like `mapSeries`, `eachOfSeries`, etc..., were already passing `null` to the final callback, even if a different, falsy value was passed into `callback` on the final iteration. `Waterfall` was an exception. \n\nThis was standardised in `v2.0`, so that all functions pass `null` to their final callback if they don't detect an error during execution. The reason for standardising it is that it will allow us to implement a number of cool, new features in the future. For instance, breaking out of a flow early if a value of `false` was explicitly passed as `error`.\n"
      },
      {
        "user": "ath88",
        "created_at": "2016-10-06T07:34:05Z",
        "body": "Oh, cool! I did not see that coming. :) Thanks for clarifying this. :)\n"
      },
      {
        "user": "hargasinski",
        "created_at": "2016-10-06T07:37:18Z",
        "body": "No worries :)\n"
      }
    ]
  },
  {
    "number": 1296,
    "title": "problem with using multiple queues",
    "created_at": "2016-10-05T12:03:36Z",
    "closed_at": "2016-10-07T15:19:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1296",
    "body": "**What version of async are you using?**\n\nv2.0.1\n\n**Which environment did the issue occur in (Node version/browser version)**\n\nNode v4.2.4\n\n**What did you do? Please include a minimal reproducable case illustrating issue.**\n\nI have multiple web services (S1, S2, ...) that I need to call with the same `http.request`s R1, R2, R3, .... Requests have to be processed in the same order as created (first R1, then R2, ...). If one of the web services Sx goes offline, the requests Rx have to wait and then be executed when the web service gets back online.\n\nTo achieve this functionality I use the async.queue and use concurency  = 1. I create a separate queue for each web service. For each web request that I get I create a task for each web service and enqueue it in the appropriate queue. The callback for the queue is called, which calls the web service. If the request is processed ok, I simply call the callback that I guess removes the task from the queue. In case the request timeouts I call `queue.unshift(task)` which puts the task back to the beginning of the queue so that it should be called again, and then again call the callback.\n\nThe problem I see is that if one web service goes offline, the task in that queue is tried repeatedly, but unfortunately no tasks from the other queues (for web services that are online) are being processed. Is this expected? I would expect that tasks from each queue would be processed independently.\n\nHere is some (pseudo) code that I have:\n\n```\n        // this is how i create a queue for each web service I have\n    service.queue = async.queue(function (task, callback) {\n        processTaskRequest(task, service, type, callback);\n    }, 1);\n\n.....\n\nfunction processTaskRequest(task, service, type, callback) {\n    makeRequest(options, task.req, task.res,\n        function (data) {\n            if (callback) { callback(); }\n        },\n        function (e, e2) {\n            console.log(\"Failed task for service \");\n            // re-enqueue the task at the beginning of the queue - the same task should be executed next\n            // this will make sure all tasks will execute and they will execute in the same order as came in\n            service.queue.unshift(task);\n            // only after X seconds try to repeat making the query - if service is offline, it doesn't make sense to do it more often\n            setTimeout(function () {\n                if (callback) { callback(); }\n            }, 10000);\n        }\n    );\n} \n```\n\nThank you in advance for any help!\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1296/comments",
    "author": "gregorleban",
    "comments": [
      {
        "user": "megawac",
        "created_at": "2016-10-05T14:17:45Z",
        "body": "Though unshifting back to the top should work it seems a bit sketchy to me. I would probably use this workflow with a mix of `async.queue` and `async.retry`\n\n``` js\nfunction handler(task, callback) {\n   retry({retry-options}, callApiWithTask, function(err, data) {\n      callback(data);\n   } \n}\n\nlet q = queue(handler, 1);\n\n// add task to call first api end point\n// add second,\n// etc etc.\n```\n\nNot sure exactly what is going wrong your code, it's hard to debug with that pseudo code\n"
      },
      {
        "user": "gregorleban",
        "created_at": "2016-10-07T15:18:52Z",
        "body": "I didn't know about the retry. I've implemented it and it works perfectly fine. Thank you for the suggestion!\n"
      },
      {
        "user": "megawac",
        "created_at": "2016-10-07T15:22:35Z",
        "body": ":tada:\n"
      }
    ]
  },
  {
    "number": 1292,
    "title": "Queue worker farm",
    "created_at": "2016-09-24T17:51:21Z",
    "closed_at": "2016-10-03T23:57:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1292",
    "body": "We'd like to use `async` for our queue worker farm on a single machine. All they do is make HTTP requests and wait for the responses, no computations. We're doing 200 req/s.\n\nRight now we're using Node's cluster API to spin up a dozen workers. Could someone give an example of how to best implement a queue worker (in that cluster):\n- to execute multiple functions simultaneously that poll SQS for jobs\n- call a function when a job is available \n- and call themselves again once their finished\n\nI appreciate any input or clues and apologize if this isn't the right place for support requests.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1292/comments",
    "author": "tillkruss",
    "comments": [
      {
        "user": "megawac",
        "created_at": "2016-10-03T23:57:11Z",
        "body": "`async.auto` is a good place to start. If you have trouble implementing your own solution you can respond here or file a stackoverflow question. I'd rather not solve such a problem for you without solid requirements (similar to stackoverflow policy).\nSorry for the slow response, wasn't sure how I wanted to answer this.\n"
      }
    ]
  },
  {
    "number": 1285,
    "title": "TypeScript Cannot find module 'async'",
    "created_at": "2016-09-19T18:34:48Z",
    "closed_at": "2016-09-20T12:27:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1285",
    "body": "<!--\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\n-->\n\n**What version of async are you using?**\nasync@2.0.1\n**Which environment did the issue occur in (Node version/browser version)**\nnode: v6.6.0  typescript: Version 1.8.10\n**What did you do? Please include a minimal reproducable case illustrating issue.**\nI want to use async in typescript by coding:  import {parallel, waterfall} from 'async'; \nbut occured an compile error: [ts] Cannot find module 'async'\n\nmy tsconfig.json as below:\n\"compilerOptions\": {\n    \"target\": \"es2015\",\n    \"module\": \"umd\",\n    \"noImplicitAny\": true,\n    \"noImplicitReturns\": true,\n    \"noEmitOnError\": true,\n    \"removeComments\": false,\n    \"moduleResolution\": \"node\",\n    \"sourceMap\": false\n  }\n**What did you expect to happen?**\n\n**What was the actual result?**\n\ncan you help me ?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1285/comments",
    "author": "QJesus",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-09-19T19:12:15Z",
        "body": "I am not familiar with how TypeScript bundles, but I have 2 questions:\n\nDo other modules from NPM bundle properly?\n\nHave you tried using `async-es`, which is published as an ES module rather than a CommonJS module?\n"
      }
    ]
  },
  {
    "number": 1276,
    "title": "\"autoInject task functions require explicit parameters.\" error when using async.constant()",
    "created_at": "2016-09-02T11:05:53Z",
    "closed_at": "2016-09-02T14:09:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1276",
    "body": "**What version of async are you using?**\n2.0.1\n\n**Which environment did the issue occur in (Node version/browser version)**\nNode v. 6.2.2\n\n**What did you do? Please include a minimal reproducable case illustrating issue.**\n\n```\nasync.autoInject({\n            hostname: async.constant(\"xxx\"),\n}, callback);\n```\n\n**What did you expect to happen?**\nThat the autoInject passes without issues an error.\n\n**What was the actual result?**\nerror - \"autoInject task functions require explicit parameters.\"\n\n**More Details**\nThe same piece of code works well with `auto()`.\n\n```\nasync.auto({\n            hostname: async.constant(\"xxx\"),\n}, callback);\n\n```\n\nIn order to make it working with `autoInject()` I had to wrap the method a function with a param.\n\n`hostname: callback => async.constant(\"xxx\"),`\n\nIt seems that function return by `async.constant()` does not work well with `autoInject`. \n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1276/comments",
    "author": "zatziky",
    "comments": [
      {
        "user": "megawac",
        "created_at": "2016-09-02T14:09:42Z",
        "body": "yeah, `autoInject` parses the function signature (i.e. usings `function.toString()` which is kind of hacky and not resilient to things like this case). `constant` creates a function with a wrapper which `autoInject` can't understand.\n\nConsider this a limitation of `autoInject`, personally I recommend using `auto` over `autoInject`\n"
      }
    ]
  },
  {
    "number": 1260,
    "title": "Using with non async code",
    "created_at": "2016-08-01T22:29:52Z",
    "closed_at": "2016-08-03T13:35:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1260",
    "body": "Hi I really like how this package allows to structure code, for example the waterfall way.\nDoes it make any sense to use it to structure non async code ? Like create functional style waterfall with non async code ? Anybody does this kind of usage ?\nOr is it too much overhead in therms of performance ?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1260/comments",
    "author": "Brakkar",
    "comments": [
      {
        "user": "megawac",
        "created_at": "2016-08-01T23:24:09Z",
        "body": "It can often be useful to reason about code with the assumption that its always asynchronous. This has the benefit of avoiding some race condition scenarios.\n\nHowever, of course it will generally be faster to execute code synchronously. I would generally not worry about it as async attempts to be very well optimized and attempts to minimize overhead in general. Also, do note that asyncjs does not gaurentee that callbacks are async. For instance in the example below, the done callback is called synchrnously\n\n``` js\nfunction done() { }\nfunction instantResolver(val, cb) {\n   cb();\n}\n\nasync.each([1], instantResolver, done);\n```\n\nLet me know if you need clarification on any of these points, feel like I didn't explain it all so well.\n\n```\n```\n"
      }
    ]
  },
  {
    "number": 1248,
    "title": "Handling of errors in find & some",
    "created_at": "2016-07-21T17:50:47Z",
    "closed_at": "2019-03-09T21:54:23Z",
    "labels": [
      "question",
      "breaking-change",
      "feedback-wanted"
    ],
    "url": "https://github.com/caolan/async/issues/1248",
    "body": "Upon some reflection I don't like how we handle errors in the internal `createTester`.\n\nWhen an error occurs we resolve the callback resolves immediately; however, if in the case of some or detect, if the iteratee returned truthy we would have exited `createTester` successfully.\n\nI think the correct approach would be to continue upon error and determine whether any item was truthy.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1248/comments",
    "author": "megawac",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-07-30T23:32:05Z",
        "body": "I think exiting immediately on an error is the \"correct\" thing to do here.  `_.some(arr, (v) => { throw new Error(); return true })` would throw, not return true.\n\nIf the error occurred on the iteration loop that called-back `true`, would the `some` function callback true?  In that specific case, I think the error should override the `true` value.\n"
      },
      {
        "user": "megawac",
        "created_at": "2016-08-03T19:58:25Z",
        "body": "Sure, but in `_.some` or `Array.prototype.some`s cases its serial and can gaurentee which item it will error on. In the async case (for not *Series) we are racing to determine whether a) a error occurs b) a test passes. Seems sketch\n\n> If the error occurred on the iteration loop that called-back true, would the some function callback true? In that specific case, I think the error should override the true value.\n\nNo that's definitely counted as an error. When checking an individual callback, error should always takes precedence over the rest of the resolve arguments.\nIn `detect` and `some` however, I'm not sure if an error in one warrants a error in all.\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-08-04T03:12:18Z",
        "body": "Ah, I see, there could be some race conditions in the parallel case, or there could be conflicting results in the parallel case.  Not sure what the correct thing to do is.  Consider this example:\n\n``` js\n_.some(_.range(10), function (num) {\n  if (num > 5) throw new Error();\n  return num === 5;\n}\n```\n\nThis won't throw with Lodash, but that is just an artifact of its short-circuiting.  But should it?  Half the values would throw an error if they were iterated over.  If it were iterated in reverse, it would throw every time, even though the `some` condition would be satisfied.\n\nI'm trying to think of a real world example with Async.  Would  you want to know that one of your iteration steps produced an error, even if the `find`/`some`/`every` condition was satisfied?\n"
      },
      {
        "user": "megawac",
        "created_at": "2017-02-08T17:30:43Z",
        "body": "Related #591 "
      },
      {
        "user": "aearly",
        "created_at": "2019-03-09T21:54:23Z",
        "body": "Hmnn, this has been open for a long time, and I'm not convinced it's still an issue now that we have `tryEach`."
      }
    ]
  },
  {
    "number": 1244,
    "title": "async.forEach function is not calling callback() for last element of array.",
    "created_at": "2016-07-20T06:41:38Z",
    "closed_at": "2016-07-20T21:12:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1244",
    "body": "I am new to node.js and I have written code using async.forEach().Something is wrong I am not getting my mistake.\n\n``` js\n    async.forEach(payload.bookings,fun,function(err,res){\n            var data ;\n            if(err)\n                console.log(err);\n            if(res) {\n\n                data = res;\n                console.log(data);\n            }\n        });\n\n        function fun(booking,cb){\n\n            var dataToSave = {};\n\n            //service choosen by customer\n            var service_id = booking.serviceId;\n\n            dataToSave.serviceId = service_id;\n\n            var query = {\n                services : {$elemMatch : { serviceId : service_id } }\n            };\n\n            var projection = {\n                cellPhoneNumber :1,\n                countryCode:1,\n                services :1\n            };\n\n            var options = {};\n\n            Service.serviceProvider.getServiceProviders(query,projection,options,function(err,data){\n\n                if(err)\n                    cb(err);\n                else{\n\n                    if(data && data.length>0){\n\n                        //getting list of SP which gives the service name given by customer\n                        dataToSave.serviceProviderList = [];\n\n                        for(var sp=0;sp<data.length;sp++){\n\n                            var serviceProvider = {};\n\n                            serviceProvider.id = data[sp]._id;\n\n                            //searching in services array of one particular service id\n                            for(var j=0;j<data[sp].services.length;j++){\n\n                                if(data[sp].services[j].serviceId==service_id)\n                                {\n                                    serviceProvider.serviceRate = data[sp].services[j].rate;\n                                    break;\n                                }\n                            }\n                            dataToSave.serviceProviderList.push(serviceProvider);\n                        }\n                        cb(dataToSave);\n                    }\n                    else{\n                        cb();\n                    }\n                }\n            });\n        };\n```\n\nOutput:\n\n```\n{ serviceId: '578e0da7c8c4cfc807040852',\n  serviceProviderList: \n   [ { id: 578e18f6ed564791083c75ad, serviceRate: 200 },\n     { id: 578e1996ed564791083c75b4, serviceRate: 200 } ] }\n```\n\nExpected output : \n\n```\n{ serviceId: '578e0da7c8c4cfc807040852',\n  serviceProviderList: \n   [ { id: 578e18f6ed564791083c75ad, serviceRate: 200 },\n     { id: 578e1996ed564791083c75b4, serviceRate: 200 } ] }\n{ serviceId: '578dca50e93da81f0423f6b6',\n  serviceProviderList: [ { id: 578e18f6ed564791083c75ad, serviceRate: 100 } ] }\n```\n\nI have seen on swagger documentation.When I click on **Try It Out** it keeps on running.only it shows the object which I have printed using console.log()\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1244/comments",
    "author": "uditkumawat",
    "comments": [
      {
        "user": "megawac",
        "created_at": "2016-07-20T21:12:30Z",
        "body": "In your final callback, `res` will not be passed in `forEach` (it wouldn't be possible to know what particular booking you were trying to refer to). Perhaps you wanted to use `map`?\n\n> `cb(dataToSave);`\n\nI think this is supposed to be `cb(null, dataToSave)`\n"
      }
    ]
  },
  {
    "number": 1232,
    "title": "reduceRight docs say takes object|array; only supports array",
    "created_at": "2016-07-12T16:31:30Z",
    "closed_at": "2016-07-12T21:33:12Z",
    "labels": [
      "docs",
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1232",
    "body": "Because `reduceRight` calls `Array.prototype.slice` on the passed in collection it only supports `Arrays`\n\nThis begs the question, is reversing an object really a good pattern? How about an iterator? If yes, should implement `eachRight`, `eachOfRight` and friends?\n\nAlso should we document `Iterable` support on all methods supporting iterators? Currently we only state we support `Array | Object` in these cases.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1232/comments",
    "author": "megawac",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-07-12T20:05:39Z",
        "body": "If you were using an iterator with `reduceRight`, you'd have to expand it into an array, e.g. `async.reduceRight([...iterator], iteratee, cb)`.  If your collection offered some sort of reverse iterator, you'd use that instead.  Reversing the keys of an Object is mostly meaningless.  I think it's fine if `reduceRight` only works with arrays.\n"
      },
      {
        "user": "megawac",
        "created_at": "2016-07-12T20:11:06Z",
        "body": "Okay, second part. Should `each*`, `eachOf`, `map*`, `filter*`, and friends be documented to take Iterables?\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-07-12T20:24:18Z",
        "body": "Ah, yes.\n"
      }
    ]
  },
  {
    "number": 1215,
    "title": "async.applyEach callback is not working",
    "created_at": "2016-07-04T06:33:48Z",
    "closed_at": "2016-07-04T19:40:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1215",
    "body": "I am using v2.2.0 of async.js and I am using it on client side.\n\nI am trying basic example of async.applyEach\n\n```\nvar enableSearch = function(string){\n  console.info(string);\n};\nvar updateSchema = function(string){\n  console.warn(string);\n};\n\nasync.applyEach([enableSearch, updateSchema], 'New msg', function(){\n  console.log('It is done...');\n});\n```\n\nI suppose I should expect results to be...\n\n```\nNew msg\nNew msg\nIt is done\n```\n\nbut some reason I am not getting `It is done`. That means callback is no firing. Anything I am doing wrong here...\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1215/comments",
    "author": "thatisuday",
    "comments": [
      {
        "user": "thatisuday",
        "created_at": "2016-07-04T06:59:31Z",
        "body": "And `async.applyEachSeries` calls only first function in the stack with no callback. i.e. `enableSearch`\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-07-04T18:57:19Z",
        "body": "Your `enableSearch` and `updateSchema` functions don't actually call any callback, so the final callback will never be called.\n"
      },
      {
        "user": "thatisuday",
        "created_at": "2016-07-05T05:22:53Z",
        "body": "@aearly Oops... sorry about that.\n"
      },
      {
        "user": "anusree-mmlab",
        "created_at": "2018-01-25T09:52:48Z",
        "body": "I have 2 callbacks on each enableSearch and updateSchema.\r\nBut the  final callback is called with the enableSearch callback. #"
      }
    ]
  },
  {
    "number": 1200,
    "title": "Error using async.eachSeries",
    "created_at": "2016-06-28T14:35:31Z",
    "closed_at": "2016-06-28T17:08:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1200",
    "body": "I tried to use the example for async.eachSeries and got an error \"Uncaught ReferenceError: inCache is not defined\".\nHow can I fix it?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1200/comments",
    "author": "hermannlang",
    "comments": [
      {
        "user": "megawac",
        "created_at": "2016-06-28T17:08:54Z",
        "body": "Lets say `cache` is a map... `cache = new Map`, `inCache` could be defined as follows\n\n``` js\nfunction inCache(item) {\n  return cache.has(item)\n}\n```\n\nThat example is only supposed to be describing a pattern. Lets say hugeArray has 5 million elements, if all the items are in the cache already we will be doing 5 million operations synchronously. \n"
      }
    ]
  },
  {
    "number": 1184,
    "title": "Memory leak when using Async.js",
    "created_at": "2016-06-10T09:07:27Z",
    "closed_at": "2016-06-12T14:23:21Z",
    "labels": [
      "bug",
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1184",
    "body": "<!--\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\n-->\n\n**What version of async are you using?** \n^2.0.0-rc.5\n\n**Which environment did the issue occur in (Node version/browser version)** \nv5.4.1\n\n**What did you do? Please include a minimal reproducable case illustrating issue.**\nWould you pls tell me what causes memory leak in the following code? The code is a simplified version of my server. I've desperately searched for leaks & solutions in nodejs, but I've found none. \n\n``` js\n'use strict'\nconst async = require('async')\n\nfunction validate(x, y, callback){\n  var validateX = function(cb){\n    x ++\n    if(cb) cb(null)\n  }\n\n  var validateY = function(cb){\n    y +=2\n    if(cb) cb()\n  }\n\n  async.waterfall(\n    [validateX, validateY],\n    function(err, result){\n      validateY = null\n      validateX = null\n      callback(err, result)\n    }\n  )\n}\n\nasync.forever(\n  function(next){\n    validate(0, 0, function(err, result){\n      if(err){\n        return next(err)\n      }\n      setTimeout(next, 5)\n    })\n  },\n  function(err){}\n)\n```\n\n**What did you expect to happen?**\nThe program runs without any memory leak\n\n**What was the actual result?**\nIts memory usage gradually increases\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1184/comments",
    "author": "anhldbk",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-06-11T23:28:15Z",
        "body": "Have you played around with Node Inspector?  Do you know what objects or closures aren't being cleaned up?\n"
      },
      {
        "user": "anhldbk",
        "created_at": "2016-06-12T14:23:21Z",
        "body": "@aearly I'm terribly sorry. After thorough profiling, there's no leak at all. So I close the issue now.\n"
      }
    ]
  },
  {
    "number": 1183,
    "title": "Error not passed to callback",
    "created_at": "2016-06-10T03:33:42Z",
    "closed_at": "2016-06-12T09:03:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1183",
    "body": "I am using async.auto to execute functions which are dependent on each other, and I am using sequelize inside those functions. I have code something like this:\n\n``` js\n\n            async.auto({\n              //Add a new Order\n              addOrder: function(callback) {\n                var query = {CreatedOn: new Date(), OrderId: orderId};\n                tempDB.order.create(query, {transaction: t}).then(function(order){\n                  callback(null, 'data', order);\n                }).catch(function(err){\n                  callback(new Error(err.message));\n                });\n              },\n              addOrderArticles: ['addOrder', function(callback, results) {\n                  Promise.all(req.body.Articles.map(function(a){\n                    var query = {\n                         OrderId: results.addOrder[1].OrderId,\n                         ArticleId: parseInt(a.ArticleId),\n                         Quantity: parseInt(a.Quantity)\n                    }\n                    tempDB.orderitem.create(query,{transaction: t}).then(function(orderItem){\n                        if(a.OrderItemVariations !== null){\n                              tempDB.sequelize.Promise.map(a.OrderItemVariations, function(variation) {\n                                tempDB.orderitemvariation.create({\n                                  OrderItemId: orderItem.OrderItemId,\n                                  VariationId: variation.VariationId\n                                }, { transaction: t }).then(function(orderItemVariation){\n                                  callback(null, 'data', results.addOrder[1]);\n                                }).catch(function(err){\n                                  callback(new Error(err.message));\n                                });\n                              });\n                        }\n                        if(a.OrderItemSplits !== null){\n                              tempDB.orderitemsplit.create({\n                                OrderItemId: orderItem.OrderItemId,\n                                Denomination: a.OrderItemSplits.Denomination,\n                                SplittedBy: a.OrderItemSplits.SplittedBy\n                              }, { transaction: t }).then(function(orderItemSplit){\n                                callback(null, 'data', results.addOrder[1]);\n                              }).catch(function(err){\n                                callback(new Error(err.message));\n                              });\n                        }\n                    }).catch(function(err){\n                    callback(new Error(err.message));\n                    });\n                  }));\n            }],\n            addOrderPayments: ['addOrderArticles', function(callback, results){\n              if(req.body.OrderPayments !== null){\n                Promise.all(req.body.OrderPayments.map(function(p){\n                 var query = {\n                  OrderId: results.addOrder[1].OrderId,\n                  PaymentTypeId: p.PaymentTypeId,\n                  Amount: p.Amount\n                 }\n                 tempDB.orderpayment.create(query, {transaction: t}).then(function(orderPmt){\n                  callback(null, 'data', results.addOrder[1]);\n                 }).catch(function(err){\n                   console.log(err.message);\n                  callback(new Error(err.message));\n                 });\n                }))\n              }\n              else{\n                callback(null, 'data', results.addOrder[1]);\n              }\n            }]\n            }, function(err, results) {\n              console.log(err);\n              if(err === null){\n                t.commit().then(function() {\n                  res.send(200);\n                }).catch((err) => {\n                  t.rollback();\n                  res.json(err);\n                });\n              }\n              else{\n                t.rollback();\n                res.json(err);\n              }\n            });\n\n```\n\nIn the above code the console.log(err) code inside final callback(err, results) always returns err as null even when there is an error thrown in the code. Am I using the correct approach to handle errors and pass them to the callback at the end. The problem is coming when I try to pass the error object using the code:\n\n``` js\n callback(new Error(err.message));\n```\n\nIs it the right way to pass the error to the main call back as I always get the error as null.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1183/comments",
    "author": "zeeshanjan82",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-06-11T21:52:58Z",
        "body": "Does each step in the `auto` flow properly pass an error?\n"
      },
      {
        "user": "zeeshanjan82",
        "created_at": "2016-06-12T08:47:27Z",
        "body": "I am using callback(new Error(err.message)); code to return the error. I am able to see the error inside the step. I am getting error in the last step which is inside addOrderPayments but when I check the err object in the function below I always get it as null\n\n``` js\nfunction(err, results) {\n              console.log(err);\n              if(err === null){\n                t.commit().then(function() {\n                  res.send(200);\n                }).catch((err) => {\n                  t.rollback();\n                  res.json(err);\n                });\n```\n"
      },
      {
        "user": "zeeshanjan82",
        "created_at": "2016-06-12T09:03:02Z",
        "body": "The issue is fixed as I had to return the error from Promise.all , there was no issue with async.\n"
      }
    ]
  },
  {
    "number": 1169,
    "title": "filter result not an array",
    "created_at": "2016-05-29T06:01:38Z",
    "closed_at": "2016-05-30T20:45:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1169",
    "body": "<!--\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\n-->\n\n**What version of async are you using?**\nversion: 2.0.0-rc.5  \n\n**Which environment did the issue occur in (Node version/browser version)**\nnode v 6.2.0\n\n**What did you do? Please include a minimal reproducable case illustrating issue.**  \n\n``` javascript\nconst fs = require('fs');  \nconst async = require('async');\n\nasync.filter(['f1', 'f2', 'f3'], fs.exists, function(ret) {\n    console.log(ret);\n});\n```\n\n[luncher@localhost async]$ node app.js \ntrue\n[luncher@localhost async]$ \n\n**What did you expect to happen?**\nexpect result must be an array \n\n**What was the actual result?**\na Boolean equal true\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1169/comments",
    "author": "Luncher",
    "comments": [
      {
        "user": "Luncher",
        "created_at": "2016-05-29T06:02:03Z",
        "body": "[luncher@localhost async]$ ls\napp.js  f1  f2  f3  node_modules  package.json\n[luncher@localhost async]$ \n"
      },
      {
        "user": "megawac",
        "created_at": "2016-05-30T20:45:55Z",
        "body": "Hi @Luncher in version 2 of async the result function for filter is in the format `function(err, ret)` instead of `function(ret)`\n"
      },
      {
        "user": "Luncher",
        "created_at": "2016-05-31T02:02:38Z",
        "body": "thanks, but the wiki  not updated\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-05-31T02:23:38Z",
        "body": "Which wiki? The current docs are accurate.\n"
      }
    ]
  },
  {
    "number": 1150,
    "title": "Throwing an error in callback results in \"Unhandled rejection Error: Callback was already called.\"",
    "created_at": "2016-05-08T11:36:00Z",
    "closed_at": "2016-05-11T19:53:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1150",
    "body": "Throwing an error in callback results in \"Unhandled rejection Error: Callback was already called.\"\nThis prevents user from seeing actual error message, created by assertions in tests. \nThis hasn't been happening in 2.0.0-rc3. Is this expected behaviour in rc4?\n\nHere's the example code\n\n``` js\nasync.waterfall([\n  (next) => {\n    apiClient\n      .post('/some-url')\n      .send({prop: 'value'})\n      .expect(200)\n      .end(next);\n  }\n], (err) => {\n  assert.ifError(err);\n  throw new Error('Some Error');\n});\n```\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1150/comments",
    "author": "pziemkowski",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-05-09T20:01:52Z",
        "body": "Looks like there's a Promise inside your `apiClient` thats catching the error you're trying to throw, and calling the `.end()` callback twice.\n"
      },
      {
        "user": "pziemkowski",
        "created_at": "2016-05-12T10:36:16Z",
        "body": "ApiClient is a regular SuperAgent client. How would it even be possible for a function in waterfall, which is executed previously to catch error thrown in callback?\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-05-12T20:16:07Z",
        "body": "It's a common pitfall with continuation-passing style.  Consider this:\n\n```\nfunction someAsyncFn(arg, callback) {\n  try {\n    var foo = doSomething(arg);\n    callback(null, foo);\n  } catch (e) {\n    callback(e);\n  }\n}\n\nsomeAsyncFn(1, function(err, val) {\n  throw new Error();\n})\n```\n\nThe error thrown in the callback will be caught by `someAsyncFn`, which will then call the callback again.  Promises wrap their resolved/rejected handlers in a try/catch, so this comes up often.  There's a promise somewhere in your code handling the error.\n"
      },
      {
        "user": "pziemkowski",
        "created_at": "2016-05-14T14:36:41Z",
        "body": "You of course have been right. Pushing it down the loop with nextTick does seem to make it work.\nThank you for pointing it out, I falsely assumed that this was already happening with callback.\n\nIs there a better way to do it instead of adding additional flow function every time?\n\nI mean this:\n\n``` js\nasync.waterfall([\n  (next) => {\n    apiClient\n      .post('/some-url')\n      .send({prop: 'value'})\n      .expect(200)\n      .end(next);\n  },\n  (res, next) => async.nextTick(next, null, res)\n], (err) => {\n  assert.ifError(err);\n  throw new Error('Some Error');\n});\n```\n"
      }
    ]
  },
  {
    "number": 1136,
    "title": "async queue never triggers drain but only sometimes",
    "created_at": "2016-04-28T14:56:09Z",
    "closed_at": "2016-05-05T22:44:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1136",
    "body": "Hello Async Usersy,\n\nI'm continuing to play around with nodejs. So below is a brief summary of my launch.js app\n\n``` js\nvar counter = 0;\nvar queue = async.queue(function(objectWithVariousProperties, callback) {\n    methodDoingVariousAsynchronousStuff(objectWithVariousProperties.link, function(err,result) \n        counter++;\n        callback();\n    });\n}, 20);\n\nqueue.drain = function() {\n    log.debug(\"Finished Queue\", {\n        \"Objects processed\" : counter\n    });\n};\n//TO various iterations over several array and construct some object and then push them in the queue via \nqueue.push(media_object)\n```\n\nMy issue is that 80% of the time the process works. the application launch via the shell command nodejs launch.js , process the queue, when queue is finished it displays the 'Finished Queue' then back to shell.\n\nHowever, sometimes the drain event is never triggered but the application finished and back to the shell without any exception. I inspected during several hours my code to find if there was a missing callback, but it does not seems so.\n\nAny idea which can explain this strange random behaviour ? \nOr any tools which would help to find the leaking code or the missing callback if any ?\n\nAs I said, sometimes, the queue process more than 5000 objects without any problem and sometimes when I launch it, it process somestuff, but stop randomly,  it just does not trigger the drain event but the process stop (again without any exception or error or anything, just a normal stop)\n\nI spent a couple of evenings trying to figure out why, so if you guys had any ideas it would be gladly welcomed.\n\nThanks in advance for your feedbacks and I wish you a very nice day,\n\nAnselme\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1136/comments",
    "author": "atrhacker",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-04-28T18:52:07Z",
        "body": "Impossible to know without knowing more of your code.  What happens when you replace `methodDoingVariousAsynchronousStuff` with just a simple `setTimeout`?\n"
      },
      {
        "user": "atrhacker",
        "created_at": "2016-04-28T19:11:36Z",
        "body": "hey Aerly, Thank a lot for your feedback. Unfortunately behind this method there is a lot of logic and asynchronous call, whihc would be impossible to copy/paste. The thing is it could be a callback never returned sometimes but is there a debugging tool allowing to capture every event not fired or something like this ? I will try with the setTimeout and keep you in touch.\n"
      }
    ]
  },
  {
    "number": 1124,
    "title": "Feature request - async.forEachOf results in callback",
    "created_at": "2016-04-24T15:11:48Z",
    "closed_at": "2016-04-24T18:41:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1124",
    "body": "Hi,\n\nI am using `async.forEachOf()` quite often and I think this is a very handy tool for task parallelization over an array. However - and correct me if I am wrong - it seems like there is no way to get the different threads' results in the final callback (I am obliged to create a results array outside of the forEachOf and to populate it with the results inside the iteratee function). Wouldn't it be better if the callback is of the form `callback(err, results)` where `results` is an array of responses corresponding to all the threads, like it is the case for `async.parallel`?\n\nKind regards,\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1124/comments",
    "author": "hatimk",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-04-24T18:41:17Z",
        "body": "Just use `async.map()` instead.\n"
      }
    ]
  },
  {
    "number": 1120,
    "title": "Request For Explanation .... How To ",
    "created_at": "2016-04-21T10:15:05Z",
    "closed_at": "2016-04-21T18:46:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1120",
    "body": "So, I ran across this module, just last night and I think it will be helpful .... I just need a little \"show and tell.\" Below you can see my function \"GetBearerToken\" which takes a parameter {bearer_token:token}.. no issues there...my problem is ...the variable \"ss\" I want to use it outside of this function...pass it to another function to do something then....of course when I try and access the \"ss\" the variable is undefined. I posted this question on stackoverflow...but it was considered a duplicate. So any help would be great...Thanks\n\n```\nGetBearerToken ({bearer_token:token},function (error, result) {         \nif (error) throw error;\n if (result) \n    {\n        var resultset\n        var i;\n        for (i=0; i< result.length; i++)\n        {              \n            resultset = (simpleObjectify(result[i].meta, result[i].rows))\n        }       \n\n        var jstring = JSON.stringify(resultset);\n        var obj = JSON.parse(jstring);\n        var ss = obj[0].uuid;\n        console.log(ss)\n        })\n```\n\noutside of function ss = undefined\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1120/comments",
    "author": "forensicsguy20012004",
    "comments": [
      {
        "user": "megawac",
        "created_at": "2016-04-21T18:46:25Z",
        "body": "This is not related to this module. Place the variable definition `ss` outside of the function scope\n"
      }
    ]
  },
  {
    "number": 1104,
    "title": "How can I dynamically push functions with different arguments to an array? I need to process those functions using Async.js (parallel or race mode)",
    "created_at": "2016-04-07T23:27:23Z",
    "closed_at": "2016-04-08T20:19:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1104",
    "body": "Currently I am trying to run in parallel the same function with different arguments using Node.JS\n\nFor this I use Async.js and i am struggling trying to push/stack functions to an array. \nThe problem is that the functions are executed with the same arguments. This is what I have:\n\n``` js\nvar async = require(\"async\");\nvar array = [];\nvar x = [1,2,3,4];\n\n// This portion of code works perfect and the arguments are passed perfectly\n// The results that i am getting are: [100, 200, 300, 400]\narray.push(function(callback){ callback(null,calculate(x[0]))});\narray.push(function(callback){ callback(null,calculate(x[1]))});\narray.push(function(callback){ callback(null,calculate(x[2]))});\narray.push(function(callback){ callback(null,calculate(x[3]))});\n\n// This portion of code does not work and I dont know why ... \n// The results that i am getting are: [400, 400, 400, 400]\n// Obviusly the function is receiving the same argument a=4 everytime is called\nfor (i=0;i<3;i++){\n    array.push(function(callback){ callback(null,calculate(x[i]))});\n}\n\nasync.parallel(array,function(err,result){\n    if (err) {\n        console.log(err);\n        return;\n    }\n    console.log(\"Results are: \" + result);\n});\n\n\nfunction calculate(a) {\n  return a*100\n}\n```\n\nAny idea?\nThanks\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1104/comments",
    "author": "alfredoborrero",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-04-08T01:41:59Z",
        "body": "Lots of stuff here, including basic JS variable scoping quirks.  The short answer to your question is that you can use `async.map`, it runs in parallel too:\n\n``` js\nasync.map([1, 2, 3, 4], function(x, callback){\n  callback(null,calculate(x))\n}, function(err,result){\n    if (err) {\n        console.log(err);\n        return;\n    }\n    console.log(\"Results are: \" + result);\n});\n```\n\nBut the real answer is that you  don't need Async at all:\n\n``` js\nvar result = [1, 2, 3, 4].map(calculate)\n```\n"
      },
      {
        "user": "alfredoborrero",
        "created_at": "2016-04-08T20:15:48Z",
        "body": "Thank you very much ...\n\nSent from my iPhone\n\n> On Apr 7, 2016, at 7:42 PM, Alex Early notifications@github.com wrote:\n> \n> Lots of stuff here, including basic JS variable scoping quirks. The short answer to your question is that you can use async.map, it runs in parallel too:\n> \n> async.map([1, 2, 3, 4], function(x, callback){\n>   callback(null,calculate(x))\n> }, function(err,result){\n>     if (err) {\n>         console.log(err);\n>         return;\n>     }\n>     console.log(\"Results are: \" + result);\n> });\n> But the real answer is that you don't need Async at all:\n> \n> var result = [1, 2, 3, 4].map(calculate)\n> —\n> You are receiving this because you authored the thread.\n> Reply to this email directly or view it on GitHub\n"
      },
      {
        "user": "alfredoborrero",
        "created_at": "2016-04-09T03:24:56Z",
        "body": "Hi Caolan,\nThank you so much for the help, it worked perfectly, however I would like to know how I can implement the \"race\" mode.\nI already tried several times and I am getting errors. \nI just want to run all my functions in parallel and get the result of whoever finishes first.\nAny idea on how to implement  Async.race ?\nRegards, \nAlfredo Borrero\nDate: Thu, 7 Apr 2016 18:42:25 -0700\nFrom: notifications@github.com\nTo: async@noreply.github.com\nCC: alf_bor@hotmail.com\nSubject: Re: [caolan/async] How can I dynamically push functions with different arguments to an array? I need to process those functions using Async.js (parallel or race mode) (#1104)\n\nLots of stuff here, including basic JS variable scoping quirks.  The short answer to your question is that you can use async.map, it runs in parallel too:\n\nasync.map([1, 2, 3, 4], function(x, callback){\n  callback(null,calculate(x))\n}, function(err,result){\n    if (err) {\n        console.log(err);\n        return;\n    }\n    console.log(\"Results are: \" + result);\n});\n\nBut the real answer is that you  don't need Async at all:\n\nvar result = [1, 2, 3, 4].map(calculate)\n\n—\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\n"
      },
      {
        "user": "alfredoborrero",
        "created_at": "2016-04-16T07:08:07Z",
        "body": "Hi Caolan,\n\nThank you so much for the help, it worked perfectly, however I would like to know how I can implement the \"race\" mode. I already tried several times and I am getting errors. \nI just want to run all my functions in parallel and get the result of whoever finishes first.\nAny idea on how to implement  Async.race ?\n\nRegards, \n"
      }
    ]
  },
  {
    "number": 1066,
    "title": "async.series crash with more than 6~7 function(callback)",
    "created_at": "2016-03-16T09:35:42Z",
    "closed_at": "2016-03-20T03:36:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1066",
    "body": "```\nvar myCallback = function(error,result) {\n                if(error) {\n                    console.log(\"error: \",error,\"msg: \",result);\n                }\n                else {\n                    console.log(\"Mac is open, all action done\");\n                }\n            };\n\n            async.series([\n                    function(callback) {\n                        callback(null, 0);\n                    },\n                function(callback) {\n                    callback(null, 0);\n                },\n                function(callback) {\n                    callback(null, 0);\n                },\n\n///stop working now below function(callback) not be called\n                function(callback) {\n                    callback(null, 0);\n                },function(callback) {\n                    callback(null, 0);\n                },function(callback) {\n                    callback(null, 0);\n                },function(callback) {\n                    callback(null, 0);\n                },\n                function(callback) {\n                    callback(null, 0);\n                },\n                function(callback) {\n                    callback(null, 0);\n                },\n                function(callback) {\n                    callback(null, 0);\n                }\n                ], myCallback\n            );\n```\n\nasync.series crash with more than 6~7 function(callback), the other functions not be called , strangely.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1066/comments",
    "author": "chinawyky",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-03-17T20:15:27Z",
        "body": "What kind of crash?  If it's a stack overflow, its likely because you're calling the callbacks on the same tick.\n"
      },
      {
        "user": "chinawyky",
        "created_at": "2016-03-18T01:55:46Z",
        "body": "``` js\nvar myCallback = function(error,result) {\n                if(error) {\n                    console.log(\"error: \",error,\"msg: \",result);\n                }\n                else {\n                    console.log(\"Mac is open, all action done\");\n                }\n            };\n\n            async.series([\n                    async.ensureAsync (\n                        function(callback) {\n\n                                callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                                callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                                callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                                callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                                callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                                callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                                callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                                callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                                callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                                callback(null, 0);\n                        })\n                ], myCallback\n            );\n```\n\nasync.series crash with more than 6~7 function(callback), the other functions not be called , strangely.\n\nI wrap all the function(callback) with async.ensureAsync, but found the last 3~4 functions hadn't be called when the program finished.  The \"crash\" may be misunderstood. The program just finished but hadn't called the last 3~4 function(callback). In my opinion, each function(callback) should be called one by one until finish, yes?\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-03-18T22:51:43Z",
        "body": "I just ran you example with async@1.5.2 and everything worked -- I saw the console log in `myCallback`.  Maybe one of your steps is calling `process.exit()`?\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-03-20T03:36:15Z",
        "body": "You can reopen this if you have a reproducible test case.\n"
      },
      {
        "user": "chinawyky",
        "created_at": "2016-03-21T01:41:36Z",
        "body": "``` js\n/**\n * Created by AlonzoChen on 16/2/24.\n */\n\nvar async = require('async');\nvar assert = require('assert');\ndescribe('Array', function() {\n    describe('#indexOf()', function () {\n        it('should return -1 when the value is not present', function () {\n\n            var myCallback = function(error,result) {\n                if(error) {\n                    console.log(\"error: \",error,\"msg: \",result);\n                }\n                else {\n                    console.log(\"Mac is open, all action done\");\n                }\n            };\n\n            async.series([\n                    async.ensureAsync (\n                        function(callback) {\n\n                            callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                            callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                            callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                            callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                            callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                            callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                            callback(null, 0);\n                        }),\n                //below function not be called\n                    async.ensureAsync (\n                        function(callback) {\n\n                            callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                            callback(null, 0);\n                        }),\n                    async.ensureAsync (\n                        function(callback) {\n\n                            callback(null, 0);\n                        })\n                ], myCallback\n            );\n        });\n    });\n});\n\n```\n\nThe above is the content of my  test file which format is \".js\", it runs under async@1.5.2, node.js v5.7.0\nBut it stills exit on line:62, which means \nasync.ensureAsync (\n                        function(callback) {\n\n```\n                        callback(null, 0);\n                    }),\n```\n\nnot be called from line: 62\n"
      },
      {
        "user": "chinawyky",
        "created_at": "2016-03-21T01:42:38Z",
        "body": "sorry, I'm afraid I do not have the entitlement to reopen it.\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-03-21T02:06:47Z",
        "body": "Mocha won't see that as an async test (you need to use `done` in the `it` function), so it will exit early for that reason.\n"
      }
    ]
  },
  {
    "number": 1065,
    "title": "How use async in Angular",
    "created_at": "2016-03-15T21:04:15Z",
    "closed_at": "2016-03-21T20:13:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1065",
    "body": "Hi I want use this library in Angular but I'm not sure if it's possible because I can find Angular dependency to inject\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1065/comments",
    "author": "jairoGilC",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-03-17T20:16:37Z",
        "body": "How are you loading other libraries in your project?\n\nAsync is available on npm, bower, as a standalone script, and many other package managers.\n"
      },
      {
        "user": "skeet",
        "created_at": "2016-03-21T16:09:16Z",
        "body": "@jairoGilC If you include the Async library it will be available on the $window object:\n\n```\n$window.async.each(things, function(thing, callback) {\n   // Do stuff\n   callback();\n}, function(err) {\n   // Do more stuff\n});\n```\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-03-21T20:13:59Z",
        "body": "This seems to be more of an Angular question than an Async question.\n"
      }
    ]
  },
  {
    "number": 1062,
    "title": "How to return data when use async?",
    "created_at": "2016-03-14T08:10:09Z",
    "closed_at": "2016-03-14T23:43:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1062",
    "body": "I`m a fresher in async, I write my async like this\n\n``` js\nfunction a () {\n  // var re = '';\n  async.auto({\n    'one': function (callback) {\n      setTimeout(function() {\n        callback(null, 1);\n      }, 2000);\n    },\n    'two': function (callback) {\n      setTimeout(function() {\n        callback(null, 2);\n      }, 1000);\n    },\n    'three': ['one', function (callback) {\n      setTimeout(function() {\n        callback(null, 3);\n      }, 200);\n    }],\n  }, function (error, results) {\n    return results;\n    // re = results;\n  });\n  // return re;\n}\nvar b = a();\nconsole.log(b);\n// undefined\n```\n\nHow to get the result generated by function a ? I need your help, Thank you!\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1062/comments",
    "author": "xywenke",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-03-14T21:18:53Z",
        "body": "You can't \"return\" the value of an async result.  Any function that needs an async result will also have to become async itself. (i.e. use a callback too)\n"
      },
      {
        "user": "xywenke",
        "created_at": "2016-03-14T23:43:33Z",
        "body": "@aearly got, Thank you very much!\n"
      }
    ]
  },
  {
    "number": 1059,
    "title": "Timeout individually for each request",
    "created_at": "2016-03-12T13:05:59Z",
    "closed_at": "2016-03-15T01:51:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1059",
    "body": "I  want to make several requests with a web scraper and want you if you do not return within the time limit returns {}\nas you can do this with the timeout?\n\nMy code is:\n\n``` js\nasync.parallel(listTask,function(err, results){\n            if (results){\n                res.send(results);\n            }\n        });\n```\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1059/comments",
    "author": "rcdiaz",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-03-15T01:51:43Z",
        "body": "Yeah, you should be able to do this with `timeout` once 2.0 lands:\n\n``` js\nasync.parallel(async.timeout(60 * 1000, listTask), function(err, results){\n    if (results){\n        res.send(results);\n    }\n});\n```\n"
      },
      {
        "user": "rcdiaz",
        "created_at": "2016-03-15T07:41:10Z",
        "body": "ah ok, thanks!!\n"
      }
    ]
  },
  {
    "number": 1031,
    "title": "async.eachSeries go back one iteration?",
    "created_at": "2016-02-22T05:25:24Z",
    "closed_at": "2016-03-10T23:49:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1031",
    "body": "My current project requires an async loop that occasionally must go back to the previous iteration and perform it again. Basically what I'm asking is if there is a way to do the opposite of nextLoop(), something like a previousLoop() function?\n\nWould appreciate it if someone knows if this is possible. Thanks!\n\nCode example:\n\n```\nasync.eachSeries(array, function(val, nextLoop, previousLoop){\n   if(val==='something') nextLoop();\n   else previousLoop(); //Is it possible to do this somehow?\n}, function(){\n   console.log('Completed');\n});\n```\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1031/comments",
    "author": "tyronedougherty",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-02-23T23:59:12Z",
        "body": "We don't offer anything like that currently.  The closest thing is `async.retry`.  It is a bit of non-standard control flow.\n"
      }
    ]
  },
  {
    "number": 1024,
    "title": "Event handlers getting removed in some situations?",
    "created_at": "2016-02-10T10:54:17Z",
    "closed_at": "2016-02-10T22:57:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1024",
    "body": "Hi, \n\nI'm not sure what's going on here, so if anyone could explain I'd be very appreciative. I noticed that in some situations when using async with streams and error event handers, I'd get unhandled errors being thrown, as the error event handlers didn't seem to be registered.\n\nI've tried to reduce it to the minimal scenario.  It seems to be when using async.series, if there is a synchronously-called-back function, followed by a function which nests it's code in a setImmediate (or ensureAsync), then the error handlers are ignored.  E.g.\n\n```\n   var dummyReadStream = fs.createReadStream('doesNotExist.txt');\n\n   async.series([\n\n           function(cb) {  //Synchronous series function\n               cb();\n           },\n\n          function(cb) {\n               setImmediate(function(){  //process.nextTick does not cause the problem\n                   doSomethingWithStreamThatInvolvesErrorEvents(dummyReadStream, function(err) {\n                       cb(err);\n                   });\n               });\n           }\n\n       ],\n       function(err) {\n           if(err) { logger.error(err);}\n           process.exit(0);\n       }\n   );\n\n\n\n   function doSomethingWithStreamThatInvolvesErrorEvents(readStream, callback) {\n\n       readStream.on('error',  function(err){ callback(err); });\n\n       var writeStream = fs.createWriteStream('test.txt');\n       writeStream.on('finish', function(){ callback(); });\n       writeStream.on('error',  function(err){ callback(err); });\n       readStream.pipe(writeStream);\n   }\n```\n\nThis results in an unhandled global error (that the source file doesn't exist).  Remove either the first series function, or the setImmediate, and the error handlers work (and no unhandled error is thrown).\n\nCan someone please explain this behaviour?\n\nThank you.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1024/comments",
    "author": "srlowe",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-02-10T22:57:03Z",
        "body": "The error is happening before you attach the handler in `doSomethingWithStreamThatInvolvesErrorEvents`.  `nextTick` and sync execution are fast enough that the handler is attached in time.\n"
      }
    ]
  },
  {
    "number": 1022,
    "title": "async.queue max length?",
    "created_at": "2016-02-09T04:38:01Z",
    "closed_at": "2016-03-21T21:21:41Z",
    "labels": [
      "bug",
      "question",
      "queue"
    ],
    "url": "https://github.com/caolan/async/issues/1022",
    "body": "Is there any way to prevent/enforce a max async.queue length? I realize it's possible to set the concurrency level, but want to prevent more than a certain number of elements from being added to the queue.\n\nTried using an if statement with queue.length(), but more elements are added than wanted, due to race conditions.\n\n```\nif(queue.length() < maxLength){\n      // add an item\n}\n```\n\nMore info: queue.length() is checked after every task is finished, in order to see if more work can be added. If two or more tasks finish at the same time check queue.length() and add work, queue.length() can go beyond maxLength.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1022/comments",
    "author": "jmt0806",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-02-09T22:19:46Z",
        "body": "There are no limits on the queue length -- only the practical limits of a JS array.\n\nI think you've uncovered a inconsistency in how queue.length() is reported though. :bug: \n"
      },
      {
        "user": "jmt0806",
        "created_at": "2016-02-10T02:27:58Z",
        "body": "Is there any way to \"lock\" a separate variable in NodeJS to prevent this situation?\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-02-10T03:31:55Z",
        "body": "You shouldn't need to \"lock\" a variable in JS since it is single-threaded -- there's only a single thread writing and accessing variables.  You might have a tricky order-of-execution problem.  Try placing a breakpoint on that line.\n"
      },
      {
        "user": "jmt0806",
        "created_at": "2016-02-10T03:49:59Z",
        "body": "True, but if I add 5 tasks to async.queue and they all finish at the same time and try to increment/decrement a var on callback, isn't that a race condition?\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-02-10T11:40:20Z",
        "body": "It depends.  There is nothing that should cause a race condition here -- execution can't be preempted:\n\n``` js\n// queue is length 9, max is 10\nif(queue.length() < maxLength){\n    // length is still 9\n    queue.push(item) // add an item\n    // length is now 10\n}\n```\n\nOut of curiosity, what version of async are you using?\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-03-21T21:21:41Z",
        "body": "A more concrete test case would be useful here.\n"
      },
      {
        "user": "umeshanthem",
        "created_at": "2017-12-15T18:58:32Z",
        "body": "**Code :**\r\n```js\r\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\nvar Q = async.queue(function(line, callback) {\r\n       // I have an async call here. Eg- CallDbAndGetData(line);\r\n\tcallback();\r\n}, 10);\r\n\r\nvar s = fs.createReadStream('C:/idcards/dev/scripts/XXXXXXXXXX.txt').pipe(es.split()).pipe(es.mapSync(function(line) {\r\n   Q.push(line, function(err) {\r\n       // console.log('finished pushing '+ line);\r\n    });\r\n}));\r\n\r\nQ.drain = function() {\r\n\tconsole.log(\"All CallDbAndGetData calls were done\");\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n```\r\nProblem statement:\r\n-Consider my database has tens of millions of data rows and when i call the CallDbAndGetData function, it takes 2-3 seconds to get the response.\r\n-My Q.push is just an I/O operation which will read a line in the file and adds it to 'Q', which will happen around millisecond's time.\r\n**-Problem** : InMemory size of Q will increase too big as the poping from q is taking around 2seconds.\r\nCan we restrict the size of Q, like defining the maxSize of Q?\r\n\r\n"
      },
      {
        "user": "aearly",
        "created_at": "2017-12-15T19:51:13Z",
        "body": "A `TransformStream` or `through` stream is probably a better fit for what your'e doing.  It won't buffer the file's entire contents."
      },
      {
        "user": "umeshanthem",
        "created_at": "2017-12-19T15:08:21Z",
        "body": "```js\r\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\nvar Q = async.queue(function(line, callback) {\r\n       // I have an async call here. Eg- CallDbAndGetData(line);\r\n       if(q._tasks.length < 100)\r\n\t    s.resume();\r\n\tcallback();\r\n}, 10);\r\n\r\nvar s = fs.createReadStream('C:/idcards/dev/scripts/XXXXXXXXXX.txt').pipe(es.split()).pipe(es.mapSync(function(line) {\r\n   Q.push(line, function(err) {\r\n       // console.log('finished pushing '+ line);\r\n       if(q._tasks.length >= 100) // restricting q length\r\n\t      s.pause();\r\n    });\r\n}));\r\n\r\nQ.drain = function() {\r\n\tconsole.log(\"All CallDbAndGetData calls were done\");\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n```\r\nThis is working fine for my case. Where q's in-memory size will not be huge and make the system slow.\r\nP.S : look for this node module ``` require('sizeof'); ``` to get the memory size of an object in nodejs. "
      }
    ]
  },
  {
    "number": 1019,
    "title": "Use Queue after drain",
    "created_at": "2016-02-02T13:40:14Z",
    "closed_at": "2016-02-09T22:24:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1019",
    "body": "Is there any way to still use the queue after drain? I am using it with a simple Express server to add items to the queue on demand but when the time between requests is more than a few seconds the push stops working\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1019/comments",
    "author": "coeus01",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-02-02T22:59:26Z",
        "body": "Yes, you should be able to push more items on the queue after a `drain`.  Keep in mind that `drain` will be called multiple times as new items you push complete and the queue empties again.\n"
      }
    ]
  },
  {
    "number": 1017,
    "title": "Elephant in the room: the upcoming async keyword",
    "created_at": "2016-01-28T18:43:49Z",
    "closed_at": "2016-03-10T23:52:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1017",
    "body": "Any thoughts on what example code using async is going to look like after the `async` keyword is universal? \n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1017/comments",
    "author": "devinus",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-02-02T23:02:20Z",
        "body": "This was discussed a bit in #956 .  I think we're going to aim for interop with functions that return promises (e.g. what async functions implicitly do).  You'd be able to use an `async` function in place of a regular callback-using function.  Async would then be useful in bridging the gap between async/await/Promise-style code and callback-style code.\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-03-10T23:52:25Z",
        "body": "This is a bit clunky, but it would work today, since `asyncify` adapts functions that return promises:\n\n``` js\nasync.map(someArray, async.asyncify(async function doSomething(item) {\n  var foo = await something(item);\n  foo.bar = \"whatever\";\n  return foo;\n}), callback)\n```\n"
      }
    ]
  },
  {
    "number": 1001,
    "title": "Ability to change retry() params from the task?",
    "created_at": "2016-01-06T11:46:41Z",
    "closed_at": "2016-06-09T21:25:31Z",
    "labels": [
      "feature",
      "question",
      "feedback-wanted"
    ],
    "url": "https://github.com/caolan/async/issues/1001",
    "body": "Hello,\n\nI would like to know if it'd be possible to be able to update the `times` argument of the `retry()` from the `task`?\nFor instance, I would like to be able to increase the `interval` value as the attempt count increases or trim down the attempt count to `0` when a particular error occurred (in order to avoid unnecessary doomed attempts).\n\nExample:\n\n``` javascript\nvar opts = {\n    times: 3,\n    interval: 500\n};\n\nasync.retry(opts, function (callback) {\n    someCall(function(err) {\n        if (err) {\n            switch (err.code) {\n                case 'Code1':\n                    opts.interval += 500; // Increases the interval for next attempt\n                    return callback(err);\n                case 'Code2':\n                    opts.times = 0; // Avoid other attempts\n                    return callback(err);\n                default:\n                    return callback(err);\n            }\n        }\n\n        callback();\n    });\n}, function (err) {\n    // Some code\n});\n```\n\nAny idea or workaround?\n\nThanks,\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1001/comments",
    "author": "eexit",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-01-07T22:24:44Z",
        "body": "Unfortunately, there's no way to change the retry options after the fact right now -- we copy the options to a new object internally.\n\nTo exit early, you could callback with a null error, and some sort of sentinel object you handle specially, but it's kind of a hack.\n\nI'd love to think of a clean way to support customizing the times and interval -- perhaps a function that is called for each iteration to get the times/interval.  This would more easily enable things like exponential backoff and early exits.\n\n``` js\nfunction getNextInterval(prevInterval, remaningTimes, lastError) {\n  if (prevInterval == null) {\n    // initial iteration\n    return {\n      interval: 100,\n      times: 5\n    };   \n  }\n  if (lastError && lastError.code === \"foo\") {\n    // exit early\n    return {\n      times: 0\n    };\n  }\n  // exponential backoff\n  return {\n    interval: lastInterval * 2,\n    times: times - 1\n  };\n}\n\nasync.times(getNextInterval, worker, done);\n```\n"
      },
      {
        "user": "eexit",
        "created_at": "2016-01-25T16:52:53Z",
        "body": "Thanks @aearly! I'll try this eventually and see how it behaves...\n"
      },
      {
        "user": "murdockcrc",
        "created_at": "2016-05-06T09:06:57Z",
        "body": "Could we implement the `interval` parameter to support an array of ints? These ints will be used when the `attempts` array gets built with the timeout functions that provide the execution delay between retries. I know it does not solve the original request (to change the parameters on the fly), but I am working under the assumption that you don't necessarily need to decide the retry backoff times at runtime.\n\nObviously, if the passed parameter for `interval` is not an array but an Int, then we use that as the timeout for all the retries.\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-05-12T20:25:59Z",
        "body": "Hmmn, perhaps we could make the retry `opts` more polymorphic -- if you pass an array for the interval, it uses those numbers for each delay interval in sequence.\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-06-09T21:25:31Z",
        "body": "I think the behavior added in #1161 should be good enough for now.\n"
      }
    ]
  },
  {
    "number": 986,
    "title": "queue drain",
    "created_at": "2015-12-22T21:01:50Z",
    "closed_at": "2016-01-02T05:07:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/986",
    "body": "I am pushing items onto a queue like:\n\n```\nself.q.push(tables, function(err) {\n```\n\nand then defining \n\n```\nself.q.drain = function(err) {\n    callback(err);\n};\n```\n\nBut it seems that drain is never called. What do you think I am doing wrong? Under what conditions will drain get called?\n\nThank you.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/986/comments",
    "author": "KevinBurton",
    "comments": [
      {
        "user": "KevinBurton",
        "created_at": "2015-12-22T22:00:02Z",
        "body": "One more piece of information. I am using Node.js fs to write to a file. I am using asychronous methods in the 'worker'. Is that not allowed? Could this be contributing to my problem?\n\nThanks again.\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-12-23T00:45:22Z",
        "body": "Drain is called when the last item in the queue finishes processing. E.g. when a worker finishes and the queue size is 0.\n\nasyncronous methods are totally allowed.  It's hard to say what's going wrong without seeing more code.\n"
      },
      {
        "user": "KevinBurton",
        "created_at": "2015-12-23T04:55:42Z",
        "body": "That is what I was expecting, but it doesn't seem to be happening. I will post a full listing of code tomorrow. I was also expecting a callback for each processed task and that is also not happening. Is the decision that the task is \"done\" based on the calls to the callback or the return? If I have asynchronous methods in \"queue\" method and they don't call their callback right away won't the just fall through and eventually cause a return from the \"queue\" function? Thank you for helping me understand this library.\n"
      },
      {
        "user": "KevinBurton",
        "created_at": "2015-12-23T13:21:45Z",
        "body": "As promised here is the code I am using. The idea is to pass in an array of strings representing the names of tables. The first part of the process is to query the database regarding schema information on the table then write the information out to a file. So as  you can see from the source there are several points that are asynchronous. One, when making the query. Two, when opening the file. Three, when writing to the file. And finally when the file is closed.\n\n``` javascript\nfunction writeSchema(tables, callback) {\n    var self = this;\n    self.q = async.queue(function(item, schemaCallback) {\n        var query = 'select \\'' + item + '\\' as TableName, COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH,' +\n            'NUMERIC_PRECISION, DATETIME_PRECISION,' +\n            'IS_NULLABLE' +\n            ' from EForms.INFORMATION_SCHEMA.COLUMNS' +\n            ' where TABLE_NAME=\\'' + item + '\\'';\n        self.request = new sql.Request();\n        self.request.query(query, function(err, recordsets) {\n            if(err) {\n                return schemaCallback(err);\n            } else if(recordsets && recordsets.length > 0) {\n                fs.open(recordsets[0].TableName + '.txt', 'w', function(err, fd) {\n                    if(!err) {\n                        recordsets.forEach(function(e, i, a) {\n                            fs.write(fd, 'var ' + e.COLUMN_NAME + ' = \\'\\';\\r\\n', function(err, written, buffer) {\n                                if(err) {\n                                    return console.log(err);\n                                }\n                            });\n                        });\n                        fs.close(fd, function(err) {\n                            return schemaCallback(err);\n                        });\n                    } else {\n                        return schemaCallback(err);\n                    }\n                });\n            }\n        });\n    }, 4);\n    self.q.drain = function(err) {\n        callback(err);\n    };\n    self.q.push(tables, function(err) {\n        if(err) {\n            console.error(('Schema: ' + err.message));\n            //console.error(err.stack)\n            if(!self.q.paused) {\n                self.q.pause();\n                callback(err);\n            }\n        }\n    });\n}\n```\n\nTo manage the 'this' the routine is called like:\n\n```\n    writeSchema.call(writeSchema, tables, function(err) {\n        if(err) console.log(err);\n    });\n```\n\nIdeas as to why when I set a breakpoint either on the 'push' or in the drain it is never hit?\n\nThank you.\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-12-24T02:54:57Z",
        "body": "There's no plain `else` clause after `} else if(recordsets && recordsets.length > 0) {`.  If you get an empty result, the no callback will be called, and the task will never be considered complete.\n"
      },
      {
        "user": "KevinBurton",
        "created_at": "2015-12-29T21:51:23Z",
        "body": "One more question. I have the following code for handling the queue.\n\n```\n    var q = async.queue(function(item, callback) {\n        db.query(item, params, function(err, results) {\n            if(err) {\n                return callback(err);\n            } else {\n                return callback();\n            }\n        });\n    }, 4);\n```\n\nIt doesn't seem that return circumvents every item being processed. If there is an error I would like to flush the items in the queue avoiding having the same error hundreds of times. Is that possible?\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-01-02T05:07:35Z",
        "body": "`q.kill()` will empty the queue and stop execution of further tasks.\n"
      },
      {
        "user": "amitdhawan",
        "created_at": "2018-02-23T11:57:43Z",
        "body": "                return callback(); should be callback();  only. No return\r\n"
      },
      {
        "user": "olragon",
        "created_at": "2018-09-11T14:01:12Z",
        "body": "UPDATE 2018-09-29! It's my code, not async, async work fine! Please ignore below.\r\n\r\n----\r\nSpend >2 hours debug this issues,  if it's happen to you, just add\r\n\r\n```js\r\n// magic here\r\nq.empty = function () {\r\n  // don't known why it's work\r\n}\r\nq.drain = function () {\r\n  // it's work!\r\n}\r\n```"
      },
      {
        "user": "onkea",
        "created_at": "2018-09-28T18:20:43Z",
        "body": "I've having a different issue. For me, the drain is running too soon, almost as soon as the code starts to execute:\r\n\r\nvar dnsQueue = async.queue(function(domain, lookupAgain) {\r\n  setTimeout(\r\n    function() {\r\n        \r\n        dns.resolve(domain, function (err, address) \r\n        {\r\n            dnsArray.push({domain: domain, address: address});\r\n            console.log('domain: ' + domain + \" address: \" + address)\r\n\r\n        }\r\n        \r\n        );\r\n        lookupAgain();\r\n\r\n\r\n    }, MaxWait);\r\n}, MaxConcurrent);\r\n\r\n\r\n// All results are now finished?\r\ndnsQueue.drain = function() {\r\n    console.log('done??');\r\n//\r\n}"
      },
      {
        "user": "olragon",
        "created_at": "2018-09-28T18:40:05Z",
        "body": "@onkea your code call `lookupAgain()` immediately after first queue execute."
      },
      {
        "user": "onkea",
        "created_at": "2018-09-28T18:52:34Z",
        "body": "Thanks @olragon, I just tried moving the lookupAgain() call to the top \r\nvar dnsQueue = async.queue(function(domain, lookupAgain) {\r\n    lookupAgain();\r\nBut it still seems to be running the drain function right away."
      }
    ]
  },
  {
    "number": 981,
    "title": "semi-awkward API for async.waterfall",
    "created_at": "2015-12-17T02:22:35Z",
    "closed_at": "2015-12-21T09:46:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/981",
    "body": "Been using this API for awhile and I have a junior developer who is working with an old project that I wrote original. In looking at the old code I realize that async.waterfall is kind of awkward:\n\nthe API as is:\n\n``` js\nasync.waterfall([\n    function(callback) {\n        callback(null, 'one', 'two');\n    },\n    function(arg1, arg2, callback) {\n      // arg1 now equals 'one' and arg2 now equals 'two'\n        callback(null, 'three');\n    },\n    function(arg1, callback) {\n        // arg1 now equals 'three'\n        callback(null, 'done');\n    }\n], function (err, result) {\n\n});\n```\n\nwould it not be much easier to use like so:\n\n``` js\nasync.waterfall([\n    function(callback) {\n        callback(null, {\n          one:'one',\n          two:'two'\n       });\n    },\n    function(arg, callback) {\n        callback(null, 'three');\n    },\n    function(arg, callback) {\n        callback(null, 'done');\n    }\n], function (err, result) {\n\n});\n```\n\nis there something like this in the async API?\n\nasync.waterfall_defunk ?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/981/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-12-21T04:51:58Z",
        "body": "It's entirely up to you, the user or waterfall, whether or not to callback with one or multiple values.  You can wrap them in an object, or pass them individually, but the next step in waterfall will always be passed-in the same number of arguments as the number previous function passes to the callback.\n\nThis is a pretty key feature, I don't think it needs changing.\n"
      },
      {
        "user": "ORESoftware",
        "created_at": "2015-12-21T05:21:26Z",
        "body": "yeah you're right, I was being stupid, you can just pass in one argument, it's up to you as the user of the lib, my bad\n"
      }
    ]
  },
  {
    "number": 969,
    "title": "each and eachSeries not passing back values to results array - why?",
    "created_at": "2015-12-01T05:11:11Z",
    "closed_at": "2015-12-01T07:22:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/969",
    "body": "This is probably my misunderstanding, but there's a small chance of a bug\n\n``` javascript\n\nasync.each([1,2,3], function(value,cb){\n    setTimeout(function(){\n        cb(null,value);\n    },200);\n\n},function complete(err, results) {\n    console.log(err,results);  //results is undefined here, err is null\n});\n\n\nasync.eachSeries([1,2,3], function(value,cb){\n    setTimeout(function(){\n        cb(null,value);\n    },200);\n\n},function complete(err, results) {\n    console.log(err,results); //results is undefined here, err is null as expected\n});\n```\n\nfor the async.series and async.parallel apis, we have the results argument being populated as an array, but with async.each and async.eachSeries, this does not seem to be the case.\n\nis there something I am missing?\n\nthanks!\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/969/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "ex1st",
        "created_at": "2015-12-01T06:43:16Z",
        "body": "async.each is asynchronous equivalent for native Array.forEach. \nYou need use async.map for passing result.\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-12-01T07:22:01Z",
        "body": ":arrow_up: What he said.  `each` is just for control flow, `map` is for gathering the results.\n"
      },
      {
        "user": "ORESoftware",
        "created_at": "2015-12-02T00:34:37Z",
        "body": "thanks all\n\nasync.mapSeries is working for me\n"
      }
    ]
  },
  {
    "number": 965,
    "title": "wait for 2 callback to move on",
    "created_at": "2015-11-29T10:57:14Z",
    "closed_at": "2015-12-01T07:23:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/965",
    "body": "consider the following scenario:\nAsync that calls a function that has 2 async functions inside.\nI want to move on only when both functions return the callback. Is it possible?\n\n```\nasync.each([arr,function(report,callback){\n  foo();\n},endCallback);\n\nfunction foo(){\n\n  FunctionA() //does something async we need to wait for\n  FunctionB() //does something async we need to wait for\n\n}\n```\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/965/comments",
    "author": "guypaskar",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-11-30T03:49:06Z",
        "body": "You can use `async.series` inside `foo()` to combine the two  together.  Just make sure that `foo` takes in and calls a callback.  You also might be able to use `waterfall` or `seq` depending on how related `FunctionA` and `FunctionB` are.\n"
      }
    ]
  },
  {
    "number": 957,
    "title": "Version of async.series where each task receives the results of all previous tasks ",
    "created_at": "2015-11-16T21:34:24Z",
    "closed_at": "2016-03-22T21:46:21Z",
    "labels": [
      "feature",
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/957",
    "body": "I frequently encounter a situation where a async.series task need the results of several previous tasks. async.waterfall is insufficient since it only provides the result of the last previous task. async,auto is too verbose, and provides additional, unneeded dependency declaration.\n\nA new function (or an improvment of async.series) would come in handy. Each task would receive a result object containing the results of all previous tasks\n\nPossible names: accumulate, seriesAccumulate\n\nExample: \n\n``` js\nasync.accumulate({\n    one: function(callback){\n        setTimeout(function(){\n            callback(null, 1);\n        }, 200);\n    },\n    two: function(callback, results){\n        // results: {one: 1}\n        setTimeout(function(){\n            callback(null, 2);\n        }, 100);\n    },\n    three: function(callback, results){\n         // results: {one: 1, two: 2}\n        setTimeout(function(){\n            callback(null, results.one + results.two);\n        }, 100);\n    }\n},\nfunction(err, results) {\n    // results is now equal to: {one: 1, two: 2, three: 3}\n});\n```\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/957/comments",
    "author": "alexpusch",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-11-16T21:36:41Z",
        "body": "Have you checked out `async.auto`?  It does something very similar to what you describe.\n"
      },
      {
        "user": "alexpusch",
        "created_at": "2015-11-16T21:42:02Z",
        "body": "As I mentioned, in a simple series scenario async.auto is too verbose, The user have to declare that each step is dependent on the previous one, resulting in those ugly arrays and duplicate step names\n\n``` js\nasync.auto({\n    one: function(callback){\n        setTimeout(function(){\n            callback(null, 1);\n        }, 200);\n    },\n    two: [\"one\", function(callback, results){\n        setTimeout(function(){\n            callback(null, 2);\n        }, 100);\n    }],\n    three: [\"two\", function(callback, results){\n        setTimeout(function(){\n            callback(null, results.one + results.two);\n        }, 100);\n    }\n   ]\n},\nfunction(err, results) {\n    // results is now equal to: {one: 1, two: 2, three: 3}\n});\n```\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-11-25T23:44:18Z",
        "body": "We are going to make some enhancements to auto in the next major release -- always have the callback last, and also add `autoInject` (#608) which infers the dependencies from the parameter names.\n\nI don't like this proposal because it relies on the order of the object keys -- something which is not guaranteed across JS environments (and is only guaranteed in Node for small objects).  With arrays it is possible, but it is too similar to `async.waterfall`.  I'm not sure we need something in between `auto` and `waterfall`, especially if we're adding `autoInject`.\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-11-25T23:56:21Z",
        "body": "A way to accomplish what you want:\n\n``` js\nfunction seriesAccumulate(tasks, done) {\n  async.reduce(tasks, [], function (results, task, next) {\n    task(results, function (err, result) {\n      results.push(result);\n      next(err, result);\n    });\n  }, done);\n}\n```\n\nI'd recommend against trying to use an object to iterate in series.\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-03-22T21:46:21Z",
        "body": "Closing this.  I don't think we need another method between `series` and `waterfall` in style.\n"
      }
    ]
  },
  {
    "number": 939,
    "title": "Does the async.each() method return the array in the same order?",
    "created_at": "2015-10-22T18:17:40Z",
    "closed_at": "2015-10-22T23:16:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/939",
    "body": "This may seem like a silly question but I want to ensure I understand it correctly. I understand that the iterator will obviously take a different amount of time per function in the array. But, is the returned array mapped in the initial order, or in the order in which the async callbacks were returned?\n\nThank you!!\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/939/comments",
    "author": "DaddyWarbucks",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-10-22T18:27:48Z",
        "body": "`async.each` and family don't return arrays at all -- just an error if one occurred.  If you want to ensure the order of results a parallel fashion, use `async.map`.\n"
      },
      {
        "user": "DaddyWarbucks",
        "created_at": "2015-10-22T23:16:17Z",
        "body": "Duh. Thank you. Sorry for the stupid question.\n"
      }
    ]
  },
  {
    "number": 937,
    "title": "Async parallel not calling final callback",
    "created_at": "2015-10-21T13:13:10Z",
    "closed_at": "2016-01-07T23:27:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/937",
    "body": "I am adding functions dynamically to an array to process them parallely (I/O wise).\n\nHere is what the code looks like:\n\n``` js\nvar parallelFn = function (i, callback) {\n  _someInternalFunction(arg, arg1, [], function (err, res) {\n    if (err) {\n      return callback(err);\n    } else {\n      if (res && res.length > 0) {\n        var items = res;\n        for (var j = 0; j < items.length; j++) {\n          // Do something\n        }\n        console.log(res.length);\n        return callback(null, res);\n      } else {\n        return callback('Error');\n      }\n    }\n  });\n};\n\nvar parallelFns = [];\n\nfor (var i=0; i<arr.length; i++) {\n  parallelFns = parallelFns.concat(\n    parallelFn.bind(null, i)\n  );\n}\n\nasync.parallel(parallelFns, function (err, results) {\n  console.log(err, results);\n\n});\n\n```\n\nAll the functions are called and `res.length` is logged, but the log in the callback is not called. What am I doing wrong here?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/937/comments",
    "author": "MrDHat",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-10-21T17:47:55Z",
        "body": "Are all your `parallelFns` completing?\n"
      },
      {
        "user": "MrDHat",
        "created_at": "2015-10-21T17:58:32Z",
        "body": "Yes. All the functions complete.\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-10-22T06:18:07Z",
        "body": "It's impossible to debug further without knowing what your internal function is  doing.  I would guess there is something going wrong there.\n"
      },
      {
        "user": "MrDHat",
        "created_at": "2015-10-22T08:37:04Z",
        "body": "The function is simple, it sends request to a third party api and returns the results.\nThat function works fine as I can successfully log the values of `res`\nEverything works as expected till `console.log(res.length);` Only the callback is not called.\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-10-26T19:04:56Z",
        "body": "So you see the results of `console.log(res.length)` for each item in `arr`?  No more, no less?\n"
      },
      {
        "user": "MrDHat",
        "created_at": "2015-10-26T19:06:54Z",
        "body": "Yes, exactly.\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-10-26T19:15:17Z",
        "body": "I tried this with the latest version of async:\n\n``` js\nvar async = require(\"async\");\n\nfunction _someInternalFunction(arg, callback) {\n    setTimeout(function () {\n        callback(null, [arg]);\n    });\n}\n\nvar arr = new Array(10);\n\nvar parallelFn = function (i, callback) {\n    _someInternalFunction(i, function (err, res) {\n        if (err) {\n            return callback(err);\n        } else {\n            if (res && res.length > 0) {\n                var items = res;\n                for (var j = 0; j < items.length; j++) {\n                    // Do something\n                }\n                console.log(res.length);\n                return callback(null, res);\n            } else {\n                return callback('Error');\n            }\n        }\n    });\n};\n\nvar parallelFns = [];\n\nfor (var i=0; i<arr.length; i++) {\n    parallelFns = parallelFns.concat(\n        parallelFn.bind(null, i)\n    );\n}\n\nasync.parallel(parallelFns, function (err, results) {\n    console.log(err, results);\n\n});\n```\n\nIt logged:\n\n```\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\nnull [ [ 0 ], [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7 ], [ 8 ], [ 9 ] ]\n```\n\nSeems to be working.  I bet the issue is in the implementation of `_someInternalFunction`.  It might be calling-back twice.\n"
      },
      {
        "user": "kafka-tamura",
        "created_at": "2017-04-30T20:04:34Z",
        "body": "@MrDHat Were you able to solve this? If yes, how? Was the issue in the internal function as @aearly pointed out."
      },
      {
        "user": "MrDHat",
        "created_at": "2017-05-01T08:17:23Z",
        "body": "@kafka-tamura I don't remember the exact issue, but, as far as I remember, the issue was in the internal function."
      }
    ]
  },
  {
    "number": 935,
    "title": "Failed assert is not propagated out of async.",
    "created_at": "2015-10-20T12:10:28Z",
    "closed_at": "2015-10-21T17:33:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/935",
    "body": "Hi,\nstarting in async 1.1.0 (also reproducible in 1.4.2) I have a problem in this block of my testing nodeJS code:\n\n``` javascript\n'test step': function(done) {\n    async.waterfall([\n        function (next) {\n            query('SELECT Id, Name, FROM Contact WHERE Email = \\'' + email + '\\'', next);\n    },\n    function (result, next) {\n        assert.strictEqual(result.totalSize, 1, 'Expecting exactly 1 record in Salesforce Contact');\n            next();\n        }\n    ], function(err) {\n           done(err);\n   });\n\n```\n\nUsing latest Mocha (2.3.3) for executing this test step.\n\nIn async 1.0.0 when assert fail, error is thrown, Mocha catch it immediately.\nBut starting async 1.1.0 if assert fail, nothing is done - looks like no throw, no callback call. Reaching Mocha timeouts.\nReproducible with chai.assert and nodeJS assert.\n\nCan you please look at it and say, what is wrong?\nThank you!\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/935/comments",
    "author": "mpetrak",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-10-20T16:23:36Z",
        "body": "What happens when you test without `waterfall`? e.g.\n\n``` js\n'test step': function(done) {\n    query('SELECT Id, Name, FROM Contact WHERE Email = \\'' + email + '\\'', function (err, result) {\n        assert.strictEqual(result.totalSize, 1, 'Expecting exactly 1 record in Salesforce Contact');         \n        done(err);\n   });\n}\n```\n"
      },
      {
        "user": "mpetrak",
        "created_at": "2015-10-21T07:43:09Z",
        "body": "Ohh, same without `waterfall`.\nSeems, it is not an async issue, but something is wrong with Salesforce query library / my usage.\n\nApologies and thank you.\n"
      }
    ]
  },
  {
    "number": 934,
    "title": "exit async.retry early",
    "created_at": "2015-10-19T10:55:58Z",
    "closed_at": "2015-10-25T06:20:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/934",
    "body": "Hi,\n\nas far as I understand,  `async.retry(5, apiMethod, resultHandler);`\nwill try to execute apiMethod 5 times if apiMethod returns an error. My program might run into situations, where it doesn't make sense to try apiMethod again after the first try. In other situations, a second try might be necessary.\n\nIs the following code safe?\n\n```\nasync.retry(5, function() {\n  if (...) {\n    // no error\n    callback(null);\n    return;\n  } else {\n    // error\n    if(...) {\n      // another try might work\n      callback(err);\n      return;\n    } else {\n      // another try will not work\n      // break without calling callback()!\n      anotherResultHandler();\n      return;\n    }\n  }\n}, resultHandler);\n```\n\nIs there another way to break async.retry early?\n\nThanks\nMichael\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/934/comments",
    "author": "michAtEl",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-10-19T16:29:49Z",
        "body": "`doWhilst` might be a better use case for what you're trying to do -- you have better control over the exit condition.\n"
      },
      {
        "user": "michAtEl",
        "created_at": "2015-10-21T20:53:09Z",
        "body": "aearly,\nThank you very much, this helps. \n\nBut I still wonder if it is possible to break async.retry (or other Control Flow patterns) early. Caolan proposed a similar way to break a waterfall early in pull #85 (\"... just use a named function for the final callback and call that instead of the task callback passed into the successful task function.\"). Does this work for other Control Flow patternsas well? If yes: I think, this should be added to the documentation.\n\nMichael\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-10-21T21:05:44Z",
        "body": "It does work, but it causes a memory leak.  The context for the waterfall is never cleaned up because it waits forever for the function you exit early from to call the waterfall callback.  There's more discussion in #552  and #880 .  One work around is to callback with a known object as the `err` parameter after you exit early, and then ignore that specific error object in the final callback.  But for your use case, `doWhilst` is likely simpler.\n"
      }
    ]
  },
  {
    "number": 931,
    "title": "Async.each[Series] not allows provide additional arguments to iterator",
    "created_at": "2015-10-15T18:26:25Z",
    "closed_at": "2015-10-25T06:20:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/931",
    "body": "Hello. I'm using async quite often in my code, especially async.each[Series] to process arrays of data. I have need to use several nest async.each[Series] to process data in categories (for instance: for each day, for each user, for each action for each currency do smth) and need to pass more global variables to the bottom of this chain for database query. But I can do that only making nested functions, and as you can see from example above, nesting degree is about 4, which make code looks awful and each time make some more fancy names for callbacks. \n\nSo the problem is that it is not possible to pass anything into iterator function arguments but target array. Is it possible to change this? Or maybe there is some way to avoid that, and therefore avoid high nesting degree?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/931/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-10-22T06:22:47Z",
        "body": "You can pass additional args to function using partial application using `Function.bind` or `_.partial`.  It also might be worth investigating if your tasks are suitable for  `async.map[Series]` or another array processing function.  Also check out  `auto` -- its really handy for complicated async flows.\n"
      }
    ]
  },
  {
    "number": 919,
    "title": "How to re-push failed task?",
    "created_at": "2015-09-28T16:34:20Z",
    "closed_at": "2015-09-29T00:58:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/919",
    "body": "Hi ..\n\nany idea how to re-push failed task, inside my async.queue, i've try something like this, but not work ..\n\n``` js\nvar q = async.queue(function(task, nextQueue) {\n    // do something\n\n    if (err) {\n        q.push(task)\n    }\n})\n```\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/919/comments",
    "author": "fer-ri",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-09-29T00:26:55Z",
        "body": "Try this:\n\n``` js\nvar q = async.queue(function(task, nextQueue) {\n    // do something\n});\n\nfunction pushWithRetry(data) {\n  q.push(data, function (err) {\n    if (err) {\n      pushWithRetry(data);\n    }\n  });\n}\n\npushWithRetry({whatever...});\n```\n"
      },
      {
        "user": "fer-ri",
        "created_at": "2015-09-29T00:58:51Z",
        "body": "ah nice .. so we retry failed task inside callback `push`\n\nThanks :+1: \n"
      }
    ]
  },
  {
    "number": 913,
    "title": "NPM install fails",
    "created_at": "2015-09-18T20:03:16Z",
    "closed_at": "2015-09-18T20:10:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/913",
    "body": "I try doing npm install async --save\nyet, it gives this error:  \n\nnpm ERR! Failed to parse json\nnpm ERR! Unexpected token 'h' at 17:6\nnpm ERR!     \"https\": \"^1.0.0\",\nnpm ERR!      ^\nnpm ERR! File: /Users/myUserAccount/Desktop/myProjectFolder/package.json\nnpm ERR! Failed to parse package.json data.\nnpm ERR! package.json must be actual JSON, not just JavaScript.\nnpm ERR! \nnpm ERR! This is not a bug in npm.\nnpm ERR! Tell the package author to fix their package.json file. JSON.parse\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/913/comments",
    "author": "squirrelsRduck",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-09-18T20:10:05Z",
        "body": "Looks like a parse error in `/Users/myUserAccount/Desktop/myProjectFolder/package.json`\n"
      },
      {
        "user": "squirrelsRduck",
        "created_at": "2015-09-18T20:10:39Z",
        "body": "good call, just noticed that.  thanks\n"
      }
    ]
  },
  {
    "number": 906,
    "title": "async.each not calling the asynchronous function inside it",
    "created_at": "2015-09-10T12:23:20Z",
    "closed_at": "2015-09-15T18:20:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/906",
    "body": "Hi\n\nAm trying to execute a asynchronous method inside async.each.\nBut the asynchronous function “GetNasVirtualDevice “ is never getting fired.\nKindly help where am wrong.\n\nBelow is my code\n:\n\n``` js\nexports.GetNasVirtualDevice = function GetNasPhysicalDeviceByNameAndPhysicalDeviceId(nasVirtualDeviceName, nasPhysicalDeviceName, callback) {\n    console.log(\"Virtual Device: \" + nasVirtualDeviceName + \"Physical Device : \" + nasPhysicalDeviceName);\n    NasVirtualDevice.findOne({ VirtualDeviceName: nasVirtualDeviceName, PhysicalDeviceName: nasPhysicalDeviceName }, function (err, virtualDevices) {\n        if (err) {\n            callback(\"\", err);\n        }\n        else {\n            //console.log(nasVirtualDeviceName);\n            callback(\"\", virtualDevices);\n        }\n\n    });\n}\nexports.ProcessNasVirtualDevices = function ProcessNasVirtualDevicesInfo(virtualDevices, callback)\n{\n    console.log(\"Started Virtual Devices\");\n    var virtualDeviceIds = [];\n    if (virtualDevices != null) {\n        //Loop through the virtual devices\n\n        async.each(virtualDevices, function (objVirtualDevice, cb) {             \n               this.GetNasVirtualDevice(objVirtualDevice.VirtualDeviceName, objVirtualDevice.PhysicalDeviceName, function (err, nasVirtualDevice) {\n                if (err) {\n                    cb(\"\", err);\n                }\n                if (nasVirtualDevice) {\n                    //console.log(\"Update\");\n                    //for (virtualDeviceProps in objVirtualDevice) {\n                    //    console.log(\"Virtual Device Properties - \" + virtualDeviceProps);\n                    //    nasVirtualDevice[virtualDeviceProps] = objVirtualDevice[virtualDeviceProps];\n                    //}\n                    nasVirtualDevice.PhysicalDeviceName = objVirtualDevice.PhysicalDeviceName;\n                    nasVirtualDevice.VirtualDeviceName = objVirtualDevice.VirtualDeviceName;\n                    nasVirtualDevice.IPAddress = objVirtualDevice.IPAddress;\n                    nasVirtualDevice.Domain = objVirtualDevice.Domain;\n                    nasVirtualDevice.Status = objVirtualDevice.Status;\n\n                    nasVirtualDevice.save(function (err) {\n                        if (err) {\n                            cb(\"\", err);\n                        }\n                        console.log(\"NasVirtualDevice \" + objVirtualDevice.VirtualDeviceName + \" updated\");\n                    });\n\n                }\n\n                else {\n                    // console.log(JSON.parse(sharePointData[\"SharePointInfo\"][\"Errors\"]));\n\n                    var nasVirtualDevice = new NasVirtualDevice();\n\n                    //for (virtualDeviceProps in objVirtualDevice) {\n                    //    console.log(\"Properties - \" + virtualDeviceProps);\n                    //    nasVirtualDevice[virtualDeviceProps] = objVirtualDevice[virtualDeviceProps];\n                    //}\n\n                    nasVirtualDevice.PhysicalDeviceName = objVirtualDevice.PhysicalDeviceName;\n                    nasVirtualDevice.VirtualDeviceName = objVirtualDevice.VirtualDeviceName;\n                    nasVirtualDevice.IPAddress = objVirtualDevice.IPAddress;\n                    nasVirtualDevice.Domain = objVirtualDevice.Domain;\n                    nasVirtualDevice.Status = objVirtualDevice.Status;\n\n                    //console.log(nasPhysicalDevice);\n                    nasVirtualDevice.save(function (err) {\n                        if (err) {\n                            cb(\"\", err);\n                        }\n                        console.log(\"NasVirtualDevice \" + objVirtualDevice.VirtualDeviceName + \" added\");\n                    });\n\n\n                }\n                cb();\n\n            });\n\n        }, function (err) {\n            // if any of the file processing produced an error, err would equal that error\n            if (err) {\n                // One of the iterations produced an error.\n                // All processing will now stop.\n                console.log('A Nas Virtual Device Failed');\n            } else {\n                console.log('All Virtual Device completed successfully');\n            }\n\n        });\n        callback(\"Nas Virtual Devices Completed\");\n\n    }\n\n}\n```\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/906/comments",
    "author": "PreethiBabu87",
    "comments": [
      {
        "user": "RaghavendhraK",
        "created_at": "2015-09-10T15:02:14Z",
        "body": "I am also facing this type of issue. But with async,series(seriesTasks) inside async.eachSeries(array). The callback of eachSeries is getting called when the first task of seriesTasks is done.\nThe same code was working fine previously with v0.9.\nWhen I updated it, it got messed up.\n\nSeems to be this issue, exists from 1.1.0. It worked in 1..0.0\n"
      },
      {
        "user": "tombell",
        "created_at": "2015-09-10T15:38:45Z",
        "body": "Encountered this after upgrading in an internal project.\n"
      },
      {
        "user": "PreethiBabu87",
        "created_at": "2015-09-10T15:49:34Z",
        "body": "to be more precise..\nmodel.findOne or model.find does not execute when inside async.each.\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-09-10T17:46:01Z",
        "body": "I notice you're calling `cb(\"\", err)`.  The `err` should be the first parameter to callbacks.\n"
      }
    ]
  },
  {
    "number": 901,
    "title": "How to send arguments in async.auto in its first method",
    "created_at": "2015-09-04T17:06:11Z",
    "closed_at": "2015-09-05T04:53:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/901",
    "body": "``` js\nvar signup=function(user){\nAsync.auto({\n            verifyPassword:verifyPassword,\n            saveUser:['verifyPassword',saveUser]\n            })\n}\nvar verifyPassword=function(user,next ){\n\n}\n```\n\nNow I want to send user object into verifyPassword function\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/901/comments",
    "author": "abhaygarg",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-09-04T18:06:34Z",
        "body": "You can use `async.apply` to partially apply `verifyPassword`:\n\n``` js\n    verifyPassword: async.apply(verifyPassword, user),\n```\n"
      },
      {
        "user": "abhaygarg",
        "created_at": "2015-09-05T04:53:24Z",
        "body": "Thanks it works\n"
      }
    ]
  },
  {
    "number": 889,
    "title": "[question] about asynch loading",
    "created_at": "2015-08-20T19:10:39Z",
    "closed_at": "2015-08-20T20:07:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/889",
    "body": "Hi,\nplease excuse my ignorance on the matter. Does asych work like head.js? Meaning you can load resources like JS scripts and CSS asynchronously in the browser?\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/889/comments",
    "author": "neuropass",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-08-20T20:07:58Z",
        "body": "Nope.  `async` has nothing to do with the async property for styles/scripts.\n"
      }
    ]
  },
  {
    "number": 888,
    "title": "Async.map calling its own callback function and ignoring my defined callback",
    "created_at": "2015-08-20T19:01:41Z",
    "closed_at": "2015-08-20T21:32:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/888",
    "body": "I have something like this\n\n``` js\nvar async = require('async');\nvar request = require('request');//request urls\n\nvar urls = ['url1','url2', 'url3' ];\n\nfunction requestUrl( url, callback){\n  request(url, function(err, resp, body){\n    callback(null, body)\n }\n}\n\nfunction cb(err, results){ console.log(results); }\n```\n\nthen I call it via\n\n``` js\nasync.map(urls, requestUrl, cb);\n```\n\nMy 'cb' never gets called. I am printing out the 'callback' function in the second parameter and it looks like this.\n\n``` js\nfunction (err, v) {\n  results[index] = v;\n  callback(err);\n}\n```\n\nWhy is it ignoring my callback and putting it in its own?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/888/comments",
    "author": "leonaburime",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-08-20T20:07:00Z",
        "body": "You're not handling the `err` in the `request` callback.  That might  be masking what the real issue is.\n"
      },
      {
        "user": "leonaburime",
        "created_at": "2015-08-20T21:32:12Z",
        "body": "This was my fault. Bad  code configuration\n"
      },
      {
        "user": "leonaburime",
        "created_at": "2015-08-20T21:32:31Z",
        "body": "Ill delete this if possible\n"
      }
    ]
  },
  {
    "number": 887,
    "title": "feature request",
    "created_at": "2015-08-20T15:11:05Z",
    "closed_at": "2015-10-25T06:23:00Z",
    "labels": [
      "feature",
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/887",
    "body": "wouldn't it be lovely if we could express our codes like this:\n\n```\nasync.waterfall( [\n    async.parallel( [\n        paralel_task1_1,\n        paralel_task1_2,\n        paralel_task1_3,\n     ]),\n     process_sync_point1,\n     async.parallel( [\n        paralel_task2_1,\n        paralel_task2_2,\n        paralel_task2_3,\n     ])\n], function(err) { \n     console[ err ? \"error\" : \"info\" ](\"process complete with \" , err || \"SUCCESS\" )\n})\n```\n\nnow it's not possible, because async.parallel, and async.waterfall (and their synonyms) return 'undefined'.\n\nWhat I propose - is that if they don't accept a finalling callback - they should not exectute, but return a function, representing the given flow-unit\n\nso now the current form requires some scaffold which does not really have any semantic meaning to the reader:\n\n```\nasync.waterfall( [\n    function (next) { \n        async.parallel( [\n            paralel_task1_1,\n            paralel_task1_2,\n            paralel_task1_3\n        ], next);\n     },\n     process_sync_point1,\n     function (result, next) {\n         async.parallel( [\n             paralel_task2_1,\n             paralel_task2_2,\n             paralel_task2_3\n         ], next);\n    }\n], function(err) { \n     console[ err ? \"error\" : \"info\" ](\"process complete with \" , err || \"SUCCESS\" )\n})\n```\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/887/comments",
    "author": "osherx",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-08-21T22:20:24Z",
        "body": "Sounds like you want currying. If you're using lodash, you can do something like:\n\n``` js\nvar parallel = _.curry(async.parallel, 2);\n```\n\nThen `parallel` will work like your first example.  We're thinking of doing this, but it doesn't work for functions with optional parameters, and there are slight performance implications.  `async.apply` also is something to explore -- it does partial application.\n\n(somewhat related: #745 )\n"
      },
      {
        "user": "osherx",
        "created_at": "2015-08-23T15:16:32Z",
        "body": "got it, thanks.\n\nBTW - async.apply looks a form of Function#bind for old browsers, am I right?\n\nand lodash - it would be great to makedo without it... \n\nSo first step would be:\n\n```\nfunction parallelStep(stack) {\n     return function(next) {\n          async.parallel(stack, next)\n     }\n}\n```\n\nbut still need to resolve passing of arguments accepted from previous stage\n\nso I guess something like:\n\n```\nfunction parallelStep(stack) {\n     return function() {\n          var next = Array.prototype.pop.apply(arguments)\n              , args = arguments\n              ;\n          async.parallel(stack.map( function(f) { return f.bind(null, args) }), next)\n     }\n}\n```\n\nah, and then - there's compatibility between handling of Array-Stack and Object-Stack.\n\n```\nfunction parallelStep(stack) {\n     return function() {\n          var next = Array.prototype.pop.apply(arguments)\n              , args = arguments\n              ;\n          async.parallel(\n             Array.isArray(stack)\n               ?  stack.map( function(f) { return f.bind(null, args) } )\n               :  Object.keys(stack).reduce( function(m, k) { m[k] = stack[k].bind(null, args); return m }, {} ) } )\n         , next)\n     }\n}\n```\n\nworths a PR?\n(assuming I use browser compatibility and add tests to that)\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-08-26T22:39:26Z",
        "body": "I'd want to solve this more broadly than just with `parallel`, and without creating more methods.  I think auto-currying methods makes the most sense in most cases, but I'd save it for a major release.  In the meantime you can do `async.apply(async.parallel, stack)`, but that doesn't solve the case where you want to pass an additional arg to each function.\n"
      },
      {
        "user": "osherx",
        "created_at": "2015-08-27T09:30:04Z",
        "body": "clear.\nkeep us posted for the new major... ;)\n"
      }
    ]
  },
  {
    "number": 885,
    "title": "\"Callback was already called\" error firing inapropriately",
    "created_at": "2015-08-18T16:27:40Z",
    "closed_at": "2015-09-29T19:48:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/885",
    "body": "I am still trying to isolate exactly how this is happening/carve out our erroring code so I can reasonably paste an example in here but I have some code that worked great before the multiple callback protection that now throws this error. Any tips on what might cause this (in my code or async) would be greatly appreciated.  I have traced through our code and I can't find any problems with our callbacks other than that we get this error.\n\nTo keep track of series being initialized and their final callback being called I I added the following to async.js:\n- a counter at the top of the file initialized to 0\n- add cod to  async.series() to:\n  - increment the counter \n  - use that counter in console logs to see when a new series is initialized and when we hit the final callback for that series.\n\nWhen I run my code I see:\ninitializing series 1\ninitializing series 2\nSeries Callback 2\nSeries Callback 1\ninitializing series 3\ninitializing series 4\nSeries Callback 4\nSeries Callback 3\ninitializing series 5\n[callback already called error]\n\nSeries 1 & 2 are nested inside a function and series 5 is the start of that same function being called again with different params.  When we enter series 5 with these new parameters the first function just gets in an if statement then calls it's callback and this is when the error fires.\n\n```\n    async.series(\n                [\n                    function(series_cb){\n                        if (size === null || action === 'delete') {\n                            //this next line causes the error\n                            return series_cb();\n                        }\n                        ...\n```\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/885/comments",
    "author": "benjamincarp",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-08-18T18:24:31Z",
        "body": "Your example code doesn't provide enough context to know what's going wrong.  You need to verify that there's no way any of your series steps could call a callback twice.\n"
      },
      {
        "user": "benjamincarp",
        "created_at": "2015-08-18T20:04:31Z",
        "body": "This error should only appear if a single step of a series calls its callback more than once correct?\n\nIf so, there is something going wrong because the point where we get the error is a callback at the top of the first step in the series (we want to skip that step because of the parameters passed in).  Since there are no callbacks in the series before this one, nothing could have previously called it unless the previous async.series calls (which have all finished and already called their final callback) are somehow interfering.\n\nI did step through all of our code line by line this morning to confirm that no steps called a callback twice and everything looks correct to me.  Do you have any tips on something else to look for?\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-08-18T21:13:57Z",
        "body": "I cant tell without seeing more  of your  code.  See if you can isolate what is going wrong to a smaller code example.\n"
      },
      {
        "user": "AndrewBarba",
        "created_at": "2015-08-23T00:21:49Z",
        "body": "Just to add to this, we are having the exact same problem. Really difficult to track down the exact issue or come up with an example but will keep at it.\n"
      },
      {
        "user": "AndrewBarba",
        "created_at": "2015-08-23T00:33:32Z",
        "body": "And 5 minutes later I found what was wrong on our end... Example if it helps\n\n```\nfunction doSomething(list, next) {\n  var result = ...\n  _.each(list, function(item) {\n    if (fails(item)) return next(new Error(...))\n  });\n  next(null, result)\n}\n```\n\nIt's a pretty common pattern for us to check for an error and then return near the top of the function. In this case we did that in an underscore each which returns from the context of underscore but does not return from the enclosing function, and thus the callback was being called twice. Hope that helps someone else out there.\n"
      },
      {
        "user": "benjamincarp",
        "created_at": "2015-09-29T19:48:46Z",
        "body": "In the end, this was a problem on our end that just exhibited itself in a very odd fashion.  Sorry for the false alarm.  I would like to provide more info on exactly what was happening but I have since changed jobs and no longer have access to their repo to reference for describing it.\n"
      },
      {
        "user": "samuelgoldenbaum",
        "created_at": "2017-05-02T20:56:21Z",
        "body": "@AndrewBarba could you perhaps add some more code showing the problem and fix? If did you deal with the guard clauses at the top of the function?"
      }
    ]
  },
  {
    "number": 880,
    "title": "Is this some kind of memory/resources leak?",
    "created_at": "2015-08-11T09:03:37Z",
    "closed_at": "2015-08-17T21:34:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/880",
    "body": "I have question about memory/resources leak in this kind of async.series construction, as you can see this code breaks async flow and it runs next function in the middle of async chain instead of collecting result until final callback is reached:\n\n``` js\nmodule.exports = function(next) {\n    var async = require('async');\n    var success;\n    async.series([\n        function(callback) {\n            // Step 1: do somthing... and set success to true or false\n            callback();\n        },\n\n        function(callback) {\n            // Step 2: if first step was success break flow control and call \"next\" immediately\n            if (success) {\n                next(null, success);\n            } else {\n                callback();\n            }\n        },\n\n        function(callback) {\n            // Step 3: do something else to gain success, this is nothing special...\n            callback();\n        },\n\n        function(callback) {\n            // Step 4: pass flow control to next(), callback is NOT CALLED\n            next(null, success);\n        }\n    ], function(err) {\n        // Handle error only:\n        next(err);\n    });\n};\n```\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/880/comments",
    "author": "pawellen",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-08-11T17:52:10Z",
        "body": "Yeah, it is.  Some discussion here: #552 \n"
      },
      {
        "user": "megawac",
        "created_at": "2015-08-16T19:34:51Z",
        "body": "You can consider calling `callback('Complete')` or similar if success, which I assume would be more appropriate anyway\n"
      },
      {
        "user": "megawac",
        "created_at": "2015-08-17T21:35:31Z",
        "body": "Dupe of #552 \n"
      }
    ]
  },
  {
    "number": 878,
    "title": "forEachOf is not implemented ?",
    "created_at": "2015-08-09T11:04:45Z",
    "closed_at": "2015-08-16T19:35:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/878",
    "body": "Hello.\nthe docs of async shows the function forEachOf\nit seems that this function doesn't exist in async.\n\nany ideas ?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/878/comments",
    "author": "kfirufk",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-08-09T22:10:56Z",
        "body": "What version are you using?  It was added after v 1.0\n"
      },
      {
        "user": "kfirufk",
        "created_at": "2015-08-23T06:16:13Z",
        "body": "thank you! :) that was the problem. i was using an older version of async.\n"
      }
    ]
  },
  {
    "number": 877,
    "title": "Ensure the callback fn is always the last parameter of waterfall functions",
    "created_at": "2015-08-07T19:16:21Z",
    "closed_at": "2015-08-07T20:37:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/877",
    "body": "Currently, in a `waterfall`, the current function needs to know exactly how many parameters the next function is expecting.  Something like this:\n\n``` javascript\nasync.waterfall([\n  function first(next) {\n    if (someCondition()) next(null, 'value 1', 'value 2');\n    else next(null, 'value 1', null); // must pass in null as the last parameter\n  },\n  function second(param1, optionalParam, next) {\n    ...\n  }\n], cb);\n```\n\nIn our `else` condition, if we don't pass in `null`, then in the `second` function, `optionalParam` will be our callback function, and `next` will be undefined.\n\n---\n\nIn a similar vein, if we pass in too many parameters, we screw things up:\n\n``` javascript\nasync.waterfall([\n  function A(next) {\n    myMongooseDocument.save(next);\n  },\n  function B(savedDocument, next) {\n    // next will not be our callback function, because\n    // mongoose passes 3 arguments to the save callback.\n    // (err, savedDocument, countOfDocumentsSaved)\n  }\n], cb);\n```\n\nIt would be extremely handy if `waterfall` checked the next functions `length` property to see how many arguments it was expecting, and then made sure the last argument was always the `next` function.\n\nThis would mean both trimming arguments when necessary, as well as inserting `undefined` arguments when applicable.  With this change, the above two scenarios would now look like this:\n\n``` javascript\nasync.waterfall([\n  function first(next) {\n    next(null, 'value1');\n  },\n  function second(param1, optionalParam, next) {\n    // param1 === 'value1'\n    // optionaParam === undefined\n    // next === callback function\n  }\n], cb);\n```\n\n``` javascript\nasync.waterfall([\n  function A(next) {\n    myMongooseDocument.save(function(err, document, affectedCount) {\n      next(err, document, affectedCount);\n    });\n  },\n  function B(savedDocument, next) {\n    // savedDocument === document\n    // next === callback function\n    // even though affectedCount was passed in, it is ignored,\n    // and next is still our callback function.\n  }\n], cb);\n```\n\nI haven't thought through every possible scenario, but I don't believe this would be a breaking change.  Well, there is one scenario currently that would break with this change:\n\n```\nasync.waterfall([\n  function first(next) {\n    next(null, 'value1');\n  },\n  function second(param) {\n    // we don't care about next, which would be very strange.\n  }\n], cb);\n```\n\nAs it stands today, `param` would be `'value 1'`.  If you were to implement this change, `param` would be the `next` callback function.  But this seems like an extremely edge-case scenario.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/877/comments",
    "author": "boblauer",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-08-07T20:30:18Z",
        "body": "You can't rely on `Function.length` to know which arg the callback is.  It doesn't work with variadic functions or partially-applied functions (or any function created with a higher-order function).  This has been brought up before:  #519 #492 .\n\nAn easy way to get the callback is to do something like this in your waterfall functions:\n\n``` js\nasync.waterfall([\n  step1Func,\n  function (/*args... next*/) {\n     var next = _.last(arguments);\n     //...\n  }\n], done);\n```\n\n...but there's no reliable way for async to do this for you.\n"
      },
      {
        "user": "boblauer",
        "created_at": "2015-08-07T20:37:32Z",
        "body": "Thanks for the explanation, hadn't considered variadic and partially-applied functions.\n"
      }
    ]
  },
  {
    "number": 875,
    "title": "Is it possible to simplify this code with async ? ",
    "created_at": "2015-08-06T15:20:10Z",
    "closed_at": "2015-08-10T06:14:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/875",
    "body": "Hello, \n\nok this is a newby question, sorry for that ! :-). I am just wondering how to simplify this code with async - Thanks ! \n\n``` js\nif (this.options.skipDuplicates) {\n    store.getStore().isInCrawlHistory(options.uri, function(error, isInCrawlHistory) {\n            if (isInCrawlHistory) {\n              log(\"Don't crawl this url); \n            }\n            else {\n              store.getStore().addInHistory(options.uri,function(error) {\n                self.q.push(options);\n                log(\"Add in the request queue\", options.url);\n              });\n            }\n\n    });\n}\nelse {\n    log(\"Add in the request queue\", options.url);\n    this.q.push(options);\n}\n```\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/875/comments",
    "author": "christophebe",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-08-07T20:32:01Z",
        "body": "`async.memoize` might be something work exploring.  `addInHistory`  could easily be memoized from the looks of things.\n"
      },
      {
        "user": "christophebe",
        "created_at": "2015-08-10T06:14:24Z",
        "body": "ok thanks for the tip ! \n"
      }
    ]
  },
  {
    "number": 874,
    "title": "Request for \"soft start\" of parallel tasks ",
    "created_at": "2015-08-03T06:51:45Z",
    "closed_at": "2015-10-25T06:22:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/874",
    "body": "I have several cases where I run a bunch of tasks in parallel and all the tasks repeated call the same service on an interval. When I start the tasks all of the request are send at almost the same time  and they continue to be called more or less in sync with each other until complete. This results in a spikes in the traffic on the service. I would like to a way to automatically spread out the start of the parallel tasks. This would spread out the traffic generated by the parallel tasks resolving the spiky traffic problem I'm seeing. I can always solve this by implementing the soft start logic in the parallel tasks themselves, but it would be nice if async.parallel supported it directly. \n\nThanks for your consideration.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/874/comments",
    "author": "brosenquist",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-08-03T21:04:47Z",
        "body": "It sounds like `async.queue` might be a better fit for what you're trying to do.  You can specify the concurrency of the queue, and even create a simple buffer to stagger calls to `queue.push()`.\n\n`parallelLimit` also might be worth exploring, to see if it helps fix the behaviour you're seeing.\n"
      }
    ]
  },
  {
    "number": 817,
    "title": "One or more arguments from callback",
    "created_at": "2015-06-30T06:55:00Z",
    "closed_at": "2015-07-01T17:09:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/817",
    "body": "``` js\nfunction log(err, res) {\n  console.log(res);\n}\n\nasync.series([function (cb) { cb(null, 1, 2, 3) }], log);\n// [ [ 1, 2, 3 ] ]\n\nasync.series([function (cb) { cb(null, 1) }], log);\n// [ 1 ]\n\nasync.series([function (cb) { cb(null, [1]) }], log);\n// [ [ 1 ] ]\n```\n\nMaybe in all case return an array?\n\n``` js\nfunction log(err, res) {\n  console.log(res);\n}\n\nasync.series([function (cb) { cb(null, 1, 2, 3) }], log);\n// [ [ 1, 2, 3 ] ]\n\nasync.series([function (cb) { cb(null, 1) }], log);\n// [ [ 1 ] ]\n\nasync.series([function (cb) { cb(null, [1]) }], log);\n// [ [ [ 1 ] ] ]\n```\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/817/comments",
    "author": "kobezzza",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-06-30T17:02:57Z",
        "body": "I believe this was a deliberate decision -- to pre-flatten the results in the common case of a single callback value.\n"
      }
    ]
  },
  {
    "number": 811,
    "title": "async.auto tasks *will* complete, eventually, if they pass an error to their callback",
    "created_at": "2015-06-29T19:20:53Z",
    "closed_at": "2015-07-06T00:54:11Z",
    "labels": [
      "docs",
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/811",
    "body": "The docs for async.auto states that\n\n> If any of the functions pass an error to their callback, it will not complete (so any other functions depending on it will not run), and the main callback is immediately called with the error.\n\nHowever, that would only be true if the main callback throws an exception as a result of the error. If no exception is ever thrown, then the remainder of the task _will_ execute when the main callback returns. For example, this test case:\n\n``` javascript\nvar async = require(\"async\");\n\nvar tasks = {\n  taskA: function taskA(callback) {\n    var err = true;\n    if (err) {\n      console.log(\"taskA sending error\");\n      callback(new Error(\"taskA error\"));\n    } \n    console.log(\"taskA continuing after error\");\n    callback(null, \"taskA result\");\n  },\n  taskB: [\"taskA\", function taskB(callback, results) {\n    console.log(\"in taskB: %j\", results);\n    callback(null, \"taskB result\");\n  }]\n};\n\nasync.auto(tasks, function finalCallback(err, results) {\n  if (err) {\n    console.log(\"finalCallback err:\", err);\n    return;\n  } \n  console.log(\"finalCallback results: %j\", results);\n});\n```\n\ngenerates the following output:\n\n```\ntaskA sending error\nfinalCallback err: [Error: taskA error]\ntaskA continuing after error\nin taskB: {\"taskA\":\"taskA result\"}\n```\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/811/comments",
    "author": "mhobbs-8B",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-06-29T20:09:29Z",
        "body": "You need a `return` in the `if (err) {` block in taskA.  The error will stop `auto` from kicking off further tasks, but it won't stop a function from executing unless you return.\n"
      },
      {
        "user": "mhobbs-8B",
        "created_at": "2015-06-30T01:08:06Z",
        "body": "Sorry, I should have been more specific. The point of this issue is the wording of the documentation. It implies that by calling `callback(err)`, the task \"will not complete\".\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-06-30T01:51:49Z",
        "body": "You're right, the docs could be more clear.\n"
      }
    ]
  },
  {
    "number": 788,
    "title": "series/waterfall callback is added to stack of last fn's done() call",
    "created_at": "2015-06-13T19:23:05Z",
    "closed_at": "2015-06-16T04:57:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/788",
    "body": "Can't seem to find this problem in the docs/issues, it seems the last fn's call to done() sits beneath the callback function in the stack, meaning its able to try/catch any errors encountered in the callback. Simple example:\n\n```\nasync.series([function(done) {\n    try {\n        done();\n    } catch(e) {\n        console.log('caught error from callback')\n    }\n}], function(err, result) {\n    throw new Error('callback threw');\n});\n```\n\nIn my case, I'm using the \"wd\" library and my last fn in the series array is:\n\n```\nbrowser.init({browserName: 'chrome'}).then(done);\n```\n\nIn my callback, I'm calling mocha.run() which throws an error if the coffeescript modules cannot compile. With the async + wd/q stack, the error is being swallowed.\nIs there another way I can use the async lib to prevent this, and ensure that all thrown errors in the callback function always bubble up to the process? thanks!\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/788/comments",
    "author": "mattfysh",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-06-13T23:18:11Z",
        "body": "This is a tricky problem because `q` and other promise implementations wrap the `onResolved` handler in try/catch, which is a bad idea if you call a callback in the handler, for the exact problem you're running in to.\n\nOne thing to do would be to defer the actual `done()` call:\n\n``` js\nbrowser.init({browserName: 'chrome'}).then(function ()  {\n  setTimeout(done, 0);\n});\n```\n\nThat way, the `mocha.run()` call gets a new call stack and the error will bubble all the way up.\n"
      },
      {
        "user": "mattfysh",
        "created_at": "2015-06-13T23:20:54Z",
        "body": "Thanks :) I ended up adding the setTimeout to get around this issue, though I wonder if this should be baked into the async lib itself? so as to prevent async functions from being able to capture callback errors this way.\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-06-16T04:57:11Z",
        "body": "I'd rather not do that -- it adds an unnecessary deferral, and I've been trying to minimize those.  Also, `try`/`catch`ing your callback call is bad practice.  I'm always trying to weigh ease of use with disallowing bad practices, but this one comes with a performance hit....\n\nYou can easily define a decorator to apply the deferral workaround more broadly:\n\n``` js\nfunction newStack(fn) {\n  return function () {\n    setImmediate(fn);\n  };\n}\n\n//...\nbrowser.init({browserName: 'chrome'}).then(newStack(done));\n```\n"
      }
    ]
  },
  {
    "number": 787,
    "title": "how to do a simple for loop",
    "created_at": "2015-06-13T17:32:25Z",
    "closed_at": "2015-06-13T19:00:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/787",
    "body": "I've been trying to figure out how to do a simple for loop, say, from 1 to 10, and have a callback when the loop is done. For example:\n\n```\nfor(i=1; i<=10;i++) {\n    User.insert({ username: \"user\" + i }, callback)\n}\n\nrunWhenDoneInserting();\n```\n\nI figured that it could be done using the `async.each` method, but that would mean building an array with all the elements I wanna loop, and that seems both wasteful (what if I want to execute a loop 1M times?), and also the array building code is quite declarative...\n\n```\nvar i = [];\nfor(var j = 1; j<=10;j++) {\n   i.push(j);\n}\n\nasync.each(i,foo,callback);\n```\n\n Is there any way to accomplish the above without having to manually create the iteration array?\nThanks!\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/787/comments",
    "author": "perrin4869",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-06-13T19:00:57Z",
        "body": "`async.times` will do what you want.  Just make sure to call the passed callback for each iteration.\n"
      },
      {
        "user": "perrin4869",
        "created_at": "2015-06-13T19:03:01Z",
        "body": "Oh I see! Thanks! Should have read the docs a bit more carefully ^^;;\n"
      }
    ]
  },
  {
    "number": 784,
    "title": "final callback for async.each is never fired",
    "created_at": "2015-06-09T03:15:15Z",
    "closed_at": "2015-06-09T03:34:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/784",
    "body": "Hi,\n\nI am writing a program which read all the files in a folder and rename them and copy to another folder.\nMy code is like:\n\n``` js\nasync.waterfall([\n            function(next){\n                fs.readdir(tmpPath, function(err, files){\n                    next(err, files)\n                });\n            },\n            function(files, next){\n                async.each(files, \n                                function(file){\n                    fileRetrieverFS.renameFiles(tmpPath, file, region);\n                }, \n                function(err){\n                    console.log('done');\n                    next(err);\n                });\n            },\n            function(next){\n                console.log('read');\n                fs.readdir(tmpPath, function(err, files){\n                    next(err, files)\n                });\n            }],\n            function(err, results){\n                if (err) console.log(err);\n            }\n        );\n```\n\nThe console.log('done'); and next(err) is never called after all files are successfully renamed.\nHow can I trigger the final callback for this case?\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/784/comments",
    "author": "ken860622",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-06-09T03:34:33Z",
        "body": "You're not calling the callback passed to the iterator function of `async.each`.\n\n``` js\nasync.each(files, function(file){\n// needs to be\nasync.each(files, function(file, callback){\n```\n\nIf you don't need asynchronous iteration, just use something like `Array.forEach` or `Array.map`.\n"
      }
    ]
  },
  {
    "number": 773,
    "title": "bug async.series",
    "created_at": "2015-06-02T09:53:42Z",
    "closed_at": "2015-06-02T23:45:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/773",
    "body": "hello\n\nI stand Julien Mutzenhardt, async I use for my project and following resettlement my async nodes modules, function async.series no longer works.\n\nThe function launches the first function defined in tasks and then stops without starting the callback function and there is no error. With async.parallel function function works again?\n\nI effecuté a git revert to commit 1b258fb79db17ea94e2f6af2372b85f9fef37258 and functions series works again, the following commits the bug returns if it can help.\n\nSincerely,\n\nJulien Mutzenhardt\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/773/comments",
    "author": "flybaby",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-06-02T15:43:24Z",
        "body": "Do you have some example code that reproduces the bug?  `series` was made more strict in the last release.\n"
      },
      {
        "user": "flybaby",
        "created_at": "2015-06-02T16:27:57Z",
        "body": "YEs, here's the piece of code (be indulgent I started in nodejs lol)\n\n```\n async.series([\n            // load config JARVIS\n            function (callback) {\n                callback(load_config(), 'load config JARVIS : OK');\n            },\n            // load LIB JARVIS\n            function (callback) {\n                callback(load_lib(), 'load lib JARVIS : OK');\n            },\n            // initialization ERROR\n            function (callback) {\n                callback(JARVIS.lib.error.init(), 'initialization ERROR : OK');\n            }],\n        //callback\n        function (err, msg) {\n            if (err) {\n                throw new Error(err);\n            }\n            for (var id in msg) {\n                if (msg.hasOwnProperty(id)) {\n                    console.log(msg[id]);\n                }\n            }\n            console.log('Initialisation OK');\n            return null;\n        });\n```\n\nFYI, I code in \"use strict\" and I'm on Mac OS X and I installed the latest version of node (v0.12.4).\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-06-02T16:33:47Z",
        "body": "What do `load_config()`, `load_lib()` and `JAVRIS.lib.error.init()`  return?   If they return anything they will cause the series to end because it will be considered an error (the first param of a callback).\n"
      },
      {
        "user": "flybaby",
        "created_at": "2015-06-02T17:03:14Z",
        "body": "excuse me\n\nload_config (), load lib () and JARVIS.lib.error.init ()\nreturn null if no error otherwise an error message {string}\nBut in the bug, the callback function is never called someting be returning functions.\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-06-02T17:54:48Z",
        "body": "Which callback is never called?\n\nI also realize that your code doesn't really need `async.series`.  Nothing you are doing is actually asynchronous.   Before it was roughly equivalent to:\n\n```\nload_config();\nload_lib();\nJARVIS.lib.error.init();\nconsole.log('Initialisation OK');\n```\n\nOne of the changes made was automatic deferral of tasks passed to things like `series` and `eachSeries`.  If you were relying on that callback being called on the same tick, it will now break.\n"
      },
      {
        "user": "flybaby",
        "created_at": "2015-06-02T20:44:26Z",
        "body": "thank you for your reply, actually I know my code is not really asynchronous equivalent to:\n\nload_config ();\nload_lib ();\nJARVIS.lib.error.init ();\nconsole.log (Initialization OK ');\n\nWhat I want to do is that it stops the call of each function (load_config ()\nload_lib () JARVIS.lib.error.init ()) if one of the functions references an error\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-06-02T23:45:39Z",
        "body": "I that case I would just have your functions throw errors and do:\n\n```\ntry {\n  load_config();\n  load_lib();\n  JARVIS.lib.error.init();\n} catch (e) {\n  console.log(e.message);\n} finally {\n  console.log('Initialisation OK');\n}\n```\n\nNo need to over-complicate things with `async.series`.\n"
      }
    ]
  },
  {
    "number": 765,
    "title": "usage question: several async tasks run parallelly, and i want to stop if any one of these task complete, how to?",
    "created_at": "2015-05-21T10:19:12Z",
    "closed_at": "2015-05-21T17:25:14Z",
    "labels": [
      "question",
      "duplicate"
    ],
    "url": "https://github.com/caolan/async/issues/765",
    "body": "i want to use `async.parallel()`, but want to stop all tasks if any one of them completes. is there any way to do it?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/765/comments",
    "author": "tomwang1013",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-05-21T17:25:14Z",
        "body": "An often requested feature (#568 #591), we're probably going to add something like this.  For now, I think you can rig something up with `detect` --- `callback(true)` in the first callback.\n"
      }
    ]
  },
  {
    "number": 760,
    "title": "forEachOf from npm",
    "created_at": "2015-05-20T16:08:00Z",
    "closed_at": "2015-05-20T23:41:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/760",
    "body": "`forEachOf` is mentioned in the documentation but is not included in the code I am getting from `npm install async`.\n\nIt does not seem to be in the 0.9.2 zip release.\n\nEdit: looks like this is in 0.10, when will this be published to `npm`?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/760/comments",
    "author": "jordonias",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-05-20T18:21:48Z",
        "body": "Yep, it was merged yesterday, might do a 0.10.0 release today.\n"
      },
      {
        "user": "jmls",
        "created_at": "2015-05-20T18:33:39Z",
        "body": "please ;) I just spent some time trying to figure out why forEachOf wasn't working ;)\n"
      },
      {
        "user": "beaugunderson",
        "created_at": "2015-05-20T19:24:15Z",
        "body": "@aearly tangential, but if we release can we bump to 1.0 so we're semver-friendly too? :)\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-05-20T20:35:07Z",
        "body": "Hmnn, it might be time for 1.0!  There are some breaking PRs and features that make sense to add (#696, #118, using _once() on all callbacks, optional callbacks, all the queue stuff) that I wanted to save for 1.0, but I suppose those could go into a 2.0 release later.\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-05-20T23:41:07Z",
        "body": "1.0.0  published!\n"
      }
    ]
  },
  {
    "number": 757,
    "title": "iterator counter issue",
    "created_at": "2015-05-19T09:10:32Z",
    "closed_at": "2015-05-20T23:05:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/757",
    "body": "any idea how to solve the following issue?\n\nvar index = 1;\nvar parallel = [];\n\nfor(i=0; i < 3; i++){\n\n  parallel.push(function(callback){\n        console.log(index); -> here should give me 1, 2, 3, but it give me only 3 instead. Any idea?\n   }); \n\nindex++;\n}\n\nasync.parallel(parallel, callback);\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/757/comments",
    "author": "martingg88",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-05-19T16:22:05Z",
        "body": "It's a common closure scope problem caused by defining functions in loops.  The `index` variable is shared by all the parallel functions.\n\nYou'll have to capture it:\n\n```\nfor(i=0; i < 3; i++){\n  (function (index) \n    parallel.push(function(callback){\n      console.log(index);\n    });\n\n  }(i));\n}\n```\n\nor do something else:\n\n```\nvar parallel = _.range(3).map(function (index) {\n  return function (callback) {\n    console.log(index);\n  }\n});\n```\n"
      },
      {
        "user": "martingg88",
        "created_at": "2015-05-20T01:35:46Z",
        "body": "thanks.\n"
      }
    ]
  },
  {
    "number": 752,
    "title": "0.9.2 version vs 0.9.0 version ?",
    "created_at": "2015-05-11T15:04:28Z",
    "closed_at": "2015-05-19T19:25:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/752",
    "body": "Hello, the official version in your website is 0.9.0, but if we git clone , it has 0.9.2 version.\nAre you going to publish the 0.9.2 version soon? What are major differences between the two versions?\nI found that your packaged tests works well on 0.9.2 but there are some failures on 0.9.0.\n\nThanks in advance for your help.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/752/comments",
    "author": "smartmouse",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-05-19T19:25:32Z",
        "body": "0.9.2 was published today!\n"
      }
    ]
  },
  {
    "number": 706,
    "title": "Iterating tasks on a queue or referencing the queue from tasks",
    "created_at": "2015-01-26T18:58:57Z",
    "closed_at": "2015-05-19T19:20:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/706",
    "body": "Looking to support cancellation in tasks on a queue in a sensible way - I would like to access all the tasks currently running on a queue or have the tasks be able to reference the queue's state.\n\nIs there a built-in way to reference the queue from a task?\n\nConversely, is there a built-in way to access all running tasks on a queue?\n\nThanks for the awesome library!\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/706/comments",
    "author": "klivin",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-01-26T19:34:04Z",
        "body": "There are `q.pause()` and `q.kill()` to stop the queue from processing, but there is currently no way to cancel currently running tasks, unless you manage it yourself.  I can definitely see how it would be useful. \n\nHow would you cancel an async function?  Queue uses a single worker function with a queue of data.  If we provided a list of running _somethings_ what would that list contain?\n\nSomewhat related: #703\n"
      }
    ]
  },
  {
    "number": 698,
    "title": "check if last item in list?",
    "created_at": "2015-01-11T09:26:57Z",
    "closed_at": "2015-05-19T19:19:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/698",
    "body": "Is there a way with `async.each` to know inside the callback if you're processing the last item in the list or not?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/698/comments",
    "author": "ralyodio",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-01-12T00:50:53Z",
        "body": "Not unless you keep track of it yourself.\n"
      },
      {
        "user": "ralyodio",
        "created_at": "2015-01-12T01:22:29Z",
        "body": "ok\n"
      }
    ]
  },
  {
    "number": 683,
    "title": "async.eachLimit final callback called multiple times",
    "created_at": "2014-12-17T00:17:58Z",
    "closed_at": "2015-05-19T19:14:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/683",
    "body": "i'm trying to use async.eachLimit to download multiple files at the same time using a ftp connection. my problem is that the ultimate function is called multiple times.\n\n```\n //entry point\nme.client.list(remotePath+'/img',function(err,imagenes){\n        if (err){\n            console.log(err);\n            throw err;\n        }\n        for(var index in imagenes){\n            if (imagenes[index].type==='-'){\n                var tmpname = imagenes[index].name.replace(' ','_');\n            me.ColaDescargas.push({\n                remote:remotePath+'/img/'+tmpname,\n                local:localpath+'/img/'+tmpname\n            });\n        }}\n        //despues de tener las imagenes procesa la cola\n        async.eachLimit(me.ColaDescargas,ftpLimit,me.ProcesarColaDescargas.bind(me),function(err){\n            if (err){\n                console.log(err);\n            }\n            console.log(\"called just once\");\n        });\n        //me.ProcesarColaDescargas(localpath);\n    });\n\n ProcesarColaDescargas=function(sig,_callback){\n    console.log('Descargando....')\n    this.client.get(sig.remote,function(err,stream){\n        if (err){\n            console.log('error descargando: '+sig.remote);\n            if (sig.remote.toLowerCase().lastIndexOf('.json')===sig.remote.length-5){\n                //_callback(err);\n                }else{\n                    _callback();\n                }\n            console.log(err);\n            return;\n        }else{\n\n        stream.once('close',function(){\n            console.log(\"close:\"+sig.remote);\n            _callback(); //cuando acabe la descarga sigue con el siguente archivo\n        });\n        try{\n            var ws = fs.createWriteStream(sig.local);\n            stream.pipe(ws);\n\n        }catch (exc){\n            console.log('no se pudo crear el archivo:'+sig.local);\n            //call();\n        }\n        }\n    });\n\n  }\n```\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/683/comments",
    "author": "moscoquera",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2014-12-17T03:41:27Z",
        "body": "Your `ProcesarColaDescargas` function is probably calling `_calback` twice.  Wrapping streams in async functions is tricky.\n"
      }
    ]
  },
  {
    "number": 665,
    "title": "Async lib vs jQuery Deferreds/Promises",
    "created_at": "2014-11-21T12:01:08Z",
    "closed_at": "2015-05-19T19:03:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/665",
    "body": "I just need to make couple of api calls and when it is done I have to code some business logic over there.\nJust using jQuery Deferreds/Promises is enough or I have to go for async library?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/665/comments",
    "author": "dineshvgp",
    "comments": [
      {
        "user": "jhallriverainc",
        "created_at": "2014-11-21T14:51:46Z",
        "body": "You can handle them with plain ol' javascript if you want. jQuery Deferred/Promise may be helpful and the async library may be helpful as well, depending on how complex the pattern of calls you need to make is. It's up to you to decide what tool fits the use case.\n"
      },
      {
        "user": "dineshvgp",
        "created_at": "2014-11-24T09:38:05Z",
        "body": "Thanks @jhallriverainc!\n"
      }
    ]
  },
  {
    "number": 658,
    "title": "async.each nested in async.waterfall",
    "created_at": "2014-11-06T16:55:15Z",
    "closed_at": "2015-05-19T19:03:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/658",
    "body": "I have recently started using async api. Now my requirement is to perform a join on 3 collections namely fields, scripts and statements. fields can have multiple scripts, and scripts can have multiple statements.\n\nhere is what I have tried so far:(to join Fields collection with scripts)\n\n// Array to hold async tasks\nvar asyncTasks = [];\n\nasync.waterfall([\n    function(callback){\n        // fetches fields based on some Id and it returns 2 fields\n        db.fields.find({entity_id: mongojs.ObjectId(\"54440a448bbbcbb4070131ab\")}, function (err, fields) {\n            console.log(JSON.stringify(fields, null, 2));\n            callback(null, fields);\n        })\n    },\n    function(arg1, callback){\n        // arg1 now equals fields  \n        arg1.forEach(function(eachField){\n            asyncTasks.push(function(callback){\n                db.scripts.find({fieldId: eachField._id.valueOf()}, function(err, scripts) {\n                    // Async call is done then alert via callback\n                    console.log(JSON.stringify(scripts, null, 2));\n                    callback(null, scripts);\n                });\n            });\n        });\n\n```\n    // Now we have an array of functions doing async tasks\n    // Execute all async tasks in the asyncTasks array\n    async.parallel(asyncTasks, function(err, results) {\n        // All tasks are done now\n        console.log(\"Scripts\" + JSON.stringify(results, null, 2));\n        callback(null, \"done\");\n    });\n\n}\n```\n\n], function (err, result) {\n        console.log(result);\n});\n// for the above code here is what i get the output\n[\n  {\n    \"_id\": \"54440a548bbbcbb4070131ac\",\n    \"name\": \"t1\",\n    \"type\": \"String\",\n    \"entity_id\": \"54440a448bbbcbb4070131ab\"\n  },\n  {\n    \"_id\": \"54447f1d20c103981fa1a27c\",\n    \"name\": \"t2\",\n    \"type\": \"String\",\n    \"entity_id\": \"54440a448bbbcbb4070131ab\"\n  }\n]\nsize of array 2\n[]\n[]\nScripts[\n  [],\n  []\n]\ndone\nThe above output doesn't print any scripts even though there are 2 scripts in database. My database is is in MongoDB, and i am using NodeJs, MongoJS api. why is db.scripts.find() returning empty array? \n\nI tested this piece of code to see if scripts returning the o/p. Please find below my code\n\n test2();\n    function test2(){\n\n```\n    var getScriptFunction = function(eachField, doneCallback){\n        if(eachField !== undefined) {\n            var fieldId = eachField;\n            console.log(fieldId);\n            db.scripts.find({fieldId: fieldId}, function (err, result) {\n                // Async call is done, alert via callback\n                doneCallback(null, result);\n            });\n        }\n    }\n    // The array is the id of fields\n    async.map([\"54440a548bbbcbb4070131ac\", \"54447f1d20c103981fa1a27c\"], getScriptFunction, function (err, results) {\n        // Square has been called on each of the numbers\n        // so we're now done!\n        if (err){\n            console.log(\"error!\" + err);\n        } else {\n            console.log(\"printed from helper function \\n\" + JSON.stringify(results, null, 2));\n        }\n    });\n}\n```\n\nThis is the o/p of the above code to fetch scripts ran individually\n\nprinted from helper function\n[\n  [\n    {\n      \"_id\": \"54440a678bbbcbb4070131ad\",\n      \"name\": \"s1\",\n      \"fieldId\": \"54440a548bbbcbb4070131ac\"\n    },\n    {\n      \"_id\": \"544af260eb7a486824a5c306\",\n      \"name\": \"s2\",\n      \"fieldId\": \"54440a548bbbcbb4070131ac\"\n    }\n  ],\n  []\n]\nThis is how fields look like (db.fields.find().pretty())\n\n[\n  {\n    \"_id\": \"54440a548bbbcbb4070131ac\",\n    \"name\": \"t1\",\n    \"type\": \"String\",\n    \"entity_id\": \"54440a448bbbcbb4070131ab\"\n  },\n  {\n    \"_id\": \"54447f1d20c103981fa1a27c\",\n    \"name\": \"t2\",\n    \"type\": \"String\",\n    \"entity_id\": \"54440a448bbbcbb4070131ab\"\n  }\n]\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/658/comments",
    "author": "maddy2308",
    "comments": [
      {
        "user": "RyanCopley",
        "created_at": "2014-11-13T21:37:42Z",
        "body": "I believe I've done this and am willing to help if you properly format your post to make it legible. Please include code tags\n"
      }
    ]
  },
  {
    "number": 638,
    "title": "Functions, bigger objects to the queue",
    "created_at": "2014-10-01T12:30:02Z",
    "closed_at": "2015-05-19T18:38:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/638",
    "body": "Hello guys, I have a doubt:\nIs it possible send functions, bigger objects, driver objects (as mysql) to the queue?\n\nThanks in advance.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/638/comments",
    "author": "herlon214",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2014-10-01T22:30:31Z",
        "body": "Yep, async will dutifully pass whatever you enqueue to your task function.\n"
      }
    ]
  },
  {
    "number": 633,
    "title": "async.each vs. async.parallel performance",
    "created_at": "2014-09-24T14:02:41Z",
    "closed_at": "2015-05-19T18:36:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/633",
    "body": "It`s not issue (I`m really sorry), just a question\n\nI need to iterate over a collection, perform an asynchronous task for each item, and when they're all done do something else\n\nusing async module,\nasync.each and async.parallel function are support my requirement\n\nwhich is the best solution for performance?\n\nfor example)\n- using each\n  var result = [];\n  async.each(datas, function(data, callback){ result.push('res'); callback();}, function(err) {} );\n- using parallel\n  for(var i = 0; i < length; i++)\n  {\n  var data = datas[i];\n  callItems.push(makeCallbackFunc(data));\n  }\n  function makeCallbackFunc(data) {\n  return function (callback) {\n    // do something using 'data';\n    callback();\n  };\n  }\n  async.parallel(\n          callItems,\n              // optional callback\n              function(err, results){  \n              });\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/633/comments",
    "author": "rndmania",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2014-09-25T17:02:36Z",
        "body": "`each` -- it doesn't involve defining a function for each item in your data.\n"
      }
    ]
  },
  {
    "number": 614,
    "title": "Error: Callback was already called",
    "created_at": "2014-09-05T10:06:32Z",
    "closed_at": "2015-05-19T18:12:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/614",
    "body": "Hello, \n\ni have this code, thats sometime trigger `Error: Callback was already called`\n\n``` js\n        var queue   = async.queue(function (job, nextQueue) {\n            var ext = false;\n\n            request.get(job.unescapedUrl, {\n                headers: {\n                    'Referer': job.unescapedUrl\n                }\n            })\n                .on('error', function (err) {\n                    nextQueue(err);\n\n                    this.abort();\n                })\n\n                .once('data', function (data) {\n                    ext = imageType(data);\n\n                    this.abort();\n                })\n\n                .on('response', function (res) {\n                    res.on('end', function() {\n                        var fileSize    = res.headers['content-length'];\n\n                        if (allowedExt.indexOf(ext) !== -1 && parseInt(fileSize) <= parseInt(settings.maxSize)) {\n                            job.ext = ext;\n                            results.push(job);\n                        } else {\n                            socket.emit('grabber:error', {\n                                step: 'validate',\n                                url: job.unescapedUrl,\n                                message: {\n                                    ext: ext,\n                                    size: fileSize,\n                                    maxSize: settings.maxSize\n                                }\n                            });\n                        }\n\n                        return nextQueue();\n                    })\n                })\n        }, settings.worker.validateImages);\n```\n\nI dont know if this is related to request package or async package ..\nThanks for your help :)\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/614/comments",
    "author": "fer-ri",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2014-09-08T00:16:09Z",
        "body": "If your request has both an error and response event, your `nextQueue` will be called twice.\n"
      },
      {
        "user": "fer-ri",
        "created_at": "2014-09-08T04:43:29Z",
        "body": "@aearly but sometimes its not, even an error occured .. so do you have any idea to refine my code above?\n\nThanks\n"
      },
      {
        "user": "aearly",
        "created_at": "2014-09-09T22:29:25Z",
        "body": "Mixing event emitters with callbacks is always tricky.  I usually do something like `callback = _.once(callback)` at the top to prevent it being called twice.\n"
      },
      {
        "user": "fer-ri",
        "created_at": "2014-09-10T10:29:27Z",
        "body": "@aearly could you give some complete code?\n\nThanks\n"
      }
    ]
  },
  {
    "number": 612,
    "title": "How to: child functions execution must be delayed while idol function will complete",
    "created_at": "2014-09-04T10:54:16Z",
    "closed_at": "2015-05-19T18:10:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/612",
    "body": "There is a function(let it be \"main\") that processes for a while, and dynamic number of functions(\"task\") that must be executed only after the \"main\" function completed.\nThis \"tasks\" appear indefinite times during the whole process of \"main\" function, so there must be a way to push this \"tasks\" to some queue..\n\nLooks like async.waterfall is a nice tool for this ([main, task, task, task, ...]), but tasks cannot be pushed after waterfall run.\n\nIs there's an opportunity to use async.queue or smth to do this?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/612/comments",
    "author": "sleepw",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2014-09-04T16:17:18Z",
        "body": "Yep, queue will do it.  The other option is just building an array of functions to pass to series, or waterfall, etc..\n"
      },
      {
        "user": "sleepw",
        "created_at": "2014-09-04T17:58:18Z",
        "body": "Trying to guess:\n1. create queue\n2. pause the queue\n3. run an idol function\n4. push some tasks\n5. idol function fires complete\n6. resume the queue\n\nyep? or there's more accurate way?\n"
      }
    ]
  },
  {
    "number": 602,
    "title": "Whilst async truth test",
    "created_at": "2014-08-26T06:19:15Z",
    "closed_at": "2015-05-21T01:30:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/602",
    "body": "Why in `whilst` method (and brothers) truth test designed sycnchronously? For me its very often reason to write my own whilst, with async test. May be we can add it? If yes, i can implement it.\n\nSorry, if Im wrong.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/602/comments",
    "author": "gobwas",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2014-08-27T03:01:24Z",
        "body": "Yes, it's designed to be synchronous.  Maybe work the test into the iterator part?\n"
      },
      {
        "user": "gobwas",
        "created_at": "2014-08-27T06:57:55Z",
        "body": "Yes, it is possible, but not looks as clear design, isnt it? Its one unnecessary closure. ) Anyway it is interesting for me, which reasons was to design test this way? =)\n"
      }
    ]
  },
  {
    "number": 687,
    "title": "Control flow to try/error if result got?",
    "created_at": "2014-12-22T12:37:08Z",
    "closed_at": "2017-04-07T05:46:23Z",
    "labels": [
      "feature",
      "help wanted"
    ],
    "url": "https://github.com/caolan/async/issues/687",
    "body": "Hi ... I love async!! and use a lot of it, especially, I love compose. \nThank you for the great module!! However, I cannot find a control flow to try/error the callback, is there any control flow function can do the following thing?\n\nThat said, I have `fn1`, `fn2`, `fn3`, all of them will callback an error or result, if `fn1` get the result, then the control flow end, or continue to `fn2`, then `fn3`. For example, it might look like:\n\n```\nasync.try( [ \n  function(next){\n     do_first_try(param, function(err, res){\n         if (err) return next(err);\n         next(null, res); /// the control flow end, because we have result now\n     }\n  }, \n  function(next){\n    do_second_try(param, function(err, res){\n        if (err) return next(err);\n        next(null, res); /// the control flow end, because we have result now\n    }\n  }, \n  function(next){\n    do_third_try(param, function(err, res){\n        if (err) return next(err);\n        next(null, res); /// the control flow end, because we have result now\n    }\n  },], function( err, result) {\n       /// get the result whatever it comes from first try or third try, or err if no result\n})\n```\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/687/comments",
    "author": "benpptung",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-01-05T20:11:17Z",
        "body": "Interesting, it's kind of like `series`, except with the inverse of how it handles errors.  It definitely could come in handy.\n"
      },
      {
        "user": "benpptung",
        "created_at": "2015-01-06T03:15:20Z",
        "body": "yes :) in fact, I am using `series` doing this now, `done(res)` to stop the try/error and return the result  or `done(null)`to continue the next try, but it is looking like an anti-pattern to callback. \n"
      },
      {
        "user": "knoid",
        "created_at": "2015-03-27T17:54:51Z",
        "body": "+1\nI'll try using `series` for now. Thanks for the tip.\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-06-02T02:32:51Z",
        "body": "After further thought -- is this any different from `retry`?  This allows you to have a unique function for every try, but is that actually useful?  This is also similar to #568\n"
      },
      {
        "user": "benpptung",
        "created_at": "2015-06-02T04:24:29Z",
        "body": "I think `retry` is doing the `same task` to get a successful response from task no more than specific times before returning an error. . e.g. ping a server alive or not. I think it is different from the idea of `try/error`, in which, we can try different ways to get a successful result. e.g. the typical way to get `XMLHttpRequest` in front-end.\n"
      },
      {
        "user": "megawac",
        "created_at": "2016-10-31T05:12:03Z",
        "body": "Yeah 👍 I'd like this. \n"
      }
    ]
  }
]