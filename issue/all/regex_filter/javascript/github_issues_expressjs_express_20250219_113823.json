[
  {
    "number": 6304,
    "title": "Router.get method in Express is called with the wrong type: The request handler is mistaken for a child application",
    "created_at": "2025-01-30T12:42:21Z",
    "closed_at": "2025-01-30T16:02:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/6304",
    "body": "Note: I use the typescript \nWhen using the tokenRouter.get method in the auth/token.ts file to define a route handler, the TypeScript compiler throws a type mismatch error. The error message is as follows:\n\n## The console messages\n\nauth/token.ts:15:30 - error TS2769: No overload matches this call.\n  The last overload gave the following error.\n    Argument of type '(req: Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>, res: Response<any, Record<string, any>>) => Response<...> | undefined' is not assignable to parameter of type 'Application<Record<string, any>>'.\n      Type '(req: Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>, res: Response<any, Record<string, any>>) => Response<...> | undefined' is missing the following properties from type 'Application<Record<string, any>>': init, defaultConfiguration, engine, set, and 63 more.\n\n15 tokenRouter.get('/getToken', function(req: Request, res: Response) {\n                                ~~~~~~~~\n\n  node_modules/@types/express-serve-static-core/index.d.ts:168:5\n    168     (path: PathParams, subApplication: Application): T;\n            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    The last overload is declared here.\n\n\nFound 1 error in auth/token.ts:15\n\n## Code part\n```typescript\nimport express, { Request, Response, Router } from 'express';\n\nconst tokenRouter: Router = express.Router();\n\ntokenRouter.get('/getToken', function(req: Request, res: Response) {\n    // 这里是处理逻辑\n    const token = 'example_token';\n    return res.json({ token });\n});\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/6304/comments",
    "author": "hyfhaozero",
    "comments": [
      {
        "user": "bjohansebas",
        "created_at": "2025-01-30T16:02:25Z",
        "body": "Could you please provide the version of Express, TypeScript, and the version of the types you are using?"
      }
    ]
  },
  {
    "number": 6025,
    "title": "Raw Body Not Passed Correctly to Svix Webhook Verification",
    "created_at": "2024-10-05T17:56:43Z",
    "closed_at": "2024-10-09T21:47:11Z",
    "labels": [
      "help wanted",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/6025",
    "body": "\r\nHi Express team,\r\n\r\nI'm encountering an issue while trying to verify a webhook payload using Svix in my Express.js app. Despite following the recommended approach from both the Svix documentation and Express documentation, I continue to receive an error stating:\r\n\r\n```\r\nError verifying the webhook: Expected payload to be of type string or Buffer.\r\n\r\n```\r\n**Context**:\r\nNode.js version: v20.17.0\r\nExpress version: 4.21.0\r\nbody-parser: I'm using bodyParser.raw({ type: \"application/json\" }) to pass the raw payload as recommended by Svix.\r\nSvix version: 1.35.0\r\n\r\nCode Snippet:\r\n\r\n```\r\nimport express from \"express\";\r\nimport { Webhook } from \"svix\";\r\nimport bodyParser from \"body-parser\";\r\n\r\nconst router = express.Router();\r\n\r\nrouter.post(\r\n  \"/webhook\",\r\n  bodyParser.raw({ type: \"application/json\" }), // Using raw body-parser\r\n  async (req, res, next) => {\r\n    const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;\r\n\r\n    if (!WEBHOOK_SECRET) {\r\n      return next(new Error(\"WEBHOOK_SECRET is missing in the environment.\"));\r\n    }\r\n\r\n    const payload = req.body;\r\n    const headers = req.headers;\r\n\r\n    const wh = new Webhook(WEBHOOK_SECRET);\r\n\r\n    try {\r\n      const evt = wh.verify(payload, headers);\r\n      // Further webhook processing...\r\n      return res.status(200).json({ success: true });\r\n    } catch (err) {\r\n      console.error(\"Webhook verification failed:\", err.message);\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: \"Webhook verification failed.\",\r\n      });\r\n    }\r\n  }\r\n);\r\n\r\nexport default router;\r\n```\r\n\r\n**Problem**:\r\nAccording to the Svix documentation, the raw JSON payload must be passed directly to the Webhook.verify() method, without modification. However, Express appears to deserialize the JSON body into a JavaScript object, which causes the verification to fail because Svix expects a string or Buffer.\r\n\r\nOddly, the verification works when I manually wrap the payload in JSON.stringify():\r\n\r\n```\r\nconst evt = wh.verify(JSON.stringify(payload), headers);\r\n```\r\nHowever, this workaround is not ideal and could lead to other issues (as noted by Svix). I believe this issue arises from how Express handles the request body, even when using bodyParser.raw.\r\n\r\n**Expected Behavior:**\r\nExpress should provide the raw JSON payload to req.body when using bodyParser.raw({ type: \"application/json\" }).\r\n\r\n**Actual Behavior:**\r\nThe payload appears to be deserialized into a JavaScript object, causing the webhook verification to fail with the error: Expected payload to be of type string or Buffer.\r\n\r\nCould you provide insight on whether this is an issue with the body-parser, Express itself, or if there is a recommended approach to ensure the raw JSON body is passed to Svix?\r\n\r\nThank you!\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/6025/comments",
    "author": "MichaelvdVeer",
    "comments": [
      {
        "user": "dpopp07",
        "created_at": "2024-10-07T15:34:23Z",
        "body": "I'm unable to reproduce this. Using a bare app with your router, I receive the body as a `Buffer`, as expected.\r\n\r\nIs it possible that you have JSON-parsing middleware earlier in your application? If you have something like `app.use(express.json())` before your router is added the application, the body will already be parsed as JSON before it hits your router's middleware and it won't be parsed again (i.e. it will remain a JS object and won't be converted to a `Buffer`)."
      },
      {
        "user": "MichaelvdVeer",
        "created_at": "2024-10-07T15:59:30Z",
        "body": "Hi @dpopp07 Thank you for your feedback! You were absolutely right. Upon reviewing my code, I realized that I had app.use(express.json()) declared before the webhook route. This was causing the body to be parsed as JSON before it reached the middleware that expects a raw Buffer.\r\n\r\nI've now moved the app.use(express.json()) to be placed after the webhook route, and that resolved the issue. Thanks again for pointing me in the right direction!"
      },
      {
        "user": "dpopp07",
        "created_at": "2024-10-07T18:09:24Z",
        "body": "Awesome, no problem! Glad it's working now"
      },
      {
        "user": "dpopp07",
        "created_at": "2024-10-09T21:43:58Z",
        "body": "@UlisesGascon I think this can be closed"
      }
    ]
  },
  {
    "number": 5693,
    "title": "Why can't we pass the URL parameters to middleware in router.use()?",
    "created_at": "2024-06-03T02:28:16Z",
    "closed_at": "2024-06-03T14:45:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5693",
    "body": "If I have\r\n\r\n```\r\nroute1.use(test);\r\n\r\nroute1.post('/:table/insert', async (req, res, next) => {\r\n    // code\r\n}\r\n```\r\n\r\nwhere `test` is\r\n\r\n```\r\nfunction test(req, res, next) {\r\n    console.log(req.params);\r\n    next();\r\n}\r\n```\r\n\r\nI'll get an empty object as the output.\r\n\r\nWhereas, if I have\r\n\r\n```\r\nroute1.post('/:table/insert', test, async (req, res, next) => {\r\n    // code\r\n}\r\n```\r\n\r\nI'll get the object with the parameters, how it should.\r\n\r\nIs this intentional or am I missing something?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5693/comments",
    "author": "NicolasPL64",
    "comments": [
      {
        "user": "Roeck",
        "created_at": "2024-06-03T11:56:46Z",
        "body": "It's about the order of middleware execution.\r\nIn the first case, test middleware runs before the route handler, logging an empty object because parameters aren't parsed yet. \r\nIn the second situation, \"test\" is placed before the route handler, executing after parameter parsing, resulting in the expected output. \r\n"
      },
      {
        "user": "wesleytodd",
        "created_at": "2024-06-03T14:45:27Z",
        "body": "Yep @Roeck is correct. To phrase it just a bit differently, the router \"layer\" which is created for `.use` is processed first and since it does not have a url the router does no url processing. The layer which is created for handling the url with the parameters is when the processing will happen, and so that is when they will be available. "
      }
    ]
  },
  {
    "number": 5649,
    "title": "Attaching user-id header to axios interceptor in middleware (is it safe)",
    "created_at": "2024-05-08T17:07:20Z",
    "closed_at": "2024-05-09T21:11:10Z",
    "labels": [
      "help wanted",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5649",
    "body": "I have an express server which has to make requests to another service. That service requires a user-id to be sent in the headers.\r\n\r\nIdeally, I would like to set this header in an axios interceptor but I have my worries about doing this. The main concern being a lack of understanding on my part as to what will happen if two overlapping requests are made. It seems to me that two interceptors would be set globally and not associated with any particular request, leading to the user-ids potentially being confused. Would this be the case? If so, could someone suggest a better alternative. This piece of middleware is set in the main.ts file and runs on every request.\r\n\r\nWhere is a snippet of what I have written:\r\n\r\n```typescript\r\nimport { Request, Response, NextFunction } from 'express';\r\nimport axios from 'axios';\r\nimport { UnauthroizedError } from '../errors/HttpErrors';\r\n\r\nexport const attachUserHeaderMiddleware = async (\r\n  req: Request,\r\n  res: Response,\r\n  next: NextFunction\r\n) => {\r\n  const id = axios.interceptors.request.use(\r\n    (config) => {\r\n      if (!req.auth) {\r\n        throw new UnauthorizedError();\r\n      }\r\n\r\n      if (config.url?.startsWith(\"/server\")) {\r\n        config.headers['user-id'] = req.auth.user.id;\r\n      }\r\n\r\n      return config;\r\n    },\r\n    (error) => {\r\n      return Promise.reject(error);\r\n    }\r\n  );\r\n\r\n  res.on('finish', () => ejectInterceptor(id));\r\n  res.on('close', () => ejectInterceptor(id));\r\n\r\n  next();\r\n};\r\n\r\nconst ejectInterceptor = (id: number) => {\r\n  axios.interceptors.response.eject(id);\r\n};\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5649/comments",
    "author": "ProjectFlinn",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2024-05-09T21:11:10Z",
        "body": "If this service is a service you own and trust maybe, but in general this type of thing is likely to be a big security mess when you trust the header and someone figures out they can pretend to be other users. There is a reason folks use sessions and secure id's and things like JWTs. If you are rolling this yourself and unsure, then you are almost certainly going to make a mistake. If this is business critical I suggest working with an expert.\r\n\r\nThat said, despite maybe being capable of answering these questions the issue tracker here is not for technical support. Especially on app design and code for configuring `axios` which is not something this project owns (or personally I would even recommend). I know @UlisesGascon marked this as `help wanted` but even if we have triager's who want to help on this it is not a valid issue for the issue tracker. I would suggest reaching out on reddit or stack overflow or somewhere with folks volunteering time to help with questions like this."
      }
    ]
  },
  {
    "number": 5532,
    "title": "Import syntax error with express.Router() import",
    "created_at": "2024-03-13T04:40:44Z",
    "closed_at": "2024-03-13T15:23:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5532",
    "body": "### Need help figuring out why this would error.\r\nI am using bun and not node for the runtime. I don't think that affects anything here. I am using express JS 5.0 BETA 1\r\nI just feel there is a better way than actually doing (despite Node/Bun caching modules I still feel like this is redundant):\r\n```\r\nimport express from 'express';\r\nconst viewRouter = express.Router();\r\n```\r\n* The Code\r\n```\r\nimport { Router as viewRouter } from 'express';\r\nviewRouter.get('/', (req, res) => {\r\n    res.render('index.ejs');\r\n});\r\nmodule.exports = viewRouter;\r\n```\r\n* The Error\r\n```\r\nSyntaxError: Unexpected token '{'. import call expects one or two arguments.\r\n      at <parse> (/mnt/z/sic-web/src/server/routes/viewRouter.js:1:1)\r\n1 | import {Router as viewRouter} from 'express';\r\n    ^\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5532/comments",
    "author": "cainba",
    "comments": [
      {
        "user": "cainba",
        "created_at": "2024-03-13T05:07:47Z",
        "body": "One thing I made an oopsie here with is the `module.exports= viewRouter` line which is commonJS . \r\nChange it to default export viewRouter and I get the following error:\r\n```\r\nTypeError: argument handler must be a function\r\n      at /mnt/z/sic-web/src/node_modules/router/lib/route.js:211:15\r\n      at /mnt/z/sic-web/src/node_modules/express/lib/application.js:474:5\r\n      at /mnt/z/sic-web/src/sicapp.js:11:1\r\n206 | \r\n207 |     for (var i = 0; i < callbacks.length; i++) {\r\n208 |       var fn = callbacks[i]\r\n209 | \r\n210 |       if (typeof fn !== 'function') {\r\n211 |         throw new TypeError('argument handler must be a function')\r\n                    ^\r\nTypeError: argument handler must be a function\r\n      at /mnt/z/sic-web/src/node_modules/router/lib/route.js:211:15\r\n      at /mnt/z/sic-web/src/node_modules/express/lib/application.js:474:5\r\n      at /mnt/z/sic-web/src/sicapp.js:11:1\r\n^C\r\ncain@cain-pc:/mnt/z/sic-web/src$ bun run dev\r\n$ bun --hot sicapp.js\r\n206 | \r\n207 |     for (var i = 0; i < callbacks.length; i++) {\r\n208 |       var fn = callbacks[i]\r\n209 | \r\n210 |       if (typeof fn !== 'function') {\r\n211 |         throw new TypeError('argument handler must be a function')\r\n                    ^\r\nTypeError: argument handler must be a function\r\n      at /mnt/z/sic-web/src/node_modules/router/lib/route.js:211:15\r\n      at /mnt/z/sic-web/src/node_modules/express/lib/application.js:474:5\r\n      at /mnt/z/sic-web/src/sicapp.js:12:1\r\n206 | \r\n207 |     for (var i = 0; i < callbacks.length; i++) {\r\n208 |       var fn = callbacks[i]\r\n209 | \r\n210 |       if (typeof fn !== 'function') {\r\n211 |         throw new TypeError('argument handler must be a function')\r\n                    ^\r\nTypeError: argument handler must be a function\r\n      at /mnt/z/sic-web/src/node_modules/router/lib/route.js:211:15\r\n      at /mnt/z/sic-web/src/node_modules/express/lib/application.js:474:5\r\n      at /mnt/z/sic-web/src/sicapp.js:12:1\r\n```"
      },
      {
        "user": "wesleytodd",
        "created_at": "2024-03-13T15:23:32Z",
        "body": "I am nearly positive even if you get this issue worked out you will just hit other issues. Express couples deeply to Node.js api's which are likely different enough to matter. Just don't want to provide an answer on the errors without pointing out you are likely in for a world of pain 🤣. Additionally I don't think it has been discussed yet, but we likely do not have any plans to support Bun, so YMMV on this effort even in the longer term.\r\n\r\nThat said, it looks to me like something else is up with your code as I am not sure how the runtime difference could cause a typeof check to fail. And since that is the case, I am going to close this since we do not do technical support in here. If you can prove this is a bug of some sort in express please re-open this, but otherwise I would ask on Reddit or StackOverflow."
      },
      {
        "user": "joeyguerra",
        "created_at": "2024-03-13T16:45:27Z",
        "body": "I agree with Wes.\r\n\r\nI'll add this to give you some suggestion though.\r\n\r\n```javascript\r\nimport { Router as viewRouter } from 'express'\r\nviewRouter().get('/', (req, res) => {\r\n  res.render('index')\r\n})\r\nexport default viewRouter\r\n```\r\n\r\n`Router` is a function.\r\n\r\nI would suggest the following instead for `viewRouter.js`\r\n\r\n```javascript\r\nexport default app => {\r\n  app.get('/', (req, res) => {\r\n    res.render('index')\r\n  })\r\n}\r\n```\r\n\r\nand in `sicapp.js`, \r\n\r\n\r\n```javascript\r\nimport express from 'express'\r\nimport viewRouter from './routes/viewRouter.js'\r\n// other code\r\n...\r\n\r\nconst app = express()\r\n....\r\nviewRouter(app)\r\n\r\n```"
      },
      {
        "user": "cainba",
        "created_at": "2024-03-13T20:03:59Z",
        "body": "Thank you both, I appreciate the feedback :D\r\nWes, not a problem. I'm not sure there is any particular use in supporting bun anyways as they either have wrappers or have their own implementation of node libraries. I think what it was though is the file encoding got messed up and maybe lost it from there? My suspicion is a formatter in VsCode.\r\n\r\nJoey, this is an excellent alternative to what I was trying to do and even cleaner at that. I will have to take a gander at this when I'm in front of my editor again. Much appreciated."
      }
    ]
  },
  {
    "number": 5517,
    "title": "How to send a request at JSON format using http module to an ExpressJS server?",
    "created_at": "2024-03-03T09:04:43Z",
    "closed_at": "2024-03-03T17:44:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5517",
    "body": "Two web servers are in place: one is developed using the Express.js framework to manage requests and responses, while the other is built with the HTTP module to forward requests to the former. The current requirement is to send requests in JSON format, but there is uncertainty on how to achieve this using the HTTP module.\r\n\r\nThe first server by express js:\r\n\r\n```\r\nconst { Web3 } = require(\"web3\");\r\nconst {toChecksumAddress}=require(\"ethereum-checksum-address\");\r\nconst express=require(\"express\");\r\nconst bodyParser=require(\"body-parser\");\r\n\r\nconst walletMap=new Map();\r\n\r\nconst urlencodedParser=new bodyParser.urlencoded({extended:false});\r\nconst app=express();\r\napp.use(bodyParser.json());\r\n\r\n...\r\n\r\napp.get(\"/wallet-status\",function(req,res){\r\n  try{\r\n    const response=walletView(req.body.address);\r\n    res.status(200).json(response);\r\n  }catch(err){\r\n    const errorObj={\r\n      error:err.name,\r\n      message:err.message\r\n    }\r\n    res.status(400).json(errorObj);\r\n  }\r\n})\r\n\r\n...\r\n\r\nfunction walletView(address){\r\n    address=address.toString();\r\n    if(toChecksumAddress(address)){\r\n      if(walletMap.get(address)===undefined){\r\n        return {\"message\":\"The address provided has not been recorded previously\"}\r\n      }else{\r\n        return walletMap.get(address);\r\n      }\r\n    }\r\n}\r\n```\r\nThe second server by http module:\r\n\r\n```\r\nconst http=require(\"http\");\r\n\r\nlet options={\r\n    host:\"127.0.0.1\",\r\n    port:2020,\r\n    path:\"/wallet-status\",\r\n    method:\"GET\",\r\n    headers:{\r\n        \"Content-Type\":\"application/json\"\r\n    }\r\n}\r\n\r\nconst httpRequest=http.request(options,function(response){\r\n    console.info(response.statusCode);\r\n})\r\n\r\nhttpRequest.end();\r\n```\r\nWhat modifications are needed for the second app to send JSON requests, allowing the callback function of `app.get(\"/wallet-status\",...)` to receive them?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5517/comments",
    "author": "AlirezaEthDev",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2024-03-03T17:44:42Z",
        "body": "Hey @AlirezaEthDev, we do not to technical support here. Please use stackoverflow or reddit to ask general questions like this. This is for bugs, features, and otherwise improving the express project itself. Thanks."
      }
    ]
  },
  {
    "number": 5351,
    "title": "Uncertain Behavior: Routing Conflict",
    "created_at": "2023-12-09T15:09:53Z",
    "closed_at": "2023-12-09T15:55:41Z",
    "labels": [
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/5351",
    "body": "I'm encountering a potential issue with my Express.js project that involves routing ambiguity. \r\nIn my `index.js`, I've set up the middleware using \r\n\r\n- `app.use('/company', companyRoutes)`. \r\n\r\n\r\nWithin `company.js`, I have two routes configured: \r\n\r\n- `router.get(/:company_id`, ... ) (corresponding to `/company/:company_id`) \r\n\r\n- `router.get(/all`, ... )                 (corresponding to `/company/all`). \r\n\r\nWhen making an API call to `/company/all`, it unexpectedly redirects to `/:company_id`,  and is executing its logic. \r\n\r\nI've observed that the regex of `/:company_id` is `/^\\/(?:([^\\/]+?))\\/?$/i`, matching routes with no parameters. \r\nRearranging the routes, I have resolved this by simply placing `/:company_id` at the end. \r\n\r\nI'm not sure if this behavior is patched or requires a different approach.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5351/comments",
    "author": "Chall-T",
    "comments": [
      {
        "user": "MrLibya",
        "created_at": "2023-12-09T15:14:08Z",
        "body": "U need to have it in correct order.\r\n```\r\nrouter.get(/all)\r\nrouter.get(/:company_id)\r\n```\r\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2023-12-09T15:16:17Z",
        "body": "You can also add a restriction in the characters accepted to make up `:company_id` to remove the ambiguity. Express will always route in the order declared, whichever matches first."
      }
    ]
  },
  {
    "number": 5331,
    "title": "Cannot route to a specific route",
    "created_at": "2023-11-23T18:11:28Z",
    "closed_at": "2023-11-25T14:26:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5331",
    "body": "> This is the route that I want the express to route\r\n```\r\napp.use('/griev', require('./routes/api/grievance'));\r\n\r\napp.all('*', (req, res) => {\r\n    res.status(404);\r\n    if (req.accepts('html')) {\r\n        res.sendFile(path.join(__dirname, 'views', '404.html'));\r\n    } else if (req.accepts('json')) {\r\n        res.json({ \"error\": \"404 Not Found\" });\r\n    } else {\r\n        res.type('txt').send(\"404 Not Found\");\r\n    }\r\n});\r\n```\r\n> This is my grievance api route\r\n\r\n```\r\nconst express = require('express');\r\nconst router = express.Router();\r\nconst grievController = require('../../controllers/grievController');\r\nconst ROLES_LIST = require('../../config/roles_list');\r\nconst verifyRoles = require('../../middleware/verifyRoles');\r\n\r\nconsole.log(\"griev route\")\r\n\r\nif (verifyRoles(ROLES_LIST.User)) {\r\n    router.post(grievController.createIssue);\r\n}\r\nelse\r\n    console.log(\"could not verify\");\r\n\r\n\r\nmodule.exports = router;\r\n```\r\n**All I get is 404 error whenever I make a post request to ```/griev``` route** ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5331/comments",
    "author": "premsai-konduru",
    "comments": [
      {
        "user": "AverageY",
        "created_at": "2023-11-23T20:03:32Z",
        "body": "Does adding a route to the post fix it?\n\n```\nrouter.post('/' , controller);\n```"
      },
      {
        "user": "premsai-konduru",
        "created_at": "2023-11-24T14:32:28Z",
        "body": "@AverageY Yeah, It solved, thank you, I did not even notice that simple thing, may be I just copy pasted the code of another route which had something like router.route('/').post.get something, I am sorry for this question "
      }
    ]
  },
  {
    "number": 5291,
    "title": "Get Request 404 Error",
    "created_at": "2023-10-19T23:55:01Z",
    "closed_at": "2023-11-27T08:43:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5291",
    "body": "I am receiving a 404 Not Found error in the browser for a get request. I have gone over my code several times but I still can't see what the issue is.  \r\n\r\nThe get request for the root file is working fine. The get request for path /stock is giving me the 404.\r\n\r\nHere is my server.js file, and below that is the ticker-router.js file for path \"/stock\". \r\n\r\nAny help would be much appreciated.\r\n\r\n\r\n```js\r\nimport express from 'express';\r\nimport router from '../ticker-router.js';\r\nimport routerM from '../home-router.js';\r\nconst PORT = process.env.PORT || 3000;\r\nconst app = express();\r\n\r\napp.use(express.static(\"dist\"));\r\n\r\napp.use((req, res, next) => {\r\nres.header(\"Access-Control-Allow-Origin\", \"*\");\r\nnext();\r\n});\r\n\r\napp.use(express.json());\r\napp.use(\"/\", routerM);\r\napp.use(\"/stock\", router);\r\n\r\n\r\napp.listen(PORT, () => {\r\n    console.log(\"Proxy listening on port:\", PORT);\r\n});\r\n```\r\n\r\n\r\n```js\r\nimport express from \"express\";\r\nimport path from \"path\";\r\nconst router = express.Router();\r\n\r\nrouter.get(\"/stock\", (req, res, next) => {\r\n  return res.sendFile(path.join(\"C:/Desktop/Ticqer\", \"/dist/ticker.html\"));\r\n});\r\n\r\nexport default router\r\n```\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5291/comments",
    "author": "chiahao-codes",
    "comments": [
      {
        "user": "krzysdz",
        "created_at": "2023-10-20T06:40:51Z",
        "body": "The `ticker-router` defines a router-relative `/stock` route, but because the router itself is mounted under `/stock` the only defined path is `/stock/stock`.\n\nYou should either mount this router as `app.use(\"/\", router)` or change the path of request handler inside the router to `router.get(\"/\", (req, res, next) => { /* ... */ })`."
      },
      {
        "user": "Dhanesh539",
        "created_at": "2023-11-01T16:59:10Z",
        "body": "\r\nThe issue with your code is that you are using the sendFile() function to serve the ticker.html file, but you have not specified the root directory for the sendFile() function. By default, the sendFile() function will serve files from the current working directory.\r\n\r\nTo fix the issue, you need to specify the root directory for the sendFile() function. You can do this by passing the root directory as a parameter to the sendFile() function.\r\n"
      },
      {
        "user": "krzysdz",
        "created_at": "2023-11-01T17:34:54Z",
        "body": "> \n> The issue with your code is that you are using the sendFile() function to serve the ticker.html file, but you have not specified the root directory for the sendFile() function. By default, the sendFile() function will serve files from the current working directory.\n> \n> To fix the issue, you need to specify the root directory for the sendFile() function. You can do this by passing the root directory as a parameter to the sendFile() function.\n> \n\nYou may not have noticed that, but the path given to `res.sendFile()` is absolute and the `root` option is used only with relative paths.\\\nThe absolute path could still be wrong, but we don't know where @chiahao-codes has saved `ticker.html` and he may have a custom Windows desktop directory location."
      },
      {
        "user": "donoftime2018",
        "created_at": "2023-11-02T02:58:39Z",
        "body": "I think you shouldn't use the path /stock/stock which is how the routes have been setup. Change the app.use('/stock') to something else or change router.get('/stock') to something else."
      },
      {
        "user": "ashish11011",
        "created_at": "2023-11-27T07:19:20Z",
        "body": "In your ticker-router.js file : -\r\nMake the get request to .get(\"/\",....);\r\nBecause in the index.js you are already using \"/stock\"\r\n\r\nrouter.get(\"/\", (req, res, next) => {\r\n  return res.sendFile(path.join(\"C:/Desktop/Ticqer\", \"/dist/ticker.html\"));\r\n});"
      }
    ]
  },
  {
    "number": 5188,
    "title": "express request and response processing ",
    "created_at": "2023-05-07T09:14:52Z",
    "closed_at": "2024-08-23T08:54:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5188",
    "body": "I see that expressjs app has a `stack` of `Layer` object Arrays. Which is the function that is used to pass the \r\n\r\nI want to know:\r\n- When a request is sent from the `http` client which `function is invoked first` and how is the stack array functions with `middlewares` invoked and results passed stepwise? \r\n- Here is an example `app.get(path, [middleware(req, res, next), m2(req, res, next), m3(req, res, next), m4(req, res, next)], handler(req, res))` => which function invokes functions stepwise => `[middleware(req, res, next), m2(req, res, next), m3(req, res, next), m4(req, res, next), handler(req, res)]`\r\n- Where is the `request` and `response` objects created that is passed as `arguments`?\r\n- Where is the `response` object callback function for `send` => `onfinish`/ `onend` functions which I can use to get the `send`/ `sendfile's` response object into a `variable` for an `interceptor`?\r\n\r\nI am looking for the entry of the request and exit if the response (with the response result).\r\n \r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5188/comments",
    "author": "ganeshkbhat",
    "comments": [
      {
        "user": "Zimmad",
        "created_at": "2023-05-30T07:29:56Z",
        "body": "When a request is sent from the HTTP client to an Express.js application, the initial function that is invoked is the one that handles the incoming request. In Express.js, this is typically referred to as a \"route handler\" or simply a \"handler function\". The handler function is responsible for processing the request and generating a response.\r\n\r\nIn the example you provided, the handler function is the one specified as the last parameter in the app.get method. It is the final function in the stack and is invoked after all the middlewares have been executed.\r\n\r\nThe stack of functions with middlewares is invoked stepwise in the order they are defined in the array. Each middleware function is invoked in sequence, passing the req (request) and res (response) objects along with the next function to the next middleware in the stack. The next function is used to pass control to the next middleware function in the stack.\r\n\r\nThe request and response objects are created and passed automatically by Express.js as part of the HTTP request-response cycle. When a request is received, Express.js creates the request object (req) and the response object (res) and passes them to the corresponding handler or middleware functions. These objects contain useful properties and methods that allow you to access information about the request and send the response back to the client.\r\n\r\nRegarding the response object callback function for res.send, Express.js does not expose a specific callback function for send. Instead, the response is sent back to the client when you invoke res.send() or any other response-sending methods. If you need to perform additional operations or intercept the response before it is sent, you can create a custom middleware function that sits in the stack before the final handler function. This middleware can access the response object and modify its behavior as needed.\r\n\r\nIn summary, the entry point for the request is the handler function that handles the specific route, and the exit point for the response is the res.send or other response-sending methods. The request and response objects are automatically created by Express.js and are passed along the middleware stack and to the handler function. You can create custom middleware functions to intercept and modify the response before it is sent back to the client."
      },
      {
        "user": "ganeshkbhat",
        "created_at": "2023-07-08T14:12:55Z",
        "body": "tried this and failed with errors. if I make an object using the `express/request.js` and `express/response.js` and want to traverse the express app router path with their middlewares to get the expected results from a non listening app like from a http server which function do i use and what options do i have?"
      }
    ]
  },
  {
    "number": 5172,
    "title": "What to do if one has other packages that require mime@^2",
    "created_at": "2023-04-23T14:46:11Z",
    "closed_at": "2023-04-23T14:51:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5172",
    "body": "Express requires mime@1.6. I have other packages that require mime@^2. Due to mime changing `lookup()` to `getType()` in version 2, this gives me either an error in express when using mime@^2 or an error in my other dependencies when using mime^1.6.\r\n\r\nWhat can one do to fix this?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5172/comments",
    "author": "xonaman",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2023-04-23T14:51:26Z",
        "body": "Just using `npm install` will build a `node_modules` directory with as many versions of a module (like `mime`) as needed."
      },
      {
        "user": "dougwilson",
        "created_at": "2023-04-23T14:53:45Z",
        "body": "Express 5 no longer uses `mime` if that is an upgrade path for you. But those are the only options available: either let `npm` install multile versions of `mime` as neede (the default behavior) or upgrade to Express 5 beta while it is finished up for RC."
      }
    ]
  },
  {
    "number": 5067,
    "title": "Change `var` to `const` and `let`",
    "created_at": "2022-12-15T16:12:02Z",
    "closed_at": "2022-12-15T18:16:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5067",
    "body": "Is there any reason why we're still using `var` as opposed to `const` and `let`?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5067/comments",
    "author": "AlexChadwickP",
    "comments": [
      {
        "user": "krzysdz",
        "created_at": "2022-12-15T16:24:09Z",
        "body": "Compatibility with old Node.js versions. This may change with Express 5.x, which should drop support for older versions."
      }
    ]
  },
  {
    "number": 5060,
    "title": "`item[]` format is parsed differently in express v5 compared to v4",
    "created_at": "2022-12-09T19:05:34Z",
    "closed_at": "2022-12-09T19:12:11Z",
    "labels": [
      "5.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5060",
    "body": "In express v4, if request contained query parameters suffixed with `[]` such as `items[]`. It would automatically be parsed into an array. This is no longer the case with express v5. \r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5060/comments",
    "author": "searchableguy",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-12-09T19:12:11Z",
        "body": "Hi @searchableguy this is correct, as the default parser was changed. You can get the old behavior using `app.set('query parser', 'extended')`."
      },
      {
        "user": "searchableguy",
        "created_at": "2022-12-09T19:45:38Z",
        "body": "Thanks for the quick response @dougwilson 👍 \n"
      },
      {
        "user": "searchableguy",
        "created_at": "2022-12-09T20:10:39Z",
        "body": "Is there a place where I can also read more about the decision to move the parser from extended? \r\n\r\nIs it for security reasons? @dougwilson "
      },
      {
        "user": "dougwilson",
        "created_at": "2022-12-09T23:43:49Z",
        "body": "Hi @searchableguy there were many reasons, all spread out through issues in the issue tracker here. The decision was ultimately \"due to popular demand\". "
      }
    ]
  },
  {
    "number": 5039,
    "title": "[suggestion] Add a new method like response.sendValue() to support number values.",
    "created_at": "2022-11-08T19:29:38Z",
    "closed_at": "2022-11-08T20:19:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5039",
    "body": "### Issue\r\nIt's always painful to send a number as a response,\r\nI have to un-necessarily convert the value to String before sending a response if value is a number,\r\nhowever, if a use case exists when the same controller sends mixed types as response then there is an additional step involved to convert the value to String only if it's a number.\r\nEven explicitly chaining with `status()` like `res.status(200).send(aNumberValue)` doesn't help.\r\n### Proposal\r\nhow about Adding a new Method like response.sendValue() which can be a wrapper on top of response.send() which will send the value as it is without setting it as the status of the response?\r\nsomething like:\r\n```Javascript\r\nres.sendValue = function sendValue(value) {\r\n  if (typeof value === \"number\") {\r\n    value = String(value);\r\n  }\r\n  return this.send(value);\r\n};\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5039/comments",
    "author": "shubanker",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-11-08T19:38:35Z",
        "body": "Hi @shubanker is the number you are sending a JSON response? If so `res.json()` should work for numbers directly. I ask because `res.send(String(num))` sends a `text/html` response as a.... number? Not sure if that is very useful, though, as the HTML response should usually have more substance to it."
      },
      {
        "user": "dougwilson",
        "created_at": "2022-11-08T19:41:55Z",
        "body": "FWIW `res.send(number)` no longer does the sending of the status code in Express 5, as that functionality was deprecated in 4.x and removed in 5. Not sure if that achieves what you're asking, though."
      },
      {
        "user": "shubanker",
        "created_at": "2022-11-08T20:14:31Z",
        "body": "> FWIW `res.send(number)` no longer does the sending of the status code in Express 5, as that functionality was deprecated in 4.x and removed in 5. Not sure if that achieves what you're asking, though.\r\n\r\nwow wasn't aware of this (still in 4.x), thanks for the update."
      },
      {
        "user": "shubanker",
        "created_at": "2022-11-08T20:19:18Z",
        "body": "> Hi @shubanker is the number you are sending a JSON response? If so `res.json()` should work for numbers directly. I ask because `res.send(String(num))` sends a `text/html` response as a.... number? Not sure if that is very useful, though, as the HTML response should usually have more substance to it.\r\n\r\nThanks a ton, `res.json()` fulfills my purpose (seems I have been using inappropriate method all along 😆)."
      }
    ]
  },
  {
    "number": 4979,
    "title": "app.set(\"query parser\") must be run before other app methods, otherwise the setting is not saved",
    "created_at": "2022-08-24T15:55:06Z",
    "closed_at": "2022-08-24T16:36:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4979",
    "body": "I want to set a custom query parser using `app.set()`. This is my app:\r\n\r\n```ts\r\nconst app = express();\r\nconst router = express.Router();\r\napp.use(cookieParser());\r\napp.use(helmet());\r\napp.use(express.json());\r\napp.use(cors());\r\napp.options(\"*\", cors());\r\napp.use(\"/\", router);\r\n\r\napp.listen(3000);\r\n```\r\n\r\nI've tried putting `app.set(\"query parser\")` between each statement, but it only works when applied at the beginning:\r\n\r\n```ts\r\nconst app = express();\r\nconst router = express.Router();\r\napp.set(\"query parser\", function(str) {\r\n  ...\r\n}); // This works\r\n...\r\napp.listen(3000);\r\n```\r\n\r\n```ts\r\nconst app = express();\r\nconst router = express.Router();\r\napp.use(cookieParser());\r\napp.set(\"query parser\", function(str) {\r\n  ...\r\n}); // This (or between any other statement) does not work\r\n...\r\napp.listen(3000);\r\n```\r\n\r\nHowever, `app.get()` shows `Function[Anonymous]` regardless of where I set the settings.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4979/comments",
    "author": "anthonyma94",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-08-24T16:36:16Z",
        "body": "Yes, that is correct. It is a side effect of how the app gets initialized with settings. The behavior has been changed in the Express 5 releases and the order no longer matters."
      }
    ]
  },
  {
    "number": 4972,
    "title": "express.urlencoded() undefined extended",
    "created_at": "2022-08-18T00:48:09Z",
    "closed_at": "2022-08-24T01:49:54Z",
    "labels": [
      "question",
      "module:body-parser"
    ],
    "url": "https://github.com/expressjs/express/issues/4972",
    "body": "Hi there! I'm sorry if this isn't the place to ask, but I cannot think of how else to find this answer other than asking right on the repo. I've been googling and rereading the docs like crazy around urlencoded() and I see on the docs its \"default\" is set to true.\r\n\r\nI understand I'm supposed to pass in either true or false on extended, but why do I have to if there's already a default to true? I also understand that this may change anyways in Express 5, but for Express 4, it's really bothering me without an explanation. \r\n\r\n`app.use(express.urlencoded());` produces this error: `body-parser deprecated undefined extended: provide extended option`\r\n\r\nProviding the line and error for a visual example. \r\n\r\n**TL;DR** Why do I have to pass in  {extended: bool} instead of leaving it empty for the default of true? \r\n\r\nIf this doesn't belong in issues, feel free to delete/close it. Just hoping someone can answer my burning question on this. I teach Express to students and this has always been hard to dance around when I'm not sure why in the first place! \r\n\r\nTIA! ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4972/comments",
    "author": "NikkiHmltn",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-08-18T03:40:31Z",
        "body": "Hi @NikkiHmltn it's no problem to ask here; we get many questions in the issue tracker and just where ever.\r\n\r\nSo for your question, it comes down to a bit of history, really. Back a long time ago, Express.js started using the Qs module to parse the URL query string, and then also the urlencoded request body. But how exactly Qs worked was non-standard, and also it turned out just surprising to users. Users would end up writing applications that didn't expect urlencoded bodies to have rich values like objects and such, and it was causing applications to contain accidental security issues. This was reported to the Express.js project over the years, and though it's not a vulnerability in Express.js itself, the decision was made in conjunction with application security experts to change the default to a more \"normal\" version and then add this \"warning\" to the current Express.js such that users would explicitly state how they wanted it parsed, so they should more consciously make the decision to use the more rich \"extended\" parser and know they'll be expecting these rich values from user input and write their code to handle them appropriately.\r\n\r\nI hope that helps."
      },
      {
        "user": "NikkiHmltn",
        "created_at": "2022-08-24T01:49:54Z",
        "body": "That helps so much!! I deeply appreciate this answer and will pass it along! :pray: \r\n"
      }
    ]
  },
  {
    "number": 4937,
    "title": "Support for PHP scripts",
    "created_at": "2022-06-22T12:46:23Z",
    "closed_at": "2022-06-22T17:15:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4937",
    "body": "I currently use express to host my website, I use PHP and HTML, PHP shows as Text and doesn't run any scripts.\r\nPlease make php work with express.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4937/comments",
    "author": "The-Developer-Nate",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-06-22T17:15:01Z",
        "body": "Hello, and welcome to Express.js. I think there may be some confusion as to what Express.js is: it is not a general web server like Apache, NGINX, IIS, etc. It is a framework written in Node.js for Node.js development. As such, the only code it \"runs\" is Javascript, the langauge of Node.js. What you are seeing is you are using the feature of Express.js to send the contents of files to your web browser (the static middleware). In theory you or someone could probably write a middleware that would load in PHP files and call out to a PHP interperter to run it, capture the outpit, and send it as the response. I doubt that would be performat compared to a more appropriate server like Apache or NGINX, though."
      }
    ]
  },
  {
    "number": 4912,
    "title": "Is there any subtle difference between use() / * []",
    "created_at": "2022-05-19T12:07:15Z",
    "closed_at": "2022-05-20T13:42:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4912",
    "body": "``` js\r\n// 1\r\napp.use(fn)\r\n\r\n// 2\r\napp.use(`/`, fn)\r\n\r\n// 3\r\napp.use(`*`, fn)\r\n\r\n// 4\r\napp.use([], fn)\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4912/comments",
    "author": "wll8",
    "comments": [
      {
        "user": "SulaimanAminuBarkindo",
        "created_at": "2022-05-19T20:40:55Z",
        "body": "there is no difference because both will prevent the request to go beyond them."
      },
      {
        "user": "wll8",
        "created_at": "2022-05-20T01:07:46Z",
        "body": "I remember I found their nuances in some project, but I forgot. I will continue to keep an eye on this issue"
      },
      {
        "user": "dougwilson",
        "created_at": "2022-05-20T13:42:44Z",
        "body": "Hi @wll8 ! So the `app.use` function takes basically n-paths and then n-middlewares. When no paths are given, the default is `'/'`. This means that 1, 2, and 4 are all exactly the same in your example. But 3 uses the path `*`, which is a capture group, so though matches the same URLs, the entire URL is captured in `req.params[0]` and then the matched part (the entire URL) is trimmed off from `req.url`, leaving it as just `/`.\r\n\r\nI hope that helps!"
      }
    ]
  },
  {
    "number": 4879,
    "title": "The router restore function can incorrectly set variables to undefined",
    "created_at": "2022-04-03T14:26:13Z",
    "closed_at": "2022-04-03T16:13:04Z",
    "labels": [
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/4879",
    "body": "I found a case where `request.params` becomes undefined. Here is a concrete test case to reproduce the case:\r\n\r\n```javascript\r\n// test/app.router.js\r\n\r\nit('should have req.params in finish event after handler2 calls next', function(done){\r\n  var app = express();\r\n\r\n  function handler1(req, res, next) {\r\n    res.once('finish', function() {\r\n      setTimeout(function() {\r\n        assert(req.params.id);\r\n      })\r\n    })\r\n\r\n    next()\r\n  }\r\n\r\n  function handler2(req, res, next){\r\n    res.end(req.params.id);\r\n    next()\r\n  }\r\n\r\n  app.get('/user/:id', handler1, handler2);\r\n\r\n  request(app)\r\n  .get('/user/1')\r\n  .expect(200, '1', done);\r\n})\r\n```\r\n\r\nThe test runs fine if there is no `next` call in `handler2`. The `setTimeout` in `handler1` ensures that the test fails.\r\n\r\nAs I understand it, the last `next` will cause the function `done` to be called in the router:\r\n\r\n```javascript\r\n// lib/router/index.js\r\n\r\n// no more matching layers\r\nif (idx >= stack.length) {\r\n    setImmediate(done, layerError);\r\n    return;\r\n}\r\n```\r\n\r\nThe problem is that `done` is not working correctly in this case. If there are middlewares and no router the `done` function will replace `baseUrl`, `next`, and `params` with the value `undefined`.\r\n\r\n```javascript\r\n// lib/router/index.js\r\n\r\n// restore vals\r\nfor (var i = 0; i < props.length; i++) {\r\n    obj[props[i]] = vals[i];\r\n}\r\n```\r\n\r\nHence the `setTimeout` in the `handler1`. Without a timeout, the `handler1` function mostly finishes successfully before `done` is called in the next iteration of the event loop.\r\n\r\nMy proposal to fix the problem would be to check for `undefined`:\r\n\r\n```javascript\r\n// lib/router/index.js\r\n\r\n// restore vals\r\nfor (var i = 0; i < props.length; i++) {\r\n  if (vals[i] !== undefined) {\r\n    obj[props[i]] = vals[i];\r\n  }\r\n}\r\n```\r\n\r\nBefore creating a pull request I would like to hear if I missed some details or a better solution.\r\n\r\nI think better would if the `done` function would not try to restore anything if there is no router at all. But I could not figure out a good way to do that.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4879/comments",
    "author": "floftar",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-04-03T16:13:04Z",
        "body": "This is working as designed. When the code path exits the router, all the values are cleared."
      },
      {
        "user": "floftar",
        "created_at": "2022-04-06T16:49:37Z",
        "body": "Thanks for the explanation!\r\n\r\nI guess that function name `restore` confused me because I thought that the function should always try to restore the variables.\r\n\r\nWhy are only `baseUrl`, `next`, and `params` request properties cleared? For instance, `query` and `method` are still available in my test case."
      },
      {
        "user": "dougwilson",
        "created_at": "2022-04-06T16:53:25Z",
        "body": "Hi @floftar because inside the `handle` function, those are the only properties that are manipulated, so it is being responsible for restoring those properties back to the values they were when the `req` first entered into that `handle` function."
      },
      {
        "user": "floftar",
        "created_at": "2022-04-07T16:00:02Z",
        "body": "Thank you! 👍"
      }
    ]
  },
  {
    "number": 4850,
    "title": "Question about v5 supporting old Node versions",
    "created_at": "2022-03-06T23:56:20Z",
    "closed_at": "2022-03-06T23:59:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4850",
    "body": "Mostly/Probably a silly question regarding Node support, *but why keep maintaining old node versions?*\r\n\r\nAFAIK by dropping the old versions of Node and setting a somewhat newer version like v8 at least would not only take advantage of new features but also allow the framework to reduce a considerable amount of code.\r\n\r\nV5 will still require the same good old **Node.js 4+** from 2015 and that's the piece I don't process.\r\n\r\nAs the V5 would be a major release, wouldn't be a good idea to detach that old support in favor of a cleaner code that could potentially make Express faster?\r\n\r\nThat was something I've been thinking over the past days while testing the V5, I definitely know it's nice to give support for old versions, but I guess it should be a limit of how much should be sacrificed in favor of it.\r\n\r\nAnywho, I know for a fact this won't happen soon, but it might be something nice to have in mind on following discussions across the community.\r\n\r\n**Side note here:** My company mostly sticks on the LTS version, and we've upgraded the last services from Node v12 to v16 last year which gave us a nice performance increase overall. I'm wondering how fast Express would be by dropping support to old versions.\r\n\r\nCheers 👋 \r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4850/comments",
    "author": "rafaell-lycan",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-03-06T23:59:41Z",
        "body": "Hi! Yes, the v5 release has no reason to support old versions, as iterated in other issues :) If there are changes that would reduce code, make it faster, etc., please absolutely feel free to pull request such changes! The only requirement for Node.js support is to support at minimum LTS at the time of the actual v5 release. I hope that helps!"
      }
    ]
  },
  {
    "number": 4846,
    "title": "express still need “view engines”？",
    "created_at": "2022-03-02T09:19:50Z",
    "closed_at": "2022-03-25T04:10:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4846",
    "body": "Most people on my side use express just for api server。\r\n\r\nSo, why not remove “view engines” out as a middleware like a single npm package？",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4846/comments",
    "author": "ryouaki",
    "comments": [
      {
        "user": "michael-azogu",
        "created_at": "2022-03-12T21:16:24Z",
        "body": "breaking changes"
      },
      {
        "user": "dougwilson",
        "created_at": "2022-03-13T19:02:21Z",
        "body": "Hi @ryouaki , and thanks for opening this discussion. I don't believe anyone has asked for this before. I understand you use Express to make APIs that don't use view engines or res.render . I'm sure there are likely many other features of Express you may also not be using, though. Can you ellaborate on the benefits that removing this would bring to your use-case?"
      }
    ]
  },
  {
    "number": 4845,
    "title": "Question about typescript",
    "created_at": "2022-03-01T14:02:48Z",
    "closed_at": "2022-03-13T19:05:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4845",
    "body": "Is it safe to use @types/express? the last package has been update in 2021. There's another way to use express with ESM?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4845/comments",
    "author": "rafaelbellintani",
    "comments": [
      {
        "user": "benjamingr",
        "created_at": "2022-03-06T16:37:25Z",
        "body": "> Is it safe to use @types/express? \r\n\r\nSure, why not?\r\n\r\n> the last package has been update in 2021\r\n\r\nExpress has been stable API wise for ±7 years now? So should be safe up to new TypeScript features from 2022.\r\n\r\n> There's another way to use express with ESM?\r\n\r\nESM, types and express are all unrelated stack-wise. You can use Node.js with ESM (name your file `.mjs` or set `type: \"module\"` in your package.json. You can use express with or without ESModules though as far as I know express does not expose named imports. You only need @types/express to get type safety with express when using TypeScript.\r\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2022-03-13T19:05:09Z",
        "body": "I'll also note that the types can sometimes update more or less frequently than the base project for various reasons. For example many bug fixes don't actually change the type interface, so may not need to update the types for thay, or there may be a miss in the types, so they update even when the project hasn't.\r\n\r\nAs far as the types, though I don't use typescript personally, I'm not aware of any critical issue with them and last time I looked over them, they seem quite accurate. "
      }
    ]
  },
  {
    "number": 4839,
    "title": "Error when running Express App: \"Primordials not defined\"",
    "created_at": "2022-02-23T12:29:47Z",
    "closed_at": "2022-02-23T15:00:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4839",
    "body": "I am having this weird issue running my Express app after the project is built using Rollup.\n\n```\nError: Command failed: node /path/to/project/dist/index.js\nfs.js:45\n} = primordials;\n    ^\n\nReferenceError: primordials is not defined\n```\nI wasn't really sure where this was coming from. After reviewing the dependency tree, I noticed that there was an express-handlebars Packsge that dependent on graceful-fs, which depends on the primordials Packsge in question,\n\nHow would I fix this issue?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4839/comments",
    "author": "PatrickLumenus",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-02-23T15:00:47Z",
        "body": "Hi @PatrickLumenus sorry you are having trouble. Express itself does not have such an expression in the source code. I would suggest opening an issue with the package you found that did, though 👍 "
      },
      {
        "user": "dougwilson",
        "created_at": "2022-02-23T15:02:34Z",
        "body": "My off-hand guess is that it may be related to an outdated `graceful-fs` module used by said dependency, so I would check that first. I believe that `graceful-fs` used to try and re-evaluate the `fs.js` source code, which includes that statement, but was I believe fixed in an updated `graceful-fs` version."
      }
    ]
  },
  {
    "number": 4833,
    "title": "Middleware on app.use that will only get called on '/'?",
    "created_at": "2022-02-21T14:36:10Z",
    "closed_at": "2022-03-25T04:10:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4833",
    "body": "So I'm serving a web page on the root route '/', and this page had an authentication middleware. Using regular \r\n\r\n`app.use('/', authorizeFront, express.static('../client/dist'));`\r\n\r\nwould cause every route to be authenticated, which is what I'm trying to avoid. I've also tried using regex to match exactly '/' but it doesn't seem to be working.\r\n\r\n`app.use('/^/$/', authorizeFront, express.static('../client/dist'));`\r\n\r\nIs there any official way to do this? Thanks!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4833/comments",
    "author": "alexndr-n",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-02-21T15:58:10Z",
        "body": "Hi 👋 The `app.use` is a prefix-based route match, so given a path of `/` it will match all requests that start with it--everything. If you want an exact match for all methods, the `app.all` would be the appropriate choice 👍 "
      }
    ]
  },
  {
    "number": 4827,
    "title": "how Port multiplexing with node express？",
    "created_at": "2022-02-17T04:50:59Z",
    "closed_at": "2022-02-17T15:48:38Z",
    "labels": [
      "discuss",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4827",
    "body": "how Port multiplexing with node express？\r\n\r\nI want to use one port for web netcat and express  web app\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4827/comments",
    "author": "hktalent",
    "comments": [
      {
        "user": "BillGR17",
        "created_at": "2022-02-17T09:31:12Z",
        "body": "You should check nodejs docs i dont think this has anything to do with expressjs "
      }
    ]
  },
  {
    "number": 4825,
    "title": "[feature request] disable decode_param for path routing",
    "created_at": "2022-02-16T16:41:08Z",
    "closed_at": "2024-08-23T09:01:42Z",
    "labels": [
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/4825",
    "body": "I have some special urls thats get mapped to local files like image50%.png.\r\n\r\n```\r\napp.get('/open/:path(*)', (req, res) => {})\r\n```\r\n\r\nBut it doesn't work because express automaticly calls decode_param.\r\nIt throws `Failed to decode param`.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4825/comments",
    "author": "lublak",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-02-16T16:44:17Z",
        "body": "Hi @lublak sorry you are having trouble. There is no need to disable the decoding for this. Your client should be sending the URL as a valid encoding of `/open/image50%25.png` 👍 . If you really want to avoid decoding for your use-case if you need to accept improperly encoded URLs, you can use something like `app.use('/open', (req, res) => {})` and then `req.url` will just be the part after `/open`. I hope that helps!"
      },
      {
        "user": "dougwilson",
        "created_at": "2022-02-16T16:48:23Z",
        "body": "Apologies, I didn't mean to close the issue, as we could add some kind of app-level config to disabled/custom the param decoding."
      },
      {
        "user": "lublak",
        "created_at": "2022-02-16T17:21:58Z",
        "body": "@dougwilson The problem is that the client is Firefox and it sends this over quite validly (not with %25) the user of course enters image50%.png and not image50%25.png.\r\nI will try that with `app.use('/open', (req, res) => {})` tomorrow."
      },
      {
        "user": "dougwilson",
        "created_at": "2022-02-16T17:28:53Z",
        "body": "Hi @lublak by invalid, I am referring to what Express.js considers invalid. The reason you are getting the error is indeed because the URL is invalid according to Express.js, as it expects parameters to be URL-encoded and if the JavaScript function to decode URL-encoded strings, `decodeURIComplement` throws as invalid, then Express.js will bubble up that error. I did not make any statements regarding how Firefox works, of course, though my understanding is it will send whatever the user types in, regardless of what the web server is expecting. My guess, though, is that Firefox will still turn spaces into `%20`, so if you disable the param decoding, a URL like `/open/foo bar.jpg` will end up as `foo%20bar.jpg` on the server when you have decoding disabled, even if the user typed in a literal space, so turning it off probably has down sides."
      },
      {
        "user": "lublak",
        "created_at": "2022-02-16T18:03:32Z",
        "body": "@dougwilson That's right I didn't think about that of course blank characters are then given as %20 by the browser. The same is true for other characters like \"ä\".\r\nFor me it means that all \"invalid\" % characters must be replaced by %25 to decodeURIComplement .\r\n\r\n```js\r\napp.use('/open', (req, res) => {\r\n   const path = decodeURIComplement(makeItValid(req.url));\r\n})\r\n```\r\nI will try to implement it tomorrow. Thanks for the thought :)"
      },
      {
        "user": "dougwilson",
        "created_at": "2022-02-16T18:06:30Z",
        "body": "No problem. The current behavior of decoding params won't be changed, as there can be security implications of your proposal, but it would depend on the application if they are relevant or not. But the feature request, as I see it, would allow the user (like yourself) to implement any kind of decoding routine as they see fit, which would allow you to write any type of logic that works for your particular use case 👍 "
      },
      {
        "user": "lublak",
        "created_at": "2022-02-17T10:14:48Z",
        "body": "@dougwilson for me it works fine :) thanks for your tip.\r\nBut i decided only support some %. `urlPath.replace(/%([&$%.-_ #?=*/]|$)/g, '%25$1')`"
      }
    ]
  },
  {
    "number": 4808,
    "title": "EADDRINUSE code in express",
    "created_at": "2022-02-04T16:59:02Z",
    "closed_at": "2022-02-04T17:02:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4808",
    "body": "\r\n```js\r\n// using nodejs we can write code to retry to listen on port using\r\nconst server = http.createServer().listen(3000);\r\nserver.on('error',function(err) {\r\n    if (err.code === 'EADDRINUSE') {\r\n        console.log('Address in use, retrying...');\r\n        setTimeout(() => {\r\n            server.close();\r\n            server.listen(3000, 'localhost');\r\n        }, 1000);\r\n    }\r\n});\r\n```\r\nhow to do this same thing in express \r\n```js\r\nconst app = require('express')();\r\napp.on('err',function(err) {\r\nconsole.log('error occured'); // this doesnt work\r\n});\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4808/comments",
    "author": "tarunsinghh",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-02-04T17:02:22Z",
        "body": "It would be the same way you do with Node.js, as `app.listen()` returns the node.js server object. You can also provide `app` as the first argument to `http.createServer()`."
      },
      {
        "user": "tarunsinghh",
        "created_at": "2022-02-04T19:20:23Z",
        "body": "didn't understand this part -> You can also provide app as the first argument to http.createServer(). , code please"
      },
      {
        "user": "dougwilson",
        "created_at": "2022-02-04T19:21:58Z",
        "body": "`const server = http.createServer(app)`"
      },
      {
        "user": "tarunsinghh",
        "created_at": "2022-02-04T19:27:38Z",
        "body": "okay, this part\r\n```js\r\napp.listen = function listen() {\r\n  var server = http.createServer(this);\r\n  return server.listen.apply(server, arguments);\r\n};  \r\n```\r\nthis is request handler only and then whole code looks like\r\n```js\r\nconst app = require('express')();\r\nconst server  = http.createServer(app);\r\nserver.listen(3000);\r\nserver.on('error',function(err) {\r\n    if (err.code === 'EADDRINUSE') {\r\n        console.log('Address in use, retrying...');\r\n        setTimeout(() => {\r\n            server.close();\r\n            server.listen(3000, 'localhost');\r\n        }, 1000);\r\n    }\r\n});\r\n```\r\nThanks."
      }
    ]
  },
  {
    "number": 4746,
    "title": "UPDATING THE SOURCE CODE",
    "created_at": "2021-11-03T17:53:51Z",
    "closed_at": "2021-11-03T17:57:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4746",
    "body": "I was reading the source code of expressjs . I was thinking that we should update the source code to latest es6 version . Have any suggestions ??? I am also willing help in the process . I have not yet modified the code . Just reading it to know how it works . ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4746/comments",
    "author": "hasnath1",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-11-03T17:57:41Z",
        "body": "Hello, and thank you for the question. The place to start would be to put a proposal forward for what exactly you plan to change, how that affects the Node.js version support of Express and list how each change would benefit the consumers of the Express library. From there, a discussion would begin for the pros and cons of whatever the proposal is. I hope that helps."
      }
    ]
  },
  {
    "number": 4729,
    "title": "Express future?",
    "created_at": "2021-10-17T01:23:10Z",
    "closed_at": "2021-10-17T01:26:46Z",
    "labels": [
      "duplicate",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4729",
    "body": "what's wrong with the express framework, why is it rarely updated, has express been neglected?\r\nwhy Express version 5 is still an alpha version even though 5 years have passed, wouldn't that make no sense for an alpha version?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4729/comments",
    "author": "agsimfzi",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-10-17T01:26:46Z",
        "body": "You already posted this question, I answered, you replied there, and then opened a new issue again. It seems more likely you are here to troll and not contribute."
      },
      {
        "user": "dougwilson",
        "created_at": "2021-10-17T01:28:15Z",
        "body": "Duplicate of #4728 "
      }
    ]
  },
  {
    "number": 4713,
    "title": "Unable to find a way to properly remove or override a route after it has already been created",
    "created_at": "2021-10-02T19:46:56Z",
    "closed_at": "2021-10-02T20:07:36Z",
    "labels": [
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/4713",
    "body": "Basically I can't find a way properly remove a route after it has already been created. or redefine it to add a middleware if needed.\r\n\r\nThis is really causing a slight setback for a project I'm working on right now that needs to be able to create, remove or alter a route on demand.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4713/comments",
    "author": "VaasKahnGrim",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-10-02T20:07:36Z",
        "body": "Hi @VaasKahnGrim yes, in Express you can only add routes; there is no method to remove or change them. There have been PRs to add this functionality, but they never worked right so far. Currently, we recommend creating a router with the routes you may need to \"refresh\" at some point and then create a middleware that directs requests to the current version of the router you need.\r\n\r\nIf you would like help, you're welcome to post here in head on over to our Gitter or StackOverflow with specific details about what you are trying to accomplish and we can help show how to accomplish that in Express if the above generic explanation was not enough."
      },
      {
        "user": "Moisei-Shkil",
        "created_at": "2022-03-01T07:44:11Z",
        "body": "> Hi @VaasKahnGrim yes, in Express you can only add routes; there is no method to remove or change them. There have been PRs to add this functionality, but they never worked right so far. Currently, we recommend creating a router with the routes you may need to \"refresh\" at some point and then create a middleware that directs requests to the current version of the router you need.\r\n> \r\n> If you would like help, you're welcome to post here in head on over to our Gitter or StackOverflow with specific details about what you are trying to accomplish and we can help show how to accomplish that in Express if the above generic explanation was not enough.\r\n\r\nHi @dougwilson, what kind of issues did you guys have with removing routes?\r\nCan you give me please a reference to the PR that closed to add this functionality?\r\nThanks, Moisei 😄"
      },
      {
        "user": "dougwilson",
        "created_at": "2022-03-07T10:00:28Z",
        "body": "Hi @Moisei-Shkil I'm sorry I don't remember exactly. If you are looking to contribute a method to remove routes, you are welcome to do so if you believe it works correctly. We can review from there 👍 "
      }
    ]
  },
  {
    "number": 4706,
    "title": "How to define endpoints for prisma in electron app",
    "created_at": "2021-09-20T12:21:46Z",
    "closed_at": "2021-10-22T15:17:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4706",
    "body": "Hi, I made an app in nuxt.js + electron.js + electron-builder . then added prisma to nuxt and used express in serverMiddleware to handle my endpoints started api/ and send them to prisma CRUD . It works just fine in dev mode, but when building .exe file , there is no serverMiddleware to handle those endpoints.\r\n\r\nSo as I searched through articles , I found out you can added express to electron as you can add prisma in background.js , but didn't found any solution to integrate them so that my requests that starts with api go through prisma functions. e.g. $axios.get('api/users) get me all users :\r\n\r\nimport express from 'express'\r\nimport { PrismaClient } from '@prisma/client'\r\nconst prisma = new PrismaClient()\r\nconst app = express()\r\napp.use(express.json())\r\napp.get('api/users', async (req, res) => {\r\n   const result = await prisma.admin.findAll()\r\n   res.json(result)\r\n})",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4706/comments",
    "author": "M-Barari",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-10-22T15:17:42Z",
        "body": "Hello, is does not seem like anyone here has familiarity with those packages to answer your question. If possible, please rephrase your question to ask only about express is isolation and we can certainly answer it, otherwise a place lile StackOverflow may be more appropriate to ask questions regarding multiple packages at the same time."
      }
    ]
  },
  {
    "number": 4691,
    "title": "express5 expected release time？",
    "created_at": "2021-08-29T14:23:29Z",
    "closed_at": "2021-08-29T15:58:29Z",
    "labels": [
      "duplicate",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4691",
    "body": "Hi,\r\nexpress is a very powerful framework, as a newcomer I like it very much. I really want to use the latest version of express, although it hasn't been updated for a long time, can you tell me your general plan? When is expected to release the amazing express5\r\nThe translation comes from Google Translate, thank you for your understanding~",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4691/comments",
    "author": "machine2maxin",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-08-29T15:58:29Z",
        "body": "Hello, and thanks for your question. The last few items are currently being worked on. I am also triaging a couple security reports. I anticipate that some releaaes of 4.x and 5.x will be coming up soon. Due to the nature of this being a volunteer project, no specific dates are usually provided as it can be difficult to predict exactlt how long it takes for someone to wrap up a pull request, for example.\r\n\r\nDuplicate of #4383 #4413 "
      }
    ]
  },
  {
    "number": 4688,
    "title": "ReferenceError: app is not defined",
    "created_at": "2021-08-27T07:35:07Z",
    "closed_at": "2021-09-03T07:44:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4688",
    "body": "Help",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4688/comments",
    "author": "Rxntiongaming",
    "comments": [
      {
        "user": "rodion-arr",
        "created_at": "2021-08-27T08:33:40Z",
        "body": "Hi @Rxntiongaming, please send code examples so we can review and point to problematic place"
      },
      {
        "user": "piemree",
        "created_at": "2021-09-03T02:08:24Z",
        "body": "you should create express app instance I think. \r\nLike this:\r\n`const express= require(\"express\");\r\n const app=express() //this is the instance`"
      },
      {
        "user": "rodion-arr",
        "created_at": "2021-09-03T07:43:54Z",
        "body": "Closing as no details were provided from author"
      }
    ]
  },
  {
    "number": 4677,
    "title": "Regex as path not functioning as expected",
    "created_at": "2021-08-15T23:09:39Z",
    "closed_at": "2021-08-15T23:15:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4677",
    "body": "In my express app, I have the following code:\r\n```js\r\napp.all(/\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))\\/.*/g,(req,res,next){\r\n   // ...\r\n})\r\n```\r\nHalf the time, when going to /port/3001 it 404s, the other half of the time it works. It seems like the regex system used by Express is the cause as testing this using \r\n```js\r\n/\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))\\/.*/g.test('/port/3001')\r\n``` \r\nreturns true.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4677/comments",
    "author": "williamhorning",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-08-15T23:15:08Z",
        "body": "You should not have the global flag on your regexp, as that is how the global flag works. You can see this in plan JavaScript:\r\n```js\r\nvar re = /\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))/g\r\nconsole.log(re.test('/port/3001')) // => true\r\nconsole.log(re.test('/port/3001')) // => false\r\n\r\nvar re = /\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))/ // no global flag\r\nconsole.log(re.test('/port/3001')) // => true\r\nconsole.log(re.test('/port/3001')) // => true\r\n\r\n```\r\n\r\nIf you remove the global flag, then each test will always start from the start of the string, which is what you are expecting. If you didn't want that behavior, you would have the global flag on, but from your report, you are expecting the opposite behavior of the global flag. This is how regular expressions work in javascript, unrelated to Express. I hope that helps."
      },
      {
        "user": "williamhorning",
        "created_at": "2021-08-16T00:45:41Z",
        "body": "> You should not have the global flag on your regexp, as that is how the global flag works. You can see this in plan JavaScript:\r\n> \r\n> ```js\r\n> var re = /\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))/g\r\n> console.log(re.test('/port/3001')) // => true\r\n> console.log(re.test('/port/3001')) // => false\r\n> \r\n> var re = /\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))/ // no global flag\r\n> console.log(re.test('/port/3001')) // => true\r\n> console.log(re.test('/port/3001')) // => true\r\n> ```\r\n> \r\n> If you remove the global flag, then each test will always start from the start of the string, which is what you are expecting. If you didn't want that behavior, you would have the global flag on, but from your report, you are expecting the opposite behavior of the global flag. This is how regular expressions work in javascript, unrelated to Express. I hope that helps.\r\n\r\nah, thanks, i was wondering why this didn't work."
      }
    ]
  },
  {
    "number": 4655,
    "title": "data is not coming on server",
    "created_at": "2021-07-23T13:25:36Z",
    "closed_at": "2021-07-23T16:20:10Z",
    "labels": [
      "question",
      "module:body-parser"
    ],
    "url": "https://github.com/expressjs/express/issues/4655",
    "body": "i was trying node.js in typescript and code is same as JS but data is not coming on server\r\n\r\n\r\napp.ts file\r\n```\r\nimport express from 'express'\r\nimport bodyParser from 'body-parser'\r\nimport config from '../config/config'\r\nimport logging from '../config/logger'\r\nimport { connectDB } from './utils/DB'\r\n// init express variable to app ==========\r\nconst app = express()\r\n\r\n\r\nconst NAMESPACE = 'server'\r\n\r\n\r\n// body parser ===========================\r\napp.use(express.json())\r\napp.use(express.urlencoded({ extended: false }))\r\n\r\nconnectDB()\r\n\r\n// logger ===================================\r\napp.use((req, res, next) => {\r\n    logging.info(NAMESPACE, `METHOD - [${req.method}], URL - [${req.url}], IP - [${req.socket.remoteAddress}]`)\r\n    res.on('finish', () => {\r\n        logging.info(NAMESPACE, `METHOD - [${req.method}], URL - [${req.url}], IP - [${req.socket.remoteAddress}], STATUS - [${res.statusCode}]`)\r\n    })\r\n    next()\r\n})\r\n\r\n\r\n// routes ======================================\r\nimport loginRoutes from './routes/login'\r\n\r\napp.use('/api/login', loginRoutes)\r\n\r\n\r\n\r\n// error handling ===============================\r\napp.use((req, res, next) => {\r\n    const error = new Error('Page not found');\r\n    return res.json({ message: error.message, statusCode: 404 }).status(404);\r\n})\r\n\r\n\r\n// server start =================================\r\napp.listen(config.server.port, () => {\r\n    console.log(`Server started on port ${config.server.port}`);\r\n})\r\n```\r\n\r\n\r\nroute/login.ts file\r\n```\r\nimport express from 'express'\r\nimport login_contollers from '../controllers/login'\r\nconst loginAPI = express.Router()\r\n\r\nloginAPI.post('/user', login_contollers.login)\r\n\r\n\r\nexport default loginAPI\r\n```\r\n\r\ncontroller/login.ts file\r\n\r\n```\r\nimport jwt from \"jsonwebtoken\";\r\n\r\ndeclare var process: {\r\n    env: {\r\n        JWT_SECRET_KEY: string,\r\n        JWT_EXPIRE_TIME: number\r\n    }\r\n}\r\n\r\n\r\nconsole.log(process.env.JWT_EXPIRE_TIME)\r\n\r\n// creating jsonwebtoken\r\n\r\nconst getToken = async (id: String) => {\r\n    console.log('from getToken', id)\r\n    return jwt.sign({ id }, process.env.JWT_SECRET_KEY, {\r\n        // in what time token expire\r\n        expiresIn: process.env.JWT_EXPIRE_TIME\r\n    })\r\n}\r\n\r\n\r\n// interface req {\r\n//     body: string,\r\n// }\r\n\r\n\r\nconst login = async (req: any, res: any, next: any) => {\r\n    console.log(req.body)\r\n     if (!id) {\r\n         return res.json({message:'please add id'}).status(200)\r\n     } else {\r\n         const token = await getToken(id)\r\n         console.log(token)\r\n         return res.json({ message: 'hello', token })\r\n     }\r\n    next()\r\n}\r\n\r\nconst LOGIN_API = {\r\n    login\r\n}\r\n\r\nexport default LOGIN_API\r\n```\r\n\r\n**in terminal it showing blank array like this {}**\r\n\r\nbut it did't work so i try bodyParser but that is also not working....\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4655/comments",
    "author": "arunsingh28",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-07-23T15:05:23Z",
        "body": "Can you put `console.log(req.headers)` right above the output of req.body and paste the output of that here?"
      },
      {
        "user": "arunsingh28",
        "created_at": "2021-07-23T16:17:17Z",
        "body": "its showing the headers \r\n\r\n```\r\n[2021-07-23T16:15:59.835Z] [INFO] [server] METHOD - [POST], URL - [/api/login/user], IP - [::1]\r\n{\r\n  'content-type': 'text/plain',\r\n  'user-agent': 'PostmanRuntime/7.28.2',\r\n  accept: '*/*',\r\n  'postman-token': '744012c2-31fb-485b-9927-0e986da8d27e',\r\n  host: 'localhost:8080',\r\n  'accept-encoding': 'gzip, deflate, br',\r\n  connection: 'keep-alive',\r\n  'content-length': '28'\r\n}\r\n```"
      },
      {
        "user": "dougwilson",
        "created_at": "2021-07-23T16:20:10Z",
        "body": "So the issue is unrelated to your typescript usage. You used two different body prasers, neither of which parse `text/plain` bodies. For that, you want to use the text paraer (`express.text()`)."
      },
      {
        "user": "arunsingh28",
        "created_at": "2021-07-23T16:21:40Z",
        "body": "thanks a lot now it is working."
      }
    ]
  },
  {
    "number": 4652,
    "title": "How to access the variable passed through res.renderer?",
    "created_at": "2021-07-21T16:09:37Z",
    "closed_at": "2021-07-21T16:15:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4652",
    "body": "I'm passing a variable to my template renderer in ExpressJs like so:\r\n\r\nindex.js\r\n```\r\napp.get('/simple_view/', function(req, res, next){\r\n  title='A TITLE';\r\n  res.render('simple', {\r\n          title: title\r\n       });\r\n    });   \r\n``` \r\nI would like to access the `title` variable in a JS script on my template page, but I'm getting `Uncaught ReferenceError: title is not defined` error. \r\n\r\nsimple,pug\r\n```\r\nscript.\r\n   console.log(title);\r\n```\r\nHow can I solve this?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4652/comments",
    "author": "da-source",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-07-21T16:15:21Z",
        "body": "Hello, and sorry for the issue you are having. You will need to post this question either on our general help channel lile Gitter or StackOverflow, or you may ask for support from the templating engine you are using: pug."
      },
      {
        "user": "da-source",
        "created_at": "2021-07-21T17:09:22Z",
        "body": "@dougwilson I posted a question on StackOverflow but haven't received an answer. Does my problem even have a solution, from the look of it? Sorry to bother you"
      },
      {
        "user": "dougwilson",
        "created_at": "2021-07-21T17:10:33Z",
        "body": "I'm not familiar with pug, unfortunately. "
      },
      {
        "user": "aravindvnair99",
        "created_at": "2021-07-21T19:16:51Z",
        "body": "@da-source Your syntax is wrong for Pug. It should be:\r\n\r\n```pug\r\nscript\r\n\t| console.log(!{JSON.stringify(title)})\r\n```"
      }
    ]
  },
  {
    "number": 4650,
    "title": "Default error handler prints [object Object]",
    "created_at": "2021-07-21T07:31:46Z",
    "closed_at": "2021-07-21T07:35:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4650",
    "body": "In lib/application.js:\r\n\r\n```\r\nfunction logerror(err) {\r\n  /* istanbul ignore next */\r\n  if (this.get('env') !== 'test') console.error(err.stack || err.toString());\r\n}\r\n```\r\n`console.error(err.toString())` prints `[object Object]` instead of enumerating through the `err` properties. Is this the intention?\r\n\r\nShouldn't `console.error(err)` be more suitable?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4650/comments",
    "author": "RevealedFrom",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-07-21T07:34:27Z",
        "body": "It's possible there is an issue with your error object. Is the object you are getting not `instanceof Error`? If not, and you do not desire to use `Error` objects for errors, you will need yo provide your own error hander to print them as your use case calls for."
      }
    ]
  },
  {
    "number": 4649,
    "title": "Get child params from parent router",
    "created_at": "2021-07-20T13:32:29Z",
    "closed_at": "2021-07-20T13:56:43Z",
    "labels": [
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/4649",
    "body": "I want to get global params from a parent router like path with originalUrl.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4649/comments",
    "author": "Joooonny",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-07-20T13:56:43Z",
        "body": "You just need to pass in `mergeParams: true` when you construct your child router."
      },
      {
        "user": "Joooonny",
        "created_at": "2021-07-21T10:29:03Z",
        "body": "This solution work for parents parameters to child, I want to get child \r\nparameter from parent\r\n\r\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2021-07-21T14:52:15Z",
        "body": "Sorry if there was any confusion around what you are asking. Can you provide an example of whay uou are trying to accomplish to better understand?"
      },
      {
        "user": "Joooonny",
        "created_at": "2021-07-21T15:03:28Z",
        "body": "I have 2 routers\r\n\r\nrouter1.use('/', router2);\r\n\r\n\r\nrouter2.get('/:id')\r\n\r\n\r\nI want to get router2 params in router1 like:\r\n\r\nrouter1.get('/', (req, res) => {\r\n\tconsole.log(req.params.id)\r\n})\r\n\r\nthis log is undefined.\r\n\r\nWhy i can get total url (req.originalUrl) but not all the params?\r\n\r\n\r\nThanks.\r\n\r\n\r\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2021-07-21T15:27:13Z",
        "body": "This is because the params are an outcome of your route definition. In your example, your log output will always be undefined as it would match only for a GET method and only if the URL was exactly a single slash."
      },
      {
        "user": "Joooonny",
        "created_at": "2021-07-21T15:41:01Z",
        "body": "I understand this, so is there a way to get params from originalUrl instead\r\nfrom my route path?"
      },
      {
        "user": "dougwilson",
        "created_at": "2021-07-21T15:45:18Z",
        "body": "If the originalUrl is longer than the current URL (which I assume has to be the case, since your route is for GET /), then you want to set `mergeParams: true` on the sub router your GET / route is on to bring the params from the parent."
      },
      {
        "user": "KamaniAman",
        "created_at": "2023-12-03T22:51:42Z",
        "body": "I am also having the same requirement. @dougwilson , can you please provide an example, how can I get the child param in parent router?"
      }
    ]
  },
  {
    "number": 4648,
    "title": "How to change the HTML, when <select> element value changes?",
    "created_at": "2021-07-20T10:08:27Z",
    "closed_at": "2021-07-21T17:47:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4648",
    "body": "I have a select element with multiple values and I need to use Express inline interpolation to change the Pug template when the value of select element changes, for example:\r\n\r\n```\r\nselect \r\n   option Apple\r\n   option Orange\r\n\r\n//THIS PART DOESN'T WORK\r\nif select.value=='Apple'\r\n   h1 #{apple.price}\r\n\r\n```\r\n\r\n\r\nI'm passing 'apple' object to Pug template via Express `res.renderer` in the example. When the user picks an 'Apple' option I need to change the `h1` value to be `apple.price`, and in case of 'Orange' option, some other value.\r\nCan this be done with Express?\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4648/comments",
    "author": "imagine3D-ai",
    "comments": [
      {
        "user": "rodion-arr",
        "created_at": "2021-07-21T17:47:40Z",
        "body": "Hi, I assume in this case you need to submit a form with selected option (`Apple/Orange`) back to server, check what was selected, pick correct price, pass it to pug and rerender it with this separate variable.\r\n\r\nOtherwise it looks like a front-end task, where you can use `onchange` event to update `<h1>` content.\r\n\r\nClosing as it does not look like an issue with Express."
      }
    ]
  },
  {
    "number": 4646,
    "title": "Can I integrate cors library into express Framework? ",
    "created_at": "2021-07-16T11:47:39Z",
    "closed_at": "2021-07-16T13:32:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4646",
    "body": "**Hello everyone! I Hope you are going well!**\r\n\r\nMy question is there is the ability to integrate **cors** library into express.js Framework?\r\nJust like body-parser?\r\nIf not I'm gonna be glad and happy to know the reasons!\r\n\r\n**Thank you!**",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4646/comments",
    "author": "mouadTaoussi",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-07-16T13:32:44Z",
        "body": "Hello! This is a duplicate of a similar request, but I can't seem to find it right now. The consensus there was no. The reasoning is that the desire is to keep it to essential components only, and break things into individual middlewares.\r\n\r\nThe body-parser is included only because there is very little you can do if you cannot read the body of a request. But CORS is only necessary if you are trying to share your resources cross domain."
      },
      {
        "user": "mouadTaoussi",
        "created_at": "2021-07-16T21:01:02Z",
        "body": "That's cool ! Thank you! "
      }
    ]
  },
  {
    "number": 4633,
    "title": "WHEN CAN WE EXPECT EXPRESS 5",
    "created_at": "2021-07-04T18:43:08Z",
    "closed_at": "2021-07-04T18:53:02Z",
    "labels": [
      "duplicate",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4633",
    "body": "i think the title says it all!\r\n\r\nregards",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4633/comments",
    "author": "Darek79",
    "comments": [
      {
        "user": "romerodiesan",
        "created_at": "2021-07-04T18:50:41Z",
        "body": "I'd like to know too. Some time ago, I read to answer a question that Express 4 has a long way to go. That sounds to me that we are not going to see express 5 for a long time. While Node JS is trying to adopt new forms of EcmaScript, we are still using preprocessors for javascript."
      },
      {
        "user": "dougwilson",
        "created_at": "2021-07-04T18:53:02Z",
        "body": "Every time this question is asked, means folks like myself need to respond instead of workijg towards it. Please ask more construtive questions in the future like \"what can i do to help\" instead of asking when something will happen. If you want something to happen byt are unable to offer help, sometimes offering to sponsor someone to do the work is another method."
      }
    ]
  },
  {
    "number": 4626,
    "title": "Is express dead?",
    "created_at": "2021-07-02T09:52:33Z",
    "closed_at": "2021-07-02T10:00:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4626",
    "body": "As I see last updates were more that 2 years ago, so my question is, is express dead? If yes, what framework should I use instead of express",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4626/comments",
    "author": "bmadone",
    "comments": [
      {
        "user": "aravindvnair99",
        "created_at": "2021-07-02T10:00:46Z",
        "body": "> As I see last updates were more that 2 years ago, so my question is, is express dead? If yes, what framework should I use instead of express\r\n\r\n@bmarvinb no it's not dead. You are always welcome to contribute by sending in PRs to open issues. As for which you should use, you are free to use any framework you wish to use. Personally speaking, I use Express and so do many others. It's your decision."
      },
      {
        "user": "dougwilson",
        "created_at": "2021-07-02T12:38:07Z",
        "body": "To add, express made up of many, many repos. The latest commit on matser, yes, is from a while back, but I actually just pushed up a branch to this repo yesterday to test a new CI as it seems our old one now has a pricing structure, so I am getting us moved over."
      },
      {
        "user": "dougwilson",
        "created_at": "2021-07-02T12:39:53Z",
        "body": "As for the framework to use, though we may say yes, use express,  this is the express issue tracker :) In reality there are multiple http frameworks in node.js which all wprk differently in various ways. Use the one that fits your needs ans criteria best."
      }
    ]
  },
  {
    "number": 4576,
    "title": "What needs to happen for progress to be made? Sponsorship? Maintainers?",
    "created_at": "2021-04-26T22:49:29Z",
    "closed_at": "2021-04-26T23:03:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4576",
    "body": "I'm just wondering if we can figure out where the bottleneck is and what to do to move it out of the way a bit.\r\n\r\nCertainly being one of the most popular projects on the planet - nay, in the Universe - there must be enough potential to unlock to get the ball rolling again. 🤷",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4576/comments",
    "author": "coolaj86",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-04-26T23:03:12Z",
        "body": "You would need to be more specific about progress on which specific part. I think there has been a lot of confusion since there are so many repos and different PRs across various repos have work in various degrees.\r\n\r\nSponsorship can help, but again, progress on what thing in particular as money would need to then be allocated to someone who would be able to move that particular part.\r\n\r\nSuch a broad question like this my be better as a discussion than an issue, especially as many quality metrics these days track open issues, etc. and I can see something link this being a longer discussion, especially since the initial post is so broad.\r\n\r\nI cannot move this to the discussions, so perhaps if you would like to open a new one there, and ideally it would help to be more specific around what you are looking to further progress on 👍 "
      }
    ]
  },
  {
    "number": 4569,
    "title": "Answering before routes are registered",
    "created_at": "2021-04-19T17:43:54Z",
    "closed_at": "2021-04-19T17:59:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4569",
    "body": "**My environment:**\r\n-Node app with Express\r\n-Nginx with nginx-mod-passenger (Phusion Passenger open source)\r\n-Ubuntu 18.04 on an virtual private server\r\n\r\n**My problem is:**\r\nPhusion Passenger seems to have a sleep mode that pauses the Node.JS app after a bit time without requests. When I now make a request and the app is woken up, express immediatly returns 404. To access the routes I have set, I must make a second request as soon as the routes are loaded.\r\n\r\n**My proposal:**\r\nAs long as not all routes are loaded, express should wait instead of responding.  ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4569/comments",
    "author": "MatsG23",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-04-19T17:45:35Z",
        "body": "Hi @MatsG23 can you show an example? Express.js cannot answer requests until you call `app.listen`. Are you invoking that method too early in your code?"
      },
      {
        "user": "MatsG23",
        "created_at": "2021-04-19T17:49:49Z",
        "body": "Wow I admire the response speed!\r\n\r\nI'm still starting the server as I learned:\r\n- get app from the default function of the express package\r\n- set the routes and middlewares\r\n- export the app\r\n- import the app in the start file, create a HTTP server and pass app as the request listener\r\n\r\nIs the problem that I'm not calling app.listen but server.listen?\r\n\r\n```js\r\nimport { createServer } from \"http\";\r\nimport app from \"./src/app\";\r\n\r\nconst port: number = 5140;\r\napp.set(\"port\", port);\r\n\r\nconst server = createServer(app);\r\nserver.listen(port);\r\nserver.on(\"listening\", () => console.log(`Server listening on port ${port}`));\r\n```"
      },
      {
        "user": "dougwilson",
        "created_at": "2021-04-19T17:52:07Z",
        "body": "That is still fine, as that is essentially what `app.listen` does. So by the time you make your `server.listen` call there, have you finished registering your routes? If not, you probably want to add some kind of mechanism that is aware of when your code completes the route registration and then call `server.listen` at that point."
      },
      {
        "user": "MatsG23",
        "created_at": "2021-04-19T17:57:28Z",
        "body": "Oh in my router I'm postponing direct registration by wrapping the router.post/router.get/... in an async parenthesis. I think this is the error!"
      },
      {
        "user": "dougwilson",
        "created_at": "2021-04-19T17:59:18Z",
        "body": "No problem @MatsG23 ! Express.js does not know when you are finished adding routes, of course. The only way it would know is just whenever you call the `.listen` to start the server. If you start it before you finish, you'll get the behavior."
      }
    ]
  },
  {
    "number": 4550,
    "title": "Nested router overrides param sanitization",
    "created_at": "2021-03-19T16:43:24Z",
    "closed_at": "2021-03-19T17:33:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4550",
    "body": "I'm trying to have a nested router `use`d by a bigger one while also sanitizing a param (an ID) globally, so that it doesn't have to be done in each nested page.\r\nIt seems that `req.params` gets overridden at every nesting, so any sanitization prior to that gets discarded.\r\n\r\nRepro:\r\n```js\r\nimport express, {Router} from 'express';\r\nimport {param, query} from \"express-validator\";\r\n\r\n// Sanitization middlewares\r\nconst sanitizers = [\r\n    param(\"id\").isInt().toInt(),\r\n    query(\"test\").isInt().toInt()\r\n]\r\n// Handler for both example pages that outputs the types of the param and the query\r\nconst requestHandler = (req, res) => {\r\n    res.send({\r\n        paramType: typeof req.params.id,\r\n        queryType: typeof req.query.test\r\n    })\r\n}\r\n\r\nconst app = express()\r\n\r\n// By putting the sanitizers in the router use() middlewares the param sanitization gets discarded\r\nconst doesntWork = Router({mergeParams: true})\r\ndoesntWork.get(\"/\", requestHandler)\r\napp.use(\"/doesnt-work/:id\", sanitizers , doesntWork)\r\n\r\n// Putting the sanitizers directly in the pages middlewares works OK\r\nconst works = Router({mergeParams: true})\r\nworks.get(\"/\", sanitizers, requestHandler)\r\napp.use(\"/works/:id\", works)\r\n```\r\n\r\nIn this small example I've declared two routes `/works/:id` and `/doesnt-work/:id`. Both also accept an int query parameter `test` that isn't affected.\r\n\r\nResults:\r\n* `/works/1?test=2` outputs `{\"paramType\": \"number\", \"queryType\": \"number\"}`\r\n* `/doesnt-work/1?test=2` outputs `{\"paramType\": \"string\", \"queryType\": \"number\"}`\r\n\r\nI didn't find any documentation for this behavior, nor any bug report. I'm guessing that the culprit is the `mergeParams` options, but it obviously cannot be omitted, otherwise the `id` param won't be visible at all in the nested router.\r\n\r\n\r\nThanks in advance for the help!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4550/comments",
    "author": "MMauro94",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-03-19T16:51:19Z",
        "body": "Hi @MMauro94 ! I'm not sure what exactly is going on in your example to figure it out. For example, what `param` function is and `query` function, as they are used in your example, but they are not a part of Express or Node.js, so not sure what they do, or how to set up an app that reproduces the issue. Would it be possible to provide enough code where I could get it running to reproduce the issue?"
      },
      {
        "user": "MMauro94",
        "created_at": "2021-03-19T16:53:50Z",
        "body": "Ooops I fogot my imports 🤦‍♂️ `param` and `query` are from the `express-validator` library. \r\nI've edited my question."
      },
      {
        "user": "dougwilson",
        "created_at": "2021-03-19T17:33:12Z",
        "body": "Thanks @MMauro94 ! It looks like the way that module works is that it provides a set of middleware (like `param` and `query` functions in your example which are factories to create middleware). The middleware looks like it validates `req.params` object (for `param`) and, if you use a modifier (like `.toInit()` in your example), it simply updates the value in `req.params`. The issue is of course that `req.params` is derived from the last path match. So as soon as Express needs to perform another patch match, it would overwrite `req.params` with the values from the path match.\r\n\r\nThe issue is actually unrelated to your use of the router. You can see this with just the following reduced example:\r\n```js\r\nconst express = require('express')\r\nconst {param, query} = require('express-validator')\r\n\r\n// Sanitization middlewares\r\nconst sanitizers = [\r\n    param(\"id\").isInt().toInt(),\r\n    query(\"test\").isInt().toInt()\r\n]\r\n// Handler for both example pages that outputs the types of the param and the query\r\nconst requestHandler = (req, res) => {\r\n    res.send({\r\n        paramType: typeof req.params.id,\r\n        queryType: typeof req.query.test\r\n    })\r\n}\r\n\r\nconst app = express()\r\n\r\napp.use(\"/doesnt-work/:id\", sanitizers , requestHandler)\r\n\r\napp.listen(3000)\r\n```\r\n\r\nThe reason is that each middleware to `app.use` is separate from each other, resulting in a patch match before each one. This means that the alterations to `req.params` made in `sanitizers` is lost because `requestHandler` is a separate path match. I scanned though the docs on `express-validator` and didn't see any help around this to warn users, but of course I did noticed none of their examples (that I saw) showed using the validator in a `app.use` statement, which is what the issue you are having is caused by.\r\n\r\nI hope that helps!"
      },
      {
        "user": "MMauro94",
        "created_at": "2021-03-19T17:51:35Z",
        "body": "That's a shame :( \r\n\r\nThanks for the super detailed and fast reply anyway!"
      }
    ]
  },
  {
    "number": 4547,
    "title": "headerSent undefined",
    "created_at": "2021-03-15T23:39:49Z",
    "closed_at": "2021-03-15T23:45:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4547",
    "body": "whenever I try to start the bot it presents this error, but I never saw this error happen.\r\nI'm still starting in this part of the express\r\n\r\n> node src/index.js\r\n\r\nTypeError: Cannot read property 'headersSent' of undefined\r\n    at headersSent (D:\\Projetos\\Columbine Projects\\node_modules\\finalhandler\\index.js:256:21)\r\n    at D:\\Projetos\\Columbine Projects\\node_modules\\finalhandler\\index.js:92:17\r\n    at D:\\Projetos\\Columbine Projects\\node_modules\\express\\lib\\router\\index.js:635:15\r\n    at next (D:\\Projetos\\Columbine Projects\\node_modules\\express\\lib\\router\\index.js:210:14)\r\n    at Function.handle (D:\\Projetos\\Columbine Projects\\node_modules\\express\\lib\\router\\index.js:174:3)\r\n    at Function.handle (D:\\Projetos\\Columbine Projects\\node_modules\\express\\lib\\application.js:174:10)\r\n    at app (D:\\Projetos\\Columbine Projects\\node_modules\\express\\lib\\express.js:39:9)\r\n    at module.exports (D:\\Projetos\\Columbine Projects\\src\\http\\api\\index.js:15:50)\r\n    at Object.<anonymous> (D:\\Projetos\\Columbine Projects\\src\\index.js:56:24)",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4547/comments",
    "author": "b-hdev",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-03-15T23:41:06Z",
        "body": "Hi @HellpMe sorry you are having this issue. Can you provide the contents of `index.js` so we can reproduce the issue to help track down the cause?"
      },
      {
        "user": "b-hdev",
        "created_at": "2021-03-15T23:43:33Z",
        "body": "```js\r\nconst express = require('express');\r\nconst app = express();\r\nconst PORT = 3000;\r\n\r\nmodule.exports = (client) => {\r\n    //Pagina inicial\r\n    app.get('/', (req, res) => {\r\n        res.type('text/plain');\r\n        res.send(`[Servidor API] de ${client.user.username}\r\n        \\n/Estatísticas - Status básico do bot\r\n        \\n/Comandos - Lista de comandos e suas categorias`);\r\n    })\r\n    //Estatísticas do Bot!\r\n    .use('./statistics', require('./statistics'))(client)\r\n    //Lista de comandos\r\n    .use('.commands', require('./commands'))(client)\r\n    //Confirmando se os Web Scrapers não estão sendo usados\r\n    .use('/guilds', require('./guilds'))(client)\r\n    .get('/robots.txt', function(req, res) {\r\n            res.type('text/plain');\r\n            res.send('User-agent: *\\nallow: /\\n\\nUser-agent: *\\ndisallow: /dashboard');\r\n    })\r\n    .get('*', async function(req, res) {\r\n        res.send('Não há nada aqui Zzz');\r\n    })\r\n    //Iniciando o servidor\r\n    .listen(PORT, () => {\r\n        client.logger.ready(`Estatísticas da [API] carregado na porta ${PORT}`);\r\n    });\r\n}\r\n```"
      },
      {
        "user": "dougwilson",
        "created_at": "2021-03-15T23:45:44Z",
        "body": "Hi @HellpMe I believe the issue is that you have your parenthesis in the wrong order in a few places. For example, instead of `.use('./statistics', require('./statistics'))(client)` I believe you meant to write `.use('./statistics', require('./statistics')(client))`"
      }
    ]
  },
  {
    "number": 4537,
    "title": "Application goes offline all the time",
    "created_at": "2021-02-23T17:48:03Z",
    "closed_at": "2021-02-23T17:54:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4537",
    "body": "I'm hosting a Discord bot on replit using this module. It creates a webserver which gets pinged by uptimerobot so it doesn't go offline. However, it does go offline often, and for a long time. I'm hosting 2 other bots the same way, but they're written in python. Even the code that's used to make the webserver is the same in the python bots (keep_alive.py and keepalive() in main file) but they *never* go offline, or if they do, it's only once in 2 weeks for only a few minutes. So I guess the problem is with this express module? Can this be solved?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4537/comments",
    "author": "jvherck",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-02-23T17:54:37Z",
        "body": "Hi @jvhdiscord sorry you are having trouble. There is nothing in Express that stops the server, so unless there is something you may have written in your code to do this (no code is shared so we cannot check) it may be an issue with your hosting provider. You may want to raise the issue with the hosting provider first or even on Stackoverflow where folks with various knowledge points can help out.\r\n\r\nUnless you can distill down the specific issue with this module and provide a way to reproduce the issue, there isn't enough information to help you from this module's issue tracker, unfortunately."
      },
      {
        "user": "NotMoni",
        "created_at": "2021-02-23T22:08:25Z",
        "body": "@jvhdiscord Please reach out to repl.it and ask for assistance for this. Unless something is wrong on how you ping the server it should be all fine. "
      },
      {
        "user": "jvherck",
        "created_at": "2021-02-26T13:51:57Z",
        "body": "Sometimes there's a connection timeout. It just keeps on loading but the code is fixed now. everything works except the webserver, which causes the bot to go offline after a while."
      }
    ]
  },
  {
    "number": 4529,
    "title": "Router only response first route if using dependency injection on router",
    "created_at": "2021-02-18T07:23:22Z",
    "closed_at": "2021-02-18T07:36:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4529",
    "body": "This is related to #4528 \r\n\r\nFull codes are as per following:\r\n\r\n<details>\r\n<summary>/index.js</summary>\r\n\r\n```js\r\nconst express = require('express');\r\nconst app = express();\r\n\r\napp.use('/buy',require('./routes/buy'))\r\napp.use('/sell',require('./routes/sell'))\r\n\r\napp.listen(5000,()=>{\r\n  console.log('Server start')\r\n})\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>/routes/buy.js</summary>\r\n\r\n```js\r\nconst express = require('express')\r\nconst router = express.Router()\r\nconst buyController = require('../controller/buy.js')\r\n\r\nrouter.use('/:id/log', require('./log')(router, 'BuyModel'))\r\nrouter.route('/').get(buyController.fetchBuys)\r\n\r\nmodule.exports = router\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>/routes/sell.js</summary>\r\n\r\n```js\r\nconst express = require('express')\r\nconst router = express.Router()\r\n\r\nrouter.use('/:id/log', require('./log')(router, 'SaleModel'))\r\n\r\nmodule.exports = router\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>/routes/log.js</summary>\r\n\r\n```js\r\nconst logController = require('../controller/log')\r\n\r\nmodule.exports = function(router, model){\r\n  router.route('/')\r\n    .get(logController.fetchLogs(model))\r\n  return router\r\n}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>/controller/log.js</summary>\r\n\r\n```js\r\nexports.fetchLogs = model => (req, res, next) => {\r\n  console.log('fetch logs');\r\n  console.log('base_url:', req.baseUrl);\r\n  console.log('...');\r\n\r\n  return res.status(200).send('done')\r\n}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>/controller/buy.js</summary>\r\n\r\n```js\r\nexports.fetchBuys = (req, res, next) => {\r\n  console.log('base_url:', req.baseUrl);\r\n  console.log('result: fetch buys');\r\n  console.log('...')\r\n  res.status(200).send()\r\n}\r\n\r\n```\r\n</details>\r\n\r\n---\r\n\r\nCurrent code consoles:\r\n\r\n**GET: /buy**\r\nfetch logs\r\nbase_url: /buy\r\n\r\n**GET: /buy/123/log**\r\nfetch logs\r\nbase_url: /buy/123/log\r\n\r\n---\r\n\r\nWhat I hope is:\r\n\r\n**GET: /buy**\r\nfetch buys\r\nbase_url: /buy\r\n\r\n**GET: /buy/123/log**\r\nfetch logs\r\nbase_url: /buy/123/log\r\n\r\n---\r\n\r\nIf I reverse the route sequence in /routes/buy.js like following\r\n\r\n```js\r\nrouter.route('/').get(buyController.fetchBuys)\r\nrouter.use('/:id/log', require('./log')(router, 'BuyModel'))\r\n```\r\n\r\n**GET: /buy**\r\nfetch buys\r\nbase_url: /buy\r\n\r\n**GET: /buy/123/log**\r\nfetch buys\r\nbase_url: /buy/123/log\r\n\r\n---\r\n\r\nWould like to know how can I make it work if I still want to use dependency injection in router",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4529/comments",
    "author": "orzinc",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-02-18T07:36:57Z",
        "body": "The issue is that in your `/routes/log.js` file, it has a function that accepts a `router` and attaches the fetchLogs to the GET / route on that router. Of course, you are passing the router that belongs to the buys route in `/routes/buy.js`, so the GET / ends up pointing there. The reason it changes when you arrange lines is because you changed which of the two GET / you have on the same router.\r\n\r\nThere are two ways to fix this:\r\n\r\n1. Change line 5 in `/routes/buy.js` to `router.use('/:id/log', require('./log')(express.Router(), 'BuyModel'))`\r\n2. Change line 5 in `/routes/buy.js` to `router.use(require('./log')(router, 'BuyModel'))` and then change line 4 in `/routes/log.js` to `router.route('/:id/log')` (and of course change line 4 in `/routes/sell.js` to the `app.use` as well.\r\n\r\nI hope this helps!"
      },
      {
        "user": "orzinc",
        "created_at": "2021-02-18T08:06:48Z",
        "body": "@dougwilson Thank you for your help, and it works great 👍"
      }
    ]
  },
  {
    "number": 4525,
    "title": "Expressjs dealing with high traffic",
    "created_at": "2021-02-08T13:12:00Z",
    "closed_at": "2021-02-09T22:56:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4525",
    "body": "So I want to know how do I wait for response to be sent to the user ?\r\n\r\nlets say my code has some sort of external requests that takes few seconds to response so using async functions the code waits for the response of that request then process it and sends the result back to the user, but it works only for 1 user meaning that if i request like 100 requests per time I will be getting a response but with conflicts of the entered data\r\nlike the request number 62 had the response of the request number 33 and so.\r\nhow do I mange this ? are there any libraries or methods to overcome it or it's just some sort of errors in my code ? ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4525/comments",
    "author": "moezemara",
    "comments": [
      {
        "user": "rodion-arr",
        "created_at": "2021-02-08T20:49:56Z",
        "body": "Hi @moezemara! Requests are saving theirs contexts during async operations, so you shouldn’t face such kind of issues. If you’ll be able to provide some reproducible example - it will be interesting to check "
      },
      {
        "user": "moezemara",
        "created_at": "2021-02-09T07:35:51Z",
        "body": "> Hi @moezemara! Requests are saving theirs contexts during async operations, so you shouldn’t face such kind of issues. If you’ll be able to provide some reproducible example - it will be interesting to check\r\n\r\nthis is the request of the outer website\r\n```js\r\nconst fetch = require(\"node-fetch\");\r\nconst config = require(\"../../../config/configs\")\r\n\r\nasync function getquestion(questionid){\r\n\tvar url =  config.url\r\n  const options = {\r\n    headers: {\r\n    'Authorization': config.Authorization,\r\n    'Accept': config.Accept,\r\n    }\r\n  };\r\n\r\n\ttry {\r\n    const response = await fetch(url, options);\r\n      json = await response.json();\r\n      return await json\r\n  }catch(error){\r\n      console.log(error);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n\tgetquestion\r\n}\r\n```\r\n```js\r\nasync function asyncer(id){\r\n    question = await getquestion(id);\r\n    question = await question.result.content.content\r\n    return [question, answer]\r\n}\r\n```\r\nThen the user gets response using this\r\n```js\r\nqa = await asyncer(id)\r\nif (qa){\r\n return await res.status(200).json({\r\n      success: 1,\r\n      question: qa[0],\r\n      answer: qa[1]\r\n })\r\n}\r\n```\r\n"
      },
      {
        "user": "rodion-arr",
        "created_at": "2021-02-09T16:25:25Z",
        "body": "I assume your issue raised due  to not all variables declared in lexical scope. It is not an issue with `express` nor Node.js - it is a nature of pure JS: you need to use `var/let/const` for variables - otherwise global variables will be created implicitly.\r\n\r\nPlease try following updated code with proper variables declaration:\r\n```javascript\r\nconst fetch = require(\"node-fetch\");\r\nconst config = require(\"../../../config/configs\")\r\n\r\nasync function getquestion (questionid) {\r\n  const url = config.url\r\n  const options = {\r\n    headers: {\r\n      'Authorization': config.Authorization,\r\n      'Accept': config.Accept,\r\n    }\r\n  };\r\n\r\n  try {\r\n    const response = await fetch(url, options);\r\n    const json = await response.json();\r\n    return json;\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  getquestion\r\n}\r\n```\r\n\r\n```javascript\r\nasync function asyncer(id){\r\n  const response = await getquestion(id);\r\n  const question = response.result.content.content\r\n  const answer = null; // answer should be defined in case it not global variable\r\n  return [question, answer]\r\n}\r\n```\r\n\r\n```javascript\r\nconst qa = await asyncer(id)\r\nif (qa) {\r\n return await res.status(200).json({\r\n      success: 1,\r\n      question: qa[0],\r\n      answer: qa[1]\r\n })\r\n}\r\n```"
      },
      {
        "user": "moezemara",
        "created_at": "2021-02-09T22:56:34Z",
        "body": "> I assume your issue raised due to not all variables declared in lexical scope. It is not an issue with `express` nor Node.js - it is a nature of pure JS: you need to use `var/let/const` for variables - otherwise global variables will be created implicitly.\r\n> \r\n> Please try following updated code with proper variables declaration:\r\n> \r\n> ```js\r\n> const fetch = require(\"node-fetch\");\r\n> const config = require(\"../../../config/configs\")\r\n> \r\n> async function getquestion (questionid) {\r\n>   const url = config.url\r\n>   const options = {\r\n>     headers: {\r\n>       'Authorization': config.Authorization,\r\n>       'Accept': config.Accept,\r\n>     }\r\n>   };\r\n> \r\n>   try {\r\n>     const response = await fetch(url, options);\r\n>     const json = await response.json();\r\n>     return json;\r\n>   } catch (error) {\r\n>     console.log(error);\r\n>   }\r\n> }\r\n> \r\n> module.exports = {\r\n>   getquestion\r\n> }\r\n> ```\r\n> \r\n> ```js\r\n> async function asyncer(id){\r\n>   const response = await getquestion(id);\r\n>   const question = response.result.content.content\r\n>   const answer = null; // answer should be defined in case it not global variable\r\n>   return [question, answer]\r\n> }\r\n> ```\r\n> \r\n> ```js\r\n> const qa = await asyncer(id)\r\n> if (qa) {\r\n>  return await res.status(200).json({\r\n>       success: 1,\r\n>       question: qa[0],\r\n>       answer: qa[1]\r\n>  })\r\n> }\r\n> ```\r\n\r\nthanks a lot \r\nit's working now"
      }
    ]
  },
  {
    "number": 4519,
    "title": "Method/ Attribute in Response object to get response body",
    "created_at": "2021-01-29T13:05:27Z",
    "closed_at": "2021-01-29T14:00:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4519",
    "body": "We have an API that runs something like this.\r\n\r\n```javascript\r\napp.get('/route', user.isAuth, cache.getFromCache, model.getFromDB, cache.setCache);\r\n```\r\n\r\nWe would like to get the response body (we prepare in model.getFromDB) to be available to the next request handler as well. \r\nWhat we currently do is:\r\n\r\n```javascript\r\nasync getFromDB() {\r\n    // ...\r\n    res.locals.cache = body;\r\n    res.status(200).json(body);\r\n}\r\n```\r\n\r\nAs should be obvious, this is a bit tricky, and someone can easily forget to do this part. Can we have a method or an attribute that stores the body, like `res.body` perhaps?\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4519/comments",
    "author": "ShubhankarKG",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-01-29T14:00:07Z",
        "body": "Hi @ShubhankarKG thanks for the suggestion. Unfortunately it is not that simple as there are many, many ways one can write a body, and not all those ways are with our helper methods. Maintaining a `res.body` at the framework would understandably be expected to have whatever the response body was, even if the response was a 10GB file.\r\n\r\nThe ability to save the response body is going to be dependent on the application.\r\n\r\nThankfully, Express is very flexible and allows you to make you app automatically save the value given the `res.json` if that is what you would like to have happen. The following can be added to your app definition, for example:\r\n\r\n```js\r\napp.response.json = (function (json) {\r\n  return function (body) {\r\n    this.locals.cache = body\r\n    return json.call(this, body)\r\n  }\r\n}(app.response.body))\r\n```\r\n\r\nThere are many ways to write the above; pulling in a AOP lib would make it more straight forward, even.\r\n\r\nI hope this helps."
      }
    ]
  },
  {
    "number": 4516,
    "title": "Feature Request",
    "created_at": "2021-01-25T06:42:13Z",
    "closed_at": "2021-01-25T07:00:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4516",
    "body": "Hey! Thanks for making such a great library. I use this for multiple projects. I just wanted to suggest a feature be added to Express.\r\n\r\nAdding a capability for `res.sendFile` to take a Buffer instead of a file path would be very useful, as for my website I use image manipulation to generate images. This would be incredibly useful to me, and probably lots of other people.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4516/comments",
    "author": "LingleDev",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-01-25T06:43:47Z",
        "body": "Hi @FHGDev ! Can you ellaborate on what you would expect to happen if you gave a `Buffer` to `res.sendFile` and how that would be different than if you gave that same `Buffer` to the already-existing `res.send`?"
      },
      {
        "user": "LingleDev",
        "created_at": "2021-01-25T06:59:04Z",
        "body": "For example, if you sent a Buffer with `res.sendFile`, you could specify what type of file the buffer data represents in options, and Express can make that sent as the Content-Type of the response. Like so:\r\n```js\r\napp.get('/some_image', (req,res) => {\r\n  // image generation code here...\r\n\r\n  res.sendFile(generatedImageBuffer, { type: 'image/png' }) \r\n})\r\n```\r\n\r\nThis would help me personally. I send PNG files by writing the generated image to a file, then passing that file's path to `res.sendFile`. This would probably save people from writing a decent amount of code to send an image file to the client.\r\n\r\n(Note I am an amateur at Express, so I most likely don't know other ways to send image data...)"
      },
      {
        "user": "dougwilson",
        "created_at": "2021-01-25T07:00:37Z",
        "body": "Ah, I see. This is already possible with the current APIs: `res.type('image/png').send(generatedImageBuffer)`. I hope that helps you!"
      },
      {
        "user": "LingleDev",
        "created_at": "2021-01-25T07:01:13Z",
        "body": "Ah! Thanks for the advice."
      }
    ]
  },
  {
    "number": 4502,
    "title": "erre npm",
    "created_at": "2021-01-05T22:30:31Z",
    "closed_at": "2021-01-06T09:21:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4502",
    "body": "npm ERR! JSON.parse package.json must be actual JSON, not just JavaScript.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4502/comments",
    "author": "abhaypratapsingh099",
    "comments": [
      {
        "user": "rodion-arr",
        "created_at": "2021-01-06T09:21:26Z",
        "body": "Hi @abhaypratapsingh099, this error tell you that you have a syntax error in you package.json file. Try to verify it in any JSON validator - it should point you to invalid place."
      }
    ]
  },
  {
    "number": 4501,
    "title": "How to decode URI parameter in Express JS",
    "created_at": "2021-01-03T05:02:53Z",
    "closed_at": "2021-01-03T12:15:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4501",
    "body": "Hi Guys,\r\n\r\nIm trying to send a GET request to my node express route with ajax but i cant figure out how to decode the URI param.\r\n\r\nThis is whats getting sent to the request:  GET /exercises/Day%201.\r\n\r\nI want to decode it so it'll be something like --> Day 1\r\n\r\nThen my query will be something like the following:\r\n\r\n router.get('/:dayOfWeek', async (req, res) => {\r\n  try {\r\n    const dow = req.params.dayOfWeek;\r\n    const program = await Program.findOne({ user: req.user.id })\r\n      .populate({\r\n        path: 'exercises',\r\n        match: { dayOfWeek: dow }\r\n      })\r\n      .exec();\r\n\r\n### JS file\r\n\r\n$('#dayOfWeek').on('change', function() {\r\n    const dayOfWeek = $('#dayOfWeek').val();\r\n    const encoded = encodeURI(dayOfWeek);\r\n    $.ajax({\r\n      type: 'GET',\r\n      url: `/exercises/${encoded}`,\r\n      dataType: 'json'\r\n    }).done((programs) => {\r\n      console.log(programs);\r\n    });\r\n  });\r\n### Routes File\r\nrouter.get('/:dayOfWeek', async (req, res) => {\r\n  try {\r\n    const dow = req.params.dayOfWeek;\r\n    const program = await Program.findOne({ user: req.user.id })\r\n      .populate({\r\n        path: 'exercises',\r\n        match: { dayOfWeek: dow }\r\n      })\r\n      .exec();\r\n    //.lean();\r\n    res.send(program);\r\n  }\r\n\r\nThanks for the help guys.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4501/comments",
    "author": "HenryDinh86",
    "comments": [
      {
        "user": "rodion-arr",
        "created_at": "2021-01-03T12:13:57Z",
        "body": "Hi @HenryDinh86! In this case param `dayOfWeek` should be already URL-decoded in your controller.\r\nId you will `console.log` your params object - you should see something like this:\r\n```\r\n{ dayOfWeek: 'Day 1' }\r\n```"
      }
    ]
  },
  {
    "number": 4494,
    "title": "req.hostname getting undefined when listening event 'upgrade'",
    "created_at": "2020-12-26T02:38:55Z",
    "closed_at": "2020-12-26T02:41:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4494",
    "body": "Hello everyone.\r\n\r\nFirst of all, I would like to wish a merry christmas and a happy new year to all the people who read this issue. \r\n\r\nRecently I've been working with websockets and trying to route them through the 'node-http-proxy' package which does it with a good job. However, to route the websockets I need to listen to the .on event ('upgrade') and obtain its origin host to decide which proxy I will forward my socket to. In my test scenarios, running Express v 4.17.1 and node-http-proxy v. 1.1.9 when I try to connect using a browser websocket I receive the 'upgrade' event as expected but the req.hostname property is undefined while the req.headers.host property is set.\r\n\r\nAny idea why this is happening? If this feature isnt supported yet, I would appreciate it if req.hostname was also available for the upgrade event. \r\n\r\nMy node.js version is 10.16.0\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4494/comments",
    "author": "MurylloEx",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2020-12-26T02:41:28Z",
        "body": "None of Express is available in the upgrade event, as that is outside of the Express framework itself (the event is from Node.js framework and so you are seeing only the items Node.js provides)."
      }
    ]
  },
  {
    "number": 4487,
    "title": "Why Expressjs code base is not being updated to new javaScript/Nodejs standards",
    "created_at": "2020-12-18T01:04:38Z",
    "closed_at": "2020-12-18T01:10:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4487",
    "body": "We all know Expressjs is the **greatest perfect** Nodejs framework ever created and everyone love it, use it and if you are new to Nodejs its the first thing you learn (many books about Nodejs/JavaScript are just teaching Expressjs). \r\n\r\nQuestions:\r\n1. Why Expressjs code base is not being updated to newer JavaScript/Nodejs standards. \r\n2. Why such a great open source project is abandoned?\r\n3. Is Expressjs a dead open source project?\r\n4. Will there ever be express 5, 6, 7, 8?\r\n5. Why no one is updating it or interested in updating?\r\n6. Is it safe to use express for future projects\r\nand more questions and more questions.....?\r\n\r\nHappy coding,\r\nThank You\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4487/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2020-12-18T01:10:35Z",
        "body": "The best way to help if you want to see these changes is... start contributing via pull requests! :)"
      }
    ]
  },
  {
    "number": 4485,
    "title": "Html image not working.",
    "created_at": "2020-12-14T21:47:23Z",
    "closed_at": "2020-12-15T15:40:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4485",
    "body": "So basically, i put a file in pfps/1.jpg. I did res.sendFile(__dirname + 'pfps/1.jpg'), and that worked. But when i do \r\nlet path = (__dirname + 'pfps/1.jpg')\r\nres.send(`\r\n<img src=${path}>\r\n`), it does not work. the image does not load.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4485/comments",
    "author": "TheFinality",
    "comments": [
      {
        "user": "rodion-arr",
        "created_at": "2020-12-15T15:40:49Z",
        "body": "Hi @F1R3L1GHT, I could not reproduce your issue, `res.send()` is working correctly.\r\n\r\nI assume `__dirname` will not fit for sending public URI for image as it will return internal server path that won't fit for putting it in `src` attribute."
      }
    ]
  },
  {
    "number": 4482,
    "title": "clearCookie not working",
    "created_at": "2020-12-12T01:54:06Z",
    "closed_at": "2020-12-15T21:07:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4482",
    "body": "clearCookie is not working, it works in the example all the time, but in my code, it only worked once....",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4482/comments",
    "author": "TheFinality",
    "comments": [
      {
        "user": "TheFinality",
        "created_at": "2020-12-12T01:55:25Z",
        "body": "holdup, it doesnt work when it redirects - it works when i type the address myself"
      },
      {
        "user": "rodion-arr",
        "created_at": "2020-12-12T18:35:14Z",
        "body": "Hey @F1R3L1GHT! Could you please provide runnable code example which reproduces mentioned problem?"
      },
      {
        "user": "TheFinality",
        "created_at": "2020-12-14T21:45:11Z",
        "body": "nvm, figured it out, a typo XD"
      },
      {
        "user": "rodion-arr",
        "created_at": "2020-12-15T15:30:10Z",
        "body": "@F1R3L1GHT are you still facing problems with clearing cookies or this issue can be closed?"
      },
      {
        "user": "getspooky",
        "created_at": "2020-12-15T21:05:30Z",
        "body": "@F1R3L1GHT  Could you please provide runnable code example ?"
      },
      {
        "user": "dougwilson",
        "created_at": "2020-12-15T21:07:38Z",
        "body": "Looks like @F1R3L1GHT said they figured out the issue, which was a typo."
      }
    ]
  },
  {
    "number": 4441,
    "title": "Routes are disappearing",
    "created_at": "2020-10-22T21:29:28Z",
    "closed_at": "2021-08-29T16:17:03Z",
    "labels": [
      "question",
      "awaiting more info"
    ],
    "url": "https://github.com/expressjs/express/issues/4441",
    "body": "Hello,\r\n\r\nI have a long term project built with express and generally functioning very well.\r\n\r\nAfter what seems like an arbitrary time (generally more than 1 hour), a large portion of the routes disappear and 404 errors are returned. I am unable to reproduce this problem on demand however I can confirm that the problem happens on both our development and our live server. Both on Ubuntu 20.04 and Nodejs 12, Express 4.17.1. I did suspect that there is something related to a back-end database inaccessibility using the Knex library, as this in the past has correlated with database connections being unavailable, but again this is a guess.\r\n\r\nI investigated within the endpoint for a while convinced that the problem was something on my side. But I decided to add a route that printed `app._router.stack` fortunately this route remained after it last crashed.\r\n\r\nI outputted before and after. Before I have just under 600 routes. After this incident I have 150\r\n\r\nThe other difference (which may be complete unrelated and completely normal) is a few of the routes which are remaining some change.\r\n\r\nI am also unable to correlate if any particular activity is causing these routes to disappear either.\r\n\r\nFrom\r\n\r\n```\r\n{\r\n\t\"name\": \"bound dispatch\",\t\t\t\t\t\t\t\r\n\t\"keys\": [],\r\n\t\"regexp\": {\r\n\t\t\"fast_star\": false,\r\n\t\t\"fast_slash\": false\r\n\t},\r\n\t\"route\": {\r\n\t\t\"path\": \"/api/cp/breakout\",\r\n\t\t\"stack\": [{\r\n\t\t\t\"name\": \"<anonymous>\",\r\n\t\t\t\"keys\": [],\r\n\t\t\t\"regexp\": {\r\n\t\t\t\t\"fast_star\": false,\r\n\t\t\t\t\"fast_slash\": false\r\n\t\t\t},\r\n\t\t\t\"method\": \"post\"\r\n\t\t}],\r\n\t\t\"methods\": {\r\n\t\t\t\"post\": true\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nTo\r\n```\r\n{\r\n\t\"name\": \"bound dispatch\",\r\n\t\"params\": {},\r\n\t\"path\": \"/api/cp/breakout\",\r\n\t\"keys\": [],\r\n\t\"regexp\": {\r\n\t\t\"fast_star\": false,\r\n\t\t\"fast_slash\": false\r\n\t},\r\n\t\"route\": {\r\n\t\t\"path\": \"/api/cp/breakout\",\r\n\t\t\"stack\": [{\r\n\t\t\t\"name\": \"<anonymous>\",\r\n\t\t\t\"keys\": [],\r\n\t\t\t\"regexp\": {\r\n\t\t\t\t\"fast_star\": false,\r\n\t\t\t\t\"fast_slash\": false\r\n\t\t\t},\r\n\t\t\t\"method\": \"post\"\r\n\t\t}],\r\n\t\t\"methods\": {\r\n\t\t\t\"post\": true\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nNote the extra:\r\n\r\n```\r\n\t\"params\": {},\r\n\t\"path\": \"/api/cp/breakout\",\r\n```\r\n\r\nThere does not appear to be anything in the error logs indicating that something has happened, nor have I been able to find this problem documented elsewhere.\r\n\r\nI would greatly appreciate any help in getting to the next step in debugging this unusual problem.\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4441/comments",
    "author": "digipigeon",
    "comments": [
      {
        "user": "Vinayakj009",
        "created_at": "2021-03-29T05:19:00Z",
        "body": "Hi,\r\n\r\nI am a newbie here, and I just learned how to enable debug logs for expressjs. Since you have neither mentioned that you have checked the debug logs, nor provided any screenshots to the same, I am guessing you might not have tried printing the debug logs.\r\nHave you tried printing the debug logs, to see if something is changing the routes?\r\nI got the debug logs running by adding the debug script to my package.json like so\r\n\r\n>\"scripts\": {\r\n>    \"start\": \"nodemon -r dotenv/config API/server.js\",\r\n>    \"test\": \"jest\"\r\n>  }\r\n\r\nto\r\n\r\n> \"scripts\": {\r\n>    \"start\": \"nodemon -r dotenv/config API/server.js\",\r\n>    \"debug\": \"DEBUG=express:* node -r dotenv/config API/server.js\",\r\n>    \"test\": \"jest\"\r\n>  }\r\n\r\nand then I started the server in debug mode as so\r\n\r\n`\r\nnpm run start\r\n`\r\nto\r\n`\r\nnpm run debug\r\n`\r\n"
      },
      {
        "user": "aravindvnair99",
        "created_at": "2021-06-06T20:17:03Z",
        "body": "Hey @digipigeon!\r\n\r\nHas the issue been resolved for you?"
      },
      {
        "user": "dougwilson",
        "created_at": "2021-08-29T16:17:03Z",
        "body": "Closing due to no response."
      }
    ]
  },
  {
    "number": 4433,
    "title": "[v5] req.query is not writable anymore",
    "created_at": "2020-10-16T11:04:23Z",
    "closed_at": "2020-10-16T12:54:24Z",
    "labels": [
      "5.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4433",
    "body": "Hey guys, in v5 it's not possible to write into `req.query` anymore, as you defined it only as getter wrapper. \r\nSometimes it was useful to write some default values (like limit/offset for pagination) into the `req.query`, and not it's not possible now. Would love to see some way how to set default values into req.query. Thank you!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4433/comments",
    "author": "Vakintoshka",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2020-10-16T12:54:05Z",
        "body": "You are correct it is not writable, which is noted in the changelog and is intentional. You should not be storing data in req.query, as that represents the query string on req.url. you can always directly change req.url in order to affect req.query, or better, store the data on req in a different way."
      }
    ]
  },
  {
    "number": 4390,
    "title": "app.use not working",
    "created_at": "2020-08-27T14:20:48Z",
    "closed_at": "2020-12-24T18:43:59Z",
    "labels": [
      "question",
      "awaiting more info"
    ],
    "url": "https://github.com/expressjs/express/issues/4390",
    "body": "**app.use  working only index file.**\r\n\r\n> app.use(\"/\",(req,res)=>\r\n> {\r\n>    res.json(\"Welcome My Project\");\r\n> });\r\n> \r\n\r\n**but the same time i call router**  \r\n\r\n> const infoRouter = require(\"./router\");\r\n> app.use(\"/info\",infoRouter);\r\n\r\nnot working, error **Cannot GET** \r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4390/comments",
    "author": "kayatechindia",
    "comments": [
      {
        "user": "krzysdz",
        "created_at": "2020-08-27T16:48:18Z",
        "body": "Could you also send here your `router` file?\r\n\r\nBTW. you can use:\r\n\\```js\r\ncode\r\n\\```\r\nand your code will be displayed better:\r\n```js\r\nconst infoRouter = require(\"./router\");\r\n```"
      },
      {
        "user": "ghinks",
        "created_at": "2020-08-27T17:09:49Z",
        "body": "Hello @kayatechindia it is often hard for us to diagnose issues without a working code example to demonstrate the issue.\r\n\r\nOur first request would be for you to create a very small program that demonstrates the issue and the http requests you are making to it.\r\n\r\nMy first **guess** is that **use** is generally not used for routing.  Maybe something like\r\n\r\n```javascript\r\napp.get('/', (req,res) => {\r\n  res.json({\r\n     \"hello\": \"world\"\r\n  });\r\n```\r\n\r\nwould be better.\r\n\r\n\r\nthen when you use the **router** and supply the prefix route are you calling the route with the prefix or the base route still ?"
      },
      {
        "user": "Gaurav2048",
        "created_at": "2020-09-15T10:09:38Z",
        "body": "@kayatechindia  use app.get and not app.use here. "
      },
      {
        "user": "wambugucoder",
        "created_at": "2020-09-16T13:33:23Z",
        "body": "@kayatechindia\r\n <i>try</i>\r\n```Javascript\r\napp.get(\"/\",(req,res)=>\r\n{\r\nres.send(\"Welcome My Project\");\r\n});\r\n```\r\nwhen importing routes use:\r\n\r\n\r\nconst infoRouter = require(\"./router\");\r\n```JavaScript\r\n   app.use((\"/info\",infoRouter)\r\n```\r\n<i>Then run your app to whatever localhost://port/info/</i>\r\n"
      },
      {
        "user": "ManchukondaManoj",
        "created_at": "2020-09-20T16:17:33Z",
        "body": "@kayatechindia  Can you please show your \r\n./router file for more info.\r\n\r\n\r\n"
      },
      {
        "user": "3imed-jaberi",
        "created_at": "2020-10-01T12:45:12Z",
        "body": "@kayatechindia, plz provide all the code so we can help you"
      },
      {
        "user": "zahqresh",
        "created_at": "2020-11-29T15:12:55Z",
        "body": "To make us better understand and help you solve the problem you should share some more information or code that you wrote more than above thanks!"
      },
      {
        "user": "bkcetinkaya",
        "created_at": "2020-12-24T18:38:29Z",
        "body": "This is so obvious that your problem is caused by your routes file and you did not share it"
      },
      {
        "user": "dougwilson",
        "created_at": "2020-12-24T18:43:55Z",
        "body": "I'm going to close this as it has been a few months and the OP never followed up with the requested information. "
      }
    ]
  },
  {
    "number": 4383,
    "title": "Stable version 5",
    "created_at": "2020-08-24T05:08:47Z",
    "closed_at": "2020-08-24T05:11:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4383",
    "body": "Hi\r\nI had a question, why version 5 is not released faster. It's been three years now and there is still an alpha version and the development process is very slow\r\nIs there a specific reason?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4383/comments",
    "author": "Hesamp",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2020-08-24T05:11:45Z",
        "body": "Hi @Hesamp there are a lost of things, but ultimately we just need contributors to help make the actual code changes behind the checkpoints listed at the top of #2237\r\n\r\nA great example of this is that we have changes to the underlying `router` module that need to be merged into Express 5.0 branch for the next 5.0 release. There is a PR #4321 opened which is unfinished. if the author needs help to make that happen, then ideally folks will volunteer their time to push up the remaining changes so we can get it landed."
      },
      {
        "user": "mreinstein",
        "created_at": "2020-09-19T01:16:21Z",
        "body": "@dougwilson how can I help?  What is the biggest blocker to v5 right now?"
      },
      {
        "user": "dougwilson",
        "created_at": "2020-09-19T01:17:42Z",
        "body": "We need to get PR #4321 finished to release the RC. This router update contains the bulk of the 5.0 changes."
      },
      {
        "user": "mreinstein",
        "created_at": "2020-09-19T01:18:37Z",
        "body": "who do I bug to get some context around this? Should I pester you?"
      },
      {
        "user": "mreinstein",
        "created_at": "2020-09-19T01:19:15Z",
        "body": "are you on discord or gitter or something? happy to briefly chat in real time if that helps."
      },
      {
        "user": "dougwilson",
        "created_at": "2020-09-19T01:23:39Z",
        "body": "In my time zone it is fairly late and am actually out finishing up a family dinner right now,  so not able to discuss at this time in that kind of way. I wanted to try to get you the quick answers to get you moving, but it sounds like you are looking for a much larger amount of time. "
      },
      {
        "user": "mreinstein",
        "created_at": "2020-09-19T01:26:16Z",
        "body": "yeah I definitely don't want to pester you mid dinner, go do that! \r\n\r\nAnd I appreciate all the work you've done to pick up the maintenance work. \r\n\r\nI can probably dig through that issue and try to figure out what to do, it's just not clear to me as a newbie to this particular codebase a) which items are already being worked on b) by whom and c) what some of the items actually are. :P but I'm happy to just poke around. sometimes real time chat is a fast way to get up to speed but I get that it doesn't scale. \r\n\r\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2020-09-19T01:31:48Z",
        "body": "If you like as well, you can send me an email (in package.json) as we can find a good time where I can help point you around and get your energy towards the release, as that is always great! "
      }
    ]
  },
  {
    "number": 4357,
    "title": "localhost cannot read property 'name' of undefined nodejs",
    "created_at": "2020-07-23T08:04:09Z",
    "closed_at": "2020-07-23T10:16:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4357",
    "body": "`TypeError: Cannot read property 'fName' of undefined\r\n    at C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\Newsletter-Signup\\app.js:20:28\r\n    at Layer.handle [as handle_request] (C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\express\\lib\\router\\layer.js:95:5)\r\n    at next (C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\express\\lib\\router\\route.js:137:13)\r\n    at Route.dispatch (C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\express\\lib\\router\\route.js:112:3)\r\n    at Layer.handle [as handle_request] (C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\express\\lib\\router\\layer.js:95:5)\r\n    at C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\express\\lib\\router\\index.js:281:22\r\n    at Function.process_params (C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\express\\lib\\router\\index.js:335:12)\r\n    at next (C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\express\\lib\\router\\index.js:275:10)\r\n    at C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\body-parser\\lib\\read.js:130:5\r\n    at invokeCallback (C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\raw-body\\index.js:224:16)`\r\n\r\nHere's my code in app.js\r\n`const express = require('express');\r\nconst bodyParser = require('body-parser');\r\nconst request = require('request');\r\nconst app = express();\r\napp.use(express.static('public'));\r\napp.use(bodyParser.urlencoded({ extended: true }));`\r\n\r\nPost request code:\r\n`app.post('/', function (req, res) {\r\n  var firstName = res.body.fName;\r\n  var lastName = res.body.lName;\r\n  var emailID = res.body.fEmail;\r\n  console.log(firstName, lastName, emailID);\r\n});`",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4357/comments",
    "author": "aishwarya07g",
    "comments": [
      {
        "user": "rodion-arr",
        "created_at": "2020-07-23T08:31:09Z",
        "body": "Hi, `body` is property of request `req`. You are using `res` instead."
      },
      {
        "user": "aishwarya07g",
        "created_at": "2020-07-23T10:16:16Z",
        "body": "Oh crap, thanks a ton! :D"
      }
    ]
  },
  {
    "number": 4344,
    "title": "How to set error.name in extended class Error in Node.js?",
    "created_at": "2020-07-11T00:14:42Z",
    "closed_at": "2020-07-14T01:13:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4344",
    "body": "I'm trying to set the error name `err.name = 'ExpressValidatorError';` \r\n\r\nof an custom Error class `class AppError extends Error` \r\n\r\nthat is passed to centralErrorHandler to filter and handle errors by `err.name`.\r\n\r\nI have did a lot of research but still couldn't figure out why `err.name` in centralErrorHandler console logs as `undefined`.\r\n\r\nWhen I change `return next(err);` in auth.controller.js to `throw err;`, the `err.name` does console log as `'ExpressValidatorError'` but i'm not sure if using throw is correct.\r\n\r\n\r\n\r\ncentralErrorHandler.js\r\n```\r\nmodule.exports = (err, req, res, next) => {           \r\n        console.log(err.name);\r\n        if(err.name === 'ExpressValidatorError') err = handleExpressValidatorError(err);            \r\n}\r\n\r\n```\r\n\r\nauth.controller.js\r\n```\r\nconst {validationResult} = require('express-validator');\r\n\r\nexports.signup = (req, res) => {     \r\n    const errors = validationResult(req); \r\n   \r\n      if (!errors.isEmpty()) {\r\n        let err = new AppError(`Invalid login credentials.`, 422);\r\n        err.name = 'ExpressValidatorError';            \r\n             \r\n        return next(err);\r\n      }\r\n\r\n    res.status(200).send(req.user);          \r\n}\r\n```\r\n\r\nappError.js\r\n```\r\nclass AppError extends Error {\r\n    constructor(message, statusCode){\r\n        super(message);\r\n\r\n        this.statusCode = statusCode;\r\n        this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';        \r\n        this.isOperational = true;        \r\n\r\n        Error.captureStackTrace(this, this.constructor);\r\n    }\r\n}\r\n\r\nmodule.exports = AppError;\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4344/comments",
    "author": "KaizenTamashi",
    "comments": [
      {
        "user": "mastermatt",
        "created_at": "2020-07-11T04:12:59Z",
        "body": "In your signup controller you're calling `return next(err);`, however, you haven't included `next` as a param for the handler.\r\nWhen I run your code, the error I get is `ReferenceError: \"next is not defined\"`. And updating the handler signature to `exports.signup = (req, res, next) => { ...` logs as you expect in `centralErrorHandler`. "
      },
      {
        "user": "KaizenTamashi",
        "created_at": "2020-07-13T14:21:10Z",
        "body": "@mastermatt Thank you, the missing `next` parameter is causing the issue. \r\nFor some reason i didn't encounter the `ReferenceError: \"next is not defined\"` in the console log."
      },
      {
        "user": "mastermatt",
        "created_at": "2020-07-13T15:23:57Z",
        "body": "Glad to help.\r\n\r\nI first changed your logging to log the whole error object instead of just `err.name`, that gave me the `ReferenceError` and it all fell into place from there. "
      },
      {
        "user": "KaizenTamashi",
        "created_at": "2020-07-14T01:13:25Z",
        "body": "@mastermatt Thank you :)"
      },
      {
        "user": "f0rnasier",
        "created_at": "2022-01-26T17:28:45Z",
        "body": "I am trying to implement almost the same code but I am getting the error \"Invalid status code: error\""
      }
    ]
  },
  {
    "number": 4333,
    "title": "Router doens't match with an route",
    "created_at": "2020-06-30T13:20:31Z",
    "closed_at": "2020-07-02T02:32:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4333",
    "body": "So, I have a following index.js file, where I define the default route and another endpoint that points to a router.\r\n\r\nTherefore, **when I try to access the endpoint /endpoint/something points to the default route, that is '/'.** I don't know what could happen.\r\n\r\nActivating the debug options shows that the new layer, in that case, endpoint was created, but I cannot figure out how to access it.\r\n\r\nSomeone could help? Thanks in advance.\r\n\r\n```js\r\nimport express from 'express';\r\nimport bodyParser from 'body-parser';\r\nimport dotenv from 'dotenv';\r\nimport endpointRouter from './src/endpoint/endpoint.router';\r\n\r\ndotenv.config();\r\n\r\nconst app = express();\r\napp.use(bodyParser.json());\r\napp.use(bodyParser.urlencoded({ extended: true }));\r\n\r\n// routes\r\napp.use('/', (req, res) => res.status(200).send({message: 'Welcome'}));\r\napp.use('/endpoint', endpointRouter);\r\n\r\napp.listen(process.env.PORT, process.env.IPCONFIG, () => console.log(`Process listening on ${process.env.PORT}`));\r\n\r\nexport default app;\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4333/comments",
    "author": "lukaswilkeer",
    "comments": [
      {
        "user": "losanni",
        "created_at": "2020-06-30T16:13:39Z",
        "body": "Try this. \r\n\r\n```\r\nconst express = require('express');\r\nconst bodyParser = require('body-parser');\r\nconst dotenv = require('dotenv');\r\nconst endpointRouter = require('./src/endpoint/endpoint.router');\r\n\r\ndotenv.config();\r\n\r\nconst app = express();\r\napp.use(bodyParser.json());\r\napp.use(bodyParser.urlencoded({ extended: true }));\r\n\r\n// routes\r\napp.get('/', (req, res) => res.status(200).send({message: 'Welcome'}));\r\napp.use('/endpoint', endpointRouter);\r\n\r\napp.listen(process.env.PORT, () => console.log(`Process listening on ${process.env.PORT}`));\r\n\r\n```"
      },
      {
        "user": "lukaswilkeer",
        "created_at": "2020-07-01T21:55:01Z",
        "body": "Thanks, it's was a mistake. Closed."
      }
    ]
  },
  {
    "number": 4279,
    "title": "Wrong render path",
    "created_at": "2020-05-15T23:18:45Z",
    "closed_at": "2020-05-17T02:52:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4279",
    "body": "Hi, I am taking post id parameter to show blog content, everything is fine on here but there is a problem, it is on code or express rendering I don't know exactly.\r\nExpress trying to send my js/css/img files in 'public/post/', but I want to it send from only 'public' path.\r\n\r\nI tried these;\r\n- I tried to change 'path.join'(express.static) but it is also didn't work.\r\n-> `path.join(__dirname + '../', 'public')` or etc...\r\n- I tried to specify path to router but it didn't.\r\n-> (In app.js) app.use('/', mainRouter, here express.path)\r\n- I searched on google, express docs but I couldn't find any solution to this.\r\n\r\n**Routers:**\r\nOnly one router: _main.js_\r\n\r\n**Public Folder:**  classic express generator\r\n\r\n**Codes:**\r\n```\r\n// Show Post By ID\r\n// 5ebabf454b74f711141a5aa4 -> Test Database ID, It exists.\r\nrouter.get('/post/:postid', (req, res, next) => {\r\n    Post.findById(req.params.postid).then((doc) => {\r\n        res.render('post', { title: devblog.name, post: doc });\r\n    }).catch((err) => {\r\n        next(createError(404, err));\r\n    });\r\n});\r\n```\r\n**Console:**\r\n```\r\nGET /post/5ebabf454b74f711141a5aa4 304 3191.975 ms - -\r\nGET /post/stylesheets/bootstrap.min.css 404 500.526 ms - 2295\r\nGET /post/stylesheets/style.css 404 562.285 ms - 2295\r\nGET /post/javascripts/jquery-3.4.1.slim.min.js 404 1438.587 ms - 2295\r\nGET /post/javascripts/bootstrap.bundle.min.js 404 2100.498 ms - 2295\r\n```\r\nHere is the problem: \r\n> /post/stylesheets/\r\n\r\nHow i can change this to normal? **What should I do?**\r\n> /post/stylesheets/ => /stylesheets/\r\n\r\nSorry for syntax, bad English sentences, If there are many flaws, please forgive me.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4279/comments",
    "author": "ipatavatsizz",
    "comments": [
      {
        "user": "jonchurch",
        "created_at": "2020-05-16T19:49:01Z",
        "body": "This is probably an issue with how you're linking to these files from your template.\r\n\r\nUsually it's forgetting to add a forward slash `/` to the resource's path:\r\n\r\nIf the URL of your page is `/post/1234` and you use a stylesheet link like the following:\r\n\r\n```html\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"css/mystyle.css\">\r\n```\r\nIt will try to load `/post/1234/css/mystle.css`\r\n\r\nBut if you use a forward slash in the html tag, it will try to load from the root of the website:\r\n\r\n```html\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"/css/mystyle.css\">\r\n```\r\n\r\nFrom the same page, that tag will try to load `/css/mystle.css`"
      },
      {
        "user": "ipatavatsizz",
        "created_at": "2020-05-17T02:52:44Z",
        "body": "Thanks a lot <3 It worked."
      }
    ]
  },
  {
    "number": 4270,
    "title": "First attempt to connect to the Expressjs App after restarting node.js terminates at user's end",
    "created_at": "2020-05-08T12:21:42Z",
    "closed_at": "2020-05-08T15:05:56Z",
    "labels": [
      "question",
      "awaiting more info"
    ],
    "url": "https://github.com/expressjs/express/issues/4270",
    "body": "route.js\r\nconst routes = require('express').Router();\r\nroutes.get('/', (req, res) => {\r\n var outputvariable =  child_process.spawnSync('powershell.exe'\r\n ///// .. do this for 15 mins)\r\nres.send('outputvariable);\r\n});\r\nmodule.exports = routes;\r\n\r\nIn the main.js \r\nconst aroute= require('./route.js'); app.use('/route', aroute);\r\n\r\nThe first hit coming to the server is being processed at the server end but the res.send is not working when I reload node main.js\r\n\r\nThere is a childprocessSync in route.js, request is going to the route.js , but the first hit to app.js is getting terminated from postman.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4270/comments",
    "author": "HarishVaranasi",
    "comments": [
      {
        "user": "ghinks",
        "created_at": "2020-05-08T15:05:56Z",
        "body": "We do feel your pain Harish. But this is really a place for issues with Express and not **application problems**.\r\n\r\nIf you are processing for 15 minutes before sending a response. Then this is most likely a client side issue. Did you expect postman to wait 15 minutes?\r\n\r\nIf you want help, post some sort of generic example that would say use a timer to simulate the work time.\r\n\r\nBut this is really something for stack overflow and not express issues."
      },
      {
        "user": "ryhinchey",
        "created_at": "2020-05-08T15:05:59Z",
        "body": "@HarishVaranasi from a quick look at your code, if you’re spawning a new process and synchronously waiting for a response before responding to the http request, it’s possible the request is timing out on the client.  I see a comment in your code about 15 minutes passing in the sync spawned process."
      }
    ]
  },
  {
    "number": 4252,
    "title": "Cookie's don't clear if maxAge is set",
    "created_at": "2020-04-24T20:14:01Z",
    "closed_at": "2020-04-24T20:23:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4252",
    "body": "If a cookie with a `maxAge` is set, performing `res.clearCookie()` will not clear the cookie.\r\n\r\nWe update the expiry in `clearCookie()` so the `expires` property is overriden to a past date:\r\n```javascript\r\nres.clearCookie = function clearCookie(name, options) {\r\n  var opts = merge({ expires: new Date(1), path: '/' }, options);\r\n\r\n  return this.cookie(name, '', opts);\r\n};\r\n```\r\n\r\nBut then when `this.cookie()` is called, it sees the cookie has a `maxAge` property, which will override the expiry date in this code:\r\n\r\n```javascript\r\n  if ('maxAge' in opts) {\r\n    opts.expires = new Date(Date.now() + opts.maxAge);\r\n    opts.maxAge /= 1000;\r\n  }\r\n```\r\n\r\nand the cookie therefore wouldn't be cleared *(In fact, it would actually cause the cookie's expiry date to be further into the future)*.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4252/comments",
    "author": "harryjamesuk",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2020-04-24T20:18:43Z",
        "body": "Hm, I'm not sure I'm understanding what you're saying. Can you provide an example reproduction? I just tried it out in Chrome and `res.clearCookie` cleared it just fine, but perhaps I am misunderstanding the report. An example app that demonstrates the issue would help a lot so we know what is being called with what values."
      },
      {
        "user": "harryjamesuk",
        "created_at": "2020-04-24T20:21:05Z",
        "body": "> Hm, I'm not sure I'm understanding what you're saying. Can you provide an example reproduction? I just tried it out in Chrome and `res.clearCookie` cleared it just fine, but perhaps I am misunderstanding the report. An example app that demonstrates the issue would help a lot so we know what is being called with what values.\r\n\r\nAn example would be\r\n```javascript\r\nres.cookie(\"example\", \"value\", {maxAge: 600000});\r\nres.clearCookie(\"example\", {maxAge: 600000});\r\n```\r\n\r\nIn this case, the cookie `example` would not be cleared.\r\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2020-04-24T20:22:02Z",
        "body": "Ah.. So that is currently intentional, and would be a breaking change to fix. There is another thread this was discussed in, as folks are currently abusing this \"feature\" to clear the value of the cookie (vs just delete the cookie)."
      },
      {
        "user": "dougwilson",
        "created_at": "2020-04-24T20:23:28Z",
        "body": "Basically the `res.clearCookie` API will delete the cookie _unless_ you provide a `maxAge` or an `expires`, in which case it only clears the _value_ of the cookie. This is as designed currently."
      },
      {
        "user": "dougwilson",
        "created_at": "2020-04-24T20:26:22Z",
        "body": "Looking at the `res.clearCookie` docs on the site, it is very minimal documentation not explaining how it works, so I can understand the confusion. Our docs has been the number 1 under-maintained thing, as finding good documentation writers is difficult. We will get the documentation updated to properly explain the API."
      },
      {
        "user": "dougwilson",
        "created_at": "2020-04-24T20:33:22Z",
        "body": "> but providing expires will also expire the cookie to Thu, 01 Jan 1970 00:00:00 GMT rather than the user supplied expires\r\n\r\nHm, that is strange. I tried that out and that is not the behavior I'm seeing. But, perhaps I'm not understanding what you mean. Can you provide code that reproduces that issue? A user-supplied `expires` to `res.clearCookie` should be what is used in the final `Set-Cookie` header (unless `maxAge` is also provided, in which case `maxAge` takes precedence)."
      },
      {
        "user": "harryjamesuk",
        "created_at": "2020-04-24T20:33:55Z",
        "body": "> > but providing expires will also expire the cookie to Thu, 01 Jan 1970 00:00:00 GMT rather than the user supplied expires\r\n> \r\n> Hm, that is strange. I tried that out and that is not the behavior I'm seeing. But, perhaps I'm not understanding what you mean. Can you provide code that reproduces that issue? A user-supplied `expires` to `res.clearCookie` should be what is used in the final `Set-Cookie` header (unless `maxAge` is also provided, in which case `maxAge` takes precedence).\r\n\r\nNevermind! You got there too quick! That does actually work as expected and makes sense now! Silly me confused the expected and actual results the wrong way round!"
      },
      {
        "user": "dougwilson",
        "created_at": "2020-04-24T20:35:28Z",
        "body": "Gotcha. Yea, it could work in various different ways, but the worse part here is that our docs are definately lacking in explaining how these APIs work 😭 . I opened a ticket on our website to get them better from this conversation at least."
      }
    ]
  },
  {
    "number": 4233,
    "title": "get undefined use express with readline",
    "created_at": "2020-04-06T05:10:05Z",
    "closed_at": "2020-04-06T07:00:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4233",
    "body": "```\r\n         // my express server code  \r\n\t const fs = require('fs');\r\n\t const readline = require('readline');\r\n\r\n\t async getLog(req, res) {\r\n\t  const _this = this;\r\n\t  try {\r\n\t\tconst { createReadStream } = fs;\r\n\t\tconst log = '/opt/example.log';\r\n\t\tconst readStream = createReadStream(log);\r\n\t\tconst rl = readline.createInterface(readStream, res);\r\n\t\trl.on(\"close\", () => {\r\n\t\t  console.log(\"end\");\r\n\t\t  readStream.close();\r\n\t\t  res.end();\r\n\t\t});\r\n\t  } catch (e) {\r\n\t\tconsole.error(e);\r\n\t\tres.json({\r\n                   code:2,\r\n                });\r\n\t  }\r\n\t}\r\n```\r\n\r\n```\r\n   // my browser code\r\n   fetch(getLog)\r\n    .then(async response => {\r\n      const reader = response.body.getReader();\r\n      do {\r\n        let { done, value } = await reader.read();\r\n        console.log(value);   //I got undefined here\r\n        if (done) {\r\n          break;\r\n        }\r\n      } while (true);\r\n    })\r\n    .catch(e => {\r\n      console.error(e);\r\n    });\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4233/comments",
    "author": "assmdx",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2020-04-06T07:00:04Z",
        "body": "Hey @assmdx, I am not sure you have an issue with express here.  Nothing you are doing in this example uses express, so I would go ahead and try to do this same with the base `http` package from core.  My guess is that it is something to do with the `readline` package, but I have not used it.  If you find that you cannot reproduce this error with the core `http` package and again think it is an express issue, please write a more complete example and repopen."
      }
    ]
  },
  {
    "number": 4226,
    "title": "How to add custom method to Expressjs Response",
    "created_at": "2020-03-24T15:28:22Z",
    "closed_at": "2020-03-24T15:34:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4226",
    "body": "I need add custom method called content to use later in Response Middleware\r\nExample : in my router\r\n```\r\n//router\r\nrouter.get('/user', this.get);\r\n.....\r\npublic get = (req: Request, res: Response, next: NextFunction) => {\r\n    res.status(201).content({ name: 'My name'});// i need custom method content here\r\n    next();\r\n  };\r\n```\r\n\r\nand in Response Middleware\r\n```\r\nexport default function ResponseMiddleware(\r\n  req: Request,\r\n  res: Response,\r\n  next: NextFunction\r\n) {\r\n  res.status(200).json({\r\n    apiVersion: '1.0',\r\n    status: true,\r\n    data: res.content // get content object here\r\n  })\r\n}\r\n\r\n```\r\n\r\nis it possible ?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4226/comments",
    "author": "duongkhoangiam",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2020-03-24T15:34:45Z",
        "body": "You can define custom methods for your app like the following (sorry not in TypeScript; I'm not familiar with it enough):\r\n```js\r\napp.response.content = function (obj) {\r\n  // implement your content method here\r\n}\r\n```\r\n\r\nYour example as-is cannot work, as you cannot have `res.content` be both a property and a method. You could make it a method that when called without args gives you the set content if you like:\r\n```js\r\napp.response.content = function (content) {\r\n  if (arguments.length === 0) {\r\n    return this._content\r\n  } else {\r\n    this._content = content\r\n    return this\r\n  }\r\n}\r\n```\r\n\r\nI hope this helps!"
      },
      {
        "user": "duongkhoangiam",
        "created_at": "2020-03-24T15:37:08Z",
        "body": "@dougwilson Thanks for you quick response. can you convert it to typescript ? because i am got error ```Property 'content' does not exist on type 'Response'```"
      },
      {
        "user": "dougwilson",
        "created_at": "2020-03-24T15:38:23Z",
        "body": "> can you convert it to typescript ?\r\n\r\n> sorry not in TypeScript; I'm not familiar with it enough"
      },
      {
        "user": "duongkhoangiam",
        "created_at": "2020-03-24T15:39:20Z",
        "body": "Ok thanks you."
      }
    ]
  },
  {
    "number": 4220,
    "title": "Response time 25ms or 15s",
    "created_at": "2020-03-17T12:58:49Z",
    "closed_at": "2020-03-19T12:35:37Z",
    "labels": [
      "question",
      "awaiting more info"
    ],
    "url": "https://github.com/expressjs/express/issues/4220",
    "body": "I usage :\r\nNuxt js v 2.10.2\r\nexpressjs v 4.17.1\r\nNodeJS v13.9.0\r\n\r\nIn the production version, I found unexpected behavior; any API request works up to 300 ms. But sometimes (one of 30 of any requests) takes 10-15 seconds. I thought there was not enough memory, but there were no errors at all. Any ideas ?\r\nI checked the time with such a function : \r\n  `const app = express()`\r\n  `app.use('/',function(req,res,next){`\r\n   ` let date1 = +(new Date())`\r\n    `res.on('finish',()=>{`\r\n     ` let time  = +(new Date())-date1`\r\n     ` if(time>1000)console.error( \"Any text\")}`\r\n   ` })`\r\n    `next()`\r\n ` })`\r\n`.........\r\n`\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4220/comments",
    "author": "Bogdah9",
    "comments": [
      {
        "user": "jonchurch",
        "created_at": "2020-03-17T21:30:26Z",
        "body": "Can you provide a minimal reproduction that demonstrates the behavior? Without seeing your code I can't tell what is happening that could cause this."
      }
    ]
  },
  {
    "number": 4198,
    "title": "does express support async and await?",
    "created_at": "2020-02-25T10:14:35Z",
    "closed_at": "2020-02-25T14:09:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4198",
    "body": "dose express support async and await for next function?\r\n\r\nthis is my code:\r\n\r\n```\r\nconst express = require('express');\r\nconst app = express();\r\n\r\nasync function sleep(timeout) {\r\n    return new Promise((resolve) => {\r\n        setTimeout(resolve, timeout);\r\n    });\r\n}\r\n\r\napp.use(async (req, res, next) => {\r\n    await sleep(100);\r\n    console.log(\"router prefix\");\r\n    await sleep(100);\r\n    await next();\r\n    await sleep(100);\r\n    console.log(\"router post\");\r\n    await sleep(100);\r\n});\r\n\r\napp.use(async (req, res, next) => {\r\n    await sleep(100);\r\n    console.log(\"log prefix\");\r\n    await sleep(100);\r\n    await next();\r\n    await sleep(100);\r\n    console.log(\"log post\");\r\n    await sleep(100);\r\n});\r\n\r\napp.get('/', async (req, res) => {\r\n    await sleep(100);\r\n    console.log(\"process prefix\");\r\n    await sleep(100);\r\n    res.send({});\r\n    await sleep(100);\r\n    console.log(\"process post\");\r\n    await sleep(100);\r\n});\r\n\r\napp.listen(3000, function () {\r\n    console.log('Example app listening on port 3000!');\r\n});\r\n```\r\nthe output is that:\r\n```\r\nrouter prefix\r\nlog prefix\r\nrouter post\r\nprocess prefix\r\nlog post\r\nprocess post\r\n```\r\nrather than : \r\n```\r\nrouter prefix\r\nlog prefix\r\nprocess prefix\r\nprocess post\r\nlog post\r\nrouter post\r\n```\r\n\r\nis it a bug, or something wrong with my code?\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4198/comments",
    "author": "phantom9999",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2020-02-25T14:09:21Z",
        "body": "Your example is how the Koa web framework works. The next() function in Express does not return a promise."
      },
      {
        "user": "richardscarrott",
        "created_at": "2020-05-08T08:24:00Z",
        "body": "Purely out of interest, what is the reason v5 doesn’t return a promise from ‘next’, are there technical / performance challenges or is it simply a design decision?"
      }
    ]
  },
  {
    "number": 4178,
    "title": "Proper way to extend Request object in Typescript",
    "created_at": "2020-02-07T22:21:38Z",
    "closed_at": "2020-02-07T22:34:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4178",
    "body": "**Question:** Hello, what is the correct way to extend the Request object and add a new property?\r\n\r\nStackoverflow is flooded with options that didn't work to me.\r\n\r\nI need it to have a different name, it can't be Request.\r\n\r\n**Suggestion:** Where is it documented? Shouldn't it be more explicit?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4178/comments",
    "author": "victorsferreira",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2020-02-07T22:34:22Z",
        "body": "We do not manage any typescript here, as this is just javascript. Not sure what the answer would be, but that hopefully answers why it is not documented. "
      }
    ]
  },
  {
    "number": 4147,
    "title": "check if express already listening to a port",
    "created_at": "2020-01-02T16:16:28Z",
    "closed_at": "2020-01-02T16:19:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4147",
    "body": "```\r\nif(!app.listining()){\r\n  app.listen(..)\r\n}\r\n```\r\nwhat is the equivalent to app.listening() or maybe app.address()\r\n\r\nnote that both `app.listening()` and `app.address` don't actually exist in express.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4147/comments",
    "author": "its-dibo",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2020-01-02T16:19:01Z",
        "body": "The `app.listen()` returns the server instance created. That result has those methods on it :+1: "
      },
      {
        "user": "dougwilson",
        "created_at": "2020-01-02T16:19:56Z",
        "body": "```js\r\nserver = app.listen()\r\nconsole.log(server.address())\r\n```"
      },
      {
        "user": "wesleytodd",
        "created_at": "2020-01-02T16:22:33Z",
        "body": "Also to clear up: how would you have the app instance know if another node process which is running the same code is listening.  That seems to me to be the only reason you would write the example code.  If you need that you would just have to try to open on multiple ports or use port `0` which will allow the kernel to assign a random port.  If you did the `0` method you could then use `server.address()` like @dougwilson shows to get the port.  It is common to use this method when using a service discovery layer, then you just report the ip and port to that after starting the server."
      },
      {
        "user": "its-dibo",
        "created_at": "2020-01-02T18:35:56Z",
        "body": "this method forces you to make the express listen again to the same port,\r\nwhat I mean is to only make express to listen to the port only if it didn't before.\r\n\r\nfor example when running `node server.js` serveral times."
      },
      {
        "user": "dougwilson",
        "created_at": "2020-01-02T18:44:23Z",
        "body": "Afaik this is a limitation of node.js : it does not provide any method between processes to know if the other is already listening. You would have to try to listen again and assume a failure means it is already listening.\r\n\r\nExpress.js itself is not the actual HTTP server that listens on the port. Instead it just delegates that the the node.js http server and is limited to what is possible with that server.\r\n\r\nYou can think of your question if your server.js was the following code:\r\n\r\n```js\r\nrequire('http').createServer((req,res)=>res.end()).listen(3000)\r\n```"
      },
      {
        "user": "wesleytodd",
        "created_at": "2020-01-02T18:48:57Z",
        "body": "> You would have to try to listen again and assume a failure means it is already listening.\r\n\r\nYes, this is what I meant when I said \"another node process which is running the same code is listening\".  @eng-dibo, this is the same as \"when running `node server.js` serveral times\".  With the code Doug posted your second run of `node server.js` will crash with an `EADDR` type error saying the port is already in use.  You can handel the error and close gracefully if you want.\r\n"
      }
    ]
  },
  {
    "number": 4116,
    "title": "Undocumented request.headers show cookie property present, but request cookies and signedCookies are undefined",
    "created_at": "2019-12-05T14:51:06Z",
    "closed_at": "2019-12-05T14:52:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4116",
    "body": "Basically issue described in title",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4116/comments",
    "author": "jeserkin",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-12-05T14:52:50Z",
        "body": "If you are saying that your cookie is not in req.cookies or req.signedCookies , there isn't much this module can do to fix that. Express itself does not populate those properties at all.\r\n\r\nIf you are looking just for general help, please stop by our Gitter."
      }
    ]
  },
  {
    "number": 4101,
    "title": "debug vs morgan",
    "created_at": "2019-11-14T04:04:18Z",
    "closed_at": "2019-11-15T21:36:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4101",
    "body": "is there difference with this two?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4101/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2019-11-14T18:11:06Z",
        "body": "Yep, one is for debug logging, the other is for request logging.  IMO, you should probably use neither and go for `pino`.  If you are publishing a package and want to use `debug`, it is a very popular option, but it is not really suited for application logging."
      }
    ]
  },
  {
    "number": 4100,
    "title": "dumb question",
    "created_at": "2019-11-14T04:02:39Z",
    "closed_at": "2019-11-14T17:45:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4100",
    "body": "hello, I have a dumb question. and sorry if I wasted your time. can you use `npm install -g express-generator` for production? if not, can you recommend a link where I could read best practices on how to setup an express? please 🙏 and thank you so much ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4100/comments",
    "author": "artoodeeto",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2019-11-14T17:01:44Z",
        "body": "Hi @artoodeeto, no question is a dumb question.  You can use the generator for production apps.  It might be a bit out of date as far as JavaScript common practices, and I have started work on a new/updated generator, but have been busy and unable to finish the work.  In the mean time, there is nothing wrong with using the generator as a great starting place."
      },
      {
        "user": "artoodeeto",
        "created_at": "2019-11-14T17:45:15Z",
        "body": "cool thanks. I appreciate the reply. Ill just create a server from scratch if its not recommended. thank you again sir. #blessed"
      }
    ]
  },
  {
    "number": 4094,
    "title": "[Feature]dynamic set and delete route",
    "created_at": "2019-11-03T14:36:24Z",
    "closed_at": "2019-11-05T23:16:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4094",
    "body": "When running a application, I set some routes like this:\r\n```js\r\n[some arrays].forEach(route => {\r\n   app.post(route.path, (req, res) => {\r\n       //...\r\n   })\r\n})\r\n```\r\nwhen I change a route's path in that array, new route is available, \r\n**but old route is available too.**\r\n\r\nhow to let the old routes invalidate.\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4094/comments",
    "author": "kybetter",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2019-11-05T23:16:25Z",
        "body": "Hi @kybetter, a better approach to this would be to create a new router which you mount like this:\r\n\r\n```javascript\r\nlet router\r\nfunction updateRoutes () {\r\n  router = new express.Router()\r\n  [some arrays].forEach(route => {\r\n     router.post(route.path, (req, res) => {\r\n         //...\r\n     })\r\n  })\r\n}\r\n\r\nsetTimeout(updateRoutes, ...)\r\n\r\napp.use((req, res, next) => {\r\n  router.handle(req, res, next)\r\n})\r\n```\r\n\r\nMake sense?"
      },
      {
        "user": "kybetter",
        "created_at": "2019-11-06T02:36:27Z",
        "body": "Thanks a lot, it works fine. ^_^"
      },
      {
        "user": "wmasfoe",
        "created_at": "2022-01-07T03:02:30Z",
        "body": "hello @wesleytodd \r\nI also encountered the same problem. I have a variable `routerName`. I want to change it in the code, and the name of the route will be updated dynamically.\r\nMy code is like this:\r\n\r\n```js\r\nlet routerNames = ['/test']\r\nlet realRouter\r\n\r\nfunction updateRouter () {\r\n  realRouter = new express.Router()\r\n  routerNames.forEach(routerName => {\r\n    realRouter.all(routerName, (req, res) => {\r\n      res.send('routerName === ' + routerNames)\r\n    })\r\n  })\r\n}\r\n\r\nsetTimeout(updateRouter, 300)\r\n\r\napp.use((req, res, next) => {\r\n  realRouter.handle(req, res, next)\r\n})\r\n\r\napp.all('/changeName', (req, res) => {\r\n  routerNames[0] += 's' // change routerName\r\n  res.send('new name === ' + routerNames)\r\n})\r\n```\r\n\r\nWhen I try to access `/changeName` to change the value of routername, the variable changes, the route does not change, and `/test` takes effect `/tests` does not take effect.\r\n\r\nHelp me 😭😭😭"
      }
    ]
  },
  {
    "number": 4088,
    "title": "Unable to send data in res.json?",
    "created_at": "2019-10-28T09:32:02Z",
    "closed_at": "2019-10-28T23:25:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4088",
    "body": "my data.js has following\r\n```\r\nconst date = {\r\n  lastDate: '27-1-2019',\r\n};\r\nexport {\r\n  date,\r\n};\r\n```\r\ni just want to import the above file in my mock.js file and send the object in res.json()\r\n\r\nmy mock.js has\r\n```\r\nconst mock = require('../mocks/data.js');\r\nconst projectedDate=mock.date;\r\nmodule.exports = (app) => {\r\napp.post('/test', (req, res) => {\r\n    res.json( projectedDate );\r\n  });\r\n}\r\n```\r\ni was getting following error\r\n```\r\n{\"error\":{},\"level\":\"error\",\"message\":\"uncaughtException: Unexpected token export\\n\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4088/comments",
    "author": "dileep524",
    "comments": [
      {
        "user": "dileep524",
        "created_at": "2019-10-28T09:35:42Z",
        "body": "server will throw above error when i try to import any file before module.exports. so how can i import the file and use the data inside module.exports\r\n"
      },
      {
        "user": "wesleytodd",
        "created_at": "2019-10-28T23:25:09Z",
        "body": "Hey @dileep524, the `export` keyword is not supported natively in node.  You are getting a syntax error as a result.  Change it to `module.exports = { date }` and you should be good."
      }
    ]
  },
  {
    "number": 4074,
    "title": "I'm curious about the build matrix on express and related packages",
    "created_at": "2019-10-08T13:45:20Z",
    "closed_at": "2019-10-08T14:24:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4074",
    "body": "Why to keep all the Node.js versions on travis.yml ?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4074/comments",
    "author": "helio-frota",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-10-08T14:24:54Z",
        "body": "They are the versions that this versions of Express supports is all. Older versions are typically the most important to test on CI since typically folks are not working with those versions who are also making pull requests. It's a mechanism to catch issues we may not catch locally. "
      }
    ]
  },
  {
    "number": 4073,
    "title": "Can't Retrieve Module Version",
    "created_at": "2019-10-06T00:17:44Z",
    "closed_at": "2019-10-06T00:19:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4073",
    "body": "I may be approaching this from the wrong angle, but the following code that I use at the beginning of an application I am working on prints that the express version is `undefined`:\r\n```javascript\r\nconst express = require('express')\r\nlogger.info(`Using express v${express.version}`)\r\n```\r\n\r\nIs there no such thing as `express.version`? I am fairly new to NodeJS and am most likely doing this wrong.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4073/comments",
    "author": "sykeben",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-10-06T00:19:37Z",
        "body": "All Node.js packages actually the same, which is the following to get the version:\r\n```js\r\nlogger.info(`Using express v${require('express/package').version}`)\r\n```"
      }
    ]
  },
  {
    "number": 4067,
    "title": "Express converting date object to ISO String by default when returning response",
    "created_at": "2019-10-01T06:44:00Z",
    "closed_at": "2019-10-01T16:13:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4067",
    "body": "I am having a simple customer model. I have created an endpoint for creating a customer and returning the created customer. I wrote a test class using supertest for testing the model.\r\nFollowing is the code from relevant files.\r\n\r\n```\r\n//customer.model.js\r\nconst customerSchema = new mongoose.Schema({\r\n    \"fullName\":{\r\n        type:String,\r\n        requried:true\r\n    },\r\n    'startDate\":{\r\n        type:Date,\r\n        required:true\r\n    },\r\n    \"endDate\":{\r\n        type:Date,\r\n        required:true\r\n    }\r\n});\r\n```\r\n```\r\n//customer.api.js\r\n\r\nrouter.post(\"/customer\",auth([\"ROLE_ADMIN\"]),async (req,res)=>{\r\n    try{\r\n        const customer = await CustomerService().add(req.body)\r\n        console.log(\"customer.endDate\",customer.endDate instanceof Date) //true\r\n        return res.status(200).send({customer});\r\n    }catch(e){\r\n        console.log(\"exception\",e);\r\n        return res.status(503).send({});\r\n    }\r\n})\r\n```\r\n\r\n```\r\n//customer.test.js\r\ndescribe(\"Customer\",()=>{\r\n    test(\"should add a user\",async()=>{\r\n        //login\r\n        const response = await request(app).post('/login').send(\r\n            {\r\n                email: 'testadmin@example.com',\r\n                password: 'MyPass777!',\r\n            }\r\n        ).expect(200);\r\n\r\n\r\n        const customer = await request(app).post(\"/customer\")\r\n        .set(\"Cookie\",response.headers['set-cookie'])\r\n        .send(_customer)\r\n        .expect(200);\r\n        expect(customer.body.customer.fullName).toBe(_customer.fullName);\r\n        expect(customer.body.customer.endDate).toBe(_customer.endDate.toISOString()); //I am getting customer.body.customer.endDate as an ISO string here\r\n        expect(customer.body.customer.startDate).toBe(_customer.startDate.toISOString());\r\n        expect(customer.body.customer.phone).toBe(_customer.phone);\r\n    })\r\n})\r\n```\r\nI am not able to understand why the express router seems to send Date in response in ISO format.\r\n\r\nKindly help out.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4067/comments",
    "author": "AshayTikekar",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2019-10-01T16:13:32Z",
        "body": "Hey @AshayTikekar, this is not express doing anything here.  My educated guess when you call `JSON.stringify` (which is what is behind `res.send` with an object or `res.json`), it calls `.toString()`, which outputs ISO formatted date string.\r\n\r\nIf you want different behavior you would want to override the date object's `toString`."
      }
    ]
  },
  {
    "number": 4041,
    "title": "Using Express to serve Gatsby files",
    "created_at": "2019-08-30T20:58:03Z",
    "closed_at": "2019-08-30T21:41:33Z",
    "labels": [
      "question",
      "module:express-static"
    ],
    "url": "https://github.com/expressjs/express/issues/4041",
    "body": "I have an application using Gatsby and Express. Right now, Gatsby generates files to the \"public\" folder and I use express.static() to dynamically serve the files. The issue is that Gatsby generates the HTML files to public/[name]/index.html but Express only checks for the index.html at a path if the URL has a trailing slash. So if you go to 'www.site.com/about' it'll flash a 404 page, so instead, you have to go to 'www.site.com/about/'.\r\n\r\nIn the past, I've tried forcing a trailing slash on each individual page (code below). This worked for a time and still does for most pages. However, for pages generated with gatsby-node, it does not let me force a trailing slash and still flashes a 404.\r\n\r\n```js\r\n  if (isPage(pathname)) {\r\n    return res.redirect(301, pathname + '/' + (search || ''))\r\n  }\r\n```\r\n\r\nIt would be great if I could create some sort of middleware for express.static that checks for and index.html at /about or maybe an entirely different way to approach this.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4041/comments",
    "author": "alexpreiss",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-08-30T21:01:23Z",
        "body": "Hi, sorry you're having trouble. The `express.static` I believe will check for `index.html` based on a file stat on the resolved path, regardless of if it ends in a trailing slash (though it does have default behavior to redirect paths without a trailing slash to one with a tailing slash). Perhaps it would help if you could provide the complete code and instructions on how to reproduce the issue you are experiencing? That would help us be able to diagnose what is going wrong with your use-case 👍 "
      },
      {
        "user": "dougwilson",
        "created_at": "2019-08-30T21:04:49Z",
        "body": "Also be sure to be careful about relative paths if you're going to get it working without the trailing slash, though: if you have, say, `<img src=foo.png>` on the page, loading as `www.site.com/about` would try to fetch `www.site.com/foo.png`, while loading as `www.site.com/about/` would try to fetch `www.site.com/about/foo.png`."
      },
      {
        "user": "alexpreiss",
        "created_at": "2019-08-30T21:41:33Z",
        "body": "Thanks for your quick response!\r\nI actually found the issue while trying to create a reproduction :P\r\n\r\n```js\r\napp.use(\r\n  express.static(path.join(__dirname, 'public'), {\r\n    maxAge: 864000000, // 10 days in milliseconds\r\n    redirect: false,\r\n    setHeaders: (res, path) => {\r\n      // Enable cors for ArticulatCF font\r\n      // It's loaded by Stripe in an iframe on a different domain\r\n      if (path.includes('ArticulatCF')) {\r\n        res.setHeader('Access-Control-Allow-Origin', '*')\r\n      }\r\n    }\r\n  })\r\n)\r\n```\r\n\r\nThe issue was the 'redirect: false'"
      }
    ]
  },
  {
    "number": 4029,
    "title": "How can i add (register) a route before ?",
    "created_at": "2019-08-19T20:11:31Z",
    "closed_at": "2019-08-19T20:22:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4029",
    "body": "i have some routes that i register with app.get(...), at the end i add a route like app.register(app, '*', ..) then i will dynamically add some rows again at runtime, but when i do this, i got * at the default route (cuz * comes before ..)\r\n\r\nso how can i register the route before?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4029/comments",
    "author": "w3hr",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2019-08-19T20:22:42Z",
        "body": "Best way to do dynamic routing is to manage a router instance:\r\n\r\n```javascript\r\nconst app = express()\r\n\r\napp.use((req, res, next) => {\r\n  const router = new express.Router()\r\n\r\n  // Build your dynamic routes here\r\n  router.get('/foo' ...)\r\n\r\n  router.handle(req, res, next)\r\n})\r\n```\r\n\r\nBe careful because this can be a performance bottleneck, and might be difficult to debug, but the code works.  Also, this methodology will not do all of the things express does for you when you mount a router, so depending on the features you need (like `baseUrl` and `url` being managed for you) your mileage may vary."
      }
    ]
  },
  {
    "number": 4023,
    "title": " Can I use express-session and cookie-session together?",
    "created_at": "2019-08-02T08:38:20Z",
    "closed_at": "2020-04-23T02:43:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4023",
    "body": "I need to save some important data on the server and some data is not important on the browser cookie, can I use 2 modules together?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4023/comments",
    "author": "matamune94",
    "comments": [
      {
        "user": "knoxcard",
        "created_at": "2019-09-02T19:23:14Z",
        "body": "I'd think that would be a bad idea juggling two different session instances.  Security and organizational nightmare.  Is there any particular reason why this would be necessary?"
      },
      {
        "user": "Sushmeet",
        "created_at": "2020-04-23T02:38:06Z",
        "body": "@matamune94 would you have any further reasoning behind your question. Perhaps a use case or what you might be trying to achieve?"
      },
      {
        "user": "dougwilson",
        "created_at": "2020-04-23T02:43:11Z",
        "body": "Hey @matamune94 since there wasn't a follow up on the first request for more information, I'm going to close this, but if you do provide more information we can re-open 👍 "
      }
    ]
  },
  {
    "number": 4016,
    "title": "problem about css class name same as HTML filename",
    "created_at": "2019-07-22T10:25:31Z",
    "closed_at": "2019-07-22T20:49:39Z",
    "labels": [
      "invalid",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4016",
    "body": "Apologies if this has been already requested.\r\nI get a strange problem when I use a css class whose name is same as the HTML file.Like blow:\r\nin my `style.css` I have:\r\n```css\r\n.warn{ color:red;}\r\n```\r\nin my html file named `warn.html` I have:\r\n```html\r\n<link rel=\"stylesheet\" href=\"/css/style.css\" type=\"text/css\">\r\n...//other code\r\n<div class=\"warn\">warning</div>\r\n```\r\nthen in express' `app.js` I have:\r\n```javascript\r\napp.use(express.static('public');\r\n...//other code\r\napp.get('/', (req, res) \r\n    =>res.sendFile('warn.html', {root:path_of_file})\r\n);\r\n```\r\nother things are all right but the `<div>` above doesn't display.\r\nthen F12 in firefox I find the `<div>` exist and click it you can see it has the property of the css class `.warn` .\r\nthe localhost test without express is also fine, it only happens when run with express on a remote linux service.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4016/comments",
    "author": "hikigaya58",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2019-07-22T20:49:39Z",
        "body": "Hi @hikigaya58, Express doesn't do anything other than serve your file.  Any styling issues you have once it is in the browser are not Express issues.  Maybe try posting on Stack Overflow."
      }
    ]
  },
  {
    "number": 4008,
    "title": "Express.js app issues",
    "created_at": "2019-07-12T18:40:29Z",
    "closed_at": "2019-07-18T01:36:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4008",
    "body": "Hello everyone. I'm working on my express app and keep getting the following error and I was wondering if someone could help me see what the problem is.\r\n```\r\nError: Failed to lookup view \"index\" in views directory \"C:\\Users\\AlphaLy\\Desktop\\SMU-coding-bootcamp\\work\\homework-done\\14th-homework\\Burger2\\Eat-Da-Burger-Week-14-\\views\"\r\n    at Function.render (C:\\Users\\AlphaLy\\Desktop\\SMU-coding-bootcamp\\work\\homework-done\\14th-homework\\Burger2\\Eat-Da-Burger-Week-14-\\node_modules\\express\\lib\\application.js:580:17)\r\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- etc ...\r\n```\r\nbelow are my files related to the problem:\r\nfolder tree:\r\n```\r\nCONFIG\r\n     connection.js\r\n     orms.js\r\nCONTROLLERS\r\n     router.js\r\nMODELS\r\n   burger.js\r\nVIEWS\r\n    index.handlebars\r\n    main.handlebars\r\n```\r\n\r\nSERVER.JS:\r\n```js\r\nvar express = require(\"express\");\r\nvar path = require('path');\r\nvar bodyParser = require(\"body-parser\");\r\nvar methodOverride = require('method-override');\r\nvar PORT = process.env.PORT || 8081;\r\n\r\nvar app = express();\r\n\r\n// serve static content for the app and set up body-parser\r\napp.use(express.static(__dirname+'/public'));\r\napp.use(bodyParser.urlencoded({\r\n  extended: false\r\n}));\r\napp.use(bodyParser.json());\r\napp.use(methodOverride('_method'));\r\n\r\n// set up Handlebars\r\nvar exphbs = require(\"express-handlebars\");\r\napp.engine(\"handlebars\", exphbs({\r\n  defaultLayout: \"main\"\r\n}));\r\n\r\n// app.set('views', path.join(__dirname, 'views'));\r\napp.set(\"view engine\", \"handlebars\");\r\n\r\n// Import routes and give the server access to them\r\nvar routes = require(\"./controllers/routes.js\");\r\napp.use('/',routes);\r\n\r\n// start the server listening\r\napp.listen(PORT, function() {\r\n  console.log(\"App now listening at localhost:\" + PORT);\r\n});\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4008/comments",
    "author": "Leealp",
    "comments": [
      {
        "user": "Chopinsky",
        "created_at": "2019-07-12T20:04:44Z",
        "body": "This should probably be asked on StackOverflow or to your tutor, and I bet the root cause is simply a misunderstanding between \"absolute folder path\" vs. \"static folder path\" vs. \"relative folder path\"."
      },
      {
        "user": "ponkys",
        "created_at": "2019-07-15T13:25:04Z",
        "body": "The VIEWS folder is written in caps. That's why it doesn't find 'views',uncomment and change here `// app.set('views', path.join(__dirname, 'views'));` to`// app.set('views', path.join(__dirname, 'VIEWS'));`"
      },
      {
        "user": "wesleytodd",
        "created_at": "2019-07-18T01:36:08Z",
        "body": "Both @Chopinsky and @ponkys are correct, this kind of question is best asked on Stack Overflow, and if your views directory is uppercase, specifying it in lowercase will result in a view not found error."
      }
    ]
  },
  {
    "number": 4003,
    "title": "The route /^\\/(hello|world|).*/ doesn't work",
    "created_at": "2019-07-06T15:29:26Z",
    "closed_at": "2019-07-07T01:11:19Z",
    "labels": [
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/4003",
    "body": "Hello.\r\n\r\n**YES**: /hello/bob/22\r\n```js\r\napp.use('/hello', website);\r\napp.use('/world', website);\r\napp.use('/', website);\r\n\r\nwebsite.get('/:name/:ids', function (req, res, next) {\r\n    console.log(req.params);  //=> { name: 'bob', ids: '22'}\r\n}\r\n```\r\n\r\n**NOT**: /hello/bob/22\r\n```js\r\napp.use(/^\\/(hello|world|).*$/, website);\r\n\r\nwebsite.get('/:name/:ids', function (req, res, next) {\r\n    console.log(req.params); //=> { name: undefined, ids: undefined }\r\n}\r\n```\r\n\r\nHow to make the second version of REGEXP?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4003/comments",
    "author": "extensionsapp",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-07-07T01:11:19Z",
        "body": "Hi @extensionsapp , the argument to the `app.use` is the mount path. The reason your second example does not work as you expect is because the mouth path has `.*` at the end, which makes the entire URL the mount path and your `website` will see every request as the URL `/` since the entire URL was considered the mount path since the regexp matches the entire URL.\r\n\r\nTo use a regular expression that matches the first example, it would be the following:\r\n\r\n```js\r\napp.use(/^\\/(?:hello|world)?/, website);\r\n```"
      },
      {
        "user": "extensionsapp",
        "created_at": "2019-07-19T00:44:58Z",
        "body": "@dougwilson Thanks for the reply, but something code does not work as it should.\r\n\r\n```js\r\napp.use(/^\\/(?:hello|world)?/, website);\r\n```\r\n\r\n**Status code 404**: `/hello/bob/22`\r\n**Status code 200**: `/world/bob/22`\r\n**Status code 404**: `/bob/22`"
      }
    ]
  },
  {
    "number": 3998,
    "title": "OPTIONS request doesn't follow the order of route declaration",
    "created_at": "2019-07-02T06:15:04Z",
    "closed_at": "2019-07-02T06:20:00Z",
    "labels": [
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/3998",
    "body": "I just notice that an OPTIONS request doesn't follow the order of route declaration and applies for all the routes that are defined using the same instance. \r\nI am not sure if it's bug or an intended behaviour since I don't fully understand the nature of OPTIONS request.\r\n\r\nHere are 2 code snippets\r\n\r\n```js\r\nconst app = require('express')();\r\n\r\napp.use((req, res, next) => {\r\n  res.send('Blocked');\r\n});\r\n\r\napp.get('/route1', (req, res) => {\r\n  res.send('route1');\r\n});\r\n\r\napp.get('/route2', (req, res) => {\r\n  res.send('route2')\r\n});\r\n\r\napp.listen(3000, () => {\r\n  console.log('Server started on port: 3000');\r\n});\r\n```\r\n\r\n```js\r\nconst app = require('express')();\r\n\r\napp.get('/route1', (req, res) => {\r\n  res.send('route1');\r\n});\r\n\r\napp.use((req, res, next) => {\r\n  res.send('Blocked');\r\n});\r\n\r\napp.get('/route2', (req, res) => {\r\n  res.send('route2')\r\n});\r\n\r\napp.listen(3000, () => {\r\n  console.log('Server started on port: 3000');\r\n});\r\n```\r\n\r\nIn first case, both GET and OPTIONS request to any of the 2 routes returns the message \"blocked\" as expected since the middleware is defined prior to both and hence any request to either of these will first pass through it.\r\n\r\nIn second case, both GET and OPTIONS request to the second route return the message \"blocked\". Again as expected.  But for the first route, the GET request return the message \"route1\" while the OPTIONS request returns the message \"Blocked\". \r\n\r\nWhy did the GET request was successfully served but the OPTIONS request first passed through the middleware that was defined after that route?\r\n\r\nI'm using v4.17.1",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3998/comments",
    "author": "abhishekjain2604",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-07-02T06:20:00Z",
        "body": "The reason is that the default OPTIONS handling only comes into play if the request reached the end of your declarations and never encountered anything that handled it. Since in your second example the .use handled the OPTIONS request (by not calling next()) the default handling was never invoked.\r\n\r\nYou can think of it in that the OPTIONS auto response is not an aspect of your app.get (i.e. it does not respond at the moment of the app.get declaration for the named route) and is instead an alternative of the 404 response (i.e. only runs if no other route handled the OPTIONS request).\r\n\r\nI hope that helps explain the behavior."
      },
      {
        "user": "abhishekjain2604",
        "created_at": "2019-07-02T07:43:14Z",
        "body": "@dougwilson Yeah that explains the behaviour quite well. Thanks a lot."
      }
    ]
  },
  {
    "number": 3996,
    "title": "Npm Err!  package.json must be actual JSON, not just JavaScript.",
    "created_at": "2019-06-30T05:21:09Z",
    "closed_at": "2020-01-17T18:25:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3996",
    "body": "I've been tryna fix this for a while, but I can't seem to figure it out. Considering I'm new to coding it may be an easy fix and I'm just not quite sure about what I'm doing'\r\n\r\n\r\n0 info it worked if it ends with ok\r\n1 verbose cli [\r\n1 verbose cli   'C:\\\\Program Files\\\\nodejs\\\\node.exe',\r\n1 verbose cli   'C:\\\\Program Files\\\\nodejs\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js',\r\n1 verbose cli   'install',\r\n1 verbose cli   'discord.io',\r\n1 verbose cli   'winston',\r\n1 verbose cli   '-save'\r\n1 verbose cli ]\r\n2 info using npm@6.9.0\r\n3 info using node@v12.5.0\r\n4 verbose npm-session 39d5088f2ca6dfd0\r\n5 silly install loadCurrentTree\r\n6 silly install readLocalPackageData\r\n7 timing stage:rollbackFailedOptional Completed in 3ms\r\n8 timing stage:runTopLevelLifecycles Completed in 28ms\r\n9 verbose stack Error: Failed to parse json\r\n9 verbose stack Unexpected token n in JSON at position 7 while parsing near '{\r\n9 verbose stack     name: “Blotch”\r\n9 verbose stack     ...'\r\n9 verbose stack     at parseError (C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\read-package-json\\read-json.js:452:11)\r\n9 verbose stack     at parseJson (C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\read-package-json\\read-json.js:104:26)\r\n9 verbose stack     at C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\read-package-json\\read-json.js:51:5\r\n9 verbose stack     at C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\graceful-fs\\graceful-fs.js:90:16\r\n9 verbose stack     at FSReqCallback.readFileAfterClose [as oncomplete] (internal/fs/read_file_context.js:61:3)\r\n10 verbose cwd C:\\Users\\Thornstrider Studios\\Desktop\\Discordbot\r\n11 verbose Windows_NT 10.0.17134\r\n12 verbose argv \"C:\\\\Program Files\\\\nodejs\\\\node.exe\" \"C:\\\\Program Files\\\\nodejs\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\" \"install\" \"discord.io\" \"winston\" \"-save\"\r\n13 verbose node v12.5.0\r\n14 verbose npm  v6.9.0\r\n15 error file C:\\Users\\Thornstrider Studios\\Desktop\\Discordbot\\package.json\r\n16 error code EJSONPARSE\r\n17 error JSON.parse Failed to parse json\r\n17 error JSON.parse Unexpected token n in JSON at position 7 while parsing near '{\r\n17 error JSON.parse     name: “Blotch”\r\n17 error JSON.parse     ...'\r\n18 error JSON.parse Failed to parse package.json data.\r\n18 error JSON.parse package.json must be actual JSON, not just JavaScript.\r\n19 verbose exit [ 1, true ]\r\n\r\n\r\nThis is what package.json says;\r\n\r\n{\r\n    name: “Blotch”,\r\n    version: “1.0.0”,\r\n    main: “bot.js”,\r\n    author: “Marsh”,\r\n    dependencies: {\r\n}\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3996/comments",
    "author": "Sunriselegacy",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2019-07-01T19:09:21Z",
        "body": "Hi @Sunriselegacy, the `package.json` you posted there is not valid json.  Object keys in json must be quoted, and you have an incomplete block, the correct file would be:\r\n\r\n```json\r\n{\r\n\"name\": \"Blotch\",\r\n\"version\": \"1.0.0\",\r\n\"main\": \"bot.js\",\r\n\"author\": \"Marsh\",\r\n\"dependencies\": { }\r\n}\r\n```\r\n\r\nI would also add that a better way to create a `package.json` file is with `$ npm init`.  There is a default one which creates a bare bones `package.json` file, but you can use the package `create-package-json` if you want more options and better defaults.  For example: `$ npm init package-json`.\r\n\r\nDisclaimer: I wrote and maintain `create-package-json`, sorry for the self promotion :)\r\n\r\nAlso, good luck learning to code, it is fun and worth the energy!"
      },
      {
        "user": "HarshithaKP",
        "created_at": "2019-12-23T09:55:00Z",
        "body": "@Sunriselegacy Is this still an issue for you ?"
      },
      {
        "user": "jonchurch",
        "created_at": "2020-01-17T18:25:06Z",
        "body": "Closing as resolved and doesn't seem to be an express issue.\r\n\r\nIf you need more help feel free to comment again."
      }
    ]
  },
  {
    "number": 3995,
    "title": "How to print request objects?",
    "created_at": "2019-06-28T16:09:31Z",
    "closed_at": "2019-07-03T05:42:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3995",
    "body": "`JSON.stringify()` complains that incoming HTTP request objects present infinite loops. How should we print requests out for debugging purposes?\r\n\r\nFairly sure this is happening with Express.js, but could be coming from the NPM request library as well.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3995/comments",
    "author": "mcandre",
    "comments": [
      {
        "user": "r0mflip",
        "created_at": "2019-06-28T17:22:34Z",
        "body": "The request and response objects are circular, just try to log them via `console.log(req)` for debugging purposes. The circular parts will be redacted."
      },
      {
        "user": "dougwilson",
        "created_at": "2019-07-03T05:42:06Z",
        "body": "Hi @mcandre yes, `JSON.stringify` isn't really the best for seeing what an object in JavaScript looks like; it is a serialization format which does not support the richness of JavaScript itself, so even if it works, you'll be missing a lot of information.\r\n\r\nUsing `console.log(req)` as above will print it to your console even with the circular reference. Another method is to use a debugger program like Visual Studio Code (what I use) and then use the tool to explore the object as you like, which lets you expand sub objects as needed.\r\n\r\nI hope this helps!"
      }
    ]
  },
  {
    "number": 3982,
    "title": "Content-Type value is converted to lowercase",
    "created_at": "2019-06-16T13:14:35Z",
    "closed_at": "2019-06-16T14:31:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3982",
    "body": "Hi,\r\nI have an issue when i set the content-type with res.set('Content-Type', 'UPPERCASE-CONTENT-TYPE');. The response I receive is then written in lower case: 'uppercase-content-type'.\r\n\r\nIs there a way to set the value without it being written in lower case?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3982/comments",
    "author": "Madayano",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-06-16T14:31:29Z",
        "body": "You can use the \"raw version of the API:\r\n\r\n    res.setHeader('Content-Type', 'UPPERCASE-CONTENT-TYPE');"
      },
      {
        "user": "Madayano",
        "created_at": "2019-06-17T07:36:54Z",
        "body": "I also tried res.setHeader('Content-Type', 'UPPERCASE-CONTENT-TYPE');, but the content type in the  generated responses was still written in lower case."
      }
    ]
  },
  {
    "number": 3980,
    "title": "Client Cannot GET /xxx.html before accessing main ",
    "created_at": "2019-06-11T02:37:33Z",
    "closed_at": "2019-06-11T11:29:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3980",
    "body": "I have the following server side code:\r\n\r\n```\r\nvar app = express();\r\napp.get('/', function (req, res) {\r\n\tres.redirect('/main');\r\n});\r\napp.get('/main', function (req, res) {\r\n\tvar d = new Date();\r\n\tres.sendFile(path.join(__dirname + '/main.html'));\r\n\tInfo(req.ip + ' - Session to main.html built successfully! ');\r\n\tapp.use(express.static(__dirname));\r\n});\r\n```\r\n\r\nAlso there are some other html files in the same directory, e.g. xxx.html.  \r\nI found the following behavior that confuses, if I build a new session, try to access localhost:7778/xxx.html, the client cannot get: Cannot GET /xxx.html:\r\n\r\n```\r\nFailed to load resource: the server responded with a status of 404 (Not Found)\r\n```\r\n\r\nOn the other hand, after accessed localhost:7778/, and then try to access localhost:7778/xxx.html, will succeed.\r\n\r\nCan anyone explain the behavior? Can I set the localhost/xxx.html be able to directly accessed?\r\n\r\nThanks a lot!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3980/comments",
    "author": "ctlkkc",
    "comments": [
      {
        "user": "r0mflip",
        "created_at": "2019-06-11T03:24:40Z",
        "body": "Your `app.use(express.static(__dirname));` shouldn't be in the route handler."
      },
      {
        "user": "ctlkkc",
        "created_at": "2019-06-11T11:29:27Z",
        "body": "Thanks, the answer solved the issue. "
      }
    ]
  },
  {
    "number": 3975,
    "title": "Cannot PUT",
    "created_at": "2019-06-03T19:53:36Z",
    "closed_at": "2019-06-04T00:04:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3975",
    "body": "Hello!\r\n\r\nI have PUT request: /ap/route/{\"id\": \"64\", \"method\":\"GET\", \"path\" :\"'/abc\"}\r\n( I also tried POST)\r\nAnd got error: \"Cannot PUT ...\"\r\n\r\nIf I set the parameter \"path\" to blank or without a slash - hve no error. So problem in \"/\". If i try \"path\": \"\\/\" got same error.\r\n\r\nIs this error in express? How I can set \"path\" with slashes?\r\n\r\nExpress version: 4.17.0\r\nNodeJs: 8.10.0",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3975/comments",
    "author": "dcromster",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2019-06-04T00:04:23Z",
        "body": "Hi @dcromster, am I to understand that you are hoping to have json encoded into the url path?  If so you will need to properly encode it with `encode​URIComponent`."
      }
    ]
  },
  {
    "number": 3970,
    "title": "ERR_SPDY_PROTOCOL_ERROR when using custom error handler",
    "created_at": "2019-05-28T14:40:48Z",
    "closed_at": "2019-05-28T14:44:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3970",
    "body": "A few weeks ago I refactored my application to use a custom error handler instead of handling errors in the routes.\r\n\r\nI added this below all my routers.\r\n```\r\napp.use(function(err,req,res,next) {\r\n    console.log(err)\r\n    if (res.headersSent === false) {\r\n        res.sendStatus(400)\r\n    }\r\n   next(err)\r\n})\r\n```\r\n\r\nIt allows me to use next(err) in my routes and if a response hasn't been sent yet, return a 400 status code.\r\n\r\n```\r\napp.post(\"/do-something\", function(req,res,next) {\r\n\r\n    doSomething.test().then(() => {\r\n        return res.sendStatus(200)\r\n    }).catch((err) => {\r\n        return next(err)\r\n    })\r\n\r\n })\r\n```\r\n\r\nThis all worked great when I initially tested it and is currently working in production.  However I am getting some odd behavior in development now.\r\n\r\nAnytime that custom error handler is used I get a `net::ERR_SPDY_PROTOCOL_ERROR 400`  in the chrome console with an empty response (empty response breaks my app).\r\n\r\nHowever, sending a 400 status code within the route itself works fine.\r\n\r\n```\r\napp.post(\"/do-something\", function(req,res,next) {\r\n\r\n    doSomething.test().then(() => {\r\n        return res.sendStatus(200)\r\n    }).catch((err) => {\r\n        return res.sendStatus(400)\r\n    })\r\n\r\n })\r\n```\r\n\r\nRemoving the next(err) from the custom error handler also fixes the problem. \r\n\r\n```\r\napp.use(function(err,req,res,next) {\r\n    console.log(err)\r\n    if (res.headersSent === false) {\r\n        res.sendStatus(400)\r\n    }\r\n})\r\n```\r\n\r\nI can't find much info on what could be causing this.... I have tried on 2 different machines.  Please let me know if more details are needed. I am happy to add the response from chrome, etc. \r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3970/comments",
    "author": "tbell511",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-05-28T14:43:46Z",
        "body": "Most likely the issue is that you are calling `next()` even though you sent a response. Just like in normal middleware, only call `next()` if you didn't respond. Your top example should probably be written as such:\r\n```js\r\napp.use(function(err,req,res,next) {\r\n    console.log(err)\r\n    if (res.headersSent === false) {\r\n        res.sendStatus(400)\r\n    } else {\r\n        next(err)\r\n    }\r\n})\r\n```"
      }
    ]
  },
  {
    "number": 3962,
    "title": "trust-proxy function not called?",
    "created_at": "2019-05-17T09:36:34Z",
    "closed_at": "2019-05-17T19:52:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3962",
    "body": "My Express server is running in a docker container with an nginx docker container proxying request to it.\r\n\r\n```\r\nRequest -> (nginx) -> (express)\r\n```\r\n\r\nI've been trying to set up Express so it only trusts the one nginx proxy, but so far I've not been able to get the `trust-proxy` setting to work.\r\nThe function I pass to the `trust-proxy` setting seems to never get called in my application.\r\n\r\n```ts\r\napp.set('trust proxy', (ip: string) => {\r\n    console.error(`PROXY ADDR: ${ip}`);\r\n    return false;\r\n});\r\n```\r\nWith this configuration, the `console.error` never appears in the logs.\r\n\r\nAm I doing something wrong here with my configuration, or is `trust proxy` not working as intended?\r\n\r\nMinimal reproduction:\r\n```ts\r\nconst app = express();\r\n\r\napp.set('trust proxy', (ip: string) => {\r\n    console.error(`PROXY ADDR: ${ip}`);\r\n    return false;\r\n});\r\n\r\napp.use('*', (_req: express.Request, res: express.Response) => {\r\n    return res.send('Hi');\r\n});\r\n\r\nconst webServer = createServer(app);\r\nwebServer.listen(3731);\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3962/comments",
    "author": "Ionaru",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-05-17T13:59:41Z",
        "body": "Hi @Ionaru . The trust proxy function is called when trust of addresses needs to be established. In your example, there is no code that needs to know anything about the upstream, so for optimization reasons, it will not get invoked.\r\n\r\nIf you add something like `req.ip`, `req.hostname` etc to your example, your function should then get called, as Express tries to determine the address."
      },
      {
        "user": "Ionaru",
        "created_at": "2019-05-17T19:52:03Z",
        "body": "Ah, I see. My bad."
      }
    ]
  },
  {
    "number": 3957,
    "title": "Routing Issue",
    "created_at": "2019-05-15T02:18:52Z",
    "closed_at": "2019-05-15T02:27:59Z",
    "labels": [
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/3957",
    "body": "Hello,\r\n\r\nI've been using the Router function for a bit now and have an endpoint that does two different functions, one gets the current user /users/me and one gets a user that is searched /users/:id, sadly these endpoints conflict for some reason, can someone please help me in finding a solution? These endpoints are BOTH in the same file.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3957/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-05-15T02:21:22Z",
        "body": "There are two main solutions:\r\n\r\n1. Since the router matches in the strict order in which they are declared, just declare the more specific route first (the `/users/me` router).\r\n2. If the `:id` parameter is only certain characters, like just digits, you can restrict that route to only those characters like `/users/:id([0-9]+)`"
      },
      {
        "user": "ghost",
        "created_at": "2019-05-15T02:22:40Z",
        "body": "@dougwilson call me blind but is there a way in express to route it (2nd way) with just numbers?"
      },
      {
        "user": "dougwilson",
        "created_at": "2019-05-15T02:24:29Z",
        "body": "I'm sorry, I'm not sure I understand your question. What do you mean by to route it with just numbers?"
      },
      {
        "user": "ghost",
        "created_at": "2019-05-15T02:25:34Z",
        "body": "Sorry, I didn't write that quite correctly, this /users/:id is only numbers, does express offer a way to lockdown the endpoint to only numbers?"
      },
      {
        "user": "dougwilson",
        "created_at": "2019-05-15T02:27:05Z",
        "body": "If I'm understanding correctly: `/users/:id([0-9]+)`"
      },
      {
        "user": "ghost",
        "created_at": "2019-05-15T02:27:59Z",
        "body": "@dougwilson Yes, that answers my question, thank you so much!"
      }
    ]
  },
  {
    "number": 3931,
    "title": "TypeError: Converting circular structure to JSON",
    "created_at": "2019-04-11T10:58:48Z",
    "closed_at": "2019-04-11T11:12:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3931",
    "body": "Hi, i'm getting this bug/error wich originates from ~\\express\\lib\\response.js:1119\r\n```\r\n> \r\nC:\\Users\\SENSORED\\ApeCrawler\\node_modules\\express\\lib\\response.js:1119\r\n    : JSON.stringify(value);\r\n           ^\r\n\r\nTypeError: Converting circular structure to JSON\r\n    at JSON.stringify (<anonymous>)\r\n    at stringify (C:\\Users\\SENSORED\\ApeCrawler\\node_modules\\express\\lib\\response.js:1119:12)\r\n    at ServerResponse.json (C:\\Users\\SENSORED\\ApeCrawler\\node_modules\\express\\lib\\response.js:260:14)\r\n    at ape_body (C:\\Users\\SENSORED\\ApeCrawler\\routes\\scrapper2.js:15:17)\r\n    at Request.request.get [as _callback] (C:\\Users\\SENSORED\\ApeCrawler\\routes\\scrapper2.js:44:20)\r\n    at self.callback (C:\\Users\\SENSORED\\ApeCrawler\\node_modules\\request\\request.js:185:22)\r\n    at Request.emit (events.js:189:13)\r\n    at Request.onRequestError (C:\\Users\\SENSORED\\ApeCrawler\\node_modules\\request\\request.js:881:8)\r\n    at ClientRequest.emit (events.js:189:13)\r\n    at TLSSocket.socketErrorListener (_http_client.js:399:9)\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3931/comments",
    "author": "jnyheim",
    "comments": [
      {
        "user": "LinusU",
        "created_at": "2019-04-11T11:00:55Z",
        "body": "The problem is probably that you are passing a circular structure to `res.json(...)`\r\n\r\nThe solution is to sort out your data, JSON has no way of representing circular structures...\r\n\r\nHope this helps ☺️ "
      },
      {
        "user": "jnyheim",
        "created_at": "2019-04-11T11:07:53Z",
        "body": "Yes, i found my issue after further analysis. The fault/issue was on my side, two lines of code was in the wrong order.  It is now fixed and working. 😄 \r\n\r\nThis issue may now be closed.\r\n\r\n-jn"
      },
      {
        "user": "vijayasai0021",
        "created_at": "2024-09-14T18:07:45Z",
        "body": "can you please help  how did you figure  it out even i'm having the same issue\r\n"
      }
    ]
  },
  {
    "number": 3922,
    "title": "what's the difference between --view=pug and --pug?",
    "created_at": "2019-04-04T23:40:25Z",
    "closed_at": "2019-04-04T23:45:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3922",
    "body": "express version: 4.16.4\r\nInit a project with generator, what's the difference between --view=pug and --pug?\r\n```\r\nexpress --view=pug myapp\r\nexpress --pug myapp\r\nexpress --view=pug --pug myapp\r\n```\r\nIs there any difference?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3922/comments",
    "author": "bi-kai",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-04-04T23:45:59Z",
        "body": "They are the same, with `--pug` being a short hand."
      }
    ]
  },
  {
    "number": 3918,
    "title": "response.js line 749 typo",
    "created_at": "2019-03-28T19:28:42Z",
    "closed_at": "2019-03-28T19:30:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3918",
    "body": "Line 749 in response.js has \r\n`res.set =`\r\nand nothing else. I'm assuming this is a typo?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3918/comments",
    "author": "AnsonSavage",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-03-28T19:30:30Z",
        "body": "No, it is not a typo. You can see if that if you delete that line and run `npm test` where the test suite fails if you're interested in what is provides 👍 "
      }
    ]
  },
  {
    "number": 3915,
    "title": "Trying to create a discord bot",
    "created_at": "2019-03-23T11:48:40Z",
    "closed_at": "2019-04-17T22:25:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3915",
    "body": "Hey so I tried to create a discord bot lately, when I tried to install the packages it gave me this issue\r\n```\r\nC:\\Users\\User-PC\\Desktop\\Bot>npm install discord.io winston -save.\r\nnpm ERR! file C:\\Users\\User-PC\\Desktop\\Bot\\package.json\r\nnpm ERR! code EJSONPARSE\r\nnpm ERR! JSON.parse Failed to parse json\r\nnpm ERR! JSON.parse Unexpected token � in JSON at position 3 while parsing near '{\r\nnpm ERR! JSON.parse �name�: �greeter-bot...'\r\nnpm ERR! JSON.parse Failed to parse package.json data.\r\nnpm ERR! JSON.parse package.json must be actual JSON, not just JavaScript.\r\n\r\nnpm ERR! A complete log of this run can be found in:\r\nnpm ERR!     C:\\Users\\User-PC\\AppData\\Roaming\\npm-cache\\_logs\\2019-03-23T11_40_15_695Z-debug.log\r\n```\r\nHere is my package.json file\r\n```\r\n{\r\n“name”: “greeter-bot”,\r\n“version”: “1”,\r\n“description”: “Sobby can do all sorts fo stuff!”,\r\n“main”: “bot.js”,\r\n“author”: “Laycrab TTV”,\r\n“dependencies”: {}\r\n}\r\n```\r\nThank you for your help",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3915/comments",
    "author": "darksoulsforever4",
    "comments": [
      {
        "user": "deevendhu",
        "created_at": "2019-03-24T14:58:18Z",
        "body": "Try the below in your package.json\r\n```\r\n{\r\n\"name\": \"greeter-bot\",\r\n\"version\": \"1\",\r\n\"description\": \"Sobby can do all sorts fo stuff!\",\r\n\"main\": \"bot.js\",\r\n\"author\": \"Laycrab TTV\",\r\n\"dependencies\": {}\r\n}\r\n```"
      },
      {
        "user": "callumok2004",
        "created_at": "2019-04-06T17:29:25Z",
        "body": "Make sure to be using correct quotations! ( \"\" ) "
      }
    ]
  },
  {
    "number": 3910,
    "title": "req.subdomain??",
    "created_at": "2019-03-18T23:25:35Z",
    "closed_at": "2019-03-18T23:27:21Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3910",
    "body": "There is a req.subdomains but not a req.subdomain?? What on earth??",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3910/comments",
    "author": "knoxcard",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-03-18T23:27:21Z",
        "body": "That's correct."
      },
      {
        "user": "imjamesb",
        "created_at": "2019-03-19T14:44:03Z",
        "body": "If you want `req.subdomain` just run `req.subdomains.joIn(\".\")`."
      }
    ]
  },
  {
    "number": 3895,
    "title": "Expressjs crashes every often with Exit status 1",
    "created_at": "2019-02-24T15:26:32Z",
    "closed_at": "2019-03-01T23:48:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3895",
    "body": "Hi Guys,\r\n        please find the debug log below and the package.json\r\n\r\n{\r\n  \"name\": \"webstore\",\r\n  \"version\": \"0.0.0\",\r\n  \"private\": true,\r\n  \"scripts\": {\r\n    \"start\": \"node ./bin/www\"\r\n  },\r\n  \"dependencies\": {\r\n    \"debug\": \"~2.6.9\",\r\n    \"express\": \"~4.16.4\",\r\n    \"hbs\": \"~4.0.1\",\r\n    \"helmet\": \"~3.15.1\",\r\n    \"http-errors\": \"~1.6.3\",\r\n    \"morgan\": \"~1.9.0\"\r\n  }\r\n}\r\n\r\nand got the below error\r\n\r\n0 info it worked if it ends with ok\r\n1 verbose cli [ '/usr/bin/node', '/usr/bin/npm', 'start' ]\r\n2 info using npm@6.4.1\r\n3 info using node@v10.13.0\r\n4 verbose run-script [ 'prestart', 'start', 'poststart' ]\r\n5 info lifecycle webstore@0.0.0~prestart: webstore@0.0.0\r\n6 info lifecycle webstore@0.0.0~start: webstore@0.0.0\r\n7 verbose lifecycle webstore@0.0.0~start: unsafe-perm in lifecycle true\r\n8 verbose lifecycle webstore@0.0.0~start: PATH: /usr/lib/node_modules/npm/node_modules/npm-lifecycle/node-gyp-bin:/tee3apps/oinos/webstore/node_modules/.bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games\r\n9 verbose lifecycle webstore@0.0.0~start: CWD: /tee3apps/oinos/webstore\r\n10 silly lifecycle webstore@0.0.0~start: Args: [ '-c', 'node ./bin/www' ]\r\n11 silly lifecycle webstore@0.0.0~start: Returned: code: 1  signal: null\r\n12 info lifecycle webstore@0.0.0~start: Failed to exec start script\r\n13 verbose stack Error: webstore@0.0.0 start: `node ./bin/www`\r\n13 verbose stack Exit status 1\r\n13 verbose stack     at EventEmitter.<anonymous> (/usr/lib/node_modules/npm/node_modules/npm-lifecycle/index.js:301:16)\r\n13 verbose stack     at EventEmitter.emit (events.js:182:13)\r\n13 verbose stack     at ChildProcess.<anonymous> (/usr/lib/node_modules/npm/node_modules/npm-lifecycle/lib/spawn.js:55:14)\r\n13 verbose stack     at ChildProcess.emit (events.js:182:13)\r\n13 verbose stack     at maybeClose (internal/child_process.js:962:16)\r\n13 verbose stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:251:5)\r\n14 verbose pkgid webstore@0.0.0\r\n15 verbose cwd /tee3apps/oinos/webstore\r\n16 verbose Linux 4.15.13-x86_64-linode106\r\n17 verbose argv \"/usr/bin/node\" \"/usr/bin/npm\" \"start\"\r\n18 verbose node v10.13.0\r\n19 verbose npm  v6.4.1\r\n20 error code ELIFECYCLE\r\n21 error errno 1\r\n22 error webstore@0.0.0 start: `node ./bin/www`\r\n22 error Exit status 1\r\n23 error Failed at the webstore@0.0.0 start script.\r\n23 error This is probably not a problem with npm. There is likely additional logging output above.\r\n24 verbose exit [ 1, true ]\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3895/comments",
    "author": "mkharibalaji",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2019-03-01T23:48:28Z",
        "body": "Hi @mkharibalaji, it is hard to say, but without more to go on there is not much we can do to help.  Either way it doesn't seem like an issue with express since nothing in the output mentions express."
      }
    ]
  },
  {
    "number": 3890,
    "title": "How to render mySQL Data using Express and EJS",
    "created_at": "2019-02-22T20:16:32Z",
    "closed_at": "2019-02-23T01:10:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3890",
    "body": "Hi I can't figure out how to display my mySQL data on an HTML page. Right now I am using Express, mySQL, and EJS as my template engine. My project is to create a Jeopardy web application. I have my mySQL database called Jeopardy set up with themes, categories, and questions tables. I want to use Express (Node.js) to read in all the data. Then I want to send that data to the ejs file to render HTML. I want to display all my table data on the html page. Can someone help me?\r\n\r\nHere is my current error. When I go to localhost:3000 this same error pops up in the webpage and the console. I don't know why this is happening. I used res.render() to define obj as a variable for the ejs file to use but it's not recognizing it. Is there anything else you guys think I should fix? I am using all these languages/frameworks for the first time so I've very inexperienced.\r\n```\r\nReferenceError: /Users/Ruthvik/Downloads/Jeopardy/views/index.ejs:7\r\n    5|   </head>\r\n    6|   <body>\r\n >> 7|     <h1><%= obj %></h1>\r\n    8|     <p>Welcome to <%= obj %></p>\r\n    9|   </body>\r\n    10| </html>\r\n\r\nobj is not defined\r\n    at eval (eval at compile (/Users/Ruthvik/Downloads/Jeopardy/node_modules/ejs/lib/ejs.js:592:12), <anonymous>:11:26)\r\n    at returnedFn (/Users/Ruthvik/Downloads/Jeopardy/node_modules/ejs/lib/ejs.js:623:17)\r\n    at tryHandleCache (/Users/Ruthvik/Downloads/Jeopardy/node_modules/ejs/lib/ejs.js:251:36)\r\n    at View.exports.renderFile [as engine] (/Users/Ruthvik/Downloads/Jeopardy/node_modules/ejs/lib/ejs.js:480:10)\r\n    at View.render (/Users/Ruthvik/Downloads/Jeopardy/node_modules/express/lib/view.js:135:8)\r\n    at tryRender (/Users/Ruthvik/Downloads/Jeopardy/node_modules/express/lib/application.js:640:10)\r\n    at Function.render (/Users/Ruthvik/Downloads/Jeopardy/node_modules/express/lib/application.js:592:3)\r\n    at ServerResponse.render (/Users/Ruthvik/Downloads/Jeopardy/node_modules/express/lib/response.js:1008:7)\r\n    at Query.<anonymous> (/Users/Ruthvik/Downloads/Jeopardy/server.js:26:21)\r\n    at Query.<anonymous> (/Users/Ruthvik/node_modules/mysql/lib/Connection.js:502:10)\r\n```\r\n\r\n\r\nserver.js\r\n```\r\nconst express = require('express');\r\nconst app = express();\r\nconst mysql = require('mysql');\r\n\r\nvar con = mysql.createConnection({\r\n    host: \"localhost\",\r\n    user: \"root\",\r\n    password: \"Federer5\",\r\n    database: \"Jeopardy\"\r\n});\r\n\r\napp.engine('html', require('ejs').renderFile);\r\napp.set('view engine', 'ejs');\r\n\r\nvar obj = {};\r\napp.get('/', function(req, res) {\r\n    con.connect(function (err) {\r\n        if (err) throw err;\r\n        console.log(\"Connected\");\r\n        var sql = \"SELECT * FROM questions\";\r\n        con.query(sql, function (err, result) {\r\n            if (err) {\r\n                throw err;\r\n            } else {\r\n                obj = {print: result};\r\n                res.render('index', obj);\r\n            }\r\n        });\r\n    });\r\n});\r\n\r\napp.listen(3000, function () {\r\n    console.log('listening on port', 3000);\r\n});\r\n```\r\n\r\nindex.ejs\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <link rel='stylesheet' href='/stylesheets/style.css' />\r\n  </head>\r\n  <body>\r\n    <h1><%= obj %></h1>\r\n    <p>Welcome to <%= obj %></p>\r\n  </body>\r\n</html>\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3890/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-02-23T01:07:53Z",
        "body": "Hi @ruthvikkonda , so in the `ejs` template, it's expecting a value named `obj`. I see you have a `obj` in your JS code, but you end up passing it to `res.render` without a name. Try the following instead:\r\n\r\n```js\r\nres.render('index', {obj: obj});\r\n```"
      },
      {
        "user": "ghost",
        "created_at": "2019-02-23T01:10:47Z",
        "body": "that worked! Thank you so much I appreciate it."
      },
      {
        "user": "antoine6191",
        "created_at": "2020-12-15T12:59:10Z",
        "body": "someone to explain how access to join data in the template with ejs? like <%= product.idcategorie.name %>\r\ni include categorie in controller query, i have the data that i want in the variable but impossible to access in the template\r\nthank"
      },
      {
        "user": "JoysonPeter006",
        "created_at": "2022-01-17T11:28:50Z",
        "body": "> Hi @ruthvikkonda , so in the `ejs` template, it's expecting a value named `obj`. I see you have a `obj` in your JS code, but you end up passing it to `res.render` without a name. Try the following instead:\r\n> \r\n> ```js\r\n> res.render('index', {obj: obj});\r\n> ```Even after giving like above my ejs file when displayed doesnt show values from database instead only showing object object. Why is it so?\r\n\r\n"
      },
      {
        "user": "shreyashuddar29",
        "created_at": "2024-04-18T15:11:14Z",
        "body": "> > Hi @ruthvikkonda , so in the `ejs` template, it's expecting a value named `obj`. I see you have a `obj` in your JS code, but you end up passing it to `res.render` without a name. Try the following instead:\r\n> > ```js\r\n> > res.render('index', {obj: obj});\r\n> > ```Even after giving like above my ejs file when displayed doesnt show values from database instead only showing object object. Why is it so?\r\n> > ```\r\n\r\nSame here!! "
      },
      {
        "user": "shreyashuddar29",
        "created_at": "2024-04-18T15:11:45Z",
        "body": "What is the solution for that ?"
      }
    ]
  },
  {
    "number": 3889,
    "title": "Routing by Variable",
    "created_at": "2019-02-22T16:58:02Z",
    "closed_at": "2019-02-23T08:52:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3889",
    "body": "I have the fear it's a totally basic-question. But I got stuck at this point ..  :(\r\n\r\nMy usecase:\r\n\r\nThe root-website is running as a \"show-room\", where no input is possible (it is presenteds to the public on multiple screens). The \"show-room\" asks periodically via ajax for data. \r\n\r\nNo it should be possible to switch from another client (with another website, e.g. /setup) the routing to another view and also give some additional information to it. Beside the ajax-transfer I also have already the POST-Datas in the index.js\r\n\r\nOne more time: The root-page shows \" website A\" and over another website I can tell the server, that it should show \"website B\". The Reload could be managed by Javascript/AJAX.\r\n\r\nMy thought was just changing the Routing, but that does not work. Yes, indeed, I did not understand all the mechanism.... ;)\r\n\r\nMy first try in index.js:\r\n```js\r\n// ...\r\napp.get('/', view01.view01Action);\r\n// ...\r\n\r\n// Getting the form-datas    \r\napp.post('/setuppost', function(req, res) {\r\n        res.render('./../setup01/views/setup.handlebars');\r\n        \r\n// Reacting to the form-datas\r\n        if(req.body.selectedView=='view05'){\r\n            app.get('/', view05.view05Action);\r\n            (... handlebars-helpers and so on...)\r\n        }\r\n```\r\n\r\nCould anybody please tell me, how to solve my usecase? THX a lot!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3889/comments",
    "author": "alcero",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-02-23T01:12:17Z",
        "body": "Hi @alcero welcome! There are various ways to achieve what you're trying to do.\r\n\r\nBased on your current example above, what I would do is just save the view action function in a variable, add a handler that calls that variable, and then have your post just swap out that variable. Here is your example changed to do just that:\r\n```js\r\n// ...\r\nvar viewAction = view01.view01Action\r\n// ...\r\napp.get('/', (req, res, next) => viewAction(req, res, next));\r\n// ...\r\n\r\n// Getting the form-datas    \r\napp.post('/setuppost', function(req, res) {\r\n        res.render('./../setup01/views/setup.handlebars');\r\n        \r\n// Reacting to the form-datas\r\n        if(req.body.selectedView=='view05'){\r\n            viewAction = view05.view05Action;\r\n            (... handlebars-helpers and so on...)\r\n        }\r\n```"
      },
      {
        "user": "alcero",
        "created_at": "2019-02-23T08:52:18Z",
        "body": "Hi @dougwilson \r\nTHANK YOU! It simply works :)\r\nSaving a function to a variable ... I didn't had the idea that may work ... thank you!\r\n"
      }
    ]
  },
  {
    "number": 3885,
    "title": "Roles and permissions access control ",
    "created_at": "2019-02-17T13:40:20Z",
    "closed_at": "2019-02-17T17:04:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3885",
    "body": "Hi sir\r\nI would like to know about roles and permissions in node express js\r\nCan u give me the reference to about that... \r\nFor example\r\nI have 3 deferent roles \r\n1.admin(can create and he can do anything) \r\n2 Interviewer(can create interviews and access his resources) \r\n3 candidate(he will register through registration form while registering him in website he has to get role candidate and he only able attend interviews and applying) \r\nHow can I do this\r\n\r\nThanks in advance sie",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3885/comments",
    "author": "Jagadhissh",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2019-02-17T17:04:07Z",
        "body": "Hi @Jagadhissh.  This is not really the best place to receive this kind of support.  Express provides no access control mechanism out of the box.  You will have to bring your own solution for this.  Maybe try posting your question in the [Express Gitter](gitter.im/expressjs/express) or on Stack Overflow.  Good luck!"
      },
      {
        "user": "Jagadhissh",
        "created_at": "2019-02-17T17:17:47Z",
        "body": "Then what I need to use... Sir\r\n\r\nDo u have any reference \r\nOr else can I continue with sails. Js"
      },
      {
        "user": "wesleytodd",
        "created_at": "2019-02-17T17:21:18Z",
        "body": "There are many options, it depends on your requirements.  A few googles should turn up results, but if you are using a framework like Sails then it sounds like you already have your solution :)"
      },
      {
        "user": "Jagadhissh",
        "created_at": "2019-02-17T17:25:21Z",
        "body": "Did u got my question..\r\nI have 2 types of persons.. They can have two different of data with deferent roles... How can I go through this using express or else do I need to continue on sails"
      },
      {
        "user": "Jagadhissh",
        "created_at": "2019-02-17T17:25:53Z",
        "body": "Is Sails.js better than express "
      },
      {
        "user": "dougwilson",
        "created_at": "2019-02-17T17:29:07Z",
        "body": "Sails.js _is_ express with everything added on for you. If Sails.js works better for you because they already added auth etc. to express then it sounds like the better choice. Using express directly is so you can choose all your own things, but it sounds like you don't want to do that, and as such Sails.js sounds like it's a good fit."
      },
      {
        "user": "wesleytodd",
        "created_at": "2019-02-17T17:29:39Z",
        "body": "Hey @Jagadhissh, to avoid spam emailing some 1k people I am going to lock this issue.  Please feel free to ask for more help in the Gitter posted above or on Stack Overflow.  This issue board is for reporting problems with Express or for general Express development activities, not for support or help building applications.\r\n\r\nTo answer your question: Sails is just a more feature full framework built on top of Express.  To say \"better\" is not really the point, its just different.  Good luck with your work!\r\n\r\nEDIT: Doug I see you posted just as I was sending this.  If you disagree with my locking of the conversation feel free to undo it."
      }
    ]
  },
  {
    "number": 3882,
    "title": "app.use ignores regex",
    "created_at": "2019-02-13T05:51:13Z",
    "closed_at": "2019-04-17T22:46:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3882",
    "body": "Maybe I got `app.use`'s API wrong, but this regex doesn't work with `app.use`:\r\n```\r\napp.use(/bundle/, function (req, res, next) {\r\n  console.log('A URL containing \"bundle\" was requested.')\r\n  next()\r\n})\r\n````\r\nWhile the same regex works with `app.get`:\r\n```\r\napp.get(/bundle/, function (req, res, next) {\r\n  console.log('A URL containing \"bundle\" was requested.')\r\n  next()\r\n})\r\n```\r\nFYI, I want to match all `bundle.js` files, e.g. `0.bundle.js`, `1.bundle.js`, etc.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3882/comments",
    "author": "desmap",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-02-13T05:54:19Z",
        "body": "Hi @desmap ! This is the expected behavior -- `app.use` is for _mounting_ middleware at given paths. The matched path is expected to end with a path separator (a `/` in a URL).\r\n\r\nIf you are just looking to match any incoming request with `bundle` anywhere in the URL, then you'll want to use `app.all`, which is a route matcher.\r\n\r\nI hope this helps!"
      },
      {
        "user": "desmap",
        "created_at": "2019-02-13T06:43:26Z",
        "body": "Hi @dougwilson, thx for the quick reply. \r\n\r\nActually, I want _middleware_ which terminates the app/redirects the user if specific files are requested and the user isn't authed.\r\n\r\nGuess I still don't get the actual use case of `app.use` vs `app.all` vs `app.get`. So, what I understood is:\r\n\r\n1. With 'path' you mean path without the actual file, right? E.g. `/foo/` but not `/foo/bar.js` (which would be different than node's `path` semantics)?\r\n2. If 1 is true, I can't set up middleware against specific files?\r\n3. To match this path I need to put always an escaped slash at the end of my regex, e.g. `/foo\\//`?\r\n4. While I can match a path like `/images/logo.jpg` with `/images\\//`, I can't match an URL like `mydomain.com/privacy` (related to 1) except the user enters `mydomain,com/privacy/` (which would never happen)\r\n\r\nIs this right? Still confused, sorry to bother."
      },
      {
        "user": "dougwilson",
        "created_at": "2019-04-17T22:46:42Z",
        "body": "Sorry I lost track of this issue.\r\n\r\n(1) When I mean path, it's referring to a path in a URL concept. It is similar to a file system path, yes.\r\n(2) You can, but if you're constructing your own regexp, the match needs to end at a `/` or end of string in order for the mount to work properly. Example would be `app.use(/bundle[^\\/]*/`, ...)`. But `app.all` is the same as `app.use` as far as your example is concerned so it would result in a simpler regexp.\r\n(3) No, just either the last character matched needs to be a `/` OR the character that appears in `req.url` after your match needs to be `/`, `?`, or end of string.\r\n(4) I don't understand this question.\r\n\r\nI hope this helps! You can keep asking question here, but there isn't an issue in express to keep the issue open."
      }
    ]
  },
  {
    "number": 3880,
    "title": "Pass middleware for all routes.",
    "created_at": "2019-02-12T13:57:42Z",
    "closed_at": "2019-04-17T22:26:56Z",
    "labels": [
      "question",
      "awaiting more info"
    ],
    "url": "https://github.com/expressjs/express/issues/3880",
    "body": "Hello friends.\r\nMy first issue at express.\r\nI would like to know if possible pass an middleware for all determined routes.\r\nEx:\r\n```js\r\n'use strict';\r\n\r\nconst express = require('express');\r\nconst router = express.Router();\r\nconst middleware = require('../middleware/authMiddleware');\r\n\r\nrouter.use(middleware);\r\n\r\nrouter.get('/api/', (req, res) => {\r\n    res.send({auth: true});\r\n});\r\n\r\nmodule.exports = app => app.use('/', router);\r\n```\r\nThanks for your help!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3880/comments",
    "author": "felipewmartins",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2019-02-12T20:36:01Z",
        "body": "Hi @felipewmartins, I am not sure I understand your question.  In your example you call `.use` which is called for all routes.  Can you explain the difference between what you are doing above and what you are asking about?"
      },
      {
        "user": "felipewmartins",
        "created_at": "2019-02-13T11:21:13Z",
        "body": "Hi @wesleytodd , thanks for your reply.\r\nImproving my question. I have a middleware responsible for authentication using jwt, I would like to force all routes of my application to be authenticated by this middleware."
      },
      {
        "user": "wesleytodd",
        "created_at": "2019-02-14T22:22:54Z",
        "body": "> force all routes of my application\r\n\r\nThis is what `.use` does, it will be called for every route in your application.  If you want to force authed users all you need to do is `res.status(401)` and not call `next`.  Make sense?"
      }
    ]
  },
  {
    "number": 3879,
    "title": "Routing to multiple Angular 7 projects in Express based on JWT authentication and Role",
    "created_at": "2019-02-12T11:37:01Z",
    "closed_at": "2019-02-14T06:43:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3879",
    "body": "I have created an Angular 7 project which has multiple applications for different roles, like admin, user, editor, etc. each have different components and view.\r\n\r\nA logged in user will land on its user role application, where as any guest user will land on 'website' application which has login and signup page.\r\n\r\nMy problem is to route using express to different angular applications based on user role determined during authentication. This works with one angular application, but doesn't work with multiple angular application",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3879/comments",
    "author": "krish512",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2019-02-12T20:39:26Z",
        "body": "Hi @krish512, while I am not an expert in Angular, I think the solution you are looking for would be to redirect to different routes from your entry route:\r\n\r\n```javascript\r\napp.get('/', (req, res) => {\r\n  if (user.isAdmin) {\r\n    return res.redirect('/admin')\r\n  }\r\n  if (user.isUser) {\r\n    return res.redirect('/user')\r\n  }\r\n  res.redirect('/website')\r\n})\r\n```\r\n\r\nDoes this help solve your problem?  In this way you could serve up a different angular app on each of those routes."
      },
      {
        "user": "krish512",
        "created_at": "2019-02-13T07:11:26Z",
        "body": "In my case, I was trying to use same route to serve 2 different angular apps based on roles,\r\n\r\n\r\n```javascript\r\napp.get('/', (req, res) => {\r\n  if (user.isAdmin) {\r\n    return res.sendFile(path.join(__dirname, '../../client/dist/admin/index.html'));\r\n  }\r\n  if (user.isUser) {\r\n    return res.sendFile(path.join(__dirname, '../../client/dist/user/index.html'));\r\n  }\r\n  return res.sendFile(path.join(__dirname, '../../client/dist/website/index.html'));\r\n})\r\n```\r\n\r\nThis returns the index.html page for the angular app but also sends all related resources like js, css as html document"
      },
      {
        "user": "wesleytodd",
        "created_at": "2019-02-14T06:41:43Z",
        "body": "Well, I wouldn't personally take this approach as it makes it more complicated to debug issues because the same route serves different views.  It is easier in the long run, IMO, to have separate routes you redirect to.\r\n\r\nThat being said, there is nothing wrong with the code you posted above, that should work just fine for serving the different html files for each.  Are you sure this is an Express issue?"
      },
      {
        "user": "krish512",
        "created_at": "2019-02-14T06:43:21Z",
        "body": "Solved it, just had to rename the index.html to different role names such as below,\r\n\r\n```javascript\r\napp.get('/', (req, res) => {\r\n  if (user.isAdmin) {\r\n    return res.sendFile(path.join(__dirname, '../../client/dist/admin/admin.html'));\r\n  }\r\n  if (user.isUser) {\r\n    return res.sendFile(path.join(__dirname, '../../client/dist/user/user.html'));\r\n  }\r\n  return res.sendFile(path.join(__dirname, '../../client/dist/website/website.html'));\r\n})\r\n```"
      }
    ]
  },
  {
    "number": 3855,
    "title": "'lazyrouter' undefined",
    "created_at": "2019-01-15T00:32:07Z",
    "closed_at": "2019-01-30T23:02:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3855",
    "body": "I started a fresh project today, installing all my usual modules (`express`, `body-parser` and such). After setting everything up, as usual, I ran into this new error on node server.js`:\r\n```\r\nC:\\Users\\ThatTonybo\\Desktop\\discussion\\node_modules\\express\\lib\\application.js:214\r\n  this.lazyrouter();\r\n       ^\r\n\r\nTypeError: Cannot read property 'lazyrouter' of undefined\r\n    at use (C:\\Users\\ThatTonybo\\Desktop\\discussion\\node_modules\\express\\lib\\application.js:214:8)\r\n    at module.exports (C:\\Users\\ThatTonybo\\Desktop\\discussion\\router.js:3:5)\r\n    at Object.<anonymous> (C:\\Users\\ThatTonybo\\Desktop\\discussion\\server.js:25:20)\r\n    at Module._compile (internal/modules/cjs/loader.js:689:30)\r\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10)\r\n    at Module.load (internal/modules/cjs/loader.js:599:32)\r\n    at tryModuleLoad (internal/modules/cjs/loader.js:538:12)\r\n    at Function.Module._load (internal/modules/cjs/loader.js:530:3)\r\n    at Function.Module.runMain (internal/modules/cjs/loader.js:742:12)\r\n    at startup (internal/bootstrap/node.js:279:19)\r\n```\r\nI've done a little investigating and searching, and it seems to occur at ln 214. `  this.lazyrouter();` in `express/lib/application.js`.\r\n\r\nIs there a quick fix to this?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3855/comments",
    "author": "ThatTonybo",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2019-01-15T00:36:05Z",
        "body": "Hey @ThatTonybo, This looks like you are binding `app.use` to something other than the express app instance.  Maybe if you provide a code example we could help more?"
      },
      {
        "user": "ThatTonybo",
        "created_at": "2019-01-15T07:24:10Z",
        "body": "Not sure where I'd be binding this at all @wesleytodd, could it be due to the fact I'm using `app.use` deconstructed?\r\n```js\r\nconst { use } = app;\r\nuse('/', Router); // and so on..\r\n```"
      },
      {
        "user": "wesleytodd",
        "created_at": "2019-01-15T20:32:22Z",
        "body": "Yep that would do it.  Deconstructing changes the context.  You would either need to bind `use` to `app`, or `.call` with `app`."
      },
      {
        "user": "ChuckJonas",
        "created_at": "2023-03-07T04:08:38Z",
        "body": "Can someone explain why you cannot do this?  I'm trying to dynamically register routes & http operation using some metadata and running into this same issue..."
      }
    ]
  },
  {
    "number": 3842,
    "title": "Doesn't load style from public folder",
    "created_at": "2019-01-02T14:43:46Z",
    "closed_at": "2019-01-02T19:35:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3842",
    "body": "Hello, I have a stylesheet in the folder \"public\" named \"style.css\". I set the public page with this line of code:\r\n```js\r\napp.use(express.static(__dirname + \"/public\"));\r\n```\r\nAnd it's working fine, except for one file: `views\\wiki\\how_to_play.ejs`. I just copy pasted the file and tried, but the style won't load. I used this code in the head:\r\n```html\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\r\n```\r\nIn the same folder I have another file called `index.ejs` with the same code, and here the loading of the stylesheet works just fine.\r\n\r\nAnyone knowing why? If you need to know enything, just ask. Sorry for my bad English.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3842/comments",
    "author": "Paultje52",
    "comments": [
      {
        "user": "Paultje52",
        "created_at": "2019-01-02T16:06:05Z",
        "body": "I found the fix for the issue: First I had this:\r\n```html\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\r\n```\r\nBut, when I chanced it to this:\r\n```html\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"/style.css\">\r\n```\r\nEverything worked just fine. Anyone knows why?"
      },
      {
        "user": "wesleytodd",
        "created_at": "2019-01-02T19:35:54Z",
        "body": "Hi @Paultje52, the reason it failed to load is because `style.css` is a relative link to the current page.  By adding the leading `/` you made it absolute to the domain name.  Glad you figured it out!"
      }
    ]
  },
  {
    "number": 3837,
    "title": "Is it a bad practise to wrap an express app by a user defined object?",
    "created_at": "2018-12-27T15:43:14Z",
    "closed_at": "2019-01-03T14:53:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3837",
    "body": "Hi guys. \r\n\r\nI am implementing a middleware which will check whether the given request contains all the required params/body. \r\n\r\n```javascript\r\napp.use(checkRequestData);\r\n\r\napp.post(\"/user\", controller.addUser);\r\napp.get(\"/user/:id\", controller.getUser);\r\n```\r\n\r\nNow in **checkRequestData**, I can get **req.body** but **req.params.id** is returning *undefined*. To get the req.params.id, I have written the following function\r\n```javascript\r\n\r\nexports.checkRequestData = (req, res, next) => {\r\n    /**\r\n     * check whether request carries required data\r\n     */\r\n    next();\r\n};\r\n\r\nexports.applyMiddleware = (app) => (...middleware) => {\r\n    return new class {\r\n\r\n        middeware(req, res, next){            \r\n            middlewares.forEach((mw) => {\r\n                mw(req, res, next);\r\n            });\r\n        }\r\n\r\n        get(route, controller){\r\n            return app.get(route, this.middeware, controller);\r\n        }\r\n\r\n        post(route, controller){\r\n            return app.post(route, this.middeware, controller);\r\n        }\r\n    }\r\n}; \r\n```\r\n\r\nAnd the server file is modified as follows:\r\n\r\n```javascript\r\nconst _app = applyMiddleware(app)(checkRequestData);\r\n\r\n_app.post(\"/user\", controller.addUser);\r\n_app.get(\"/user/:id\", controller.getUser);\r\n```\r\n\r\nUsing this method I am able to get the request data. \r\n\r\nIs this the right approach of using express middlewares? Will this cause any issues to the in-built express methods?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3837/comments",
    "author": "softlore",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-12-27T18:12:27Z",
        "body": "Hi @gmk292.  This is probably not the way I would do it, but that is not to say it is wrong.  One other approach you might take is to create an array of reusable middleware and use it on each route.  The reason `params` is missing is because no route has been matched for that middleware.  You could get around this like so:\r\n\r\n```javascript\r\napp.post(\"/user\", checkRequestData, controller.addUser);\r\napp.get(\"/user/:id\", checkRequestData, controller.getUser);\r\n```\r\n\r\nIf you have multiple of these middleware you can group them in an array like this:\r\n\r\n```javascript\r\nconst middleware = [checkRequestData, handleRequestDataErrors];\r\n\r\napp.post(\"/user\", middleware, controller.addUser);\r\napp.get(\"/user/:id\", middleware, controller.getUser);\r\n```\r\n\r\nThis composition approach gets rid of the custom wrapper, and sticks with just usage of the express api.  Usually this makes for easier debugging in the future for you and anyone else who works on your project.  Good luck."
      },
      {
        "user": "softlore",
        "created_at": "2019-01-03T14:53:52Z",
        "body": "Thanks for your answer. I will follow your advise."
      }
    ]
  },
  {
    "number": 3819,
    "title": "Middleware of one router gets called while accessing path of another router",
    "created_at": "2018-12-07T16:00:53Z",
    "closed_at": "2018-12-07T16:22:07Z",
    "labels": [
      "4.x",
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/3819",
    "body": "```\r\nconst app = express();\r\n\r\nexport const root = Router();\r\nroot.get('/', (req, res) => {\r\n     res.send(\"Hello World\");\r\n})\r\n// middleware 1\r\nroot.use(accountAuth);\r\nroot.post('/product', product);\r\nroot.post('/dashboard', operator, dashboard);\r\n\r\nexport const account = Router();\r\naccount.post('/login', login);\r\naccount.post('/forgot', forgot);\r\naccount.post('/reset-password', reset_password);\r\n\r\n//middleware 2\r\naccount.use(accountAuth);\r\naccount.patch('/', update_info);\r\naccount.post('/logout', logout);\r\naccount.patch('/password', update_password);\r\n\r\napp.use('/', root);\r\napp.use('/account', account);\r\n```\r\n\r\nIn the above code, when I'm sending post request to path /account/login. middleware 1 is getting called. ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3819/comments",
    "author": "vksid",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-12-07T16:22:07Z",
        "body": "Hi! This is as designed. Your middleware 1 in the code above you have mounted to / and since  /account/login begins with / it will be executed.\r\n\r\nThe flow to get there is as follows:\r\n\r\n1. GET  /account/login enters app\r\n2. Check against app.use('/', root); since /account/login begins with /, it enters root.\r\n3. GET  /account/login enters root\r\n4. Check against root.get('/', route. The method matches, but the path does not, so continue to next\r\n5. Check against root.use(accountAuth); by default everything enters into a plain app.use, the request enters into your middleware 1\r\n\r\nI hope that helps"
      }
    ]
  },
  {
    "number": 3818,
    "title": "ERR_EMPTY_RESPONSE while downloading excel",
    "created_at": "2018-12-06T08:51:10Z",
    "closed_at": "2018-12-06T22:23:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3818",
    "body": "I am trying to download an excel file for very large data.I am having this issue.Data comes after wards but the \"This page isn’t working localhost didn’t send any data.\r\nERR_EMPTY_RESPONSE\" shows first..kindly help me",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3818/comments",
    "author": "bilal68",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-12-06T22:23:46Z",
        "body": "Hi @bilal68, as I said in my other comment.  I would recommend posting in the express gitter channel or on Stack Overflow to get help.  It would also help people if you could post a code example.  Good Luck!"
      },
      {
        "user": "bilal68",
        "created_at": "2018-12-07T06:13:15Z",
        "body": "my records are more than 100,000? sometimes it downloaded but sometimes it stuck and page goes down showing the message ERR_EMPTY_RESPONSE,data comes afterwards on the breakpoints but didn't downloaded."
      }
    ]
  },
  {
    "number": 3815,
    "title": "How could I use `return 'ok'` instead `res.send('ok')`",
    "created_at": "2018-12-04T05:31:38Z",
    "closed_at": "2018-12-04T05:58:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3815",
    "body": "If there are some conditional breaks, I have to use `return res.send('ok')`, I wanna just use `return 'ok'` in every route handlers.\r\n\r\nJust like this:\r\n```\r\napp.get('/', () => 'ok')\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3815/comments",
    "author": "wxs77577",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-12-04T05:58:09Z",
        "body": "Hey @wxs77577, this is not currently possible in express.  Like you said in your question, the way is to just `res.send`.  "
      },
      {
        "user": "LinusU",
        "created_at": "2018-12-04T09:51:51Z",
        "body": "@wxs77577 one way is to add a small \"sugar\"-method yourself to add routes that returns the result. I personally use something like this in a few servers:\r\n\r\n```js\r\nconst express = require('express')\r\n\r\n/* ... */\r\n\r\nconst app = express()\r\n\r\nfunction route (method, path, handler) {\r\n  app[method](path, (req, res, next) => {\r\n    handler(req)\r\n      .then(result => result ? res.json(result) : res.status(204).end(''))\r\n      .catch(next)\r\n  })\r\n}\r\n\r\nroute('get', '/v1/version', async () => ({ version: packageInfo.version }))\r\n\r\nroute('post', '/v1/users', userCtrl.post)\r\n\r\nroute('post', '/v1/login-sessions', loginCtrl.initiate)\r\nroute('post', '/v1/login-sessions/:sessionId/finalize', loginCtrl.finalize)\r\n\r\n/* ... */\r\n```"
      }
    ]
  },
  {
    "number": 3800,
    "title": "How to rewrite url when using routers",
    "created_at": "2018-11-13T20:43:24Z",
    "closed_at": "2018-11-14T05:55:36Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3800",
    "body": "Hello, trying to rewrite the url to redirect requests but having some problems when the url doesn't have a trailing slash. Here is a minimal app to demonstrate.\r\n\r\n```js\r\nconst express = require('express')\r\nconst app = express()\r\nconst port = 3000\r\nconst router = express.Router()\r\n\r\nconst subFolder = '/forum'\r\n\r\napp.use(subFolder, rewrite);\r\n\r\nfunction rewrite(req, res, next) {\r\n    console.log(req.path)\r\n    if (req.path !== '/') {\r\n        return next()\r\n    }\r\n    req.url = '/categories'\r\n    app.handle(req, res, next);\r\n}\r\n\r\nrouter.get('/regular-page', (req, res) => res.send('Hello World!'))\r\nrouter.get('/categories', (req, res) => res.send('Categories'));\r\napp.use(subFolder, router);\r\n\r\napp.listen(port, () => console.log(`Example app listening on port ${port}!`))\r\n```\r\n\r\nThe goal is to redirect `localhost:3000/forum` and `localhost:3000/forum/` to `localhost:3000:/forum/categories`. Right now only `localhost:3000/forum/` works. The other just 404s.\r\n\r\nThanks.\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3800/comments",
    "author": "barisusakli",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-11-13T20:46:17Z",
        "body": "I can help fix your code, but need to know: given the url /forum/foo do you want that not rewritten or rewritten to /categories/foo ?"
      },
      {
        "user": "barisusakli",
        "created_at": "2018-11-13T20:50:36Z",
        "body": "Hi @dougwilson `/forum/foo` should just go to `/forum/foo` only want to rewrite `/forum` and `/forum/` everything else should go to their regular handlers, so `/forum/regular-page` says `Hello World!`"
      },
      {
        "user": "barisusakli",
        "created_at": "2018-11-13T20:57:57Z",
        "body": "This seems to work, gonna test it in our main app 🤔 \r\n\r\n```js\r\nconst express = require('express')\r\nconst app = express()\r\nconst port = 3000\r\n\r\nconst router = express.Router()\r\n\r\nconst subFolder = '/forum'\r\n\r\nrouter.use('/', rewrite); // changed from app.use(subFolder, rewrite)\r\n\r\nfunction rewrite(req, res, next) {\r\n    console.log(req.path)\r\n    if (req.path !== '/') {\r\n        return next()\r\n    }\r\n    req.url = '/categories'\r\n    app.handle(req, res, next);\r\n}\r\n\r\nrouter.get('/regular-page', (req, res) => res.send('Hello World!'))\r\nrouter.get('/categories', (req, res) => res.send('Categories'));\r\napp.use(subFolder, router);\r\n\r\napp.listen(port, () => console.log(`Example app listening on port ${port}!`))\r\n```\r\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2018-11-14T05:55:36Z",
        "body": "Hi @barisusakli there is a lot going on between your examples that may be causing the mix up. For example, when you `app.use(path, fn)`, the `req.url` with in the `fn` will have the `path` chopped off it, and if you alter the `req.url` property within that `fn`, you're only going to alter that portion of the url, as after `fn` exits, the `path` is still restored back to the front of the URL. This is by design.\r\n\r\nIn your second example, you've moved the `.use(path, fn)` from the `app` and onto the `router` that is mounted under `/forum` and then are looping the request back through the top of your app. This it's great because (1) it will re-invoke all your middlewares, which may not be desirable and (2) it can cause a loop condition.\r\n\r\nIdeally, you'll want to do the URL rewrite in a `.use` that is mounted at the point of the rewrite. Since you are trying to rewrite `/forum` to `/forum/category`, the point of the rewrite can just be be `/forum`, so you can mount it there.\r\n\r\nBecause you're using a router pattern, and `/forum` will always enter into the mount point with a non-empty path, you can just put a `.use` at the top of your router to change `/` to `/categories`:\r\n\r\n```js\r\nrouter.use(function rewrite(req, res, next) {\r\n    if (req.url === '/') req.url = '/categories'\r\n    next()\r\n})\r\n```\r\n\r\nHere is the completed app:\r\n```js\r\nconst express = require('express')\r\nconst app = express()\r\nconst port = 3000\r\nconst router = express.Router()\r\n\r\nconst subFolder = '/forum'\r\n\r\nrouter.use(function rewrite(req, res, next) {\r\n    if (req.url === '/') req.url = '/categories'\r\n    next()\r\n})\r\nrouter.get('/regular-page', (req, res) => res.send('Hello World!'))\r\nrouter.get('/categories', (req, res) => res.send('Categories'));\r\napp.use(subFolder, router);\r\n\r\napp.listen(port, () => console.log(`Example app listening on port ${port}!`))\r\n```\r\n\r\nI hope this helps!"
      },
      {
        "user": "barisusakli",
        "created_at": "2018-11-14T22:39:58Z",
        "body": "@dougwilson thanks for the detailed reply."
      }
    ]
  },
  {
    "number": 3799,
    "title": "Route.use with * ignore the last middleware",
    "created_at": "2018-11-13T15:23:23Z",
    "closed_at": "2018-11-13T16:27:17Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3799",
    "body": "The Problem:\r\nLets assume we have route '/A/:idOfA/B/:idOfB/C/:idOfC'\r\nI want to add a route that handles every route that ends with `/someRoute`\r\n\r\nI also added:\r\n```javascript\r\nrouter.param('idOfA', populateAParam);\r\nrouter.param('idOfB', populateBParam);\r\nrouter.param('idOfC', populateCParam);\r\n```\r\nTo capture `/someRoute` for every possible route I added this:\r\n`router.use(/.*\\/someRoute/, someRouteHandler);`\r\n\r\nThe Expected Result:\r\nThe following functions should run in order:\r\npopulateAParam, populateBParam, populateCParam, someRouteHandler\r\n\r\nThe Actual Result:\r\nThe following functions are executed:\r\npopulateAParam, populateBParam, someRouteHandler\r\n\r\ni.e. `populateCParam` was not executed\r\n\r\nAny idea why is this happening? any better suggestion to accomplish this task?\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3799/comments",
    "author": "ShaharMynd",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-11-13T15:25:49Z",
        "body": "Hi @ShaharMynd thanks for the report! I'm not 100% sure how to reproduce given the information above. Can you provide the following so we can take a look?\r\n\r\n1. Version of node.js this module and any other you are using.\r\n2. Complete code that I can copy and paste and run without any modification to see the issue.\r\n3. Complete instructions on how to run the above code and exactly how to replicate the issue.\r\n4. A description of what you expect the outcome to be in contract to what actually happens when I follow you above steps.\r\n\r\nThank you."
      },
      {
        "user": "ShaharMynd",
        "created_at": "2018-11-13T16:19:24Z",
        "body": "```\r\nvar express = require('express');\r\n//Configure app\r\nvar port = process.env.PORT || 1337;\r\nvar app = express();\r\n\r\napp.param('aparam', (req, res, next) => {\r\n    console.log('aparm ran');\r\n    next();\r\n})\r\n\r\napp.param('bparam',(req, res, next) => {\r\n    console.log('bparm run!');\r\n    next();\r\n})\r\n\r\napp.get('/a/:aparam', function (req, res) {\r\n    res.send('hello world')\r\n  });\r\n\r\napp.get('/a/:aparam/b/:bparam', function (req, res) {\r\nres.send('hello world2')\r\n})\r\n\r\napp.use('*/someRoute', (req, res) => {\r\n    res.send('someRoute');\r\n})\r\n\r\n  //Start server\r\napp.listen(port);\r\n```\r\nGET localhost:1337/a/123123/b/123\r\nI see in the console\r\naparm ran\r\nbparm run!\r\n\r\nGET localhost:1337/a/123123/b/123/someRoute\r\nI don't see anything in the console.\r\n\r\nIt ignores the params (Both A and B)\r\n\r\n1) Node version 8.11.3\r\n2) The above code\r\n3) put the code in server.js and then node ./server\r\n\r\n4)\r\nI expect it to \r\nprint in the console aparm ran \r\nthen print bparm run!\r\nthen send me response someRoute\r\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2018-11-13T16:27:17Z",
        "body": "Hi @ShaharMynd thanks for the response. This is working as expected. Your URL that prints nothing, `/a/123123/b/123/someRoute` does not match either route that has params: neither `/a/:aparam` nor `/a/:aparam/b/:bparam`. This is because there is an extra `/someRoute` at the end, which means it's longer than the route.\r\n\r\nAs a better example, `app.get('/foo', ...)` would only match `GET /foo`, it wouldn't match against `GET /foo/bar`, because of the extra `/bar` on the end. The `app[method]` helpers are exact route matching, which means that extra path parts on the end don't match that route. `app.use` is prefix-matching, which means it would just match against a prefix.\r\n\r\nThe param callbacks are only called when the route that is using them is matched."
      }
    ]
  },
  {
    "number": 3765,
    "title": "cant start express with meteor.js ...",
    "created_at": "2018-10-15T11:00:13Z",
    "closed_at": "2018-10-15T13:07:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3765",
    "body": "Even such simple code \r\n```\r\nimport { express } from 'express'\r\nconst app = express();\r\napp('/', (req,res) => {\r\n  doWahateverYouWant(); \r\n}); \r\napp.listen(3000)\r\n```\r\n\r\nthrows : \r\n\r\n```\r\nW20181015-12:55:18.707(2)? (STDERR) TypeError: stream.listeners is not a function\r\nW20181015-12:55:18.707(2)? (STDERR)     at hasPipeDataListeners (/Users/greg/Projects/Meteor/project/node_modules/unpipe/index.js:22:26)\r\nW20181015-12:55:18.707(2)? (STDERR)     at unpipe (/Users/greg/Projects/Meteor/project/node_modules/unpipe/index.js:52:8)\r\nW20181015-12:55:18.707(2)? (STDERR)     at send (/Users/greg/Projects/Meteor/project/node_modules/finalhandler/index.js:306:3)\r\nW20181015-12:55:18.708(2)? (STDERR)     at /Users/greg/Projects/Meteor/project/node_modules/finalhandler/index.js:133:5\r\nW20181015-12:55:18.708(2)? (STDERR)     at Function.handle (/Users/greg/Projects/Meteor/project/node_modules/express/lib/application.js:170:5)\r\nW20181015-12:55:18.708(2)? (STDERR)     at app (/Users/greg/Projects/Meteor/project/node_modules/express/lib/express.js:39:9)\r\n```\r\n\r\nAny idea what could be that ? ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3765/comments",
    "author": "pociej",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-10-15T13:07:11Z",
        "body": "```\r\napp('/', (req,res) => {\r\n  doWahateverYouWant(); \r\n}); \r\n```\r\nIs not a thing. I'm not sure what you're trying to do, but this should probably be either app.use or app.get like so:\r\n```\r\napp.use('/', (req,res) => {\r\n  doWahateverYouWant(); \r\n}); \r\n```"
      }
    ]
  },
  {
    "number": 3747,
    "title": "How to regenerate req.query and req.params after rewriting req.url in Express4?",
    "created_at": "2018-09-15T14:23:55Z",
    "closed_at": "2018-09-15T15:15:29Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3747",
    "body": "I understand `req.query` and `req.params` are automatically regenerated after we rewrite `req.url` in Express 5.\r\n\r\nThis is not the case in Express 4. So what is the recommended method in Express 4 to make sure `req.query` and `req.params` fit the rewrited `req.url` ?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3747/comments",
    "author": "aguyinmontreal",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-09-15T15:15:29Z",
        "body": "You have to set the values after you change the url in express 4 to the new ones."
      }
    ]
  },
  {
    "number": 3744,
    "title": "npm ERR! code EJSONPARSE",
    "created_at": "2018-09-13T18:06:36Z",
    "closed_at": "2018-09-13T18:08:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3744",
    "body": "Help I am getting this error\r\n> C:\\Users\\Admin\\Desktop\\bot>npm install discord.io winston -save.\r\n> npm ERR! file C:\\Users\\Admin\\Desktop\\bot\\package.json\r\n> npm ERR! code EJSONPARSE\r\n> npm ERR! JSON.parse Failed to parse json\r\n>  pm ERR! JSON.parse Unexpected token � in JSON at position 0 while parsing near '��{\r\n> npm ERR! JSON.parse  \u001c n a m e \u001d ...'\r\n> npm ERR! JSON.parse Failed to parse package.json data.\r\n> npm ERR! JSON.parse package.json must be actual JSON, not just JavaScript.\r\n> \r\n> npm ERR! A complete log of this run can be found in:\r\n> npm ERR!     C:\\Users\\Admin\\AppData\\Roaming\\npm-cache\\_logs\\2018-09-13T17_55_13_036Z-debug.log\r\n> \r\n\r\n\r\nHere is the log:\r\n\r\n> 0 info it worked if it ends with ok\r\n> 1 verbose cli [ 'C:\\\\Program Files\\\\nodejs\\\\node.exe',\r\n> 1 verbose cli   'C:\\\\Program Files\\\\nodejs\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js',\r\n> 1 verbose cli   'install',\r\n> 1 verbose cli   'discord.io',\r\n> 1 verbose cli   'winston',\r\n> 1 verbose cli   '-save.' ]\r\n> 2 info using npm@6.4.1\r\n> 3 info using node@v10.10.0\r\n> 4 verbose npm-session c92302b61857a70f\r\n> 5 silly install loadCurrentTree\r\n> 6 silly install readLocalPackageData\r\n> 7 timing stage:rollbackFailedOptional Completed in 15ms\r\n> 8 timing stage:runTopLevelLifecycles Completed in 89ms\r\n> 9 verbose stack Error: Failed to parse json\r\n> 9 verbose stack Unexpected token � in JSON at position 0 while parsing near '��{ \r\n>  \r\n> 9 verbose stack  \u001c n a m e \u001d ...'\r\n> 9 verbose stack     at parseError (C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\read-package-json\\read-json.js:452:11)\r\n> 9 verbose stack     at parseJson (C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\read-package-json\\read-json.js:104:26)\r\n> 9 verbose stack     at C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\read-package-json\\read-json.js:51:5\r\n> 9 verbose stack     at C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\graceful-fs\\graceful-fs.js:78:16\r\n> 9 verbose stack     at FSReqWrap.readFileAfterClose [as oncomplete] (internal/fs/read_file_context.js:53:3)\r\n> 10 verbose cwd C:\\Users\\Admin\\Desktop\\bot\r\n> 11 verbose Windows_NT 10.0.17134\r\n> 12 verbose argv \"C:\\\\Program Files\\\\nodejs\\\\node.exe\" \"C:\\\\Program Files\\\\nodejs\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\" \"install\" \"discord.io\" \"winston\" \"-save.\"\r\n> 13 verbose node v10.10.0\r\n> 14 verbose npm  v6.4.1\r\n> 15 error file C:\\Users\\Admin\\Desktop\\bot\\package.json\r\n> 16 error code EJSONPARSE\r\n> 17 error JSON.parse Failed to parse json\r\n> 17 error JSON.parse Unexpected token � in JSON at position 0 while parsing near '��{ \r\n>  \r\n> 17 error JSON.parse  \u001c n a m e \u001d ...'\r\n> 18 error JSON.parse Failed to parse package.json data.\r\n> 18 error JSON.parse package.json must be actual JSON, not just JavaScript.\r\n> 19 verbose exit [ 1, true ]\r\n> \r\n\r\nWhat should I do?\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3744/comments",
    "author": "CubecCubehead",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-09-13T18:08:13Z",
        "body": "The error is from the command `npm install discord.io winston -save`, which is `npm`. It states that the file `C:\\Users\\Admin\\Desktop\\bot\\package.json` is not valid JSON."
      },
      {
        "user": "CubecCubehead",
        "created_at": "2018-09-13T18:10:01Z",
        "body": "crap I forgot about that thx\r\nwrong format"
      }
    ]
  },
  {
    "number": 3728,
    "title": "parseurl package.json: Unexpected end of JSON input",
    "created_at": "2018-08-23T20:00:10Z",
    "closed_at": "2018-08-23T20:09:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3728",
    "body": "Hello,\r\n\r\nI seem to have run into an error that prevents my Node.JS App from running. It seems as though at some point during express' initialization, it uses the parseurl node module. The parse url node module's package.json is causing an \"Unexpected end of JSON input\". This could be a problem with the parseurl package or something trying to initialize the parseurl package. You can see full stack trace below and my dependencies section of my package.json.\r\n\r\n**Node.JS Version:** 8.9.0\r\n\r\n**Dependencies:**\r\n```\r\n\"dependencies\": {\r\n    \"atlassian-connect-express\": \"^3.0.2\",\r\n    \"axios\": \"^0.18.0\",\r\n    \"body-parser\": \"^1.18.3\",\r\n    \"bootstrap-vue\": \"^2.0.0-rc.11\",\r\n    \"connect-history-api-fallback\": \"^1.5.0\",\r\n    \"cookie-parser\": \"^1.4.3\",\r\n    \"cors\": \"^2.8.4\",\r\n    \"express\": \"^4.16.3\",\r\n    \"helmet\": \"^3.13.0\",\r\n    \"mermaid\": \"^8.0.0-rc.8\",\r\n    \"mongoose\": \"^5.2.7\",\r\n    \"mongoose-vermongo\": \"0.0.4\",\r\n    \"ncp\": \"^2.0.0\",\r\n    \"sqlite3\": \"^4.0.2\",\r\n    \"vue\": \"^2.5.17\",\r\n    \"vue-router\": \"^3.0.1\"\r\n  }\r\n```\r\n\r\n**Stack:**\r\n```\r\nApplication has thrown an uncaught exception and is terminated:\r\n\r\nSyntaxError: Error parsing D:\\home\\site\\wwwroot\\node_modules\\express\\node_modules\\parseurl\\package.json: Unexpected end of JSON input\r\n\r\n    at JSON.parse (<anonymous>)\r\n\r\n    at readPackage (module.js:120:52)\r\n\r\n    at tryPackage (module.js:130:13)\r\n\r\n    at Function.Module._findPath (module.js:212:20)\r\n\r\n    at Function.Module._resolveFilename (module.js:536:25)\r\n\r\n    at Function.Module._load (module.js:468:25)\r\n\r\n    at Module.require (module.js:587:17)\r\n\r\n    at require (internal/module.js:11:18)\r\n\r\n    at Object.<anonymous> (D:\\home\\site\\wwwroot\\node_modules\\express\\lib\\router\\index.js:23:16)\r\n\r\n    at Module._compile (module.js:643:30)\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3728/comments",
    "author": "kmccmk9",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-08-23T20:09:51Z",
        "body": "Hey @kmccmk9, this is probably not an express issue, but an npm install issue.  Try removing your `node_modules` and trying again.  Depending on your `npm` version you might also want to run `npm cache clean`.  If that does not work for you, I would try posting on Stack Overflow as these github issues are more for reporting express bugs.  Good luck!"
      }
    ]
  },
  {
    "number": 3704,
    "title": "unable to get params from middleware into route",
    "created_at": "2018-08-01T13:28:20Z",
    "closed_at": "2018-08-01T13:30:06Z",
    "labels": [
      "4.x",
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/3704",
    "body": "\r\napp.js\r\n\r\n```\r\nconst adminRoutes = require('./routes/admin');\r\napp.use('/admin/customer/:customerId', (req, res, next) => {\r\n    console.log('middleware id=', req.params.customerId);\r\n    next();\r\n}, adminRoutes);\r\n```\r\n\r\nand here is routes/admin.js\r\n\r\n\r\nconst express = require('express');\r\nconst router = express.Router();\r\n\r\n\r\nrouter.post('/user', (req, res) => {\r\n    console.log('route id=', req.params.customerId);\r\n    res.json(req.params);\r\n});\r\n\r\nmodule.exports = router;\r\n\r\n\r\n\r\nI am getting following output \r\n\r\n```\r\nmiddleware id= 1\r\nroute id= undefined\r\n```\r\n\r\n\r\nwhile expected output is\r\n\r\n```\r\nmiddleware id= 1\r\nroute id= 1\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3704/comments",
    "author": "arifjaunpur",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-08-01T13:30:06Z",
        "body": "Your router in admin.js needs to have the option to merge the parameters from the above router set.\r\n\r\n    const router = express.Router({mergeParams: true});"
      }
    ]
  },
  {
    "number": 3699,
    "title": "Camelize the response",
    "created_at": "2018-07-23T11:18:53Z",
    "closed_at": "2018-07-23T14:08:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3699",
    "body": "I am getting an object contains the properties, arrays of objects, etc. I just need to convert the complete object keys in camel case. Is it possible in express or I need to write my own parser for that ?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3699/comments",
    "author": "ahmadraza-gh",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-07-23T14:08:07Z",
        "body": "Hi @AhmadRaza786, express does not have functionality like this.  If you have trouble with it, I would suggest posting on StackOverflow.  Good luck!"
      }
    ]
  },
  {
    "number": 3691,
    "title": "Router.get firing twice for the same route on page load",
    "created_at": "2018-07-14T16:17:30Z",
    "closed_at": "2018-07-14T22:48:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3691",
    "body": "\r\n\r\nIn my router\r\n\r\nRouter.get('/login', IndexController.login); \r\n\r\nIn my controller\r\n\r\nexports.login = (req,res,next)=>{\r\n    console.log('login get');\r\n    res.render('main/login',{pageTitle: 'Login'});\r\n\r\n};\r\n\r\nThe console logs login get twice, meaning that this is called twice. If I remove the render call then it is logged only once. I have been trying to debug for several days now but still cant seem to figure this one out. When using a curl request from another terminal the log is seen only once as well, but using chrome/firefox/IE yields the double or sometimes triple log call. I don't see this behaviour with POST calls however. -EJS -EXPRESS -Node\r\n\r\nUPDATE In chrome dev tools, after inspecting the network tab, I only see 1 GET request being made for the page.\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3691/comments",
    "author": "nove1398",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-07-14T18:59:30Z",
        "body": "My guess is that your view is making a request you were not planning on.  Maybe a favicon or an xhr reuest?  I would check your browser network tab."
      },
      {
        "user": "nove1398",
        "created_at": "2018-07-14T21:32:56Z",
        "body": "Thanks for the reply @wesleytodd I checked the network tab as you suggested, I notice an initial request followed at some point later by another request to the same URL not sure why that one is being called, but an \"img\" requested it. Are you familiar with how to resolve this? or should I just tinker with all the images until i figure it out?"
      },
      {
        "user": "nove1398",
        "created_at": "2018-07-14T22:04:33Z",
        "body": "Ok Following your advice @wesleytodd  I discovered it was an extra call from an img tag on the page, it seems it was making an extra url call."
      }
    ]
  },
  {
    "number": 3688,
    "title": "syntax error : Indentifier 'express' has already been declared..??",
    "created_at": "2018-07-08T00:11:37Z",
    "closed_at": "2018-07-08T15:51:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3688",
    "body": "this is my server.js file code\r\nconst express = require('express');\r\nconst mongoose = require('mongoose');\r\nconst bodyParser = require('body-parser');\r\nconst passport = require('passport');\r\n\r\nconst users = require('./routes/api/users');\r\nconst profile = require('./routes/api/profile');\r\nconst posts = require('./routes/api/posts');\r\n\r\nconst app = express();\r\n\r\n// Body parser middleware\r\napp.use(bodyParser.urlencoded({ extended: false }));\r\napp.use(bodyParser.json());\r\n\r\n// DB Config\r\nconst db = require('./config/keys').mongoURI;\r\n\r\n// Connect to MongoDB\r\nmongoose\r\n  .connect(db)\r\n  .then(() => console.log('MongoDB Connected'))\r\n  .catch(err => console.log(err));\r\n\r\n// Passport middleware\r\napp.use(passport.initialize());\r\n\r\n// Passport Config\r\nrequire('./config/passport')(passport);\r\n\r\n// Use Routes\r\napp.use('/api/users', users);\r\napp.use('/api/profile', profile);\r\napp.use('/api/posts', posts);\r\n\r\nconst port = process.env.PORT || 5000;\r\n\r\napp.listen(port, () => console.log(`Server running on port ${port}`));\r\nand i am getting this error\r\n dentifier 'express' has already been declared at new script (vm.js:74:7) at createscript (vm.js:246:10) at Object.runInThisContext(vm.js:298:10) at module._compile(internal/module/cjs/loader.js:713:10) ...\r\nearlier my code was running very well i was getting the response from postman then suddenly it was showing reference error : express not defined even though i have dependencies of express after that i have tried to reinstall it ....and also tried to reinstall globally",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3688/comments",
    "author": "sonaskyla12",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-07-08T15:51:29Z",
        "body": "Hi @sonaskyla12, I am not sure from your code where the error is, it looks fine.  My guess is that one of the other files you are pulling in has an issue, like `./routes/api/users` or one of those.  What to look for is two lines declaring the variable `express`, like `const express ...`.  Hope that helps."
      }
    ]
  },
  {
    "number": 3687,
    "title": "DELETE route isn't being matched but the same GET route is",
    "created_at": "2018-07-04T08:23:48Z",
    "closed_at": "2018-07-08T15:59:25Z",
    "labels": [
      "question",
      "awaiting more info"
    ],
    "url": "https://github.com/expressjs/express/issues/3687",
    "body": "Hi!\r\n\r\nRunning `express v4.15.3`, and I'm running into a problem where my `DELETE` route isn't being matched.\r\n\r\nthese are my routes:\r\n```\r\nvar trainingRoutes = express.Router();\r\n\r\n// ROUTES\r\ntrainingRoutes.post('', createTrainingDataLine);\r\ntrainingRoutes.get('/searchterm/:searchTerm', findBySearchTerm); \r\ntrainingRoutes.get('', findWithQueryParams);\r\ntrainingRoutes.get('/id/:id', findById);\r\ntrainingRoutes.delete(\"/id/:id\", deleteById);\r\n```\r\n\r\nAll the non-`delete` routes work, including the `GET /id/:id` route.\r\n\r\nI've run this too with some debugging, and this is what I see when launching node with the `DEBUG=express:*` flag\r\n\r\n```\r\n$ DEBUG=express:* node server/server.js \r\n  express:router:route new '' +0ms\r\n  express:router:layer new '' +1ms\r\n  express:router:route post '' +1ms\r\n  express:router:layer new '/' +0ms\r\n  express:router:route new '/searchterm/:searchTerm' +0ms\r\n  express:router:layer new '/searchterm/:searchTerm' +0ms\r\n  express:router:route get '/searchterm/:searchTerm' +0ms\r\n  express:router:layer new '/' +0ms\r\n  express:router:route new '' +0ms\r\n  express:router:layer new '' +0ms\r\n  express:router:route get '' +0ms\r\n  express:router:layer new '/' +0ms\r\n  express:router:route new '/id/:id' +0ms\r\n  express:router:layer new '/id/:id' +0ms\r\n  express:router:route get '/id/:id' +0ms\r\n  express:router:layer new '/' +0ms\r\n  express:router:route new '/id/:id' +0ms\r\n  express:router:layer new '/id/:id' +0ms\r\n  express:router:route delete '/id/:id' +0ms\r\n  express:router:layer new '/' +0ms\r\n  express:application set \"x-powered-by\" to true +2ms\r\n  express:application set \"etag\" to 'weak' +0ms\r\n  express:application set \"etag fn\" to [Function: generateETag] +0ms\r\n  express:application set \"env\" to 'development' +0ms\r\n  express:application set \"query parser\" to 'extended' +0ms\r\n  express:application set \"query parser fn\" to [Function: parseExtendedQueryString] +0ms\r\n  express:application set \"subdomain offset\" to 2 +0ms\r\n  express:application set \"trust proxy\" to false +0ms\r\n  express:application set \"trust proxy fn\" to [Function: trustNone] +0ms\r\n  express:application booting in development mode +0ms\r\n  express:application set \"view\" to [Function: View] +0ms\r\n  express:application set \"views\" to '<snip>/views' +0ms\r\n  express:application set \"jsonp callback name\" to 'callback' +0ms\r\n  express:router use '/' query +7ms\r\n  express:router:layer new '/' +0ms\r\n  express:router use '/' expressInit +0ms\r\n  express:router:layer new '/' +0ms\r\n  express:router use '/' jsonParser +0ms\r\n  express:router:layer new '/' +0ms\r\n  express:router use '/' logger +0ms\r\n  express:router:layer new '/' +0ms\r\n  express:router use '/trainingdata' router +0ms\r\n  express:router:layer new '/trainingdata' +0ms\r\n  express:router use '/swagger/api' serveStatic +1ms\r\n  express:router:layer new '/swagger/api' +0ms\r\n  express:router use '/explorer' serveStatic +0ms\r\n  express:router:layer new '/explorer' +0ms\r\n  express:router use '/' router +0ms\r\n  express:router:layer new '/' +0ms\r\n  express:router:route new '/' +0ms\r\n  express:router:layer new '/' +0ms\r\n  express:router:route get '/' +0ms\r\n  express:router:layer new '/' +0ms\r\n  express:router use '/health' router +0ms\r\n  express:router:layer new '/health' +0ms\r\n  express:router use '/' <anonymous> +4ms\r\n  express:router:layer new '/' +0ms\r\n  express:router use '/' <anonymous> +0ms\r\n  express:router:layer new '/' +0ms\r\n```\r\n\r\nThe lines for the `GET /id/:id` and `DELETE /id/:id` are... in the middle-ish, and pulled out here for reference:\r\n\r\n```\r\n  express:router:route new '/id/:id' +0ms\r\n  express:router:layer new '/id/:id' +0ms\r\n  express:router:route get '/id/:id' +0ms\r\n  express:router:layer new '/' +0ms\r\n  express:router:route new '/id/:id' +0ms\r\n  express:router:layer new '/id/:id' +0ms\r\n  express:router:route delete '/id/:id' +0ms\r\n```\r\nI haven't found anything else in here that looks like the same route.\r\n\r\nNow, when running... The logs I get for the `GET /trainingdata/id/:id` route is:\r\n\r\n```\r\n  express:router dispatching GET /trainingdata/id/5b3c7f880a7894d597a87310 +9m\r\n  express:router query  : /trainingdata/id/5b3c7f880a7894d597a87310 +0ms\r\n  express:router expressInit  : /trainingdata/id/5b3c7f880a7894d597a87310 +0ms\r\n  express:router jsonParser  : /trainingdata/id/5b3c7f880a7894d597a87310 +0ms\r\n  express:router logger  : /trainingdata/id/5b3c7f880a7894d597a87310 +0ms\r\n  express:router trim prefix (/trainingdata) from url /trainingdata/id/5b3c7f880a7894d597a87310 +0ms\r\n  express:router router /trainingdata : /trainingdata/id/5b3c7f880a7894d597a87310 +0ms\r\n  express:router dispatching GET /id/5b3c7f880a7894d597a87310 +0ms\r\n2018-07-04 08:15:52 info: \t::ffff:127.0.0.1 - - [04/Jul/2018:08:15:52 +0000] \"GET /trainingdata/id/5b3c7f880a7894d597a87310 HTTP/1.1\" 200 227 \"-\" \"Paw/3.1.7 (Macintosh; OS X/10.13.5) GCDHTTPRequest\"\r\n```\r\n\r\nSo it works its way through. and then gets it, and I see it logged in my logs (last line)\r\n\r\nBut with `DELETE /trainingdata/id/:id` - which is literally changing the method in my API player...\r\n```\r\n  express:router dispatching DELETE /trainingdata/id/5b3c7f880a7894d597a87310 +1m\r\n  express:router query  : /trainingdata/id/5b3c7f880a7894d597a87310 +0ms\r\n  express:router expressInit  : /trainingdata/id/5b3c7f880a7894d597a87310 +0ms\r\n  express:router jsonParser  : /trainingdata/id/5b3c7f880a7894d597a87310 +0ms\r\n  express:router logger  : /trainingdata/id/5b3c7f880a7894d597a87310 +0ms\r\n  express:router trim prefix (/trainingdata) from url /trainingdata/id/5b3c7f880a7894d597a87310 +0ms\r\n  express:router router /trainingdata : /trainingdata/id/5b3c7f880a7894d597a87310 +1ms\r\n  express:router dispatching DELETE /id/5b3c7f880a7894d597a87310 +0ms\r\n  express:router router  : /trainingdata/id/5b3c7f880a7894d597a87310 +0ms\r\n  express:router <anonymous>  : /trainingdata/id/5b3c7f880a7894d597a87310 +0ms\r\n  express:router <anonymous>  : /trainingdata/id/5b3c7f880a7894d597a87310 +0ms\r\n2018-07-04 08:17:04 info: \t::ffff:127.0.0.1 - - [04/Jul/2018:08:17:04 +0000] \"DELETE /trainingdata/id/5b3c7f880a7894d597a87310 HTTP/1.1\" 404 266 \"-\" \"Paw/3.1.7 (Macintosh; OS X/10.13.5) GCDHTTPRequest\"\r\n \r\nError: ENOENT: no such file or directory, stat '><snip>/public/500.html'\r\n```\r\n\r\nFor whatever reason, when it gets to `dispatching DELETE`, it's behaviour then differs, and it doesn't seem to be able to find it.\r\n\r\nI've also got very liberal commenting within the functions that I'm calling, so I'm sure the `deleteById` function is never called. :/\r\n\r\nI'd really appreciate some directions on how to further debug this. I've exhausted what I know!\r\n\r\nThank you\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3687/comments",
    "author": "kriston13",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-07-06T18:20:13Z",
        "body": "Hey @kriston13, if you could post more of your code maybe we could help. Your routes look fine and the logs you posted do not show a clear problem.  There are many reasons you could have a `404` even if it does match, for example if your middleware calls next without an error.  So it is hard to tell exactly what is wrong without more context."
      },
      {
        "user": "kriston13",
        "created_at": "2018-07-08T15:59:18Z",
        "body": "Hi @wesleytodd, I figured it out. Your comment about it matching, but moving on gave me the clue, and it turned out my `DELETE` code was calling a static method, when it should have been calling an instance method. And the instance method *had* been designed to pass on to the next layer absent a `request.body`. \r\n\r\nLong story short, had a brain fart, apologies, and thank you for the hint!\r\n\r\nCheers"
      }
    ]
  },
  {
    "number": 3674,
    "title": "How come only bodyParser.json is exposed?",
    "created_at": "2018-06-19T17:27:22Z",
    "closed_at": "2018-10-27T17:31:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3674",
    "body": "This module depends on body-parser and exposes `bodyParser.json`. However, if someone wanted to get the pure text result of the output, or use another method from body-parser, they'd have to install it themselves. Why not just expose all of the functions and save the user an extra install? Or not expose anything, and make the module lighter?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3674/comments",
    "author": "willowiscool",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-06-19T21:08:01Z",
        "body": "I think the general idea was to remove all these originally, but the `json` one was brought back.  I looked quickly for the old conversations but it was too long ago for me to remember what to look for.\r\n\r\nI do think, if the choice is to include any, then all should be exposed.  But maybe there was some question about this someone else would remember better."
      },
      {
        "user": "dougwilson",
        "created_at": "2018-10-27T17:31:37Z",
        "body": "The others are being exposed in Express 4.17. Follow the release and what it includes in #3778"
      }
    ]
  },
  {
    "number": 3671,
    "title": "Question about middleware in Routers",
    "created_at": "2018-06-15T03:55:22Z",
    "closed_at": "2018-06-15T04:03:07Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3671",
    "body": "middleware auth\r\n```js\r\nexports.isClient = (req, res, next) => {\r\n    if (!req.user) {\r\n        return res.json({\r\n            \"code\": 400,\r\n            \"msg\": \"no auth user\"\r\n        });\r\n    }\r\n    next();\r\n}\r\n\r\nexports.isAdmin = (req, res, next) => {\r\n    if (!req.user || !req.user.isAdmin) {\r\n        return res.json({\r\n            \"code\": 400,\r\n            \"msg\": \"no auth admin\"\r\n        });\r\n    }\r\n    next();\r\n}\r\n```\r\n\r\narticle admin router\r\n```js\r\nconst express = require('express');\r\nconst router = express.Router();\r\nconst authMiddleware = require('../middlewares/auth');\r\nconst articleController = require('../controllers/article');\r\n\r\nrouter.use(authMiddleware.isAdmin);\r\n\r\nrouter.get('/api/admin/articles', articleController.getArticles);\r\nrouter.post('/api/admin/articles', articleController.postArticle);\r\nrouter.delete('/api/admin/articles', articleController.deleteArticles);\r\nrouter.get('/api/admin/articles/:id', articleController.getArticle);\r\nrouter.put('/api/admin/articles/:id', articleController.putArticle);\r\n\r\nmodule.exports = router;\r\n```\r\n\r\narticle client router\r\n```js\r\nconst express = require('express');\r\nconst router = express.Router();\r\nconst authMiddleware = require('../middlewares/auth');\r\nconst articleController = require('../controllers/article');\r\n\r\nrouter.use(authMiddleware.isClient);\r\n\r\nrouter.get('/api/client/articles', articleController.getArticles);\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n```js\r\nconst articleClientRouter = require('./routers/articleClient');\r\nconst articleAdminRouter = require('./routers/articleAdmin');\r\n\r\napp.use('/', articleClientRouter);\r\napp.use('/', articleAdminRouter);\r\n```\r\n\r\nWhen I use client user to access /api/client/articles\r\n```\r\n\"/api/client/articles\" -> isClient -> isAdmin -> \"no auth admin\"\r\n```\r\nWhy go through the isAdmin? the router places the middleware not according to the path, but according to the controller(articleController.getArticles)?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3671/comments",
    "author": "rsinensis",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-06-15T04:03:07Z",
        "body": "This is because both `isClient` and `isAdmin` have been mounted on the path of `/`, so all requests will go through both, as all paths start with `/`.\r\n\r\nFrom your example above, let's walk through what happens with `GET /api/client/articles`:\r\n\r\n1. `app.use('/', articleClientRouter);` -- since `/api/client/articles` begins with `/`, enter into `articleClientRouter`.\r\n2. `router.use(authMiddleware.isClient);` -- since `/api/client/articles` begins with `/`, enter into `authMiddleware.isClient`.\r\n3. `router.get('/api/client/articles', articleController.getArticles);` -- since `GET /api/client/articles` matches, enter into `articleController.getArticles`. What this does is anyone's guess, because no code was provided. Let's assume it calls `next()` so we'll continue routing.\r\n4. Nothing left in router, exit back to top level\r\n5. `app.use('/', articleAdminRouter);` -- since `/api/client/articles` begins with `/`, enter into `articleAdminRouter`.\r\n6. `router.use(authMiddleware.isAdmin);` -- since  `/api/client/articles` begins with `/`, enter into `authMiddleware.isAdmin`.\r\n7. No routes match `GET /api/client/articles`, exit back to top level\r\n8. No routes left in top level, 404.\r\n"
      }
    ]
  },
  {
    "number": 3662,
    "title": "how to use express with typescript?",
    "created_at": "2018-06-04T15:38:21Z",
    "closed_at": "2018-06-04T16:17:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3662",
    "body": "how to use express with typescript? can express support typescript?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3662/comments",
    "author": "ReExia",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-06-04T16:08:22Z",
        "body": "Hey @setsunahao, yes you can use typescript with express.  I would recommend moving your question to stack overflow as you will get more help over there and this is really only a place for reporting issues.  Good luck!"
      },
      {
        "user": "ReExia",
        "created_at": "2018-06-04T16:17:11Z",
        "body": "oh thank you "
      },
      {
        "user": "ReExia",
        "created_at": "2018-06-04T16:17:16Z",
        "body": "oh thank you "
      },
      {
        "user": "ReExia",
        "created_at": "2018-06-04T16:17:18Z",
        "body": "oh thank you "
      },
      {
        "user": "ReExia",
        "created_at": "2018-06-04T16:17:19Z",
        "body": "oh thank you "
      },
      {
        "user": "ReExia",
        "created_at": "2018-06-04T16:17:23Z",
        "body": "oh thank you "
      },
      {
        "user": "ReExia",
        "created_at": "2018-06-04T16:17:29Z",
        "body": "oh thank you "
      }
    ]
  },
  {
    "number": 3647,
    "title": "Can't throw error in router middleware ",
    "created_at": "2018-05-08T03:17:07Z",
    "closed_at": "2018-06-14T15:00:30Z",
    "labels": [
      "question",
      "awaiting more info"
    ],
    "url": "https://github.com/expressjs/express/issues/3647",
    "body": "I used ajax post data to express server,i want throw error to errorhandle in  router middleware when error was happen,but still thorw error, `next();` not excute,very strange! below is my code\r\n```\r\nclientRouter.use('/api', (req, res, next)=>{\r\n    if(1){ \r\n        next(); // not excute!\r\n     }else{ \r\n        next(new Error('111')); //alaways excute!\r\n     }   \r\n}, apiRouter);\r\n```\r\nerrorhandel in app.js\r\n```\r\napp.use((err, req, res, next) => {\r\n  log.error(\"req.xhr:\", req.xhr); //alaways false!\r\n  // set locals, only providing error in development\r\n  res.locals.message = err.message;\r\n  res.locals.error = (APP_ENV === 'development' ? err : {});\r\n  if (req.xhr) {\r\n    res.send(<ApiResponse>{\r\n      status:false,\r\n      err: (APP_ENV === 'development' ? err.toString() :'err happen!') \r\n    });\r\n  } else {\r\n    // render the error page\r\n    res.status(err.status || 500);\r\n    res.render('error');\r\n  }\r\n});\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3647/comments",
    "author": "keyiis",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-05-08T15:41:28Z",
        "body": "Hey @keyiis, `1` is truthy in javascript, so your error condition (`//always excute!`) will not be hit.  Maybe I am miss understanding your question, so feel free to post more information to help me understand and I will try to help more."
      },
      {
        "user": "dougwilson",
        "created_at": "2018-06-14T15:00:30Z",
        "body": "Closing since there was no response, so asume that answered the question."
      }
    ]
  },
  {
    "number": 3646,
    "title": "Unhandled rejection ReplyError: CROSSSLOT Keys in request don't hash to the same slot",
    "created_at": "2018-05-07T07:31:24Z",
    "closed_at": "2018-06-14T15:01:39Z",
    "labels": [
      "question",
      "awaiting more info"
    ],
    "url": "https://github.com/expressjs/express/issues/3646",
    "body": "Hello there,\r\n\r\nI am using ioredis to enable redis cluster usage to set and purge keys. On purging keys, I get the above error. The purge happens anyway. When I use the redis instance in expressjs middleware I get this error otherwise I dont.\r\n\r\nI am using 4.10.x as the express version.\r\n\r\nThanks for the help.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3646/comments",
    "author": "anuradhag",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-05-07T15:03:39Z",
        "body": "This sounds like an issue with either the redis package or your application.  If you post a comprehensive example we can help debug, but otherwise I would look at what you are calling to redis with."
      },
      {
        "user": "anuradhag",
        "created_at": "2018-05-08T05:58:54Z",
        "body": "\r\n         \r\n\r\n\t\r\n        var express = require('express');\r\n\tvar expressSession = require(\"express-session\");\r\n\tvar sessionStorage = require('connect-redis')(expressSession);\r\n\tvar redis = require('ioredis');\r\n\tvar config = require('./config');var app = express();\r\n\r\n\tvar client = new redis.Cluster([{\r\n\t\thost: config.session.host,\r\n\t\tport: config.session.port,\r\n\t\tpassword: config.session.pass,\r\n\t\tttl: config.session.ttl\r\n\t}]);\r\n\r\n\tapp.use(expressSession({\r\n\t  unset: \"destroy\",\r\n\t  saveUninitialized: false,\r\n\t  resave: false,\r\n\t  secret: config.session.secret,\r\n\t  store: new sessionStorage({\r\n\t\t\tclient: client,\r\n\t\t\tttl: config.session.ttl,\r\n\t    prefix: '{sess}.'\r\n\t  }),\r\n\t  key: \"authorization.sid\",\r\n\t  cookie: {maxAge: config.session.maxAge}\r\n\t}))\r\n\r\n\tapp.use(bodyParser.urlencoded({extended: true}));\r\n\tapp.use(bodyParser.json());\r\n\r\n\tapp.post('/login', function(req, res) {\r\n\t\tif(req.user) {\r\n\t\t\treturn res.redirect('/home');\r\n\t\t}\r\n\r\n\t\tif (req.body.username === 'Anu' && req.body.password === 'Password') {\r\n\t\t\treq.logIn({name: 'Anu'}, function(err) {\r\n\t\t\t\treturn res.redirect('/home');\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\treturn res.send(400);\r\n\t\t}\r\n\t})\r\n\r\n\tapp.get('/logout', function(req, res) {\r\n\t\treq.logout();\r\n\t})\r\n\r\n\tvar port = process.env.PORT || '3000';\r\n\tapp.listen(port);\r\n\r\n\r\nA very rough sample. Nothing complicated. On req.logout() I am getting the above unhandled error."
      },
      {
        "user": "anuradhag",
        "created_at": "2018-05-08T06:02:20Z",
        "body": "Note: I get this error only when I use it in the express middleware and not when using the io-redis package seperately.\r\n\r\nActually everything works fine except for express logging this unhandled error. "
      },
      {
        "user": "wesleytodd",
        "created_at": "2018-05-08T14:25:30Z",
        "body": "Interesting. It has been a while since I have used the `express-session` and `connect-redis` packages, so I can not remember how they store the sessions, but this error occurs when the redis package attempts to insert multiple keys at once and they are not in the same cluster node.  It is possible that `ioredis` or `connect-redis` is batching things incorrectly behind the scenes.  Either way this is not an express issue, so try posting it on `connect-redis` or `ioredis`."
      },
      {
        "user": "anuradhag",
        "created_at": "2018-05-09T09:27:04Z",
        "body": "Okay. I have raised the same in _ioredis_ "
      },
      {
        "user": "dougwilson",
        "created_at": "2018-06-14T15:01:39Z",
        "body": "The issue opened in ioredis explains the resolution. Closing over here."
      }
    ]
  },
  {
    "number": 3629,
    "title": "Adding database models to the request object?",
    "created_at": "2018-04-20T18:49:03Z",
    "closed_at": "2018-05-05T15:57:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3629",
    "body": "I have a question about what the request object can be used for within Express. In particular, I'm considering creating a middleware that adds a database model to the request object, something like this:\r\n\r\n```javascript\r\nconst express = require('express');\r\nconst db = require('./databaseModel.js');\r\n\r\nconst app = express();\r\n\r\napp.use((req, res, next) => {\r\n    req.db = db;\r\n    next();\r\n}\r\n\r\napp.get('/store', (req, res) => {\r\n    req.db.getAllStoreItems()\r\n    .then(storeItems => res.send(storeItems))\r\n    .catch(error => res.sendStatus(500));\r\n}\r\n```\r\n\r\nIs this an appropriate use of the request object? I'm considering this approach because it will make it easier to test my route controllers (I can just pass in a mocked database without needing to monkey patch the models), but I haven't seen this usage pattern much online so I'm not sure if there are performance implications/other gotchas that I'm not considering.\r\n\r\nThanks for the help!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3629/comments",
    "author": "edahlseng",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-04-20T18:54:44Z",
        "body": "While this is a very common approach, it is actually not the best way.  The best way would be to use one of three other approaches:\r\n\r\n1. `app.set`:  you could do `app.set('myModel', model)` then in the handler function `req.app.get('myModel')`.\r\n2. `app.locals.myModel = model`: Similar to above, but would also make them available in the view rendering\r\n3. `res.locals.myModel = model`: Similar to 2 but you could selectively do it for different routes, where as the app ones are global to the application\r\n\r\nLet me know if you need more details on these, or examples.\r\n\r\nNow for the main reason not to do `req.db = myModel`.  It is a performance antipattern.  In an http server the request and response objects are probably the most commonly created objects.  So the runtime will optimize things for this.  But if you modify its shape by adding a key it will deopt it.  Specifically the app settings, app.locals and res.locals are made for this because deopting them is not such a big deal.  I have some benchmarks which I used to compare this and found that just one modification to req can cut perf in half in a basic reduced test case."
      },
      {
        "user": "dougwilson",
        "created_at": "2018-05-05T15:57:41Z",
        "body": "Closing since question was answered and no further follow up questions."
      },
      {
        "user": "edahlseng",
        "created_at": "2018-05-07T04:53:43Z",
        "body": "@wesleytodd thanks for the detailed answer!"
      }
    ]
  },
  {
    "number": 3616,
    "title": "NPM Failed to parse json",
    "created_at": "2018-04-08T02:32:18Z",
    "closed_at": "2018-04-08T02:44:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3616",
    "body": "Hey there, does anyone by chance know why i'm getting this error when I do sudo npm install?? Thanks!\r\n\r\n`ubuntu@ip-172-26-3-197:~$ sudo npm install\r\nnpm ERR! file /home/ubuntu/package.json\r\nnpm ERR! code EJSONPARSE\r\nnpm ERR! Failed to parse json\r\nnpm ERR! Unexpected string in JSON at position 232 while parsing '{\r\nnpm ERR!   \"name\": \"learnmore\",\r\nnpm ERR!   \"version\": \"1'\r\nnpm ERR! File: /home/ubuntu/package.json\r\nnpm ERR! Failed to parse package.json data.\r\nnpm ERR! package.json must be actual JSON, not just JavaScript.\r\nnpm ERR! \r\nnpm ERR! Tell the package author to fix their package.json file. JSON.parse\r\n\r\nnpm ERR! A complete log of this run can be found in:\r\nnpm ERR!     /home/ubuntu/.npm/_logs/2018-04-08T02_28_21_871Z-debug.log`",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3616/comments",
    "author": "aidenappl",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-04-08T02:44:10Z",
        "body": "Hi! It says you have a file at the location /home/ubuntu/package.json in your system that has unparsable JSON. You would either need to fix the JSON in that file or simply delete that file."
      }
    ]
  },
  {
    "number": 3615,
    "title": "req.is('json') returns null while content-type: json is present",
    "created_at": "2018-04-05T04:15:35Z",
    "closed_at": "2018-04-05T12:19:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3615",
    "body": "Minimal example, tested with express 4.16.3, node v9.4.0, Windows 10: \r\n\r\n```\r\nconst request = require('superagent')\r\nconst express = require('express')\r\nconst app = express()\r\n\r\napp.get('/', (req, res) => {\r\n  console.log('Header value:', req.headers['content-type'])\r\n  console.log('req.is value:', req.is('json'))\r\n  res.sendStatus(200)\r\n})\r\n\r\napp.listen(3333, async () => request.get('localhost:3333').type('json'))\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3615/comments",
    "author": "georgyfarniev",
    "comments": [
      {
        "user": "georgyfarniev",
        "created_at": "2018-04-05T04:30:02Z",
        "body": "I dig more into this issue and figured out that this problem is related to type-is module itself. "
      },
      {
        "user": "dougwilson",
        "created_at": "2018-04-05T12:19:15Z",
        "body": "That is working as expected. Your example request has no body:\r\n\r\n> null will be returned if the request does not have a body."
      }
    ]
  },
  {
    "number": 3607,
    "title": "`router.use` vs function",
    "created_at": "2018-03-28T04:11:20Z",
    "closed_at": "2018-04-14T16:12:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3607",
    "body": "    router.use((req, res, next) => { // export as single route in a file\r\n      if (req.isAuthenticated()) {\r\n        next();\r\n        return;\r\n      }\r\n      res.sendStatus(401);\r\n    });\r\n    \r\n    const authenticate = (req, res, next) => {\r\n      if (req.isAuthenticated()) {\r\n        next();\r\n        return;\r\n      }\r\n      res.sendStatus(401);\r\n    };\r\nThe above are 2 ways of writing the authentication route for use in another route (like below). Which way is preferred and why?\r\n\r\n    router.post('/', authenticate, (req, res, next) => {});\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3607/comments",
    "author": "James2516",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-03-28T04:18:11Z",
        "body": "I'm not quite sure I fully understand what you're trying to illustrate in order to provide a good answer. Perhaps someone else here has a better idea :+1:"
      },
      {
        "user": "James2516",
        "created_at": "2018-03-28T04:26:42Z",
        "body": "So in order to make sure a route is authenticated before being accessed, we need to add an `authenticate` middleware to it.\r\neg.\r\n```\r\nrouter.post('/data', authenticate, (req, res, next) => { console.log('inserting data'); });\r\n```\r\n`console.log('inserting data');` will be executed only if the `authenticate` middleware calls `next()`.\r\n\r\nThere are 2 ways of writing this `authenticate` middleware:\r\n1.\r\n```\r\nconst express = require('express');\r\n\r\nconst router = express.Router();\r\n\r\nrouter.use((req, res, next) => {\r\n  // returns true if cookie contains valid session id and user is deserialised\r\n  if (req.isAuthenticated()) { \r\n    next();\r\n    return;\r\n  }\r\n  res.sendStatus(401);\r\n});\r\n\r\nmodule.exports = router;\r\n```\r\n2.\r\n```\r\nconst authenticate = (req, res, next) => {\r\n  if (req.isAuthenticated()) {\r\n    next();\r\n    return;\r\n  }\r\n  res.sendStatus(401);\r\n};\r\n\r\nmodule.exports = authenticate;\r\n```\r\n\r\nBoth can then be imported with `const authenticate = require('...')` and used in the above `router.post` example.\r\n\r\nWhich way of writing this middleware (1 or 2) is preferred?"
      },
      {
        "user": "wesleytodd",
        "created_at": "2018-03-28T15:55:48Z",
        "body": "I don't think there is a preference at the framework level.  In your application, it is sometimes nice to break up your middelware into multiple files, and both ways you show have pros and cons.  \r\n\r\nPersonally I prefer to have my application middleware each in their own file, then use a `routes.js` file to tie them all together.  But that is just a way I have organized them, not a \"preferred way\".  Hope that helps."
      },
      {
        "user": "czaarek99",
        "created_at": "2018-04-14T15:24:03Z",
        "body": "I'd say it completely depends on how you like to organize things. I agree with @wesleytodd \r\nThis is more of a question of coding style, pick something that suits you and something and that works."
      }
    ]
  },
  {
    "number": 3588,
    "title": "Phantom console.error",
    "created_at": "2018-03-13T23:04:04Z",
    "closed_at": "2018-03-13T23:33:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3588",
    "body": "I'm getting a strange output in my error logs, just a random \"200\" on it's own line without a stack trace or anything. I tracked it down to:\r\n\r\n    EventEmitter.logerror (lib/application.js:606:43)\r\n\r\nAny ideas what could be causing this?\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3588/comments",
    "author": "jwerre",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-03-13T23:07:18Z",
        "body": "Werid. There are many ways to cause this, since it's the error logger, including something as simple as \"next(200)\" since the number 200 is being passed back to Express as an error. You should be able to attach a debugger and put a break point there to see where it comes from. I can also help out if you're able to provide an example app doing this :+1:"
      },
      {
        "user": "jwerre",
        "created_at": "2018-03-13T23:15:51Z",
        "body": "That bit of insight actually helped. I was calling next(200) twice. The second was probably being caught by `logerror`. Thanks for the quick reply."
      },
      {
        "user": "dougwilson",
        "created_at": "2018-03-13T23:33:56Z",
        "body": "No problem. Yea, the if you keep calling `next(err)` it will end up in our catch-all so they don't get silently swallowed."
      }
    ]
  },
  {
    "number": 3586,
    "title": "Error: Coordinates out of range",
    "created_at": "2018-03-07T22:46:03Z",
    "closed_at": "2018-03-08T01:16:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3586",
    "body": "I'm getting an error when trying to setup a dynamic map\r\n\r\n```\r\napp.get('/tileserver/:layer/:z/:x/:y/tile.png', function (req, res, next) {\r\n    const layer = req.params.layer;\r\n    const z = req.params.z;\r\n    const x = req.params.x;\r\n    const y = req.params.y;\r\n\r\n    const stra = tilestrata();\r\n    stra.layer(layer)\r\n        .route('tile@2x.png')\r\n            .use(disk.cache({dir: '../cache/basemap'}))\r\n            .use(mapnik({\r\n                pathname: 'maps/example.xml',\r\n                tileSize: 512,\r\n                layer: 'all',\r\n                scale: 2\r\n            }))\r\n        .route('tile.png')\r\n            .use(disk.cache({dir: '.../cache/basemap'}))\r\n            .use(dependency(layer, 'tile@2x.png'))\r\n            .use(sharp(function(image, sharp) {\r\n                return image.resize(256);\r\n            }));\r\n    stra.listen();    \r\n    stra.getTile(layer, 'tile.png', z, x, y, function(err, img){\r\n        //stra.close();\r\n        if (err) {\r\n            console.log(err);\r\n            res.statusCode = 401;\r\n            res.send('None shall pass');\r\n        } else {\r\n            res.writeHead(200, {\r\n                'Content-Type': 'image/png',\r\n                'Content-Length': img.length\r\n            });\r\n            res.end(img); \r\n        }\r\n    });\r\n});\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3586/comments",
    "author": "jvaldezch",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-03-07T23:37:44Z",
        "body": "Hi @jvaldezch.  I do not see anything here that could be an express related error, we do not have any \"coordinates out of range\" error.  Are you sure you posted in the correct location?  Maybe you meant to post this on whichever map library you are using?"
      },
      {
        "user": "jvaldezch",
        "created_at": "2018-03-08T00:22:48Z",
        "body": "@wesleytodd was my mistake:\r\n\r\nstra.getTile(layer, 'tile.png', x, y, z, function(err, img){\r\n\r\nIt was XYZ order which differs from ZXY from GET request."
      }
    ]
  },
  {
    "number": 3577,
    "title": "Issue with ExpressJS and timeout",
    "created_at": "2018-02-27T07:29:57Z",
    "closed_at": "2018-03-01T01:43:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3577",
    "body": "I get an issue with ExpressJS. I get an error message when uploading large files...\r\n\r\n**Error message :**\r\n\r\n> Bad Gateway\r\n> The proxy server received an invalid response from an upstream server.\r\n> Apache/2.4.7 (Ubuntu) Server at xxxxxxxxx Port 80\r\n\r\nEverything works when the connexion of the user is above 3G...\r\n\r\nIs there any configuration to do on my Apache or about ExpressJS options ?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3577/comments",
    "author": "antho227",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-02-27T17:28:08Z",
        "body": "Sounds like a timeout from Apache.  Look into apache's setting for timeouts, and up them for this upload route."
      }
    ]
  },
  {
    "number": 3576,
    "title": "Cannot res.send / res.json a javascript set",
    "created_at": "2018-02-26T19:13:07Z",
    "closed_at": "2018-02-26T19:16:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3576",
    "body": "I am trying to res.send or res.json a javascript set.  The set should have items in it but is empty when it gets to the client.  Here is my code:\r\n\r\n```\r\napp.get('/test-endpoint', function(req, res) {\r\n    let set1 = new Set();\r\n    set1.add('SOME ITEM');\r\n    console.log('Set 1:', set1);  // logs out set1 correctly in the terminal (Set 1 Set: { 'SOME ITEM' })\r\n\r\n    res.json(set1);  // when this gets to the client side it is an empty set ({})\r\n});\r\n```\r\nIs this a problem with res.json / res.send?\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3576/comments",
    "author": "erictraub",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-02-26T19:16:19Z",
        "body": "This is just how Node.js treats sets: `JSON.stringify` will make them `{}`:\r\n```\r\nnode\r\n> let set1 = new Set();\r\nundefined\r\n> set1.add('SOME ITEM');\r\nSet { 'SOME ITEM' }\r\n> set1\r\nSet { 'SOME ITEM' }\r\n> JSON.stringify(set1);\r\n'{}'\r\n> \r\n```"
      }
    ]
  },
  {
    "number": 3565,
    "title": "Post request flood?",
    "created_at": "2018-02-14T08:47:11Z",
    "closed_at": "2018-02-15T11:22:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3565",
    "body": "Introduction\r\n================\r\nI´ve a nodejs application with express that have some post and get request. The whole website works just fine without problems.\r\n\r\nProblem\r\n============\r\nIf I call the post request to much in time the site will crash. It will not respond to other requests. Doesn´t matter if it´s get or post request. I just can close the tab and open the site in a new one. Then it work again.\r\n\r\nMy Code\r\n===========\r\n\r\n## Client side ##\r\nIt´s a easy post request to set a client permission. There is no callback defined.\r\n\r\n    $.post(\r\n       '/clients/set/client/permission',\r\n       {\r\n          permName: globPermissionTable[permName],\r\n          value: checked,\r\n          id: '<%= data[0].id %>'\r\n       }\r\n    );\r\n\r\n----------\r\n\r\n## Server side ##\r\nJust a easy post segment. Even if I will uncomment all in the request it will be not response.\r\n\r\n    app.post('/clients/set/client/permission', function(req, res) {\r\n\t   // Permissioncheck\r\n\t   /*var permName = req.body.permName, val = req.body.value, id = req.body.id;\r\n\t   if(helper.checkParams([permName, val, id])) {\r\n\t\t     database.SetClientPermissions(parseInt(id), permName, (val === 'true') ? true : false);\r\n\t   };*/\r\n    });",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3565/comments",
    "author": "lgund",
    "comments": [
      {
        "user": "lgund",
        "created_at": "2018-02-14T08:58:33Z",
        "body": "I found out now that if a write _res.send('finished');_ this problem doesn´t happen. If it´s that important to always send something back?\r\n\r\n-----------\r\nFull Code:\r\n`app.post('/clients/set/client/permission', function(req, res) {\r\n   res.send('finished');\r\n});`"
      },
      {
        "user": "wesleytodd",
        "created_at": "2018-02-14T21:50:51Z",
        "body": "Yes, you always need to send a response.  Otherwise the connection will remain open waiting for that response.  If you are not going to handle a request in a middleware, you can also just call `next` and allow express to respond for you with a 404:\r\n\r\n```\r\napp.post('/foo', function (req, res, next) {\r\n  if (something) {\r\n    return res.send('response');\r\n  }\r\n  next();\r\n});\r\n```"
      },
      {
        "user": "lgund",
        "created_at": "2018-02-15T11:22:27Z",
        "body": "Thanks. That helped a lot!"
      }
    ]
  },
  {
    "number": 3548,
    "title": "npm error : Failed to parse package.json data",
    "created_at": "2018-01-30T15:09:06Z",
    "closed_at": "2018-01-31T20:34:47Z",
    "labels": [
      "question",
      "awaiting more info"
    ],
    "url": "https://github.com/expressjs/express/issues/3548",
    "body": "Can anyone help me please i tried `npm cache clean` but didn't work for me... this is what my package.json looks like \r\n`\r\n{\r\n    \"name\": \"app-name\",\r\n    \"version\": \"0.1.0\",\r\n    \"description\": \"My Description\",\r\n    \"engines\": {\r\n      \"node\": \"6.11.1\"\r\n    },\r\n    \"main\": \"server.js\",\r\n    \"scripts\": {\r\n      \"start\": \"node server.js\"\r\n    },\r\n    \"dependencies\": {\r\n      \"body-parser\": \"^1.15.2\",\r\n      \"cors\": \"^2.8.0\",\r\n      \"del\": \"2.2.0\",\r\n      \"express\": \"^4.14.0\",\r\n      \"http\": \"0.0.0\",\r\n      \"method-override\": \"^2.3.6\",\r\n      \"morgan\": \"^1.7.0\"\r\n    }\r\n  }\r\n`\r\nand this is the error occured after `npm install`\r\n`\r\nnpm ERR! file C:\\Users\\Toshiba\\Desktop\\ionicproj\\server\\package.json\r\nnpm ERR! code EJSONPARSE\r\nnpm ERR! Failed to parse json\r\nnpm ERR! Unexpected token   in JSON at position 4 while parsing near '{npm ERR!     \"name\": \"app-name\"...'\r\nnpm ERR! File: C:\\Users\\Toshiba\\Desktop\\ionicproj\\server\\package.json\r\nnpm ERR! Failed to parse package.json data.\r\nnpm ERR! package.json must be actual JSON, not just JavaScript.\r\nnpm ERR!\r\nnpm ERR! Tell the package author to fix their package.json file. JSON.parse\r\n\r\nnpm ERR! A complete log of this run can be found in:\r\nnpm ERR!     C:\\Users\\Toshiba\\AppData\\Roaming\\npm-cache\\_logs\\2018-01-30T14_34_29_827Z-debug.log\r\n`",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3548/comments",
    "author": "shahraZd",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-01-30T17:44:13Z",
        "body": "Hi @shahraZd.  It looks like you have an error in your `package.json`.   Although in the above code I dont see it.  Are you sure this is the `package.json` which lives at `C:\\Users\\Toshiba\\Desktop\\ionicproj\\server\\package.json`?"
      },
      {
        "user": "shahraZd",
        "created_at": "2018-01-31T18:47:44Z",
        "body": "yes i  am pretty sure i have only one  package.json in that folder"
      },
      {
        "user": "wesleytodd",
        "created_at": "2018-01-31T20:34:47Z",
        "body": "Well there is no other cause of this error.  So I would check it again.  And there is pretty much no way this is an express error.  So I am going to close this.  If you are unable to find the cause yourself, I suggest posting to stackoverflow, as this is not technically a support channel.  Good luck!"
      },
      {
        "user": "GenericJam",
        "created_at": "2018-07-18T13:56:11Z",
        "body": "If some other lost soul lands here... try deleting the package-lock.json file. That worked for me. It's not npm that is the problem even though it seems like it. The super cryptic error message isn't too helpful."
      }
    ]
  },
  {
    "number": 3539,
    "title": "npm start <filename>",
    "created_at": "2018-01-20T15:29:26Z",
    "closed_at": "2018-02-14T00:44:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3539",
    "body": "var express = require('express');\r\n\r\nI am just using this much code in my server.js file and after running\r\n\r\nnpm install express successfully. I ran\r\nnpm start server.js then it throws error as:\r\n\r\nmeanproject@1.0.0 start D:\\dinkar\\node_js_installed\\npm_setup\r\nnode server.js \"server.js\"\r\n\r\nD:\\dinkar\\node_js_installed\\npm_setup\\server.js:1\r\n(function (exports, require, module, __filename, __dirname) { ��v\r\n^\r\n\r\nSyntaxError: Invalid or unexpected token\r\nat createScript (vm.js:80:10)\r\nat Object.runInThisContext (vm.js:139:10)\r\nat Module._compile (module.js:599:28)\r\nat Object.Module._extensions..js (module.js:646:10)\r\nat Module.load (module.js:554:32)\r\nat tryModuleLoad (module.js:497:12)\r\nat Function.Module._load (module.js:489:3)\r\nat Function.Module.runMain (module.js:676:10)\r\nat startup (bootstrap_node.js:187:16)\r\nat bootstrap_node.js:608:3\r\nnpm ERR! code ELIFECYCLE\r\nnpm ERR! errno 1\r\nnpm ERR! meanproject@1.0.0 start: node server.js \"server.js\"\r\nnpm ERR! Exit status 1\r\nnpm ERR!\r\nnpm ERR! Failed at the meanproject@1.0.0 start script.\r\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\r\n\r\nnpm ERR! A complete log of this run can be found in:\r\nnpm ERR! C:\\Users\\NITIKA\\AppData\\Roaming\\npm-cache_logs\\2018-01-19T19_51_14_091Z-debug.log\r\nWhy this is happening on simple code? Is something missing in it!\r\nThanks for any kind of suggestions",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3539/comments",
    "author": "nitikabhanot",
    "comments": [
      {
        "user": "jbielick",
        "created_at": "2018-01-21T17:19:11Z",
        "body": "It looks like you have invalid characters in your file:\r\n\r\n```\r\nD:\\dinkar\\node_js_installed\\npm_setup\\server.js:1\r\n(function (exports, require, module, __filename, __dirname) { ��v\r\n```\r\n\r\n`��v` should not be there. This has nothing to do with express.js."
      },
      {
        "user": "WORMSS",
        "created_at": "2018-01-23T13:18:55Z",
        "body": "@nitikabhanot It could be a BOM (Byte Order Mark) ?? "
      },
      {
        "user": "alissonbovenzo",
        "created_at": "2018-01-30T20:14:17Z",
        "body": "@nitikabhanot U can share in a gist ur server.js ?"
      },
      {
        "user": "dougwilson",
        "created_at": "2018-02-14T00:44:29Z",
        "body": "Closing since @nitikabhanot never responded."
      }
    ]
  },
  {
    "number": 3506,
    "title": "res.send(number) to not override statusCode if already defined by res.status(code)",
    "created_at": "2017-12-11T18:08:53Z",
    "closed_at": "2017-12-11T18:13:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3506",
    "body": "The problem:\r\n\r\n```\r\nres.status(200).send(1000)\r\n```\r\n\r\nreturns\r\n\r\n```\r\ninvalid status code: 1000\r\n```\r\n\r\nThis prevents sending a number as response without converting to string before. If `statusCode` was set by `res.status(code)`, it should handle the number without override the statusCode.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3506/comments",
    "author": "igorprado",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-12-11T18:13:03Z",
        "body": "Yea, but that change would be a breaking change. I would suggest making this change in 5.0, but in 5.0 `res.send(number)` no longer changes the status code at all to that number, so effectively this issue is resolved in 5.0. This is available in 5.0.0-alpha.1 and higher 🎉 "
      }
    ]
  },
  {
    "number": 3498,
    "title": "Rendering public/index.html file instead of index.pug. Why?",
    "created_at": "2017-12-05T18:19:51Z",
    "closed_at": "2018-10-27T17:45:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3498",
    "body": "**_First of all, thank you for this awesome framework!_**\r\n\r\nHello, guys. I have a bit misunderstanding about this. Consider this situation...\r\n\r\n```\r\nconst express = require('express');\r\nconst app = express();\r\n\r\napp.set('view engine', 'pug');\r\napp.use(express.static('public'));\r\n\r\napp.get('/', (req, res, next) => res.render('index.pug'))\r\n   .listen(3000);\r\n```\r\n\r\nThen, on views/index.pug...\r\n```\r\nhtml(lang=\"en\")\r\n    head\r\n        meta(charset=\"UTF-8\")\r\n        meta(name=\"viewport\", content=\"width=device-width, initial-scale=1.0\")\r\n        meta(http-equiv=\"X-UA-Compatible\", content=\"ie=edge\")\r\n        title Document\r\n    body\r\n        h1 HTML from views/ directory\r\n````\r\n\r\nFinally, on public/index...\r\n```\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\r\n    <title>Document</title>\r\n</head>\r\n<body>\r\n    <h1>HTML from public/</h1>     \r\n</body>\r\n</html>\r\n```\r\nWhy the browser renders the public index file instead of views/index.pug file?\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3498/comments",
    "author": "GianCastle",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-12-05T18:23:48Z",
        "body": "Hi! Express will execute your statements from top to bottom, stopping once something is fulfilled.\r\n\r\nYour code line\r\n\r\n    app.use(express.static('public'));\r\n\r\nWill end up responding because if the request is GET / then static will look for an index.html file in your public directory.  Since you have one, that ends the response.\r\n\r\nThere are a coulpe different things you can do:\r\n\r\n1. Move your render above that to make it match first.\r\n2. Turn off thr index feature to just not use index.html files at all."
      }
    ]
  },
  {
    "number": 3492,
    "title": "Getting undefined on req.body",
    "created_at": "2017-12-01T23:27:09Z",
    "closed_at": "2018-02-14T02:12:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3492",
    "body": "`var express    = require('express');   \r\nvar app        = express();               \r\nvar bodyParser = require('body-parser');\r\nvar mysql = require('mysql');\r\nvar md5 = require('MD5');\r\nvar con = mysql.createConnection({\r\n  host: \"localhost\",\r\n  user: \"shoaib\",\r\n  password: \"\",\r\n  database: \"watch\"\r\n});\r\n\r\ncon.connect(function(err) {\r\n  if (err) throw err;\r\n  console.log(\"Connected!\");\r\n});\r\n\r\n\r\nvar urlencodedParser = bodyParser.urlencoded({ extended: false })\r\nvar port = process.env.PORT || 8080;        \r\nvar router = express.Router();  \r\nrouter.post('/',urlencodedParser,function(req, res) {\r\n res.setHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n  con.connect(function(err) {\r\n  \tvar query = \"Select * From user Where email=? AND password=?\";\r\n  \t var table = [req.body.email,req.body.password ];\r\n  \t console.log(req.body[0]);\r\n\r\n        query = mysql.format(query, table);\r\n        con.query(query, function (err, rows) {\r\n            if (err) {\r\n                res.json({ \"Error\": true, \"Message\": \"Error executing MySQL query\" });\r\n            } else if(rows!=0) {\r\n                res.json({ \"Error\": false, \"Message\": \"Success\",\"Users\": rows });\r\n            } else {\r\n                res.json({ \"Error\": true,});\r\n            }\r\n        });\r\n    });\r\n  });\r\n\r\napp.use('/api', router);\r\napp.listen(port);\r\nconsole.log('Magic happens on port ' + port);`",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3492/comments",
    "author": "shoaib086",
    "comments": [
      {
        "user": "priidikvaikla",
        "created_at": "2017-12-03T17:25:18Z",
        "body": "Perhaps when you are doing / POST, the header `Content-Type: application/x-www-form-urlencoded` is not set?"
      },
      {
        "user": "gntem",
        "created_at": "2017-12-12T10:45:26Z",
        "body": "Kinda of old issue but this looks relatively simple code, so i see no reason why it wont work, try turning on debug output in express and watch the request headers in browser developer tools it should give you enough clues."
      },
      {
        "user": "dougwilson",
        "created_at": "2018-02-14T02:12:20Z",
        "body": "Closing since never heard back from the OP."
      }
    ]
  },
  {
    "number": 3477,
    "title": "route.get cannot match url",
    "created_at": "2017-11-14T09:15:55Z",
    "closed_at": "2017-11-14T13:11:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3477",
    "body": "This is the code in index.js\r\n```\r\nvar express = require('express');\r\nvar router = express.Router();\r\n\r\n/* GET home page. */\r\nrouter.get('/', function(req, res, next) {\r\n  res.render('index', { title: 'Express' });\r\n});\r\n\r\nrouter.get('/test', function(req, res, next, value) {\r\n\r\n    res.json({test:'test1'});\r\n});\r\n\r\nrouter.get('/test', function(req, res, next) {\r\n    res.json({test: 'test2'});\r\n});\r\n\r\nmodule.exports = router;\r\n```\r\n## Expected behavior\r\nreturn `{test:'test1'}` and ` value = undefined ` or throw  an Error。\r\n\r\n## Actual behavior\r\nreturn  `{test:'test2'}` and no error，if I remove \r\n```\r\nrouter.get('/test', function(req, res, next) {\r\n    res.json({test: 'test2'});\r\n});\r\n```\r\njust get a 404，it is hard to debug.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3477/comments",
    "author": "jimczj",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-11-14T13:11:24Z",
        "body": "If you provide a function that takes 4 arguments it is an error handlig middleware, not a route handler. Remove the \"value\" argument from your function declaration :)"
      }
    ]
  },
  {
    "number": 3446,
    "title": "Express 5 router strange behavior (parameters)",
    "created_at": "2017-10-09T23:30:56Z",
    "closed_at": "2017-10-10T12:41:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3446",
    "body": "Hi.\r\n\r\nI have pretty simple code to compare express route parameters (wich uses \"router\" package) and path-match, both use path-to-regexp under the hood.\r\n```javascript\r\nimport Pathmatch from 'path-match'\r\n\r\nconst routeMatch = Pathmatch({\r\n\tsensitive: false,\r\n\tstrict: false,\r\n\t// end: false\r\n})('/api/:module/:s*');\r\n\r\napp.get('/api/:module/:s*', (req, res) => {\r\n\tconst pr = {};\r\n\tpr['srv'] = req.params;\r\n\tpr['lib'] = routeMatch(req.path);\r\n\r\n\tres.json(pr);\r\n});\r\n```\r\nand i get strange results with path \"/api/about/first/second\":\r\n\r\n```\r\n{\r\n  \"srv\":{\r\n    \"0\": \"/second\",\r\n    \"module\": \"about\",\r\n    \"s\":\"first\"\r\n  },\r\n  \"lib\":{\r\n    \"module\": \"about\",\r\n    \"s\":[\"first\",\"second\"]\r\n  }\r\n}\r\n```\r\nAlso express doesnt handle path \"/api/about\" in that case.\r\nThats a bug or my missunderstanding of concepts?\r\n\r\n--\r\nExpress 5 alpha-6\r\nRouter 1.3.2\r\nPath-match 1.2.4",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3446/comments",
    "author": "IamFake",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-10-10T03:27:51Z",
        "body": "It looks like this is because of the version of `path-to-regexp` Express is currently using. That version defines the `*` character in the path as it's own expression, not part of the `:s` name. In other words, it see the route `/api/:module/:s*` as the pieces `/api/`, `:module`, `/`, `:s`, and `*`, so you get `:module` as a named match in the second segment, `:s` as a named mated in the third segment, and all the rest of the URL is slurped up into a positional match (`0` since it's the first positional one)."
      },
      {
        "user": "IamFake",
        "created_at": "2017-10-10T12:41:49Z",
        "body": "Oh, i've forgot that there may be \"local\" node_modules that \"replaces\" the project's node_modules. I thought it uses project global scope."
      }
    ]
  },
  {
    "number": 3433,
    "title": "error handled at unknown error handler",
    "created_at": "2017-09-27T18:28:29Z",
    "closed_at": "2017-09-27T19:00:58Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3433",
    "body": "express version : 4.15,\r\nnode version: 8.1.4\r\n\r\nim currently experiencing an odd behavior within my application, I have nested routes and im defining my routes like this\r\n\r\n```js\r\nconst router = require('express').Router();\r\nconst m = require('../modules/index').v1;\r\n\r\nrouter.route('/')\r\n  .post(m.create)\r\n  .get(m.list)\r\n  .all(m.transformer);\r\n\r\nrouter.route('/:id')\r\n  .all(m.middlewareById)\r\n  .put(m.editById)\r\n  .delete(m.deleteById)\r\n  .get(m.getById)\r\n  .all(m.transformer);\r\nmodule.exports = router;\r\n```\r\nIm currently developing m.create API controller, and when and error occurs that is not handled sends me a response of HTML page with error object. \r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n    <head>\r\n        <meta charset=\"utf-8\">\r\n        <title>Error</title>\r\n    </head>\r\n    <body>\r\n        <pre>[object Object]</pre>\r\n    </body>\r\n</html>\r\n```\r\nI want to eliminate this behavior and response with JSON only, but somehow its by passing my defined request handlers, and instead of getting handled at a middle ware that I specify, or the one at `app.js` \r\nits is being handled somewhere else mysteriously, i've been express user for 3 or more years and this is the first time im facing such behavior.\r\nhas something changed in new Express version? \r\n\r\n_app.js_\r\n```js\r\nconst express = require('express');\r\nconst path = require('path');\r\n// const favicon = require('serve-favicon');\r\nconst logger = require('morgan');\r\nconst cookieParser = require('cookie-parser');\r\n...\r\n\r\napp.use('/', index);\r\napp.use('/systemadmin', systemAdminRoutes);\r\n\r\n// catch 404 and forward to error handler\r\napp.use((req, res, next) => {\r\n  const err = new Error('Not Found');\r\n  err.status = 404;\r\n  next(err);\r\n});\r\n\r\n// error handler\r\napp.use((err, req, res) => {\r\n  // next is the last argument in above function\r\n  // set locals, only providing error in development\r\n  // res.locals.message = err.message;\r\n  // res.locals.error = req.app.get('env') === 'development' ? err : {};\r\n  debug(err); // nothing logs here \r\n  debug(err.message);\r\n  debug(err.name);\r\n  debug(err.errorCode);\r\n  debug(err.stack);\r\n  // render the error page\r\n  res.status(err.status || 500);\r\n  res.send({error: err.message}); //this never gets called\r\n});\r\n\r\nmodule.exports = app;\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3433/comments",
    "author": "muhammadfaizan",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-09-27T18:31:28Z",
        "body": "Maybe you ran a linter on your code recently? Your code above you have\r\n```js\r\napp.use((err, req, res) => {\r\n```\r\n\r\nBut (which has always been in the case), it MUST have 4 arguments in order to work:\r\n```js\r\napp.use((err, req, res, next) => {\r\n```"
      },
      {
        "user": "muhammadfaizan",
        "created_at": "2017-09-27T19:00:58Z",
        "body": "@dougwilson this is insane ! \r\nThanks by the way :)\r\nIt did work. "
      }
    ]
  },
  {
    "number": 3432,
    "title": "In-place Express update to 4.15.5 still has old forwarded",
    "created_at": "2017-09-27T16:54:34Z",
    "closed_at": "2017-09-28T17:46:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3432",
    "body": "Hello, I'm writing to request an update for the dependency proxy-addr to a version, like version 2.0.2, that has the security patched version of forwarded in it's dependencies., 0.1.2. \r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3432/comments",
    "author": "JaneCoder",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-09-27T18:06:09Z",
        "body": "The semver range already covers the patched version. Simply upgrading to 4.15.5 will force the new version of the dependency."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-09-27T18:07:47Z",
        "body": "The plan is to include proxy-addr 2.0.2 in Express.js 4.16 on Monday Oct 2, but until then installing a fresh Express.js 4.15.5 will drop you forwarded 0.1.2 in your tree."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-09-27T18:12:28Z",
        "body": "If it helps, here is what the `forwarded` tree looks like for an install of Express 4.15.5:\r\n```\r\n$ npm i express\r\n+ express@4.15.5\r\nadded 42 packages in 3.213s\r\n\r\n$ npm ls forwarded\r\nexpress-3432\r\n└─┬ express@4.15.5\r\n  └─┬ proxy-addr@1.1.5\r\n    └── forwarded@0.1.2 \r\n```\r\n\r\nLet me know if there is still something you need or if there is something preventing you from picking up the correct version of `forwarded` in your installation of 4.15.5, and I'm happy to get you onto the correct version 👍 "
      },
      {
        "user": "dougwilson",
        "created_at": "2017-09-27T18:27:38Z",
        "body": "Ok, so I've been experimenting a bit, and definitely with npm@5 getting a simple command to bump `forwarded` on a non-clean express install is not straight forward. The only command that actually worked was `npm i --no-save forwarded@0.1.2`, but that assumes what you actually need to do.\r\n\r\nI think that even if this causes the \"mime\" fixed to be delayed, juggling around the dependencies more and getting an Express 4.15.6 that have all semver ranges to not allow `forwarded < 0.1.2` may be the only ideal way to resolve this for a lot of folks."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-09-27T18:51:28Z",
        "body": "This certainly will make me think about bothering with semver ranges at all any more. Having ranges instead of a specific version adds risk to the install, but it's generally been argued that the trade off of getting security updates is worth it. This seems to indicate that it really only helps users who don't already have it installed, and the existing user base cannot take advantage of it as easily :("
      },
      {
        "user": "JaneCoder",
        "created_at": "2017-09-27T20:05:21Z",
        "body": "Yes, that is an interesting paradox. Thank you so much for your help.\r\nYou rock, digging into it like this. Sorry I did not get back to you sooner.  "
      },
      {
        "user": "dougwilson",
        "created_at": "2017-09-28T19:53:11Z",
        "body": "Express.js 4.16.0 is out now where the `forwarded` ranges don't include anything below 0.1.2 🎉 "
      }
    ]
  },
  {
    "number": 3420,
    "title": "Defining a router-specific error handler",
    "created_at": "2017-09-20T17:44:59Z",
    "closed_at": "2017-09-20T20:41:48Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3420",
    "body": "hi there,\r\n\r\nI would like a little advice on the correct way to define a error handler for a specific router (my use case is a webapp with \"normal\" html routes, and a route `/api` where a new Router instance is attached that only deals in JSON output):\r\n\r\nI am using `Express v4.15.3`, is the following conceptually what I should be doing? :\r\n\r\n```js\r\nconst r = Router;\r\n\r\nr.get('/users', (req, res, next) { res.send({ users : []}); }\r\n\r\n// ... more routes ...\r\n\r\n// add error handler last so that all errors fall into it\r\nr.use((req, res, next, err) { res.send(outputJsonApiError(err)); });\r\n\r\napp.use('/api', r);\r\n```\r\n\r\n\r\nP.S. I have searched the docs and the issues lists but failed to have a \"lightbulb moment\"(tm) ... sorry for the noise (I always struggle a bit with express error handling - in the past I have ended up with a footgun more than once!)",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3420/comments",
    "author": "iamjochem",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-09-20T18:40:06Z",
        "body": "Yea, that would work. Just kind in mine that the routes will run in the order you declared, so you may want to swap the `r.use` with the `r.get` in your example above so the error handler is the last thing in your router so errors that occur in your routes will fall into the error handler."
      },
      {
        "user": "iamjochem",
        "created_at": "2017-09-20T20:41:48Z",
        "body": "@dougwilson - thank you for clarifying (& so quickly)! \r\n\r\nI edited my original post to reflect your comment just in case anyone stumbles across it - I did know about handler ordering but I wasn't thinking when I wrote the snippet)."
      }
    ]
  },
  {
    "number": 3404,
    "title": "not works when use regular exp or set \"/\" to exclude path.",
    "created_at": "2017-08-31T02:14:06Z",
    "closed_at": "2017-08-31T02:34:20Z",
    "labels": [
      "4.x",
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/3404",
    "body": "Express version:4.15.4 ,nodeJs version：6.11\r\n\r\n. 1 look the following code. I use a regular exp to match a path and route the request to pageRouter.When I request the localhost:8000/new, the regular EXP looks not work, but I have test the EXP use /^\\/(?!api$\\|api\\/.*\\|resource$\\|resource\\/.*)/.test('/new'), it return true. and if I use /(?!api$\\|api\\/.*\\|resource$\\|resource\\/.*)/ it works but that against with the api doc. \r\n```\r\nrouter.use('/api',apiRouter);\r\nrouter.use('/resource',resourceRouter);\r\nrouter.use(/^\\/(?!api$|api\\/.*|resource$|resource\\/.*)/,pageRouter);\r\n\r\npageRouter.get(\"*\",(req,resp,next)=>{let name = req.originalUrl...})\r\n\r\n```\r\n. 2  look the following code. The request first through the `resourceRouter ` then through `pageRouter` but I think that should be just through the `resourceRouter `.\r\n```\r\nrouter.use('/api',apiRouter);\r\nrouter.use('/resource',resourceRouter);\r\nrouter.use(\"/\",pageRouter);\r\n\r\npageRouter.get(\"*\",(req,resp,next)=>{let name = req.originalUrl...})\r\n```\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3404/comments",
    "author": "sinbargit",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-08-31T02:34:20Z",
        "body": "HI @sinbargit the issue with your regular expression is how `.use` works. It is not just a matter of does the regular expression match the input, but since `.use` needs to strip down the matched path, it expects your match to stop before a `/` character to cut on.\r\n```\r\n$ node -pe \"/^\\/(?!api$|api\\/.|resource$|resource\\/.)/.exec('/test')\"\r\n[ '/', index: 0, input: '/test' ]\r\n```\r\nThe regular expression on your URL is matching one character, which makes the cut-off point the character `t`, which is not a `/` character. If you want to continue down the regular expression path, the easiest solution is to just adjust the regular expression to match just the part you want to cut off prior to entering the `pageRouter`. If you want to cut nothing (i.e. enter the `pageRouter` with the full URL), then use `/^(?!\\/api$|\\/api\\/.|\\/resource$|\\/resource\\/.)/`.\r\n\r\nI hope this helps!"
      }
    ]
  },
  {
    "number": 3381,
    "title": "Question: Why does the express router call the params keys?",
    "created_at": "2017-08-01T19:50:47Z",
    "closed_at": "2017-09-25T06:14:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3381",
    "body": "So I am debugging how to test an express router object. Essentially to have 100% coverage. Anyways, what I noticed while debugging is that the router object creates a stack of routes. Cool, except when I look at the stack, `params` are undefined while `keys` is an array of my params. Pretty misleading. Then in my service, I can request these so called `keys` as `req.params`.\r\n\r\nJust wonder why the params do not get populated here. Is this params property only for inherited params? like from `router.param`",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3381/comments",
    "author": "JemiloII",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-08-01T19:56:49Z",
        "body": "Well, the names of those properties were from before I managed Express.js so I don't know why, only that they are and changing them is not simple with a lot of code floating around using those properties. "
      },
      {
        "user": "kevinkassimo",
        "created_at": "2017-08-03T10:10:59Z",
        "body": "Do you mean `router.params`? This contains only all callbacks added through `router.param()`. In `lib/router/index.js`\r\n```javascript\r\nproto.param = function param(name, fn) {\r\n    //...\r\n    (this.params[name] = this.params[name] || []).push(fn);\r\n    return this;\r\n}\r\n```\r\nOr do you mean `layer.params` of each layer stored on `router.stack`? In this case, in `function Layer()` of `lib/router/layer.js`\r\n```javascript\r\nthis.regexp = pathRegexp(path, this.keys = [], opts); // regexp group fills this.keys with parameter names\r\n```\r\n`layer.params` is only populated as `layer.params[paramName] === paramValue` when `layer.match()` is called in `router.handle()` (aka `router()`), and that a match exist to the corresponding path. I am not quite sure what could have been the problem, but I would suggest checking the source code of `Layer.prototype.match()` in `lib/router/layer.js` and possibly `proto.handle()` in `lib/router/index.js`, to get a better understanding of them.\r\n\r\n"
      },
      {
        "user": "JemiloII",
        "created_at": "2017-08-06T21:38:28Z",
        "body": "@kevinkassimo so the in the stack the params will get populated once the route is being navigated to? While the keys are simply there for reference? Also thanks for the direction of where to read."
      },
      {
        "user": "kevinkassimo",
        "created_at": "2017-08-07T04:14:21Z",
        "body": "@JemiloII In `Layer.prototype.match()` of `router/layer.js`,\r\n```javascript\r\nLayer.prototype.match = function match(path) {\r\n  var match\r\n\r\n  if (path != null) {\r\n    //...\r\n    match = this.regexp.exec(path) // try match the path\r\n  }\r\n\r\n  if (!match) { // current match failed, layer.params is undefined and not populated\r\n    this.params = undefined;\r\n    this.path = undefined;\r\n    return false;\r\n  }\r\n  // If matched\r\n  var keys = this.keys;\r\n  var params = this.params;\r\n\r\n  for (var i = 1; i < match.length; i++) {\r\n    var key = keys[i - 1];\r\n    var prop = key.name;\r\n    var val = decode_param(match[i]) // using the grouping of regexp\r\n\r\n    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {\r\n      params[prop] = val; // populate layer.params HERE!\r\n    }\r\n  }\r\n  return true;\r\n}\r\n```\r\nAlso after reviewing the logic of `router.handle()`, I believe the steps could indeed be understood as:  \r\n1. `router.handle()` is invoked with a new given path that requires inspection  \r\n2. A path match on some layer stored on the stack is found  \r\n2.1 before this path match returned true, `layer.params` is populated using the param names stored in `layer.keys` as keys to establish key value mappings  \r\n3. `router.handle` then merges current `layer.params` into `req.params`  \r\n3.1 `router.handle` first try processing all param handlers added through `router.param()`  \r\n3.2 `router.handle` then calls your provided path handlers, by internally calling `layer.handle_request(req, res, next)`, and that all param data could be accessed through `req.params`  \r\n4. if you call `next()` in your provided handler, the `router.handle()` continues tracing down the `router.stack`. For each extra match, goto 2. Else done.\r\n\r\nSo basically I believe you are correct."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-09-25T06:14:27Z",
        "body": "So following along here, I think the original question is answered. If not, please let us know and the issue can be reopened."
      }
    ]
  },
  {
    "number": 3378,
    "title": "Cannot GET /texts.ejs when trying to navigate to linked html page",
    "created_at": "2017-07-29T02:20:28Z",
    "closed_at": "2017-08-01T03:43:27Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3378",
    "body": "I have a navbar in my app linking to different pages within the same app. These are all kept in my `views` folder in my root directory. They are all html files. However, when I run a node server and try to access another html file in the `views` directory linked to the `index.html` file, I get `Cannot GET /texts.html`.\r\n\r\nI know this may seem trivial but I don't know much about Express. My code:\r\n\r\n```javascript\r\nvar express = require('express');\r\nvar app = express();\r\nvar path = require('path');\r\nconst VIEWS = path.join(__dirname, 'views');\r\nvar port = process.env.PORT || 8080;\r\n\r\napp.set('views', VIEWS);\r\napp.set('view engine', 'html');\r\napp.use(express.static('public'));\r\n\r\napp.use(express.static(path.join(__dirname, 'public')));\r\n\r\napp.get('/', function (req, res) {\r\n  res.sendFile('index.html', { root : VIEWS });\r\n});\r\n\r\n\r\n// app.get(\"/faq\", function (req, res) {\r\n//   res.sendFile('faq.html', { root : VIEWS });\r\n// });\r\n//\r\n// app.get(\"/texts\", function (req, res) {\r\n//   res.sendFile('texts.html', { root : VIEWS });\r\n// });\r\n\r\napp.listen(port, function () {\r\n  console.log('Example app listening on 8080!');\r\n});\r\n```\r\n\r\nI'm not sure what is happening. I've tried all manner of versions of this. Any help would be appreciated.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3378/comments",
    "author": "twhite96",
    "comments": [
      {
        "user": "mekicha",
        "created_at": "2017-07-29T16:13:58Z",
        "body": "You need to define a route for` /texts`, or rather you need to uncomment it (from your code above). And from your `index.html `file you can link to the route that serves `texts.html` like so:\r\n`<a href=\"/texts\">texts</a>`"
      },
      {
        "user": "jimmyolo",
        "created_at": "2017-08-01T03:14:21Z",
        "body": "as i know, here are some approaches:\r\n1. xxx.html as static files (not using js template)\r\n  a). using express provide static files\r\n      just add the directory to static, `app.use(express.static('path_to_your_static_file_directory'));`\r\n      then, you can get the file by hostname/path_to_your_static_file_with_its_extension\r\n      no need to write router to get files, only need to write api to get server-side data\r\n  b). use express response method\r\n    write router to response user request\r\n    ```js\r\n    const router = express.Router();\r\n    router.get('/test', (req, res, next) => {\r\n        res.sendFile('file_with_its_extension', {root: 'path_to_file_directory'});\r\n    })\r\n    app.use('/html', router);\r\n    ```\r\n    use `hostname/html/test` to get your file\r\n2. server-side rendering, \r\n```js\r\n// example, using ejs\r\napp.set('views', path.join(__dirname, 'views')); // set views root directory, your .html\r\napp.set('view engine', 'ejs');\r\napp.engine('.html', require('ejs').renderFile); // register .html as an engine in express view system\r\n\r\napp.get('/test', (req, res, next) => {\r\n    // the same as res.render('relative_views_path_to_ejsTemplateName', {});\r\n    res.render('relative_views_path_to_your.html', {});\r\n});\r\n```\r\nnote: the better approach 1. is using other reverse-proxy (nginx,...) to provide static sources"
      },
      {
        "user": "twhite96",
        "created_at": "2017-08-01T03:43:27Z",
        "body": "Actually, I got it working. Wasn't specifying the route to each file. Thank you. I will close this out now."
      }
    ]
  },
  {
    "number": 3376,
    "title": "Regex-based subrouter cannot route anything",
    "created_at": "2017-07-28T08:31:06Z",
    "closed_at": "2017-07-29T07:53:46Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3376",
    "body": "Hello,\r\nI'm experiencing a routing unavailability at `router2` in the code below. This code can route `/api/awesome` but not `mypage`. This code is of course simplified and the part of bigger system, so it is difficult to change the routing structure of `router1` and `router2`.\r\n\r\nWill there be any idea to resolve this while keeping this subrouter structure?\r\n\r\n```js\r\nconst express = require('express');\r\nconst app = express();\r\n\r\nconst router1 = express.Router();\r\nconst router2 = express.Router();\r\n\r\nrouter2.get('/mypage', function(req, res, next) {\r\n\tres.json('mypage');\r\n\tnext();\r\n});\r\n\r\nrouter1.use(/^\\/(?!api).*/, router2);\r\n\r\nrouter1.get('/api/awesome', function(req, res, next) {\r\n\tres.json('awesome');\r\n\tnext();\r\n});\r\n\r\napp.use(router1);\r\n\r\napp.listen(8080);\r\n```\r\n\r\nExpress version: 4.15.3\r\nNode.js version: 8.2.1",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3376/comments",
    "author": "Kivol",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-07-28T14:22:26Z",
        "body": "Hi @Kivol the reason your `/mypage` route is not matching is because the way `.use` works is that it will cut off whatever matched as it passes down (so you only need to write the rest of the path, not the full path over and over). Your regular expression, `/^\\/(?!api).*/`, since it ends with `.*` will always match the entire url, which in turn means the entire thing is trimmed out, making `router2` only see `req.url` as `/`, which won't match `/mypage`.\r\n\r\nYou can correct this my making the regular expression match nothing on success for what you're trying to do. Example: `/^(?!\\/api)/`. Here is the full example with this change made:\r\n\r\n```js\r\nconst express = require('express');\r\nconst app = express();\r\n\r\nconst router1 = express.Router();\r\nconst router2 = express.Router();\r\n\r\nrouter2.get('/mypage', function(req, res, next) {\r\n\tres.json('mypage');\r\n});\r\n\r\nrouter1.use(/^(?!\\/api)/, router2);\r\n\r\nrouter1.get('/api/awesome', function(req, res, next) {\r\n\tres.json('awesome');\r\n});\r\n\r\napp.use(router1);\r\n\r\napp.listen(8080);\r\n```"
      },
      {
        "user": "Kivol",
        "created_at": "2017-07-29T07:53:46Z",
        "body": "Hi @dougwilson , you save my day. Thank you for clear and kind explanation!"
      }
    ]
  },
  {
    "number": 3374,
    "title": "Question",
    "created_at": "2017-07-26T16:17:12Z",
    "closed_at": "2017-07-26T16:44:51Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3374",
    "body": "If we use nested express() object then mount into main app with different path.\r\nthen what are requirement of router, why should we use please tell me\r\nlike:\r\nvar express=require(\"express\");\r\nvar app=express();\r\n\r\nvar express1=require\"express\");\r\nvar app2=express1();\r\n\r\napp2.get(\"/user\",function(req,res,next){\r\nres.send(\"user from nested\");\r\n});\r\n\r\napp.use(\"/nest\",app2);\r\napp.listen(3000);\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3374/comments",
    "author": "raviguru123",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-07-26T16:44:51Z",
        "body": "Hi @raviguru123 there are quite a few differences between nested routers and nested apps. Some high level differences:\r\n\r\n* apps are more heavy weight than routers\r\n* routers will keep settings intact while apps reset them\r\n* routers will keep view engines intact while apps reset them\r\n* app provide mount / unmount events if needed\r\n\r\nI hope that helps!"
      },
      {
        "user": "raviguru123",
        "created_at": "2017-07-27T06:54:17Z",
        "body": "Thanks  @dougwilson "
      }
    ]
  },
  {
    "number": 3359,
    "title": "res.staus.send fails for numbers",
    "created_at": "2017-07-08T23:13:59Z",
    "closed_at": "2017-07-09T00:54:30Z",
    "labels": [
      "4.x",
      "deprecate",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3359",
    "body": "I am trying to send back integers for an API but express thinks that I am trying to send stati. I get the following error:\r\n\r\n```\r\nexpress deprecated res.send(status): Use res.sendStatus(status)\r\nevents.js:160\r\n      throw er; // Unhandled 'error' event\r\n      ^\r\n\r\nRangeError: Invalid status code: 5\r\n```\r\n\r\nHowever the code that this refers to is the following:\r\n\r\n```js\r\nres.status(200).send(result.body);\r\n```\r\n\r\nI propose that the warning `express deprecated res.send(status): Use res.sendStatus(status)` should not come into effect if the status of the response object has already been set by `res.status`.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3359/comments",
    "author": "Nokel81",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-07-09T00:54:29Z",
        "body": "Yes, this is confusing, which is exactly why the APIs are changing in Express and the old ones deprecated in 4. Using res.json is what I assume you want to do. Just because the status was set preciously doesn't mean that giving a number to res.send is any less deprecated, as it will still not work in Express 5."
      }
    ]
  },
  {
    "number": 3350,
    "title": "Looking for input Koa vs Express - Do not debate",
    "created_at": "2017-06-26T03:33:38Z",
    "closed_at": "2017-09-22T01:20:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3350",
    "body": "Hi,\r\n\r\nFirst, let's clarify that I'm not opening this to debate. I'm looking for **answers**, not arguments.\r\nI started an app using Koa since I heard it has better error handling. But, Express 5 is in developement.\r\n\r\nWill express 5 have error handling similar to Koa?\r\nI don't want to spent most of my time putting error handlers everywhere.\r\n\r\nAlso, how good is the async/await support in express?\r\n\r\nThanks\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3350/comments",
    "author": "Extarys",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-06-26T03:37:33Z",
        "body": "Hi @Extarys , not using Koa day-to-day, I really don't know exactly how Koa's error handling is, so cannot easily comment on \"Will express 5 have error handling similar to Koa?\" since I don't have a clean understanding of (1) what it is and (2) what your specific idea of it is.\r\n\r\nAs for \"Also, how good is the async/await support in express?\", an async function is simply a function that will automatically be wrapped in a Promise by JavaScript, and there is absolutely plans to make Express 5 handle promises being returned by handlers / middleware, so I assume that is \"good\", though if you could provide some more detail on what exactly defines \"good\" support, I can probably provide some better answers.\r\n\r\nI hope this helps and starts this off on a non-debate footing."
      },
      {
        "user": "ryouaki",
        "created_at": "2017-07-09T04:28:06Z",
        "body": "async/await is a new function of javascript .and will be supported on node.js v8"
      },
      {
        "user": "lvpro",
        "created_at": "2017-07-11T19:58:44Z",
        "body": "@jonathanong prob has an insightful opinion on this one."
      },
      {
        "user": "agauniyal",
        "created_at": "2017-07-26T18:42:57Z",
        "body": "@dougwilson what do you mean by\r\n>  Express 5 handle promises being returned by handlers / middleware\r\n\r\nCan you provide some pseudo-code example about this 😅 ?"
      },
      {
        "user": "lvpro",
        "created_at": "2017-07-26T18:58:33Z",
        "body": "Not to speak for @dougwilson , but this is the general idea @agauniyal ...\r\n\r\nIn Koa, the routers already know how to deal with promises and Koa will return status 500 on uncaught exceptions.  With express, if you don't wrap your async handler similar to this, express would crash on uncaught exceptions.  This is one of the reasons some of us just find Koa more convenient for writing modern async style code.\r\n\r\n```\r\napp.get('/', safeHandler(handler));\r\n\r\nfunction safeHandler(handler) {\r\n  return function(req, res) {\r\n    handler(req, res).catch(error => res.status(500).send(error.message));\r\n  };\r\n}\r\n\r\nasync function handler(req, res) {\r\n  await new Promise((resolve, reject) => reject(new Error('Hang!')));\r\n  res.send('Hello, World!');\r\n}\r\n```"
      },
      {
        "user": "adamreisnz",
        "created_at": "2017-07-26T23:53:27Z",
        "body": "I've just started using async/await in my Express middleware, and have seen the \"wrapper\" solution as @lvpro offers above for capturing errors globally suggested in a variety of blog posts.\r\n\r\nI too am wondering if there is a way to create a plugin for Express, or to handle those errors globally somehow without using the wrapper. Will Express 5 support this out of the box?"
      },
      {
        "user": "olalonde",
        "created_at": "2017-09-12T19:48:28Z",
        "body": "@adamreisnz there's been a ton of PRs and issues over the years for this but still nothing AFAIK :( "
      },
      {
        "user": "LinusU",
        "created_at": "2017-09-12T22:45:01Z",
        "body": "Instead of reimplementing the error handling, I would highly recommend delegating the error to express using the next function:\r\n\r\n```diff\r\n  function safeHandler(handler) {\r\n-   return function(req, res) {\r\n-     handler(req, res).catch(error => res.status(500).send(error.message));\r\n+   return function(req, res, next) {\r\n+     handler(req, res).catch(err => next(err));\r\n    };\r\n  }\r\n```"
      },
      {
        "user": "adamreisnz",
        "created_at": "2017-09-12T22:50:36Z",
        "body": "This is my implementation;\r\n\r\n```js\r\n'use strict';\r\n\r\n/**\r\n * Helper middleware to wrap async functions\r\n */\r\nmodule.exports = function wrapAsync(fn) {\r\n  return function(req, res, next) {\r\n    Promise\r\n      .resolve(fn(req, res, next))\r\n      .catch(error => next(error));\r\n  };\r\n};\r\n```\r\n\r\nWrapping it in a promise resolve fixes the problem where your function does not return a promise, so it's also safe to use this wrapper with non-async functions.\r\n\r\nError handling is delegated to express."
      },
      {
        "user": "LinusU",
        "created_at": "2017-09-13T07:53:34Z",
        "body": "@adamreisnz I would suggest a small change, to also capture if `fn` is throwing:\r\n\r\n```diff\r\n  module.exports = function wrapAsync(fn) {\r\n    return function(req, res, next) {\r\n-     Promise\r\n-       .resolve(fn(req, res, next))\r\n+     Promise.resolve()\r\n+       .then(() => fn(req, res, next))\r\n        .catch(error => next(error));\r\n    };\r\n  };\r\n```"
      },
      {
        "user": "adamreisnz",
        "created_at": "2017-09-13T08:17:37Z",
        "body": "Good point, thanks 👍 "
      },
      {
        "user": "adamreisnz",
        "created_at": "2017-09-13T09:34:52Z",
        "body": "I've also included a warning to make sure you pass in a function. Otherwise, if you accidentally pass in an undefined value (e.g. typo when referencing a middleware), the problem will be rather hard to debug;\r\n\r\n```js\r\n'use strict';\r\n\r\n/**\r\n * Helper middleware to wrap async functions\r\n */\r\nmodule.exports = function wrapAsync(fn) {\r\n  if (typeof fn !== 'function') {\r\n    throw new Error('Not a function provided for wrapAsync');\r\n  }\r\n  return function(req, res, next) {\r\n    Promise\r\n      .resolve()\r\n      .then(() => fn(req, res, next))\r\n      .catch(error => next(error));\r\n  };\r\n};\r\n```"
      },
      {
        "user": "LinusU",
        "created_at": "2017-09-13T12:20:19Z",
        "body": "```diff\r\n  module.exports = function wrapAsync(fn) {\r\n    if (typeof fn !== 'function') {\r\n-     throw new Error('Not a function provided for wrapAsync');\r\n+     throw new TypeError('Not a function provided for wrapAsync');\r\n    }\r\n    return function(req, res, next) {\r\n      Promise\r\n        .resolve()\r\n        .then(() => fn(req, res, next))\r\n        .catch(error => next(error));\r\n    };\r\n  };\r\n```\r\n\r\nYou could also throw a `TypeError` instead of an error \r\n\r\n> The TypeError object represents an error when a value is not of the expected type."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-09-22T01:20:55Z",
        "body": "I'm not sure if there is a purpose to keeping this issue open any more; if you feel otherwise, please let us know and we can re-open!"
      }
    ]
  },
  {
    "number": 3328,
    "title": "ERROR: Get Request in Express serves up HTML",
    "created_at": "2017-06-06T14:10:10Z",
    "closed_at": "2017-06-06T22:34:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3328",
    "body": "Hey, I'm fairly new to express, and I'm currently using it to host my Reactjs project.\r\n\r\nI've currently run into an issue, where I try to call a GET request from the expressjs script, and the response back is the HTML code of the current page. I tried hosting it localling, and the GET request worked fine. However, it's only when I deploy it onto the IIS server that I run into issues.\r\n\r\nI'm running Windows 7 Service Pack 1. Node version v.6.9.5, npm version 3.10.10, express 4.15.2.\r\n\r\nHere is my server.js file:\r\n\r\n`hello!app.use(bodyParser.json());`\r\n`app.use(bodyParser.urlencoded({extended: false}));`\r\n`app.use(cors());`\r\n`app.use(router);`\r\n`router.use('/counselling/triageadmin/', express.static(path.join(__dirname, '/build')));`\r\n`\r\n`\r\n`router.get('*', (req,res) => {`\r\n`\tres.sendFile(path.join(__dirname+'/build/index.html'));`\r\n`});`\r\n`\r\n`\r\n`router.get('/counselling/triageadmin/getTable', function (req, res, next){`\r\n`\tvar request = new sql.Request(db);`\r\n`\trequest.query('select * from Counselling order by TicketID desc', (err, result) =>{`\r\n`\t\tif (err) { return next(err); }`\r\n`\t\tres.json(JSON.stringify(result[\"recordset\"]));`\r\n`\t});`\r\n`});`\r\n\r\nI call the GET request using AXIOS this way:\r\n\r\n`    axios({`\r\n`      method: 'get',`\r\n`      url: '/counselling/triageadmin/getTable',`\r\n`      headers: {`\r\n`        'Content-Type': 'application/json'`\r\n`      },`\r\n`      data: {}`\r\n`    }).then(function(response){`\r\n`      self.setState({`\r\n`        data: response.data,`\r\n`      });`\r\n`    }).catch(function (error){`\r\n`      console.log(error);`\r\n`    });`\r\n\r\nThe formatting of the code in GitHub is not the greatest, so if you guys want a better formatted section of code, please let me know and I will pastebin it.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3328/comments",
    "author": "andehwong",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-06-06T22:34:48Z",
        "body": "Hi @AndehWong in Express, routes run from top to bottom. This means that your `router.get('*'` route will match the request and return an HTML response before it even looks at your `router.get('/counselling/triageadmin/getTable'`. You want to put the `router.get('/counselling/triageadmin/getTable'` above the `router.get('*'`."
      }
    ]
  },
  {
    "number": 3319,
    "title": "why is 'next' in createApplication needed?",
    "created_at": "2017-05-25T03:09:01Z",
    "closed_at": "2017-05-25T03:26:45Z",
    "labels": [
      "3.x",
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3319",
    "body": "```js\r\nfunction createApplication() {\r\n  var app = function(req, res, next) {\r\n    app.handle(req, res, next);\r\n  };\r\n```\r\nI deleted it in my local env,it turns out fine.\r\nAnd It seems no way to assaign it , how to use this 'next' here?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3319/comments",
    "author": "ginobilee",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-05-25T03:26:45Z",
        "body": "Hi @ginobilee it is used when you mount apps on each other. For example:\r\n```js\r\nvar app  = express()\r\nvar app1 = express()\r\n\r\napp.use(app1)\r\n```"
      },
      {
        "user": "ginobilee",
        "created_at": "2017-05-25T04:32:26Z",
        "body": "Thank you !\r\n I just begin learning express.I know it too little to ask this question,almost regret just after i post it .\r\nThank you again!"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-05-25T04:32:59Z",
        "body": "It's not a problem at all, @ginobilee "
      }
    ]
  },
  {
    "number": 3315,
    "title": "[as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)",
    "created_at": "2017-05-22T14:27:53Z",
    "closed_at": "2017-05-28T10:18:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3315",
    "body": "Here's error message of my MEAN Application. I don't know how and why this happened. Can you explain, when this error occurs to find and prevent it...\r\n\r\n```\r\n[as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)\r\nat next (/var/app/current/node_modules/express/lib/router/route.js:110:13)\r\nat Route.dispatch (/var/app/current/node_modules/express/lib/router/route.js:91:3)\r\nat Layer.handle [as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)\r\nat /var/app/current/node_modules/express/lib/router/index.js:267:22\r\nat param (/var/app/current/node_modules/express/lib/router/index.js:340:14)\r\nat param (/var/app/current/node_modules/express/lib/router/index.js:356:14)\r\nat Function.proto.process_params (/var/app/current/node_modules/express/lib/router/index.js:400:3)\r\nat next (/var/app/current/node_modules/express/lib/router/index.js:261:10)\r\nat Function.proto.handle (/var/app/current/node_modules/express/lib/router/index.js:166:3)\r\nat router (/var/app/current/node_modules/express/lib/router/index.js:35:12)\r\nat Layer.handle [as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)\r\nat trim_prefix (/var/app/current/node_modules/express/lib/router/index.js:302:13)\r\nat /var/app/current/node_modules/express/lib/router/index.js:270:7\r\nat Function.proto.process_params (/var/app/current/node_modules/express/lib/router/index.js:321:12)\r\nat next (/var/app/current/node_modules/express/lib/router/index.js:261:10)\r\nat module.exports.defineUserInfo (/var/app/current/helpers/middlewares.js:54:12)\r\nat Layer.handle [as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)\r\nat trim_prefix (/var/app/current/node_modules/express/lib/router/index.js:302:13)\r\nat /var/app/current/node_modules/express/lib/router/index.js:270:7\r\nat Function.proto.process_params (/var/app/current/node_modules/express/lib/router/index.js:321:12)\r\nat next (/var/app/current/node_modules/express/lib/router/index.js:261:10)\r\nat module.exports.tokenCheck (/var/app/current/helpers/middlewares.js:215:20)\r\nat Layer.handle [as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)\r\nat trim_prefix (/var/app/current/node_modules/express/lib/router/index.js:302:13)\r\nat /var/app/current/node_modules/express/lib/router/index.js:270:7 status: 404 }\r\n```\r\n\r\n\r\nAnd this is second example, when error occured:\r\n\r\n```\r\nt Layer.handle [as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)\r\nat next (/var/app/current/node_modules/express/lib/router/route.js:110:13)\r\nat Route.dispatch (/var/app/current/node_modules/express/lib/router/route.js:91:3)\r\nat Layer.handle [as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)\r\nat /var/app/current/node_modules/express/lib/router/index.js:267:22\r\nat param (/var/app/current/node_modules/express/lib/router/index.js:340:14)\r\nat param (/var/app/current/node_modules/express/lib/router/index.js:356:14)\r\nat Function.proto.process_params (/var/app/current/node_modules/express/lib/router/index.js:400:3)\r\nat next (/var/app/current/node_modules/express/lib/router/index.js:261:10)\r\nat Function.proto.handle (/var/app/current/node_modules/express/lib/router/index.js:166:3)\r\nat router (/var/app/current/node_modules/express/lib/router/index.js:35:12)\r\nat Layer.handle [as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)\r\nat trim_prefix (/var/app/current/node_modules/express/lib/router/index.js:302:13)\r\nat /var/app/current/node_modules/express/lib/router/index.js:270:7\r\nat Function.proto.process_params (/var/app/current/node_modules/express/lib/router/index.js:321:12)\r\nat next (/var/app/current/node_modules/express/lib/router/index.js:261:10)\r\nat module.exports.defineUserInfo (/var/app/current/helpers/middlewares.js:54:12)\r\nat Layer.handle [as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)\r\nat trim_prefix (/var/app/current/node_modules/express/lib/router/index.js:302:13)\r\nat /var/app/current/node_modules/express/lib/router/index.js:270:7\r\nat Function.proto.process_params (/var/app/current/node_modules/express/lib/router/index.js:321:12)\r\nat next (/var/app/current/node_modules/express/lib/router/index.js:261:10)\r\nat module.exports.tokenCheck (/var/app/current/helpers/middlewares.js:215:20)\r\nat Layer.handle [as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)\r\nat trim_prefix (/var/app/current/node_modules/express/lib/router/index.js:302:13)\r\nat /var/app/current/node_modules/express/lib/router/index.js:270:7 status: 404 }\r\n```\r\n\r\nAnd this is third example of related error:\r\n\r\n```\r\nent/node_modules/express/lib/router/index.js:302:13)\r\nat /var/app/current/node_modules/express/lib/router/index.js:270:7\r\nat Function.proto.process_params (/var/app/current/node_modules/express/lib/router/index.js:321:12)\r\nat next (/var/app/current/node_modules/express/lib/router/index.js:261:10)\r\nat module.exports.tokenCheck (/var/app/current/helpers/middlewares.js:215:20)\r\nat Layer.handle [as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)\r\nat trim_prefix (/var/app/current/node_modules/express/lib/router/index.js:302:13)\r\nat /var/app/current/node_modules/express/lib/router/index.js:270:7 status: 404 }\r\n```\r\n\r\nAnd this is fourth and last related error :D :\r\n\r\n```\r\nles/express/lib/router/route.js:110:13)\r\nat Route.dispatch (/var/app/current/node_modules/express/lib/router/route.js:91:3)\r\nat Layer.handle [as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)\r\nat /var/app/current/node_modules/express/lib/router/index.js:267:22\r\nat param (/var/app/current/node_modules/express/lib/router/index.js:340:14)\r\nat param (/var/app/current/node_modules/express/lib/router/index.js:356:14)\r\nat Function.proto.process_params (/var/app/current/node_modules/express/lib/router/index.js:400:3)\r\nat next (/var/app/current/node_modules/express/lib/router/index.js:261:10)\r\nat Function.proto.handle (/var/app/current/node_modules/express/lib/router/index.js:166:3)\r\nat router (/var/app/current/node_modules/express/lib/router/index.js:35:12)\r\nat Layer.handle [as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)\r\nat trim_prefix (/var/app/current/node_modules/express/lib/router/index.js:302:13)\r\nat /var/app/current/node_modules/express/lib/router/index.js:270:7\r\nat Function.proto.process_params (/var/app/current/node_modules/express/lib/router/index.js:321:12)\r\nat next (/var/app/current/node_modules/express/lib/router/index.js:261:10)\r\nat module.exports.defineUserInfo (/var/app/current/helpers/middlewares.js:54:12)\r\nat Layer.handle [as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)\r\nat trim_prefix (/var/app/current/node_modules/express/lib/router/index.js:302:13)\r\nat /var/app/current/node_modules/express/lib/router/index.js:270:7\r\nat Function.proto.process_params (/var/app/current/node_modules/express/lib/router/index.js:321:12)\r\nat next (/var/app/current/node_modules/express/lib/router/index.js:261:10)\r\nat module.exports.tokenCheck (/var/app/current/helpers/middlewares.js:215:20)\r\nat Layer.handle [as handle_request] (/var/app/current/node_modules/express/lib/router/layer.js:82:5)\r\nat trim_prefix (/var/app/current/node_modules/express/lib/router/index.js:302:13)\r\nat /var/app/current/node_modules/express/lib/router/index.js:270:7 status: 404 }\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3315/comments",
    "author": "vkupar",
    "comments": [
      {
        "user": "blakeembrey",
        "created_at": "2017-05-22T15:16:36Z",
        "body": "@vatex You will probably need to share the full stack trace for someone to be able to help you. It looks like you've trimmed the beginning from them all, so I couldn't tell if it's coming from your code or not. At least all the current stack trace just points to it being an error that related to a request."
      },
      {
        "user": "vkupar",
        "created_at": "2017-05-28T10:18:23Z",
        "body": "Sorry, It's just \"404 not found\" error code :/"
      }
    ]
  },
  {
    "number": 3299,
    "title": "any plan on performance improvements?",
    "created_at": "2017-05-06T21:43:42Z",
    "closed_at": "2017-05-06T21:48:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3299",
    "body": "\r\nI have tested koa and express with basic 'Hello world' response.\r\n\r\n## performance comparison\r\n\r\nwhere koa is much faster:\r\n\r\nkoa's records:\r\n\r\n```\r\nRequests per second:    4345.20 [#/sec] (mean)\r\nRequests per second:    4545.75 [#/sec] (mean)\r\nRequests per second:    4829.70 [#/sec] (mean)\r\nRequests per second:    4515.21 [#/sec] (mean)\r\n```\r\n\r\nexpress's records:\r\n\r\n```\r\nRequests per second:    3572.34 [#/sec] (mean)\r\nRequests per second:    4021.62 [#/sec] (mean)\r\nRequests per second:    3913.94 [#/sec] (mean)\r\nRequests per second:    3842.52 [#/sec] (mean)\r\n```\r\n\r\n## vig\r\n\r\nvig is a new framework focusing on web logic which is usually called controller by most mvc-based frameworks. \r\n\r\nIt is designed to be performance aware, modular, simple and re-entrant.\r\n\r\nand as i have tested,  there is no big difference in performance with express.\r\n\r\nvig's records:\r\n\r\n```\r\nRequests per second:    3563.68 [#/sec] (mean)\r\nRequests per second:    3882.52 [#/sec] (mean)\r\nRequests per second:    3783.89 [#/sec] (mean)\r\nRequests per second:    3921.03 [#/sec] (mean)\r\n```\r\n\r\nsince express is much slower now, I am wondering if there is any plan on performance improvements?\r\n\r\n(for koa is still under development and somewhat off the road to me, i may not set time to add support to koa for the time being.)\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3299/comments",
    "author": "calidion",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-05-06T21:48:37Z",
        "body": "We are always working on improving performance. If you find anything specific to change / improve, please feel free to make a pull request or outline where the bottleneck is and a suggested solution :)"
      },
      {
        "user": "calidion",
        "created_at": "2017-05-06T23:24:34Z",
        "body": "I am afraid I haven't got time at time being.\r\nI would be glad to hear improvements from you:)\r\n\r\nI would plan to add an adapter for koa if problem remains, thought it seems ugly to me :-)\r\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-05-06T23:49:32Z",
        "body": "I have already implemented all the improvements I know about."
      },
      {
        "user": "calidion",
        "created_at": "2017-05-07T01:13:30Z",
        "body": "sad to hear that."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-05-07T01:24:35Z",
        "body": "We are always working on improving performance. If you find anything specific to change / improve, please feel free to make a pull request or outline where the bottleneck is and a suggested solution :)"
      }
    ]
  },
  {
    "number": 3294,
    "title": "Question: app.param function",
    "created_at": "2017-04-28T09:43:23Z",
    "closed_at": "2020-04-15T23:52:11Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3294",
    "body": "I have seen that the `app.param` function are isolated by Router rather than by application.\r\nI know we have `Router({mergeParams:true})` for merging the param data from parent to child, but I didn't know if we had a way of merging the parent's param functions to the child too?\r\n\r\n- Colin",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3294/comments",
    "author": "WORMSS",
    "comments": [
      {
        "user": "jcready",
        "created_at": "2017-04-28T13:08:52Z",
        "body": "This cropped up in the Gitter chat yesterday. Here's the minimal example:\r\n\r\n```js\r\napp.param('foo', (req, res, next, foo) => {\r\n  console.log('foo', foo)\r\n  next()\r\n})\r\n\r\nconst bar = new Router({ mergeParams: true })\r\nbar.get('/:foo', (req, res) => res.end())\r\n\r\napp.use('/bar', bar)\r\n```\r\n\r\nWhen I `GET /bar/baz` I don't see \"foo baz\" show up in my console with the above setup."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-04-30T03:17:38Z",
        "body": "Yes, currently you cannot merge params to a child app, as that is by design since apps are meant to be more isolated from each other than routers. Typically your own code base is built up from router instances on a single app and different code bases are shared as apps. When the params are merged, it can be especially surprising when using position-based params in a child app, since the child app would not expect it's paras to get offset by the parent's and the child app should be usable on it's own, typically expecting that params is empty if it didn't set anything.\r\n\r\nAnyway, the feature could potentially be added if you wanted to provide at least a very clear use-case for adding them, bonus points for a suggested implementation or a PR with an implementation :)"
      },
      {
        "user": "WORMSS",
        "created_at": "2017-04-30T07:54:53Z",
        "body": "I have an idea in my head, but I don't think it could take multiple layers into account.. It would either be root app layer + nth layer. So if u nested a router within a router, the nested router would not pick up the top level router, only the one at root....."
      },
      {
        "user": "jonchurch",
        "created_at": "2020-04-15T23:52:11Z",
        "body": "Closing as interest seems to have faded"
      }
    ]
  },
  {
    "number": 3285,
    "title": "Mounting a sub-app onto a router doesn't emmit the 'mount' event.",
    "created_at": "2017-04-23T00:58:46Z",
    "closed_at": "2017-04-23T01:04:12Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3285",
    "body": "How to reproduce:\r\n===\r\n```js\r\nvar express = require('express');\r\nvar subapp = express();\r\nvar app = express();\r\n\r\nsubapp.on('mount', () => {\r\n    console.log('mounted');\r\n})\r\n\r\napp.use('/subapp', subapp);\r\n\r\napp.listen(8080);\r\n```\r\n```\r\n=> mounted\r\n```\r\n\r\nbut\r\n\r\n```js\r\nvar express = require('express');\r\nvar subapp = express();\r\nvar app = express();\r\n\r\nsubapp.on('mount', () => {\r\n    console.log('mounted');\r\n})\r\n\r\nvar router = express.Router();\r\n\r\nrouter.use('/subapp', subapp);\r\napp.use(router);\r\n\r\napp.listen(8080);\r\n```\r\n```\r\nno log :P\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3285/comments",
    "author": "tomasgvivo",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-04-23T01:04:12Z",
        "body": "Yes, this is working as intended. An app is only \"mounted\" on another app. Adding an app to a router does not run through the same semantics, namely how it links together the settings, locals, and more. This is as designed.\r\n\r\nI hope this helps!"
      }
    ]
  },
  {
    "number": 3283,
    "title": "Testing for express version",
    "created_at": "2017-04-18T10:24:33Z",
    "closed_at": "2017-04-19T03:16:48Z",
    "labels": [
      "3.x",
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3283",
    "body": "Hello, I couldn't find in the documentation anywhere if there was a `require('express').version` or `app.version`.\r\n\r\nI have a middleware that has to change how it implements certain code depending on **Express 3.*** vs **Express 4.***.\r\n\r\nFYI: it regards the depreciated usage of path as an array in 3.* but allowed in 4.* and I didn't want to make a express3-module and express4-module for a single if statement.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3283/comments",
    "author": "WORMSS",
    "comments": [
      {
        "user": "blakeembrey",
        "created_at": "2017-04-18T16:10:29Z",
        "body": "You could do `require('express/package')`. Or you could try feature detection of the express instance. Or you could just export two versions of the library as `express` and `express3`."
      },
      {
        "user": "WORMSS",
        "created_at": "2017-04-18T17:06:24Z",
        "body": "I don't think i could do feature detection. But, I do like the package import route... I may even implement the duel export too. So someone could force it, or use auto (which would be the package import way).\r\n\r\nThank you very much @blakeembrey"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-04-19T03:16:48Z",
        "body": "Yea, we don't explicitly export the version because `require('express/package').version` works great and is universal to all npm packages to boot :)"
      }
    ]
  },
  {
    "number": 3282,
    "title": "inspect an action/handle/route function before i do with something",
    "created_at": "2017-04-12T22:19:35Z",
    "closed_at": "2017-04-19T16:21:27Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3282",
    "body": "i am trying to create a handering API with my routes.\r\nbut i cannot restrict everything. i add a decorator on the function like:\r\n\r\n```javascript\r\napp.use((req, res, next) => {\r\n   // i got the app inside...\r\n  // if it is decorated the handle/route/function it does it self\r\n  if (app.handle.decorated === true) {\r\n    next();\r\n }\r\n ... verify auth ...\r\n})\r\n\r\nconst decorate.auth = () => {};\r\ndecorate.auth.decorated = true;\r\n\r\n// a decorated auth,  so the middleware should skip\r\nroute.get('/something', decorate.auth('public', (req, res) => {\r\n  res.send('ok');\r\n}\r\n```\r\nThe problem is I want to restrict except the ones that are decorated, but i cannot find the handle/route before it is fired. ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3282/comments",
    "author": "patrikx3",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-04-12T22:42:03Z",
        "body": "Hi @patrikx3 I'm not 100% sure on what you're trying to do exactly, but it sounds like a pattern for doing granular auth restrictions per route. If that is right, one pattern you can try is to use a middleware pattern to skip, for example:\r\n```js\r\n// 1. Let's assume that you have a middleware that looks up a user's access level\r\napp.use((req, res, next) => {\r\n   req.user.accessLevel = 'public'\r\n})\r\n\r\n// 2. Then you could make an access level checker\r\nfunction requireAccessLevel(level) {\r\n  return (req, res, next) => {\r\n    if (req.user && req.user.accessLevel === level) next()\r\n    else next('route')\r\n  }\r\n}\r\n\r\n// 3. Then you would define your route\r\nroute.get('/something', requireAccessLevel('private'), (req, res) => {\r\n  res.send('ok')\r\n}\r\n```"
      },
      {
        "user": "patrikx3",
        "created_at": "2017-04-12T22:49:09Z",
        "body": "the problem is that i am trying to do everything in reverse. i try to restrict everything, but i try to allow a few routes with public access, but the problem since i already forbid everything my middleware doesnt' got access to my route.\r\n\r\ni can restrict , that is ok.\r\nbut i try to restrict everything automatically, but add a few public route like public, role2, role1. \r\nlike hardening.\r\nsince you created do you have a little idea when you get a little chance how it would be to every action/function/route before i do it?\r\n\r\n**but i would decorate a child app, router, or a route as well.**\r\n\r\nif it has no authorization decorator, forbid.\r\n:) \r\n\r\nciao if you have a little time! thanks so much!"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-04-13T02:08:30Z",
        "body": "Hi @patrikx3 gotcha. I definitely didn't fully understand what you are asking, as I suspected may be the case. I'm still a little fuzzy on what you're trying to do, but I think I may understand this time (?). Typically if you wanted to have a route layout of fully accessible + generally restricted, you could just place the few accessible routes physically before the auth check restriction:\r\n```js\r\n// 1. Declare the routes available to everyone\r\napp.get('/', ..);\r\n\r\n// 2. Add your auth restriction\r\napp.use(blockNonAdmins());\r\n\r\n// 3. Declare the restricted routes\r\napp.get('/control_panel', ...);\r\n```"
      },
      {
        "user": "patrikx3",
        "created_at": "2017-04-13T02:10:07Z",
        "body": "thanks for helping! you are so cool! got it working with you!!!\r\nciao!!"
      }
    ]
  },
  {
    "number": 3279,
    "title": "simple question: what is the reason for app.router?",
    "created_at": "2017-04-11T15:21:35Z",
    "closed_at": "2017-04-11T20:41:57Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3279",
    "body": "hi!!!! hello!! bello!!\r\n\r\nSince we have express.Router() why do we like app.router? thanks so much!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3279/comments",
    "author": "patrikx3",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-04-11T20:41:57Z",
        "body": "Hi @patrikx3 I'm confused about your question \"why do we like app.router?\". I'm not sure what you mean, as `app.router` doesn't exist in Express 4, which is when `express.Router()` was added."
      },
      {
        "user": "patrikx3",
        "created_at": "2017-04-11T20:44:09Z",
        "body": "it says in v5 the app.router is back. what is the purpose since express.Router()? "
      },
      {
        "user": "dougwilson",
        "created_at": "2017-04-11T20:48:32Z",
        "body": "Oh, sorry, I didn't realize what you are referring to. So `express.Router()` is how you create a new router instance. The `app.router` is a reference to the already-existing instance that underlays the top-level Express routing."
      },
      {
        "user": "patrikx3",
        "created_at": "2017-04-11T20:51:22Z",
        "body": "ok so it is just for info? what is the use case for it? whenever get a chance dude! ciao! "
      },
      {
        "user": "dougwilson",
        "created_at": "2017-04-12T12:12:07Z",
        "body": "The purpose is to expose it to allow users to alter it's configuration. Folks already access it today in Express 4.x as `app._router`, so this just makes is not seem so bad."
      }
    ]
  },
  {
    "number": 3277,
    "title": "Express doesn't catch Promises",
    "created_at": "2017-04-10T16:02:26Z",
    "closed_at": "2017-04-10T19:46:48Z",
    "labels": [
      "5.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3277",
    "body": "When Express will catch Promises as well?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3277/comments",
    "author": "patrikx3",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-04-10T16:04:25Z",
        "body": "Hi @patrikx3 the current plan is for it to land in 5.0.0-alpha.6"
      },
      {
        "user": "patrikx3",
        "created_at": "2017-04-10T16:06:38Z",
        "body": "Hi @dougwilson, Is it in the master so I can use it somehow with NPM?\r\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-04-10T16:07:53Z",
        "body": "There is no code in this repository for the feature yet."
      }
    ]
  },
  {
    "number": 3274,
    "title": "TypeError: Router.use() requires middleware function but got a Object",
    "created_at": "2017-04-08T16:12:50Z",
    "closed_at": "2017-04-10T07:24:23Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3274",
    "body": "macOS Sierra 10.12.4\r\nnode v7.8.0\r\nnpm 4.2.0\r\n\r\nindex.js\r\n```javascript\r\nconst express = require('express')\r\nconst bodyParser = require('body-parser')\r\nconst session = require('express-session')\r\nconst mongoose = require('mongoose')\r\nconst MongoStore = require('connect-mongo')(session)\r\nconst morgan = require('morgan')\r\nconst csrf = require('lusca').csrf()\r\nconst fs = require('fs')\r\nconst path = require('path')\r\nconst rfs = require('rotating-file-stream')\r\n\r\nmongoose.connect('mongodb://localhost/test')\r\n\r\nconst app = express()\r\n\r\nconst logDir = path.join(__dirname, 'log')\r\nfs.existsSync(logDir) || fs.mkdirSync(logDir)\r\nconst accessLogStream = rfs('access.log', {\r\n  interval: '1d',\r\n  path: logDir\r\n})\r\n\r\napp.use(bodyParser.json())\r\napp.use(bodyParser.urlencoded({extended: true}))\r\napp.use(session({\r\n  secret: 'ohmy411',\r\n  store: new MongoStore({\r\n    mongooseConnection: mongoose.connection\r\n  })\r\n}))\r\napp.use(morgan('combined'), { stream: accessLogStream })\r\napp.use((req, res, next) => csrf(req, res, next))\r\n\r\napp.get('/', (req, res) => res.send('hello world'))\r\n\r\napp.listen(3000)\r\n```\r\n\r\nerror info\r\n```\r\n➜  server (master) ✗ node index.js\r\nexpress-session deprecated undefined resave option; provide resave option index.js:26:9\r\nexpress-session deprecated undefined saveUninitialized option; provide saveUninitialized option index.js:26:9\r\n/Users/simonqian/Work/ohmy411/server/node_modules/express/lib/router/index.js:458\r\n      throw new TypeError('Router.use() requires middleware function but got a ' + gettype(fn));\r\n      ^\r\n\r\nTypeError: Router.use() requires middleware function but got a Object\r\n    at Function.use (/Users/simonqian/Work/ohmy411/server/node_modules/express/lib/router/index.js:458:13)\r\n    at Function.<anonymous> (/Users/simonqian/Work/ohmy411/server/node_modules/express/lib/application.js:220:21)\r\n    at Array.forEach (native)\r\n    at Function.use (/Users/simonqian/Work/ohmy411/server/node_modules/express/lib/application.js:217:7)\r\n    at Object.<anonymous> (/Users/simonqian/Work/ohmy411/server/index.js:32:5)\r\n    at Module._compile (module.js:571:32)\r\n    at Object.Module._extensions..js (module.js:580:10)\r\n    at Module.load (module.js:488:32)\r\n    at tryModuleLoad (module.js:447:12)\r\n    at Function.Module._load (module.js:439:3)\r\n    at Module.runMain (module.js:605:10)\r\n    at run (bootstrap_node.js:423:7)\r\n    at startup (bootstrap_node.js:147:9)\r\n    at bootstrap_node.js:538:3\r\n```\r\n\r\ndependencies\r\n```json\r\n  {\r\n    \"body-parser\": \"^1.17.1\",\r\n    \"connect-mongo\": \"^1.3.2\",\r\n    \"express\": \"^4.15.2\",\r\n    \"express-session\": \"^1.15.2\",\r\n    \"lusca\": \"^1.4.1\",\r\n    \"mongoose\": \"^4.9.2\",\r\n    \"morgan\": \"^1.8.1\",\r\n    \"rotating-file-stream\": \"^1.2.1\",\r\n    \"uuid\": \"^3.0.1\"\r\n  }\r\n```\r\n\r\nWhere is it wrong?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3274/comments",
    "author": "simonqian",
    "comments": [
      {
        "user": "willyelm",
        "created_at": "2017-04-08T16:25:28Z",
        "body": "here:\r\n\r\n```javascript\r\napp.use(morgan('combined'), { stream: accessLogStream })\r\n```\r\n\r\nseems like you are trying to use 2 middleware where the second is a Object `{ stream: accessLogStream }`. you should have:\r\n\r\n```javascript\r\napp.use(morgan('combined', { stream: accessLogStream }))\r\n```\r\n"
      },
      {
        "user": "simonqian",
        "created_at": "2017-04-09T02:23:17Z",
        "body": "@willyelm its working now thank you so much!"
      }
    ]
  },
  {
    "number": 3238,
    "title": "How to render from string?",
    "created_at": "2017-03-06T19:10:33Z",
    "closed_at": "2017-03-07T02:11:22Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3238",
    "body": "Hello.\r\n\r\nHow to render from string?\r\n\r\nindex.js\r\n```\r\nres.render('index', {\"hello\": \"world\"});\r\n```\r\nindex.ejs\r\n```\r\n<%- hello %>\r\n```\r\n\r\nWe need so:\r\n```\r\nvar hello = '<%- hello %>';\r\nres.render(hello, {\"hello\": \"world\"});\r\n```\r\n\r\nIt's possible?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3238/comments",
    "author": "extensionsapp",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-03-06T19:15:41Z",
        "body": "Depending on the case, typically you would just use the engine directly. For example:\r\n```js\r\nvar hello = '<%- hello %>';\r\nres.send(ejs.render(hello, {\"hello\": \"world\"}));\r\n```"
      },
      {
        "user": "extensionsapp",
        "created_at": "2017-03-06T19:24:52Z",
        "body": "@dougwilson This is exactly what I need. Thank you."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-03-07T02:11:22Z",
        "body": "No problem :)"
      }
    ]
  },
  {
    "number": 3234,
    "title": "Creating a custom renderer for a JS file",
    "created_at": "2017-03-04T08:29:07Z",
    "closed_at": "2017-03-04T08:38:09Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3234",
    "body": "Not sure if this has been asked here before or on SO but I thought I'd post here incase we need to convert to an issue.\r\n\r\nI have the following route;\r\n\r\n```javascript\r\napp.get('/embed/:id.js', (req, res) => {\r\n  res.header('Content-Type', 'text/javascript')\r\n\r\n  res.sendFile(__dirname + '/views/embedTemplate.js', {\r\n    embedId: req.params.id\r\n  })\r\n})\r\n\r\n```\r\n\r\nObviously `sendFile` doesn't permit modifying the file as it's just the `fs` returning the file. So, instead of creating a custom engine to replace `#embedId#` for example, if there a way to `render` the file and modify the contents?\r\n\r\nMy first guess at something like based on the examples would be \r\n\r\n```javascript\r\napp.get('/embed/:id.js', (req, res) => {\r\n  res.header('Content-Type', 'text/javascript')\r\n\r\n  var filePath = __dirname + '/views/embedTemplate.js'\r\n\r\n  var fileToRender = fs.readFile(filePath, function (err, content) {\r\n    if (err) return callback(err)\r\n\r\n    var rendered = content.toString().replace('#embedId#', req.params.id)\r\n    return rendered\r\n  })\r\n\r\n  res.send(fileToRender)\r\n})\r\n```\r\n\r\nAm I missing something that is built into Express?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3234/comments",
    "author": "notrab",
    "comments": [
      {
        "user": "notrab",
        "created_at": "2017-03-04T08:38:08Z",
        "body": "Ok so I figured this out.\r\n\r\nI also moved the render into the readFile callback to prevent thread blocking.\r\n\r\n```javascript\r\napp.get('/embed/:id.js', (req, res) => {\r\n  var filePath = Path.join(__dirname, '/views/embedTemplate.js')\r\n\r\n  fs.readFile(filePath, function (err, content) {\r\n    if (err) return callback(err)\r\n\r\n    var rendered = content.toString().replace('#embedId#', req.params.id)\r\n\r\n    res.setHeader('Content-Type', 'text/javascript')\r\n    res.write(rendered, 'binary')\r\n    res.end()\r\n  })\r\n})\r\n```\r\n\r\nI've never done this with Express before - Maybe an example I can submit a PR for 😏"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-03-04T21:16:14Z",
        "body": "You could reduce your last example down to the following:\r\n```js\r\napp.get('/embed/:id.js', (req, res) => {\r\n  var filePath = Path.join(__dirname, '/views/embedTemplate.js')\r\n\r\n  fs.readFile(filePath, function (err, content) {\r\n    if (err) return callback(err)\r\n    res.type('js').send(content.toString().replace('#embedId#', req.params.id))\r\n  })\r\n})\r\n```\r\n\r\nBut even then, it would be nice to do it in some more generic way. You may want to even consider thinking about that file as really not a JS file at all, but as a template. You could then use the `res.render` process directly, perhaps to render a \"tjs\" file (was thinking template js, idk). In that case, you could just use an existing template engine, like handlebars, ejs, pug, whatever, and attach that to handle tjs extensions. Then the only additional thing is that you want to send it with the correct content type:\r\n```js\r\napp.get('/embed/:id.js', (req, res) => {\r\n  res.render('embedTemplate.tjs', { endedId: req.params.id }, function (err, content) {\r\n    if (err) return callback(err)\r\n    res.type('js').send(content)\r\n  })\r\n})\r\n```"
      },
      {
        "user": "notrab",
        "created_at": "2017-03-06T22:19:37Z",
        "body": "Totally missed this response. Thank you @dougwilson - this is exactly what I need! 🙌"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-03-07T02:10:24Z",
        "body": "Awesome, no problem :) !"
      }
    ]
  },
  {
    "number": 3219,
    "title": "parser.incoming._addHeaderLines is not a function",
    "created_at": "2017-02-21T17:36:49Z",
    "closed_at": "2017-02-21T17:41:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3219",
    "body": "I tried running express with uws and I get this error : \r\n\r\n> _http_common.js:138\r\n>       parser.incoming._addHeaderLines(headers, headers.length);\r\n>                       ^\r\n> \r\n> TypeError: parser.incoming._addHeaderLines is not a function\r\n>     at HTTPParser.parserOnMessageComplete (_http_common.js:138:23)\r\n> \r\n> npm ERR! Darwin 16.1.0\r\n> npm ERR! argv \"/usr/local/bin/node\" \"/usr/local/bin/npm\" \"run\" \"start:dev\"\r\n> npm ERR! node v7.5.0\r\n> npm ERR! npm  v4.1.2\r\n> npm ERR! code ELIFECYCLE\r\n> npm ERR! AdminMeepV2@0.1.0 start:dev: `npm run resetdb && node server.js`\r\n> npm ERR! Exit status 1\r\n> npm ERR! \r\n> npm ERR! Failed at the AdminMeepV2@0.1.0 start:dev script 'npm run resetdb && node server.js'.\r\n> npm ERR! Make sure you have the latest version of node.js and npm installed.\r\n> npm ERR! If you do, this is most likely a problem with the AdminMeepV2 package,\r\n> npm ERR! not with npm itself.\r\n> npm ERR! Tell the author that this fails on your system:\r\n> npm ERR!     npm run resetdb && node server.js\r\n> npm ERR! You can get information on how to open an issue for this project with:\r\n> npm ERR!     npm bugs AdminMeepV2\r\n> npm ERR! Or if that isn't available, you can get their info via:\r\n> npm ERR!     npm owner ls AdminMeepV2\r\n> npm ERR! There is likely additional logging output above.\r\n> \r\n> npm ERR! Please include the following file with any support request:\r\n> npm ERR!     /Users/gatsbill/Desktop/meepV2/server/npm-debug.log\r\n> Aureliens-MBP:server gatsbill$ \r\n\r\nHere is my code : \r\n\r\n```js\r\n'use strict';\r\n\r\nconst express = require('express');\r\n\r\nObject.setPrototypeOf(express.request, require('uws').http.getRequestPrototype());\r\nObject.setPrototypeOf(express.response, require('uws').http.getResponsePrototype());\r\n\r\nconst app = express();\r\nconst server = require('http').createServer(app);\r\n\r\nconst config = require('./config');\r\nconst setGlobalMiddlewares = require('./middlewares/middlewares');\r\nconst routes = require('./routes');\r\n\r\n// set global middlewares\r\nsetGlobalMiddlewares(app);\r\n\r\n// route controller\r\napp.use(routes);\r\n\r\n// start http server\r\nserver.listen(config.server.port, () => {\r\n   console.log('server listen on port ' + config.server.port);\r\n});\r\n```\r\n\r\nDunno if you need all the middleware ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3219/comments",
    "author": "billouboq",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-02-21T17:39:29Z",
        "body": "I'm not sure. That error is coming from Node.js core (`_http_common.js:138`), not from this module. Can you share the code you used? Do you have a full stack trace? Perhaps there is a bug somewhere in `uws`? Not sure."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-02-21T17:41:15Z",
        "body": "Ah, you edited the original post. Looks like the issue is your line\r\n```js\r\nconst server = require('http').createServer(app);\r\n```\r\n\r\nYou need to use the `uws` module to create the server, not Node.js core. I believe that line should be:\r\n```js\r\nconst server = require('uws').http.createServer(app);\r\n```"
      },
      {
        "user": "wesleytodd",
        "created_at": "2017-02-21T17:41:24Z",
        "body": "Looks like the server you are using is core `http` with the req/res from uws.  That is probably never going to work.  You MIGHT be able to do it with the uws server.\r\n\r\nEDIT: looks like Doug beat me to it :)"
      },
      {
        "user": "billouboq",
        "created_at": "2017-02-21T17:42:48Z",
        "body": "oh thought I was in the uws git... my bad, and yeah forgot to use uws instead of node core http module, thx"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-02-21T17:46:19Z",
        "body": "No problem :)"
      }
    ]
  },
  {
    "number": 3180,
    "title": "Caching issues",
    "created_at": "2017-01-23T10:56:11Z",
    "closed_at": "2017-02-20T14:19:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3180",
    "body": "Hi,\r\n  I am using ``expressjs`` in my ``nodejs`` application. We have internationalization(supporting multiple languages) in our application. For this internationalization to achieve i used `i18next` with ``mongodb`` backend. when ever i update translations i used to reload the translations. It is working fine in my local machine. But in Linux environment it is misbehaving. like first time page refresh it is giving me correct name,but from next refresh of same page onwards giving me old data. In browser console also updated data only printing. So i approached `i18next` team to look into it. After debugging, they told that it might be a some cache issue related to express js . So i am posting here my problem. Kindly suggest me. i have been stagnated by this issue since 10 days.\r\ni am using ``expressjs 4.12.4`` version.\r\n\r\nThanks in Advance.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3180/comments",
    "author": "aniinprni",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-01-23T12:11:29Z",
        "body": "Hm, that is definitely weird. Have you tried the most recent express version to verify it is not a bug that has been fixed? If so, is it possible you can provide some code that demonstrates the issue so we can work together to resolve?"
      },
      {
        "user": "aniinprni",
        "created_at": "2017-01-24T11:35:06Z",
        "body": "Hi, i updated ``expressjs`` and tried. It is behaving same as before.\r\nHere is the code. In my **server.js**\r\n```\r\nvar i18n = require('i18next');\r\nvar Backend=require('i18next-node-mongodb-backend');\r\nvar middleware=require('i18next-express-middleware');\r\nvar express = require('express');\r\nvar app = express();\r\napp.use(express.static(path.join(__dirname, 'public')));\r\ni18n.use(Backend).use(middleware.LanguageDetector).init({\r\n\t\tdebug: false,\r\n\t\tload: ['ar','en'],\r\n\t\tfallbackLng: 'ar',\r\n\t\tbackend: { \r\n\t\t\turi: 'mongodb://localhost/test',\r\n\t\t\tcollection: 'i18next'\r\n\t\t},\r\n\t\tdetection:{\r\n\t\t\t  order: ['path','cookie'],\r\n\t\t\t  lookupFromPathIndex: 0,\r\n\t\t\t  lookupCookie: 'lng'\r\n\t\t}\r\n\t}, (err, t) => {\r\n\t\treturn t;\r\n});\r\napp.use(middleware.handle(i18n, {}));\r\n```\r\n\r\nin my **routes.js**\r\n```\r\napp.post('/urlforlangupdate',function(req,res,next){\r\ni18next.reloadResources([\"ar\",\"en\"]);\r\n   res.json();\r\n});\r\n```\r\nhere i need to  reload translations dynamically with out server restart. i think it is related to express cache . i might be wrong also. Kindly suggest me to reload translations dynamically."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-01-24T15:16:11Z",
        "body": "I'm not sure what exactly is going on, but I don't see you using `res.render` anywhere, which is the only thing that involves any kind of cache in Express. Can you elaborate on what cache you're running into? Are those modules performing some kind of cache?"
      },
      {
        "user": "aniinprni",
        "created_at": "2017-01-25T06:58:53Z",
        "body": "i am using ``i18next`` module to load translations from ``mongodb``. whenever a change is happened for translations i need to update those translations into my application(say **main** web application) with out server restart. here what i am doing is i will update translations from one application(say **internal** web application). When that update happens i am triggering one ``post  request`` to reload those translations in my **main** application. Hope you understand what my requirement is. This requirement absolutely working fine in my windows local machine. but when i moved to linux, giving me problem. I printed those translations via ``console.log``. it is printing updated data in both ``browser`` and ``node`` consoles. but when i refresh the browser url, still it is showing old translations. if I try to modify the same translation twice or trice then it is giving one time one translation and next time old translation. Like this it is happening.  Hope you understand what is my problem. And sorry for my bad english. Kindly suggest me on this"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-01-25T13:55:31Z",
        "body": "Hi @aniinprni I'm not sure I understand the issue, mainly because I'm not familiar with `i18next` module. Can you elaborate on what cache you're running into? Are those modules performing some kind of cache? The only caching in Express itself is really in `res.render`, but I don't see you having that anywhere in your code above."
      },
      {
        "user": "aniinprni",
        "created_at": "2017-02-20T14:19:48Z",
        "body": "Ok thank you dougwilson"
      }
    ]
  },
  {
    "number": 3167,
    "title": "Why is `new Layer(path...)` used inside `Router` instead of `Layer(path...)`",
    "created_at": "2017-01-05T08:19:21Z",
    "closed_at": "2017-01-06T01:12:10Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3167",
    "body": "I'm going through the source code and I've noticed the following. \r\nIn the `router/index.js` the layer is created like this:\r\n\r\n```\r\n    var layer = new Layer(path, {\r\n      sensitive: this.caseSensitive,\r\n      strict: false,\r\n      end: false\r\n    }, fn);\r\n```\r\nWhile, in `router/route` the layer is created like this:\r\n\r\n`      var layer = Layer('/', {}, handle);`\r\n\r\nBased on the implementation of `Layer`:\r\n\r\n```\r\nfunction Layer(path, options, fn) {\r\n  if (!(this instanceof Layer)) {\r\n    return new Layer(path, options, fn);\r\n  }\r\n```\r\nboth calls do the same. Why use different initializations?\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3167/comments",
    "author": "maxkoretskyi",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-01-06T01:12:10Z",
        "body": "Honestly it's to get the code coverage up until Express 5.0 when this is already removed & addressed :)"
      },
      {
        "user": "maxkoretskyi",
        "created_at": "2017-01-06T09:29:37Z",
        "body": "got it, thanks for the quick feedback"
      }
    ]
  },
  {
    "number": 3157,
    "title": "json parse error",
    "created_at": "2016-12-23T23:19:14Z",
    "closed_at": "2016-12-24T15:08:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3157",
    "body": "Hello,\r\n\r\nI'm trying to do two different project request. I am request a using request module other project using express but  json parse error in the express project\r\n\r\nexample object \r\n```\r\nvar data= {\r\n    User: {\r\n        ID: 123\r\n    },\r\n    Text: 'hello world'\r\n};\r\n```\r\n\r\n\r\n```\r\n request.post({\r\n            headers: { 'content-type': 'application/x-www-form-urlencoded' },\r\n            url: \"url/test\",\r\n            body: JSON.stringify(data)\r\n        }, function (error, response, body) {\r\n\r\n            logger.debug(\"error : \", error);\r\n            logger.debug(\"body : \", body);\r\n\r\n        });\r\n```\r\n\r\nListen a express project\r\n\r\n```\r\napp.post('/test', function(req, res) {\r\n\r\n    try {\r\n        res.header('Access-Control-Allow-Origin', req.headers.origin || \"*\");\r\n        res.header('Access-Control-Allow-Methods', 'POST');\r\n        res.header('Access-Control-Allow-Headers', 'Content-Type');\r\n\r\n        console.log(req.body);\r\n        var x = JSON.parse(req.body);\r\n\r\n        res.send(200);\r\n\r\n    } catch (error) {\r\n\r\n        res.send(200);\r\n    }\r\n});\r\n```\r\n\r\n**req.body is** \r\n\r\n{ '{\"User\":{\"ID\":123},\"Text\":\"hello world\"}': '' }\r\n\r\n**erorr is** \r\n\r\nSyntaxError: Unexpected token o in JSON at position 1\r\n\r\nbeats extra single quote { '{\"User\":{\"ID\":123},\"Text\":\"hello world\"}'**: '' }**\r\n\r\n \r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3157/comments",
    "author": "anotherbuild",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-12-24T15:08:05Z",
        "body": "If you are sending JSON, your content type in your code should be application/json , not application/x-www-form-urlencoded"
      }
    ]
  },
  {
    "number": 3148,
    "title": "Is this usecase recommended or discouraged?",
    "created_at": "2016-12-09T10:37:53Z",
    "closed_at": "2016-12-10T17:59:15Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3148",
    "body": "I created some modules for normalizing URLs in different ways (+ there are some others out there), so I would like to bundle them into a single module. This works right now:\r\n\r\n```js\r\napp.use((req, res, next) => {\r\n  req.app.use((req, res, next) => {\r\n    console.log(\"I am called!\");\r\n    next();\r\n  });\r\n  req.app.use((req, res, next) => {\r\n    console.log(\"Me too!\");\r\n    next();\r\n  });\r\n  console.log(\"Great\");\r\n  next();\r\n});\r\n```\r\n\r\nWhich correctly outputs:\r\n\r\n```\r\nGreat\r\nI am called!\r\nMe too!\r\n```\r\n\r\nHowever I worry that this is abusing express functionality/original intent. So I'd like to ask if this is frowned upon or perfectly valid within express' API.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3148/comments",
    "author": "franciscop",
    "comments": [
      {
        "user": "blakeembrey",
        "created_at": "2016-12-09T20:55:22Z",
        "body": "This is not a good way to do it, you're creating a memory leak by mounting applications every single request loop which means that for each request, you have one extra set of middleware mounted (and a new function for each middleware instance too == more memory overhead). \r\n\r\nIt sounds like what you want to do is to look up how Express routers work. It allows you to do this:\r\n\r\n```js\r\nconst router = express.Router();\r\n\r\nrouter.use((req, res, next) => {\r\n  console.log(\"I am called!\");\r\n  next();\r\n});\r\n\r\nrouter.use((req, res, next) => {\r\n  console.log(\"Me too!\");\r\n  next();\r\n});\r\n\r\napp.use(router);\r\n```\r\n\r\nBasically, you can create any instance you'd like and accept `(req, res, next)` - inside that you can do whatever you'd like - be that routing, request management, etc. I wouldn't mess with the application instance itself as you will create a memory leak adding too many instances of middleware."
      },
      {
        "user": "dougwilson",
        "created_at": "2016-12-10T01:18:36Z",
        "body": "And to build on what @blakeembrey said, from a strict sense of the question \"So I'd like to ask if this is frowned upon or perfectly valid within express' API.\": all of that is valid use of the Express API that is public & supported, though it does seem odd."
      },
      {
        "user": "franciscop",
        "created_at": "2016-12-10T17:59:15Z",
        "body": "@blakeembrey that makes total sense, of course the \"base\" `use` one is also a middleware so it'll be called each time. A flag or counter could be added to avoid leaking, but then your solution with the Router seems way better so I'll use it that way. Thanks!"
      }
    ]
  },
  {
    "number": 3140,
    "title": "app.mountpath not correctly set when the express nesting level is greater than one",
    "created_at": "2016-11-25T16:54:16Z",
    "closed_at": "2016-11-25T17:13:55Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3140",
    "body": "when using this code in express 4\r\n\r\n```js\r\nvar nested2 = express();\r\nvar nested = express();\r\nvar server = express();\r\n\r\nnested2.get('/', function (req, res) {\r\n  res.end(nested2.mountpath);\r\n});\r\n\r\nnested.use('/nested2', nested2);\r\n\r\nserver.use('/nested', nested);\r\n```\r\n\r\nthen accessing\r\n\r\n> /nested/nested2\r\n\r\noutputs\r\n\r\n> /nested2\r\n\r\ninstead of\r\n\r\n> /nested/nested2\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3140/comments",
    "author": "derMart",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-11-25T17:13:55Z",
        "body": "You'll want to create a function that walks through `app.mountpath` + `app.parent` to get the full mount path :)"
      },
      {
        "user": "derMart",
        "created_at": "2016-11-28T10:09:40Z",
        "body": "Ok, so you say that this is intended behaviour?\r\nCan you please specify what exactly app.mountpath returns? Is it the string you specify when attaching the app on the parent express object? f.e.:\r\n\r\n> parent.use(stringPattern, app);\r\n> console.log(app.mountpath); // -> stringPattern\r\n\r\nCould you please update the documentation accordingly, since it is misleading respectively incorrect:\r\n\r\napp.mountpath API documentation states\r\n\r\n> The app.mountpath property contains one or more path patterns on which a sub-app was mounted.\r\n\r\nThis can be interpreted also as if the full path will be returned.\r\nFurther it is written:\r\n\r\n> It is similar to the baseUrl property of the req object, except req.baseUrl returns the matched URL path, instead of the matched patterns.\r\n\r\nreq.baseUrl on the contrary will give the full path. The documentation here is incorrect.\r\n\r\nSo what I actually want is req.baseUrl which will do what you suggest (and additionally resolve the patterns to the actual matched path). Please do not change the behaviour of req.baseUrl.\r\n\r\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-11-28T12:30:11Z",
        "body": "Yes, this is working as intended. Sorry ours docs were confusing, it is very hard to write docs and the docs made sense to us, though confused you. If you can, please use the edit button at the bottom of the docs page to make a PR with the wording you feel will be less confusing :)"
      }
    ]
  },
  {
    "number": 3136,
    "title": "res.redirect(404, '/path/') Not working. ",
    "created_at": "2016-11-21T23:00:49Z",
    "closed_at": "2016-11-21T23:09:51Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3136",
    "body": "This does not work.\r\n\r\n```res.redirect(404, '/path/to/404/page/')```\r\n\r\nThis does. \r\n\r\n```\r\nres.sendStatus(404)'\r\nres.redirect('/path/to/404/page/')\r\n```\r\n\r\nNot sure if that's by design in the case of a 404? Other status codes like `302` work fine. ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3136/comments",
    "author": "solocreativeco",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-11-21T23:09:51Z",
        "body": "In the first example, the response has a 404 status and basically no browser will do anything besides display the redirect page, as 4xx are not redirect codes.\r\n\r\nIn your second example, even though you put the status as 404, the redirect call will overwrite it with 302.\r\n\r\nUltimately it is up to the web browser to actually follow the redirect, and they will only do it for the redirect codes."
      },
      {
        "user": "solocreativeco",
        "created_at": "2016-11-21T23:11:55Z",
        "body": "Ahhh, cool, thanks for your time! :)"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-11-22T00:53:20Z",
        "body": "No problem :) !"
      }
    ]
  },
  {
    "number": 3127,
    "title": "Using sendFile for a 500 throws \"Request aborted\"",
    "created_at": "2016-11-15T15:29:19Z",
    "closed_at": "2016-11-15T16:17:46Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3127",
    "body": "I am trying to send a static `500.html` since I don’t want to rely on template rendering for my error pages (since the template renderer itself may be the cause of the problem).\r\n\r\n``` javascript\r\napp.use((err, req, res, next) => {\r\n\tres.status(500).sendFile('/path/to/500.html', (err) => {\r\n\t\tconsole.error(err);\r\n\t\tnext(err);\r\n\t});\r\n});\r\n```\r\n\r\nThis throws an `ECONNABORTED` error:\r\n\r\n```\r\n{ [Error: Request aborted] code: 'ECONNABORTED' }\r\n```\r\n\r\nI can get pretty much any other by-the-numbers 500 implementation working, just not `sendFile`. I can’t find any documentation on it either. Am I missing something? Or am I using `sendFile` in an uncommon way?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3127/comments",
    "author": "phortuin",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-11-15T15:39:08Z",
        "body": "Hi @phortuin was the request actually aborted? What version of Node.js & Express are you using? What are the other \"any other by-the-numbers 500 implementation\" that works? Is there a way you can provide a full application with instructions on how to reproduce the issue if you don't think that the client is actually aborting the request?\n"
      },
      {
        "user": "phortuin",
        "created_at": "2016-11-15T16:03:38Z",
        "body": "Express 4.14.0 and Node 6.9.1 (also checked Node 5.5.0). What I tried as well is for instance using `send`:\n\n``` javascript\napp.use((err, req, res, next) => {\n    const output = fs.readFileSync('/path/to/500.html', 'utf8');\n    res.status(500).send(output);\n    next(err);\n});\n```\n\nor in other words, simply using `send` works fine. `res.render` wouldn’t be a problem as well, but that would negate my idea of sending only static content. I can probably put something together to reproduce this if you want\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-11-15T16:07:36Z",
        "body": "The `res.send` method simply ignoring errors like the client aborting the request, while `res.sendFile` is for sending files from disk (that are going to be very large), and many times people want to know when the client aborts the request so didn't receive the entire file. If you're not interested in responding to the errors when sending the file, why not ignore them similar to `res.send`?\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-11-15T16:10:36Z",
        "body": "Otherwise, if you can throw together an app + instructions to reproduce, I can dig in :)\n"
      },
      {
        "user": "phortuin",
        "created_at": "2016-11-15T16:17:46Z",
        "body": "Found it— after refactoring and isolating the problem some more, I suddenly got an \"Can't set headers after they are sent\". I had a line of code outside a `try/catch` that tried to send output. So the Request aborted was kind of a red herring. Thanks for your support, I'll close the ticket :)\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-11-15T16:18:08Z",
        "body": "> If you're not interested in responding to the errors when sending the file, why not ignore them similar to res.send?\n\nAnd to be clear, by this I mean don't even provide the optional `callback` argument to the `res.sendFile` call. If you provide it, you're opting into knowing about all the errors that occur. If you don't provide it, only critical errors are forwarded down the error middleware chain, like like how `res.send` and `res.render` work when you don't have any callaback on those.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-11-15T16:19:45Z",
        "body": "Great, glad you did! But otherwise, I would say for simplicity, if all your error handler is is\n\n``` js\napp.use((err, req, res, next) => {\n    res.status(500).sendFile('/path/to/500.html', (err) => {\n        console.error(err);\n        next(err);\n    });\n});\n```\n\nYou can simply rewrite it as the following and still be just as safe from crashing:\n\n``` js\napp.use((err, req, res, next) => {\n    res.status(500).sendFile('/path/to/500.html');\n});\n```\n"
      },
      {
        "user": "phortuin",
        "created_at": "2016-11-15T16:27:36Z",
        "body": "Will do! Nevertheless, even without the callback in `sendFile` I would still have an empty response because of my mistake elsewhere with trying to send something after the 500 was caught (\"Can't set headers after they are sent\"). That I got a 'Request aborted' was probably due to the (uncaught) header error, which indeed aborted the request. All that was easily fixed though, and for simplicity I'll use your code without the callback.\n\nThanks a bunch!\n"
      }
    ]
  },
  {
    "number": 3121,
    "title": "How to add a stringified script tag in a script",
    "created_at": "2016-11-08T12:14:26Z",
    "closed_at": "2016-11-08T12:26:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3121",
    "body": "I have express using pug as a view. My index.pug has the following:\r\n\r\n```\r\nscript(type='text/javascript').\r\n      window.__DATA__ = !{payload}\r\n```\r\n\r\nwhere payload is a json object. It has been stringified in the render function of express:\r\n\r\n```\r\nres.render('index', {\r\n    payload : JSON.stringify({\r\n           \"anExample\": \"<script></script>\"\r\n     })\r\n  })\r\n```\r\n\r\nWhen my Json object has `</script>` it terminates my `window.__DATA =` function early due to the ending script tag. How can I prevent this from blowing up my page? Is this a limitation of Pug or Express or the browser?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3121/comments",
    "author": "terencechow",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-11-08T12:26:29Z",
        "body": "This is because pug and most other templates only provide string escaping for you to put the string inside HTML, not inside a script block.  Pug may provide a way to properly escape a string for use in a script block, but you would want to ask on the Pug board, as escaping is provided by the template tool.\n"
      }
    ]
  },
  {
    "number": 3109,
    "title": "new release?",
    "created_at": "2016-10-25T13:38:55Z",
    "closed_at": "2016-10-25T20:14:29Z",
    "labels": [
      "5.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3109",
    "body": "So node 7.0 is near to a release date with async/await support.\nShould we expect an express release soon utilizing it?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3109/comments",
    "author": "bonesoul",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-10-25T20:14:29Z",
        "body": "Hi @bonesoul, your question may be better answered in our Gitter room for discussions, rather than the issue tracker. Node.js 7.0 has a very buggy async/await available behind a flag, but that doesn't directly relate to any Express.js release timelines. The Express 5.0 release is planned to support Promises directly as the handler, which would translate to seamless async/await support as well. Currently this is available in Express 4.x in various third-party modules if you would like to begin using it today.\n"
      },
      {
        "user": "bonesoul",
        "created_at": "2016-10-25T20:24:23Z",
        "body": "thanks for your kind reply, i'll be joining the gitter for further discussion.\n"
      },
      {
        "user": "ParadeTo",
        "created_at": "2017-02-10T02:50:14Z",
        "body": "Expect that very much!"
      }
    ]
  },
  {
    "number": 3107,
    "title": "unix socket support",
    "created_at": "2016-10-20T15:35:29Z",
    "closed_at": "2016-10-21T13:16:07Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3107",
    "body": "Is it possible to use express with unix socket instead of `host:port` ?\n\nThe `listen` signature just call underlying server `listen` method, so I tried with:\n\n``` node\nserver = require('net').createServer(express());\nserver.listen('/tmp/sock', function() {\n  fs.chmodSync('/tmp/sock', 0777);\n});\n```\n\nBut then when, through nginx, I try to access a page, express crashes with the following error:\n\n```\n[...]/node_modules/express/lib/router/index.js:140\n  var search = 1 + req.url.indexOf('?');\n                          ^\n\nTypeError: Cannot read property 'indexOf' of undefined\n    at Function.handle ([...]/node_modules/express/lib/router/index.js:140:27)\n    at EventEmitter.handle ([...]/node_modules/express/lib/application.js:173:10)\n    at Server.app ([...]/node_modules/express/lib/express.js:38:9)\n    at emitOne (events.js:77:13)\n    at Server.emit (events.js:169:7)\n    at Pipe.onconnection (net.js:1431:8)\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3107/comments",
    "author": "magne4000",
    "comments": [
      {
        "user": "LinusU",
        "created_at": "2016-10-20T15:55:57Z",
        "body": "I think that this is already supported:\n\n``` js\nconst express = require('express')\nconst app = express()\n\n// ...\n\napp.listen('/tmp/sock', () => {\n  console.log('Now listening on /tmp/sock')\n})\n```\n"
      },
      {
        "user": "hacksparrow",
        "created_at": "2016-10-20T17:39:10Z",
        "body": "@magne4000 you will need to use `http`, not `net`.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-10-21T02:42:13Z",
        "body": "Yes, @magne4000 , your code incorrectly used the `net` module; if you simply replace your `require('net')` with `require('http')` it works just fine. In addition, you can just pass in the socket path to `app.listen` and Express.js will handle the rest for you. I'm simply summarizing the great replies from @LinusU and @hacksparrow since there hasn't been a response. @magne4000 please let us know if this works for you and we can close the issue, otherwise we can try to figure out why you can't get your UNIX socket working.\n"
      },
      {
        "user": "magne4000",
        "created_at": "2016-10-21T07:31:26Z",
        "body": "Ok my bad ... it seems rather logical to use `http` instead of `net`.\nNow perhaps we need a note in `listen` documentation to mention that socket are also supported ?\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-10-21T13:16:06Z",
        "body": "Glad to hear you got it working! You're absolutely welcome to make a PR to update/add to our documentation. There is a link to edit the docs and open a PR all within your web browser at the bottom of every documentation page :)\n"
      }
    ]
  },
  {
    "number": 3105,
    "title": "res.send integer deprecation problem",
    "created_at": "2016-10-18T00:18:22Z",
    "closed_at": "2016-10-18T00:20:15Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3105",
    "body": "Even though this is purposeful, when I pass an integer into res.send, like this:\n\n``` javascript\nrouter.get('/', function(req, res) {\n\n    var foo = 20;\n    res.send(foo);\n});\n\n```\n\nI get a deprecated error:\n\n```\nexpress deprecated res.send(status): Use res.sendStatus(status) instead \n```\n\nand 20 does not show up in the browser. \nThis seems very illogical because now I have to go through an extra step, `res.send(\"\" + foo)`, to convert the parameter to a string, and display a simple integer. Any opinions or notes?  \n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3105/comments",
    "author": "adamsiwiec",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-10-18T00:20:15Z",
        "body": "Sop in Express 4.x and below, providing an integer to `res.send` means to send that integer as the HTTP status code. This confusing behavior is exactly why it is deprecated. Until 5.x comes out, you have to stringify your number, unfortunately.\n"
      }
    ]
  },
  {
    "number": 3102,
    "title": "NodeJS started to serve static files very slowly",
    "created_at": "2016-10-13T14:25:24Z",
    "closed_at": "2016-10-24T11:18:42Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3102",
    "body": "#### Expected behaviour\n\nFaster serving static files for development purposes (I know that on production NodeJS should not serve static files because it's slow). I need it only for local dev env.\n#### Actual behaviour\n\nWhen I refresh the website, very frequently it get stuck and it takes a few/dozen seconds to render.\nIn realtime logs, there is also no information about successful requests (I don't know why it disappeared), I cannot see what static files are served with status 200. There are only missing files listed.\nEverything in log appears with a delay.\nThere are weird `- - ms - -` and there are no successful requests listed.\n#### Steps to reproduce\n\nI run `node bin/www`\n#### Software versions used\n\n```\nOS         : Windows 7 64bit\nNodeJS  : 4.4.5\n```\n#### Log output\n\n```\nλ node bin/www\nGET /favicon.ico - - ms - -\nGET /favicon.ico - - ms - -\nGET /favicon.ico - - ms - -\nGET /favicon.ico - - ms - -\nGET /favicon.ico - - ms - -\nGET /img/favicon.ico - - ms - -\nGET /img/logo.png - - ms - -\nGET /favicon.ico - - ms - -\nGET /favicon.ico - - ms - -\nGET /browser-sync/socket.io.min.1.5.0.js.map - - ms - -\nGET /browser-sync/socket.io.min.1.5.0.js.map - - ms - -\nGET /img/favicon.ico - - ms - -\nGET /img/logo.png - - ms - -\nGET /img/favicon.ico - - ms - -\nGET /img/favicon.ico - - ms - -\nGET /favicon.ico - - ms - -\nGET /browser-sync/socket.io.min.1.5.0.js.map - - ms - -\nGET /browser-sync/socket.io.min.1.5.0.js.map - - ms - -\nGET /favicon.ico - - ms - -\n```\n#### Static files in app.js\n\n`const path = require('path');`\n`app.use(express.static(path.join(__dirname, 'frontend/dist')));`\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3102/comments",
    "author": "archasek",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-10-13T14:50:47Z",
        "body": "Hi @archasek I'm not sure there is enough information to reproduce. Can you provide the full source code you are using when this happens, include those static files? The more you can help us setup the environment and make the exact same requests as you, the more likely we'll be able to reproduce and debug the issue.\n"
      },
      {
        "user": "archasek",
        "created_at": "2016-10-13T15:46:01Z",
        "body": "The problem in loggin was connected with:\n`app.use(logger('dev'));`\nIt should be above other middlewares and `express.static()`\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-10-15T04:04:03Z",
        "body": "Ah, I see. Did that resolve your issue here, @archasek , or is there anything you think we should be looking into?\n"
      },
      {
        "user": "archasek",
        "created_at": "2016-10-15T10:18:07Z",
        "body": "I will let you know on Monday/Tuesday. Thanks\n"
      },
      {
        "user": "hacksparrow",
        "created_at": "2016-10-24T11:09:43Z",
        "body": "@archasek any updates?\n"
      },
      {
        "user": "archasek",
        "created_at": "2016-10-24T11:16:48Z",
        "body": "The first thing was the order of middlewares and logger, the second thing is Browsersync and its proxy feature -  it's getting stuck every X refreshes and takes dozen of seconds to rerender a page.  So it's not really connected with Express I think. I will create an issue in the Browsersync github. \n"
      },
      {
        "user": "hacksparrow",
        "created_at": "2016-10-24T11:18:42Z",
        "body": "Thanks for the update @archasek. Closing this.\n"
      }
    ]
  },
  {
    "number": 3098,
    "title": "Used app / router does not exec `params` middleware without call from within app / router",
    "created_at": "2016-10-12T05:11:05Z",
    "closed_at": "2016-10-12T05:47:40Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3098",
    "body": "I was just creating a router with only a param in it and found out the hard way that it doesn't execute in the `app` it's `app.use` in.\n\nHere's the code:\n\n``` js\nfunction myRouter () {\n  const router = Router({mergeParams: true})\n  router.param('appId', async (req, res, next, appId) => {\n    console.log('hi')\n    return next()\n  })\n  router.all('/:appId/*', (req, res, next) => {\n    return next()\n  })\n  return router\n}\n```\n\nThis will not log `hi` without.\n\n``` js\n  router.all('/:appId/*', (req, res, next) => {\n    return next()\n  })\n```\n\nWhich seems a bit unintuitive.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3098/comments",
    "author": "reggi",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-10-12T05:18:04Z",
        "body": "Right, the `router.param`s are confined to the router they were declared in. This is one of the purposes for creating new routers rather than reusing existing routers: because you want to create your own parameters. This allows for each router to have it's own parameter scope and allows for composability by not having routers interfere with each other.\n"
      },
      {
        "user": "reggi",
        "created_at": "2016-10-12T05:47:40Z",
        "body": "Thanks @dougwilson for the clarification. \n"
      }
    ]
  },
  {
    "number": 3087,
    "title": "route.param multiple callbacks",
    "created_at": "2016-09-17T07:13:57Z",
    "closed_at": "2016-09-19T08:28:37Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3087",
    "body": "Current express 4 docs specify `router.param` as`router.param(name, callback)`, Is it possible/allowed to insert a middleware  like `route.param(name, check_authentic_middleware,callback)`\n\nBecause `app.get` has the this format `app.get(path, callback [, callback ...])` which allows multiple callbacks `app.get(name,cb1,cb2)`\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3087/comments",
    "author": "navaneetharaopy",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-09-17T22:59:52Z",
        "body": "Hi @navaneetharaopy, no, it is not possible to specify more than one callback to the `router.param` method. You can, however, call it once per each callback in order to attach more than one. That API is actually a deprecated API so we don't really intend on adding anything to it. Perhaps if you help us understand what you are trying to accomplish, we can help you out :)\n"
      },
      {
        "user": "navaneetharaopy",
        "created_at": "2016-09-19T04:44:17Z",
        "body": "Just figured out i can  attach a callback to existing route , so that every request is authenticated and  loaded with param value.  Like \n`route.get('name',auth_middleware,load_param_data,res_callback)`\n`auth_middleware` - checks whether request is genuine.\n`load_param` - get info from db depending on param.\n`res_callback` - respond to request.\n\n  Thank you\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-09-19T08:22:04Z",
        "body": "Hi @navaneetharaopy, cool :) Are you good to go now? I'm not entirely sure if you're saying you were able to solve your issue using that pattern or if you still have a question :)\n"
      },
      {
        "user": "navaneetharaopy",
        "created_at": "2016-09-19T08:28:37Z",
        "body": "Yes , we can close this issue. Thanks.\n"
      }
    ]
  },
  {
    "number": 3086,
    "title": "Access native Node.js ClientRequest and ServerResponse objects",
    "created_at": "2016-09-14T07:43:51Z",
    "closed_at": "2016-09-14T07:59:15Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3086",
    "body": "Hello there! Sorry if this question was raised before. How can I access native Node.js request and response objects? For example in `koa` it's possible through getters `context.req = request.req = response.req` and `context.res = request.res = response.res` for request and response respectively.\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3086/comments",
    "author": "roman-vanesyan",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-09-14T07:54:47Z",
        "body": "The only objects are the native ones, just we added our own methods and properties to them.\n"
      },
      {
        "user": "roman-vanesyan",
        "created_at": "2016-09-14T07:58:52Z",
        "body": "Thanks, I just poorly looked into the documentation and didn't notice the note:\n\n```\nThe req object is an enhanced version of Node’s own request object and supports all built-in fields and methods.\n```\n"
      },
      {
        "user": "roman-vanesyan",
        "created_at": "2016-09-14T07:59:15Z",
        "body": "Thanks, @dougwilson for fast answer ;)\n"
      }
    ]
  },
  {
    "number": 3085,
    "title": "What is the best practice to place this kind of custom middleware function?",
    "created_at": "2016-09-11T13:11:17Z",
    "closed_at": "2016-09-13T12:20:54Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3085",
    "body": "Man, I have a project whose hierarchy is like this:\n\n```\n├── app/\n├── config.js\n├── index.js\n├── node_modules/\n├── package.json\n└── routes/\n```\n\nCurrently, I place all my router in `routes`, these routes share one public middle function in `routes/middlewares/jwt-verifier.js`.\n\nI want to ask, what is the best practice to place this kind of custom middleware function?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3085/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "NickNaso",
        "created_at": "2016-09-11T14:09:26Z",
        "body": "Hi @m31271n \nin  my opinion you should place middeware where they are useful.  \nIn general middleware take care to process http request and response so if you reduce the number of used middleware you should increase performance.\nIn express you have three level to place middleware:\n- Main Application\n- Sub Applications \n- Routes\n\n``` javascript\n'use strict';\nconst express = require('express');\nconst app = express();\n\n// Common midleware in the app\napp.use(function middlewareApp(req, res, next) {\n  // Process req and res ...\n  next();\n});\n\nconst mySubApp1 = express.Router();\n\n// Common middleware for the sub apps\nmySubApp1.use(function middlewareSubApp1(req, res, next) {\n  // Process req and res ...\n  next();\n});\n\n\nmySubApp1.get('/my-route1/',\n  // Middleware for the route\n  function myMiddleware1(req, res, next) {\n    // Process req and res ...\n    next();\n  }, \n  function (req, res, next) {\n    res.send();\n  }\n);\n\nmySubApp1.get('/my-route2/',\n  // Middleware for the route\n  function myMiddleware2(req, res, next) {\n    // Process req and res ...\n    next();\n  }, \n  function (req, res, next) {\n    res.send();\n  }\n);\n\napp.use('/my-app', mySubApp1);\n\napp.listen(3000);\n```\n\nYou can understand that if you well split your app you are at good point. You can more easily decide where to place middleware. \nHope this help you\nNick\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-09-13T12:20:54Z",
        "body": "Nice! Thank you. @NickNaso \n"
      }
    ]
  },
  {
    "number": 3082,
    "title": "Set max SSL fragment size in Express",
    "created_at": "2016-09-11T03:38:22Z",
    "closed_at": "2016-09-12T13:14:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3082",
    "body": "I'm using express to set up an HTTPS server for some embedded devices. However, due to the lack of computing capabilities, the default SSL fragment size 16384 is too large for these devices. I wonder how I can change this size in express.\nI found that in tls modules, TLSSocket class has a method _tlsSocket.setMaxSendFragment(size)_ which may work, but I can't find out how to use it in Express.\nThis is how my server is established:\n\n```\nvar app = require('express')();\nvar cert_path = '/home/houlu/Programs/Node/http/ssl/';\nvar privateKey = fs.readFileSync(cert_path+'server.key', 'utf8');\nvar certificate = fs.readFileSync(cert_path+'server.crt', 'utf8');\nvar credentials = {key: privateKey, cert: certificate};\n\nhttpsServer = https.createServer(credentials, app);\n```\n\nThanks a lot!  :-)\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3082/comments",
    "author": "houluy",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-09-11T03:52:30Z",
        "body": "Since this is a socket-level option, this would be handled outside of Express, since Express is request/response-level (multiple request/response pairs can share a single socket).\n\nI think the following would work (not 100% sure, as the Node.js documentation isn't very clear, and I'm not at a computer to test), assuming you wanted all sockets to have this setting:\n\n``` js\nvar app = require('express')();\nvar cert_path = '/home/houlu/Programs/Node/http/ssl/';\nvar privateKey = fs.readFileSync(cert_path+'server.key', 'utf8');\nvar certificate = fs.readFileSync(cert_path+'server.crt', 'utf8');\nvar credentials = {key: privateKey, cert: certificate};\n\nvar httpsServer = https.createServer(credentials, app);\n\nhttpsServer.on('connection', function (tlsSocket) {\n  tlsSocket.setMaxSendFragment(/* whatever size */);\n});\n```\n"
      },
      {
        "user": "houluy",
        "created_at": "2016-09-11T12:41:19Z",
        "body": "Thanks a lot, I'll have a try and let you know the results.\nBesides, I think it should be 'secureConnection' instead of 'connection' in HTTPS context.\n:)\n"
      },
      {
        "user": "houluy",
        "created_at": "2016-09-12T08:41:51Z",
        "body": "It works! Thanks a lot!\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-09-12T13:14:49Z",
        "body": "Awesome, good t hear! Let us know if you have any other questions :)\n"
      }
    ]
  },
  {
    "number": 3058,
    "title": "express.Router()",
    "created_at": "2016-08-17T06:43:11Z",
    "closed_at": "2016-08-17T06:53:26Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3058",
    "body": "A function with a name starting with an uppercase letter should only be used as a constructor.\n\nThe sentence `const router = express.Router();` issues with AirBnb eslint.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3058/comments",
    "author": "cuni0716",
    "comments": [
      {
        "user": "blakeembrey",
        "created_at": "2016-08-17T06:47:42Z",
        "body": "Can you provide more context? This isn't really a bug, just an issue with your chosen linting. Why not just use `new`?\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-08-17T06:53:26Z",
        "body": "Yea, looks like a non-issue to me :) `express.Router` _is a constructor_; you can do `new express.Router()`. The `new` is optional, just like many of the object constructors in JavaScript itself (i.e. `Error('oh no!')` and `new Error('oh no!')` are identical, as the `new` keyword is optional).\n"
      },
      {
        "user": "cuni0716",
        "created_at": "2016-08-17T07:08:45Z",
        "body": "Ok, thanks for the quickly response!\n"
      }
    ]
  },
  {
    "number": 3041,
    "title": "new tag for 5.0 alpha?",
    "created_at": "2016-07-21T13:02:14Z",
    "closed_at": "2017-01-29T03:33:38Z",
    "labels": [
      "5.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3041",
    "body": "5.0-alpha.2 is the latest tag and it seems quite a ways behind the 5.0 branch. Any chance we can get a new tag cut?  \n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3041/comments",
    "author": "zackarychapple",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-07-28T17:05:10Z",
        "body": "Hi @zackarychapple, sorry for the delay in a new alpha. I really want one too, but have been away for actually way longer than I expected for uninteresting reasons. I did already merge in the latest 4.x changes to the 5.0 branch, but we just want to actually land a bunch of the pending 5.x changes."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-01-29T03:33:38Z",
        "body": "A new Express 5.0 alpha has been released: use `npm install express@5.0.0-alpha.3` to get it :)"
      },
      {
        "user": "zackarychapple",
        "created_at": "2017-01-30T13:26:32Z",
        "body": "Fantastic!  Thank you very much!"
      }
    ]
  },
  {
    "number": 3015,
    "title": "Last router's next() does not immediately invoke parent's router middleware",
    "created_at": "2016-05-29T14:15:04Z",
    "closed_at": "2016-05-29T15:46:14Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3015",
    "body": "Hi, I quess it's intended bahavior, however I would like to know why is that.\nThe next() in a context of a single router immidiately invokes next middleware registered on that router.\nSo if there is a code placed after next(), it's invoked after the next middleware is finished:\n\n``` javascript\nrouter.use(function(req, res, next) {\n    console.log(\"1\");\n    next(); // immidiately invokes next middleware\n    console.log(\"3\");\n}).use(function(req, res, next) {\n    console.log(\"2\");\n    next();\n});\n// outputs: 1 2 3\n```\n\nHowever when middleware is wrapped into another router this behavior will change.\nThe next() will instruct the router to call next() on it's parent's stack, but only after the current middleware is completely finished:\n\n``` javascript\nrouter.use(express.Router().use(function(req, res, next) {\n    console.log(\"1\");\n    next(); // the parent's next middleware is called after this one is finished\n    console.log(\"3\");\n})).use(function(req, res, next) {\n    console.log(\"2\");\n    next();\n});\n// outputs: 1 3 2\n```\n\nMaybe it's because the request object is changed inside the router, so if the next() would immediately invoke parent's middleware, the request object would change again, so it wouldn't correspond with the request intially passed to router?\nIn that case, can't the router have own copy of the request object?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3015/comments",
    "author": "urugator",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-05-29T15:46:14Z",
        "body": "> however I would like to know why is that.\n\nThere are two main reasons:\n1. A router instance has the interface of `router(req, res, callback)`, and to follow Node.js standards and not release Zalgo, `callback` is never called on the same tick.\n2. Many people had issues interacting with the Express.js `app(req, res, callback)` and `router(req, res, callback)` interfaces, since `callback` would sometimes be called on the same tick and sometimes on a future tick, all depending on what the middleware inside just happened to be doing. As of Express.js 4, we guarantee consisdent next tick behavior, regardless of what middleware are doing inside Express and Zalgo remains caged.\n"
      }
    ]
  },
  {
    "number": 3013,
    "title": "I want to rewrite res, what should I do",
    "created_at": "2016-05-27T15:24:06Z",
    "closed_at": "2016-05-27T15:44:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3013",
    "body": "i want to rewrite res in express,but i try a lot of ways, are not successful;\n\n for example\n\n``` js\napp.get(\"/hello\",function(req,res){\n     res.end();\n});\n```\n\noutput:\"66666\"\n\n``` js\nvar res=http.ServerResponse.prototype;\n\nres.end=function(){\n     console.log(\"66666\");\n     var args=[].slice.call(arguments);\n     res.end.call(args);\n }\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3013/comments",
    "author": "weiqingting",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-05-27T15:44:39Z",
        "body": "Hi @weiqingting, I'm not 100% sure what your question is, but based on \"i want to rewrite res in express\", it sounds like you're saying that you want to intercept the outbound response and change it in some way (i.e. transform the response).\n\nIf this is the case, then there is no easy way to do this issue #2811 is a tracking issue for making it more usable. Since Express.js does not actually do anything more than provide routing and a few sugar APIs, a good response rewriting API would probably need to be in Node.js core itself (which is where our `res`/`req` come from) or we have to resort to hard patches.\n"
      }
    ]
  },
  {
    "number": 2999,
    "title": "Get variable setted with middleware",
    "created_at": "2016-05-17T20:36:37Z",
    "closed_at": "2016-05-18T19:06:42Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2999",
    "body": "Before in Express 3 we could define a middleware that allow us to save variable in the req:\n\n``` js\nfunction(req, res, next){\n     req.test = \"test\";\n    next();\n}\n```\n\nAnd then we could get it with :\n\n``` js\nfunction(req,res){\n   console.log(req.test) // test\n}\n```\n\nBut now in Express 4 I managed to store it in the request but i cant get the value, when i print the object req, i can see that its stored there but i cant access to it.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2999/comments",
    "author": "CoericK",
    "comments": [
      {
        "user": "hacksparrow",
        "created_at": "2016-05-18T19:06:41Z",
        "body": "@CoericK it still works that way. Here is a working example:\n\n``` js\nvar express = require('express');\nvar app = express();\n\n// middleware for setting a custom property on the request object\napp.use(function (req, res, next) {\n  req.test = 'test';\n  next()\n})\n\napp.get('/hello', function (req, res) {\n  // accessing the custom property defined earlier\n  console.log(req.test);\n  res.send('HELLO!');\n});\n\napp.listen(5000);\n\n```\n"
      }
    ]
  },
  {
    "number": 2969,
    "title": "Parse Json Strings",
    "created_at": "2016-04-13T16:42:02Z",
    "closed_at": "2016-04-13T17:05:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2969",
    "body": "The solution provided in #2460 does not work. Returns \n`URIError: URI malformed`\n\nIn my case for example, my queries should be something of the sort:\n\n`where={%22name%22:%20{%22$like%22:%20%22%bari%22}}`\n\nWhich translates to: \n\n`\n\"where\": {\n  \"name\": {\n    \"$like\": \"%bar\"\n  }\n}\n`\n\nAny help would be appreciated. #2460 is the most similar problem I could find but did not work for me.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2969/comments",
    "author": "ybrodsky",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-04-13T17:05:43Z",
        "body": "Hi! The solution works, just your URI itself is invalid. You have a literal `%` in there, and `%` has a special meaning in a URI, so it has to be encoded. The correct query string should look like the following:\n\n```\nwhere={%22name%22:%20{%22$like%22:%20%22%25bar%22}}\n```\n"
      },
      {
        "user": "ybrodsky",
        "created_at": "2016-04-13T17:17:34Z",
        "body": "Thanks for the help.\nYou were right, nevertheless I am getting a different error now. \n`SyntaxError: Unexpected token w`\n\nIt's because of the 'where=' part when it tries to parse the json object. \nAny idea how could I go around this, without getting rid of the 'where='\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-04-13T17:20:53Z",
        "body": "If you are actually using a query string with name value pairs, then the issue you referenced actually didn't have anything to do with your issue :) You can just use the `req.query` object and parse the string that is in the `where` property:\n\n``` js\nvar obj = JSON.parse(req.query.where)\n```\n"
      },
      {
        "user": "ybrodsky",
        "created_at": "2016-04-13T17:27:18Z",
        "body": "Yea, guess you are right. =/\nThanks for the prompt help, much appreciated.\n"
      }
    ]
  },
  {
    "number": 2949,
    "title": "Route resolution with params. Firing multiple middleware - correct route returns.",
    "created_at": "2016-03-22T06:07:17Z",
    "closed_at": "2016-03-23T12:03:58Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2949",
    "body": "Hi.\n\nHaving a really weird though persistent issue. When I setup routes such as\n\n```\napp.get('/test/dosomething', middleware1, actionFn1);\napp.get('/test/:idparam', middleware2, actionFn2);\n```\n\nAnd I hit `/test/dosomething` it returns correctly. However it also fires `middleware2`. This is a problem because I will often have different authentication rules for the two routes, and it will throw an error (get in the way / be executed) before actionFn1\n\nMy workaround is to setup routes such as\n`app.get('/test/dosomething/foo', middleware1, actionFn1);`\n\nWhich works. Removing the second route also fixes the problem. \n\nIs this a bug? If not can you point me in the direction of what I am doing wrong? I have done some searching but being so weird I haven't found any answers. I can setup an open source project to demo it if need be (it currently does this on a sails like framework I maintain)\n\nKind regards,\n\nRyan\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2949/comments",
    "author": "rknell",
    "comments": [
      {
        "user": "tunniclm",
        "created_at": "2016-03-22T10:45:57Z",
        "body": "Hi @rknell \n\nI was unable to recreate this behaviour with express@4.13.4 using this example code:\n\n``` js\nvar express = require('express');\nvar app = express();\n\nfunction m1(req, res, next) { console.log('m1'); next(); }\nfunction m2(req, res, next) { console.log('m2'); next(); }\nfunction a1(req, res, next) { res.send('a1'); }\nfunction a2(req, res, next) { res.send('a2'); }\n\napp.get('/test/dosomething', m1, a1);\napp.get('/test/:idparam', m2, a2);\n\napp.listen(3000);\n```\n\nWhen I visit `/test/dosomething` I see this on the browser:\n\n```\na1\n```\n\n...and this in the log:\n\n```\n$ node app.js\nm1\n```\n\nHow does the above example differ from your code?\n"
      },
      {
        "user": "wesleytodd",
        "created_at": "2016-03-22T14:39:57Z",
        "body": "@rknell As you can see in @tunniclm's example, the `a1` middleware sends a response and does not call `next`.  My guess is that your version of `a1` is calling `next` somehow, which means that express will just continue on down the middleware chain to the next route.\n"
      },
      {
        "user": "rknell",
        "created_at": "2016-03-23T01:35:18Z",
        "body": "Hi Guys,\n\nThanks for getting back to me. I've had a further dig and it looks as though it had to do with how I was applying the middleware (There was some dynamic craziness, which I spent a few more hours yesterday working on). Still not sure why it was happening (and I will report back if I get to the bottom of it) but it seems to have resolved now. Probably can close this off.\n\nCheers and sorry for the bother,\n\nKind regards,\n\nRyan\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-03-23T12:03:58Z",
        "body": "Thanks for the update, Ryan!\n"
      }
    ]
  },
  {
    "number": 2920,
    "title": "Access default router",
    "created_at": "2016-03-02T14:07:16Z",
    "closed_at": "2016-05-04T20:41:15Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2920",
    "body": "Hi,\n\nExpress app creates the default router, is there any way to access it publicly without using private `app._router`? Need it for listing all of the routes.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2920/comments",
    "author": "pronebird",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-03-02T14:09:35Z",
        "body": "Not until Express 5.0, as `app.router` was a public property in Express 3.x, but was used in a very different way, so back in Express 4.0, it was decided to put an error on that property and simply move it to `app._router` for the time being. You're safe to use `app._router` in Express 4.x, as I consider everything you can reach part of the public API, for better or worse :)\n"
      },
      {
        "user": "hacksparrow",
        "created_at": "2016-05-04T16:59:59Z",
        "body": "@pronebird I hope your question is answered. Can we close this now?\n"
      }
    ]
  },
  {
    "number": 2912,
    "title": "Provide object with custom config parameters instead of router path",
    "created_at": "2016-02-26T16:16:29Z",
    "closed_at": "2016-02-26T18:31:43Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2912",
    "body": "In addition to\n\n``` js\nrouter.get('news/create', callback)\n```\n\nI want to write\n\n``` js\nrouter.get({\n    path: 'news/create',\n    authorization: true //custom parameter in req\n}, callback)\n```\n\nIt simpler to check custom parameter in middleware then to set authentification middleware for every router declaration especially when you have a lot of middlewares in your project\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2912/comments",
    "author": "tamtakoe",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-02-26T18:31:43Z",
        "body": "Hi @tamtakoe, I'm not 100% sure what you are expecting the `authorization: true` option to do, but this should be doable in the current Express.js mechanisms. You'll find that Express.js does have quite a different philosophy from, say, Hapi.js. For example, your example, like Hapi.js, is very configuration-orientated, while Express is done using convention. Part of the tagline for Express is \"minimal\", and as part of that philosophy, the routing is very simplistic and flexible, allowing for you to add middlewares on the routes.\n\nYou can of course always subclass the router with your own router that does the addition automatically.\n"
      }
    ]
  },
  {
    "number": 2911,
    "title": "Modifying req.params",
    "created_at": "2016-02-26T12:39:43Z",
    "closed_at": "2016-02-26T14:21:10Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2911",
    "body": "I am having some issues adding properties to `req.params`. It seems the params get wiped out when stepping to the next middleware:\n\n```\nfunction foobarRouter(type) {\n  var router = express.router();\n  router.use(function (req, res, next) {\n    req.params.type = type;\n    next();\n  });\n  router.get('/',         renderPage('foobars'));\n  router.get('/new',      renderPage('foobar_edit'));\n  router.get('/:id',      renderPage('foobar'));\n  router.get('/:id/edit', renderPage('foobar_edit'));\n}\napp.use('/foo', foobarRouter('foo'));\napp.use('/bar', foobarRouter('bar'));\n```\n\nDespite explicitly setting `req.params.type`, it is undefined in `renderPage`.\n\nI had a look at `mergeParams: true`, but it seems that this only preserves the params from the parent, which doesn't work in this case because the parent (the `app.use`) doesn't have any real params.\n\nIt would work if I did, `app.use('/:type', foobarRouter());`, but the route needs to be restricted to specific types only.\n\nHow can I modify the `req.params` for a sub-router so that it looks like they came from the parent?\n\nThanks.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2911/comments",
    "author": "SystemParadox",
    "comments": [
      {
        "user": "tunniclm",
        "created_at": "2016-02-26T13:28:13Z",
        "body": "AFAIK `req.params` is populated by the route based on `:` tokens or regexp  capture groups within the route definition and is not for storing general values. Typically middleware will store values as properties directly on the `req` object. Be careful not to chose a property that clashes with the base request object or any other middleware you are using though.\n"
      },
      {
        "user": "tunniclm",
        "created_at": "2016-02-26T13:32:20Z",
        "body": "(Also, I assume this code is not what you are actually using since it contains some typos/bugs)\n\nHere's what I used for checking:\n\n``` js\nvar express = require('express');\nvar app = express();\n\nfunction renderPage(name) {\n  return function(req,res,next) {\n    res.send('params: ' + JSON.stringify(req.params) + ', req.params.type: ' + req.params.type + ', req.mytype: ' + req.mytype);\n  }\n}\n\nfunction foobarRouter(type) {\n  var router = express.Router();\n  router.use(function (req, res, next) {\n    req.params.type = type;\n    req.mytype = type;\n    next();\n  });\n  router.get('/',         renderPage('foobars'));\n  router.get('/new',      renderPage('foobar_edit'));\n  router.get('/:id',      renderPage('foobar'));\n  router.get('/:id/edit', renderPage('foobar_edit'));\n  return router;\n}\napp.use('/foo', foobarRouter('foo'));\napp.use('/bar', foobarRouter('bar'));\n\napp.listen(3000);\n```\n"
      },
      {
        "user": "SystemParadox",
        "created_at": "2016-02-26T14:08:17Z",
        "body": "Adding properties directly to the `req` object isn't any better than passing them to `renderPage` directly, I still have to handle them manually.\n\nIt's a bit frustrating that params can only be added by the URL parser and not in code anywhere.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-26T14:21:10Z",
        "body": "Hi @SystemParadox, in your example, you are actually modifying `req.params` just fine, but perhaps asking the question \"where did the object `req.params` come from?\" may help understand why your modification disappears in another route.\n\n`req.params` is not like `res.locals`, which is a global object set at the start of Express, rather `req.params` is actually being set as a result of the URL parse. This means that when you where in `router.use(function (req, res, next) {`, the `req.params` object was the result of parsing the URL against `/\\/?/`, which means `req.params = {}`.\n\nNow, you adding a new property to that object in your middleware, which is nice and all, and actually continues to exist... until the next URL parse, because guess what? Express needs to signal what params it found on the current URL parse.\n\nYour code example is not enough to understand the goal you are trying to achieve by setting `req.params.type`, but perhaps you want to use `res.locals.type` instead, as this is one of the global bags Express provides for you to store things between middlewares and routes.\n\n**Edit** Meant `res.locals`, but accidentally originally wrote `req.locals`.\n"
      },
      {
        "user": "SystemParadox",
        "created_at": "2016-02-26T15:45:02Z",
        "body": "Yes I realise why the `req.params` is being overwritten. However, there is `mergeParams: true` which is half way there, I'm just unable to manually set the params early enough for `mergeParams` to work.\n\nWhat I'm trying to achieve is something akin to this:\n\n```\nvar router = express.Router({ mergeParams: true });\napp.use('/:type', router);\n```\n- (Where `:type` is available to handlers defined on `router`)\n- **BUT** the router should only be traversed for specific types, because there is no way to back-out of a sub-router once in it (apart from making none of the routes inside it match, which is pointless)\n\nI was hoping I was just missing something, but at the moment it seems like this is not possible. I guess I will just have to do it the less concise way. I'm not even sure what changes I would propose to make express handle this, unless anyone else has any suggestions?\n\nThanks.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-26T16:00:01Z",
        "body": "Hi @SystemParadox, from your description of the goal, it sounds like what you want is the following:\n\n``` js\nvar router = express.Router({ mergeParams: true });\napp.use('/:type', typeRouter('foo', router)); // only runs router when /foo\n\nfunction typeRouter(type, router) {\n  return function (req, res, next) {\n    if (req.params.type !== type) return next();\n    router(req, res, next);\n  };\n}\n```\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-26T16:04:32Z",
        "body": "The `mergeParams` in my example is not needed for it to function, I just included it because you had it. It would only be necessary if you wanted `req.params.type === 'foo'` inside the router itself. The example is also the exact way Express is design to handle the use-case you've provided, and ideally at some point these kinds of design patterns that Express looks for can be documented, as it's only discover-able currently once you fully understand the concepts of Express.\n"
      },
      {
        "user": "tunniclm",
        "created_at": "2016-02-26T16:06:27Z",
        "body": "@dougwilson Would `app.use('/:type(foo|bar)', router);` also be a reasonable solution?\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-26T16:08:51Z",
        "body": "@tunniclm, indeed! Didn't even think about that :) That's even simpler if the reduced regular expressions provides the necessary match :)\n"
      },
      {
        "user": "SystemParadox",
        "created_at": "2016-03-03T10:21:44Z",
        "body": "@dougwilson yes that's it exactly! I knew there had to be something!\n\nThanks very much for your help :)\n"
      }
    ]
  },
  {
    "number": 2910,
    "title": "Blank PDF when served from Express",
    "created_at": "2016-02-25T20:31:06Z",
    "closed_at": "2016-02-25T21:51:56Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2910",
    "body": "Similar to #1555 but that one was closed so not sure if my comment will get any attention.\nCopying my comment from there.\n\nI am running into similar issue with my first ever nodejs service. I have following:\n\n``` javascript\n\nvar headers = {} \n///Setting some custom headers for authentication\n\nvar urlObj = new URL( url );\nvar options = {\n            host: urlObj.host,\n            path: urlObj.pathname + urlObj.query,\n            headers: headers\n };\n http.get( options, function( response ) {\n            var body = '';\n            response.on( 'data', function( data ) {\n                body += data;\n             } );\n\n             response.on( 'end', function() {\n                  res.set( 'Content-Type', 'application/pdf' );\n                  res.send( new Buffer( body, 'binary' ) );\n             } );\n } );\n```\n\nBut I see a blank PDF with the correct number of pages and browser renders it as a PDF but all pages are empty.\nAccessing the `url` directly shows the right pdf so the pdf is fine.\nAny input will be really appreciated.\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2910/comments",
    "author": "vinodmehta",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2016-02-25T21:40:20Z",
        "body": "For stuff like this I usually use the `request` module, you could try something like this:\n\n``` javascript\nvar request = require('request');\nvar app = require('express')();\n\napp.get('/my-pds.pds', function (req, res) {\n  var opts = {} // ...\n  request.get(opts).pipe(res);\n});\n```\n\nRequest and express handle the rest.\n\nAlso, fyi, people who follow the repo also get notifications for comments on closed issues, so your other comment would get seen.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-25T21:44:05Z",
        "body": "> Also, fyi, people who follow the repo also get notifications for comments on closed issues, so your other comment would get seen.\n\nBut I would say it's best practice to open a new issue unless you have something specific to add to the other issue :) More often than not, a \"me too\" ends up with a different answer, and the original issue author gets emails for something they don't care about. It also means that even if we get the emails, we can't forget to answer you, since we'll see an open issue :)\n"
      },
      {
        "user": "wesleytodd",
        "created_at": "2016-02-25T21:45:02Z",
        "body": "Good to know, thanks @dougwilson :)\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-25T21:51:56Z",
        "body": "And of course, just to iterate on the answer from @wesleytodd, hopefully his answer should fix your issue, @vinodmehta. The reason you are seeing odd behavior is because the way you are piping the PDF file ends up corrupting the file, because the operation `body += data;` will actually cause the `data` Buffer to get decoded as if it was UTF-8 into a string, which will corrupt binary data.\n\nThe `request` module is a really good approach, and I would recommend that, as it's very straight-forward and simple :)\n\nIf you wanted to tweak your original code to see where you went wrong, here is a simple tweak that should address the binary data corruption:\n\n``` js\nvar headers = {} \n///Setting some custom headers for authentication\n\nvar urlObj = new URL( url );\nvar options = {\n            host: urlObj.host,\n            path: urlObj.pathname + urlObj.query,\n            headers: headers\n };\n http.get( options, function( response ) {\n            var body = []; // we're going to store all the chunks of binary data\n            response.on( 'data', function( data ) {\n                body.push(data); // build up an array of Buffers\n             } );\n\n             response.on( 'end', function() {\n                  res.set( 'Content-Type', 'application/pdf' );\n                  res.send( Buffer.concat(body) ); // join all the buffers together as a binary blob\n             } );\n } );\n```\n"
      },
      {
        "user": "vinodmehta",
        "created_at": "2016-02-26T00:03:53Z",
        "body": "Thanks. Yes `request` module really simplified the code a lot to basically one liner.\n\n``` javascript\nrequest.get( { url: url, headers: headers } ).pipe( res );\n```\n"
      }
    ]
  },
  {
    "number": 2873,
    "title": "All Router middleware installed before route.METHOD installations should run before them",
    "created_at": "2016-01-30T12:31:09Z",
    "closed_at": "2016-02-15T10:30:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2873",
    "body": "The following code should respond with \"forbidden\" but instead executes the route handler and responds with \"was not cancelled\".\n\nIf the route is created before the middleware is installed, then the method handlers installed after the middleware cannot be cancelled by the middleware, the middleware does not even run in this case.\n\n```\nvar express = require('express');\n\nvar router = express.Router();\n// NB: if the route is created here, before the middleware is installed, then it cannot be cancelled by the middleware\nvar route = router.route('/test');\n\nrouter.use(function(req,res,next) {\n    // cancel execution\n    console.log('cancelling execution');\n    res.send(\"FORBIDDEN\\n\");\n});\n\nroute.get(function(req, res) {\n    console.log('execution was not cancelled');\n    res.send(\"WAS NOT CANCELLED\\n\");\n});\n\nexpress().use(router).listen(8123);\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2873/comments",
    "author": "timlind",
    "comments": [
      {
        "user": "timlind",
        "created_at": "2016-01-30T12:34:47Z",
        "body": "feature request #1980 would of course help with this. #2828 \n"
      },
      {
        "user": "sjanuary",
        "created_at": "2016-02-02T15:00:50Z",
        "body": "I played around with your code a bit and if you add a next() call to your 'route.get' middleware then your 'router.use' middleware will be called, it just comes second.  It seems like the 'get' middleware takes precedence if the route is created first because it's set on the **route** itself, which is higher up the hierarchy than the router's 'use' middleware.  If the route is created after the 'use' middleware then the route is lower down the hierarchy so the 'use' middleware gets called first.\n\nI'm not sure it's very clear from the docs whether this is a bug, or just that the way it currently works could be better documented.  Since the route is created first in your example it could be argued that any middleware on that route should be executed before middleware added later to the router.\n"
      },
      {
        "user": "sjanuary",
        "created_at": "2016-02-11T14:25:32Z",
        "body": "I'd be happy to make a doc update to clarify how ordering currently works when `Route` is used, but I don't want to shut down discussion by doing that if anyone else wants to comment?\n"
      },
      {
        "user": "Fishrock123",
        "created_at": "2016-02-11T14:35:05Z",
        "body": "The output is correct for this code, handlers are executed in the order they were registered.\n\nThis is due to the fact that `router.route()` is a shortcut to the attached `{methodname}` handlers.\n\n@sjanuary Is also correct, that the middleware will be called if you tell your route to also call to the next middleware, although usually that isn't what you'd do. (Typically routes are endpoints after regular middleware.)\n\n@sjanuary whatever you feel is necessary, but afaik this is the correct behavior.\n"
      },
      {
        "user": "Fishrock123",
        "created_at": "2016-02-11T14:36:04Z",
        "body": "(Also don't be afraid to tag issues! 😀)(I think you have access to that?)\n"
      },
      {
        "user": "sjanuary",
        "created_at": "2016-02-15T10:30:41Z",
        "body": "Raised an issue in expressjs.com to document this.\n"
      }
    ]
  },
  {
    "number": 2840,
    "title": "Sending buffer yields inconsistent results",
    "created_at": "2016-01-05T23:15:21Z",
    "closed_at": "2016-01-06T01:53:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2840",
    "body": "I have a buffer for a png file. Sending the buffer as a GET response produces an inconsistent result.\n\nFor the same buffer (`which starts with <Buffer 89 50 4e`) sometimes I get a file with the first bytes as hexadecimal `89 50 4e 47 0d` which is correct for a png file and sometimes I get a file which begins with `ef bf bd 50 4e` which is incorrect.\n\nAll of the following cases have the same behavior (work sporadically):\n\n1)\n    `res.end(fileBuffer);`\n\n2)\n   `res.end(fileBuffer, 'binary');`\n\n3)\n    `res.write(fileBuffer, 'binary');\n    res.end(null, 'binary');`\n\nSome other facts:\n\nThe buffer is not the problem since I tested saving it in the file system, and it is always a successful operation.\n\nI've tried several other alternatives for sending the image with no success; like having a base64 string for the buffer and sending it with base64 encoding. But for this issue I keep the problem in the buffer case. And the problem occurs also for other kind of files, but again I keep it in the png case.\n\nFor some png files the problem never occurs. For other png files I have the inconsistent results problem.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2840/comments",
    "author": "josevillacreses",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-01-05T23:46:09Z",
        "body": "Hi! There is likely nothing we can do without at least you providing code we can run to reproduce the issue. Just trying to write a simple app that sends that buffer always results in consistent correct responses.\n\nSo, in order for us to proceed, please either issue us a pull request that fixes the issue or you need to provide us enough information to reproduce, at least the following:\n1. Version of Express\n2. Version of Node.js\n3. A complete application file that reproduces the issue we can run.\n4. Complete instructions for how to call the app to see the issue.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-01-05T23:47:43Z",
        "body": "And, just to note, the methods `res.end` and `res.write` are not implemented in Express, as those are just the methods that are part of Node.js core. If you are having issues with those methods, you will likely need to file a bug against Node.js, which is where those methods come from.\n"
      },
      {
        "user": "josevillacreses",
        "created_at": "2016-01-06T00:00:02Z",
        "body": "Thank you for your quick answer.\n\nThe exact same behavior happens with `res.send(fileBuffer);`.\n\nI'll be uploading the info you request.\n\nThank you again.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-01-06T00:21:48Z",
        "body": "No problem! Yea, though `res.send` just calls `res.end`, so if you have an issue there, it of course will also be in `res.send`, which we still won't be able to fix. I'll await all the info from you soon :) \n"
      },
      {
        "user": "josevillacreses",
        "created_at": "2016-01-06T00:52:22Z",
        "body": "In isolating the issue in a simple application, I encountered the problem does not occur. Of course, it is not the same exact scenario as the original application with the problem.\n\nSo, please don't close it until I gather some more information about the issue.\n\nThank you for your kind help.\n"
      },
      {
        "user": "josevillacreses",
        "created_at": "2016-01-06T01:53:27Z",
        "body": "I identified where the problem is: for development purposes I use `grunt-connect-proxy` as a proxy server in front of my node server. There it is the mess-up.\n\nThank you for your time.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-01-06T15:54:54Z",
        "body": "Ah, gotcha. Thanks for the follow up! I'm sure someone will run into this same issue at some point and find the answer helpful :)\n"
      }
    ]
  },
  {
    "number": 2830,
    "title": "charset=utf8 inserted between two phrase media type in response header",
    "created_at": "2015-12-17T23:32:52Z",
    "closed_at": "2015-12-17T23:56:07Z",
    "labels": [
      "3.x",
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2830",
    "body": "Hi,\n\nExpress is mangling the response header I'm trying to set for a two phrase media type\n\nWe are establishing a HATEOAS convention where we have a generic collection type, designated as a vnd, and various media types which might be collected there, also a vnd. \n\n```\nres.set('content-type', 'application/vnd.samcorp.collection;content=\"application/vnd.samcorp.foo\"');\n\n```\n\nRead this as - we are sending you a samcorp collection of samcorp.foos. \n\nExpress renders the header as:\n\n```\nHTTP/1.1 200 OK\nX-Powered-By: Express\nContent-Type: application/vnd.samcorp.collection; charset=utf-8; content=\"application/vnd.samcorp.foo\"\n...\n```\n\nIs there a way I can get rid of the intruding charset header?\n\nIt's worth noting that I had to do a lot of googling to discover how to include the content specifier. Using what is below results in an invalid parameter error from Express, so the double quotations in what was above became necessary.\n\n```\n res.set('content-type', 'application/vnd.samcorp.collection;content=application/vnd.samcorp.foo');\n\n```\n\nThanks,\nNicholas\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2830/comments",
    "author": "nicholasf",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-12-17T23:56:06Z",
        "body": "Hi! This is expected behavior and is 100% to the HTTP specification to how the `Content-Type` header works. If your client is confused by the re-formatting, then it has a buggy implementation and does not follow the HTTP specifications correctly.\n\nThat said, if you simply want to avoid us adding the `charset` parameter to your `Content-Type` header, you have to methods:\n1. Provide a `Buffer` object to `res.send` instead of a string. We will not add the `charset` parameter, because we are not doing any encoding to your response.\n2. Skip using `res.send` altogether and use the lower-level Node.js `res.write`/`res.end` methods.\n\nI hope this helps!\n"
      },
      {
        "user": "nicholasf",
        "created_at": "2015-12-17T23:59:50Z",
        "body": "@dougwilson thanks, yeh, it does. I'll delve into the two options you suggest. Thanks for offering them.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-12-18T00:03:59Z",
        "body": "No problem! This is a case where Express is adding sugar through things like `res.send` and `res.json`, and trying to ensure that your responses are a spec-compliant as possible (which is why you also had to quote the second type, as it contained characters that were not valid as a parameter value unless quoted), is conflicting with something you are trying to achieve.\n\nThe way we usually recommend attacking this is to report here so we can double-check that it makes sense from a spec point-of-view (which it looks like it does based on your report) and offer the methods to avoid the sugar :)\n"
      }
    ]
  },
  {
    "number": 2826,
    "title": "Memory leak on nodeJs strongloop strong supervisor",
    "created_at": "2015-12-13T03:07:06Z",
    "closed_at": "2015-12-15T20:32:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2826",
    "body": "Our node supervisor is having memory leak and it's getting crashed. For below memory it takes around 2 weeks before we get OOM error.\n\n```\n// boot script\nstart() { \n    cd ${APPDIR} \n    mkdir -p ${LOGDIR} \n    killall node \n    sleep 5 \n    rm -rf ${APPDIR}/.tmp \n    (slc run --no-profile -d --cluster <%= @clusters %> --log ${LOGDIR}/${APP_NAME}.log -p ${LOGDIR}/${APP_NAME}.pid ${APPDIR}/${APP} --port **** --max-old-space-size=8192)    RETVAL=$?\n```\n\n//strongloop\n\n```\n/user/lig/node_modules/strongloop/nod_modules/strong-supervisor/bin/sl-run.js --no-profile --no-detach--cluster cpus --log/log\n```\n\nit runs on AWS m3.large 7.5 GB ram. There are 3 instances in cluster\n\nAny suggestions are appreciated\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2826/comments",
    "author": "vinojoy",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-12-13T03:36:50Z",
        "body": "Hi! We can certainly help, but with no known memory leaks in Express and without any code, I'm not sure how we can help.\n\nWe need the following information in order to proceed:\n1. Version of Express you are using\n2. Version of Node.js you are using\n3. An entire application we can run that reproduces the issue. Try to keep the number of requires as small as possible, as anything can introduce a memory leak. Ideally the only require statement in your entire app is for express.\n"
      },
      {
        "user": "vinojoy",
        "created_at": "2015-12-15T00:29:06Z",
        "body": "1) Version of Express you are using : 4.13.3\n2) Version of Node.js you are using  : v0.10.39\n3) Not sure how to share that info \n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-12-15T01:04:20Z",
        "body": "Hi @vinojoy , if you cannot paste the application in this field, then you hve too much going on. You should trim your application down to something small, only using Express, to demonstrate that the memory leak actually is coming from Express and not something in other dependency, your code, or the interaction between things.\n\nFor example, your issue here is that there is a memory leak in Express. I assume that you have done all the debugging, which has pointed to it specifically being in Express. Can you at least share your findings that point to the issue being Express?\n\nWithout being able to see the memory issue ourselves, we are in the dark and there is pretty much no action we can possibly do on this issue. I know you said \"Any suggestions are appreciated\", but I'm not sure what suggestions I can give. Are you looking for something in particular? I have never used the `strong-supervisor` module you are showing above and it is not even part of Express.\n"
      },
      {
        "user": "vinojoy",
        "created_at": "2015-12-15T17:55:56Z",
        "body": "@dougwilson issue seems to  be on strong supervisor which is part of strongloop\n"
      },
      {
        "user": "vinojoy",
        "created_at": "2015-12-15T17:57:58Z",
        "body": "i will be moving this thread to strong supervisor \n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-12-15T20:32:01Z",
        "body": "Ok. I'm closing this as a question, but I can always re-open if you have additional details.\n"
      },
      {
        "user": "vinojoy",
        "created_at": "2015-12-15T21:30:54Z",
        "body": "Thanks\n"
      }
    ]
  },
  {
    "number": 2807,
    "title": "Error: EMFILE, too many open files",
    "created_at": "2015-11-18T14:43:58Z",
    "closed_at": "2015-12-15T04:12:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2807",
    "body": "This error is thrown for every static file which express tries to open and send as http response (.html, .js. img, etc). This happens when fd (file descriptors) get flooded in linux. Any idea why express (fs module) is not gracefully closing the file descriptors when not in use?\n\nI started getting this error when I moved my Express Server to production environment (When I started getting traffic in website).\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2807/comments",
    "author": "shankscript",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-11-18T15:22:51Z",
        "body": "Hi @shanksrepo , all our tests for fd closing are passing and as far as we know, fds get closed. I can't really say much more without a way to reproduce the issue, though.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-12-15T04:12:14Z",
        "body": "Hi @shanksrepo , I'm closing this issue due to it going stale. If you can provide some additional information, like perhaps version of Express, version of Node.js, and an example server that reproduces the issue along with the steps to reproduce, we can take a closer look :)\n"
      },
      {
        "user": "gkorland",
        "created_at": "2017-12-15T11:21:37Z",
        "body": "Is there any solution for this case?\r\nWe started getting this error:\r\n```\r\n    Error: EMFILE: too many open files, open 'XXX\\xx.js'\\r\r\n```"
      }
    ]
  },
  {
    "number": 2794,
    "title": "How to get name of template used to render the current route?",
    "created_at": "2015-11-09T17:07:53Z",
    "closed_at": "2015-11-11T02:21:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2794",
    "body": "How can I get the name of the template that was used to render the current route? For example if you are on a route `GET /mypage` rendered by a template `mypage.jade` and submit a form to `POST /mypage` route, then within the POST /mypage route handler how do you get the name of the template mypage.jade?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2794/comments",
    "author": "rightaway",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-11-11T02:21:18Z",
        "body": "Hi! Unless you convey that information somehow, then there is no way to get at it. One possibility is to add a hidden `<input>` element to the form on that page and add some information in the value to signal what the template is.\n"
      }
    ]
  },
  {
    "number": 2777,
    "title": "emitting events on listen/close and not only on mount",
    "created_at": "2015-10-14T14:11:57Z",
    "closed_at": "2015-10-14T14:30:28Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2777",
    "body": "I have been using express.js a while now and I just realized that the app object we get from `require('express')()` is inheriting from event emitter.\nI do quite regularly write unit tests for API express apps and I have always tried to search for a nice way of letting my test know, that the app is already listening.\nJust now I realized, that subscribing to an event would be the easiest solution. A small problem is-express app is not emitting such an event. Only event emitted throughout whole codebase is 'mount'.\nIt can be easily done manually:\n\n``` javascript\napp.listen(config.port, function() {\n  app.emit('listening')\n  console.log(\"Express server is listening on \" + config.port)\n})\n```\n\nI think everyone would benefit greatly from `listen` and `close` events being fired by default in the expressJS codebase. I don't think this goes against lightweight nature of express.\nWhat do you think?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2777/comments",
    "author": "capaj",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-10-14T14:30:28Z",
        "body": "Hi! Unfortunately it's not possible to add this feature. The reason is that the `app` is not connected in any way to a Node.js core server (the `app.listen()` method is just a convenience for `http.createServer(app).listen()`, not a true API). In fact, Express apps can be used without a server at all or in multiple servers at once.\n"
      }
    ]
  },
  {
    "number": 2770,
    "title": "Each request is calling linux stat",
    "created_at": "2015-09-30T14:39:19Z",
    "closed_at": "2015-09-30T16:42:58Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2770",
    "body": "Hi,\nWe added some monitoring to our servers lately after finding some unexpected latency on some times, and saw on our calls to the servers latency is caused by calling linux stat command.\nWe are still investigating to see if this may be related to other used services, but can it be express related issue? \n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2770/comments",
    "author": "eranbrill",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-09-30T14:47:54Z",
        "body": "The express.static will call stat to see if a file exists or not. If you are using express.static to serve files, then yes, you will see a stat. Ideally your express.static should be .use()d after your routes to avoid unnecessary stat calls.\n"
      },
      {
        "user": "eranbrill",
        "created_at": "2015-09-30T16:42:58Z",
        "body": "Works Like A charm, thanks !\n"
      }
    ]
  },
  {
    "number": 2765,
    "title": "Terminating request after handling an error",
    "created_at": "2015-09-27T14:47:03Z",
    "closed_at": "2015-09-28T22:13:52Z",
    "labels": [
      "3.x",
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2765",
    "body": "I've been tinkering with file upload streams and came across such scenario:\n1. something causes an error and this error is passed down to the custom error handler\n2. the custom error handler invokes `res.status(500).send(message)`\n3. request is still not terminated\n   This is caused by data waiting on the request to be handled. I want the request to terminated soon after 2 happens.\n\nI've looked into the `express` code and noticed that there is a last handler I could pass the error to. The problem is, in \"production\" mode a generic error message would be sent to the user, whereas I'd prefer a custom message. Tampering with `http.STATUS_CODES` is out of question for me.\n\nAfter looking a bit further and experimenting, I've created such a snippet:\n\n```\napp.use((err, req, res, next) => {\n  // Print error\n  console.error(err.stack);\n\n  function write() {\n    res.status(500).send('Internal server error - see logs for details');\n  }\n\n  if (req.complete) {\n    return write();\n  }\n\n  // Terminate request if there is unsent data\n  req.unpipe();\n  req.on('end', write);\n  req.resume();\n});\n```\n\nThe bottom part is obviously copied from the `finalhandler` lib.\n\nMy question (at last) is: can this be done a bit cleaner? Getting there wasn't that easy and the result looks a bit complicated. Did I miss something in the docs?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2765/comments",
    "author": "fatfisz",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-09-27T15:00:05Z",
        "body": "No, you did not miss anything. The issue here is a Node.js core issue. The finalhandler contains a workaround for the Node.js core issue, but it is not fool proof and can have some nasty effects, so I don't recommend using it if you want to be sure the client gets your message.\n\nYou would have the exact same problem if you were just using the \"http\" module from Node.js core directly and not Express.\n\nTypically, the suggested pattern to get around this problem is two things 1) open an issue with Node.js to see what can be done or 2) at the site you are reading from the request, even if you have an error, finish reading the entire request before calling next(error) (this is what the body-parser and multiparty modules do).\n"
      },
      {
        "user": "fatfisz",
        "created_at": "2015-09-27T15:32:05Z",
        "body": "Thanks for the quick response :) That clarifies things a bit; I will look further into this issue.\n\nAbout 2 - it would be better to terminate the request immediately, since there may be a lot of data awaiting. If the error occurs at 5% of upload, then keeping user waiting for the next 95% is undesirable for me.\n\nCould you write more about those \"nasty effects\"? Is this about memory leaks or something else?\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-09-27T15:52:51Z",
        "body": ">  would be better to terminate the request immediately, since there may be a lot of data awaiting. If the error occurs at 5% of upload, then keeping user waiting for the next 95% is undesirable for me.\n\nRight, but using the pattern in finalhandler, you'll just end up waiting for that 95% anyway, so you are not saving any time by copying that pattern :) The only successful way Node.js give you to terminate at the 5% is using req.destroy(), which won't send your response (which leads back to possibility a bug in Node.js core).\n\n> Could you write more about those \"nasty effects\"? Is this about memory leaks or something else?\n\nIt is with things like calling .unpipe() in a context where you do not know what is piped--that destination may now never close some related file descriptor and you'll end up with a fd leak or other really hard to notice things. That's why I would recommend handling this condition at the site you are reading from the request, since you'll know what you need to clean up.\n"
      },
      {
        "user": "fatfisz",
        "created_at": "2015-09-27T16:05:29Z",
        "body": "> Right, but using the pattern in finalhandler, you'll just end up waiting for that 95% anyway, so you are not saving any time by copying that pattern :)\n\nI've missed that :/ Just tested this with a 3.5GB file, which takes 14s to upload. When I invoke an error after 1GB is uploaded, it is printed immediately (after 4s or so), but the request still takes full 14s to end.\n\nIt seems that the best way for me is to save an info about error somewhere on the server side, then destroy the request, and handle this on client side by querying the server with a request id or something.\n\nOr just abandon the whole \"immediate termination\" idea and just let users reap what they've sown by trying to upload too much data.\n\nThanks again for help!\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-09-28T22:13:52Z",
        "body": "It's no problem! I'm going to close this issue for now, but please feel free to reach out! Also, let me know if there is something you wanted to keep this issue for and I can definitely reopen.\n"
      }
    ]
  },
  {
    "number": 2758,
    "title": "weird 404 in Express router",
    "created_at": "2015-09-18T02:55:47Z",
    "closed_at": "2015-09-18T03:45:31Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2758",
    "body": "We have been getting this 404 error message on our server for months now and have been ignoring the message but it hasn't gone away, and I have no idea where it comes from:\n\n```\n\"Error: 404: Not Found\",\n\"    at /opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/setup/setupExpress.js:47:15\",\n\"    at Layer.handle [as handle_request] (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/layer.js:95:5)\",\n\"    at trim_prefix (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:312:13)\",\n\"    at /opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:280:7\",\n\"    at Function.process_params (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:330:12)\",\n\"    at next (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:271:10)\",\n\"    at jsonParser (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/body-parser/lib/types/json.js:100:40)\",\n\"    at Layer.handle [as handle_request] (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/layer.js:95:5)\",\n\"    at trim_prefix (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:312:13)\",\n\"    at /opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:280:7\",\n\"Error: 404: Not Found\",\n\"    at /opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/setup/setupExpress.js:47:15\",\n\"    at Layer.handle [as handle_request] (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/layer.js:95:5)\",\n\"    at trim_prefix (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:312:13)\",\n\"    at /opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:280:7\",\n\"    at Function.process_params (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:330:12)\",\n\"    at next (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:271:10)\",\n\"    at jsonParser (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/body-parser/lib/types/json.js:100:40)\",\n\"    at Layer.handle [as handle_request] (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/layer.js:95:5)\",\n\"    at trim_prefix (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:312:13)\",\n\"    at /opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:280:7\",\n\"Error: 404: Not Found\",\n\"    at /opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/setup/setupExpress.js:47:15\",\n\"    at Layer.handle [as handle_request] (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/layer.js:95:5)\",\n\"    at trim_prefix (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:312:13)\",\n\"    at /opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:280:7\",\n\"    at Function.process_params (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:330:12)\",\n\"    at next (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:271:10)\",\n\"    at jsonParser (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/body-parser/lib/types/json.js:100:40)\",\n\"    at Layer.handle [as handle_request] (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/layer.js:95:5)\",\n\"    at trim_prefix (/opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:312:13)\",\n\"    at /opt/csv/var/lib/smartconnect/0.0.2-csv.139/nodejs/node_modules/express/lib/router/index.js:280:7\",\n```\n\nany idea?\neach block is identical, I just kept the repeats so you know that you got the entire error stack\n\n(you can ignore the extra quotes on each line, they have to do with JSON formatting in browser output)\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2758/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "ORESoftware",
        "created_at": "2015-09-18T02:57:43Z",
        "body": "line 47 of our Express app, is of course\n\n```\n// catch 404 and forward to error handler\napp.use(function (req, res, next) {\n    var err = new Error('404: Not Found');   //this line :)\n    err.status = 404;\n    next(err);\n});\n```\n\nso that doesn't help\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-09-18T03:45:31Z",
        "body": "Basically what is happening is that in your code above, you are creating a new `Error` object on line 47, and then you are calling `next(err)`. If you do not then have any kind of `app.use(function (err, req, res, next) {` declaration after that middleware, the error will be automatically handled by Express, which includes printing the error's stack trace to STDERR.\n"
      },
      {
        "user": "ORESoftware",
        "created_at": "2015-09-18T04:09:06Z",
        "body": "yeah, I guess my question is that I have no idea where the 404 originates from. I am sure it's my error not Express' but it is a mystery. I just changed the above to this:\n\n``` javascript\n// catch 404 and forward to error handler\napp.use(function (req, res, next) {\n    var err = new Error('404: Not Found ' + req.originalUrl); //here\n    err.status = 404;\n    next(err);\n});\n```\n\nwe'll see if I can track it down. The other possiblity is that I am doing this somewhere in the code\n\n``` javascript\nnext(null);\nres.send({});\n```\n\nso what's happening is that the response is being sent successfully, but the 404 error handler is also being invoked, this is probably the case, you can just close this ticket, it's probably my mistake\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-09-18T04:58:48Z",
        "body": "Ah, I see what you mean; I misunderstood your original request :)\n\nSo, looking at your stack trace there, you can rule out the possibility of those being generated from a `next(null); res.send({})';`, as it shows that a request came in, went through your `bodyParser.json()` and then ended, due to no routes being matched.\n\nYour idea of adding `req.originalUrl` will be your best bet, as based on the stack trace, it's just a request coming into your server that you have no route for. The most common ones would be `/favicon.ico` or `/robots.txt` if you don't have those on your server.\n"
      },
      {
        "user": "ORESoftware",
        "created_at": "2015-09-18T05:26:34Z",
        "body": "i see, yeah, that could be it, will let you know, the 404s appeart out of nowhere\n"
      },
      {
        "user": "ashenwgt",
        "created_at": "2017-03-11T07:38:44Z",
        "body": "I also got the same error and found this thread while searching an answer. \r\n\r\nHere I'm sharing the way that you should tackle this error.\r\n\r\n1) First comment out the lines which handle your 404 error.\r\n```javascript\r\n// catch 404 and forward to error handler\r\n// app.use(function (req, res, next) {\r\n//    var err = new Error('404: Not Found ' + req.originalUrl); //here\r\n//    err.status = 404;\r\n//    next(err);\r\n// });\r\n```\r\n\r\n2) Now reload your page and you will see something like \r\n\r\n> Cannot GET /(some route)\r\n\r\n3) Understanding: The 404 or Not Found error message is the standard HTTP response code, to indicate that the client was able to communicate with a given server, but the server could not find what was requested. And it now says the missing resource is on the route \"/(some route)\".\r\n\r\n4) Handling the error\r\n\r\nIf it's a web page, the problem is \"/(some route)\" cannot be found in the JS files in ~/routes/ directory. You may have forgotten to handle that route or can be a typo or something. Handle it appropriately.\r\n\r\nIf it's a resource, make sure the resource exists in the mentioned route of your project. \r\n\r\n"
      },
      {
        "user": "Dill1",
        "created_at": "2018-12-10T19:22:23Z",
        "body": "For me they were requests to the sourceMapping (.js.map) files for 3rd party js files - I removed the //#sourceMappingURL line in the files. "
      }
    ]
  },
  {
    "number": 2740,
    "title": "Middleware conflicts - question",
    "created_at": "2015-08-21T19:20:01Z",
    "closed_at": "2015-08-21T19:23:40Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2740",
    "body": "Following scenario:\n\n``` js\nvar middlewre = function(){\n    return function(req, res, next){\n        // do somthing\n        next();\n   }\n}\n```\n\nthen you use it twice:\n\n``` js\napp.use('/', middleware());\napp.use('/SomePath', middleware());\n```\n\nIf request comes to '/SomePath' the middleware will run twice. does it make sense? I would expect that '/' is superset and the middleware will run only once.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2740/comments",
    "author": "kfiron",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-08-21T19:23:40Z",
        "body": "Hi! Yes, this is exactly as designed. We always run in declared order, and do not do anything special for de-duplicating or prioritizing in the default router.\n\nIf you need them to only run once, the solution we offer is to attach a flag to `req` or similar:\n\n``` js\nvar middlewre = function(){\n    return function(req, res, next){\n        if (req.middlewareRan) return next();\n        req.middlewareRan = true;\n        // do somthing\n        next();\n   }\n}\n```\n"
      },
      {
        "user": "kfiron",
        "created_at": "2015-08-21T19:25:11Z",
        "body": "Thanks\n"
      }
    ]
  },
  {
    "number": 2734,
    "title": "req.params cleared",
    "created_at": "2015-08-13T23:13:30Z",
    "closed_at": "2015-08-14T00:37:56Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2734",
    "body": "We just upgraded from Express 3 to Express 4 and we're seeing some weird behaviour with `req.params`. On some routes, the content of `req.params` seems to be deleted in the middle of route handling function. We also noticed that `req.returned` suddenly changes from `false` to `true` when `req.params` is cleared. Any idea what could be happening here?\n\n``` js\napp.post('/item/:item_id', auth.checkPermissions('create_item'), function(req, res, next) {\n  console.log(req.returned); // prints: false\n  console.log(req.params.item_id); // prints: 123\n\n  (some async code)\n\n  console.log(req.returned); // prints: true\n  console.log(req.params.item_id); // prints: undefined\n}\n```\n\nExpress version: 4.13.3\nNode version: 0.10.39\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2734/comments",
    "author": "Chris911",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-08-13T23:16:47Z",
        "body": "Hm, definitely weird. Just doing the following does not easily reproduce the issue. Can you provide some more complete code we can run and reproduce the issue? Also, please note the version of Node.js and Express with your complete code example :)\n\n``` js\nvar i = 0\n\napp.post('/test/:id', function (req, res, next) {\n  var id = ++i\n  console.log('req ' + id + ' first ' + req.params.id)\n  setTimeout(function () {\n    console.log('req ' + id + ' second ' + req.params.id)\n    req.end()\n  }, 5000)\n})\n```\n"
      },
      {
        "user": "Chris911",
        "created_at": "2015-08-13T23:28:33Z",
        "body": "Added the versions. The async code is actually really big and can't copy here but I'll try to get a smaller repro. Switching back to Express 3 we don't have that issue.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-08-13T23:34:08Z",
        "body": "> Switching back to Express 3 we don't have that issue.\n\nGotcha. I mean, the change was fairly major on the internals, so it's hard to even speculate, unfortunately :( My only thought is perhaps you have code calling `next()` twice somewhere, I have no idea.\n\nGetting code that reproduces the issue (or perhaps a PR to fix the issue) would probably be the only option currently. I've been playing around and still haven't been able to cause the issue locally with Express 4.13.3 and Node.js 0.10.38\n"
      },
      {
        "user": "Chris911",
        "created_at": "2015-08-14T00:08:40Z",
        "body": "I found the issue. I'm calling `next()` and then doing some more stuff with the request. Strangely (or not) calling `res.send()` instead of `next()` works as it did in Express 3. A previous middleware is also calling `next()` but I don't know if that's really the issue. \n\nWe're currently using `next()` to send data and I think that's bad practice in Express 3 and maybe plain wrong in Express 4. Will switch to use `res.send` directly everywhere when there's no more middleware to call. \n\nThanks for your time. If you think this is actually a bug I'll share the code to repro.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-08-14T00:17:20Z",
        "body": "It's no problem. So `req.params` is only valid once the function for your handler is called and is no longer valid once you call `next()`, which is a change from Express 3.x, done in part because of various issues with the old behavior.\n\nBasically the rule of thumb is the following: once you call `next()` in a handler, `req` and `res` no longer belong to your handler and you should no longer be operating on them (because, well, you passed the possession of these objects to the next handler).\n"
      },
      {
        "user": "Chris911",
        "created_at": "2015-08-14T00:37:56Z",
        "body": "That makes perfect sense. Thanks for you help. \n"
      }
    ]
  },
  {
    "number": 2733,
    "title": "email/contact to sent security vulns",
    "created_at": "2015-08-13T14:12:13Z",
    "closed_at": "2015-12-15T04:07:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2733",
    "body": "Hi, I believe I found a DoS on express so before I post it on this public issue list, is there a contact (email) that I can use to send the info and PoC?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2733/comments",
    "author": "DinisCruz",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-08-13T14:14:08Z",
        "body": "Please send it to my email address, which you can find on my GitHub profile.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-08-14T00:50:19Z",
        "body": "Hi @DinisCruz , I just saw you tried to contact me on Skype. Sorry for not seeing that, I wasn't expecting that so was never looking :S Based on your profile, I probably missed you now from time zone differences, but if you want to try Skype again tomorrow, I'll be sure to watch it for your reach out!\n"
      }
    ]
  },
  {
    "number": 2716,
    "title": "consider updating path-to-regexp dependency",
    "created_at": "2015-07-25T05:29:18Z",
    "closed_at": "2015-07-25T05:40:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2716",
    "body": "the below\n\n`router.route('/v1/users/:userId/(events|forms)', fooMiddleware);`\n\ngenerates an error using path-to-regexp version 0.1.6\n\n```\nSyntaxError: Invalid regular expression: /^\\/users\\/(?:([^\\/]+?))\\/(?(?:([^\\/]+?))|forms)\\/?$/: Invalid group\n    at new RegExp (native)\n    at pathtoRegexp (c:\\Asker\\application\\node_modules\\express\\node_modules\\path-to-regexp\\index.js:69:10)\n```\n\nhowever by re-npm-installing my express package with path-to-regexp version changed to the most recent version (1.2.0) it processed my route just fine\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2716/comments",
    "author": "lukeavsec",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-07-25T05:40:24Z",
        "body": "Hi! The update is not backwards-compatible. It'll be upgraded as part of our 5.0 release :) (i.e. PR #2057)\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-07-25T05:41:37Z",
        "body": "I'll let you know when the 5.0 beta 1 is released (should be this weekend), which will have the updated `path-to-regexp` module :)\n"
      },
      {
        "user": "lukeavsec",
        "created_at": "2015-07-25T05:53:16Z",
        "body": "Ahhh I see. Sorry for the confusion - thanks for the clear-up!\n"
      }
    ]
  },
  {
    "number": 2707,
    "title": "Is there a way to let exceptions bubble up instead of passing to finalhandler",
    "created_at": "2015-07-16T03:55:04Z",
    "closed_at": "2015-07-16T04:03:00Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2707",
    "body": "I'm trying to do some exception handling in my app built on express and it's being problematic that every time I throw an exception it gets printed to the screen.\n\nIs this configurable?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2707/comments",
    "author": "ericuldall",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-07-16T03:56:09Z",
        "body": "Are you talking about getting printed to your web browser, or to the console you are running Node.js on?\n"
      },
      {
        "user": "ericuldall",
        "created_at": "2015-07-16T03:59:21Z",
        "body": "it does both. I think you just addressed this question on finalhandler issues. Does that answer stand?\n"
      },
      {
        "user": "ericuldall",
        "created_at": "2015-07-16T04:01:54Z",
        "body": "basically i'm using `process.on('uncaughtException')` and my thrown errors aren't getting there.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-07-16T04:03:00Z",
        "body": "The main two configurations are the following:\n\n``` js\n// don't print errors on your node console window\napp.set('env', 'test')\n\n// don't print errors to your web browser\napp.set('env', 'production')\n```\n\nBy default Express assumes development mode, which is what causes the stack traces to head to your web browser.\n\nAlso by default, Express will dump stack traces to your STDERR handle, which is standard when running the server and redirecting STDERR to an error log (as in `node app.js 2> error.log`).\n\n> I think you just addressed this question on finalhandler issues. Does that answer stand?\n\nYes, it does :) especially if you want it to be extremely configurable :) Another thing you can do is the following to use `finalhandler` but turn those two features off:\n\n``` js\nvar express = require('express')\nvar finalhander = require('finalhandler')\nvar http = require('http')\n\nvar app = express()\n\n// declare things on app\n\nvar server = http.createServer(function (req, res) {\n  app(req, res, finalhandler(req, res, {\n    env: 'production', // no stack traces; option name will be better in 1.0\n    onerror: function (err) {\n      throw err; // rethrow to your uncaughtException handler, but i _highly_ don't suggest this\n    }\n  }))\n})\n\nserver.listen(3000)\n```\n"
      },
      {
        "user": "ericuldall",
        "created_at": "2015-07-16T04:04:07Z",
        "body": "thanks again @dougwilson \n"
      }
    ]
  },
  {
    "number": 2669,
    "title": "IP address as a url param error",
    "created_at": "2015-06-03T17:47:46Z",
    "closed_at": "2015-06-03T19:36:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2669",
    "body": "When declaring an IP address as a URL parameter `req.params` incorrectly parses the value. \n\nAdd the following param to the URL  `:ip((?:[0-9]{1,3}\\.){3}[0-9]{1,3})`\n\nUse the value 192.168.1.2 for ip\n\nThen check  `req.params.ip` it will return as 1. \n\n```\nconsole.log('req.originalUrl',req.originalUrl);\nconsole.log('(req.params.ip',req.params.ip);\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2669/comments",
    "author": "DaleCox",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-06-03T17:54:54Z",
        "body": "Hi, Can you supply a full app that reproduces the error (as there are many things that can influence this?\n\nAlso, it may just be because your param definition does not work with `path-to-regexp` module. Try using `:ip([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})`\n"
      },
      {
        "user": "DaleCox",
        "created_at": "2015-06-03T19:36:35Z",
        "body": "Unfortunately I don't have anything I can post at this time. \n\nThank you the reg ex you provided solved the issue.  \n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-06-03T23:58:33Z",
        "body": "Gotcha. If the updated reg ex worked, then it looks like it's just a limitation in `path-to-regexp` that we use, which is what I thought (you cannot use `(?:` in the reg ex).\n"
      }
    ]
  },
  {
    "number": 2659,
    "title": "params in middleware not work",
    "created_at": "2015-05-24T05:41:16Z",
    "closed_at": "2015-05-24T05:46:51Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2659",
    "body": "I have a router with a middleware for manage entry , but not recognize all params from the request,\n\nby example  I have a route like /:username/:idMessage , then the middleware only recognize the username param but not the idMessage\n\n``` javascript\nvar router = express.Router({mergeParams: true});\nrouter.use(function (req, res, next) {\n    console.log(req.params.username);\n    //juliocanares\n\n    console.log(req.params.idMessage);\n    //undefined\n\n    next();\n});\n\n//localhost:3000/juliocanares\nrouter.get('/', function (req, res) {\n    console.log(req.params.username);\n    //juliocanares\n    return res.json({username: req.params.username});\n});\n\n//localhost:3000/juliocanares/10\nrouter.get('/:idMessage', function (req, res) {\n    console.log(req.params.idMessage);\n    //10\n    return res.json({idMessage: req.params.idMessage});\n});\n\napp.use('/:username', router);\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2659/comments",
    "author": "juliocanares",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-05-24T05:46:51Z",
        "body": "This is working as designed. Your `router` will only ever see the params as defined for it, and in your example, this is `app.use('/:username', router);`, thus `router` will only ever have `req.params.username`.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-05-24T05:48:00Z",
        "body": "You can always redefine\n\n``` js\nrouter.use(function (req, res, next) {\n    console.log(req.params.username);\n    //juliocanares\n\n    console.log(req.params.idMessage);\n    //undefined\n\n    next();\n});\n```\n\nto be the following instead:\n\n``` js\nrouter.use('/:idMessage', function (req, res, next) {\n    console.log(req.params.username);\n    //juliocanares\n\n    console.log(req.params.idMessage);\n    //10\n\n    next();\n});\n```\n"
      },
      {
        "user": "juliocanares",
        "created_at": "2015-05-24T06:37:53Z",
        "body": "thanks @dougwilson :dancer: \n"
      }
    ]
  },
  {
    "number": 2638,
    "title": "4.x performance issue",
    "created_at": "2015-05-07T03:26:18Z",
    "closed_at": "2018-11-07T02:14:23Z",
    "labels": [
      "help wanted",
      "question",
      "investigate"
    ],
    "url": "https://github.com/expressjs/express/issues/2638",
    "body": "i was tested 3.x and 4.x  by same get request\n\n```\nGET '/health'  -> response 'ok'\n```\n\ntest result 3.x  is winner about 15% better than 4.x\n\ni guess maybe because route logic\n\nin 3.X\n\n```\nconsole.log(app._router.map)\n{ get: \n   [ { path: '/health',\n       method: 'get',\n       callbacks: [Object],\n       keys: [],\n       regexp: /^\\/health\\/?$/i } ],\n  post: \n   {}  }\n```\n\nin 4.X\n\n```\nconsole.log(app._router.stack)\n[ { handle: [Function: query],\n    name: 'query',\n    params: undefined,\n    path: undefined,\n    keys: [],\n    regexp: { /^\\/?(?=\\/|$)/i fast_slash: true },\n    route: undefined },\n  { handle: [Function: expressInit],\n    name: 'expressInit',\n    params: undefined,\n    path: undefined,\n    keys: [],\n    regexp: { /^\\/?(?=\\/|$)/i fast_slash: true },\n    route: undefined },  \n  { handle: [Function],\n    name: '<anonymous>',\n    params: undefined,\n    path: undefined,\n    keys: [],\n    regexp: /^\\/health\\/?$/i,\n    route: { path: '/health', stack: [Object], methods: [Object] } } ]\n```\n\nif my guess is true, how to overcome this performance issue?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2638/comments",
    "author": "rndmania",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-05-07T03:28:12Z",
        "body": "Interesting. What is the exact version of 3.x you are using and the exact version of 4.x? And what is the benchmarking methodology you are using and how can I reproduce the same measurements on my machine? I can then dig into the issue.\n"
      },
      {
        "user": "rndmania",
        "created_at": "2015-05-07T05:36:27Z",
        "body": "thanks for reply.\n3.5.1 vs. 4.12.1\n\ni use nGrinder performance testing tool.\nbut, i think we can use simple benchmark tool  such as 'ab'(apache benchmark)\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-05-07T12:54:14Z",
        "body": "Thanks :) So what version of Node.js are you running? Can you provide the same `app.js` file I can use to reproduce? And what were the settings used in the nGrinder performance testing tool? Did you run the Express server on the same machine or a different machine than nGrinder?\n"
      },
      {
        "user": "rndmania",
        "created_at": "2015-05-08T05:26:00Z",
        "body": "run Express server on different machine than nGrinder\nand same condition is used in testing between 3.x and 4.x\n(same machine, same load, same resource usage)\n\nnGrinder is 1 controller + 4 agent\n\nfor 3.5.1\n\n```\nif (cluster.isMaster) { // Master Process\n     // Create worker processes \n     for ( var i = 0; i < workerProcNum; i++) {\n       cluster.fork();\n     }\n     cluster.on('exit', function(worker, code, signal) {\n             cluster.fork();\n     });\n} else { // Worker Process\n     var app = express();\n     app.set('port', serverPort);\n     app.use(express.methodOverride());\n     app.use(app.router);\n\n     // Error Handling\n     app.use(function(err, req, res, next) {\n             res.send(err.status || 500, err.toString());\n             errorLogger.error(err.stack);\n              });\n\n     // Use the \"X-Forwarded-For\" ip address\n     app.enable('trust proxy');\n\n     var health = require('./routes/health');\n     app.get('/health', health.health);\n\n     app.listen(app.get('port'));\n     console.log('Express server listening on port ' + app.get('port'));\n}\n```\n\nfor 4.12.1\n\n```\nif (cluster.isMaster) { // Master Process\n     // Create worker processes \n     for ( var i = 0; i < workerProcNum; i++) {\n       cluster.fork();\n     }\n     cluster.on('exit', function(worker, code, signal) {\n             cluster.fork();\n     });\n} else { // Worker Process\n     var app = express();\n     app.set('port', serverPort);\n\n     // Use the \"X-Forwarded-For\" ip address\n     app.enable('trust proxy');\n\n     var health = require('./routes/health');\n     app.get('/health', health.health);\n\n     app.use(function(err, req, res, next) {\n        if(res.headersSent === false) {\n                res.status(err.status || 500).send('Invalid Request');\n        }\n\n        appLogger.error(err.stack);\n        debug(err.stack);\n     });\n\n     app.listen(app.get('port'), function(){\n          console.log('Express server listening on port ' + server.address().port);\n      });\n}\n```\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-05-08T05:34:30Z",
        "body": "Thank you! And hopefully these are the last two questions:\n1. What version of node.js are you testing on?\n2. Does the difference between 3.x and 4.x change if you remove the use of `cluster`? (to remove non-Express variables from the test)\n"
      },
      {
        "user": "rndmania",
        "created_at": "2015-05-08T07:38:44Z",
        "body": "ah.. sorry\n1. v.0.12.0\n2. i should test it. please give me some time ^^\n\nthankyou.!!\n"
      },
      {
        "user": "tunniclm",
        "created_at": "2016-01-11T13:12:05Z",
        "body": "I tried to reproduce this on the same level on node and express, using `ab` and a dummy route handler function (just prints a console message).\n\nI tried two cluster sizes:  `1` and `2`. I used `ab -c 4 -n 10000 ...` to drive load (from the same machine).\n\nThe machine for testing was  a 4-core / 2 SMT-per-core Intel Core i7 laptop (mains power) running Ubuntu 14.0.4.\n\n## Results (cluster size = 2)\n\n### 4.12.1\n\n```\nRequests per second:    1551.18 [#/sec] (mean)\nTime per request:       2.579 [ms] (mean)\nTime per request:       0.645 [ms] (mean, across all concurrent requests)\n\nRequests per second:    1569.97 [#/sec] (mean)\nTime per request:       2.548 [ms] (mean)\nTime per request:       0.637 [ms] (mean, across all concurrent requests)\n\nRequests per second:    1641.87 [#/sec] (mean)\nTime per request:       2.436 [ms] (mean)\nTime per request:       0.609 [ms] (mean, across all concurrent requests)\n\nRequests per second:    1682.43 [#/sec] (mean)\nTime per request:       2.378 [ms] (mean)\nTime per request:       0.594 [ms] (mean, across all concurrent requests)\n\nRequests per second:    1666.91 [#/sec] (mean)\nTime per request:       2.400 [ms] (mean)\nTime per request:       0.600 [ms] (mean, across all concurrent requests)\n```\n\n### 3.5.1\n\n```\nRequests per second:    1524.67 [#/sec] (mean)\nTime per request:       2.624 [ms] (mean)\nTime per request:       0.656 [ms] (mean, across all concurrent requests)\n\nRequests per second:    1601.80 [#/sec] (mean)\nTime per request:       2.497 [ms] (mean)\nTime per request:       0.624 [ms] (mean, across all concurrent requests)\n\nRequests per second:    1694.21 [#/sec] (mean)\nTime per request:       2.361 [ms] (mean)\nTime per request:       0.590 [ms] (mean, across all concurrent requests)\n\nRequests per second:    1685.28 [#/sec] (mean)\nTime per request:       2.373 [ms] (mean)\nTime per request:       0.593 [ms] (mean, across all concurrent requests)\n\nRequests per second:    1666.64 [#/sec] (mean)\nTime per request:       2.400 [ms] (mean)\nTime per request:       0.600 [ms] (mean, across all concurrent requests)\n```\n"
      }
    ]
  },
  {
    "number": 2634,
    "title": "Help with typo in my code",
    "created_at": "2015-05-03T01:33:25Z",
    "closed_at": "2015-05-03T01:42:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2634",
    "body": "Using Express 4.12.3 and node 0.12.2 and attempting to implement CouchDB using cradle I attempted to use routes that mirror the CouchDB uses of http methods GET -- to read PUT -- to add create etc and DELETE -- to delete\n\nUsing a near line for line match with a PUT '/createDB' route and a PUT '/deleteDB' route the  PUT '/createDB' works consistently while THE '/deleteDB' ROUTE FAILS using either  the PUT or DELETE methods.\n -----  WEIRD -------  :-()\n\n``` js\nrouter.put('/createDB', function(req, res, next) {    // WORKS !!!!\n    var db = new (cradle.Connection)().database(req.query.dbName);\n    db.create();\n    db.exists(function(err,exists){\n        if (err) res.send(req.query.dbName + ' not created');\n        if (exists) res.send(req.query.dbName + ' created');\n    });\n\n});\n\nrouter.put('/deleteDB', function(reg, res, next){      // FAILS\n    var db = new (cradle.Connection)().database(req.query.dbName);\n    db.exists(function(err,exists) {\n        if (err) res.send(req.query.dbName + ' does not exist');\n        if (exists) {\n            db.destroy();\n            res.send(req.query.dbName + ' destroyed');\n        }\n    });\n});  //  Notice that the syntax is essentially identical to the /createDB route above ???\n\nrouter.delete('/deleteDB', function(reg, res, next){   // FAILS\n    var db = new (cradle.Connection)().database(req.query.dbName);\n    db.exists(function(err,exists) {\n        if (err) res.send(req.query.dbName + ' does not exist');\n        if (exists) {\n            db.destroy();\n            res.send(req.query.dbName + ' destroyed');\n        }\n    });\n```\n\nThere is nothing wrong with the routes, the failure is on the parse \n The stack trace\n\n``` html\n<!DOCTYPE html><html><head><title></title><link rel=\"stylesheet\" href=\"/stylesheets/style.css\"></head><body><h1>req is not defined</h1><h2></h2><pre>ReferenceError: req is not defined\n    at c:\\Users\\cloidjgreen\\WebstormProjects\\MGScheduler\\routes\\db.js:43:49\n    at Layer.handle [as handle_request] (c:\\Users\\cloidjgreen\\WebstormProjects\\MGScheduler\\node_modules\\express\\lib\\router\\layer.js:82:5)\n    at next (c:\\Users\\cloidjgreen\\WebstormProjects\\MGScheduler\\node_modules\\express\\lib\\router\\route.js:110:13)\n    at Route.dispatch (c:\\Users\\cloidjgreen\\WebstormProjects\\MGScheduler\\node_modules\\express\\lib\\router\\route.js:91:3)\n    at Layer.handle [as handle_request] (c:\\Users\\cloidjgreen\\WebstormProjects\\MGScheduler\\node_modules\\express\\lib\\router\\layer.js:82:5)\n    at c:\\Users\\cloidjgreen\\WebstormProjects\\MGScheduler\\node_modules\\express\\lib\\router\\index.js:267:22\n    at Function.proto.process_params (c:\\Users\\cloidjgreen\\WebstormProjects\\MGScheduler\\node_modules\\express\\lib\\router\\index.js:321:12)\n    at next (c:\\Users\\cloidjgreen\\WebstormProjects\\MGScheduler\\node_modules\\express\\lib\\router\\index.js:261:10)\n    at Function.proto.handle (c:\\Users\\cloidjgreen\\WebstormProjects\\MGScheduler\\node_modules\\express\\lib\\router\\index.js:166:3)\n    at router (c:\\Users\\cloidjgreen\\WebstormProjects\\MGScheduler\\node_modules\\express\\lib\\router\\index.js:35:12)</pre></body></html>\n```\n\nJust using GET to deliver the route and param works fine.  \nNot a desirable workaround.  I have debugged deeply into the stack and do not find the failure point.\nThe request seems intact deep into the code\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2634/comments",
    "author": "cloidjgreen",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-05-03T01:42:15Z",
        "body": "You have typos... Your function argument is `reg` instead of `req`, thus why you would get `ReferenceError: req is not defined` errors.\n"
      }
    ]
  },
  {
    "number": 2621,
    "title": "Container elements not properly rendered inside of SVG elements",
    "created_at": "2015-04-18T07:18:19Z",
    "closed_at": "2015-04-18T15:29:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2621",
    "body": "I'm not sure if this is an issue with ExpressJS or Jade, but the typical HTML container elements (div and span come to mind) that supposedly work in SVG elements too are rendered outside of the SVG element. \n\nAn example like the following would cause the div to get rendered outside the SVG element. Note : I have tried adding all the gobbledy gook that you would normally add if it was an SVG file. It didn't change a thing. I tried doing height/width with and without quotes, with and without pixels. I tried putting everything inside of style=\"\". It still renders the div outside of the SVG element. \n\n```\n  svg#testing\n    defs\n      pattern#flowers(patternUnits=\"userSpaceOnUse\" width=276 height=183)\n        image(xlink:href='/img/flowers.jpg', height=183 width=276)\n    div\n      circle#circle(cx=50 cy=50 r=10 fill='url(#flowers)')\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2621/comments",
    "author": "herokuprojects666",
    "comments": [
      {
        "user": "herokuprojects666",
        "created_at": "2015-04-18T07:20:02Z",
        "body": "Well... all my formatting was removed. I can assure you all the indentation is correct. The circle SVG element renders correctly when the div is removed. \n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-04-18T07:20:32Z",
        "body": "I added your formatting :) It's definitely a Jade issue or some sorts, rather than anything Express.\n"
      }
    ]
  },
  {
    "number": 2595,
    "title": "/lib/response.js -> undefined is not a function at this.get()",
    "created_at": "2015-03-16T02:14:46Z",
    "closed_at": "2015-03-16T02:20:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2595",
    "body": "I honestly don't even know what information to provide.\nAll I know is my stack trace says:\n\n_Possibly unhandled TypeError: undefined is not a function... lib\\response.js:130:17_\n\nI am using _bluebird_ promise library and the error is being generated when I try:\n\n```\n.then(response.send, next);\n```\n\nbut not when I do:\n\n```\n.then(function(result) {\n    response.send(result)\n}, next);\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2595/comments",
    "author": "lukeavsec",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-03-16T02:19:07Z",
        "body": "I'm also unsure. Best thing for both of us would be if you could provide an app that reproduces this issue that I can cut-and-paste and run on my own machine. Please note the versions of Bluebird, Express, and Node.js you are seeing this in as well. I honestly don't know anything about Bluebird, but if I could run this on my local, I can probably figure it out. It may be an issue here, or it could simply be an issue of using Bluebird incorrectly.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-03-16T02:20:36Z",
        "body": "Oh, spoke to soon, I figured it out: you're just using JavaScript itself incorrectly. See, `.send` is a method, so you cannot pass it like a function. Your line should be:\n\n``` js\n.then(response.send.bind(response), next);\n```\n"
      },
      {
        "user": "lukeavsec",
        "created_at": "2015-03-16T03:13:23Z",
        "body": "Doug. You are the man.\nYou solved my problem and taught me something.\nMuch appreciated.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-03-16T03:17:54Z",
        "body": "No problem, any time :) I'm glad I was able to figure it out after squinting my eyes at your code after my first post :) \n"
      }
    ]
  },
  {
    "number": 2593,
    "title": "Router mergeParams=true does not work ",
    "created_at": "2015-03-14T17:41:11Z",
    "closed_at": "2015-03-14T17:57:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2593",
    "body": "express 4.12.2. According to the Router doc about `mergeParams` option:\n\n> Preserve the `req.params` values from the parent router. If the parent and the child have conflicting param names, the child’s value take precedence.\n\nMay be I miss something, but it does not behave in that way at all:\n\n``` javascript\nvar express = require('express');\nvar app = express();\n\n\napp.get('/users/:username', function(req, res, next) {\n        console.log('> app.get');\n\n    if (req.params.username !== 'alice') {\n        throw new Error('app.get: username != alice');\n    }\n\n    next();\n});\n\nvar router1 = express.Router({mergeParams: true});\napp.use(router1);\n\nrouter1.get('*', function(req, res, next) {\n        console.log('> router1.get');\n\n        // This throws.  \n    if (req.params.username !== 'alice') {\n        throw new Error('router1.get: username != alice');\n    }\n\n    next();\n});\n\napp.listen(5000, '0.0.0.0');\n```\n\nNow send a GET request with url \"/users/alice\" and it will print:\n\n```\n> app.get\n> router.get\nError: router1.get: username != alice\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2593/comments",
    "author": "ibc",
    "comments": [
      {
        "user": "ibc",
        "created_at": "2015-03-14T17:55:55Z",
        "body": "May be `mergeParams` just work when declaring a named param in the mount path of the router?\n"
      },
      {
        "user": "ibc",
        "created_at": "2015-03-14T17:57:04Z",
        "body": "Yes, sorry for the noise.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-03-14T21:17:08Z",
        "body": "> Yes, sorry for the noise.\n\nI'm not sure if there is such thing as \"noise\" :) So to answer this, what `mergeParams` does is merge any `req.params` that _exists at the time the router is entered_. The reason it wasn't doing anything in your example above is because `app.use(router1);` does not have any parameters. You can see this by doing something like `app.use(function (req, res, next) { console.dir(req.params); next() })` and seeing it as nothing there.\n\nTo expand on your example, there are two possible solutions to achieve this, and the correct one for your situation depends on exactly how you are looking for the sub router to behave:\n\n``` js\nvar express = require('express');\nvar app = express();\n\napp.get('/users/:username', function(req, res, next) {\n        console.log('> app.get');\n\n    if (req.params.username !== 'alice') {\n        throw new Error('app.get: username != alice');\n    }\n\n    next();\n});\n\nvar router1 = express.Router({mergeParams: true});\n// now router1 will actually inherit parameters, since it's defined on a path with them\napp.all('/users/:username', router1);\n\nrouter1.get('*', function(req, res, next) {\n        console.log('> router1.get');\n\n    if (req.params.username !== 'alice') {\n        throw new Error('router1.get: username != alice');\n    }\n\n    next();\n});\n\napp.listen(5000, '0.0.0.0');\n```\n"
      },
      {
        "user": "ibc",
        "created_at": "2015-03-17T11:36:50Z",
        "body": "Clear, thanks a lot.\n"
      },
      {
        "user": "seyedasfar",
        "created_at": "2019-04-14T09:28:33Z",
        "body": "What is the purpose of using mergeParams?"
      },
      {
        "user": "abdoerrahiem",
        "created_at": "2020-07-07T09:08:42Z",
        "body": "> What is the purpose of using mergeParams?\r\n\r\nto use route in another route"
      }
    ]
  },
  {
    "number": 2566,
    "title": "Is there a way to register a function/layer after the app.get function",
    "created_at": "2015-02-24T08:35:45Z",
    "closed_at": "2015-03-01T08:31:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2566",
    "body": "I want to do the cleanup thing after each get or post route is done, since `route.use` is called before the `route.$httpmethod`, so I wonder is there a way to register a function which is called **_after**_ the `route.$httpmethod`.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2566/comments",
    "author": "louis-she",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-03-01T04:08:00Z",
        "body": "So, there currently isn't really a built-in way, since all Express offers is to run a bunch of functions in a specific order. You can accomplish this using something like the `on-finished` module, though:\n\n``` js\nvar onFinished = require('on-finished')\n\n// Put this _before_ your routes\napp.use(function (req, res, next) {\n  onFinished(res, function () {\n    // Perform cleanup here, which is fired after any response that passes through this middleware\n  })\n  next()\n})\n```\n"
      },
      {
        "user": "louis-she",
        "created_at": "2015-03-01T08:25:47Z",
        "body": "yep, I have got this by someone from google group and it's the same answer there .\nSo I think this is now the right solution for this.\n"
      }
    ]
  },
  {
    "number": 2565,
    "title": "query param number values from client request turn into strings in req.query",
    "created_at": "2015-02-24T07:12:20Z",
    "closed_at": "2015-02-24T13:07:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2565",
    "body": "I'm not sure if this is due to the nature of http or something express is doing, but I am passing numbers as values to my express api and when I try to obtain them with req.query.x they are typeof string. This is causing me to do extra manual work on the server as my db is expecting numbers. If numbers remained type number, I could just pass them to my db outright through my blueprint and not have to do a custom controller.\n\nPlease advise. \n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2565/comments",
    "author": "mgenev",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-02-24T13:07:56Z",
        "body": "Yes, this is how HTTP works. The query string is just a list of key value pairs where each side is a string. You can always play around with the node.js core module querystring.\n"
      }
    ]
  },
  {
    "number": 2558,
    "title": "Add .set() to Express Router",
    "created_at": "2015-02-21T22:32:42Z",
    "closed_at": "2015-02-23T05:28:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2558",
    "body": "Hello,\n\nI've been working on a project and pretend using both EJS and Jade for it.\nFor this purpose, I thought separating stuff in multiple routers would work. However, when I tried to run it, I noticed the `express.Router()` does not include a `router.set('view engine', 'ejs')`. I am currently getting the files using `fs` and it works fine, but I really would like to have the advantages and simpler code that rendering with Express has. \n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2558/comments",
    "author": "gtomitsuka",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-02-21T22:37:10Z",
        "body": "Hi! We won't add `.set` and friends to routes, because it's one of the defining difference between routers (simply routing requests) and apps (having settings, methods, etc.). If you need different view engines for different parts of your project, consider simply using sub apps.\n"
      },
      {
        "user": "gtomitsuka",
        "created_at": "2015-02-21T22:40:57Z",
        "body": "Nah, I'll fork it and then do my own implementation. Thanks anyway!\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-02-21T22:44:02Z",
        "body": "No problem :+1: let me know how the fork goes, though; the router code won't even exist in Express 5, haha.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-02-23T05:30:41Z",
        "body": "P.S. this issue is a duplicate of #2524\n"
      }
    ]
  },
  {
    "number": 2547,
    "title": "Reject two(2+) in a row incoming requests.",
    "created_at": "2015-02-15T03:30:32Z",
    "closed_at": "2015-02-17T21:45:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2547",
    "body": "Sometimes we need restrict executing repeating requests from a user if the first request has not been finished. For example: We do want register user at some service, and only after that put him into database with external id. I would like to have a service where I can set protected routes.\nI have solved this problem by checking flag at request.start() -> and removed it after the request has been completed. Anyway I'm looking for your suggestion guys.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2547/comments",
    "author": "vsromanc",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-02-15T03:39:54Z",
        "body": "You may want to ask this on Stackoverflow.com, our IRC channel, or somewhere similar, as that would reach the most amount of people who would have good suggestions :)\n"
      }
    ]
  },
  {
    "number": 2531,
    "title": "Loosing params consistency in child routes with mergeParams",
    "created_at": "2015-02-06T14:00:29Z",
    "closed_at": "2015-02-06T14:15:55Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2531",
    "body": "Hi folks,\n\nI'm facing an issue which is that if I nest 2 routers like in the example below, my modifications on the `req.params` object are not kept in the child route. Any thought on how to resolve it ?\n\n``` js\nvar express = require('express');\n\nmodule.exports = function(app) {\n\n    var myRouter = express.Router();\n    var mySpecificRouter = express.Router({\n        mergeParams: true\n    });\n\n    myRouter.all('*', app.requestHelper.verifyToken);\n\n    myRouter.route('/')\n        .get(app.controller.my.list);\n\n    myRouter\n        .use('/:id', function(req, res, next) {\n            if (/^[0-9]+$/.test(req.params.id)) {\n                console.log('parent params before parsing', req.params);\n                req.params.id = parseInt(req.params.id, 10);\n                console.log('parent params', req.params);\n                next();\n            } else {\n                app.status(400).send({error:'bad request'});\n            }\n        }, mySpecificRouter);\n\n    mySpecificRouter\n        .route('/')\n        .get(function(req, res, next) {\n            console.log('child params', req.params);\n            app.status(200).send({});\n        });\n\n    app.use('/route', myRouter);\n};\n```\n\nSo the console log of a get request on /route/101 give me the following:\n\n```\nparent params before parsing {id: '100'}\nparent params {id: 100}\nchild params {id: '101'}\n```\n\nWhen I check in the `parentParams` in the index of the router I see the original object instead of the altered one...\n\nThanks !\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2531/comments",
    "author": "YouriT",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-02-06T14:15:55Z",
        "body": "It's because `req.params` is not just a \"bag-o-things\"; you have to modify it within a `app.param`/`router.param` declaration, rather than a `.use()`:\n\n``` js\nvar express = require('express');\n\nmodule.exports = function(app) {\n\n    var myRouter = express.Router();\n    var mySpecificRouter = express.Router({\n        mergeParams: true\n    });\n\n    myRouter\n        .param('id', function(req, res, next, val) {\n            if (/^[0-9]+$/.test(val)) {\n                console.log('parent params before parsing', req.params);\n                req.params.id = parseInt(req.params.id, 10);\n                next();\n            } else {\n              res.status(400).send({error:'bad request'});\n            }\n        })\n        .use('/:id', mySpecificRouter);\n\n    mySpecificRouter\n        .route('/')\n        .get(function(req, res, next) {\n            console.log('child params', req.params);\n            res.status(200).send({});\n        });\n\n    app.use('/route', myRouter);\n};\n```\n"
      },
      {
        "user": "YouriT",
        "created_at": "2015-02-06T15:12:36Z",
        "body": "Thanks @dougwilson !!!\n"
      }
    ]
  },
  {
    "number": 2529,
    "title": "Deprecated message thrown when using res.status",
    "created_at": "2015-02-04T05:12:05Z",
    "closed_at": "2015-02-04T05:24:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2529",
    "body": "I have been aware that since express@4.x, `res.send(201, obj)` format has been deprecated. But I am running into a situation where in 4.x I would want to send an `id` back, as shown as follows:\n\n``` js\nvar app = express();\n\napp.use(function(req, res) {\n  res.statusCode(201).send(1111); // where this is the ID.\n});\n\nrequest(app)\n   .get('/')\n   .expect(1111)\n   .expect(201, done);\n```\n\nBut I would get the deprecated message:\n\n`express deprecated res.send(status)`\n\nI was wondering if how should I approach this situation in `express` where I would want to send an integer back without having to do the following:\n\n``` js\napp.use(function(req, res) {\n  res.statusCode(201).send({ id: 1111 }); // where this is the ID.\n});\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2529/comments",
    "author": "limianwang",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-02-04T05:19:12Z",
        "body": "It's an unfortunate edge-case, and a prime sample of why this is deprecated :) `res.send(1111)` actually tries to send a response with the status code of 1111. To signify that you want the number as the body, simply wrap it in `String`: `res.status(201).send(String(1111))`; if you wanted to send JSON, `res.status(201).json(1111)`\n"
      },
      {
        "user": "limianwang",
        "created_at": "2015-02-04T05:21:53Z",
        "body": "Ah okay. I guess `res.status(201).send(String(1111))` isn't a bad work around. I'll use that for now. \n\nThanks!\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-02-04T05:24:28Z",
        "body": "No problem. It wound be necessary even if there was no deprecation at all :) The deprecation means that it finally _won't_ be necessary in 5.0 :D\n"
      }
    ]
  },
  {
    "number": 2513,
    "title": "Slows down after serving files for a while.",
    "created_at": "2015-01-25T12:35:07Z",
    "closed_at": "2015-01-31T23:13:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2513",
    "body": "I'm using expressjs 4.10.7 as a file server with the `static` middleware and I've noticed that after a few days it becomes extremely slow at serving files and I have to restart express to get back to normal speed.\n\nIs this a known issue? Is there something I can do to avoid it?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2513/comments",
    "author": "ronag",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-01-25T18:23:46Z",
        "body": "Unfortunately I have never seen such a problem :/ Unless your server is _only_ the following:\n\n``` js\nvar express = require('express')\nvar app = express()\napp.use(express.static(__dirname))\napp.listen(3000)\n```\n\nThen there are many, meany reasons your app can be slowing down over time. The main reason a Node.js will do that is because of a memory leak somewhere. If you can isolate down something I can run that will reproduce the issue or track down that memory leak with various Node.js tools, that would be the best place to start.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-01-31T23:13:30Z",
        "body": "I'm going to close this because I haven't heard anything back in about a week. Please feel free to respond, even if it's closed, and I can always reopen!\n"
      }
    ]
  },
  {
    "number": 2510,
    "title": "route can not use in chinese",
    "created_at": "2015-01-23T04:09:55Z",
    "closed_at": "2015-01-23T05:16:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2510",
    "body": "work good/articles/:type(%E8%B6%8B%E5%8A%BF|%E8%A7%82%E7%82%B9|%E6%A1%88%E4%BE%8B)\n\nwrong:   /articles/:type(趋势|观点|案例)?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2510/comments",
    "author": "suzukua",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-01-23T04:16:39Z",
        "body": "When you put strings in the path, they are matches against the literal URL, rather than the decoded component. You can use `req.param` to validate against the decoded value as a work-around:\n\n``` js\napp.param('type', function (req, res, next, val) {\n  var match = type === '趋势' || type === '观点' || type === '案例'\n  next(match ? null : 'route')\n})\n\napp.get('/articles/:type', function (req, res) {\n  res.end()\n})\n```\n"
      },
      {
        "user": "suzukua",
        "created_at": "2015-01-23T05:16:57Z",
        "body": "Good, thank you.\n"
      }
    ]
  },
  {
    "number": 2509,
    "title": "req.params is an array in 3.x",
    "created_at": "2015-01-22T12:46:22Z",
    "closed_at": "2015-01-22T16:22:13Z",
    "labels": [
      "3.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2509",
    "body": "Documentation states:\n\n> This property is an array containing properties mapped to the named route \"parameters\". For example if you have the route /user/:name, then the \"name\" property is available to you as req.params.name. This object defaults to {}.\n\nLast sentence makes me expect that it is not an array. But it is, which makes some libraries, like `lodash` for example, handle it unexpectedly.\n\nOn the other hand, one dealing with routes in regular expression format would probably find the length property handy. Any ideas for the workaround? Is it a bug?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2509/comments",
    "author": "rauno56",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-01-22T16:22:13Z",
        "body": "The docs are all correct for 3.x. Unfortinately the feature for 3.x is locked and we won't change the behavior. The exact behavior is this:\n- A route that has no params will get `req.params = {}` (i.e. it defaults to `{}`).\n- A route with params on it will get an array (i.e. `[]`) with either numeric indicies or properties, or both, depending on what the path was.\n"
      }
    ]
  },
  {
    "number": 2507,
    "title": "Help with best practice using router param and router routes",
    "created_at": "2015-01-22T02:37:18Z",
    "closed_at": "2015-01-22T16:11:32Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2507",
    "body": "I currently have a few router routes\n\n``` js\nrouter.route('/invite/token/:inviteToken')\n    .get(function (req, res) {\n      res.status(200).json(req.invite);\n    });\n\nrouter.route('/invite/:inviteId')\n    .get(function (req, res) {\n      res.status(200).json(req.invite);\n    });\n```\n\nAnd the following simple router params:\n\n``` js\nrouter.param('inviteToken', function (req, res, next, inviteToken) {\n  console.log('inviteToken');\n  // populate req.invite\n  next();\n});\n\nrouter.param('inviteId', function (req, res, next, inviteId) {\n  console.log('inviteId');\n  // populate req.invite\n  next();\n});\n```\n\nHowever when I try to fetch an invite by token the inviteId param handler is always triggered first with the literal value `\"token\"`. Is there an issue with the way I've set up the routes and params?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2507/comments",
    "author": "jakeklassen",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-01-22T03:04:22Z",
        "body": "It should only be triggered if your path is `GET /invite/token`. If you think you definitely have more on your URL after `/token`, then that's weird. Can you post the exact version of Express you are using, and combine those those code snips into a complete file I can run? It's possible there may be some issue with how you are combining things, yes.\n"
      },
      {
        "user": "jakeklassen",
        "created_at": "2015-01-22T16:11:32Z",
        "body": "I can confirm the issue was on my end. I created a stripped down version of my issue and it ran just as expected. The problem was in one of my own middleware helpers. Appreciate the help.\n"
      }
    ]
  },
  {
    "number": 2503,
    "title": "Multiple res.download resulting in ERR_INVALID_RESPONSE",
    "created_at": "2015-01-18T18:09:34Z",
    "closed_at": "2015-01-18T18:15:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2503",
    "body": "Hi,\nI am currently facing a problem with a route which lets users download files. The filename and the hash of the file are first queried from a database and then used in the `res.download` method to let the user download the file.\n\nIt is possible however, that under the same route, the file might change. That's because a file in my app has an id and the file can be changed afterwards (for example a new revision). The problem I am facing is, that Google Chrome will get an ERR_INVALID_RESPONSE error when the file behind the logic changes. It works however fine with Internet Explorer.\n\nThis is the route's code:\n\n```\n// download document\nrouter.get('/dl/:id', function(req, res){\n\n    // TODO: check permissions\n    var id = req.param('id');\n    var sql = req.sql;\n    var hash;\n    var filename;\n\n    var ddq = new sql.Request();\n    ddq.stream = true;\n    ddq.input('documentID', sql.Int, id);\n    ddq.execute('getDocumentDataForDownload');\n    ddq.on('row', function(row){\n        hash = row.document_hash;\n        filename = row.document_real_name;\n        console.log(hash);\n        console.log(filename);\n    });\n    ddq.on('done', function(v){\n        res.download('./fs/' + hash, filename, function(err){\n            if(err){\n                console.log(err);\n            }\n        });\n    });\n});\n```\n\nExpress Version 4.11\n\nAny ideas what could cause this problem?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2503/comments",
    "author": "luca-moser",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-01-18T23:53:38Z",
        "body": "Hi @XemsDoom , I see you closed your issue. Was this on accident, or did you resolve your issue?\n"
      },
      {
        "user": "luca-moser",
        "created_at": "2015-01-19T08:38:39Z",
        "body": "I closed it on purpose because the error vanished, but I don't know really why.\nBut thanks for the reply!\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-01-19T14:54:24Z",
        "body": "No problem :) If you do see it again, feel free to re-post here and I can always re-open. Ideally you could have some code I can copy and paste into a file and run myself to see it :)\n"
      }
    ]
  },
  {
    "number": 2477,
    "title": "can i change X-Powered-By:Express?",
    "created_at": "2014-12-21T15:13:50Z",
    "closed_at": "2014-12-21T16:39:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2477",
    "body": "can i change X-Powered-By:Express?\nif i can ,how can i do?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2477/comments",
    "author": "snowdream",
    "comments": [
      {
        "user": "sogawa",
        "created_at": "2014-12-21T16:13:00Z",
        "body": "How about this?\n\n``` javascript\nvar express = require('express');\nvar app = express();\n\napp.disable('x-powered-by');\n// or\napp.set('x-powered-by', '....');\n```\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-12-21T16:39:09Z",
        "body": "You can do it just by using the code:\n\n``` js\napp.use(function (req, res, next) {\n  res.setHeader('X-Powered-By', 'Rainbows')\n  next()\n})\n```\n"
      },
      {
        "user": "charleskyalo",
        "created_at": "2021-01-15T13:19:14Z",
        "body": "> You can do it just by using the code:\r\n> \r\n> ```js\r\n> app.use(function (req, res, next) {\r\n>   res.setHeader('X-Powered-By', 'Rainbows')\r\n>   next()\r\n> })\r\n> ```\r\nThank you @dougwilson :smile:\r\nNow am going to set the response header as follows\r\n```js\r\napp.use((req,res,next) => {\r\nres.setHeader('X-Powered-By','php')\r\nnext();\r\n})\r\n```"
      },
      {
        "user": "Jopchumba",
        "created_at": "2021-02-14T18:46:54Z",
        "body": "Thanks for the snippet rainbows sounds fun, "
      }
    ]
  },
  {
    "number": 2470,
    "title": "Memory usage",
    "created_at": "2014-12-15T18:18:06Z",
    "closed_at": "2014-12-17T16:32:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2470",
    "body": "I'm experiencing somewhat strange behavior using Node 0.11.14. Running the script below, and then refreshing `localhost:5000` in a web browser results in the memory usage on Node continually growing.\n\n```\nvar express = require(\"express\"),\n    app = express();\n\napp.get(\"/\", function(req, res) {\n  res.json(\"something\");\n});\n\napp.listen(5000, function() {\n  console.log(\"info\", \"Listening on port 5000\");\n});\n```\n\nUsing Node 0.10.33 I experience the same behavior, but memory usage seems to grow slower. \n\nIt seems like each request makes memory usage go up, and it never comes back down. Even when no requests are being made memory usage remains the same. Is there a point at which memory usage will drop? \n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2470/comments",
    "author": "jczaplew",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2014-12-16T00:08:20Z",
        "body": "v8, which does memory management of the heap, is pretty different between 0.10 and 0.11, so you would see different behavior between the two. This is brought up every so often, especially when you're looking at memory usage and not too familiar with how v8 manages it's heap.\n\nThere is only a memory leak if you can keep refreshing the page and it goes up until the process crashes because it uses up v8's 2GB heap space. Typically once your heap reaches some magic number that v8 has, it decides to start releasing some of that memory back to the OS--VMs like v8 try to hold on to memory instead of releasing it back to the OS because they figure you're going to use it again later and allocating from the OS is slow.\n\nNow, I'm not saying there is definitely no memory leak, especially when used with the 0.11.x line, but we need to be sure. You can look through the conversion at #2248 to see some tools and tests you can use that could help identifying if there even is a memory leak, and if so, what is leaking.\n"
      },
      {
        "user": "jczaplew",
        "created_at": "2014-12-17T16:32:14Z",
        "body": "Thanks for the help! I'll have to dive into this a little more (mostly to satisfy my curiosity), but I would assume that it's just the way v8 manages it's heap, and not an actual memory leak. I think if it was there would be a lot of panic out there...\n"
      }
    ]
  },
  {
    "number": 2463,
    "title": "File parser in express",
    "created_at": "2014-12-08T12:07:51Z",
    "closed_at": "2014-12-08T15:08:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2463",
    "body": "Hi All, \nI am working on file uploader module with express.js. \nto parse a post call with file there are multiple file parsors like multer. they store the file at temporary location and provide us path of that. \nBasically i want dont want to do this way. I dont want to store at temporary location. I directly want to get stream of uploaded file for further operation on file. \n\nany help on this ?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2463/comments",
    "author": "morwalz",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2014-12-08T15:08:20Z",
        "body": "Hi @morwalz , you would need to ask the question within those file parser modules, as they are outside the scope of core Express. You'll have to be very careful with your limits if you do that, though, because a user uploading a 100MB file will use 100MB+ of RAM if you don't store it in a temporary disk. Then if multiple requests do that at the same time, it can very easily OOM your process, which is why they all default to temporary disk file.\n\nIf you use `multiparty` or `busboy` to parse directly and don't use the middleware, then you control what happens, like not writing it to disk. For help, though, you'll need to ask on their repos.\n"
      }
    ]
  },
  {
    "number": 2462,
    "title": "Problem with routes containing dots and numbers",
    "created_at": "2014-12-08T11:18:30Z",
    "closed_at": "2014-12-08T11:28:15Z",
    "labels": [
      "3.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2462",
    "body": "If I create the following route:\n\n``` javascript\napp.get('/:foo', function(req, res) {\n  res.send('');\n});\n```\n\nThen go to `/0.1.0` I get a `Cannot GET /0.1.0` message.\n\nSo:\n`/0.1.0` is broken\n`/0.1.2` works fine\n`/1.1.0` works fine\n`/0.12.0` works fine\n`/0.1..0` works fine\n`/0..1.0` works fine\n`/a.b.c` works fine\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2462/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2014-12-08T15:05:23Z",
        "body": "Hi, I see you closed this issue. Was there a particular reason? Did you find you answer or was it an accident?\n"
      },
      {
        "user": "ghost",
        "created_at": "2014-12-12T09:54:38Z",
        "body": "It was a complete accident.\nI didn't realise that another module was running during the entire test and so this issue can be safely ignored.\n"
      },
      {
        "user": "ffflabs",
        "created_at": "2014-12-12T11:26:07Z",
        "body": "We should have \"like\" buttons in github.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-12-12T14:56:57Z",
        "body": "Ah, gotcha :) I just wanted to check in to be sure you weren't still having the issue and has closed the ticket by accident or such :) Thanks!\n"
      }
    ]
  },
  {
    "number": 2439,
    "title": "How to dispatch route ?",
    "created_at": "2014-11-11T21:54:36Z",
    "closed_at": "2014-11-11T22:03:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2439",
    "body": "Is it possible to dispatch some certain route programmatically like, `app.dispatch('get', '/foo', { params, querystrign ... }` ?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2439/comments",
    "author": "riston",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2014-11-11T22:03:29Z",
        "body": "No, you cannot dispatch mocked objects, only real HTTP requests/responses. You can always use the `supertest` or `superagent` libraries if you want to call your routes programmatically.\n"
      }
    ]
  },
  {
    "number": 2436,
    "title": "Router middleware applied to static if defined after?",
    "created_at": "2014-11-10T11:47:47Z",
    "closed_at": "2014-11-10T14:46:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2436",
    "body": "```\nrouter = express.Router()\nrouter.use helmet.csp(config.server.csp)\nrouter.get '/config', site.config\napp.use '/', router\napp.use express.static(...)\n```\n\nThe images still have the helmet CSP headers, while the docs say \"A router is an isolated instance of middleware and routes.\"?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2436/comments",
    "author": "analytically",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2014-11-10T14:46:14Z",
        "body": "Hi! The router is an isolated instance _of middleware and routes_ (not of actions to the request/response), but in your example, you're sending everything through the `router` since you added it at the path `/`, so anything that happens to the request/response in the router when it falls back out will still be there when `express.static` comes into play.\n"
      }
    ]
  },
  {
    "number": 2435,
    "title": "question about `U+2028/9` char handling in `res.jsonp`",
    "created_at": "2014-11-10T02:52:10Z",
    "closed_at": "2014-11-10T02:58:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2435",
    "body": "i know that `U+2028/9` means `line terminated` to javascript and it can cause XSS in jsonp. but why not just remove it such as `body = body.replace(/\\u2028/, '')` staff instead of turning it to `\\\\u2028` which is a string of 6 and seems non-sense?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2435/comments",
    "author": "luckydrq",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2014-11-10T02:58:48Z",
        "body": "Because it's information loss. We don't know what the user does or does not want to send back, so we assume that we we're giving is what the user wants to make it to the client.\n"
      }
    ]
  },
  {
    "number": 2428,
    "title": "Tries to write even tho connection is closed",
    "created_at": "2014-11-05T23:03:06Z",
    "closed_at": "2014-11-06T00:01:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2428",
    "body": "I got this error `error: write EPIPE` when you would do something like this:\n\n```\nfunction(req, res, next){\n   setTimeout(function(){\n       res.download(file);\n   }, 20000) // time it takes to convert a file\n\n  // user aborts the request after 5 sec timeout\n}\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2428/comments",
    "author": "jimmywarting",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2014-11-06T00:01:14Z",
        "body": "This is a standard Node.js core issue and Express does not extract those types of things away. You can get the same issue not even using Express, for example:\n\n``` js\nvar http = require('http')\nvar server = http.createServer(app)\n\nfunction app(req, res) {\n  setTimeout(function () {\n    res.write('hello')\n    res.end(' world')\n  }, 20000)\n\n  // user aborts the request after 5 sec timeout\n}\n```\n\nYou needs to do things like add `req.on('abort', fn)` listeners or use the `on-finished` modules which extracts this away to just not write to the response if the response ends early. Example:\n\n``` js\nvar onFinished = require('on-finished')\n\nfunction(req, res, next){\n   var finished = false;\n\n   setTimeout(function(){\n       if (!finished) {\n           res.download(file);\n       }\n   }, 20000) // time it takes to convert a file\n\n  // user aborts the request after 5 sec timeout\n  onFinished(res, function () {\n      finished = true;\n  });\n}\n```\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-11-06T00:02:30Z",
        "body": "And you get the bonus of once you know the response suddenly finished, you can cancel the actions that are generating the file to download early, saving resources as soon as possible.\n"
      }
    ]
  },
  {
    "number": 2426,
    "title": "req.route being exposed to middleware after other routes",
    "created_at": "2014-10-31T11:11:15Z",
    "closed_at": "2014-10-31T13:37:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2426",
    "body": "``` javascript\n      //When requested with path '/'\n      app.use('/',function(req,res,next){\n        //`req.route` equals `undefined`\n        next();\n      });\n\n      app.get('/',function(req,res,next){\n        //`req.route` is not `undefined`\n        next();\n      });\n\n      app.use('/',function(req,res,next){\n        //`req.route` is kept\n        res.end();\n      });\n```\n\nI'm not sure this is intentional or not, just found this when I read the source code. I could help to create a pull request If this behavior is not expected.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2426/comments",
    "author": "oyyd",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2014-10-31T13:37:17Z",
        "body": "It was semi-intentional such that error handlers could see what the last route that was running was. It certainly cannot be removed because it would break backwards-compatibility, though. Basically `req.route` is set to the route that is running, but left as-is through the rest of the run within the same router until another route is hit.\n"
      },
      {
        "user": "oyyd",
        "created_at": "2014-10-31T13:56:36Z",
        "body": "I see. Thank you for your answer.\n"
      }
    ]
  },
  {
    "number": 2423,
    "title": "Calling next() without a callback causes an error",
    "created_at": "2014-10-30T15:05:25Z",
    "closed_at": "2014-10-30T15:40:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2423",
    "body": "Hi Guys,\n\nI have an issue where I have two routes that utilize the same controller function:\n\n``` js\napp.route('route1').post(callback1);\napp.route('route2').post(callback1, callback2);\n```\n\nAs you can see on route1 consists of just a single callback function,  and route2 contains a chain of two callbacks.\n\nCallback1 returns a response on the 'res' object and calls next(), callback2 does nothing on the res object, it primarily reads some data from req and does some processing.\n\nSo route2 works fine, however route1 causes the 'Error: can set headers...' primarily because there is no callback from calling next().\n\nIs this expected behaviour or there is a graceful way to handle this? As in just silently fail if there is no callback in the chain?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2423/comments",
    "author": "iq-dot",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2014-10-30T15:40:34Z",
        "body": "> Callback1 returns a response on the 'res' object and calls next()\n\nYou can never call `next()` after you called `res.send()` or `res.end()`. If you provide the actual contents of those callbacks I may be able to help further if that didn't apply to you.\n"
      },
      {
        "user": "iq-dot",
        "created_at": "2014-10-30T16:17:38Z",
        "body": "Sure I can do that but route2 does NOT have any errors and I call next() after returning a response, so that does not seem to be the issue. It works fine and it is the same code, so that tells me the problem is that there is no callback to call from a next() on route1 but on route2 because there is, no error is thrown.\n\n``` js\nfunction callback1(req, res, next) {\n\n    req.login(user, function(err) {\n        if (err) {\n            log.error(err);\n            res.status(400).send(err);\n        } else {\n            res.jsonp(user);\n            next();\n        }\n    });\n}\n\nfunction callback2(req, res, next) {\n\n    var aux = req.aux;\n    var analytic = new Analytic({\n        aux: aux\n    });\n\n    analytic.save(function (err) {\n        if (err) {\n            log.error(err);\n        }\n    });   \n}\n```\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-10-30T16:41:10Z",
        "body": "You cannot call `next()` after you end your response, which `res.jsonp` is doing. Remove the `next()` after the `res.jsonp`.\n\n`next()` is _only called_ when you have not sent a response to the client, so you need to continue processing. Once you have sent a response using `res.send`, `res.end`, `res.json`, `res.jsonp`, etc. you can no longer call `next()`.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-10-30T16:43:21Z",
        "body": "`next()` goes through _the entire express framework_, it doesn't only go to the second arguments in the same route. If your `route1` does not have something after `callback1` that is expecting to be called after a response has already been sent, then you cannon call `next()`.\n"
      }
    ]
  },
  {
    "number": 2392,
    "title": "Deprecated should only log once",
    "created_at": "2014-10-11T14:13:27Z",
    "closed_at": "2014-10-11T14:17:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2392",
    "body": "We're seeing a lot of\n\n```\nexpress deprecated res.send(status, body): Use res.status(status).send(body) instead at node_modules/toobusy-middleware/index.js:76:13\n```\n\nin our logs. It'd be great if express would only log this once, and state something like 'logging of this deprecation warning is now turned off' to avoid filling the logs with nothing but deprecated warnings.\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2392/comments",
    "author": "analytically",
    "comments": [
      {
        "user": "analytically",
        "created_at": "2014-10-11T14:17:00Z",
        "body": "NO_DEPRECATION=express, nevermind :-)\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-10-11T15:08:11Z",
        "body": "Yes, that will suppress it :) As for frequency, it logs once per call site (of course, per process as well). This means if the deprecated call occurs in 50 different places, it'll log all 50 of them, which allows them to be fixed without just see the fist n, fixing those, restarting, fixing the next n, and repeating that over and over.\n\nThough I assume those are coming from a module you did not create, correct?\n"
      },
      {
        "user": "analytically",
        "created_at": "2014-10-11T17:59:46Z",
        "body": "Yep indeed. Must say I'm well impressed with your dedication and code, thanks a lot!\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-10-11T18:41:19Z",
        "body": "Thanks :) But yea, I asked because I think I should update depd such that if you are using a module you don't control the code for, you probably don't event want to see warnings from it, since you cannot take action to correct them.\n"
      },
      {
        "user": "analytically",
        "created_at": "2014-10-11T18:43:56Z",
        "body": "Well I sorta do want to see them (in dev), since then I can potentially fork or create an issue and hope. The deprecation might hide a performance issue. For me NO_DEPRECATION solves this nicely, since I can set that in production.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-10-11T18:48:57Z",
        "body": "Ok. Interesting to hear that perspective, since most of the time, people like to complain about the messages :) I'll leave them alone, haha\n"
      }
    ]
  },
  {
    "number": 2390,
    "title": "Interrogate express app directly",
    "created_at": "2014-10-10T19:27:17Z",
    "closed_at": "2014-10-11T00:11:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2390",
    "body": "Is it possible to interrogate server directly?\n\nexample:\n\n```\nvar app = express();\n//...\napp.getResponse(request, function(error, response){\n});\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2390/comments",
    "author": "mitica",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2014-10-10T19:32:17Z",
        "body": "Can you provide a more complete example or a more detailed question, please? I'm not quite sure what exactly you're asking yet.\n"
      },
      {
        "user": "jordonias",
        "created_at": "2014-10-10T21:51:29Z",
        "body": "I think he means something like what `supertest` does?\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-10-10T21:56:18Z",
        "body": "That is my assumption right now as well.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-10-11T00:11:33Z",
        "body": "@Mitica I haven't heard anything back, so for now I'm going to assume this will help you:\n\n``` js\nvar express = require('express')\nvar request = require('supertest')\n\nvar app = express()\n\napp.get('/foo', function (req, res) {\n  res.send('bar!')\n})\n\n// later\nrequest(app)\n.get('/foo')\n.end(function (err, res) {\n  if (err) throw err\n  // do something with res\n})\n```\n\nLet me know if you were thinking of something else.\n"
      },
      {
        "user": "mitica",
        "created_at": "2014-10-11T07:22:16Z",
        "body": "(sorry my poor english)\n@dougwilson, yes I mean this functionality - but for performance reasons I need to do it 'internally', not with supertest.\nI need to render more than one pages/routes for one client connection(headers, body, etc.), for implementing partial views.\nSomething like this:\n\n```\napp.get('/', function(req, res, done){\n  res.render('index', function(error, html){\n  var myReq = new Request('/home/somelist','GET', req); // fake\n    app.processInternalRequest(myReq, function(err, response){\n      res.send(html + response.body);\n    });\n  });\n});\n```\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-10-11T15:15:26Z",
        "body": "Gotcha. No, express has nothing like that, because express is just a layer on top of Node.js core http server. If you can find a module that does that on npm for Node.js http servers, please share so we can let other people know :) The closest you're going to get here is to create a mock req, a mock res, and call \"app(req, res, function(err){})\" but passing express mocked things is extremely unsupported by us.\n\nIn the end, for what you are doing, you are going about the wrong approach. Your partials are too coupled with your framework. You should refactor so you can just call your functions directly that do not involve express methods and they render your partials and return strings. Then you can call those functions directly.\n"
      }
    ]
  },
  {
    "number": 2387,
    "title": "Router: Cannot use literal characters \\] and \\) in Regex",
    "created_at": "2014-10-09T14:17:28Z",
    "closed_at": "2014-10-09T15:04:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2387",
    "body": "I know is horrible having special characters in URLs but I sadly have to manage them, so I tried to use this route:\n\n``` javascript\nrouter.get(\"/thumb/:file([a-zA-Z\\-0-9\\/ \\._\\%,&\\[\\]]+)/:size\", function (req, res) {\n   //do stuff\n});\n```\n\nto handle an URL like: `/thumb/canada/news-events/event-list/185-Roma_Ghezzi[1].jpg/75x75`\n\nAdding the character `\\\\]` will make the route stop working, even if the URL doesn't contain those characters.\n\nEven worst when you try adding the characters `\\\\(` or `\\\\)` because it crashes the process with the error:\n\n```\nSyntaxError: Invalid regular expression: /^\\/thumb\\/(?:([a-zA-Z-0-9\\/ \\._%,&[]))]+)\\/(?:([^\\/]+?))\\/?$/: Unmatched ')'\n    at new RegExp (<anonymous>)\n```\n\nI'd really prefer to use this a rule like the following one:\n\n``` javascript\nrouter.get(\"/thumb/:file(.+)/:size\", function (req, res) {\n   //do stuff\n});\n```\n\nbut the expression `(.+)` doesn't match a string like: `folder/subfolder/file` because the slashes `/` are considered a stop character (I guess).\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2387/comments",
    "author": "darkoromanov",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2014-10-09T14:28:14Z",
        "body": "Correct, it is a limitation, and our dependency has an update that may fix it, but it's not backwards-compatible, so it can never land inside express 4.\n\nAnother thing is that the URL above, `/thumb/canada/news-events/event-list/185-Roma_Ghezzi[1].jpg/75x75` should be coming into your server as `/thumb/canada/news-events/event-list/185-Roma_Ghezzi%5B1%5D.jpg/75x75`, which you would be able to match using a regular express in your URL.\n\nFor one thing, you can never match on `/` within the part regular expressions, as they only are supposed to span a single path component. You may be interested in the `*` character in the path, which may satisfy your needs:\n\n``` js\nrouter.get(\"/thumb/:file*/:size\", function (req, res) {\n   //do stuff\n});\n```\n\nAs a last resort, the path itself can be whatever regular expression you like:\n\n``` js\nrouter.get(/^\\/thumb\\/(.+?)\\/([^\\/]+)\\/?$/, function (req, res) {\n   //do stuff\n});\n```\n"
      },
      {
        "user": "darkoromanov",
        "created_at": "2014-10-09T15:04:34Z",
        "body": "Ok I understand, URLencoding the file name is a good point. However, this regex:\n\n``` javascript\nrouter.get(\"/thumb/:file*/:size\", function (req, res) {\n   //do stuff\n});\n```\n\ndoesn't work as expected as it returns these params:\n\nURL: /thumb/canada/news-events/event-list/1.jpg/75x75\n\n``` javascript\n{ '0': '75x75',\n  file: 'canada',\n  size: '/news-events/event-list/1.jpg' }\n```\n\nInstead, this rule \n\n``` javascript\nrouter.get(/^\\/thumb\\/(.+?)\\/([^\\/]+)\\/?$/, function (req, res) {\n//do stuff\n});\n```\n\nworks perfectly as it produces:\n\n``` javascript\n{ '0': 'canada/news-events/event-list/1.jpg', '1': '75x75' }\n```\n\nThanks!\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-10-09T15:22:31Z",
        "body": "Interesting note on that string rule. And just as a side-note, RegExp paths are of course fully supported, so you're not taking advantage of a \"hidden\" feature or anything :)\n"
      }
    ]
  },
  {
    "number": 1938,
    "title": "npm install -g not working on windows 7 with the latest node.js ",
    "created_at": "2014-02-27T01:54:49Z",
    "closed_at": "2014-02-27T01:55:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/1938",
    "body": "hi, sorry about the noob issue report. can you please confirm if this is really an issue? thanks in advance:\n\n309 silly lockFile 81f018b6-methods-0-1-0 methods@0.1.0\n310 silly lockFile 81f018b6-methods-0-1-0 methods@0.1.0\n311 silly lockFile 0760c556-range-parser-0-0-4 range-parser@0.0.4\n312 silly lockFile 0760c556-range-parser-0-0-4 range-parser@0.0.4\n313 error Failed to parse json\n313 error Unexpected token \n314 error File: ...\\package.json\n315 error Failed to parse package.json data.\n315 error package.json must be actual JSON, not just JavaScript.\n315 error\n315 error This is not a bug in npm.\n315 error Tell the package author to fix their package.json file. JSON.parse\n316 error System Windows_NT 6.1.7601\n317 error command \"...\\node_modules\\npm\\bin\\npm-cli.js\" \"install\" \"-g\" \"express\"\n318 error cwd ...\n319 error node -v v0.10.26\n320 error npm -v 1.4.3\n321 error file ....\\package.json\n322 error code EJSONPARSE\n323 verbose exit [ 1, true ]\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/1938/comments",
    "author": "val-samonte",
    "comments": [
      {
        "user": "defunctzombie",
        "created_at": "2014-02-27T01:56:14Z",
        "body": "Likely a download failure on npm\n"
      },
      {
        "user": "val-samonte",
        "created_at": "2014-02-27T02:03:53Z",
        "body": "apologies, but what could be the solution for this? can I just clone this repo instead? sorry for the newbie question. Im new with nodejs.\n"
      },
      {
        "user": "defunctzombie",
        "created_at": "2014-02-27T02:05:09Z",
        "body": "Cloning this repo don't do it cause cookie is a dependency. I think this is a temporary npm issue. The best bet is to try and install again. (Clean any failed install).\n"
      },
      {
        "user": "val-samonte",
        "created_at": "2014-02-27T02:10:54Z",
        "body": "thanks for the fast response. yep, tried to clean everything. did uninstall then install the node.js too. and actually this is my 2-3rd day doing this cycle. hmm what could i've done wrong...\n"
      },
      {
        "user": "jonathanong",
        "created_at": "2014-02-27T02:21:23Z",
        "body": "it is not your fault. when in doubt, blame npm\n"
      },
      {
        "user": "eivindfjeldstad",
        "created_at": "2014-02-27T02:27:32Z",
        "body": "words to live by, hahah\n"
      },
      {
        "user": "suissa",
        "created_at": "2014-11-26T14:40:33Z",
        "body": "npm ERR! Failed to parse json\nnpm ERR! Unexpected end of input\nnpm ERR! File: /Users/jeancarlonascimento/.npm/ee-first/1.1.0/package/package.json\nnpm ERR! Failed to parse package.json data.\nnpm ERR! package.json must be actual JSON, not just JavaScript.\nnpm ERR! \nnpm ERR! This is not a bug in npm.\nnpm ERR! Tell the package author to fix their package.json file. JSON.parse\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-11-26T14:43:27Z",
        "body": "That listed package is ee-first not express. Even then, that error is because your response is corrupted on disk. Run npm cache clean and try again.\n"
      }
    ]
  },
  {
    "number": 5403,
    "title": "Inconsistent Logging Order for GET and POST Requests",
    "created_at": "2024-01-23T10:50:40Z",
    "closed_at": "2024-01-24T20:16:34Z",
    "labels": [
      "help wanted",
      "good first contribution"
    ],
    "url": "https://github.com/expressjs/express/issues/5403",
    "body": "**Issue Description:**\r\nI have implemented middleware in my Express application to log request details and response time. The main application code is provided below:\r\n\r\n```javascript\r\nconst path = require('path');\r\nconst express = require('express');\r\n\r\nconst friendsRouter = require('./routes/friends.router');\r\nconst messagesRouter = require('./routes/messages.router');\r\n\r\nconst app = express();\r\nconst publicPath = path.join(__dirname, 'public');\r\n\r\nconst PORT = 3000;\r\n\r\napp.use((req, res, next) => {\r\n  const start = Date.now();\r\n  next();\r\n\r\n  const delta = Date.now() - start;\r\n  console.log(`${req.method} ${req.baseUrl}${req.url} ${delta}ms`);\r\n});\r\n\r\napp.use(express.json());\r\napp.use('/static', express.static(publicPath));\r\n\r\napp.use('/friends', friendsRouter);\r\napp.use('/messages', messagesRouter);\r\n\r\napp.listen(PORT, () => {\r\n  console.log(`Server listening on port ${PORT}`);\r\n});\r\n```\r\n\r\nIn friendsRouter, I have an extra middleware to log the ip address:\r\n```javascript\r\nfriendsRouter.use((req, res, next) => {\r\n  console.log('ip address', req.ip);\r\n  next();\r\n});\r\n```\r\n\r\nWhen I send a GET request, the logs are as expected:\r\n```bash\r\nGET /friends/ 2ms\r\nip address ::1\r\n```\r\n\r\nHowever, when I send a POST request, the order of logs is not consistent:\r\n```bash\r\nPOST /friends 4ms\r\nip address ::1\r\n```\r\n\r\n**Expected Behavior:**\r\nConsistent order of logs is expected for both GET and POST requests since the order of middleware functions is not changed.\r\n\r\n**Actual Behavior:**\r\nThe order of logs is inconsistent for GET and POST requests, and there's a noticeable difference in the path format for POST requests.\r\nFor a POST request, there is no / at the end.\r\n\r\n**Additional Information:**\r\nExpress version: 4.18.2\r\nNode.js version: 20.10.0\r\nOperating System: WSL2",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5403/comments",
    "author": "ThomasCode92",
    "comments": [
      {
        "user": "ammyroy119",
        "created_at": "2024-01-24T11:07:11Z",
        "body": "The inconsistency in the order of logs and the difference in the path format for GET and POST requests may be due to the fact that the delta logging is done outside of the asynchronous operation in the middleware stack. When using asynchronous operations like next() or async middleware, the timing of logging might be affected.\r\n\r\nTo address this issue, you can modify the logging middleware to ensure that the delta logging is done after the asynchronous operations complete. One way to achieve this is by using the response event emitted by Express after the response has been sent.\r\n\r\nHere's an updated version of your logging middleware:\r\n```\r\n`app.use((req, res, next) => {\r\n  const start = Date.now();\r\n\r\n  res.on('finish', () => {\r\n    const delta = Date.now() - start;\r\n    console.log(`${req.method} ${req.baseUrl}${req.url} ${delta}ms`);\r\n  });\r\n\r\n  next();\r\n});\r\n```\r\nBy attaching the logging code to the finish event of the response, you ensure that it will be executed after the response has been sent, regardless of any asynchronous operations in the middleware stack.\r\n\r\nAfter making this change, the order of logs for both GET and POST requests should be consistent."
      },
      {
        "user": "ThomasCode92",
        "created_at": "2024-01-24T11:18:19Z",
        "body": "@ammyroy119 Thank you so much for the detailed explanation and solution! I've tested it, and it appears to be working perfectly! Your assistance is greatly appreciated."
      }
    ]
  },
  {
    "number": 4824,
    "title": "HTTP HEAD request giving ERR_STREAM_WRITE_AFTER_END error with node express 4.x",
    "created_at": "2022-02-16T14:12:03Z",
    "closed_at": "2022-03-27T06:10:21Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/expressjs/express/issues/4824",
    "body": "I have a health check route for my application which we use to check the application's health, it's a ```GET``` route but clients send ```HTTP HEAD``` call to the same route but I am getting ```ERR_STREAM_WRITE_AFTER_END``` error. When digging into that I found out whenever I try to send response data for type ```HEAD``` call this error comes but couldn't find the actual reason for the same. Can someone explain why it's behaving this way? The sample code is given below.\r\n\r\nCode with error, it's giving error even with ```res.json``` and ```res.send```\r\n\r\n````\r\nrouter.get('/health', function (req, res) {\r\n    res.send({\r\n        message: \"working great!!!\"\r\n    });\r\n    res.end();\r\n});\r\n````",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4824/comments",
    "author": "jatinseth2007",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-02-16T14:14:26Z",
        "body": "Hi, sorry you are having issues. You should not be calling both `res.send` and `res.end`. I'm not at a computer to check, but can you see if removing the `res.end` call fixes the issue? If not, what version of Node.js are you using?"
      },
      {
        "user": "dougwilson",
        "created_at": "2022-02-16T14:22:53Z",
        "body": "Ok, I was able to confirm removing `res.end` stops the error. The error comes from Node.js itself, from the `res.end` call. Why it only appears when it is a HEAD request, I am not sure, but would be a Node.js issue, as Express.js does unfortunately not control the APIs from Node.js like `res.end`."
      },
      {
        "user": "jatinseth2007",
        "created_at": "2022-02-16T14:34:12Z",
        "body": "> Ok, I was able to confirm removing `res.end` stops the error. The error comes from Node.js itself, from the `res.end` call. Why it only appears when it is a HEAD request, I am not sure, but would be a Node.js issue, as Express.js does unfortunately not control the APIs from Node.js like `res.end`.\r\n\r\nI am using ```NODE - 16.13.1```, by removing `res.end` doesn't resolve the error for me but by removing `res.send` resolves the error for me. I posted this one to understand more why it's behaving this way? for example for `HTTP HEAD` method why by using `res.send` or `res.json` it's throwing the error."
      },
      {
        "user": "dougwilson",
        "created_at": "2022-02-16T14:41:38Z",
        "body": "It should not be throwing for HEAD for those methods. When you are testing, can you test this as the entire program? If it doesn't happen, then you may need to provide the entire code that causes it so we can reopen and investigate. \r\n\r\n```js\r\nconst express = require('express')\r\nconst app = express()\r\n\r\napp.get('/health', function (req, res) {\r\n    res.send({\r\n        message: \"working great!!!\"\r\n    })\r\n})\r\n\r\napp.listen(3000)\r\n```"
      },
      {
        "user": "jatinseth2007",
        "created_at": "2022-02-17T04:25:54Z",
        "body": "> \r\n\r\nFor me even this same code you have written is throwing error, only by removing `res.send` and putting `res.end`, it's working for me, and the full code is exactly nothing else we are checking if `DB` is up and `REDIS` is up and reply back. \r\n\r\nI am using `NODE -> 16.13.1` + `EXPRESS 4.x`"
      },
      {
        "user": "dougwilson",
        "created_at": "2022-02-17T04:27:41Z",
        "body": "Hi @jatinseth2007 thanks, and that is unfortunate. I cannot reproduce the issue. That means you or someone else will likely need to contribute a fix for it. I will leave this open to see if anyone can contribute a fix."
      },
      {
        "user": "lukaswilkeer",
        "created_at": "2022-02-23T21:37:49Z",
        "body": "@jatinseth2007 cause the asynchronous characteristic of javascript and it's interpretiviness is occurring a racing condition, where you call res.end before setting the headers.\r\n\r\nYou can use the **iterator protocol** to make this work, and then, call the res.end() or even the res.send if set the request posses a HEAD method;"
      },
      {
        "user": "dougwilson",
        "created_at": "2022-03-27T06:10:21Z",
        "body": "I'm going to close this for now, as I still cannot reproduce the issue, so don't have any idea what the cause is / what would be a fix (if any) in Express.js. In addition, no one else has provided any fix in the time here. You're always welcome to pull request a fix, though!"
      }
    ]
  },
  {
    "number": 2660,
    "title": "Unexpected behaviour from app.param middleware",
    "created_at": "2015-05-24T17:59:09Z",
    "closed_at": "2015-06-19T00:59:43Z",
    "labels": [
      "ideas",
      "help wanted"
    ],
    "url": "https://github.com/expressjs/express/issues/2660",
    "body": "Hi,\n\napp.param shows an unexpected behaviour if it is used in another app instance.\n## Full and runnable JS code\n### app.js\n\n``` javascript\n'use strict'\n\nvar express = require('express')\nvar app = express()\n\napp.use(require('./parameters'))\napp.use(require('./routes'))\n\napp.listen(5000)\n```\n### parameters.js\n\n``` javascript\n'use strict'\n\nvar express = require('express')\nvar app = module.exports = express()\n\napp.param('user', function(req, res, next, id) {\n  console.log('param method called with id ', id)\n  req.user = {\n    id: id\n  }\n  next()\n})\n```\n### routes.js\n\n``` javascript\n'use strict'\n\nvar express = require('express')\nvar app = module.exports = express()\n\napp.get('/:user', function(req, res) {\n  res.send(req.user.id)\n})\n```\n## Clear description of the problem or unexpected behavior.\n\nStarting the app with \n\n```\nnode app.js\n```\n\nand accessing \n\n```\nlocalhost:5000/test\n```\n\nyou will get\n\n```\nTypeError: Cannot read property 'id' of undefined\n```\n\nbecause app.param was never executed.\n\nInstead putting all together it works like here\n\n``` javascript\n'use strict'\n\nvar express = require('express')\nvar app = module.exports = express()\n\napp.param('user', function(req, res, next, id) {\n  console.log('param method called with id ', id)\n  req.user = {\n    id: id\n  }\n  next()\n})\n\napp.get('/:user', function(req, res) {\n  res.send(req.user.id)\n})\n```\n## Clear description of the expected result.\n\nI would expect that the first code example should also work. So you can separate the code in differente files and mount them together.\n## Steps you have taken to debug it yourself.\n\nOnly the steps described here.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2660/comments",
    "author": "rudolfschmidt",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-05-24T18:11:31Z",
        "body": "Hi! Thanks for the report, though this is the intended behavior and is not a bug. If you would like to contribute a PR such that the behavior you desire works, that would be most welcome :)\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-05-24T18:23:27Z",
        "body": "Based on your initial post, though, what is there would never be fixed, however, because a sub app should never be able to influence a parent app (i.e. a parent app would never look at params in an independent sub app). It may be more desirable to pick a different code organization method, however. BUT we are always open to PRs if you wanted to implement a new behavior and we can always discuss on that PR :)\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-06-19T00:59:43Z",
        "body": "Closing due to lack of response and no PRs offered; if someone runs across this in the future, PRs are welcome :)\n"
      }
    ]
  },
  {
    "number": 2619,
    "title": "change res.links() to also accept array",
    "created_at": "2015-04-15T16:15:47Z",
    "closed_at": "2024-10-29T15:42:07Z",
    "labels": [
      "4.x",
      "help wanted",
      "pr"
    ],
    "url": "https://github.com/expressjs/express/pull/2619",
    "body": null,
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2619/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "UlisesGascon",
        "created_at": "2024-10-29T15:42:07Z",
        "body": "Duplicated with #2702, so I will close it"
      }
    ]
  },
  {
    "number": 2052,
    "title": "app#use(RegExp, Function)",
    "created_at": "2014-04-14T21:46:19Z",
    "closed_at": "2014-05-01T02:32:29Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/expressjs/express/issues/2052",
    "body": "Can we get support for this?\nLooking briefly at it - doesn't look like it'd take much.\n\nI believe it was supported in 3.X if I'm not mistaken\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2052/comments",
    "author": "zokeefe",
    "comments": [
      {
        "user": "defunctzombie",
        "created_at": "2014-04-14T21:47:28Z",
        "body": "PR welcome for further review\n"
      }
    ]
  }
]