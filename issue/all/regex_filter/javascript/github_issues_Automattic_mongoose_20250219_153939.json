[
  {
    "number": 14959,
    "title": "Initialize Models on build time",
    "created_at": "2024-10-12T16:16:53Z",
    "closed_at": "2024-11-14T09:48:12Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14959",
    "body": "### Prerequisites\n\n- [x] I have written a descriptive issue title\n\n### Mongoose version\n\n8.7.0\n\n### Node.js version\n\n20.14.10\n\n### MongoDB version\n\n7.x\n\n### Operating system\n\nWindows\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n11\n\n### Issue\n\nFor a backup solution i'm restoring mongodb data from a json file.\n\nIn case that a model is not yet initialized yet, I offer fallback solutions for insertMany.\n\n```ts\nexport const insertMany = async ({\n  name,\n  data,\n}: InsertManyByCollectionProps) => {\n  const mongooseModel = mongoose.models[name];\n\n// if model is initialized and already used atleast once\n  if (mongooseModel) {\n    await mongooseModel.insertMany(data, { ordered: false }); \n\n    return;\n  }\n\n  const knownModels: Record<string, mongoose.Model<any>> = {\n   modelName: ExampleModel\n\n  };\n\n  const knownModel = knownModels[name];\n\n// if model is known (e.g. core model)\n  if (knownModel) {\n    await knownModel.insertMany(data, { ordered: false }); \n\n    return;\n  }\n\n// fallback, if model is not initialized and not \"known model\" (e.g. plugin model)\n  await mongoose.connection.db?.collection(name).insertMany( \n    data.map((v) => {\n      const newV = { ...v };\n\n      if (newV._id) {\n        newV._id = ObjectId.createFromHexString(v._id);\n      }\n\n      if (newV.createdAt) {\n        newV.createdAt = new Date(newV.createdAt);\n      }\n\n      if (newV.updatedAt) {\n        newV.updatedAt = new Date(newV.updatedAt);\n      }\n\n      return newV;\n    }),\n    { ordered: false }\n  ); \n};\n\n```\n\nIs there a way to initialize all defined models directly during creation so that the data can be parsed correctly by the schema?\nThis is useful if the model can't be defined in a list and is not yet in use. (e.g. plugins)\nOtherwise I have to come up with some serialization for deeply nested ObjectId's or Dates.",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14959/comments",
    "author": "timheerwagen",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2024-10-20T19:40:37Z",
        "body": "I'm not sure I understand what the question is here. How are you creating your models?"
      },
      {
        "user": "timheerwagen",
        "created_at": "2024-10-22T15:54:26Z",
        "body": "One of my models:\n```ts\n\nconst MongooseFileSchema = new mongoose.Schema<FileSchema>(\n  {\n    name: { type: String, required: true },\n  },\n);\n\nMongooseFileSchema.index({\n  name: \"text\",\n});\n\nexport const FileModel =\n  (mongoose.models?.[FILE_MODEL_NAME] as Model<FileSchema>) ||\n  mongoose.model<FileSchema>(FILE_MODEL_NAME, MongooseFileSchema);\n\n```\n\nIf this model is not yet used by FileModel.find, it is not included in `mongoose.models`."
      },
      {
        "user": "vkarpov15",
        "created_at": "2024-11-05T17:39:14Z",
        "body": "Ok, where are you getting the model names from then?"
      },
      {
        "user": "timheerwagen",
        "created_at": "2024-11-05T17:56:44Z",
        "body": "The special case is when another plugin introduces a model, my backup plugin cannot know that it exists until it is used. And that is the problem, that this model is not taken into account afterwards."
      },
      {
        "user": "vkarpov15",
        "created_at": "2024-11-13T20:23:38Z",
        "body": "Then I think the issue is more that you need to get all the model names first, perhaps by running a separate loop over your data to instantiate the models. Would that work?"
      }
    ]
  },
  {
    "number": 14871,
    "title": "Mongoose aws4 wrong service account",
    "created_at": "2024-09-06T15:54:48Z",
    "closed_at": "2024-09-29T00:26:03Z",
    "labels": [
      "help",
      "help wanted",
      "Stale"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14871",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n8.2.0\n\n### Node.js version\n\n18.18.0\n\n### MongoDB version\n\n 6.0\n\n### Operating system\n\nLinux\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\nalpine3.18\n\n### Issue\n\nHI!\r\n\r\nI'm trying to connect to mongoatlas using ?authMechanism=MONGODB-AWS and with a service account isra defined.\r\nHowever eks default service account is being used resulting is the following error.\r\n\r\nMongoServerError: Could not find user \"arn:aws:sts::XXXXX for 'db $external'\r\n\r\nAny ideas?\r\n\r\nVersions:\r\n\"aws4\": \"1.13.2\"\r\n\"mongoose\": \"8.2.0\",\r\n\r\nThank you",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14871/comments",
    "author": "pedrooct",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2024-09-09T19:23:39Z",
        "body": "Are you able to connect using the mongodb node driver?"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2024-09-24T00:23:06Z",
        "body": "This issue is stale because it has been open 14 days with no activity. Remove stale label or comment or this will be closed in 5 days"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2024-09-29T00:26:02Z",
        "body": "This issue was closed because it has been inactive for 19 days and has been marked as stale."
      }
    ]
  },
  {
    "number": 14815,
    "title": "How to type added static methods and query helpers",
    "created_at": "2024-08-18T19:02:06Z",
    "closed_at": "2024-09-02T10:37:16Z",
    "labels": [
      "help",
      "help wanted",
      "Stale"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14815",
    "body": "### Mongoose version\r\n\r\n8.5.2\r\n\r\n### Node.js version\r\n\r\nv20.13.1\r\n\r\n### MongoDB version\r\n\r\n7.0\r\n\r\n\r\nI carefully read the Typescript section in the documentation, and static methods started working for me, but the query assistants did not work. An error occurred: Property 'isAbsent' does not exist on type '{}'. After spending a lot of time, I gave up and decided to create a question. I initially created universal types for static methods and query helpers, which I connected via a global plugin. And then I passed the schema interface to the generic, which was inherited from Document. In general, the question could be called 'How to add static methods or query helpers globally, without getting into each model and not duplicating generics in interfaces', but most likely this cannot be done).\r\n\r\nMy attempt\r\n‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è\r\n./querieHelpers.type\r\n```\r\nimport { QueryWithHelpers, HydratedDocument, Document } from \"mongoose\"\r\n\r\n\r\nexport default interface IQueryHelpers<T> {\r\n  isAbsent(statusCode: number): Promise<QueryWithHelpers<HydratedDocument<T>[], HydratedDocument<T>, IQueryHelpers<T>>>\r\n}\r\n```\r\n./static.type\r\n```\r\nimport {\r\n  FilterQuery,\r\n  ProjectionType,\r\n  QueryOptions,\r\n  Model,\r\n  QueryWithHelpers,\r\n} from \"mongoose\";\r\n\r\nimport IQueryHelpers from \"./querieHelpers.type\";\r\n\r\nexport default interface IGlobalMethods<T> {\r\n  findOneEnabled (\r\n    this: Model<T>,\r\n    filters: FilterQuery<T>,\r\n    projection?: ProjectionType<T>,\r\n    options?: QueryOptions\r\n  ): QueryWithHelpers<\r\n  T | null, T, IQueryHelpers<T>\r\n>,\r\n}\r\n```\r\n./addQuerieHelpers.plugin\r\n```\r\nimport { Schema } from \"mongoose\";\r\n\r\nimport isAbsent  from './isAbsent.qh'\r\n\r\nconst addStatics = function(schema: Schema) {\r\n  schema.query.isAbsent /*<===Error*/ = isAbsent\r\n}\r\n\r\nexport default addStatics\r\n```\r\n./addStatic.plugin\r\n```\r\nimport { Schema } from \"mongoose\";\r\n\r\nimport findOneEnabled  from './findOneEnabled.static'\r\n\r\nconst addStatics = function(schema: Schema) {\r\n  schema.statics.findOneEnabled = findOneEnabled\r\n}\r\n\r\nexport default addStatics\r\n\r\n```\r\n./findOneEnabled.static\r\n```\r\nimport {\r\n  FilterQuery,\r\n  ProjectionType,\r\n  QueryOptions,\r\n  Model\r\n} from \"mongoose\";\r\n\r\nconst findOneEnabled = async function<T> (\r\n  this: Model<T>,\r\n  filters: FilterQuery<T>,\r\n  projection?: ProjectionType<T>,\r\n  options?: QueryOptions\r\n): Promise<T | null> {\r\n  const updatedFilters = { ...filters, enabled: true };\r\n  return await this.findOne(updatedFilters, projection, options);\r\n};\r\n\r\nexport default findOneEnabled;\r\n```\r\n./isAbsent.qh\r\n```\r\nimport { QueryWithHelpers, HydratedDocument} from \"mongoose\"\r\n\r\nimport ApiError from \"../../../errors/api.error\"// some error\r\nimport IQueryHelpers from \"./querieHelpers.type\"\r\n\r\nconst isAbsent = async function<T>(\r\n  this: QueryWithHelpers<any, \r\n  HydratedDocument<T>,\r\n  IQueryHelpers<T>>, \r\n  statusCode: number\r\n): Promise<T> {\r\n  const doc = await this.exec()\r\n  const model = this.model.modelName\r\n  const query = this.getQuery()\r\n\r\n  if (!doc) {\r\n    throw ApiError.StatusCode(statusCode, model, query)// some error\r\n  }\r\n\r\n  return doc\r\n}\r\nexport default isAbsent\r\n```\r\n./model\r\n```\r\nimport { Schema, Document, model, Model} from 'mongoose';\r\n\r\nimport IStaticMethods from \"./static.type\";\r\nimport IQueryHelpers from \"./querieHelpers.type\";\r\n\r\nexport interface IEntity extends Document {\r\n  idEntity: number\r\n}\r\n\r\ninterface ProfileModel extends Model<IEntity, IQueryHelpers<IEntity>>, IStaticMethods<IEntity> {}\r\n\r\nconst entitySchema = new Schema<\r\nIEntity,\r\nModel<IEntity, IQueryHelpers<IEntity>>,\r\n{},\r\nIQueryHelpers<IEntity>,\r\n{},\r\nIStaticMethods<IEntity>>({\r\n  idEntity: {type: Number, required: true}\r\n})\r\n\r\n\r\nexport default model<IEntity, ProfileModel>('Profile', entitySchema)\r\n```\r\n./index\r\n```\r\nimport mongoose from \"mongoose\";\r\n\r\nimport addStatic from './addStatic.plugin'\r\nimport addQuerieHelpers from './addStatic.plugin'\r\n\r\nmongoose.plugin(addStatic)\r\nmongoose.plugin(addQuerieHelpers)\r\n```",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14815/comments",
    "author": "Jaspper132",
    "comments": [
      {
        "user": "github-actions[bot]",
        "created_at": "2024-09-02T00:22:38Z",
        "body": "This issue is stale because it has been open 14 days with no activity. Remove stale label or comment or this will be closed in 5 days"
      }
    ]
  },
  {
    "number": 14805,
    "title": "Question about .findOne()",
    "created_at": "2024-08-14T02:19:08Z",
    "closed_at": "2024-08-15T01:29:59Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14805",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n8.5.3\n\n### Node.js version\n\n20.10.0\n\n### MongoDB version\n\n7.0.12\n\n### Operating system\n\nNone\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nWith .findOne(), what would happen if many documents meet the filter? Would .findOne() return the newest one? If this is not the case, is there any way of doing it?",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14805/comments",
    "author": "CarlosDev123",
    "comments": [
      {
        "user": "Ayanabilothman",
        "created_at": "2024-08-14T18:48:57Z",
        "body": "if many documents meet the filter, findOne() will return the first matched document. If you want the newest matched document, use findOne() with sort() method, and sort by createdAt attribute.\r\n\r\nfor example:\r\n`User.findOne({age:30}).sort({ createdAt: -1 })` \r\nwill return the newest user whose age is 30"
      }
    ]
  },
  {
    "number": 14750,
    "title": "Mongoose potentially fails to disconnect from mongod when used with pm2",
    "created_at": "2024-07-16T08:14:35Z",
    "closed_at": "2024-07-17T06:46:07Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14750",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n7.7.0 (according to the lockfile)\r\n\r\n### Node.js version\r\n\r\n20.15.1\r\n\r\n### MongoDB version\r\n\r\nv7.0.3\r\n\r\n### Operating system\r\n\r\nLinux\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\nUbuntu v22.04.3\r\n\r\n### Issue\r\n\r\n## NOTE:\r\nI am not certain the issue is within mongoose. I am investigating the possible culprits.\r\n\r\n---\r\n\r\nApologies for the messy title, I don't quite know how to correctly categorize it as I'm still investigating it.\r\nI'm running an app with pm2 set to cluster mode and max instances. The app uses mongodb (via mongoose).\r\nWhen running the app via pm2, the amount of mongod threads climbs consistently, starting from 80 threads and up to >999, causing server unavailability and unresponsiveness.\r\n\r\nI have added kill_timeout: 6000 to the pm2 ecosystem.config.js but it doesn't seem to have fixed the issue, as I manually have to restart mongod in order to reduce the amount of threads.\r\nBelow is the ecosystem.config.js file:\r\n```js\r\nmodule.exports = {\r\n\tapps: [\r\n\t\t{\r\n\t\t\tname: 'name',\r\n\t\t\tport: '3000',\r\n\t\t\texec_mode: 'cluster',\r\n\t\t\tinstances: 'max',\r\n\t\t\tkill_timeout: 6000,\r\n\t\t\tscript: 'path/to/script.mjs'\r\n\t\t}\r\n\t]\r\n}\r\n```\r\n\r\nI have already made sure that in terms of the app code, the connection through mongoose happens in a server plugin (a piece of code that runs once on server startup) and the disconnection happens in a graceful shutdown hook that listens to SIGINT and SIGTERM. If needed, I can share a reproduction privately as the project is closed source.",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14750/comments",
    "author": "GalacticHypernova",
    "comments": [
      {
        "user": "GalacticHypernova",
        "created_at": "2024-07-17T06:46:07Z",
        "body": "The issue is not mongoose "
      },
      {
        "user": "RShah512",
        "created_at": "2024-07-31T04:25:15Z",
        "body": "@GalacticHypernova Did you mange to find out the root cause for this issue?"
      }
    ]
  },
  {
    "number": 14627,
    "title": "Is there a way to preserve documents modifications when a doc is modified and then populated?",
    "created_at": "2024-05-31T15:11:05Z",
    "closed_at": "2024-06-05T20:43:44Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14627",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.12.8, 7.6.12\n\n### Node.js version\n\n14.21.3, 16.20.2\n\n### MongoDB version\n\n5.0.26\n\n### Operating system\n\nNone\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nHi all,\r\n\r\nWondering if there's a way to preserve changes when doing the following:\r\n\r\n```JS\r\nconst foo = await Foo.findById('someId').populate('bar')\r\n\r\nfoo.bar.name = 'hi there'\r\n\r\nawait foo.populate('bar')\r\n// At this point the foo.bar.name modification is wiped out, saving the document will result in no changes\r\n```\r\n\r\nI know that this looks like a contrived example and there should be no reason to do it. The problem I'm trying to solve is this:\r\nI have a function, `funky`, that will populate `bar`, it essentially just does `await foo.populate('bar')`, that multiple code paths go to and `funky` requires that all properties of `bar` be available. These code paths contain a mixture of:\r\n  - Instances of a populated `bar` where only certain paths have been selected, such as ` await Foo.findById('someId').populate({path: 'bar', select: 'name'})`\r\n  - Instances like the example above where `select` is not used and modifications to `bar` are made. This includes cases where modifications happen before and after the second `populate` is performed.\r\n\r\nI suppose the answer here is that I should audit all of these code paths and remove any `selects` that are happening, and then I shouldn't need the second populate. Just wanted to ask here if there's a way around this though before I spend the time, and potentially create new bugs. \r\n\r\nThanks for any advice.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14627/comments",
    "author": "ericneubauerbumphealth",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2024-06-02T15:00:16Z",
        "body": "Unfortunately the only workarounds would be to\r\n\r\n 1. `save()` the document before populating again: `await foo.bar.save(); await foo.populate('bar');`\r\n 2. avoid the extra `populate()` if `bar` is already populated: `if (!foo.populated('bar')) await foo.populate('bar');`\r\n 3. store a reference to the old document before populating: `const oldDoc = foo.bar; await foo.populate('bar');` \r\n  \r\n `populate()` creates a new populated document, so any change state on the previous document would get wiped out. Do any of these approaches work for you?"
      },
      {
        "user": "ericneubauerbumphealth",
        "created_at": "2024-06-05T20:43:35Z",
        "body": "I decided to go ahead and remove a lot of the `select`s that are currently being used in the app so that if a document is populated it should have all fields available. That combined with suggestion #‚Å†2 should put us in a good spot. Thank you!"
      }
    ]
  },
  {
    "number": 14578,
    "title": "Return the deleted document after a deleteOne operation",
    "created_at": "2024-05-08T15:56:35Z",
    "closed_at": "2024-05-09T15:36:23Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14578",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n8.3.4\n\n### Node.js version\n\n18.2.0\n\n### MongoDB version\n\n6.5.0\n\n### Operating system\n\nLinux\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\nLinux 6.8.7-arch1-\n\n### Issue\n\nWe are currently migration our codebase from version 6.5.4 to version 8.3.4.\r\n\r\nAs recomended, we first migrated to version 7 and dealed with the breaking changes, and then moved to migrate from version 7 to the latest version.\r\n\r\nThis is where we hit a wall, as our system depends on a pair of middlewares that detects every change done to the documents:\r\n- A post `save` that detects creation and updates of documents that works fine\r\n- A post `deleteOne` (migrated from a `remove` in mongoose 7) that detects deletions of documents.\r\n\r\nThe new return being a query instead of the deleted document  messed up everything in in our workflow.  Is there any easy alternative or change we can do to restore the behavior of the `deleteOne` method?\r\n\r\nThanks for looking into it.",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14578/comments",
    "author": "Davian99",
    "comments": [
      {
        "user": "Davian99",
        "created_at": "2024-05-09T12:09:15Z",
        "body": "Nevermind, I discovered the `{ document: true, query: false }` option that works exactly the same as before.\r\n\r\n```\r\nschema.post('deleteOne', { document: true, query: false }, async function(document, next) {\r\n  // document contains the deleted document\r\n});\r\n```"
      },
      {
        "user": "vkarpov15",
        "created_at": "2024-05-09T15:36:23Z",
        "body": "Yeah the issue is that `deleteOne()` is both a query method and a document method. And query `deleteOne()` doesn't have access to the deleted document, you need to use `findOneAndDelete()` for that."
      }
    ]
  },
  {
    "number": 14498,
    "title": "Using the ms package on expireAt option",
    "created_at": "2024-04-04T01:06:02Z",
    "closed_at": "2024-04-14T21:23:30Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14498",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n8.3.0\r\n\r\n### Node.js version\r\n\r\nv20.10.0\r\n\r\n### MongoDB version\r\n\r\n7.0.7\r\n\r\n### Operating system\r\n\r\nNone\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n_No response_\r\n\r\n### Issue\r\n\r\n  ```js\r\n  const time = new Date();\r\n  time.setDate(time.getDate() + 30);\r\n  const expiresAt = new Date(time);\r\n\r\n  const punishmentData = {\r\n    id: '',\r\n    type: '',\r\n    user: '',\r\n    guild: '',\r\n    moderator: '',\r\n    reason: '',\r\n    date: '',\r\n    expires: '',\r\n    automod: '',\r\n    expireAt: expiresAt\r\n  };\r\n  ```\r\n  \r\n  On the code above, I use \"new Date()\" to set an expiration date to the data, my question is, instead of that, can I use something like the ms package? And if it's not possible, is there any alternative? Something like this:\r\n  \r\n  ```js\r\n  const punishmentData = {\r\n    id: '',\r\n    type: '',\r\n    user: '',\r\n    guild: '',\r\n    moderator: '',\r\n    reason: '',\r\n    date: '',\r\n    expires: '',\r\n    automod: '',\r\n    expireAt: ms('30d')\r\n  };\r\n  ```",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14498/comments",
    "author": "CarlosDev123",
    "comments": [
      {
        "user": "CarlosDev123",
        "created_at": "2024-04-04T04:29:11Z",
        "body": "I just updated to mongoose 8.3.0 and for some reason only 2 out of my 7 schemas were created, after downgrading versions I'm still getting this problem"
      },
      {
        "user": "CarlosDev123",
        "created_at": "2024-04-06T19:27:43Z",
        "body": "> I just updated to mongoose 8.3.0 and for some reason only 2 out of my 7 schemas were created, after downgrading versions I'm still getting this problem\r\n\r\nThis was resolved. However I'm still wondering if my first question is possible"
      },
      {
        "user": "CarlosDev123",
        "created_at": "2024-04-14T19:37:36Z",
        "body": "Any update?"
      },
      {
        "user": "vkarpov15",
        "created_at": "2024-04-25T22:10:42Z",
        "body": "You'd need to do `expireAt: new Date(Date.now() + ms('30d'))`. `ms('30d')` just returns the number of milliseconds in 30 days, you need to make sure you add that to the current time.\r\n\r\n`expiresAt: ms('30d')` just tells MongoDB that your collection expires 30 days after January 1, 1970, which I'm sure isn't what you're looking for."
      }
    ]
  },
  {
    "number": 14302,
    "title": "Dynamic population on a property nested in array of objects ",
    "created_at": "2024-01-29T10:30:29Z",
    "closed_at": "2024-02-27T00:18:02Z",
    "labels": [
      "help",
      "help wanted",
      "Stale"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14302",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n7.6.2\n\n### Node.js version\n\nv20.6.1\n\n### MongoDB version\n\nmongo atlas\n\n### Operating system\n\nmacOS\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nI am following #7273\r\nI did it just like the snippet described in the issue: \r\n```ts\r\nconst structureTemplateSchema: StructureTemplateSchema = new Schema({\r\n\tname: { type: String, required: true },\r\n\tprojectId: refTo(\"Project\", true),\r\n\tstructureType: { type: String, required: true },\r\n\tlayout: [\r\n\t\t{\r\n\t\t\ttemplateId: {\r\n\t\t\t\ttype: Schema.Types.ObjectId,\r\n\t\t\t\trequired: true,\r\n\t\t\t\trefPath: \"layout.refTo\",\r\n\t\t\t},\r\n\t\t\ttemplate: {\r\n\t\t\t\ttype: Schema.Types.ObjectId,\r\n\t\t\t\trequired: true,\r\n\t\t\t\trefPath: \"layout.refTo\",\r\n\t\t\t},\r\n\t\t\trefTo: {\r\n\t\t\t\ttype: String,\r\n\t\t\t\tenum: [\"UnitTemplate\", \"UnitTemplateGroup\"],\r\n\t\t\t\trequired: true,\r\n\t\t\t},\r\n\t\t\tstartingLevel: { type: Number, required: true, default: 1 },\r\n\t\t},\r\n\t],\r\n\ttotalLevels: { type: Number, required: true, default: 1 },\r\n});\r\n\r\n```\r\nand I am trying to populate the `template` property. \r\n\r\nI do `StructureTemplates.find().populate('layout.template')` \r\nand get: \r\n```ts\r\n{\r\n  \"_id\": \"65b77bf99ca495951775f777\",\r\n  \"name\": \"Sample\",\r\n  \"projectId\": \"65a2cab6c6631317f537e1c2\",\r\n  \"structureType\": \"TOWER\",\r\n  \"layout\": [\r\n    {\r\n      \"templateId\": \"65a869c1d5e5889cf6203491\",\r\n      \"template\": \"65a869c1d5e5889cf6203491\",\r\n      \"refTo\": \"UnitTemplate\",\r\n      \"startingLevel\": 0,\r\n      \"_id\": \"65b77bf99ca495951775f778\"\r\n    }\r\n  ],\r\n  \"totalLevels\": 2,\r\n  \"__v\": 0\r\n}\r\n\r\n\r\n```\r\n\r\nWhat am I doing wrong here?",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14302/comments",
    "author": "akshay-nm",
    "comments": [
      {
        "user": "akshay-nm",
        "created_at": "2024-01-29T10:31:08Z",
        "body": "What do I need to do to get the `template` populated?"
      },
      {
        "user": "IslandRhythms",
        "created_at": "2024-02-02T16:03:40Z",
        "body": "```javascript\r\nconst mongoose = require('mongoose');\r\n\r\nconst { Schema } = mongoose;\r\n\r\nconst structureTemplateSchema = new Schema({\r\n\tname: { type: String, required: true },\r\n\t// projectId: refTo(\"Project\", true), // what is this suppose to be?\r\n\tstructureType: { type: String, required: true },\r\n\tlayout: [\r\n\t\t{\r\n\t\t\ttemplateId: {\r\n\t\t\t\ttype: Schema.Types.ObjectId,\r\n\t\t\t\trequired: true,\r\n\t\t\t\trefPath: \"layout.refTo\",\r\n\t\t\t},\r\n\t\t\ttemplate: {\r\n\t\t\t\ttype: Schema.Types.ObjectId,\r\n\t\t\t\trequired: true,\r\n\t\t\t\trefPath: \"layout.refTo\",\r\n\t\t\t},\r\n\t\t\trefTo: {\r\n\t\t\t\ttype: String,\r\n\t\t\t\tenum: [\"UnitTemplate\", \"UnitTemplateGroup\"],\r\n\t\t\t\trequired: true,\r\n\t\t\t},\r\n\t\t\tstartingLevel: { type: Number, required: true, default: 1 },\r\n\t\t},\r\n\t],\r\n\ttotalLevels: { type: Number, required: true, default: 1 },\r\n});\r\n\r\nconst testSchema = new Schema({\r\n  name: String\r\n});\r\n\r\nconst Structure = mongoose.model('Structure', structureTemplateSchema);\r\nconst UnitTemplate = mongoose.model('UnitTemplate', testSchema);\r\n\r\nasync function run() {\r\n  await mongoose.connect('mongodb://localhost:27017');\r\n  await mongoose.connection.dropDatabase();\r\n\r\n  const doc = await UnitTemplate.create({\r\n    name: 'Test Testerson'\r\n  });\r\n\r\n  const structure = await Structure.create({\r\n    name: 'Quiz Quizzerson',\r\n    structureType: 'Test',\r\n    layout: [{\r\n      templateId: doc._id,\r\n      template: doc._id,\r\n      refTo: 'UnitTemplate'\r\n    }]\r\n  });\r\n\r\n  const res = await Structure.findOne().populate('layout.template');\r\n  console.log('what is res', res, 'what is template', res.layout[0].template);\r\n}\r\n\r\nrun();\r\n```"
      },
      {
        "user": "IslandRhythms",
        "created_at": "2024-02-02T20:19:40Z",
        "body": "Without seeing what else you're doing I cannot help figure out what you're doing wrong. The best I can do is provide this script that shows how to do it correctly."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2024-02-22T00:17:54Z",
        "body": "This issue is stale because it has been open 14 days with no activity. Remove stale label or comment or this will be closed in 5 days"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2024-02-27T00:18:01Z",
        "body": "This issue was closed because it has been inactive for 19 days and has been marked as stale."
      }
    ]
  },
  {
    "number": 14297,
    "title": " trying to populate nested field using refpath",
    "created_at": "2024-01-26T10:01:28Z",
    "closed_at": "2024-03-10T20:39:36Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14297",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n8.0.3\r\n\r\n### Node.js version\r\n\r\nv20.2.0\r\n\r\n### MongoDB version\r\n\r\n6.0.13\r\n\r\n### Operating system\r\n\r\nLinux\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\nUbuntu 22.04.2 LTS\r\n\r\n### Issue\r\ni am using dynamic references based on the type field in my chatList.When populating such dynamic references i need to populate the field inside in it also.\r\n\r\n```\r\nimport mongoose from \"mongoose\";\r\n\r\nconst contactSchema = mongoose.Schema({\r\n\tuserId: { type: mongoose.Types.ObjectId, ref: \"User\", unique: true },\r\n\tchatList: [\r\n\t\t{\r\n\t\t\t_id: false,\r\n\t\t\ttype: {\r\n\t\t\t\ttype: String,\r\n\t\t\t\tenum: [\"Private\", \"Group\"],\r\n\t\t\t\trequired: true,\r\n\t\t\t},\r\n\t\t\tchat: {\r\n\t\t\t\ttype: mongoose.Schema.Types.ObjectId,\r\n\t\t\t\trefPath: \"chatList.$.type\",\r\n\t\t\t},\r\n\t\t},\r\n\t],\r\n\tfollowings: [\r\n\t\t{\r\n\t\t\ttype: mongoose.Schema.Types.ObjectId,\r\n\t\t\tref: \"User\",\r\n\t\t},\r\n\t],\r\n\tfollowers: [\r\n\t\t{\r\n\t\t\ttype: mongoose.Schema.Types.ObjectId,\r\n\t\t\tref: \"User\",\r\n\t\t},\r\n\t],\r\n});\r\n\r\nexport default mongoose.model(\"Contact\", contactSchema);\r\n```\r\nthis is  my schema where i use dynamic refrences. now i need to populate the chat field along with all other field. also after populate the chat field i need to pupulate the participant field inside the chat . the chat field schema just look like this \r\n\r\n```\r\nimport mongoose from \"mongoose\";\r\n\r\nconst privateSchema = mongoose.Schema(\r\n\t{\r\n\t\tparticipants: [\r\n\t\t\t{\r\n\t\t\t\ttype: mongoose.Schema.Types.ObjectId,\r\n\t\t\t\tref: \"User\",\r\n\t\t\t},\r\n\t\t],\r\n\t\tmessages: [\r\n\t\t\t{\r\n\t\t\t\ttype: mongoose.Schema.Types.ObjectId,\r\n\t\t\t\tref: \"Message\",\r\n\t\t\t},\r\n\t\t],\r\n\t},\r\n\t{ timestamps: true }\r\n);\r\n\r\nexport default mongoose.model(\"Private\", privateSchema);\r\n```\r\nhow can i do that. i just refer your docs .but it does'nt work for me. ",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14297/comments",
    "author": "MuGrahiman",
    "comments": [
      {
        "user": "IslandRhythms",
        "created_at": "2024-02-01T17:31:53Z",
        "body": "Here you go:\r\n```javascript\r\nconst mongoose = require('mongoose');\r\n\r\nconst contactSchema = mongoose.Schema({\r\n\tchatList: [\r\n\t\t{\r\n\t\t\t_id: false,\r\n\t\t\ttype: {\r\n\t\t\t\ttype: String,\r\n\t\t\t\tenum: [\"Private\", \"Group\"],\r\n\t\t\t\trequired: true,\r\n\t\t\t},\r\n\t\t\tchat: {\r\n\t\t\t\ttype: mongoose.Schema.Types.ObjectId,\r\n\t\t\t\trefPath: 'chatList.type',\r\n\t\t\t},\r\n\t\t},\r\n\t],\r\n});\r\n\r\nconst privateSchema = mongoose.Schema(\r\n\t{\r\n\t\tparticipants: [\r\n\t\t\t{\r\n\t\t\t\ttype: mongoose.Schema.Types.ObjectId,\r\n\t\t\t\tref: \"User\",\r\n\t\t\t},\r\n\t\t],\r\n\t\tmessages: [\r\n\t\t\t{\r\n\t\t\t\ttype: mongoose.Schema.Types.ObjectId,\r\n\t\t\t\tref: \"Message\",\r\n\t\t\t},\r\n\t\t],\r\n\t},\r\n\t{ timestamps: true }\r\n);\r\n\r\nconst userSchema = new mongoose.Schema({\r\n  name: String\r\n});\r\n\r\nconst messageSchema = new mongoose.Schema({\r\n  text: String\r\n});\r\n\r\nconst Contact = mongoose.model('Contact', contactSchema);\r\n\r\nconst Private = mongoose.model('Private', privateSchema);\r\n\r\nconst User = mongoose.model('User', userSchema);\r\n\r\nconst Message = mongoose.model('Message', messageSchema);\r\n\r\nasync function run() {\r\n  await mongoose.connect('mongodb://localhost:27017');\r\n  await mongoose.connection.dropDatabase();\r\n\r\n  const user = await User.create({ name: 'Test Testerson '});\r\n  const message = await Message.create({ text: 'This is a test message' });\r\n\r\n  const private = await Private.create({ participants: [user._id], messages: [message._id] });\r\n\r\n  const contact = await Contact.create({ chatList: [{ type: 'Private', chat: private._id }]});\r\n\r\n  const res = await Contact.findOne().populate({ path: 'chatList.chat', populate: [{ path: 'participants' }, { path: 'messages' }] });\r\n\r\n  console.log(res, res.chatList[0].chat);\r\n}\r\n\r\nrun();\r\n```"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2024-03-01T00:20:13Z",
        "body": "This issue is stale because it has been open 14 days with no activity. Remove stale label or comment or this will be closed in 5 days"
      }
    ]
  },
  {
    "number": 14273,
    "title": "Can't seem to type my functions correctly (using discriminator models)",
    "created_at": "2024-01-19T15:12:20Z",
    "closed_at": "2024-02-20T21:42:33Z",
    "labels": [
      "help",
      "help wanted",
      "typescript"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14273",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.12.5\n\n### Node.js version\n\n18.19.0\n\n### MongoDB version\n\n5.0\n\n### Operating system\n\nmacOS\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\nSonoma 14.2.1\n\n### Issue\n\nThere are a number of situations where I seem to fail in writing the correct typing to make the typescript code work.\r\n\r\nI've defined my models as follow\r\n\r\n```\r\ninterface IBase {\r\n  nameBase: string;\r\n}\r\n\r\ninterface IDiscriminator extends IBase {\r\n  nameDiscriminator: string;\r\n}\r\n\r\nconst baseSchema = new mongoose.Schema<IBase>();\r\nconst discriminatorSchema = new mongoose.Schema<IDiscriminator>();\r\n\r\nconst BaseModel = mongoose.model<IBase>('base', baseSchema);\r\nconst DiscriminatedModel = BaseModel.discriminator<IDiscriminator>('discriminator', discriminatorSchema);\r\n```\r\n\r\nThe following works without issues:\r\n```\r\nclass TestClass {\r\n  public testFunction<T extends IBase>(M: mongoose.Model<T>) {\r\n    console.log(M);\r\n  }\r\n}\r\n\r\nconst testClass = new TestClass();\r\ntestClass.testFunction(BaseModel);\r\ntestClass.testFunction(DiscriminatedModel);\r\n```\r\n\r\nWhen moving the generic typing to the class definition it doesn't work, the code:\r\n```\r\nclass TestClass2<X extends IBase> {\r\n  public testFunction(M: mongoose.Model<X>) {\r\n    console.log(M);\r\n  }\r\n}\r\n\r\nconst testClass2 = new TestClass2();\r\ntestClass2.testFunction(BaseModel);\r\ntestClass2.testFunction(DiscriminatedModel);\r\n```\r\nDisplays an error on the last function call's argument (testClass2.testFunction(DiscriminatedModel);\r\n\r\nTS2345 - Argument of type Model<IDiscriminator..... is not assignable to type Model<IBase......\r\n\r\nBut I don't seem to understand why moving the generic triggers the error since (to me) it looks like it hasn't changed the inference between the 2 ways of writing the code.",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14273/comments",
    "author": "jpl-ivengi",
    "comments": [
      {
        "user": "valeriuflorescu16",
        "created_at": "2024-01-30T09:14:39Z",
        "body": "The main difference here is that the in the first instance, the generic type is defined at method level - each time you call `testFunction`, you can pass in a different type (one that is valid, so it has to extend `IBase`, which it does in your scenario so everything works well).\r\n\r\nIn `TestClass2`, the generic parameter is defined at class level, which is where the issue lies. Once you create an instance of `TestClass2`, the generic type is fixed for that instance. So if you were to replace `const testClass2 = new TestClass2();` with `const testClass2 = new TestClass2<IDiscriminator>();` then you would see the type error on the call of the function with `BaseModel`, and the second one would be fine. \r\n\r\nSo basically, you have more flexibility when defining the generic parameter at method level. üëç "
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2024-02-14T00:17:36Z",
        "body": "This issue is stale because it has been open 14 days with no activity. Remove stale label or comment or this will be closed in 5 days"
      },
      {
        "user": "vkarpov15",
        "created_at": "2024-02-20T21:42:33Z",
        "body": "The issue is that, while `X extends IBase`, there's no guarantee that `mongoose.Model<X>` extends `mongoose.Model<IBase>` in the following code.\r\n\r\n```ts\r\nclass TestClass2<X extends IBase> {\r\n  public testFunction(M: mongoose.Model<X>) {\r\n    console.log(M);\r\n  }\r\n}\r\n```\r\n\r\nI'd recommend @valeriuflorescu16 's approach: define the generic at the method level, not the class level. TypeScript doesn't have a way for us to tell the compiler that `mongoose.Model<IDiscriminator>` extends `mongoose.Model<IBase>`."
      }
    ]
  },
  {
    "number": 14203,
    "title": "how to make pre-hook callback function generic so that I can import it every mongoose schema?",
    "created_at": "2023-12-29T08:24:34Z",
    "closed_at": "2024-01-04T04:42:12Z",
    "labels": [
      "help",
      "help wanted",
      "needs clarification"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14203",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.4.4\n\n### Node.js version\n\n14\n\n### MongoDB version\n\n4.4.18\n\n### Operating system\n\nLinux\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nI am trying to make `pre hook` callback function generic so that I can use it in every schema. I was able to do it `post hook` but looks like pre doesn't allow me.\r\n\r\nin pre hook i am trying perform `findOne` then pass it to mongoose since i want to store data before performing any operation then i can compare both data in post hook.\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14203/comments",
    "author": "hiijitesh",
    "comments": [
      {
        "user": "hiijitesh",
        "created_at": "2023-12-29T08:30:25Z",
        "body": "```js\r\n\r\n// this function is suppose to be in other module and passing myModel to this function\r\nconst preFunctionHelper = function (myModel) {\r\n\treturn async function (next) {\r\n\t\ttry {\r\n\t\t\tconst { _id } = this.getQuery();\r\n\t\t\tconst myData = await myModel.findOne({ _id: id }).lean();\r\n\r\n\t\t\tnext();\r\n\t\t} catch (error) {\r\n\t\t\tconsole.error(\"Error in pre hook:\", error);\r\n\t\t\tnext(error);\r\n\t\t}\r\n\t};\r\n};\r\n\r\n// imorting preFunctionHelper and using it here\r\nschema.pre(\"updateOne\", preFunctionHelper(TestModel));\r\n\r\n\r\n```"
      },
      {
        "user": "vkarpov15",
        "created_at": "2024-01-02T11:51:31Z",
        "body": "What do you mean by \"but looks like pre doesn't allow me.\"? Are you getting some sort of error message?"
      },
      {
        "user": "hiijitesh",
        "created_at": "2024-01-02T11:59:06Z",
        "body": "@vkarpov15  Thank your for your response :)\r\nLet me clarify \r\n`\"but looks like pre doesn't allow me.\"? ` means pre was not getting executed whenever I tried to use it in schema module.\r\n\r\nGood thing is that I somehow manage to make it modular and was able to use it.\r\n\r\n```js\r\nfunction preHookHelper() {\r\n\treturn async function (next) {\r\n\t\ttry {\r\n\t\t\tconst query = this.getQuery();\r\n\t\t\t// main issue was how pass the \"Model\", which is solved by \"this.model\"\r\n\t\t\tconst oldData = await this.model.find(query).lean();\r\n\t\t\r\n\t\t\tthis._data = { oldData, query };\r\n\r\n\t\t\tnext();\r\n\t\t} catch (error) {\r\n\t\t\tconsole.error(\"Error in pre hook:\", error);\r\n\t\t\tnext(error);\r\n\t\t}\r\n\t};\r\n}```"
      }
    ]
  },
  {
    "number": 14181,
    "title": "i cant get the stored data from mongoDB database",
    "created_at": "2023-12-15T14:40:07Z",
    "closed_at": "2023-12-17T07:32:07Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14181",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n8.0.0\r\n\r\n### Node.js version\r\n\r\n18.18.0\r\n\r\n### MongoDB version\r\n\r\n6.0.0\r\n\r\n### Operating system\r\n\r\nWindows\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n10\r\n\r\n### Issue\r\n\r\nI am working on a project in which the user can create posts and can comment on them, and in the backend I created a schema model for the post and another for the comment, and when I comment on the post via the client side, the comment is created successfully and is stored in the database, but I cannot display the comments on the post page, and the error in the console is this\r\n`{error: 'Cast to ObjectId failed for value \"{ _id: undefined }\" (type Object) at path \"_id\" for model \"Post\"'}` \r\n\r\ncommentModel.js\r\n```\r\nimport mongoose from \"mongoose\";\r\nconst ObjectId = mongoose.Types.ObjectId;\r\n\r\nconst commentSchema = mongoose.Schema({\r\n    postId: {\r\n    type: ObjectId,\r\n    ref: \"Post\",\r\n    required: true,\r\n    },\r\n    comment: {\r\n        type: String,\r\n        required: true,\r\n    },\r\n    replies: [{\r\n        reply: {\r\n            type: String,\r\n            required: true,\r\n        },\r\n        username: {\r\n            type: String,\r\n            required: true,\r\n        },\r\n        commentId: {\r\n            type: ObjectId,\r\n            required: true,\r\n        },\r\n    }],\r\n    username: {\r\n        type: String,\r\n        required: true,\r\n    }\r\n}, {\r\n    timestamps: true\r\n})\r\n\r\nconst Comment = mongoose.model('Comment', commentSchema);\r\n\r\nexport default Comment;\r\n```\r\n\r\ncommentController.js\r\n\r\n```\r\nconst getComments = async (req, res) => {\r\n    const id = req.params;\r\n    try {\r\n        const post = await Post.findById( id )\r\n        if (!post) {\r\n            return res.status(404).json({ error: \"Post Not Found!\" })\r\n        }\r\n\r\n        const comments = await Comment.find({ postId: id }).sort({ createdAt: -1 })\r\n        res.status(200).json(comments);\r\n        \r\n    } catch (error) {\r\n        res.status(500).json({ error: error.message })\r\n    }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14181/comments",
    "author": "mohqaz",
    "comments": [
      {
        "user": "sean-daley",
        "created_at": "2023-12-15T18:06:56Z",
        "body": "If I had to take a guess, I'd say your problem is here:\r\n\r\n```\r\nconst id = req.params;\r\n```\r\n\r\nI'm guessing that's undefined? I don't know what you're using for req/res ... express? But, regardless, you might want to make sure that's getting set correctly before getting passed to the mongoose findById call."
      },
      {
        "user": "mohqaz",
        "created_at": "2023-12-15T18:19:30Z",
        "body": "Comments in the frontend are called inside useEffect. Don't forget that the Controller function is intended to fetch comments only. \r\nComments are called based on the post's ID that is included in the comment once it is created. Note the comment model"
      },
      {
        "user": "sean-daley",
        "created_at": "2023-12-15T19:22:55Z",
        "body": "> Comments in the frontend are called inside useEffect. Don't forget that the Controller function is intended to fetch comments only.\r\n> Comments are called based on the post's ID that is included in the comment once it is created. Note the comment model\r\n\r\nSorry not sure what you‚Äôre trying to say there. I can only go by what code you‚Äôve posted.\r\nThe error you are reporting is an undefined Id to model Post.\r\n\r\n‚ÄòAnd you have this code there\r\n```\r\n {\r\n    const id = req.params;\r\n    try {\r\n        const post = await Post.findById( id )\r\n```\r\n\r\nwhich is making a model Post call using an Id from your req.params setting.\r\nWhich is why I asked what that id is because if it‚Äôs undefined you will get the error you are seeing.\r\n\r\nif that‚Äôs not the call that‚Äôs erroring out then you might need to provide some more details."
      },
      {
        "user": "mohqaz",
        "created_at": "2023-12-16T06:40:58Z",
        "body": "> > Comments in the frontend are called inside useEffect. Don't forget that the Controller function is intended to fetch comments only.\r\n> > Comments are called based on the post's ID that is included in the comment once it is created. Note the comment model\r\n> \r\n> Sorry not sure what you‚Äôre trying to say there. I can only go by what code you‚Äôve posted. The error you are reporting is an undefined Id to model Post.\r\n> \r\n> ‚ÄòAnd you have this code there\r\n> \r\n> ```\r\n>  {\r\n>     const id = req.params;\r\n>     try {\r\n>         const post = await Post.findById( id )\r\n> ```\r\n> \r\n> which is making a model Post call using an Id from your req.params setting. Which is why I asked what that id is because if it‚Äôs undefined you will get the error you are seeing.\r\n> \r\n> if that‚Äôs not the call that‚Äôs erroring out then you might need to provide some more details.\r\n\r\nnow i get this error \r\n`\"Cast to ObjectId failed for value \\\"{ postId: '657af1874c383d956cbed7f2' }\\\" (type Object) at path \\\"_id\\\" for model \\\"Post\\\"\"`\r\n\r\nnote the id of post in the error it's not undefined"
      },
      {
        "user": "mohqaz",
        "created_at": "2023-12-17T07:31:02Z",
        "body": "i solve it, i made the comments inside post schema and i gave it it's own id \r\nthank you @sean-daley"
      }
    ]
  },
  {
    "number": 14165,
    "title": "Mongoose Connection hangs indefinitely after script is done unless `connection.close()` is called",
    "created_at": "2023-12-08T05:47:50Z",
    "closed_at": "2023-12-18T03:11:12Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14165",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n8.0.3\r\n\r\n### Node.js version\r\n\r\n20.10.0\r\n\r\n### MongoDB version\r\n\r\n6.0\r\n\r\n### Operating system\r\n\r\nmacOS\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n13.1\r\n\r\n### Issue\r\n\r\nI have a nodejs script running where I connect to MongoDB Atlas using Mongoose, read/write some data and then the script exits. The issue I am facing is that if I don't explicitly close the connection via `mongoose.connection.close()`, the script will run indefinitely until I force close it using CTRL + C. \r\n\r\nIs it advisable to explicitly run `connection.close()` to gracefully close the mongoose connection or is there something I am doing wrong?\r\n\r\nHere's how my code looks like,\r\n\r\ndb.ts\r\n\r\n```ts\r\n\r\nimport mongoose, { Schema } from 'mongoose';\r\nimport * as dotenv from 'dotenv';\r\n\r\ndotenv.config();\r\n\r\nexport const connectToDB = async () => {\r\n    const uri = process.env.MONGO_URI;\r\n    if (!uri) {\r\n        logger.error(\r\n            'Mongo URL not found in env. Please add the url in the env file. Exiting....'\r\n        );\r\n        process.exit(1);\r\n    }\r\n    try{\r\n        await mongoose.connect(uri, {\r\n            retryWrites:true,\r\n            writeConcern:{\r\n                w:'majority'\r\n            },\r\n            user:process.env.MONGO_USR,\r\n            pass:process.env.MONGO_PWD,\r\n            dbName:process.env.MONGO_DB_NAME\r\n        });\r\n        logger.info('connected to DB')\r\n    }catch(error:any){\r\n        logger.error(error, \"Error connecting to MongoDB, shutting down.....\")\r\n        process.exit(1)\r\n    }\r\n   \r\n};\r\n\r\n```\r\nand my main.ts\r\n\r\n```ts\r\n\r\nimport {connectToDB) from './db'\r\n\r\nawait connectToDB()\r\n\r\n//code execution\r\n\r\nconsole.log('script completed`) // it'll run indefinitely after logging it unless I stop it via CTRL+C\r\n\r\nawait mongoose.connection.close() //will stop the script as expected\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14165/comments",
    "author": "Altair2169",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-12-18T03:11:12Z",
        "body": "Yes, you should call `close()` to explicitly disconnect from the database. Mongoose will keep the connection to MongoDB open until you explicitly close it."
      }
    ]
  },
  {
    "number": 14121,
    "title": "Use Vector in Mongoose schema ",
    "created_at": "2023-11-24T20:14:49Z",
    "closed_at": "2023-11-25T18:07:53Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14121",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.7.3\n\n### Node.js version\n\n16.4\n\n### MongoDB version\n\n5\n\n### Operating system\n\nLinux\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n20.04\n\n### Issue\n\nI am trying to find appropriate docs on how to use vectorsearch with Mongoose and mongodb atlas.\r\n\r\nHow do you define the vector field in the schema?\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14121/comments",
    "author": "PeterPilley",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-11-25T18:07:53Z",
        "body": "`myVector: { type: [Number] }`, can add optional validation to check the array length like `myVector: { type: [Number], validate: v => v.length === 1536 }`."
      }
    ]
  },
  {
    "number": 14106,
    "title": "Handling connection/model exceptions in a better way",
    "created_at": "2023-11-21T22:48:30Z",
    "closed_at": "2023-12-16T00:18:07Z",
    "labels": [
      "help",
      "help wanted",
      "needs clarification",
      "Stale"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14106",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n7.6.3\n\n### Node.js version\n\n18.16.0\n\n### MongoDB version\n\n5.8.0\n\n### Operating system\n\nNone\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n14.1.0\n\n### Issue\n\nI have an architecture handling multiple connections with mongoose. In case, assuming `db1` and `db2` as their names.\r\n\r\nIn some specific flows, if the `db2` break down (by a `ECONNREFUSED` or anything like that), it shouldn't break the entire flow when throwing the exception.\r\n\r\nThe easier way to handle it is using the `try/catch` solution, but _\"in loco\"_, every place that handle the second database should have a `try/catch` wrapper handling it.\r\n\r\nI would like to know if there's a clever way/strategy to handle it using mongoose? Any suggestion? Idea? Something using the `connection.on` listener or something like that?",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14106/comments",
    "author": "noghartt",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-11-25T17:15:14Z",
        "body": "I'm confused by what you mean by `db2` break down; can you provide some sample code that demonstrates what you're seeing?"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2023-12-10T00:20:14Z",
        "body": "This issue is stale because it has been open 14 days with no activity. Remove stale label or comment or this will be closed in 5 days"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2023-12-16T00:18:06Z",
        "body": "This issue was closed because it has been inactive for 19 days and has been marked as stale."
      }
    ]
  },
  {
    "number": 14091,
    "title": "Error ",
    "created_at": "2023-11-17T23:37:24Z",
    "closed_at": "2023-11-21T19:08:32Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14091",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n1.0.1\n\n### Node.js version\n\n18.16.0\n\n### MongoDB version\n\n6.3.0\n\n### Operating system\n\nWindows\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n10.0.22631.2715\n\n### Issue\n\nBuenas noches tengo un error y no he podido encontrar la solucion alguien q me pueda ayudar, este es el error q me aparece:\r\n\r\n(node:4268) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version\r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\n(node:4268) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version  ",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14091/comments",
    "author": "Ronald-Lozano",
    "comments": [
      {
        "user": "Uzlopak",
        "created_at": "2023-11-17T23:40:14Z",
        "body": "its a warning not an error"
      },
      {
        "user": "Ronald-Lozano",
        "created_at": "2023-11-18T12:11:34Z",
        "body": "> es una advertencia no un error\r\n\r\npero como lo puedo solucionar"
      },
      {
        "user": "vkarpov15",
        "created_at": "2023-11-21T19:08:32Z",
        "body": "Busca por `useNewUrlParser` y `useUnifiedTopology` en su proyecto y quitarlo\r\n\r\n```javascript\r\nmongoose.connect(uri, {\r\n  useNewUrlParser: true // <-- delete this line\r\n});\r\n```"
      }
    ]
  },
  {
    "number": 14089,
    "title": "Lazy connection handling while registering new models",
    "created_at": "2023-11-17T04:34:17Z",
    "closed_at": "2023-11-25T16:56:39Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14089",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n7.6.3\n\n### Node.js version\n\n18.16.0\n\n### MongoDB version\n\n5.8.0\n\n### Operating system\n\nmacOS\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n14.1.0\n\n### Issue\n\nI have a monorepo where I handle 2+ connections accordingly to the entrypoints.\r\n\r\nIn case, I have a specific flow where a model registered via `mongoose.model` runs before the connection to the DB.\r\n\r\n```ts\r\n// packages/A/Model.ts\r\n// ...\r\nconst model = mongoose.model('Model', ModelSchema);\r\n```\r\n\r\nIf a try to do something like: `connection.model('Model', ModelSchema)`, it throws an error because `connection` is undefined until connnect.\r\n\r\n```ts\r\n// packages/A/Model.ts\r\n// ...\r\nimport { getConnection } from '@packages/mongodb';\r\n\r\nconst connection = getConnection('OtherDatabase'); // get connection accordingly to the `mongoose.connections`\r\n\r\nconst model = connection.model('Model', ModelSchema);\r\n```\r\n\r\nI would like to know if there's a way/strategy to handle this kind of _\"model registry\"_ in a multi DB architecture allowing this lazy code evaluation.",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14089/comments",
    "author": "noghartt",
    "comments": [
      {
        "user": "sibelius",
        "created_at": "2023-11-17T12:21:21Z",
        "body": "can we be able to define the collection name and the database name in the SchemaModel ?\r\n\r\nSchema.collectionName = 'ok':\r\nSchema.databaseName = 'another-database';"
      },
      {
        "user": "vkarpov15",
        "created_at": "2023-11-21T16:16:39Z",
        "body": "I typically end up with a function that I use to create a connection and attach models. That's usually the way to go when you have multiple connections. Something like the following:\r\n\r\n```javascript\r\nconst connectionString = process.env.MONGODB_CONNECTION_STRING;\r\nconsole.log('Connecting to', connectionString);\r\n\r\nmodule.exports = function models(connection) {\r\n  connection = connection ?? mongoose.createConnection(connectionString, {\r\n    serverSelectionTimeoutMS: 5000\r\n  });\r\n\r\n  initTask(null, connection);\r\n\r\n  for (const [schemaName, schema] of Object.entries(schemas)) {\r\n    // \"accessTokenSchema\" -> \"AccessToken\"\r\n    const modelName = schemaName.charAt(0).toUpperCase() +\r\n      schemaName.replace(/Schema$/, '').slice(1);\r\n    connection.model(modelName, schema, modelName);\r\n  }\r\n\r\n  return connection;\r\n};\r\n```\r\n\r\nDoes that help?"
      },
      {
        "user": "sibelius",
        "created_at": "2023-11-21T16:28:19Z",
        "body": "if have something like this\r\n\r\n```jsx\r\nexport const getConnection = (connectionName: string) => {\r\n  const connection = mongoose.connections.find(\r\n    (c) => c.name === connectionName,\r\n  );\r\n\r\n  if (!connection) {\r\n    return mongoose;\r\n  }\r\n\r\n  return connection;\r\n};\r\n\r\nexport const getModelBySchema = (schema: SchemaMultiDB) => {\r\n  const connection = getConnection(schema.databaseName);\r\n\r\n  return connection.model(schema.name, schema);\r\n};\r\n```\r\n\r\nthe usage is\r\n\r\n```jsx\r\nconst Event = getModelBySchema(EventSchema);\r\n```\r\n\r\nWe would like to keep using just `EventModel` instead of having a lazy function to get the model from a custom connection"
      },
      {
        "user": "vkarpov15",
        "created_at": "2023-11-25T16:56:39Z",
        "body": "@sibelius that patterns works as well. It's not my favorite pattern, but it's the only real option if you have multiple connections and want to be able to import models via `require()` / `import`."
      }
    ]
  },
  {
    "number": 14085,
    "title": "How to make inferred type of Model.constructor and Model.findOne be Document<string> not Document<unknown>",
    "created_at": "2023-11-16T11:21:32Z",
    "closed_at": "2023-12-04T17:25:36Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14085",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n8.0.1\r\n\r\n### Node.js version\r\n\r\n18.17.1\r\n\r\n### MongoDB version\r\n\r\n4.4.25\r\n\r\n### Operating system\r\n\r\nLinux\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n22.04\r\n\r\n### Issue\r\n\r\nI have following code. How do I make `new UserModel(...)`'s return type be `Document<string,...>`? Please see commented code. Thanks in advance!\r\n\r\n```typescript\r\nimport { Schema, model, connect, Model, HydratedDocument, Document } from 'mongoose';\r\nimport { nanoid } from 'nanoid';\r\n\r\ninterface IUser {\r\n    _id?: string;\r\n    name: string;\r\n    email: string;\r\n    avatar?: string;\r\n}\r\n\r\ntype UserDocument = Document<string, {}, IUser> & IUser & Required<{ _id: string }>;\r\n\r\ninterface UserModel extends Model<IUser> {\r\n    createTestUser(): Promise<UserDocument>;\r\n}\r\n\r\nconst userSchema = new Schema<IUser & Required<{ _id: string }>, UserModel>({\r\n    _id: { type: String, default: () => nanoid() },\r\n    name: { type: String, required: true },\r\n    email: { type: String, required: true },\r\n    avatar: String\r\n});\r\n\r\n\r\nclass UserStatics {\r\n    public static async createTestUser(): Promise<UserDocument> {\r\n        // How do I make the type of PK into `string`, instead of `unknown`\r\n        const someUser: Document<unknown, {}, IUser> & IUser & Required<{\r\n            _id: string;\r\n        }> = await UserModel.findOne();\r\n\r\n        // How do I make the type of PK into `string`, instead of `unknown`\r\n        const user: Document<unknown, {}, IUser> & IUser & Required<{\r\n            _id: string;\r\n        }> = new UserModel({\r\n            name: \"John Doe\",\r\n            email: \"johndoe@example.com\",\r\n            avatar: \"asdfasdf\"\r\n        });\r\n        await user.save();\r\n        return user;\r\n    }\r\n}\r\n\r\nuserSchema.loadClass(UserStatics);\r\n```",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14085/comments",
    "author": "dulguun0225",
    "comments": [
      {
        "user": "dulguun0225",
        "created_at": "2023-11-17T00:12:23Z",
        "body": "I set the Model's THydratedDocument generic type to `Document<string, {}, IUser> & IUser & Required<{ _id: string }>;`. It seems to be doing what I want. Is this a correct approach?\r\n\r\n```typescript\r\nimport { Schema, model, connect, Model, HydratedDocument, Document, Types } from 'mongoose';\r\nimport { nanoid } from 'nanoid';\r\n\r\ninterface IUser {\r\n    _id: string;\r\n    name: string;\r\n    email: string;\r\n    avatar?: string;\r\n}\r\n\r\ntype UserDocument = Document<string, {}, IUser> & IUser;\r\n\r\ninterface UserModel extends Model<IUser, {}, {}, {}, UserDocument> {\r\n    createTestUser(): Promise<UserDocument>;\r\n}\r\n\r\nconst userSchema = new Schema<IUser, UserModel>({\r\n    _id: { type: String, default: () => nanoid(), required: true },\r\n    name: { type: String, required: true },\r\n    email: { type: String, required: true },\r\n    avatar: String\r\n});\r\n\r\nclass UserStatics {\r\n    public static async createTestUser(): Promise<UserDocument> {\r\n        // Inferred type is `UserDocument | null` which is what I want\r\n        const found = await UserModel.findOne();\r\n\r\n        // Inferred type is `UserDocument` which is what I want\r\n        const user = new UserModel({\r\n            name: \"John Doe\",\r\n            email: \"johndoe@example.com\",\r\n            avatar: \"asdfasdf\"\r\n        });\r\n        await user.save();\r\n        return user;\r\n    }\r\n}\r\n\r\nuserSchema.loadClass(UserStatics);\r\n```"
      },
      {
        "user": "vkarpov15",
        "created_at": "2023-12-04T17:25:36Z",
        "body": "I'd recommend doing `type UserDocument = HydratedDocument<IUser>;` instead of `type UserDocument = Document<string, {}, IUser> & IUser;`, `HydratedDocument<>` is our recommended approach for getting the hydrated document type from a raw document type because it handles query helpers and other details. But otherwise your code works :+1:"
      }
    ]
  },
  {
    "number": 14061,
    "title": "Trouble with TypeScript Type Inference on Mongoose Model Creation",
    "created_at": "2023-11-08T17:03:54Z",
    "closed_at": "2023-11-14T03:06:46Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14061",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n8.0.0\r\n\r\n### Node.js version\r\n\r\n20.9.0\r\n\r\n### MongoDB version\r\n\r\n7.0.0\r\n\r\n### Operating system\r\n\r\nWindows\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n10\r\n\r\n### Issue\r\n\r\n**Description:**\r\nHello Mongoose team,\r\n\r\nI'm encountering an issue with TypeScript where the type inference is not working as expected when creating a Mongoose model with a defined interface. Despite following the TypeScript integration documentation, TypeScript is unable to infer the type from the usage of the model function. The error produced is _\"Type argument cannot be inferred from usage\"_.\r\n\r\n**Environment:**\r\n\r\nNode.js version: 20.9.0\r\nMongoose version: 8.0.0\r\nTypeScript version: 5.2.2\r\n\r\n**Code to Reproduce:**\r\n\r\n> models/Subscriber.ts\r\n\r\n```\r\nimport { Document, model, Schema } from \"mongoose\";\r\n\r\nexport interface ISubscriber extends Document {\r\n  credentialsProvider: \"Local\" | \"Google\" | \"Facebook\";\r\n  email: string;\r\n  password?: string;\r\n\r\n  firstName: string;\r\n  lastName: string;\r\n  phoneNumber: string;\r\n  gender: \"Male\" | \"Female\" | \"Other\";\r\n\r\n  birthday?: Date;\r\n  picture?: string;\r\n}\r\n\r\nconst subscriberSchema = new Schema<ISubscriber>(\r\n  {\r\n    credentialsProvider: {\r\n      type: String,\r\n      enum: [\"Local\", \"Google\", \"Facebook\"],\r\n      required: true,\r\n    },\r\n    email: { type: String, required: true, unique: true },\r\n    password: { type: String, required: false },\r\n\r\n    firstName: { type: String, required: true },\r\n    lastName: { type: String, required: true },\r\n    phoneNumber: { type: String, required: true },\r\n    gender: { type: String, enum: [\"Male\", \"Female\", \"Other\"], required: true },\r\n\r\n    birthday: { type: Date, required: false },\r\n    picture: { type: String, required: false },\r\n  },\r\n  { timestamps: true }\r\n);\r\n\r\nconst SubscriberModel = model<ISubscriber>(\"Subscribers\", subscriberSchema);\r\n\r\nexport default SubscriberModel;\r\n```\r\n\r\n> tsconfig.json\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es6\",\r\n    \"module\": \"commonjs\",\r\n    \"moduleResolution\": \"Node\",\r\n    \"noImplicitAny\": false,\r\n    \"sourceMap\": true,\r\n    \"outDir\": \"./dist\",\r\n    \"strict\": true,\r\n    \"esModuleInterop\": true,\r\n    \"skipLibCheck\": true,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"strictNullChecks\": false\r\n  },\r\n  \"include\": [\"src/**/*.ts\"],\r\n  \"exclude\": [\"node_modules\"]\r\n}\r\n```\r\n\r\nWhen hovering over SubscriberModel, my IDE indicates that the model's type is inferred as ` Model<unknown, unknown, unknown, unknown, Document<unknown, unknown, unknown> & MergeType<unknown extends {_id?: infer U} ? IfAny<U, {_id: Types.ObjectId}, Required<{_id: U}>> : {_id: Types.ObjectId}, unknown>, ISubscriber>`, and when attempting to use `SubscriberModel.create()`, TypeScript does not recognize the type returned by `SubscriberModel`, despite having the `ISubscriber` interface defined and used in `model<ISubscriber>`.\r\n\r\nThank you for your time and assistance.",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14061/comments",
    "author": "Baghdad-Hamdoud",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-11-09T19:06:02Z",
        "body": "The `Subscriber.ts` file you provided compiles without error. Is there a TypeScript issue you're seeing? Because it looks like \"Type argument cannot be inferred from usage\" is a webstorm error, and we currently don't debug IDE type preview issues."
      },
      {
        "user": "Baghdad-Hamdoud",
        "created_at": "2023-11-09T20:50:07Z",
        "body": "Indeed, I'm using WebStorm and `Subscriber.ts` compiles normally. So I conclude that the error displayed and the fact that there is no autocompletion for my SubscriberModel when I import it elsewhere is due to WebStorm."
      },
      {
        "user": "vkarpov15",
        "created_at": "2023-11-14T03:06:44Z",
        "body": "In that case we're going to close this issue. Debugging IDE autocomplete is very tricky and not something we're likely to figure out in a reasonable amount of time."
      }
    ]
  },
  {
    "number": 13997,
    "title": "I can`t connect to database",
    "created_at": "2023-10-22T14:43:05Z",
    "closed_at": "2023-10-22T17:15:08Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13997",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n2.0.2\n\n### Node.js version\n\n18.18.2\n\n### MongoDB version\n\n1.40.4\n\n### Operating system\n\nWindows\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n11\n\n### Issue\n\nconst err = new MongooseError(message);\r\n                      ^\r\n\r\nMongooseError: Operation `global-configs.findOne()` buffering timed out after 10000ms\r\n    at Timeout.<anonymous> (C:\\Users\\–ò–≤–∞–Ω\\DAN IT\\Vintage_Vine\\node_modules\\mongoose\\lib\\drivers\\node-mongodb-native\\collection.js:198:23)\r\n    at listOnTimeout (node:internal/timers:569:17)\r\n    at process.processTimers (node:internal/timers:512:7)",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13997/comments",
    "author": "DidenkoIvan",
    "comments": [
      {
        "user": "Uzlopak",
        "created_at": "2023-10-22T17:15:09Z",
        "body": "I dont think that we support that ancient versions of mongo and mongoose. Please upgrade mongoose."
      }
    ]
  },
  {
    "number": 13896,
    "title": "- error TypeError: (0 , _lib_mongoose__WEBPACK_IMPORTED_MODULE_1__.mongooseConnect) is not a function",
    "created_at": "2023-09-26T09:32:59Z",
    "closed_at": "2023-10-01T16:03:39Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13896",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n7.5.2\r\n\r\n### Node.js version\r\n\r\n19\r\n\r\n### MongoDB version\r\n\r\n6.0.0\r\n\r\n### Operating system\r\n\r\nWindows\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n10\r\n\r\n### Issue\r\n\r\nI have this error trying to connect my mongoose\r\n- error TypeError: (0 , _lib_mongoose__WEBPACK_IMPORTED_MODULE_1__.mongooseConnect) is not a function\r\nmy code is the following\r\n\r\napp/api/products/route.ts\r\n\r\n```\r\nimport { Product } from \"@/models/Product\";\r\nimport {mongooseConnect} from \"@/lib/mongoose\";\r\nimport { NextResponse } from \"next/server\";\r\nimport clientPromise from \"@/lib/mongodb\";\r\nimport mongoose from \"mongoose\";\r\n\r\n// Remove the default keyword and use a named export\r\nexport  async function POST(req: Request) {\r\n  \r\n    const { method } = req;\r\n    await mongooseConnect();\r\n  if(method === 'POST'){  \r\n  const {title,description,price}= req.body;\r\n  const productDoc = await Product.create({\r\n    title,description,price,\r\n   })\r\n\r\n    return NextResponse.json(productDoc);\r\n  }\r\n}\r\n```\r\n\r\nlib/mongoose.ts\r\n\r\n```\r\nimport mongoose from \"mongoose\";\r\n\r\nexport function mongooseConnect({children}){\r\n    if(mongoose.connection.readyState===1){\r\n        return mongoose.connection.asPromise();\r\n    } else {\r\n        const uri=process.env.MONGODB_URI;\r\n        return mongoose.connect(uri);\r\n    }\r\n}\r\n```\r\n\r\nmodels/Product.ts\r\n\r\n```\r\nimport {model,models,Schema} from \"mongoose\";\r\n\r\nconst ProductSchema= new Schema({\r\ntitle:{type:String, require:true},\r\ndescription: {type:String},\r\nprice: {type:Number, require:true},\r\n},{\r\n    timestamps: true,\r\n});\r\n\r\nexport const Product = models.Product || model('Product', ProductSchema);\r\n```\r\n\r\n   \r\n  ",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13896/comments",
    "author": "aldofemat",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-10-01T16:03:39Z",
        "body": "Hard to tell without a more complete code sample, but this isn't a Mongoose issue because Mongoose doesn't export a `mongooseConnect()` function. You should try printing out the value of `mongooseConnect` using `console.log(mongooseConnect)` to see what value you're getting."
      },
      {
        "user": "Shreyansh-kankane",
        "created_at": "2024-03-05T20:42:13Z",
        "body": "How do you solve the problem, I got the same error, I am also doing the same, Please answer \r\n@aldofemat \r\n"
      }
    ]
  },
  {
    "number": 13860,
    "title": "How to use middleware for $lookup",
    "created_at": "2023-09-15T13:21:43Z",
    "closed_at": "2023-09-26T14:33:18Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13860",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n6.9.1\r\n\r\n### Node.js version\r\n\r\n16.17.1\r\n\r\n### MongoDB version\r\n\r\n7.0\r\n\r\n### Operating system\r\n\r\nmacOS\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n13.4 (22F66)\r\n\r\n### Issue\r\n\r\nI am doing:\r\n\r\n```\r\nawait this.orderModel.aggregate([\r\n    {\r\n        $lookup: {\r\n            from: 'additionalverses',\r\n            localField: '_id',\r\n            foreignField: 'order',\r\n            as: 'additionalVerses',\r\n        }\r\n    }\r\n])\r\n```\r\n\r\nI want to write `additionalverses.pre()` middleware to omit {status: draft} additional verses.\r\nIs it possible?",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13860/comments",
    "author": "ZeeshanAhmadKhalil",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-09-26T14:33:18Z",
        "body": "Not possible unfortunately. You would need to add an additional `$match` stage to your `aggregate()` to filter out `status: 'draft'` verses"
      }
    ]
  },
  {
    "number": 13833,
    "title": "Best approach to use Mongoose with SocketIO per user connection",
    "created_at": "2023-09-06T19:07:58Z",
    "closed_at": "2023-09-18T15:30:38Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13833",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.65\n\n### Node.js version\n\n18.17.1\n\n### MongoDB version\n\n6.0.5\n\n### Operating system\n\nLinux\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\nUbuntu 20.04\n\n### Issue\n\nI have an API created with Socket.IO 4.\r\n\r\nThis API every time it starts it makes a connection to MongoDB using Mongoose. This connection remains open until the script exits.\r\n\r\nThis use of Mongoose ‚Äã‚Äãcreates the Models and Schemas on every startup.\r\n\r\nEvery time a user connects to the Socket.IO server, it uses this open connection to MongoDB to save that user's data into MongoDB. When there is a disconnection, this data is deleted, using the connection opened there at the beginning of the script.\r\n\r\nIs my approach incorrect or correct?\r\n\r\nMy fear is that a hundred users connect at the same time and the execution of the script takes time to execute each save/delete one at a time.\r\n\r\nOr should I for each request open a connection to MongoDB, do what needs to be done and close the connection (another fear: overloading with MongoDB)?\r\n\r\n** I already noticed that even making a connection, there are always 5 connections in MongoDB that were established with the origin in the IP of the Socket.IO server.\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13833/comments",
    "author": "El-Tommy",
    "comments": [
      {
        "user": "CCR-bhurtel",
        "created_at": "2023-09-09T08:13:53Z",
        "body": "Think about your application's structure and the average runtime of database operations. Reusing a single connection may be beneficial if most activities are fast and don't block the event loop for too long. Consider per-request connections if you expect lengthy procedures.\r\n\r\nThe fact that there are consistently 5 connections in MongoDB created with the Socket.IO server's origin IP suggests that this is a result of the way Mongoose handles connection pools by default.\r\n\r\nA connection pool to MongoDB with a default pool size of 5 connections is maintained by Mongoose by default. To effectively handle incoming database requests, these connections are made and maintained. In a sensible setting, the connection pool size of 5 balances the need to handle concurrent requests without taxing the MongoDB server.\r\n\r\nYou can change the connection pool size like this:-\r\n```\r\nmongoose.connect('mongodb://localhost:27017/mydb', {\r\n  poolSize: 10 // Adjust the pool size as needed\r\n});\r\n```\r\n\r\n"
      },
      {
        "user": "vkarpov15",
        "created_at": "2023-09-18T15:30:38Z",
        "body": "\"Or should I for each request open a connection to MongoDB, do what needs to be done and close the connection (another fear: overloading with MongoDB)?\" <-- there's virtually no case where you should open a new connection for every request. Opening a connection when your application starts and keeping that connection open is the recommended way to use Mongoose for most applications, and nothing in your app's description indicates that pattern won't work for your use case."
      }
    ]
  },
  {
    "number": 13832,
    "title": "In a custom type, how to trigger the castForQuery querying a nested property of the type?",
    "created_at": "2023-09-06T13:56:23Z",
    "closed_at": "2023-10-17T18:08:51Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13832",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n7.5.0\n\n### Node.js version\n\n18.2.0\n\n### MongoDB version\n\n6.0.9\n\n### Operating system\n\nLinux\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\nArch\n\n### Issue\n\nHi!\r\n\r\nWe are currently writing a custom Mixed type for mongoose and found the next issue with the triggering of the `castForQuery` function of the class.\r\n\r\nAs a mixed type, it may have nested properties that we should be able to query (and to do that, we first need to cast the query values). \r\n\r\nThe problem is the following: if we try to query the collection with a nested property like this the custom `castForQuery` is not triggering. \r\n`model.find({'customs.a': '123'})`\r\n\r\nOn the other hand, querying it like this does indeed trigger it.\r\n`model.find({customs: {a: '123'}})`\r\n\r\nIs there anything we can do to trigger it in the first case? We can modify how our queries are generated for now, but a solution for the first case would speed up everything.\r\n\r\nThe following code is a really simple repro for out issue:\r\n```\r\nconst mongoose = require('mongoose');\r\n\r\nclass Customs extends mongoose.SchemaType {\r\n  constructor(key, options) {\r\n    super(key, options, 'Customs');\r\n  }\r\n\r\n  cast(val) {\r\n    console.log('Casting');\r\n    return val;\r\n  }\r\n\r\n  castForQuery($conditional, value, context) {\r\n    console.log('Casting query');\r\n    return value;\r\n  }\r\n}\r\nmongoose.Schema.Types.Customs = Customs;\r\n\r\nconst schema = new mongoose.Schema({\r\n  customs: Customs,\r\n});\r\n\r\nconst model = mongoose.model('schema', schema);\r\n\r\nmongoose.connect('mongodb://127.0.0.1:27017', { useNewUrlParser: true, useUnifiedTopology: true })\r\n  .then(async () => {\r\n    console.log('Does not trigger');\r\n    await model.find({'customs.a': '123'});\r\n    console.log('Does trigger');\r\n    await model.find({customs: {a: '123'}});\r\n  });\r\n```\r\n\r\nThanks for looking into it!",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13832/comments",
    "author": "Davian99",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-10-17T18:08:51Z",
        "body": "Unfortunately not, the way that Mongoose query casting works is that it first finds the schema type, so `custom.a` resolves to `undefined`, and then casts to match the schematype. There's unfortunately no way to plug into that schema type resolution process to say that subpaths of `custom` should have type `Custom`.\r\n\r\nYou should be aware that `model.find({'customs.a': '123'});` is a different query than `model.find({customs: {a: '123'}});`. The first finds documents where `customs.a` is equal to '123', regardless of other properties on `customs`. The latter finds documents where `customs` is deep equal to `{ a: '123' }`, so additional properties on `customs` will cause the query to not return any results."
      }
    ]
  },
  {
    "number": 13831,
    "title": "Error: *****Model validation failed: _id: Class constructor ObjectId cannot be invoked without 'new' after updating to 7.5.x",
    "created_at": "2023-09-06T12:06:15Z",
    "closed_at": "2023-09-18T14:33:35Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13831",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n7.5.0\r\n\r\n### Node.js version\r\n\r\n18.x\r\n\r\n### MongoDB version\r\n\r\n5.8\r\n\r\n### Operating system\r\n\r\nmacOS\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n_No response_\r\n\r\n### Issue\r\n\r\nI recently updated Mongoose to `7.5.0` and started to getting the error below. I could share more information.\r\n\r\n```\r\n{\r\n     _id: TypeError: Class constructor ObjectId cannot be invoked without 'new'\r\n         at ObjectId.SchemaType.getDefault (/app/node_modules/mongoose/lib/schematype.js:1143:31)\r\n         at applyDefaults (/app/node_modules/mongoose/lib/helpers/document/applyDefaults.js:99:24)\r\n         at model.Document (/app/node_modules/mongoose/lib/document.js:180:5)\r\n         at model.Model (/app/node_modules/mongoose/lib/model.js:123:12)\r\n         at new model (/app/node_modules/mongoose/lib/model.js:4702:15)\r\n         at /app/node_modules/mongoose/lib/model.js:2913:18\r\n         at Array.map (<anonymous>)\r\n         at Function.create (/app/node_modules/mongoose/lib/model.js:2902:30)\r\n         at ModelRepository.create\r\n(/app/dist/apps/channel/webpack:/src/modules/model/repositories/model.repository.ts:44:52)\r\n         at session.withTransaction.retryWrites (/app/dist/apps/channel/webpack:/src/modules/model/V1/model.service.ts:173:62)\r\n         at attemptTransaction (/app/node_modules/mongodb/src/sessions.ts:587:15)\r\n         at ClientSession.withTransaction (/app/node_modules/mongodb/src/sessions.ts:460:12)\r\n         at ModelServiceV1.create (/app/dist/apps/model/webpack:/src/modules/model/V1/model.service.ts:171:23)\r\n         at processTicksAndRejections (node:internal/process/task_queues:95:5)\r\n         at /app/node_modules/@nestjs/core/router/router-execution-context.js:46:28\r\n         at Object.<anonymous> (/app/node_modules/@nestjs/core/router/router-proxy.js:9:17)\r\n   }\r\n```\r\n\r\nHere is my function which I was using to create document.\r\n```\r\n async create(\r\n        data: Omit<Model, '_id' | 'created_at' | 'updated_at'>,\r\n        session: ClientSession,\r\n    ): Promise<Model> {\r\n        const mdl = new this.model(data);\r\n        return mdl.save({ session });\r\n    }\r\n```\r\nAlso I tried to use `create()` instead of `save()` and it failed too.\r\n\r\n```\r\n    async create(\r\n        data: Omit<Model, '_id' | 'created_at' | 'updated_at'>,\r\n        session: ClientSession,\r\n    ): Promise<Model> {\r\n        const result = await this.model.create([data], { session });\r\n        return result[0];\r\n    }\r\n```\r\n\r\nThanks a lot.",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13831/comments",
    "author": "nullRefErr",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-09-18T14:33:35Z",
        "body": "It looks like you have a schema that defines a default value for an ObjectId path like this:\r\n\r\n```javascript\r\nmyPath: {\r\n  type: 'ObjectId',\r\n  default: ObjectId\r\n}\r\n```\r\n\r\nUse the following instead:\r\n\r\n```javascript\r\nmyPath: {\r\n  type: 'ObjectId',\r\n  default: () => new ObjectId()\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 13824,
    "title": "Anomalous behavior of sort method on array of strings",
    "created_at": "2023-09-05T08:09:08Z",
    "closed_at": "2023-09-28T00:17:05Z",
    "labels": [
      "help",
      "help wanted",
      "needs clarification",
      "Stale"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13824",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n^7.3.x\n\n### Node.js version\n\n16.x\n\n### MongoDB version\n\n^5.6.x\n\n### Operating system\n\nNone\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nI'm trying to apply sort in a collection having one of the field - tags (type array of strings). \r\nI'm getting response result re-ordered in no particular pattern, the tags are not sorted lexicographically but the order of items is different from what I got without applying sort on any field. \r\nI read somewhere that result will get sorted based on first item of tags array, but that's not happening.\r\nPlease comment if someone knows about the issue or have similar questions.",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13824/comments",
    "author": "shrutipant7",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-09-08T14:30:29Z",
        "body": "Can you please provide a repro script or at least some code samples? Hard to infer what your code looks like from a prose description."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2023-09-23T00:16:09Z",
        "body": "This issue is stale because it has been open 14 days with no activity. Remove stale label or comment or this will be closed in 5 days"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2023-09-28T00:17:05Z",
        "body": "This issue was closed because it has been inactive for 19 days and has been marked as stale."
      }
    ]
  },
  {
    "number": 13790,
    "title": "QueryWithHelpers doesn't support both findOne and find",
    "created_at": "2023-08-28T16:51:22Z",
    "closed_at": "2023-10-07T00:16:40Z",
    "labels": [
      "help",
      "help wanted",
      "typescript",
      "Stale"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13790",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n7.x.x\n\n### Node.js version\n\n18.x\n\n### MongoDB version\n\n6.x\n\n### Operating system\n\nmacOS\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nWhen defining query helpers in typescript it isnt possible to support both findOne and find. \r\n\r\nreduced example\r\n```\r\nexport interface IPos {\r\n  company: string\r\n}\r\n\r\nexport type PosQueryHelpers = {\r\n  inCompany: (companyId: string) => QueryWithHelpers<\r\n    HydratedDocument<IPos, PosMethodHelpers>[],\r\n    HydratedDocument<IPos, PosMethodHelpers>,\r\n    PosQueryHelpers\r\n  >;\r\n};\r\n\r\nexport type PosMethodHelpers = {}\r\n```\r\n\r\nNow if i want to search \r\n\r\n```\r\n// doesn't work\r\nPos.findOne().inCompany('something') // typed to return an array\r\n\r\n// works\r\nPos.find().inCompany('something') // this works as expected\r\n\r\n// hack\r\nPos.findOne().inCompany('something').findOne() // work as expected\r\n```\r\n\r\nIs there a better way of typing such that the first argument of `QueryWithHelpers` returns array if find() and single doc if chaining from `findOne`",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13790/comments",
    "author": "roopakv",
    "comments": [
      {
        "user": "roopakv",
        "created_at": "2023-09-03T22:17:25Z",
        "body": "it seems like this is the same case with count().\r\n\r\n```\r\n// doesn't work\r\nPos.count().inCompany('something')\r\n\r\n// works\r\nPos.count().inCompany('works').count();\r\n```\r\n\r\nthe expectation of return is set of documents. \r\n\r\nWhile unsure how to solve it, basically the queryOp doesn't pass through."
      },
      {
        "user": "vkarpov15",
        "created_at": "2023-09-16T20:48:15Z",
        "body": "The best approach I've been able to find is to add a `ResultType` generic to `inCompany` as follows. Does the following work for you?\r\n\r\n```ts\r\nimport mongoose from 'mongoose';\r\n\r\ntype PosQueryHelpers = {\r\n  inCompany: <ResultType = mongoose.HydratedDocument<User>[]>(companyId: string) => mongoose.QueryWithHelpers<\r\n    ResultType,\r\n    mongoose.HydratedDocument<User>,\r\n    PosQueryHelpers,\r\n    User\r\n  >;\r\n};\r\n\r\ninterface User {\r\n  name: string;\r\n}\r\n\r\ntype UserModelType = mongoose.Model<User, PosQueryHelpers>;\r\n\r\nconst schema = new mongoose.Schema<User, UserModelType, {}, PosQueryHelpers>({ name: { type: String, required: true } });\r\nconst UserModel = mongoose.model<User, UserModelType, PosQueryHelpers>('User', schema);\r\n\r\nUserModel.findOne().inCompany<mongoose.HydratedDocument<User>>('something').then((res: User) => console.log(res));\r\n```"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2023-10-01T00:20:02Z",
        "body": "This issue is stale because it has been open 14 days with no activity. Remove stale label or comment or this will be closed in 5 days"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2023-10-07T00:16:40Z",
        "body": "This issue was closed because it has been inactive for 19 days and has been marked as stale."
      }
    ]
  },
  {
    "number": 13676,
    "title": "SchemaDefinitionProperty `type` not compatible when using SchemaType Getters",
    "created_at": "2023-07-31T09:17:06Z",
    "closed_at": "2023-08-10T21:08:44Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13676",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n7.x.x\r\n\r\n### Node.js version\r\n\r\n18.x\r\n\r\n### MongoDB version\r\n\r\n6.x\r\n\r\n### Operating system\r\n\r\nLinux\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n_No response_\r\n\r\n### Issue\r\n\r\nI'm trying to make all `ObjectId` fields into strings using `SchemaType.get()` introduced in v5.4. \r\n\r\nMy schemas are using the `EnforcedDocType` generic argument for type-safety, so I get the following error when setting `type` to `Schema.Types.ObjectId` in any of my schemas where the `ObjectId` field is changed to `string`.\r\n\r\n```\r\nType '{ type: typeof mongoose.Schema.Types.ObjectId; required: true; }' is not assignable to type 'SchemaDefinitionProperty<string> | undefined'.\r\n  Types of property 'type' are incompatible.\r\n    Type 'typeof ObjectId' is not assignable to type 'typeof Mixed | StringSchemaDefinition | undefined'.\r\n      Type 'typeof ObjectId' is not assignable to type 'typeof Mixed | StringConstructor | typeof String'.\r\n        Type 'typeof ObjectId' is not assignable to type 'typeof Mixed'.\r\n          Types of property 'schemaName' are incompatible.\r\n            Type '\"ObjectId\"' is not assignable to type '\"Mixed\"'.\r\n```\r\n\r\nHere's sample code:\r\n\r\n```\r\nimport mongoose from \"mongoose\";\r\n\r\nmongoose.Schema.ObjectId.get((v) => v.toString());\r\n\r\ninterface Test {\r\n    testId: string;\r\n}\r\n\r\nconst testSchema = new mongoose.Schema<Test>({\r\n\ttestId: {\r\n\t\ttype: mongoose.Schema.Types.ObjectId,\r\n\t\trequired: true,\r\n\t},\r\n});\r\n```\r\n\r\nI need `Test['testId']` to remain string so that the rest of my app code works as expected and I don't want to maintain two separate types, one for the schema and one for the app.\r\n\r\nI'm not completely clear on whether I have to set `type` for `testId` to `String` or `ObjectId`. I presume it's `ObjectId` because it's still that in the database and I need any strings passed to be changed to `ObjectId`s.\r\n\r\nAny help is much appreciated!",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13676/comments",
    "author": "kaulsh",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-08-10T21:08:44Z",
        "body": "The key point is that Mongoose's types internally store 2 distinct types for models and schemas: the raw document type, which represents what the raw document stored in MongoDB looks like; and the hydrated document type, which is what the result of `await MyModel.findOne()` looks like.\r\n\r\nYour code, as written, is setting the raw document type to have `testId: string`, which isn't what you want because the document will have `testId` as an ObjectId in MongoDB. You need to overwrite Mongoose's default hydrated document type as follows. This approach unfortunately requires a huge amount of generics because of how our automatic type inference works, but it gets the job done.\r\n\r\n```ts\r\nimport mongoose from \"mongoose\";\r\n\r\nmongoose.Schema.ObjectId.get((v) => v.toString());\r\n\r\ninterface Test {\r\n    testId: mongoose.Types.ObjectId;\r\n}\r\n\r\ntype TestHydratedType = mongoose.HydratedDocument<{ testId: string }>;\r\n\r\ntype TestModelType = mongoose.Model<\r\n  Test,\r\n  {},\r\n  {},\r\n  {},\r\n  TestHydratedType\r\n>;\r\n\r\nconst testSchema = new mongoose.Schema<\r\n  Test,\r\n  TestModelType,\r\n  {},\r\n  {},\r\n  {},\r\n  {},\r\n  mongoose.DefaultSchemaOptions,\r\n  Test,\r\n  TestHydratedType\r\n>({\r\n  testId: {\r\n    type: mongoose.Schema.Types.ObjectId,\r\n    required: true,\r\n  },\r\n});\r\n\r\nconst TestModel = mongoose.model<Test, TestModelType>('Test', testSchema);\r\n\r\nconst doc = new TestModel({ testId: 'foo' });\r\nconst str: string = doc.testId;\r\n\r\nasync function foo() {\r\n  // Keep in mind that, if you use `lean()`, getters don't run by default\r\n  const doc2 = await TestModel.findOne().orFail().lean();\r\n  const oid: mongoose.Types.ObjectId = doc2.testId;\r\n}\r\n```"
      },
      {
        "user": "kaulsh",
        "created_at": "2023-09-23T08:44:38Z",
        "body": "I don't know if this will help anyone but I made a little helper for the comment above:\r\n\r\n```\r\nimport {\r\n\tDefaultSchemaOptions,\r\n\tHydratedDocument,\r\n\tModel,\r\n\tSchema,\r\n\tSchemaDefinition,\r\n\tSchemaDefinitionType,\r\n\tSchemaOptions,\r\n\tmodel,\r\n} from 'mongoose';\r\n\r\nexport function TypedModel<\r\n\tEnforcedSchemaType extends Record<string, any> = any,\r\n\tHydratedDocumentType = EnforcedSchemaType,\r\n\tHydratedType = HydratedDocument<HydratedDocumentType>,\r\n\tModelType = Model<EnforcedSchemaType, {}, {}, {}, HydratedType>,\r\n>(\r\n\tcollectionName: string,\r\n\tschemaDefinition: SchemaDefinition<\r\n\t\tSchemaDefinitionType<EnforcedSchemaType>,\r\n\t\tEnforcedSchemaType\r\n\t>,\r\n\tschemaOptions: SchemaOptions<\r\n\t\tEnforcedSchemaType,\r\n\t\t{},\r\n\t\t{},\r\n\t\t{},\r\n\t\t{},\r\n\t\tHydratedType\r\n\t>,\r\n) {\r\n\tconst schema = new Schema<\r\n\t\tEnforcedSchemaType,\r\n\t\tModelType,\r\n\t\t{},\r\n\t\t{},\r\n\t\t{},\r\n\t\t{},\r\n\t\tDefaultSchemaOptions,\r\n\t\tEnforcedSchemaType,\r\n\t\tHydratedType\r\n\t>(schemaDefinition, schemaOptions);\r\n\treturn model<EnforcedSchemaType, ModelType>(collectionName, schema);\r\n}\r\n```\r\n\r\n```\r\nexport const Example = z.object({\r\n\t_id: ObjectId,\r\n\tuserId: ObjectId,\r\n});\r\nexport type Example = z.infer<typeof Example>;\r\n\r\nexport const ExampleHydrated = z.object({\r\n\t_id: z.string(),\r\n\tuserId: z.string(),\r\n\tcreatedAt: z.coerce.date(),\r\n});\r\nexport type ExampleHydrated = z.infer<typeof ExampleHydrated>;\r\n\r\nexport const ExampleModel = TypedModel<Example, ExampleHydrated>(\r\n\t'examples',\r\n\t{\r\n\t\tuserId: {\r\n\t\t\ttype: mongoose.Schema.Types.ObjectId,\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t},\r\n\t{ timestamps: { createdAt: true } },\r\n);\r\n```\r\n\r\nSecond generic argument to `TypedModel` is not required, it will default to the first. Which implies default behavior if you are not doing special hydration things."
      }
    ]
  },
  {
    "number": 13673,
    "title": "Typescript logic to avoid null as a result for model.findOne",
    "created_at": "2023-07-30T12:32:20Z",
    "closed_at": "2023-08-06T19:20:58Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13673",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n7.4.1\n\n### Node.js version\n\n18.16.1\n\n### MongoDB version\n\nLatest\n\n### Operating system\n\nNone\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nHi, I have been using Mongoose v5 for a long time and now I've started to migrate to Mongoose 7. I'm following the official guide which recommends to migrate to v6 first and then to 7, but I'm having some issues with Typescript that did not happen on v5.\r\n\r\nWhen I call `model.findOne()` now, it can return null, which makes sense, but this did not happen on Mongoose 5. This is fine for most cases when you are not sure if there'll be any document at all. However, it does not make sense if my program does different checks before calling the method (findOne) that Typescript says it can be null.\r\n\r\nFor instance, let's say I have two documents that are created at the same time but in different models with different schemas:\r\n```\r\n// Global\r\ninterface GlobalUser {\r\n\tid: string;\r\n\tname: string;\r\n\tavatar: string;\r\n}\r\n\r\nconst SchemaGlobalUser = new mongoose.Schema<GlobalUser>({\r\n\tid: String,\r\n\tname: String,\r\n\tavatar: String\r\n});\r\n\r\nconst ModelGlobalUser = mongoose.model<GlobalUser>('Global', SchemaGlobalUser);\r\n\r\n// Local (copying the interface and schema for a better explanation)\r\ninterface LocalUser {\r\n\tid: string;\r\n\tname: string;\r\n\tavatar: string;\r\n}\r\n\r\nconst SchemaLocalUser = new mongoose.Schema<LocalUser>({\r\n\tid: String,\r\n\tname: String,\r\n\tavatar: String\r\n});\r\n\r\nconst ModelLocalUser = mongoose.model<LocalUser>('Local', SchemaLocalUser);\r\n```\r\n\r\nAnd I create the documents at the same time (with different data):\r\n```\r\nconst newGlobalModel = new ModelGlobalUser({\r\n\tid: user.id,\r\n\tname: user.username,\r\n\tavatar: user.avatar\r\n});\r\n\r\nconst newLocalModel = new ModelLocalUser({\r\n\tid: user.id,\r\n\tname: user.localName,\r\n\tavatar: user.localAvatar\r\n});\r\n\r\nawait newGlobalModel.save();\r\nawait newLocalModel.save();\r\n```\r\n\r\nThen if I call `ModelGlobalUser.findOne({id: user.id})` and it exists, `ModelLocalUser.findOne({id: user.id})` cannot be null. Same thing should happen if I call them in different files or functions (for example, do something -> first findOne (global) -> call another function where the second findOne (local) is done). Nevertheless, Typescript always says it can be null.\r\n\r\nAs said previously, this did not happen on Mongoose 5, where Typescript never said it could be null. Is there any way to return to that old behaviour by setting an option when creating the model or something? I know it's pretty impossible for Typescript to recognise when it can or cannot be null, but maybe a way to tell Typescript that some models cannot return null documents could solve it (basically a way to ignore that findOne can return no documents). ",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13673/comments",
    "author": "k2helix",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-08-01T19:39:41Z",
        "body": "Try `await ModelLocalUser.findOne({id: user.id}).orFail()`, that will make the result non-nullable. Does that help?"
      },
      {
        "user": "k2helix",
        "created_at": "2023-08-02T11:33:19Z",
        "body": "> Try `await ModelLocalUser.findOne({id: user.id}).orFail()`, that will make the result non-nullable. Does that help?\r\n\r\nYup, it helps. Do you know if there is a way to use `orFail` for a whole model so I do not have to add it after every `findOne`? Because that way there's no much difference between doing that and adding a `!` after it."
      },
      {
        "user": "vkarpov15",
        "created_at": "2023-08-06T19:20:58Z",
        "body": "Not with TypeScript unfortunately. You could write middleware to add `orFail()` to every query operation, but that wouldn't help TypeScript infer that the result is non-nullable. You're better off just using `orFail()`."
      },
      {
        "user": "vermaslal",
        "created_at": "2024-08-12T17:23:12Z",
        "body": "I had same issue on @nestjs/mongoose . I found adding compiler option as below works\r\n\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"strictNullChecks\": true,\r\n    \"noImplicitAny\": true,\r\n    ...\r\n  }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 13590,
    "title": "500 Error when using populate method in mongoose",
    "created_at": "2023-07-09T08:05:52Z",
    "closed_at": "2023-07-10T16:16:25Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13590",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n7.3.1\r\n\r\n### Node.js version\r\n\r\n18.14.2\r\n\r\n### MongoDB version\r\n\r\n6.06\r\n\r\n### Operating system\r\n\r\nWindows\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n11\r\n\r\n### Issue\r\n\r\nI am trying to fetch data from MongoDB using mongoose and the populate method, but I get a 500 error. Here is the code that causes the error:\r\n```\r\nexport const productGetAllMiddleware = expressAsyncHandler(\r\n  async (req: Request, res: Response, next: NextFunction) => {\r\n    try {\r\n      req.query.page = req.query.page ? req.query.page : \"1\";\r\n      const products = await productModel\r\n        .find({})\r\n        .populate(\"inventory_id\")\r\n        .limit(10)\r\n        .skip(10 * (parseInt(req.query.page as string) - 1))\r\n        .exec();\r\n      res.status(200).json(products);\r\n    } catch (err) {\r\n      console.log(err);\r\n      return next(err);\r\n    }\r\n  }\r\n);\r\n```\r\nIf I remove the populate method, the code works fine. Here are the productModel and inventoryModel schemas that I am using:\r\n\r\n```\r\n// productModel\r\nimport mongoose, { InferSchemaType } from \"mongoose\";\r\nimport BaseSchema from \"./BaseSchema\";\r\n\r\nconst Schema = mongoose.Schema;\r\nconst Product = new Schema({\r\n  name: {\r\n    type: String,\r\n    required: [true, \"Name is required\"],\r\n    validate: {\r\n      validator: function (v: string) {\r\n        return v.trim().length > 0;\r\n      },\r\n      message: \"Name cannot be empty\",\r\n    },\r\n  },\r\n  desc: {\r\n    type: String,\r\n    required: [true, \"Description is required\"],\r\n    validate: {\r\n      validator: function (v: string) {\r\n        return v.trim().length > 10;\r\n      },\r\n      message: \"Description should be at least 10 characters long\",\r\n    },\r\n  },\r\n  SKU: {\r\n    type: String,\r\n    required: [true, \"SKU is required\"],\r\n    validate: {\r\n      validator: function (v: string) {\r\n        return /^[A-Z0-9]+$/.test(v);\r\n      },\r\n      message: \"SKU should only contain uppercase letters and numbers\",\r\n    },\r\n  },\r\n  price: {\r\n    type: Number,\r\n    required: [true, \"Price is required\"],\r\n    validate: {\r\n      validator: function (v: number) {\r\n        return v > 0;\r\n      },\r\n      message: \"Price should be a positive number\",\r\n    },\r\n  },\r\n  category_id: { type: Schema.Types.ObjectId, ref: \"ProductCategory\" },\r\n  discount_id: { type: Schema.Types.ObjectId, ref: \"ProductDiscount\" },\r\n  inventory_id: {\r\n    type: Schema.Types.ObjectId,\r\n    ref: \"ProductInventory\",\r\n    require: true,\r\n  },\r\n  image: [{ type: String, default: \"\" }],\r\n  amountPurchased: { type: Number, default: 0 },\r\n});\r\n\r\ntype ProductType = InferSchemaType<typeof Product>;\r\nProduct.add(BaseSchema);\r\nProduct.virtual(\"id\").get(function () {\r\n  return this._id.toHexString();\r\n});\r\n\r\nexport default mongoose.model<ProductType>(\"Product\", Product);\r\n\r\n// inventoryModel\r\nimport mongoose, { InferSchemaType } from \"mongoose\";\r\nimport BaseSchema from \"./BaseSchema\";\r\nconst Schema = mongoose.Schema;\r\nconst ProductInventory = new Schema({\r\n  quantity: {\r\n    type: Number,\r\n    required: [true, \"Quantity is required\"],\r\n    min: [0, \"Quantity cannot be negative\"],\r\n  },\r\n});\r\ntype ProductInventoryType = InferSchemaType<typeof ProductInventory>;\r\nProductInventory.add(BaseSchema);\r\nexport default mongoose.model<ProductInventoryType>(\r\n  \"ProductInventory\",\r\n  ProductInventory\r\n);\r\n\r\n// baseSchema\r\nimport mongoose from \"mongoose\";\r\nconst { Schema } = mongoose;\r\nconst BaseSchema = new Schema(\r\n  {\r\n    deleted_at: { type: Date, default: null },\r\n  },\r\n  {\r\n    timestamps: true,\r\n  }\r\n);\r\nexport default BaseSchema;\r\n```\r\nCan anyone help me figure out why the populate method is causing an error and how to fix it? Thanks in advance.\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13590/comments",
    "author": "loingtan",
    "comments": [
      {
        "user": "ayushkavad",
        "created_at": "2023-07-09T17:25:17Z",
        "body": "hey! @maikusobu \r\n\r\nThe issue in your code lies in the definition of the \"inventory_id\" field in your productModel schema. There's a typo in the schema definition where you wrote \"require\" instead of \"required\". Because of this typo, Mongoose doesn't recognize the \"inventory_id\" field as required and allows it to be empty, which leads to an error when trying to populate it.\r\n\r\nTo fix the issue, update the \"inventory_id\" field definition in the productModel schema as follows:\r\n\r\n```JavaScript\r\ninventory_id: {\r\n  type: Schema.Types.ObjectId,\r\n  ref: \"ProductInventory\",\r\n  required: true, \r\n},\r\n```\r\nAfter making this change, the \"inventory_id\" field will be recognized as required, and Mongoose will properly validate and populate it when fetching data from MongoDB."
      },
      {
        "user": "loingtan",
        "created_at": "2023-07-10T03:36:15Z",
        "body": "@ayushkavad  its working thank you"
      }
    ]
  },
  {
    "number": 13511,
    "title": "`match`ing on current date in a virtual populate",
    "created_at": "2023-06-15T03:51:13Z",
    "closed_at": "2023-06-15T19:29:03Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13511",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n6.7.4\r\n\r\n### Node.js version\r\n\r\n16.20\r\n\r\n### MongoDB version\r\n\r\n4.4\r\n\r\n### Operating system\r\n\r\nmacOS\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n_No response_\r\n\r\n### Issue\r\n\r\nHello,\r\n\r\nI'm trying to use a populate virtual that `match`es on a Date field, filtering for documents which have a value that is in the past. My first instinct was to do something like this:\r\n\r\n```ts\r\n// MySchema: { _id }\r\n// OtherSchema: { _id, myRef, activeAt }\r\n\r\nMySchema.virtual(\"myVirtual\", {\r\n    ref: \"OtherSchema\",\r\n    localField: \"_id\",\r\n    foreignField: \"myRef\",\r\n    justOne: true,\r\n    match: {\r\n        activeAt: {\r\n            $lte: new Date()\r\n        }\r\n    },\r\n    options: {\r\n        sort: { activeAt: -1 }\r\n    }\r\n});\r\n```\r\n\r\nBut `new Date()` just evaluates when the app first starts up, and so the match query is always just for the same date.\r\n\r\nIs there some way to query for the current timestamp when the populate runs?",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13511/comments",
    "author": "seankwalker",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-06-15T13:20:16Z",
        "body": "Try replacing `match: { activeAt: { $lte: new Date() } }` with `match: () =>({ activeAt: { $lte: new Date() } })`. Setting `match` to a function means Mongoose executes the `match` function every time you call `populate()`, so that should solve your problem."
      },
      {
        "user": "seankwalker",
        "created_at": "2023-06-15T19:29:03Z",
        "body": "@vkarpov15 oh that works perfectly, thank you so much! ü§¶ing at myself because I totally misunderstood the docs. Since it gives the example of matching based on the doc being populated, I thought that was the only way the function match worked.\r\n\r\nThanks again üôè "
      }
    ]
  },
  {
    "number": 13485,
    "title": "Mongoose serializable queries?",
    "created_at": "2023-06-06T13:43:30Z",
    "closed_at": "2023-06-29T00:21:59Z",
    "labels": [
      "help",
      "help wanted",
      "Stale"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13485",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n5.13\n\n### Node.js version\n\n14\n\n### MongoDB version\n\n4\n\n### Operating system\n\nNone\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nWe're working on converting our applications to temporal, and one of the steps we've considered is abstracting away Mongoose calls through Temporal, having them all made within a Temporal activity. This means the queries need to be serialized and sent off, and returned. \r\n\r\nI was wondering if there's any way to be able to convert a query, and then serialize it, and send it off to then get put back in to the Mongoose object for a model, and executed. I don't believe I see a way of being able to do this, but if there is, I'd love to know. Thanks!",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13485/comments",
    "author": "natdm",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-06-08T23:54:08Z",
        "body": "Mongoose doesn't have a way to serialize an arbitrary query instance, but you can always represent a query in a serializable way. For example, you can have a `find()` activity that takes in a model name and a POJO filter; that activity executes the query and returns the result as a POJO. That's the more idiomatic way to do things in Temporal anyway: anything that references a Mongoose model should be in an activity, not a workflow.\r\n\r\nOn a side note, I'd love to hear about your experience working with Mongoose and Temporal. I've done a lot of work with Temporal over the years, but never with Mongoose unfortunately."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2023-06-23T00:23:33Z",
        "body": "This issue is stale because it has been open 14 days with no activity. Remove stale label or comment or this will be closed in 5 days"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2023-06-29T00:21:58Z",
        "body": "This issue was closed because it has been inactive for 19 days and has been marked as stale."
      }
    ]
  },
  {
    "number": 13469,
    "title": "How to walk through a schema's paths, recursing on subdocuments and arrays?",
    "created_at": "2023-06-02T17:14:11Z",
    "closed_at": "2023-06-08T01:55:34Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13469",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.8.4\n\n### Node.js version\n\n18.12.0\n\n### MongoDB version\n\n6\n\n### Operating system\n\nNone\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nI want to write a test ensuring that if a schema path is an optional enum, then `null` is included as an allowed value. (That Mongoose doesn't automatically include `null` for optional enums arguably a design flaw, but that's another topic.)\r\n\r\nI've written this code which works for scalar fields:\r\n```typescript\r\nconst path = schema.paths;\r\nfor (const pathName of Object.keys(paths)) {\r\n        const schemaType = paths[pathName];\r\n        if (!schemaType.isRequired) {\r\n          const enums = schemaType.options.enum;\r\n          if (enums) {\r\n            assert.ok(\r\n              enums.some((x: any) => x === null),\r\n              `Schema path '${pathName}' from model '${model.modelName}' is an optional enum, but doesn't allow \\`null\\`. Either make the path required, or allow null.`\r\n            );\r\n          }\r\n        }\r\n```\r\n\r\nBut I can't figure out how to recursively handle subdocuments and arrays. I spent an hour trying to figure it out, but there are too many undocumented methods in the API. Any help would be much appreciated. Thanks!",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13469/comments",
    "author": "JavaScriptBach",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-06-08T01:55:34Z",
        "body": "@JavaScriptBach try the following:\r\n\r\n```javascript\r\n'use strict';\r\n\r\nconst { Schema } = require('mongoose');\r\n\r\nconst schema = new Schema({\r\n  name: String,\r\n  nested: new Schema({ foo: String }),\r\n  arr: [{ bar: String }]\r\n});\r\n\r\niteratePaths(schema);\r\n\r\nfunction iteratePaths(schema, prefix = '') {\r\n  if (prefix) {\r\n    prefix = prefix + '.';\r\n  }\r\n  schema.eachPath((path, schematype) => {\r\n    console.log(prefix + path);\r\n    if (schematype.schema) {\r\n      iteratePaths(schematype.schema, prefix + path);\r\n    }\r\n  });\r\n}\r\n```\r\n\r\nYou are right that `null` not being a valid value for optional enums is strange, this is the 3rd time I've seen #3044 has popped up in the last year or so, I think it is time we re-open that."
      }
    ]
  },
  {
    "number": 13454,
    "title": "IAM Role Session Token Authentication",
    "created_at": "2023-06-01T17:46:32Z",
    "closed_at": "2023-06-03T19:45:28Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13454",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n5.10.19\n\n### Node.js version\n\n18\n\n### MongoDB version\n\n5\n\n### Operating system\n\nLinux\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\nAL2\n\n### Issue\n\nHello! \r\n\r\nWe are using IAM roles to connect to mongo via mongoose. \r\n\r\nTo do this we pass a `SESSION_TOKEN` into the connection string such as: \r\n```js\r\n`${protocol}://${accessKey}:${awsSecretKey}@${host}/${db}?authSource=%24external&authMechanism=MONGODB-AWS&retryWrites=true&w=majority&authMechanismProperties=AWS_SESSION_TOKEN:${awsSessionToken}&ssl=true?${replica}`\r\n```\r\n\r\nThe problem is after 15 mins the session token is invalidated and we need to re-create it. \r\n\r\nIs there a way to do this in mongoose automatically? Or any tips on how to tackle this problem! Tried calling `disconnect` then `connect` but getting this error while testing: `MongoError: server is closed`",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13454/comments",
    "author": "sidpremkumar",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-06-03T19:45:28Z",
        "body": "Currently there's no good way to do that other than to create a new connection each time your session token changes. The MongoDB Node driver team is working on supporting this.\r\n\r\nThe problem with calling `disconnect()` on a timer is that any in-flight operations will fail. So you may want to do something like the following (rough example, no error handling)\r\n\r\n```javascript\r\nlet currentConnection;\r\n\r\nsetInterval(() => {\r\n  let oldConnection = currentConnection;\r\n  currentConnection = mongoose.createConnection(`${protocol}://${accessKey}:${awsSecretKey}@${host}/${db}?authSource=%24external&authMechanism=MONGODB-AWS&retryWrites=true&w=majority&authMechanismProperties=AWS_SESSION_TOKEN:${awsSessionToken}&ssl=true?${replica});\r\n  setTimeout(() => {\r\n    oldConnection.destroy();\r\n  }, 10000);\r\n}, 15 * 60 * 1000)\r\n```"
      },
      {
        "user": "sidpremkumar",
        "created_at": "2023-06-05T12:54:29Z",
        "body": "> Currently there's no good way to do that other than to create a new connection each time your session token changes. The MongoDB Node driver team is working on supporting this.\r\n> \r\n> The problem with calling `disconnect()` on a timer is that any in-flight operations will fail. So you may want to do something like the following (rough example, no error handling)\r\n> \r\n> ```js\r\n> let currentConnection;\r\n> \r\n> setInterval(() => {\r\n>   let oldConnection = currentConnection;\r\n>   currentConnection = mongoose.createConnection(`${protocol}://${accessKey}:${awsSecretKey}@${host}/${db}?authSource=%24external&authMechanism=MONGODB-AWS&retryWrites=true&w=majority&authMechanismProperties=AWS_SESSION_TOKEN:${awsSessionToken}&ssl=true?${replica});\r\n>   setTimeout(() => {\r\n>     oldConnection.destroy();\r\n>   }, 10000);\r\n> }, 15 * 60 * 1000)\r\n> ```\r\n\r\nHi @vkarpov15 thanks for the response here! \r\n\r\nJust curious if we used `destroy` would we be safe from in-flight requests? Just want to dig into what you mean by `no error handling` as we would like to move forward with this approach. "
      },
      {
        "user": "vkarpov15",
        "created_at": "2023-06-08T15:55:47Z",
        "body": "`destroy()` closes the connection permanently. It doesn't do anything to help with potentially erroring out in-flight requests. Right now we don't have a better way of doing that other than setting a timer - the `setTimeout()` will hopefully give in-flight operations enough time to complete before killing the connection.\r\n\r\nWe and the MongoDB Node driver team are working on a better solution, but right now creating a new connection and closing the old connection after a certain time period is the simplest and most durable approach."
      }
    ]
  },
  {
    "number": 13205,
    "title": "i cant save data from checkbox using js and mongoose",
    "created_at": "2023-03-23T15:12:51Z",
    "closed_at": "2023-03-23T21:52:38Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13205",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n7.0.0\n\n### Node.js version\n\n18.15.0 \n\n### MongoDB version\n\n6.0\n\n### Operating system\n\nWindows\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n10\n\n### Issue\n\ni have form for new product and using checkbox for chose many size \r\nwhen i choose more than 1 size this error happen\r\n\r\n this.$__.validationError = new ValidationError(this);\r\n                               ^\r\n\r\nValidationError: Product validation failed: size: Cast to string failed for value \"[ 'S', 'M', 'L' ]\" (type Array) at path \"size\"\r\n\r\n\r\n\r\nand this is the schema \r\n\r\nconst mongoose = require('mongoose');\r\nconst Schema = mongoose.Schema;\r\n\r\nconst ProductSchema = new Schema({\r\n    title: String,\r\n    image: String,\r\n    price: Number,\r\n    size: {\r\n        type: String,\r\n        enum: ['S', 'M', 'L', 'xL', '2xL']\r\n    }\r\n});\r\n\r\nand this is example of the checkbox\r\n\r\n <div class=\"form-check form-check-inline\">\r\n                <input class=\"form-check-input\" type=\"checkbox\" name=\"products[size]\" id=\"M\" value=\"M\">\r\n                <label class=\"form-check-label\" for=\"M\">\r\n                    Medium\r\n                </label>\r\n              </div> \r\n\r\n\r\nmodule.exports = mongoose.model('Product', ProductSchema);",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13205/comments",
    "author": "mohamed9777",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-03-23T21:52:38Z",
        "body": "Sounds like you need to update your schema to the following:\r\n\r\n```javascript\r\nconst ProductSchema = new Schema({\r\n  title: String,\r\n  image: String,\r\n  price: Number,\r\n  size: {\r\n    type: [String], // <-- make size an array of strings rather than just a string\r\n    enum: ['S', 'M', 'L', 'xL', '2xL']\r\n  }\r\n});\r\n```"
      },
      {
        "user": "mohamed9777",
        "created_at": "2023-03-24T05:46:57Z",
        "body": "thanks alot <3"
      }
    ]
  },
  {
    "number": 13127,
    "title": "ref and Populate in mongoose to a specific field",
    "created_at": "2023-03-04T18:52:05Z",
    "closed_at": "2023-03-04T19:20:08Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13127",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.8.2\n\n### Node.js version\n\n18.14.2\n\n### MongoDB version\n\n5.1.0\n\n### Operating system\n\nNone\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nI want to be able to create a product and in the package I of that product I want to be able to put an id of one of the skus that I have in my storage model and when I GET the product I want it to show the info about that sku. I have search for an answer for this for days, and I can not find a solution\r\n\r\n\r\n```\r\nconst ProductSchema = new mongoose.Schema({\r\n    name:{type:String, required:true, unique:true},\r\n    stores:[{\r\n        name:String,\r\n        package:[{\r\n            name:String,\r\n            sku: // i want here to pass one of the skus id and when i populate the product i want it to return that sku info\r\n        }]\r\n    }],\r\n\r\n},{timestamps : true})\r\nexport default mongoose.models.Product || mongoose.model(\"Product\", ProductSchema);\r\n\r\n\r\nconst storageSchema = new mongoose.Schema({\r\n    name:String,\r\n    region:[{\r\n        name:String,\r\n        skus:[{\r\n            name:String,\r\n            variant:[{\r\n                name:String,\r\n            }]\r\n        }]\r\n}]\r\n},{timestamps: true})\r\nexport default mongoose.models.Storage || mongoose.model(\"Storage\", storageSchema);\r\n\r\n//example of the resposnse i want \r\n{\r\n    \"_id\": \"6402ec724db3304dfc134069\",\r\n    \"name\": \"product Name\",\r\n    \"stores\": [\r\n        {\r\n            \"name\": \"Store Name\",\r\n            \"package\": [\r\n                {\r\n                    \"name\": \"package name\",\r\n                    \"sku\" : [{\r\n                        \"name\":\"sku name\",\r\n                        \"variant\":[{\r\n                            \"name\":\"variant name\"\r\n                        },\r\n                        {\r\n                            \"name\":\"variant name\"\r\n                        },\r\n                        {\r\n                            \"name\":\"variant name\"\r\n                        },\r\n                        {\r\n                            \"name\":\"variant name\"\r\n                        },]\r\n                    }]\r\n                    \"_id\": \"6402ee69c737a9d40948d522\"\r\n                }\r\n            ],\r\n            \"_id\": \"6402ede4c737a9d40948d4f9\"\r\n        }\r\n    ],\r\n}\r\n\r\n//example of the storage data \r\n{\r\n    \"_id\": \"63f43de1b8604ed5c5c99f02\",\r\n    \"StorageName\": \"Storage Name\",\r\n    \"region\": [\r\n        {\r\n            \"name\": \"region name\",\r\n            \"_id\": \"63f43e9eb8604ed5c5c99f48\",\r\n            \"skus\": [\r\n                {\r\n                    \"name\": \"first sku\",\r\n                    \"variant\":[{\r\n                        \"name\":\"variant name\"\r\n                    },\r\n                    {\r\n                        \"name\":\"variant name\"\r\n                    },\r\n                    {\r\n                        \"name\":\"variant name\"\r\n                    },\r\n                    {\r\n                        \"name\":\"variant name\"\r\n                    },],\r\n                    \"_id\": \"63f4c734b8604ed5c5c99f99\"\r\n                },\r\n                {\r\n                    \"name\": \"sec sku\",\r\n                    \"variant\":[{\r\n                        \"name\":\"variant name\"\r\n                    },\r\n                    {\r\n                        \"name\":\"variant name\"\r\n                    },\r\n                    {\r\n                        \"name\":\"variant name\"\r\n                    },\r\n                    {\r\n                        \"name\":\"variant name\"\r\n                    },],\r\n                    \"_id\": \"63f4c73ab8604ed5c5c99fa7\"\r\n                },\r\n                {\r\n                    \"name\": \"third sku\",\r\n                    \"_id\": \"6402baac4db3304dfc133db7\"\r\n                }\r\n            ]\r\n        },\r\n        {\r\n            \"name\": \"region name\",\r\n            \"_id\": \"63f43ea9b8604ed5c5c99f5b\",\r\n            \"skus\": [\r\n                {\r\n                    \"name\": \"first sku\",\r\n                    \"_id\": \"63f4db42cfb1ebe9fafc1ff0\"\r\n                },\r\n                {\r\n                    \"name\": \"sec sku\",\r\n                    \"_id\": \"63f4db4dcfb1ebe9fafc200a\"\r\n                },\r\n                {\r\n                    \"name\": \"third sku\",\r\n                    \"_id\": \"63f4db5ccfb1ebe9fafc2027\"\r\n                }\r\n            ]\r\n        }\r\n    ],\r\n}\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13127/comments",
    "author": "MBAS89",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-03-04T19:20:08Z",
        "body": "You would need a separate model for skus. Mongoose can only populate from models, not from subdocuments of models.  Once you have a sku model, you should be able to do `sku: { type: mongoose.ObjectId, ref: 'SKU' }` and `.populate('stores.package.sku')`? "
      }
    ]
  },
  {
    "number": 13118,
    "title": "Can't prevent duplicates when updating an object in an array",
    "created_at": "2023-03-02T21:57:22Z",
    "closed_at": "2023-03-04T10:39:20Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13118",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.9.0\n\n### Node.js version\n\n18.13.0\n\n### MongoDB version\n\n6.0\n\n### Operating system\n\nmacOS\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n13.2.1\n\n### Issue\n\nI have spent at least six hours of today trying to solve a seemingly easy problem. I am trying to either add or update an object that is in an array of subdocuments, based on the value of a field `price_level`. Here is my schema:\r\n```\r\nimport mongoose, { Schema } from 'mongoose';\r\n\r\nconst orderBookSchema = new Schema({\r\n   pair_name: {\r\n      type: String,\r\n      required: true\r\n   },\r\n   side: String,\r\n   entries: [{ price_level: String, volume: String }],\r\n});\r\n\r\nexport const OrderBook = mongoose.model('OrderBook', orderBookSchema);\r\n```\r\nIf `entries` contains an object that has a particular `price_level`, it should update the `volume` to the new value. Otherwise, add the new element `{ pair_name, volume }` to the array. Here is the code:\r\n```\r\nstatic updateOrderBook = async (pairName: string, side: 'ask' | 'bid', orderBookEntries: string[][], deleteExisting: boolean = false) => {\r\n   const existingOrderBook = await OrderBook.findOne({ pair_name: pairName, side });\r\n\r\n   if (!existingOrderBook) {\r\n      await OrderBook.create({ pair_name: pairName, side, entries: [] });\r\n   }\r\n\r\n   if (deleteExisting) {\r\n      const filter = { pair_name: pairName, side };\r\n      const update = { $set: { entries: [] } };\r\n      await OrderBook.updateOne(filter, update).exec();\r\n   }\r\n\r\n   for await (const [priceLevel, volume] of orderBookEntries) {\r\n      const filter = {\r\n         pair_name: pairName,\r\n         side,\r\n         'entries.price_level': priceLevel\r\n      };\r\n\r\n      const update = { $set: { 'entries.$.volume': volume } };\r\n      const result = await OrderBook.updateOne(filter, update).exec();\r\n\r\n      if (result.matchedCount === 0) {\r\n         const newElement = { price_level: priceLevel, volume: volume };\r\n         const addUpdate = { $addToSet: { entries: newElement } };\r\n         await OrderBook.updateOne({ pair_name: pairName, side }, addUpdate).exec();\r\n      }\r\n   }\r\n\r\n   const filter = { pair_name: pairName, 'entries.volume': '0.00000000' };\r\n   const update = { $pull: { entries: { volume: '0.00000000' } } };\r\n   await OrderBook.updateOne(filter, update).exec();\r\n};\r\n```\r\nI have tried so many different permutations of operators and so on, and checked the properties of `result`, but whatever I do, a duplicate or two slips through. It is not consistent ‚Äì mostly it seems to behave, and when I hardcode some values to test, it is fine.\r\n\r\nBut occasionally, when it's coming from the Kraken web socket API, duplicates appear.\r\n\r\nChatGPT is doing my head in. It has suggested so many different things, and of those that compiled, they did not work.\r\n\r\nI have tried:\r\n- using a `Number` instead of a `String` for the subdocument properties\r\n- applying a transaction to the code block\r\n- removed replication\r\n- not using `.exec()` at the end of the update function calls\r\n\r\nIt's really tricky to debug, because it is intermittent and I am unable to reproduce it by manually passing in mock data.\r\n\r\nIs there a fault with my query? This sort of thing should not happen:\r\n```\r\nentries: [\r\n    // ...more\r\n    {\r\n      price_level: '23463.40000',\r\n      volume: '0.13447916',\r\n      _id: new ObjectId(\"6401151cc708de7a1ff9bf01\")\r\n    },\r\n    {\r\n      price_level: '23463.40000',\r\n      volume: '0.13447916',\r\n      _id: new ObjectId(\"6401151cc708de7a1ff9c0ac\")\r\n    }\r\n    // ...more\r\n]\r\n```\r\n...but it does.\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13118/comments",
    "author": "jambudipa",
    "comments": [
      {
        "user": "jambudipa",
        "created_at": "2023-03-04T10:39:20Z",
        "body": "So I rejigged the schema, and it turned out to be agonisingly simple:\r\n```\r\nstatic updateOrderBook = async (\r\n   pairName: string,\r\n   side: 'ask' | 'bid',\r\n   orderBookEntries: string[][],\r\n   deleteExisting: boolean = false\r\n) => {\r\n   const orderBook = { pairName, side };\r\n\r\n   if (deleteExisting) {\r\n      await OrderBook.deleteMany(orderBook);\r\n   }\r\n\r\n   for await (const [priceLevel, volume] of orderBookEntries) {\r\n      const filter = { ...orderBook, priceLevel };\r\n      if (+volume === 0) {\r\n         await OrderBook.findOneAndDelete(filter);\r\n      } else {\r\n         await OrderBook.findOneAndUpdate(\r\n            filter,\r\n            { $set: { volume } },\r\n            { upsert: true }\r\n         );\r\n      }\r\n   }\r\n};\r\n```"
      },
      {
        "user": "vkarpov15",
        "created_at": "2023-03-04T18:54:15Z",
        "body": "So instead of having one order book, you have a separate document for every price level in the order book? That's an interesting idea. It definitely works. Just a bit slower to load the current state of the order book.\r\n\r\nAnother potential approach would be to use a map rather than an array, with price levels as the key. Just make sure to multiply out the price level to avoid dots in the key name.\r\n\r\n```\r\nconst mongoose = require('mongoose');\r\n\r\nconst orderBookSchema = new mongoose.Schema({\r\n   pair_name: {\r\n      type: String,\r\n      required: true\r\n   },\r\n   side: String,\r\n   entries: { type: Map, of: Number }\r\n});\r\n\r\nconst OrderBook = mongoose.model('OrderBook', orderBookSchema);\r\n\r\n// Update a given price level\r\nOrderBook.updateOne({ _id: orderBookId }, { $inc: { `entries.${priceLevel}`: volume } });\r\n```"
      },
      {
        "user": "jambudipa",
        "created_at": "2023-03-04T19:03:09Z",
        "body": "It‚Äôs ok, I rejigged my schema and now it is working perfectly. As you mention, speed might have been a concern but I have tested it and it‚Äôs easily fast enough. There are only a couple of thousand documents or so.Perhaps I can try out your Map suggestion if speed becomes an issue.Sent from my iPhoneOn 4 Mar 2023, at 18:54, Valeri Karpov ***@***.***> wrote:Ôªø\nSo instead of having one order book, you have a separate document for every price level in the order book? That's an interesting idea. It definitely works. Just a bit slower to load the current state of the order book.\nAnother potential approach would be to use a map rather than an array, with price levels as the key. Just make sure to multiply out the price level to avoid dots in the key name.\nconst mongoose = require('mongoose');\n\nconst orderBookSchema = new mongoose.Schema({\n   pair_name: {\n      type: String,\n      required: true\n   },\n   side: String,\n   entries: { type: Map, of: Number }\n});\n\nconst OrderBook = mongoose.model('OrderBook', orderBookSchema);\n\n// Update a given price level\nOrderBook.updateOne({ _id: orderBookId }, { $inc: { `entries.${priceLevel}`: volume } });\n\n\n‚ÄîReply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you modified the open/close state.Message ID: ***@***.***>"
      }
    ]
  },
  {
    "number": 13048,
    "title": "Connecting to local MongoDb from a Docker container fails in any 6.x.x versions",
    "created_at": "2023-02-17T22:47:03Z",
    "closed_at": "2023-02-18T18:46:59Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13048",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.9.1\n\n### Node.js version\n\n16.13.2\n\n### MongoDB version\n\n4.0.5\n\n### Operating system\n\nWindows\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\nWindows 10 Pro (OS Build: 19044.1645)\n\n### Issue\n\nTeam,\r\n\r\nBy using `host.docker.internal` as the `host` value within a Docker Container; up to version **5.12.7** it works beautifully to connect to my local MongoDb (outside of Container), however, it fails to connect at any versions above that, including 6.x.x.   \r\n\r\nHere is sample code snippet:\r\n\r\n    open(mongoose, callback) {        \r\n        const options = {\r\n            // useMongoClient: true,      // <-- no longer necessary\r\n            // useNewUrlParser: true,     // <-- no longer necessary\r\n            // useUnifiedTopology: true,  // <-- no longer necessary\r\n            promiseLibrary: global.Promise  // <-- not sure if its needed in 6.x.x; works fine in 5.12.7\r\n        };\r\n\r\n        const env = process.env.MICRO_SVC_ENV,\r\n              dockerLocalHost = 'host.docker.internal',\r\n              connStr = `mongodb://${dockerLocalHost}:27017/someDb`;\r\n\r\n        mongoose.connect(connStr, options, (err) => {\r\n            if (err) {\r\n                console.error(`${logPrefix} Open(${env}). Mongoose.Connect() failed:`, err);\r\n                return;\r\n            }\r\n\r\n            console.log(`${logPrefix} Open(${env}). CONNECTED to MongoDB.`);\r\n        });\r\n        /// rest of code....\r\n\r\nDoes anyone know if the new versions of mongoose has disabled this feature, or may be I am missing an extra options setting when connecting?        ",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13048/comments",
    "author": "sonnyk22",
    "comments": [
      {
        "user": "Pr0dt0s",
        "created_at": "2023-02-18T15:34:45Z",
        "body": "The connection is trying to use the server¬¥s configured listening ip (127.0.0.1) unsuccessfully since that points to the loopback interface inside the docker container.\r\n\r\nSetting the option ```directConnection: true``` to force the use of the host in the connection string seem to solve this issue.\r\n"
      },
      {
        "user": "sonnyk22",
        "created_at": "2023-02-18T18:46:54Z",
        "body": "Fantastic!  Your great solution worked out perfectly; thank you.  Closing this ticket."
      }
    ]
  },
  {
    "number": 13014,
    "title": "Filter in pre (find) hook Mongoose",
    "created_at": "2023-02-09T18:52:05Z",
    "closed_at": "2023-02-16T04:13:28Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13014",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.3.3\n\n### Node.js version\n\n19.5\n\n### MongoDB version\n\n4.4.18 Community\n\n### Operating system\n\nLinux\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\nManjaro Linux 5.15.91-1\n\n### Issue\n\nI'm trying to perform a query that filters an array from another document, to mention something about the structure, I try to populate the document based on the specified product and store id, so that it doesn't bring the other data from the array but in this case I understand that I can't access the document fields while in the middleware, I'm reading the documentation but I still learning concepts\r\n```\r\n\r\nbUnitSchema.pre(/^find/, function (next) {\r\n  this.populate({\r\n    path: \"menuItem.product\",\r\n\r\n    select: {\r\n      \"storeId.$\": 1,\r\n    },\r\n    match: {\r\n      \"storeId.store\": \"62a811d1af67f5415770f297\",\r\n      \r\n    }\r\n  });\r\n  next();\r\n});\r\n\r\n```\r\n\r\nany guide would be of excellent help\r\n\r\nI try something like this\r\n```\r\n\r\nbUnitSchema.pre(/^find/, function (next) {\r\n  \r\n  this.populate({\r\n    path: \"menuItem.product\",\r\n\r\n    select: {\r\n      \"storeId.$\": 1,\r\n    },\r\n    match: {\r\n      \r\n       *//here im trying to do something like this*\r\n      *\"storeid.store\": bUnitSchema.menuItem.store*\r\n    },\r\n  });\r\n\r\n  next();\r\n});\r\n```\r\n\r\nbut give me\r\n`\r\nstore not defined`",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13014/comments",
    "author": "jj-devs",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-02-12T18:56:58Z",
        "body": "I think you would need a post hook, not a pre hook. If I'm reading this correctly, I think you're trying to use the result of `find()` in a `populate()`, which isn't going to work in a pre hook because the query hasn't executed yet."
      },
      {
        "user": "jj-devs",
        "created_at": "2023-02-16T04:13:27Z",
        "body": "Yes you are right, that was i need, this is the code:\r\n```\r\nbUnitSchema.post(/^find/, async function (docs) {\r\n  for (let doc of docs) {\r\n    for (let store of doc.menuItem) {\r\n      await doc.populate({\r\n        path: \"menuItem.product\",\r\n        select: {\r\n          \"storeId.$\": 1,\r\n        },\r\n        match: {\r\n          \"storeId.store\": store.store,\r\n        },\r\n      });\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nThanks for the help @vkarpov15 !"
      }
    ]
  },
  {
    "number": 12998,
    "title": " \"Schema hasn't been registered for model \"[object Object]\" error in two way referential relationship in mongo ig because of 'populate' function.",
    "created_at": "2023-02-04T06:33:19Z",
    "closed_at": "2023-02-06T15:38:48Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12998",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.8.1\n\n### Node.js version\n\n16.13.2\n\n### MongoDB version\n\n6.0.3\n\n### Operating system\n\nWindows\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nHere I have declared a two way referential relationship, If I import 'farm' module before 'products' module I am having access to all farms but linked linked products are throwing \"Schema hasn't been registered for model \"[object Object]\" error. If I import 'products' first I cannot access 'farms' collections.\r\n**farm.js**\r\n```\r\nconst mongoose=require('mongoose');\r\nconst product = require('./products');\r\nconst {Schema}=mongoose;\r\n\r\nconst farmSchema=new Schema({\r\n    name:{\r\n        type:String,\r\n        required:[true,'Farm must have an name!']\r\n    },\r\n    city:{\r\n        type:String\r\n    },\r\n    email:{\r\n        type:String,\r\n        required:true\r\n    },\r\n    products:[\r\n        {\r\n            type:Schema.Types.ObjectId,\r\n            ref:product//ref refers to model \r\n        }\r\n    ]\r\n})\r\n\r\nconst farm=mongoose.model('Farm',farmSchema)\r\n\r\nmodule.exports=farm\r\n```\r\n**product.js**\r\n```\r\nconst mongoose=require('mongoose')\r\nconst farm = require('./farm')\r\n\r\nconst productSchema=new mongoose.Schema({\r\n    Pname:{\r\n        type:String,\r\n        required:true\r\n    },\r\n    Price:{\r\n        type:Number,\r\n        required:true,\r\n        min:0\r\n        \r\n    },\r\n    category:{\r\n        type:String,\r\n        lowercase:true,//item will always be lowercase\r\n        enum:['fruit','vegetable','dairy','drinks','nota']\r\n\r\n    },\r\n    farms:[\r\n       {\r\n        type:mongoose.Schema.Types.ObjectId,\r\n        ref:farm\r\n       }\r\n    ]\r\n})\r\n\r\nconst product=mongoose.model('Product',productSchema)\r\n\r\nmodule.exports=product  \r\n```\r\n**index.js**\r\n### This code renders a new page and set up relationship between them.\r\n```app.get('/farm/:id/product/new',async(req,res)=>{//this is the new route for product in a farm, no need to create product individually.(this is correct becouse why anyone will write a subcomment if there is no comment.)\r\n    const {id}=req.params;\r\n    const f=await farm.findById(id)\r\n    res.render('views/products/new',{categories,f})\r\n})\r\n\r\n//setting relationship between two collections\r\napp.post('/farm/:id/product',async(req,res)=>{\r\n    const {id}=req.params\r\n    const Cfarm=await farm.findById(id)\r\n    const {Pname,Price,category}=req.body;\r\n    const p=new product({Pname,Price,category})\r\n    Cfarm.products.push(p)\r\n    p.farms=Cfarm //not pushing bcz many to one relationship\r\n    await Cfarm.save()\r\n    await p.save()\r\n    res.redirect(`/farm/${id}`)\r\n\r\n})\r\n```\r\n### This is a product route which renders the specific page for the product. Having issue populating in this one.\r\n```app.get('/product/:id',async (req,res)=>{\r\n    const {id}=req.params;\r\n    const p=await product.findById(id).populate('farm','name')\r\n    console.log(p)\r\n    res.render('views/products/detail',{p})\r\n})\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12998/comments",
    "author": "ManjeetvermaCode",
    "comments": [
      {
        "user": "ManjeetvermaCode",
        "created_at": "2023-02-04T06:35:59Z",
        "body": "In short- I can access farm with it's associated products but not vice-versa. \r\nPS-This is my first time asking question on GitHub."
      },
      {
        "user": "lpizzinidev",
        "created_at": "2023-02-06T08:44:57Z",
        "body": "Hi @ManjeetvermaCode  ‚úã\r\n\r\nTry to change your imports and references to:\r\n```\r\n// farm.js\r\n// Change `const product = require('./products');` to:\r\nrequire('./products');\r\n\r\nproducts: [\r\n  {\r\n    type: Schema.Types.ObjectId,\r\n    ref: 'Product',\r\n  },\r\n];\r\n\r\n// product.js\r\n// Remove `const farm = require('./farm');`\r\nfarms: [\r\n  {\r\n    type: mongoose.Schema.Types.ObjectId,\r\n    ref: 'Farm',\r\n  },\r\n];\r\n```"
      },
      {
        "user": "ManjeetvermaCode",
        "created_at": "2023-02-06T15:38:48Z",
        "body": "Ok thx, its working!"
      }
    ]
  },
  {
    "number": 12973,
    "title": "unique constraint failing on the field",
    "created_at": "2023-02-01T08:30:24Z",
    "closed_at": "2023-02-10T17:23:42Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12973",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n4.13.14\n\n### Node.js version\n\n14\n\n### MongoDB version\n\n5\n\n### Operating system\n\nLinux\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n22.04\n\n### Issue\n\nHi Team,\r\n\r\nI have a field that initially allowed to have duplicate values but now if I mark it as `unique: true` the app throws the below error. Any idea on how to enforce unique constraint on a field?\r\n\r\n` \"uncaughtException: E11000 duplicate key error collection`\r\n\r\nThanks,\r\nArun\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12973/comments",
    "author": "arunkumar413kadari",
    "comments": [
      {
        "user": "anuragphadnis",
        "created_at": "2023-02-01T08:50:01Z",
        "body": "This happens when you have nonunique values in the field where you want to apply the unique constraint. Please check your database for nonunique values. Now since you want to enforce this unique field one way could be to update the fields in the MongoDB database and ensure that no duplicate fields exist."
      },
      {
        "user": "arunkumar413kadari",
        "created_at": "2023-02-01T13:25:26Z",
        "body": "@anuragphadnis Thanks for the information."
      }
    ]
  },
  {
    "number": 12957,
    "title": "sort does not seem to be working when using populate",
    "created_at": "2023-01-30T01:20:24Z",
    "closed_at": "2023-02-06T22:56:26Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12957",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n5.13.8\n\n### Node.js version\n\n16.13.0\n\n### MongoDB version\n\n5.0.2\n\n### Operating system\n\nmacOS\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n11.5.2\n\n### Issue\n\nI am trying to sort documents that are part of a query that uses populated documents, for example:\r\n\r\n```\r\nItemOwnership.find()\r\n        .populate({\r\n            path: 'itemId',\r\n            sort: { title: 1 }\r\n        })\r\n        .populate({\r\n            path: 'userId',\r\n        })\r\n        .limit(10)\r\n        .exec();\r\n```\r\n\r\nHere, `title` is a field on the Item (`itemId`) document. My goal is to sort all the documents in the `itemOwnership` collection by `itemId.title`. Is this even possible? If not, what alternatives are there?",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12957/comments",
    "author": "joetidee",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-02-06T22:56:26Z",
        "body": "@joetidee that isn't possible. As written, your query will return `ItemOwnership` documents with each ItemOwnership's `itemId` sorted by title.\r\n\r\nAlternatives are:\r\n\r\n1) add an `itemIdTitle` property to `ItemOwnership` and sort by that\r\n2) use MongoDB aggregation framework with `$lookup`"
      }
    ]
  },
  {
    "number": 12835,
    "title": "Model.find() vs Query.find()",
    "created_at": "2022-12-25T19:20:22Z",
    "closed_at": "2022-12-29T17:23:35Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12835",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n5.13.15\n\n### Node.js version\n\n14.17.1\n\n### MongoDB version\n\nnot installed\n\n### Operating system\n\nmacOS\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nCurrently I am learning NodeJs with MongoDB, and Mongoose as well.\r\nI am confusing some Mongoose implementation:\r\n1. Can **find()** method be used with Model and Query equally?\r\n2. Is there any difference between Model.find() and Query.find()?\r\n3. Is it OK to using chained .finds like: Model.find().find().find()\r\n\r\nThanks in advance!",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12835/comments",
    "author": "TemurbekRuziyev",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2022-12-29T17:23:35Z",
        "body": "`Model.find()` is equivalent to creating a new `Query` instance and calling `find()` on it. So no significant difference.\r\n\r\n`Model.find().find().find()` is fine. We sometimes do stuff like `Model.find({ name: 'test' }).find({ age: { $gte: 30 } })`, which is equivalent to `Model.find({ name: 'test', age: { $gte: 30 } })`"
      }
    ]
  },
  {
    "number": 12812,
    "title": "Can't get access to data from Model.findOne() outside its body.",
    "created_at": "2022-12-17T15:02:57Z",
    "closed_at": "2022-12-18T18:49:53Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12812",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.6.0\n\n### Node.js version\n\n18.8.0\n\n### MongoDB version\n\n6.0\n\n### Operating system\n\nWindows\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n11\n\n### Issue\n\nSo im trying to get the data from my db using moongose like that\r\n```js\r\nlet value;\r\nModel.findOne({ something: something}, (err, Doc) => {\r\n    if (err) {\r\n        console.error(err);\r\n        return;\r\n    }\r\n    if (Doc) {\r\n        value = Doc.value\r\n    } else {\r\n        value = config.value\r\n    }\r\n});\r\n```\r\nbut i need to get it in entire program and i don't really know how to do it. when i try to console log in this i have a correct value, but outside of it i get undefined.",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12812/comments",
    "author": "Jacob1Tm",
    "comments": [
      {
        "user": "Uzlopak",
        "created_at": "2022-12-17T15:14:04Z",
        "body": "Can you use async await logic?"
      },
      {
        "user": "Jacob1Tm",
        "created_at": "2022-12-17T15:19:58Z",
        "body": "Now i have this error\r\n\r\n```\r\nconst err = new MongooseError('Query was already executed: ' + str);\r\n                  ^\r\n\r\nMongooseError: Query was already executed: Model.findOne({})\r\n    at model.Query._wrappedThunk [as _findOne] (C:\\A\\Repo\\node_modules\\mongoose\\lib\\helpers\\query\\wrapThunk.js:23:19)\r\n    at C:\\A\\Repo\\node_modules\\kareem\\index.js:426:25\r\n    at process.processTicksAndRejections (node:internal/process/task_queues:77:11) {\r\n  originalStack: 'Error\\n' +\r\n    '    at model.Query._wrappedThunk [as _findOne] (C:\\\\A\\\\Repo\\\\node_modules\\\\mongoose\\\\lib\\\\helpers\\\\query\\\\wrapThunk.js:27:28)\\n' +\r\n    '    at C:\\\\A\\\\Repo\\\\node_modules\\\\kareem\\\\index.js:426:25\\n' +\r\n    '    at process.processTicksAndRejections (node:internal/process/task_queues:77:11)'\r\n}\r\n```"
      },
      {
        "user": "Uzlopak",
        "created_at": "2022-12-17T15:25:42Z",
        "body": "Without callback fn as last parameter, the functions will return promises, which you can await."
      },
      {
        "user": "Jacob1Tm",
        "created_at": "2022-12-17T15:32:19Z",
        "body": "uhh, im not sure what do you mean...\r\ni mean what function."
      },
      {
        "user": "Uzlopak",
        "created_at": "2022-12-17T16:34:02Z",
        "body": "await Model.findOne({ something: something})"
      },
      {
        "user": "Jacob1Tm",
        "created_at": "2022-12-17T16:39:06Z",
        "body": "im really confused right now what should i do with it... "
      },
      {
        "user": "Uzlopak",
        "created_at": "2022-12-17T16:44:00Z",
        "body": "How many years or months experience do you have with Javascript for backend?"
      },
      {
        "user": "Jacob1Tm",
        "created_at": "2022-12-17T16:50:20Z",
        "body": "not much..."
      },
      {
        "user": "Uzlopak",
        "created_at": "2022-12-17T18:06:38Z",
        "body": "Please first learn about async await and Promises, and how they prevent you from callback hell. "
      },
      {
        "user": "Jacob1Tm",
        "created_at": "2022-12-18T18:49:53Z",
        "body": "Finally works!"
      },
      {
        "user": "Jacob1Tm",
        "created_at": "2022-12-18T18:53:22Z",
        "body": "~~and now i see what i did wrong thx~~"
      }
    ]
  },
  {
    "number": 12783,
    "title": "Creates a find query: gets a list of documents that match filter",
    "created_at": "2022-12-09T03:42:28Z",
    "closed_at": "2022-12-17T07:04:37Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12783",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.8.0\n\n### Node.js version\n\n16.16.0\n\n### MongoDB version\n\n4.12.1\n\n### Operating system\n\nWindows\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n11\n\n### Issue\n\n```js\r\n if (method === \"GET\") {\r\n        // get all the event from eventschemas ?\r\n        const events = await EventSchema.find({});\r\n        res.status(200).json(events);\r\n\r\n    }\r\n```\r\n\r\n\r\nThe error :\r\n\r\n  Each member of the union type '{ <ResultDoc = any>(filter: FilterQuery<any>, projection?: ProjectionType<any>, options?: QueryOptions<any>, callback?: Callback<ResultDoc[]>): Query<...>; <ResultDoc = any>(filter: FilterQuery<...>, projection?: ProjectionType<...>, callback?: Callback<...>): Query<...>; <ResultDoc = any>(filter: FilterQuery<...>, ...' has signatures, but none of those signatures are compatible with each other.ts(2349)",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12783/comments",
    "author": "Abbhiishek",
    "comments": [
      {
        "user": "IslandRhythms",
        "created_at": "2022-12-16T18:28:06Z",
        "body": "Is `EventSchema` the name of your model? That's very confusing"
      },
      {
        "user": "Abbhiishek",
        "created_at": "2022-12-17T07:04:37Z",
        "body": "The issue is fixed \r\nThanks for having a look üëçüèª \r\n\r\nMade some changes in `tsconfig.js` file "
      },
      {
        "user": "Boboss74",
        "created_at": "2023-01-26T21:15:54Z",
        "body": "@Abbhiishek what were the changes ?"
      }
    ]
  },
  {
    "number": 12773,
    "title": "Reuse subschema contains refPath",
    "created_at": "2022-12-07T02:56:13Z",
    "closed_at": "2022-12-07T03:27:35Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12773",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.7.4\n\n### Node.js version\n\n18.12.1\n\n### MongoDB version\n\n6.0.2\n\n### Operating system\n\nWindows\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nI have schemas like this:\r\n```js\r\nconst childSchema = new Schema({\r\n    title: String,\r\n    type: { type: String, enum: ['Test'] },\r\n    test: { type: Schema.Types.ObjectId, refPath: 'child.type' },\r\n  });\r\n  const parentSchema = new Schema({ title: String, child: childSchema });\r\n```\r\nIt works.\r\nBut I want to use childSchema on another schema like this:\r\n```js\r\n  const subAnotherSchema = new Schema({ title: String, child: childSchema });\r\n  const anotherSchema = new Schema({ title: String, subAnother: subAnotherSchema });\r\n```\r\nBecause refPath nested another schema so refPath now wrong.\r\nHow can I reuse childSchema?",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12773/comments",
    "author": "conduongtong",
    "comments": [
      {
        "user": "conduongtong",
        "created_at": "2022-12-07T03:27:35Z",
        "body": "I solved by using replace refPath: 'child.type' to ref: function(child) { return child.type; }"
      },
      {
        "user": "vkarpov15",
        "created_at": "2022-12-28T23:45:23Z",
        "body": "Use `ref` function instead of `refPath`. As you saw, `refPath` is relative to the top-level document, which makes it tricky to reuse schemas. If you use `ref: function() { return this.type; }`, that's relative to the subdocument, which is better for schema reuse."
      }
    ]
  },
  {
    "number": 12732,
    "title": "Check if any error is instanceof one of Mongoose errors",
    "created_at": "2022-11-28T14:07:02Z",
    "closed_at": "2022-11-28T14:25:33Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12732",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n6.7.3\r\n\r\n### Node.js version\r\n\r\n14\r\n\r\n### MongoDB version\r\n\r\n5\r\n\r\n### Operating system\r\n\r\nLinux\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n_No response_\r\n\r\n### Issue\r\n\r\nIs there a way to know if an error is instance of one of the different mongoose errors ?\r\n\r\nI can go one by one like `err instanceof mongoose.Error.CastError` etc, but is there a more generic way ?\r\n\r\nSome solutions have this kind of method like in axios. `isAxiosError`\r\n\r\nThanks a lot.",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12732/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "Uzlopak",
        "created_at": "2022-11-28T14:10:02Z",
        "body": "All MongooseErrors extend from MongooseError. So you should be able to do `err instanceof mongoose.Error`"
      }
    ]
  },
  {
    "number": 12729,
    "title": "Subdocument is not saving automatically.",
    "created_at": "2022-11-27T13:00:10Z",
    "closed_at": "2022-11-28T17:30:14Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12729",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.7.3\n\n### Node.js version\n\n19.0.0\n\n### MongoDB version\n\n6.0.3\n\n### Operating system\n\nmacOS\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n13.0.1\n\n### Issue\n\nI'm new to typescript and mongoose and mongo DB so I can have some mistakes :(\r\n\r\nI've created the document with subdocument:\r\n```ts\r\ninterface IBadge {\r\n  badgeId: number\r\n}\r\ninterface IUser {\r\n  badges: IBadge[]\r\n}\r\n\r\nconst BadgeModel = model<IBadge>('badge', new Schema<IBadge>({\r\n  badgeId: String\r\n}))\r\nconst UserModel = model<IUser>('user', new Schema<IUser>({\r\n  badges: [{ type: Schema.Types.ObjectId, ref: 'badge' }],\r\n}))\r\n```\r\nI want to save IBadge interface with IUser interface.\r\nI accessed the database with this code.\r\n```ts\r\nasync function setUserData(data: IUser) {\r\n  await new UserModel(data).save()\r\n}\r\nexport async function getDataOfUserId(id: string, existThen: (id: string, data: IUser) => Promise<void>) {\r\n  await existThen(id, <IUser>await UserModel.findOne({'id': id}).exec())\r\n}\r\nexport async function updateUserDataId(id: string, data: IUser) {\r\n  await setUserData(data)\r\n}\r\n\r\nawait getDataOfUserId(user, async (id, data) => {\r\n      data.badges.push(getBadgeModel({\r\n        badgeId: 12\r\n      }))\r\n      await updateUserDataId(id, data)\r\n    })\r\n```\r\nIt saves IUser interface(My interface contains other data but I've removed it for explanation) but IBadge interface is not saved.\r\n\r\nThis is the output when I call `db.users.find()` and `db.badges.find()` in the mongosh. \r\n```\r\n[\r\n  {\r\n    _id: ObjectId(\"638359e04decdc54e8b08fbc\"),\r\n    badges: [ ObjectId(\"63835ee68ad0e70279c7c0d9\") ],\r\n    __v: 1\r\n  }\r\n]\r\n```\r\n```\r\n```\r\n\r\nThanks for your help! :D",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12729/comments",
    "author": "dayo05",
    "comments": [
      {
        "user": "IslandRhythms",
        "created_at": "2022-11-28T16:37:59Z",
        "body": "Please include the code for `getBadgeModel()`"
      },
      {
        "user": "dayo05",
        "created_at": "2022-11-28T17:30:14Z",
        "body": "I've solve my question, just minor mistake.\r\n\r\nI should change\r\n```ts\r\nconst UserModel = model<IUser>('user', new Schema<IUser>({\r\n  badges: [{ type: Schema.Types.ObjectId, ref: 'badge' }],\r\n}))\r\n```\r\nto \r\n```ts\r\nconst UserModel = model<IUser>('user', new Schema<IUser>({\r\n  badges: [{ type: BadgeSchema, ref: 'badge' }],\r\n}))\r\n```\r\nThanks for response!"
      }
    ]
  },
  {
    "number": 12667,
    "title": "How to load mongoose Schema from the collection name",
    "created_at": "2022-11-07T19:02:14Z",
    "closed_at": "2022-11-23T16:16:45Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12667",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n6.7.2\r\n\r\n### Node.js version\r\n\r\n14.19.1\r\n\r\n### MongoDB version\r\n\r\n4.11.0\r\n\r\n### Operating system\r\n\r\nmacOS\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\nMacOS Monterey, 12.4\r\n\r\n### Issue\r\n\r\nIdeally, for populate to work during queries in mongoose, both the schemas of that which is been populated and the calling schema needs to be imported in same file under same repo.\r\n\r\nNow, I have a scenario where a schema called `AuthorSchema` was created by another internal micro-service in another repo which is pointing to the same database as my own service and I wish to populate it during my queries.\r\n\r\nIs there a way to automatically decode the `AuthorSchema` from the `author` collection name after I've connected to the database?\r\n\r\nE.g\r\n  \r\n\r\n    let posts = await Post.find({})\r\n                .populate(\"author\", 'first_name last_name _id').limit(10)\r\n\r\nWhere I have created `postSchema` in my own service but `authorSchema` was created by another micro-service in another repo called `author-management-microservice` and as such I have no access to that schema.\r\n\r\n\r\nWhat I would want is something like:\r\n\r\n    let AuthorSchema = mongoose.connection.decodeSchemaFromCollectionName('author');\r\n    \r\nSuch that I can modify my query to something like\r\n\r\n    let posts = await Post.find({})\r\n                    .populate({path:\"author\", model:AuthorSchema, select:'first_name last_name _id'}).limit(10)\r\n\r\nThe reason I want something like this is because I have been battling with `MissingSchemaError: Schema hasn't been registered for model \"Author\".` whenever I try to populate `author` and I don't want to copy around duplicate schema files across different micro-services.\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12667/comments",
    "author": "ebitogu",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2022-11-23T16:16:45Z",
        "body": "It looks like you're looking for the Author model, not the author schema. `populate({ model: authorSchema })` doesn't work.\r\n\r\nTo find the author model, loop through `mongoose.models` and find the model whose `collection.name` matches 'author'\r\n\r\n```javascript\r\nfunction findModelByCollectionName(collectionName) {\r\n  for (const Model of Object.values(mongoose.models)) {\r\n    if (Model.collection.name === collectionName) {\r\n      return Model;\r\n    }\r\n  }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 12662,
    "title": "Mongoose Schema created using CommonJS not working again after porting to Module",
    "created_at": "2022-11-06T13:33:35Z",
    "closed_at": "2022-11-07T19:17:03Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12662",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.7.1\n\n### Node.js version\n\n14.19.1\n\n### MongoDB version\n\n4.11.0\n\n### Operating system\n\nmacOS\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\nMacOS Monterey, 12.4\n\n### Issue\n\nI started out my Mongoose Schema declarations using CommonJS as shown below and populate was working perfectly.\r\n\r\nFor CommonJS I have:\r\n\r\n**author.js**\r\n\r\n    const mongoose = require('mongoose');\r\n    \r\n    const AuthorSchema = new mongoose.Schema({\r\n        _id: mongoose.Schema.Types.ObjectId,\r\n        first_name: String,\r\n        last_name: String,\r\n        email: String,\r\n    }, {\r\n        timestamps: {\r\n            createdAt: 'created_at',\r\n            updatedAt: 'updated_at'\r\n        }\r\n    });\r\n    \r\n    module.exports = mongoose.model('Author', AuthorSchema);\r\n\r\n**comment.js**\r\n\r\n    const mongoose = require('mongoose');\r\n    \r\n    const CommentSchema = new mongoose.Schema({\r\n        _id: mongoose.Schema.Types.ObjectId,\r\n        text: String,\r\n        author: {\r\n            type: mongoose.Schema.Types.ObjectId,\r\n            ref: 'Author'\r\n        }\r\n    }, {\r\n        timestamps: {\r\n            createdAt: 'created_at',\r\n            updatedAt: 'updated_at'\r\n        }\r\n    });\r\n    \r\n    module.exports = mongoose.model('Comment', CommentSchema);\r\n\r\nand the below query worked flawlessly when using CommonJS\r\n\r\n    let comments = await Comment.find({ author: authorId })\r\n            .populate(\"author\", 'first_name last_name _id').limit(10);\r\n\r\n\r\nNow, my team wanted us to move away from CommonJS to modules and so I added `type:module` to my `package.json` file and attempted to refactor the schema declarations above to the following:\r\n\r\n**new_author.js**\r\n\r\n    import mongoose from 'mongoose';\r\n    \r\n    const AuthorSchema = new mongoose.Schema({\r\n        _id: mongoose.Schema.Types.ObjectId,\r\n        first_name: String,\r\n        last_name: String,\r\n        email: String,\r\n    }, {\r\n        timestamps: {\r\n            createdAt: 'created_at',\r\n            updatedAt: 'updated_at'\r\n        }\r\n    });\r\n    \r\n    export default mongoose.model('Author', AuthorSchema);\r\n\r\n\r\nand \r\n\r\n**new_comment.js**\r\n\r\n    import mongoose from 'mongoose';\r\n\r\n    const CommentSchema = new mongoose.Schema({\r\n        _id: mongoose.Schema.Types.ObjectId,\r\n        text: String,\r\n        author: {\r\n            type: mongoose.Schema.Types.ObjectId,\r\n            ref: 'Author'\r\n        }\r\n    }, {\r\n        timestamps: {\r\n            createdAt: 'created_at',\r\n            updatedAt: 'updated_at'\r\n        }\r\n    });\r\n    \r\n    export default mongoose.model('Comment', CommentSchema);\r\n\r\nand all of a sudden the following query no longer works\r\n\r\n  \r\n\r\n    let comments = await Comment.find({ author: authorId })\r\n                .populate(\"author\", 'first_name last_name _id').limit(10);\r\n\r\nThe error I keep getting back is\r\n\r\n    MissingSchemaError: Schema hasn't been registered for model \"Author\".\r\n\r\nThis is unbelievable. As you can see above, nothing changed other than using `imports` and `export default` statements.\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12662/comments",
    "author": "ebitogu",
    "comments": [
      {
        "user": "skyme5",
        "created_at": "2022-11-06T16:29:04Z",
        "body": "I think `AuthorSchema` hasn't beed registered when executing `populate`. Maybe you can import AuthorSchema before executing populate? @hashweather "
      },
      {
        "user": "ebitogu",
        "created_at": "2022-11-06T18:00:14Z",
        "body": "Unfortunately, AuthorSchema was created in a different micro-service  which is responsible for all things author management in a different repo so I can't import it into my own service.\r\n\r\nThe code works when both services are using CommonJS. It only fails when both services switched to module."
      },
      {
        "user": "ebitogu",
        "created_at": "2022-11-06T18:03:46Z",
        "body": "Each service is responsible for a single action so cross importing schemas is not allowed. Each service is responsible for its own models and communication happens only through grpc."
      },
      {
        "user": "skyme5",
        "created_at": "2022-11-06T19:57:55Z",
        "body": "@hashweather how about using the collection names from mongodb in `ref`, for this case setting `ref: authors` might help"
      },
      {
        "user": "ebitogu",
        "created_at": "2022-11-06T20:28:44Z",
        "body": "I changed ref to `authors` and issue still persists"
      },
      {
        "user": "ebitogu",
        "created_at": "2022-11-07T06:31:54Z",
        "body": "This is really weird. The ```authors``` collection already has over 1k documents in it so how is it possible that its schema has not been created?\r\n\r\nPlease note that this issue doesn't happen if both services move back to CommonJS. It seems to only happen when we switched to module"
      }
    ]
  },
  {
    "number": 12547,
    "title": "Can't use $add aggregation inside FindOneAndUpdate",
    "created_at": "2022-10-12T13:35:36Z",
    "closed_at": "2022-10-13T19:58:24Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12547",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.2.9\n\n### Node.js version\n\nv16.14.2\n\n### MongoDB version\n\n5.0.6 Community\n\n### Operating system\n\nWindows\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n11\n\n### Issue\n\nI am getting this error with my findOneAndUpdate\r\n\r\n```\r\n'Cast to Number failed for value \"{ '$add': [ '$val', 20 ] }\" (type Object) at path \"volume\"'\r\n```\r\n\r\nHere is the object that is passed into the query\r\n```js\r\nlet dtoWithTrade: any = {\r\n  ...stockDto, volume: {\r\n    \"$add\": [\"$val\", Number(stockDto!.volume)]\r\n  }\r\n}\r\nawait this.executeEdit(dtoWithTrade, reject, resolve);\r\n```\r\nstockDto is just a type with some values, nothing that will impact this query.\r\n\r\nHere is the find and update:\r\n```js\r\nStock.findOneAndUpdate(stockDto.id ? { _id: stockDto.id } : { symbol: stockDto.symbol }, stockDto, { new: true })\r\n```\r\nwhere stockDto has the following form:\r\n```js\r\n{\r\n  id: \"6346c2301dc804d795c09fef\",\r\n  volume: {\r\n    $add: [\r\n      \"$val\",\r\n      20,\r\n    ],\r\n  },\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12547/comments",
    "author": "adamcole123",
    "comments": [
      {
        "user": "samuelastech",
        "created_at": "2022-10-13T19:40:06Z",
        "body": "A similar issue can be found in #12543"
      },
      {
        "user": "adamcole123",
        "created_at": "2022-10-13T19:58:24Z",
        "body": "I used `$inc` instead and it worked perfectly"
      }
    ]
  },
  {
    "number": 12428,
    "title": "Mongoose 5.13.5 has node_moduels/@types/mongodb version 3.6",
    "created_at": "2022-09-14T07:18:23Z",
    "closed_at": "2022-10-06T00:27:06Z",
    "labels": [
      "help",
      "help wanted",
      "Stale"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12428",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n5.13.5\r\n\r\n### Node.js version\r\n\r\n16.17\r\n\r\n### MongoDB version\r\n\r\n4.9.1\r\n\r\n### Operating system\r\n\r\nWindows\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n_No response_\r\n\r\n### Issue\r\n\r\nInside the mongoose node_modules I have a folder of node_modules holds the @types/mongodb of version 3.6 somehow.\r\n\r\nThis causing me issues with:\r\n\r\n```\r\nlet objects: mongodb.FindCursor<TCacheItem<K, T>> ->> return FindCursor/AbstractCursor\r\nWhile:\r\n objects = await this._collection.find({}).project({_id: 0}); --> return Cursor\r\n```\r\n \r\nThe find function comes from the \r\n`node-mongodb-native/3.6/api/Collection.html#find`\r\n\r\nAny explanation?\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12428/comments",
    "author": "Amitcoh1",
    "comments": [
      {
        "user": "IslandRhythms",
        "created_at": "2022-09-14T15:52:16Z",
        "body": "Can you upgrade to latest mongoose version?"
      },
      {
        "user": "hasezoey",
        "created_at": "2022-09-15T08:33:47Z",
        "body": "i dont quite understand the issue, but just some notes:\r\nmongodb 3.6 does not have its own types so there is a `@types/mongodb` package, only since mongodb 4.0 does it have its own types\r\n\r\nfrom what i can tell, `.find` in mongodb is meant to return a `Cursor`, which in 4.0 got renamed to `FindCursor`\r\n\r\ni also dont quite understand the context of the code-sample supplied, but assuming from the types, you are trying to assign a mongodb 3.6 type to a mongodb 4.0 types, which are not compatible\r\nif you want to use mongodb 4.0, you need to upgrade mongoose to at least 6.0 (or downgrade your own mongodb package to 3.6)"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2022-09-30T00:34:39Z",
        "body": "This issue is stale because it has been open 14 days with no activity. Remove stale label or comment or this will be closed in 5 days"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2022-10-06T00:27:05Z",
        "body": "This issue was closed because it has been inactive for 19 days since being marked as stale."
      }
    ]
  },
  {
    "number": 12296,
    "title": "Aggregate search returns empty array for Atlas full text search",
    "created_at": "2022-08-19T04:02:54Z",
    "closed_at": "2022-09-13T00:24:35Z",
    "labels": [
      "help",
      "help wanted",
      "Stale"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12296",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.2.7\n\n### Node.js version\n\n14.17.5\n\n### MongoDB version\n\n5.0.10\n\n### Operating system\n\nmacOS\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n11.5.1\n\n### Issue\n\nI have a MongoDB Atlas database which I access through Mongoose in my code. I would like to use the full text search function in Atlas by using Mongoose aggregate function:\r\n```\r\nlet results = await Player.aggregate().search({\r\n   text: {\r\n      query: keyword,\r\n      path: \"playerHltvUrlName\",\r\n   },\r\n});\r\n```\r\nThis code returns empty array. I enabled the Mongoose debug and the MongoDB command appears in console. \r\n```\r\nMongoose: players.aggregate([ { '$search': { text: { query: 's1mple', path: 'playerHltvUrlName' } } }], {})\r\n```\r\nTyping the same command through the Shell client returns a document and not empty array. Why does apparantly the same command in the same circumstances work in one case (Mongo Shell) and not the other (Mongoose)?",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12296/comments",
    "author": "villaincs",
    "comments": [
      {
        "user": "github-actions[bot]",
        "created_at": "2022-09-08T00:22:59Z",
        "body": "This issue is stale because it has been open 14 days with no activity. Remove stale label or comment or this will be closed in 5 days"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2022-09-13T00:24:35Z",
        "body": "This issue was closed because it has been inactive for 19 days since being marked as stale."
      }
    ]
  },
  {
    "number": 12238,
    "title": "Chaining a Mongoose Query returned by an async function",
    "created_at": "2022-08-08T16:31:03Z",
    "closed_at": "2022-08-09T09:06:48Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12238",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n6.3.3\r\n\r\n### Node.js version\r\n\r\n18.6.0\r\n\r\n### MongoDB version\r\n\r\n5.0.10\r\n\r\n### Operating system\r\n\r\nWindows\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n_No response_\r\n\r\n### Issue\r\n\r\nLet's say we have the following method defined on a Schema:\r\n```js\r\nasync method() {\r\n  // do async stuff first, then\r\n  return this.constructor.find();\r\n}\r\n```\r\n\r\nChaining on an async method will return an error:\r\n```js\r\nconst model = new Model();\r\nawait model.method().populate('field').exec();\r\n// throws .populate is not a function\r\nawait (await model.method()).populate('field').exec();\r\n// same\r\n```\r\n\r\nI understand that the error is thrown because `model.method()` won't return a Mongoose Query, but instantiated documents.\r\n\r\nI'm not sure why the query has been executed, but I guess it has to do with Mongoose internally calling exec for pending queries when there is a change in the event loop or something like that.\r\n\r\nHow can I properly chain the `populate` call here? Is there an option to delay the execution?\r\n\r\n`method` needs to be async because async stuff actually happens inside, besides the `find` call.\r\n\r\nThanks!\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12238/comments",
    "author": "jeanbmar",
    "comments": [
      {
        "user": "imranbarbhuiya",
        "created_at": "2022-08-09T08:26:40Z",
        "body": "You can do it by returning an object or array. I don't think simply returning the query will work as `await` will call `then` on query and it'll execute the query.\r\n\r\n```ts\r\nasync method() {\r\n  // do async stuff first, then\r\n  return {find: this.constructor.find()};\r\n}\r\n```\r\n\r\n```ts\r\nconst model = new Model();\r\nawait (await model.method()).find.populate('field').exec();\r\n```"
      },
      {
        "user": "jeanbmar",
        "created_at": "2022-08-09T08:52:28Z",
        "body": "Thank you for your answer :).\r\n\r\nNow I see, the Query thenable returned by `method` is \"resolved\" like a regular promise, which triggers query execution.\r\nI wonder if there is a pretty workaround for this.\r\nWrapping the object like you propose totally works but it kind of breaks the chaining since the result has to be unwrapped.\r\n"
      },
      {
        "user": "jeanbmar",
        "created_at": "2022-08-09T09:06:48Z",
        "body": "At best we can `await (await model.method()).populate('field').exec();` if we set the thenable to undefined in the `method` function.\r\nBut it comes with side effects and the syntax is still not ideal anyway.\r\nThere's no magic to chain from a Promise but this is regular Promise stuff!"
      }
    ]
  },
  {
    "number": 12228,
    "title": "Program completely exits after Mongoose receives an error. No method of error handling prevents this.",
    "created_at": "2022-08-08T07:52:49Z",
    "closed_at": "2022-08-22T00:12:45Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12228",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.3.4\n\n### Node.js version\n\n18.6.0\n\n### MongoDB version\n\n4.4\n\n### Operating system\n\nLinux\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n20.04\n\n### Issue\n\nTo summarize this issue, it's basically causing my program to exit or crash when an error is thrown by mongoose. When I first encountered this error, I tried fitting my program with more error handling. However, after all the effort the program still crashes from an error that is thrown. I think it's because somewhere where an error isn't handled but I can't seem to find where that is.\r\n\r\nThis is my database module, and the way I error handle.\r\n```js\r\nimport { Console } from 'console'\r\nimport mongoose from 'mongoose'\r\nimport Logger from '../util/logger'\r\n\r\nconst logger = new Logger(`Worker/${process.pid}/database/site`)\r\n\r\nconst schemas = {\r\n  sitemeta: new mongoose.Schema({\r\n    setting: { type: String },\r\n    data: { type: Object }\r\n  }, { collection: 'site-meta' }),\r\n  project: new mongoose.Schema({\r\n    project_name: { type: String },\r\n    description: { type: String },\r\n    project_short_name: { type: String },\r\n    side_project: { type: Boolean },\r\n    project_body: { type: String },\r\n    thumbnail_source: { type: String }\r\n  }, { collection: 'projects' }),\r\n  admin: new mongoose.Schema({\r\n    key_hash: { type: String },\r\n    key_identifier: { type: String }\r\n  }, { collection: 'admins' })\r\n}\r\n\r\nasync function dbConnect () {\r\n  try {\r\n    await mongoose.connect(process.env.MONGODB!, { dbName: 'site' })\r\n    mongoose.connection\r\n      .on('error', () => logger.error('db error occured'))\r\n      .once('open', () => logger.log('Connected to database'))\r\n  } catch {\r\n    logger.error('DB connect fail')\r\n  }\r\n}\r\n\r\ndbConnect()\r\n\r\nconst SiteMeta = mongoose.model('site-meta', schemas.sitemeta)\r\nconst Project = mongoose.model('projects', schemas.project)\r\nconst Admin = mongoose.model('admins', schemas.admin)\r\n\r\nexport { SiteMeta, Project, Admin }\r\n\r\n```\r\n\r\nIn order to test this, I an purposely shutting off my MongoDB server instance and then starting the app and watching the console. This is the error that I get:\r\n```\r\n/home/myusr/website-core/node_modules/mongodb/src/sdam/topology.ts:606\r\n        const timeoutError = new MongoServerSelectionError(\r\n                             ^\r\nMongoServerSelectionError: connect ECONNREFUSED MYIP:PORT\r\n    at Timeout._onTimeout (/home/myusr/website-core/node_modules/mongodb/src/sdam/topology.ts:606:30)\r\n    at listOnTimeout (node:internal/timers:564:17)\r\n    at processTimers (node:internal/timers:507:7) {\r\n  reason: TopologyDescription {\r\n    type: 'Unknown',\r\n    servers: Map(1) { 'wonik-server.ddns.net:4823' => [ServerDescription] },\r\n    stale: false,\r\n    compatible: true,\r\n    heartbeatFrequencyMS: 10000,\r\n    localThresholdMS: 15,\r\n    logicalSessionTimeoutMinutes: undefined\r\n  },\r\n  code: undefined,\r\n  [Symbol(errorLabels)]: Set(0) {}\r\n}\r\n```\r\nHowever, \"DB connect fail\" is being written to the console from the catch on line 33. Which means it's at least handling  the error. However for some reason the app still crashes.\r\n\r\nFull log:\r\n```\r\n[ERROR] [08/08/2022, 03:46:14][wonik-website-core/Worker/8955/database/site] DB connect fail\r\n/home/myusr/website-core/node_modules/mongodb/src/sdam/topology.ts:606\r\n        const timeoutError = new MongoServerSelectionError(\r\n                             ^\r\nMongoServerSelectionError: connect ECONNREFUSED MYIP:PORT\r\n    at Timeout._onTimeout (/home/myusr/website-core/node_modules/mongodb/src/sdam/topology.ts:606:30)\r\n    at listOnTimeout (node:internal/timers:564:17)\r\n    at processTimers (node:internal/timers:507:7) {\r\n  reason: TopologyDescription {\r\n    type: 'Unknown',\r\n    servers: Map(1) { 'wonik-server.ddns.net:4823' => [ServerDescription] },\r\n    stale: false,\r\n    compatible: true,\r\n    heartbeatFrequencyMS: 10000,\r\n    localThresholdMS: 15,\r\n    logicalSessionTimeoutMinutes: undefined\r\n  },\r\n  code: undefined,\r\n  [Symbol(errorLabels)]: Set(0) {}\r\n}\r\n[nodemon] app crashed - waiting for file changes before starting...\r\n```\r\nI need help finding a solution to error handling which prevents mongoose from crashing my app. Thanks in advance!",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12228/comments",
    "author": "dxataclub",
    "comments": [
      {
        "user": "Mumbarun",
        "created_at": "2023-09-12T14:48:13Z",
        "body": "I've the same issue, any advice on how to resolve this?\r\n\r\nThanks in advance"
      },
      {
        "user": "vkarpov15",
        "created_at": "2023-09-25T16:48:30Z",
        "body": "@Mumbarun please open a new issue and follow the issue template"
      }
    ]
  },
  {
    "number": 12227,
    "title": "Returning the documents that were upserted from a BulkWrite operation",
    "created_at": "2022-08-08T07:39:33Z",
    "closed_at": "2022-09-02T07:22:35Z",
    "labels": [
      "help",
      "help wanted",
      "Stale"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12227",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.5.1\n\n### Node.js version\n\n18.7.0\n\n### MongoDB version\n\n6.0.0\n\n### Operating system\n\nmacOS\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n12.5\n\n### Issue\n\nI am trying to return the documents that were upserted from a bulkwrite operation but it doesn't work. So here is the code in JS:\r\n\r\n```javascript\r\nimport Product from '../models/product.model';\r\nimport { values } from 'lodash';\r\nlet results = []; // this is an array of records to be upserted into the DB, it is not empty\r\nlet result = {}\r\nProduct.bulkWrite(\r\n            results.map((aproduct) => \r\n              ({\r\n                updateOne: {\r\n                  filter: {id : aproduct.id},\r\n                  update: {$set: aproduct},\r\n                  upsert: true\r\n                }\r\n              })\r\n            )\r\n          ).then(results => {\r\n             // Trying to fetch the documents that have been upserted by the BulkWrite operation\r\n             Product.find({'_id': { $in: values(results.upsertedIds)}}).then(function(docs) {\r\n                console.info(\"UPSERTED DOCS: \", docs);\r\n                result.upsertedDocuments = docs;\r\n                console.info(\"Merged Results: \", result);\r\n                arrNewIds = docs;\r\n              });\r\n          }\r\n      }\r\n\r\n// The issue is that from this line, the result object is empty despite being populated in the then as shown above.\r\n// The expected result would have been\r\n// result.upsertedDocuments to hold the upserted documents but it doesn't seem to be case despite the very same variable being populated in the then function\r\n```",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12227/comments",
    "author": "franclin",
    "comments": [
      {
        "user": "mssodhi",
        "created_at": "2022-08-18T04:25:55Z",
        "body": "@franclin try changing your _id filter to `_id: { $in: results.getUpsertedIds().map(({ _id }) => _id) }`"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2022-09-02T00:20:20Z",
        "body": "This issue is stale because it has been open 14 days with no activity. Remove stale label or comment or this will be closed in 5 days"
      }
    ]
  },
  {
    "number": 12127,
    "title": "Typing issues: FilterQuery<T> and UpdateQuery<T> do not give appropriate errors",
    "created_at": "2022-07-20T01:29:41Z",
    "closed_at": "2022-07-23T02:17:38Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12127",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n6.4.5\r\n\r\n### Node.js version\r\n\r\n16.14.2\r\n\r\n### MongoDB version\r\n\r\n5.0.6\r\n\r\n### Operating system\r\n\r\nmacOS\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n12.2\r\n\r\n### Issue\r\n\r\n```ts\r\nimport {Schema, model, Types} from 'mongoose';\r\n\r\n// User Object\r\nexport interface IUser {\r\n    _id: Types.ObjectId;\r\n    userName: string;\r\n    email: string;\r\n    age: number;\r\n}\r\nconst userSchema = new Schema<IUser>({\r\n    userName: {\r\n        type: String,\r\n        required: true,\r\n        unique: true\r\n    },\r\n    email: {\r\n        type: String,\r\n        required: true,\r\n        unique: true,\r\n    },\r\n    age: {type: Number}\r\n});\r\nconst User = model<IUser>('User', userSchema);\r\n// end User Object\r\n\r\n// Call Object\r\nexport interface ICall {\r\n    _id: Types.ObjectId;\r\n    callID: string;\r\n    user: Types.ObjectId;\r\n}\r\nconst callSchema = new Schema<ICall>( {\r\n    callID: {\r\n        type: String,\r\n        required: true,\r\n        unique: true\r\n    },\r\n    user : {\r\n        type: Schema.Types.ObjectId,\r\n        ref: 'User',\r\n        required: true\r\n    }\r\n});\r\nconst Call = model<ICall>('Call', callSchema);\r\n// end call object\r\n\r\n// Example issues:\r\nconst updateUserOne = async (username: string) => {\r\n    const user = await User.findOne(\r\n        {userName: 'myuser',            // BUG: does not trace userName back to IUser\r\n             wrongField: 'test'});          // BUG: doesn't complain that wrongField is not on IUser\r\n    user.email = 'newemail';           // OK: *does* identify email correctly as a field on IUser\r\n    user.invalidField = 'invalid';      // OK: correctly gives error\r\n    user.age = 'hello';                     // OK: gives error that number and string types do not match\r\n    user.save();\r\n}\r\n\r\nconst updateUserTwo = async (username: string) => {\r\n    const user = await User.findOneAndUpdate(\r\n        {userName: 'myuser',             // BUG: same as above\r\n            wrongField: 'test'},             // BUG: same as above\r\n        {email: 'newemail',                 // BUG: does not identify that email is part of IUser\r\n                wrongField: 'test',          // BUG: does not complain that wrongField is not on IUser\r\n                age: 'notanage'}            // BUG: does not complain that age is of type string and not type number\r\n\r\n    );\r\n}\r\n\r\nconst getCallInfo = async (callID: string) => {\r\n    const call = await Call.findOne(\r\n        {callID: 'callID_123',                           // BUG: doesn't recognize callID as a field on ICall\r\n            badField: 'wrongdata'})                // BUG: doesn't give error that badField is not on ICall\r\n    const callWithUser = await call.populate<{user: IUser}>('user');\r\n    console.log(callWithUser.user.wrongField); // OK: correctly identifies error that wrongField is not in IUser\r\n\r\n    // BUG: doesn't say that invalidField does not exist on ICall\r\n    const callWithWrongField = await call.populate<{invalidField: IUser}>('user');\r\n    // (assumes that callWithWrongField.invalidField is of type IUser)\r\n}\r\n```\r\n\r\nAs noted in the comments (\"BUG\"), I cannot get typing to behave as I expect:\r\n- FilterQuery and UpdateQuery do not appropriately trace fields back to the interface definition nor do they produce errors in the above code. This is true both for ts-node compilation of this file and for jetbrains webstorm automatic typing issue identification\r\n- populate does fails to identify attempts to populate invalid fields\r\n\r\nThis is an issue because\r\n- I don't get type errors for invalid field names\r\n- when I use renaming features of the code editor, the UpdateQuery and FilterQuery params are not matched so after rename, e.g., `find()` calls will silently fail.\r\n\r\nAm I doing something wrong? Is there a way to get the typing to work? Or is there another way to deal with this?\r\n\r\nOne possible workaround is to define the FilterQuery and UpdateQuery as types `Partial<IUser>` but that's a lot of extra code writing?",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12127/comments",
    "author": "jsrozner",
    "comments": [
      {
        "user": "jsrozner",
        "created_at": "2022-07-20T15:51:41Z",
        "body": "For the `find()` and `findAndUpdate()` type queries, if I separate the code into two pieces, e.g., \r\n```\r\nconst filter : FilterQuery<IUser> = {// filters here};\r\nconst update : Partial<IUser> = {//field updates here};\r\nawait User.findOneAndUpdate(filter, update);\r\n```\r\nThen I get all the correct expected type behaviors. So two more observations:\r\n1) The first issue (with filter) might be with my code editor (webstorm) rather than an issue with typescript. VScode seems to appropriately match the `FilterQuery` argument correctly.\r\n\r\n2) Update might not ever actually complain because `UpdateQuery<T>`allows arbitrary fields in the type definition (`[other: string]: any`). Hence my use of `Partial<T>` rather than `UpdateQuery<T>` when definining `update` above.\r\n\r\nBut there must be some better way to handle all of this? "
      },
      {
        "user": "vkarpov15",
        "created_at": "2022-07-23T02:17:38Z",
        "body": "The problem is that, for example, the `findOneAndUpdate()` you suggested is almost perfectly valid in Mongoose:\r\n\r\n```ts\r\nconst user = await User.findOneAndUpdate(\r\n        {userName: 'myuser',             // OK: userName is the expected type\r\n            wrongField: 'test'},             // OK: Mongoose either strips the key out or allows the key through depending on `strictQuery`\r\n        {email: 'newemail',                 // OK: `email` is the expected type\r\n                wrongField: 'test',          // OK: Mongoose either strips the key out or allows the key through depending on `strict`\r\n                age: '42'}                       // OK: Mongoose casts string '42' to number 42\r\n\r\n    );\r\n```\r\n\r\nMongoose does a lot of neat type casting and data cleanup at runtime, but it does make it tricky to determine the exactly right set of compile time types that are \"valid\" for whatever your definition of valid is. For example, technically `age` can be a number, a `Number`, a string that contains a number, or an object with a `valueOf()` function that returns a number, and Mongoose will convert it to a number at runtime.\r\n\r\nIf you want extra strictness, you unfortunately need to add it yourself."
      }
    ]
  },
  {
    "number": 12104,
    "title": " UnhandledPromiseRejectionWarning: MongooseServerSelectionError: connect ECONNREFUSED 127.0.0.1:27017",
    "created_at": "2022-07-14T11:18:38Z",
    "closed_at": "2022-07-18T21:27:13Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12104",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n5.11.11\r\n\r\n### Node.js version\r\n\r\n14.18.3\r\n\r\n### MongoDB version\r\n\r\n4.4.12\r\n\r\n### Operating system\r\n\r\n_No response_\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\nw11\r\n\r\n### Issue\r\n\r\nÊàëÊòØÂú®docker ‰∏≠ÈÄöËøádocker-composeÂàõÂª∫ÁöÑmongodb Âíånode È°πÁõÆÔºå\r\n**-- docker-compose.yml**\r\n....\r\ndb:\r\n    # image: mongo:4.4.12-focal\r\n    image: mongo:4.4.12\r\n    container_name: mongodb\r\n    environment: #ËÆæÁΩÆÂ∏∏Èáè Áõ∏ÂΩì‰∫éenv\r\n      MONGO_INITDB_ROOT_USERNAME: admin\r\n      MONGO_INITDB_ROOT_PASSWORD: 12345678\r\n      MONGO_INITDB_DATABASE: navigation\r\n      MONGO_USERNAME: navigation\r\n      MONGO_PASSWORD: 12345678\r\n    volumes:\r\n      - ./mongo/database:/data/db\r\n      - ./mongo/db:/data/localDb # Êú¨Âú∞Êï∞ÊçÆ\r\n      - ./mongo/mongo-init.sh:/docker-entrypoint-initdb.d/mongo-init.sh\r\n      - ./mongo/mongo.conf:/data/configdb/mongo.conf\r\n    command: mongod --config /data/configdb/mongo.conf\r\n    ports:\r\n      - 27017:27017\r\n    restart: always \r\n\r\n  server: \r\n    build: ./ # ËøêË°åDockerfileÂàõÂª∫\r\n    image: server\r\n    container_name: server\r\n    volumes:\r\n      - ./dist:/usr/src/app/dist\r\n      - ./logs:/usr/src/app/logs\r\n    environment:\r\n      - AUTHOR=GRATEFULL\r\n      - DOCKER_ENV=production\r\n    restart: always\r\n    depends_on:\r\n      - db\r\n    links:\r\n      - db\r\n    ports:\r\n      - 3000:3000\r\n     \r\n **-- index.js ËøûÊé•mongodb**\r\n const options = {\r\n      auto_reconnect: true,\r\n      poolSize: 10,\r\n      useNewUrlParser:true,\r\n      useUnifiedTopology:true,\r\n      useFindAndModify:false\r\n  }\r\n  mongoose.connect(dbUrl,options)\r\n\r\n**-- Êä•Èîô**\r\nmongoDB disconnected!\r\nmongoDB error!\r\n(node:43) UnhandledPromiseRejectionWarning: MongooseServerSelectionError: connect ECONNREFUSED 127.0.0.1:27017\r\n    at NativeConnection.Connection.openUri (/usr/src/app/node_modules/mongoose/lib/connection.js:832:32)\r\n    at /usr/src/app/node_modules/mongoose/lib/index.js:345:10\r\n    at /usr/src/app/node_modules/mongoose/lib/helpers/promiseOrCallback.js:31:5\r\n    at new Promise (<anonymous>)\r\n    at promiseOrCallback (/usr/src/app/node_modules/mongoose/lib/helpers/promiseOrCallback.js:30:10)\r\n    at Mongoose._promiseOrCallback (/usr/src/app/node_modules/mongoose/lib/index.js:1135:10)\r\n    at Mongoose.connect (/usr/src/app/node_modules/mongoose/lib/index.js:344:20)\r\n    at Object.<anonymous> (/usr/src/app/models/index.js:18:12)\r\n    at Module._compile (internal/modules/cjs/loader.js:1085:14)\r\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10)\r\n    at Module.load (internal/modules/cjs/loader.js:950:32)\r\n    at Function.Module._load (internal/modules/cjs/loader.js:790:12)\r\n    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:76:12)\r\n    at internal/main/run_main_module.js:17:47",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12104/comments",
    "author": "520Girl",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2022-07-18T21:27:13Z",
        "body": "All this error says is that Mongoose can't connect to MongoDB, which means there's some issue with your Docker config."
      }
    ]
  },
  {
    "number": 12003,
    "title": "Schema type disappears when using InferSchemaType with SchemaOptions",
    "created_at": "2022-06-28T09:46:57Z",
    "closed_at": "2022-06-30T03:55:24Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12003",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.4.1\n\n### Node.js version\n\n14.18.3\n\n### MongoDB version\n\nUnsure\n\n### Operating system\n\nmacOS\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n12.4\n\n### Issue\n\nCreated as empty object type when creating schema type using `InferSchemaType` with `SchemaOptions`\r\n\r\n```typescript\r\nconst baseSchemaOptions: SchemaOptions = {\r\n    versionKey: false,\r\n}\r\n\r\nconst BaseSchema = new Schema({\r\n    name: String\r\n}, baseSchemaOptions);\r\n\r\ntype BaseSchemaType = InferSchemaType<typeof BaseSchema>;\r\n// type BaseSchemaType = {}\r\nconst BaseModel = mongoose.model<BaseSchemaType>(\"Test\", BaseSchema);\r\n// const BaseModel = mongoose.Model<{}, {}, {}, {}, any>\r\n```\r\n\r\nbut without `SchemaOptions`\r\n\r\n```typescript\r\nconst BaseSchema = new Schema({\r\n    name: String\r\n});\r\nBaseSchema.set(\"versionKey\", false);\r\n\r\ntype BaseSchemaType = InferSchemaType<typeof BaseSchema>;\r\n// type BaseSchemaType = { name: string; }\r\nconst BaseModel = mongoose.model<BaseSchemaType>(\"Test\", BaseSchema);\r\n// const BaseModel = mongoose.Model<{ name: string; }, {}, {}, {}, any>\r\n```\r\nIs this type correct?\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12003/comments",
    "author": "jeetkn",
    "comments": [
      {
        "user": "mohammad0-0ahmad",
        "created_at": "2022-06-30T01:44:45Z",
        "body": "@jeetkn  Thanks for reporting this issue.\r\nI will check if we can fix that, but a quick workaround is :\r\n```js\r\nonst BaseSchema = new Schema({\r\n    name: String\r\n}, baseSchemaOptions as any);\r\n```"
      },
      {
        "user": "mohammad0-0ahmad",
        "created_at": "2022-06-30T01:51:30Z",
        "body": "I will create a PR for solving this issue soon, thanks again @jeetkn "
      }
    ]
  },
  {
    "number": 11967,
    "title": "[help] InferSchemaType, accessing _id field",
    "created_at": "2022-06-21T16:07:26Z",
    "closed_at": "2022-07-02T22:32:07Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/11967",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n6.4.0\r\n\r\n### Node.js version\r\n\r\n18.3\r\n\r\n### MongoDB version\r\n\r\nUnsure\r\n\r\n### Operating system\r\n\r\nLinux\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\narch-5.18.5 something\r\n\r\n### Issue\r\n\r\nUsing `InferSchemaType` to create the schema interface type, how do I access the `_id` field? If I put it in the schema definition, I have to also set it explicitly when inserting new documents. If I don't put it there, `InferSchemaType` does not include it in the interface.\r\n\r\nWhat do I do? I'd like to know the same for `.save()` and so on. Am I supposed to do a type union?\r\n\r\nCode:\r\n\r\n```javascript\r\nimport { Document, InferSchemaType, Schema } from \"mongoose\"\r\n\r\nconst mySchema = new Schema({\r\n  foo: { type: String, required: true }\r\n})\r\n\r\ntype MySchemaType_Problematic = InferSchemaType<typeof mySchema>\r\n// MySchemaType_Problematic is missing the _id field along with the save() method etc.\r\n\r\n// Workaround:\r\ntype MySchemaType_Workaround = InferSchemaType<typeof mySchema> & Document\r\n// MySchemaType_Workaround can now be used properly, with _id and save() etc.\r\n```",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/11967/comments",
    "author": "tx46",
    "comments": [
      {
        "user": "mohammad0-0ahmad",
        "created_at": "2022-06-21T21:01:47Z",
        "body": "@philiparvidsson  Thanks for providing this issue.\r\nI would like to say that you can use type union until we can make better integration for _id path.\r\n_id field is quite a special case that, it will take more efforts to improve its typing along entire mongoose.\r\nI am aware of this issue and promise to provide better mechanism for InferSchemaType as soon as possible for all special paths like _id.\r\nBest regards."
      },
      {
        "user": "vkarpov15",
        "created_at": "2022-06-22T02:06:54Z",
        "body": "@philiparvidsson can you please provide some code samples? That would be helpful for me to understand what you're trying to do."
      },
      {
        "user": "tx46",
        "created_at": "2022-06-22T03:48:39Z",
        "body": "I added some example code, providing a brief example of the issue as well as the workaround I'm using."
      },
      {
        "user": "mohammad0-0ahmad",
        "created_at": "2022-06-23T00:57:41Z",
        "body": "@philiparvidsson  InferSchemaType meant to be a helper to infer schema defenition type.\nSo It will not return a document function but it will obtain paths type.\nAs I descriped _id property it is not added yet because there it a default path in the schema.\nDo you need to use these types within mongoose code or you obtain the type of schema for another usecase?\n\nCan you please provide more details to be able to help maybe?"
      },
      {
        "user": "tx46",
        "created_at": "2022-06-23T03:14:21Z",
        "body": "In this particular case, I'm passing a MySchemaType_Problematic to a factory function. If the factory cannot generate the needed type, it needs to log that it did not understand the data it received. So I tried to do: log.error(`Factory was unable to create instance for {mySchemaType._id}`)\r\n\r\nBut it doesn't work since the type doesn't have an id. I guess I could cast it to any because I know for a fact that _id is there, but that defeats the purpose of having any type on it to begin with."
      },
      {
        "user": "tx46",
        "created_at": "2022-06-23T09:13:52Z",
        "body": "Another thing that I suspsect is a bug: Setting the type of a field (in the schema) to mongoose.Schema.Types.ObjectId gives the wrong type in the inferred type. E.g.,\r\n\r\nconst mySchema = ...({ _id: mongoose.Schema.Types.ObjectId })\r\ntype MyType = InferSchemaType<typeof mySchema>\r\n\r\nconst a: MyType = { _id: new mongoose.Types.ObjectId(\"...\") }\r\n\r\nFails, because it is expecting to be assigned a mongoose.schema.Types.ObjectId (which is the \"metatype\" here, so there is no way I can use that type for assigning anything).\r\n\r\nTL;DR: mongoose.Schema.Types.ObjectId should be inferred to mongoose.Types.ObjectId for fields"
      },
      {
        "user": "vkarpov15",
        "created_at": "2022-07-02T22:32:07Z",
        "body": "From OP, I'd recommend doing:\r\n\r\n```ts\r\ntype MySchemaType_Workaround = HydratedDocument<InferSchemaType<typeof mySchema>>\r\n```\r\n\r\nFor \"TL;DR: mongoose.Schema.Types.ObjectId should be inferred to mongoose.Types.ObjectId for fields\", this was fixed in 6.4.2 with #12007.\r\n\r\nThose two issues are fixed, and there aren't enough code samples for this to be actionable. So I'm going to close this. Please re-open with a complete code sample that we can run to demonstrate the issue you're seeing, if you're still having issues."
      }
    ]
  },
  {
    "number": 11941,
    "title": "What would happen if i call this.save() inside post save hook?",
    "created_at": "2022-06-16T19:25:59Z",
    "closed_at": "2022-06-17T19:50:25Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/11941",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n5.9.20\n\n### Node.js version\n\n16.15.1\n\n### MongoDB version\n\n5.0\n\n### Operating system\n\nWindows\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n10\n\n### Issue\n\nHi, I have found a problem in a codebase where a i get a DocumentNotFoundError because of searching for a document that has already being deleted. The code had this:\r\n\r\n```js\r\nenrollmentSchema.post(\"save\", function () {\r\n this.save();\r\n});\r\n``` \r\nCommenting that code seems to solve the issue but i dont understand why exactly and also why that doesnt make an infinite loop. The error doesnt tell me what exact line threw it so im searching for the bug blindly. Any suggestions?",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/11941/comments",
    "author": "angelhodar",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2022-06-17T19:50:25Z",
        "body": "```\r\nenrollmentSchema.post(\"save\", function () {\r\n this.save();\r\n});\r\n```\r\n\r\nThat would cause an infinite loop, but a hard to catch infinite loop because you aren't doing `return this.save()`. As structured, that post hook causes an infinite loop that fires off a new `save()` at every tick of the event loop, but never causes a stack overflow."
      },
      {
        "user": "angelhodar",
        "created_at": "2022-06-17T20:19:26Z",
        "body": "@vkarpov15 So if I put a console.log(\"Saved\") in the callback for the save function when it succcess, it should flood the console with the Saved message on every tick? Because I have tried that and thats not what happens. It just shows the message when i call save outside of the middleware shown above. Thats the part i dont understand"
      },
      {
        "user": "vkarpov15",
        "created_at": "2022-06-17T20:26:40Z",
        "body": "@angelhodar that's strange. Can you provide a more complete code sample?"
      }
    ]
  },
  {
    "number": 11938,
    "title": "Set model for many schemas in the same file",
    "created_at": "2022-06-15T09:00:44Z",
    "closed_at": "2022-06-15T21:53:17Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/11938",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n6.3.8\r\n\r\n### Node.js version\r\n\r\n16.13.2\r\n\r\n### MongoDB version\r\n\r\n5.0.6\r\n\r\n### Operating system\r\n\r\n_No response_\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n_No response_\r\n\r\n### Issue\r\n\r\nWhen I created two different schemas related to the model (via optional param in schema object), I accepted an error that shows a Mongoose did override the name of each model, despite these being two separate collections with unique names. \r\nThe following code is related to the scenario: \r\n```\r\nconst mongoose = require('mongoose');\r\nconst st_schema = new mongoose.Schema({\r\n    name: String,\r\n    degree: String\r\n}, {collection: 'students'});\r\nconst st_model = mongoose.model('',st_schema);\r\nconst dpt_schema = new mongoose.Schema({\r\n    name: String,\r\n    num_students: Number\r\n}, {collection: 'departments'});\r\nconst dpt_model = mongoose.model('',dpt_schema);\r\n```\r\n**The error: OverwriteModelError: Cannot overwrite \"\" model once compiled.**\r\nI assumed that cause uses the same variable (const mongoose.). \r\nWe have other roads to define the model, but I would like to learn more details about a specific scenario. \r\nPay attention to the collection of defined \"Inline\" schema variables and the same file.",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/11938/comments",
    "author": "GalO005",
    "comments": [
      {
        "user": "Uzlopak",
        "created_at": "2022-06-15T11:45:34Z",
        "body": "Well. No.it is because the first argument of model is the same\r\n\r\nI would probably do it like this:\r\n\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nconst st_schema = new mongoose.Schema({\r\n    name: String,\r\n    degree: String\r\n}, {collection: 'students'});\r\nconst st_model = mongoose.model('st',st_schema, 'students');\r\nconst dpt_schema = new mongoose.Schema({\r\n    name: String,\r\n    num_students: Number\r\n}, {collection: 'departments'});\r\nconst dpt_model = mongoose.model('dpt',dpt_schema, 'departments');\r\n```"
      },
      {
        "user": "GalO005",
        "created_at": "2022-06-15T21:40:58Z",
        "body": "So, where is the advantage of defining collection in the schema? \r\nI see that we have duplicate declarations. Right?  @Uzlopak "
      },
      {
        "user": "Uzlopak",
        "created_at": "2022-06-15T21:45:23Z",
        "body": "Idk, for me it is actually also new that you can define collection in Schemas. Lol. I usually define that on the model, how i showed it to you."
      },
      {
        "user": "GalO005",
        "created_at": "2022-06-15T21:53:17Z",
        "body": "Yes, I know your technique.\r\nThanks. "
      }
    ]
  },
  {
    "number": 11894,
    "title": "Sorting a field defined by setters and getters returns in a seemingly random order",
    "created_at": "2022-06-04T02:00:11Z",
    "closed_at": "2022-06-06T18:48:14Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/11894",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.2.9\n\n### Node.js version\n\n14.15.4\n\n### MongoDB version\n\n5.0\n\n### Operating system\n\nWindows\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n11\n\n### Issue\n\nI have the following operation and schema\r\n```js\r\nStock.find({\r\n  volume: {\r\n    $gt: 0,\r\n  },\r\n})\r\n.skip(0)\r\n.limit(1002)\r\n.sort([\r\n  [\"gains\",1,],\r\n])\r\n```\r\n\r\n```js\r\nimport mongoose from \"mongoose\";\r\nimport Stock from '../../usecases/entities/Stock';\r\nimport Double from '@mongoosejs/double';\r\nvar Schema = mongoose.Schema;\r\n\r\nconst stockSchema = new Schema<Stock>({\r\n\tid: mongoose.SchemaTypes.ObjectId,\r\n\tsymbol: String,\r\n\tname: String,\r\n\tvalue: Double,\r\n\tvolume: Number,\r\n\topen: Double,\r\n\tclose: Double,\r\n\tlatest_trade: Date,\r\n\tgains: {\r\n\t\ttype: Double,\r\n\t\tdefault: calcGains,\r\n\t\tget: calcGains,\r\n\t\tset: calcGains,\r\n\t}\r\n}, { collection: 'stocks' })\r\n\r\nfunction calcGains (this: Stock) {\r\n\treturn this.value! - this.open!;\r\n};\r\n\r\nexport default stockSchema;\r\n```\r\n\r\nThe resulting order of results is seemingly random:\r\n```js\r\n[\r\n  {\r\n    id: \"629698605b83c6484b0685f7\",\r\n    symbol: \"test2\",\r\n    name: \"test2\",\r\n    value: {\r\n      value: 805.18,\r\n      _bsontype: \"Double\",\r\n    },\r\n    volume: 89821,\r\n    open: {\r\n      value: 191.66,\r\n      _bsontype: \"Double\",\r\n    },\r\n    close: {\r\n      value: 876.77,\r\n      _bsontype: \"Double\",\r\n    },\r\n    latest_trade: undefined,\r\n    gains: 613.52,\r\n  },\r\n  {\r\n    id: \"626c4abf9d070f119597aa27\",\r\n    symbol: \"WPT\",\r\n    name: \"Zoozzy\",\r\n    value: {\r\n      value: 605.69,\r\n      _bsontype: \"Double\",\r\n    },\r\n    volume: 700519253,\r\n    open: {\r\n      value: 202.55,\r\n      _bsontype: \"Double\",\r\n    },\r\n    close: {\r\n      value: 835.27,\r\n      _bsontype: \"Double\",\r\n    },\r\n    latest_trade: undefined,\r\n    gains: 403.14000000000004,\r\n  },\r\n  {\r\n    id: \"626c4abf9d070f119597aaae\",\r\n    symbol: \"SYPR\",\r\n    name: \"Zoozzy\",\r\n    value: {\r\n      value: 221.2,\r\n      _bsontype: \"Double\",\r\n    },\r\n    volume: 170786391,\r\n    open: {\r\n      value: 347.28,\r\n      _bsontype: \"Double\",\r\n    },\r\n    close: {\r\n      value: 325.65,\r\n      _bsontype: \"Double\",\r\n    },\r\n    latest_trade: undefined,\r\n    gains: -126.07999999999998,\r\n  },\r\n  {\r\n    id: \"626c4abf9d070f119597ac7d\",\r\n    symbol: \"CIM^A\",\r\n    name: \"Zoozzy\",\r\n    value: {\r\n      value: 633.43,\r\n      _bsontype: \"Double\",\r\n    },\r\n    volume: 762921526,\r\n    open: {\r\n      value: 999.61,\r\n      _bsontype: \"Double\",\r\n    },\r\n    close: {\r\n      value: 551.19,\r\n      _bsontype: \"Double\",\r\n    },\r\n    latest_trade: undefined,\r\n    gains: -366.18000000000006,\r\n  },\r\n  {\r\n    id: \"626c4abf9d070f119597adb6\",\r\n    symbol: \"VSAR\",\r\n    name: \"Zooxo\",\r\n    value: {\r\n      value: 815.78,\r\n      _bsontype: \"Double\",\r\n    },\r\n    volume: 506945404,\r\n    open: {\r\n      value: 739.53,\r\n      _bsontype: \"Double\",\r\n    },\r\n    close: {\r\n      value: 295.73,\r\n      _bsontype: \"Double\",\r\n    },\r\n    latest_trade: undefined,\r\n    gains: 76.25,\r\n  },\r\n  {\r\n    id: \"626c4abf9d070f119597abcc\",\r\n    symbol: \"MTFB\",\r\n    name: \"Zooxo\",\r\n    value: {\r\n      value: 316.65,\r\n      _bsontype: \"Double\",\r\n    },\r\n    volume: 569762868,\r\n    open: {\r\n      value: 126.96,\r\n      _bsontype: \"Double\",\r\n    },\r\n    close: {\r\n      value: 178.37,\r\n      _bsontype: \"Double\",\r\n    },\r\n    latest_trade: undefined,\r\n    gains: 189.69,\r\n  },\r\n  {\r\n    id: \"626c4abf9d070f119597ab11\",\r\n    symbol: \"PAYX\",\r\n    name: \"Zoovu\",\r\n    value: {\r\n      value: 13.85,\r\n      _bsontype: \"Double\",\r\n    },\r\n    volume: 853804568,\r\n    open: {\r\n      value: 836.02,\r\n      _bsontype: \"Double\",\r\n    },\r\n    close: {\r\n      value: 135.61,\r\n      _bsontype: \"Double\",\r\n    },\r\n    latest_trade: undefined,\r\n    gains: -822.17,\r\n  }\r\n]\r\n``` \r\n\r\nNotice how the `gains` value isn't going in any order.\r\n\r\nWhen I replace the gains field with any other field then it sorts perfectly fine, so i suspect the problem is with my schema.\r\n\r\nAny ideas?",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/11894/comments",
    "author": "adamcole123",
    "comments": [
      {
        "user": "Uzlopak",
        "created_at": "2022-06-04T07:00:28Z",
        "body": ".sort should accept an Object and not an Array. So try `{ gains: 1}`. And i know it doesnt matter for queries but always do the sort before the skip and limit."
      },
      {
        "user": "adamcole123",
        "created_at": "2022-06-04T12:51:41Z",
        "body": "@Uzlopak I adjusted my logic so that it looks like this\r\n\r\n```js\r\nlet sort: {[key: string]: number} = {};\r\n\r\nif(options.order !== undefined && \r\n  options.order.orderBy !== undefined && \r\n  options.order.orderDirection !== undefined){\r\n  sort[options!.order!.orderBy!] = options?.order?.orderDirection === 0 ? -1 : 1;\r\n}\r\n```\r\n```js\r\nlet returnStocks = await Stock\r\n\t\t\t.find({ ...query })\r\n\t\t\t.sort(sort)\r\n\t\t\t.skip((options?.page * options.limit!) - (options.limit!))\r\n\t\t\t.limit(options.limit!);\r\n```\r\n\r\nand it still doesnt seem to be sorting correctly. Do you know if sorting works with these sort of getters and setters in the schema?\r\n\r\n(Keep in mind that this works with any other field in this schema)\r\n"
      },
      {
        "user": "adamcole123",
        "created_at": "2022-06-06T18:48:14Z",
        "body": "I changed my schema to this and it seemed to do the trick for my needs\r\n\r\n```js\r\nconst stockSchema = new Schema<Stock>({\r\n\tid: mongoose.SchemaTypes.ObjectId,\r\n\tsymbol: String,\r\n\tname: String,\r\n\tvalue: {\r\n\t\ttype: Double,\r\n\t\tmin: 0,\r\n\t},\r\n\tvolume: Number,\r\n\topen: {\r\n\t\ttype: Double,\r\n\t\tdefault: 0.0\r\n\t},\r\n\tclose: {\r\n\t\ttype: Double,\r\n\t\tdefault: 0.0\r\n\t},\r\n\tlatest_trade: Date,\r\n\tgains: {\r\n\t\ttype: Double,\r\n\t\tdefault: 0.0,\r\n\t}\r\n}, { collection: 'stocks' })\r\n\r\nstockSchema.pre('save', function (next) {\r\n    this.gains = calcGains(this.get('value'), this.get('open'));\r\n    next();\r\n});\r\n\r\nfunction calcGains (value: number, open: number) {\r\n\treturn Number.parseFloat((value! - open!).toFixed(2))!;\r\n};\r\n\r\nexport default stockSchema;\r\n```"
      },
      {
        "user": "Uzlopak",
        "created_at": "2022-06-07T05:31:30Z",
        "body": "Yes. Makes sense. You now store the value into collection so mongodb can sort."
      }
    ]
  },
  {
    "number": 11859,
    "title": "why are mongod to nodejs connections bidirectional, doubling the amount of connections in total?",
    "created_at": "2022-05-30T20:07:14Z",
    "closed_at": "2022-06-10T22:07:00Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/11859",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.2.2\n\n### Node.js version\n\nv17.3.1\n\n### MongoDB version\n\nv4.4.7\n\n### Operating system\n\n_No response_\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\nubuntu 18\n\n### Issue\n\ni'm connecting to mongodb through mongoose, from nodejs server, using this line:\r\n\r\n        mongoose.createConnection(`${uri}`,{dbName:\"user\",server: {poolSize : 1}});\r\n        mongoose.createConnection(`${uri}`,{dbName:\"db2\",server: {poolSize : 1}});\r\n\r\ncuriously when i inspect TCP connection in linux terminal, using `lsof -i tcp:27017` , i found that for each connection between nodejs and mongodb server, there are TWO(???) TCP connections, which doubles the amount of connections needed.\r\n\r\nI have the screenshot here. \r\n\r\n```\r\n    COMMAND     PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME\r\n    mongod      779 root    5u  IPv4 1078325      0t0  TCP localhost:27017->localhost:42688 (ESTABLISHED)\r\n    mongod      779 root   11u  IPv4   19794      0t0  TCP localhost:27017 (LISTEN)\r\n    mongod      779 root   46u  IPv4 1078335      0t0  TCP localhost:27017->localhost:42692 (ESTABLISHED)\r\n    mongod      779 root   48u  IPv4 1077657      0t0  TCP localhost:27017->localhost:42698 (ESTABLISHED)\r\n    mongod      779 root   72u  IPv4 1042013      0t0  TCP localhost:27017->localhost:41086 (ESTABLISHED)\r\n    mongod      779 root   74u  IPv4 1042015      0t0  TCP localhost:27017->localhost:41088 (ESTABLISHED)\r\n    mongod      779 root  129u  IPv4  721690      0t0  TCP localhost:27017->localhost:53000 (ESTABLISHED)\r\n    mongod      779 root  133u  IPv4  721692      0t0  TCP localhost:27017->localhost:53002 (ESTABLISHED)\r\n    mongod      779 root  142u  IPv4  758478      0t0  TCP localhost:27017->localhost:55034 (ESTABLISHED)\r\n    mongod      779 root  144u  IPv4  758483      0t0  TCP localhost:27017->localhost:55038 (ESTABLISHED)\r\n    sshd      12453 root    8u  IPv4  722486      0t0  TCP localhost:53000->localhost:27017 (ESTABLISHED)\r\n    sshd      12453 root    9u  IPv4  722488      0t0  TCP localhost:53002->localhost:27017 (ESTABLISHED)\r\n    sshd      12453 root   10u  IPv4 1041239      0t0  TCP localhost:41086->localhost:27017 (ESTABLISHED)\r\n    sshd      12453 root   11u  IPv4 1041240      0t0  TCP localhost:41088->localhost:27017 (ESTABLISHED)\r\n    sshd      12453 root   12u  IPv4  759420      0t0  TCP localhost:55034->localhost:27017 (ESTABLISHED)\r\n    sshd      12453 root   13u  IPv4  759431      0t0  TCP localhost:55038->localhost:27017 (ESTABLISHED)\r\n    node\\x20/ 16446 root   20u  IPv4 1077542      0t0  TCP localhost:42692->localhost:27017 (ESTABLISHED)\r\n    node\\x20/ 16446 root   21u  IPv4 1077536      0t0  TCP localhost:42688->localhost:27017 (ESTABLISHED)\r\n    node\\x20/ 16446 root   23u  IPv4 1078433      0t0  TCP localhost:42698->localhost:27017 (ESTABLISHED)\r\n\r\n```\r\nnotice that TCP connections are port [42692, 42688, 42698] are counted twice. \r\n\r\ni also have a few connections made through `sshd`, and clearly they are single connections, just for reference purposes. \r\n\r\ni have a limited amount of con-current connections quota, so the question is, what's wrong here? is it possible to get rid of the doubled connections?\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/11859/comments",
    "author": "martianmartian",
    "comments": [
      {
        "user": "Uzlopak",
        "created_at": "2022-06-01T06:50:13Z",
        "body": "You create two connections."
      },
      {
        "user": "deistermatheus",
        "created_at": "2022-06-02T21:39:27Z",
        "body": "I think you are effectively listing twice because both processes live on the same machine. The amount of connections that would be relevant to your server limit are those owned by mongod, which is the database process.\r\n\r\n"
      },
      {
        "user": "vkarpov15",
        "created_at": "2022-06-10T22:07:00Z",
        "body": "@deistermatheus is right, notice how the \"command\" column lists \"mongod\" for one of the 42692 connections and \"node\" for the other."
      }
    ]
  },
  {
    "number": 5491,
    "title": "Support question - override validation - force insertion to db",
    "created_at": "2017-07-20T19:30:41Z",
    "closed_at": "2017-07-27T00:30:30Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/5491",
    "body": "A quick google search did yield anything - is there a way to do something like this:\r\n\r\n```js\r\n  Prompt.update({'specialId': 'STANDARD_TEXT_RESPONSE'}, {\r\n        '#id': 'NO_LINK',\r\n        'specialId': 'STANDARD_TEXT_RESPONSE',\r\n        'acqId': 'DUMMY_ACQ',\r\n        'parentId': null,\r\n        'kind': 'text',\r\n        'value': '[placeholder text]'\r\n      }, {upsert: true, multi: false, force: true}, cb);   // force is true\r\n\r\n```\r\n(Obviously, \"force\" is probably not a real property on the options object, but just an example.)\r\n\r\nI need to force this into the DB. The validation error is that 'DUMMY_ACQ' cannot be cast to ObjectId, but I would like to ignore that error and force this document into the collection.\r\n\r\nany help appreciated.\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/5491/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "sobafuchs",
        "created_at": "2017-07-22T17:20:59Z",
        "body": "not that i know of. Your best bet is to either create a union type through a discriminator or to make it a Mixed Type (but make sure to manually `markModified()` if you use a Mixed Type and are doing `save` ops)\r\n\r\n@vkarpov15 can you think of a way to do this?"
      },
      {
        "user": "ORESoftware",
        "created_at": "2017-07-22T18:30:03Z",
        "body": "@varunjayaraman thanks, I was reading some older issues and it seems like you can use a plugin or something which simply skips the validation, but still not sure how to do that. But, I would rather be able to skip the validation directly in the context of the `Prompt.update` call."
      },
      {
        "user": "sobafuchs",
        "created_at": "2017-07-26T22:59:00Z",
        "body": "@ORESoftware you could try using the underlying driver and bypassing mongoose for this?"
      },
      {
        "user": "ORESoftware",
        "created_at": "2017-07-27T00:30:30Z",
        "body": "@varunjayaraman yeah I think that's reasonable, thanks"
      }
    ]
  },
  {
    "number": 5214,
    "title": "[BUG] (node:8232) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): MongoError: the limit must be positive",
    "created_at": "2017-05-02T11:56:10Z",
    "closed_at": "2017-05-28T18:13:01Z",
    "labels": [
      "can't reproduce",
      "help wanted",
      "needs clarification"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/5214",
    "body": "Hi,\r\n\r\nI have big application on AWS. unexpectedly it crashed and thrown this error: \r\n\r\n\"(node:8232) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): MongoError: the limit must be positive\"\r\n\r\nCan you tell me when this error occurs? This will help me or not, to write console logs in error callback to catch where is this error?\r\n\r\nP.S. I don't know what happened... I seen this error in 24 hour, after occured.\r\n\r\nEnvironment:\r\n> AWS - Elastic Beanstalk\r\n> 64bit Amazon Linux 2016.09 \r\n> Node.js v6.10.0\r\n> Mongoose v4.7.5\r\n> MongoDB v3.4",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/5214/comments",
    "author": "vkupar",
    "comments": [
      {
        "user": "vkupar",
        "created_at": "2017-05-05T18:48:06Z",
        "body": "Here is more clear error message:\r\n{ MongoError: the limit must be positive\r\n    at Function.MongoError.create (/var/app/current/node_modules/mongodb-core/lib/error.js:31:11)\r\n    at /var/app/current/node_modules/mongodb-core/lib/connection/pool.js:483:72\r\n    at authenticateStragglers (/var/app/current/node_modules/mongodb-core/lib/connection/pool.js:429:16)\r\n    at Connection.messageHandler (/var/app/current/node_modules/mongodb-core/lib/connection/pool.js:463:5)\r\n    at Socket.<anonymous> (/var/app/current/node_modules/mongodb-core/lib/connection/connection.js:317:22)\r\n    at emitOne (events.js:96:13)\r\n    at Socket.emit (events.js:188:7)\r\n    at readableAddChunk (_stream_readable.js:176:18)\r\n    at Socket.Readable.push (_stream_readable.js:134:10)\r\n    at TCP.onread (net.js:548:20)\r\n  name: 'MongoError',\r\n  message: 'the limit must be positive',\r\n  ok: 0,\r\n  errmsg: 'the limit must be positive',\r\n  code: 15958,\r\n  codeName: 'Location15958' }"
      },
      {
        "user": "sobafuchs",
        "created_at": "2017-05-07T22:21:14Z",
        "body": "this is hard to debug without more context. I've seen this error before when `$slice` was used (mongodb aggregation). Do you have more instructive error logs?"
      },
      {
        "user": "vkupar",
        "created_at": "2017-05-08T17:48:00Z",
        "body": "@varunjayaraman Unfortunatelly, only this error logged :/ I have tons of operations in database and I don't know, where and when happened..."
      },
      {
        "user": "sobafuchs",
        "created_at": "2017-05-16T03:45:48Z",
        "body": "I'll keep this open for a little bit longer in case anyone else wants to chime in, but I'll have to close it soon without more context since there's nothing much I can do without a code sample / some context"
      },
      {
        "user": "ShiChenCong",
        "created_at": "2017-07-07T07:18:38Z",
        "body": "i have the same problem"
      },
      {
        "user": "vkarpov15",
        "created_at": "2017-07-11T22:23:48Z",
        "body": "Please provide code sample"
      }
    ]
  },
  {
    "number": 5213,
    "title": "Mongod start not trigger with Mongoose",
    "created_at": "2017-05-01T23:19:22Z",
    "closed_at": "2017-06-11T18:32:31Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/5213",
    "body": "when start the node with connected database, triggers below events,\r\n\r\n```\r\nmongoose.connection.once('open', console.log.bind(console,'connection open !!!!!'));\r\nmongoose.connection.on('connected', console.log.bind(console,'connection connected !!!!!'));\r\n```\r\n\r\nwhen stop the database,triggers below events,\r\n\r\n```\r\nmongoose.connection.on('disconnected', console.log.bind(console,'connection disconnected !!!!!'));\r\nmongoose.connection.on('close',console.log.bind(console,'connection close !!!!!'));\r\n```\r\n\r\nThen again I start the mongodb database\r\n\r\nBut application get hang when trying at access the database even through `reconnectTries` set 1 in the server option\r\n\r\n```\r\nvar options = { server: {reconnectTries: 1,socketOptions: { keepAlive: 300000,connectTimeoutMS: 10000 } } } ; \r\nmongoose.connect(uri,options)\r\n```\r\nbelow is my code block\r\n\r\n```\r\napp.get('/res', function(req, res, next) {\r\n\tvar result;\r\n\tconsole.log('Trying to access the database')\r\n\trootRes.find({}, function (err, result) {\r\n  \tif (err) {\r\n  \t\tconsole.log('Error occur !!!!!!!!!!!!!!!!!!')\r\n  \t};\r\n \tres.json(result);\r\n \t})\r\n});\r\n```\r\n\r\nI'm having experiencing that when we start the mongodb after stop, 'connected' event not triggerd.\r\n`mongoose.connection.on('connected', console.log.bind(console,'connection connected !!!!!'));`\r\n\r\nAny idea about this. Can you please provide some ideas which I don't know.\r\n\r\nI'm using\r\n\"mongoose\": \"4.6.4\"\r\n\"mongod\" :\"3.2.9\"\r\n\r\nThank you\r\n \r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/5213/comments",
    "author": "akudahewa",
    "comments": [
      {
        "user": "houssem-yahiaoui",
        "created_at": "2017-05-13T20:01:36Z",
        "body": "What about your connection string can you show us the full mongoose configuration ?"
      },
      {
        "user": "sobafuchs",
        "created_at": "2017-05-28T18:25:51Z",
        "body": "oops sorry we missed this. Are you still experiencing this issue @akudahewa ?"
      }
    ]
  },
  {
    "number": 5138,
    "title": "Mongoose authentication fail when trying to connect to MongoDB Atlas",
    "created_at": "2017-03-31T17:05:48Z",
    "closed_at": "2017-10-09T14:49:55Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/5138",
    "body": "#4818 Referencing this issue: it's closed but I am still reproducing the same problem.\r\n\r\nMongoose version: `4.9.2`\r\nNode.js version: `7.7.4`\r\nMongoDB Atlas version: `3.2`\r\n\r\nWhen trying to connect via mongo shell, everything works fine.\r\n\r\n```\r\nmongo 'mongodb://someUser:somePassword@someShard-shard-00-00-fjfvq.mongodb.net:27017,someShard-shard-00-01-fjfvq.mongodb.net:27017,someShard-shard-00-02-fjfvq.mongodb.net:27017/someDb?replicaSet=someShard-shard-0&ssl=true&authSource=admin'\r\n```\r\n\r\nHere, I'm connecting to `someDb`, but I'm authenticating the user against the `admin` database.\r\n\r\nWhen trying to connect with Mongoose I get the following error:\r\n\r\n```\r\n { MongoError: authentication fail\r\nat Function.MongoError.create ...\r\n```\r\n\r\nI'm thinking it's an error with it not handling the `authSource` properly. Mongoose successfully connects if I make `admin` the database I'm trying to connect to, but doesn't connect if I make `admin` the `authSource` I'm trying to authenticate against.\r\n\r\nAny ideas?",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/5138/comments",
    "author": "emaxedon",
    "comments": [
      {
        "user": "gilalan",
        "created_at": "2017-04-07T00:01:33Z",
        "body": "Same problem here! \r\n\r\nMongoose version: 4.2.10\r\nNode.js version: 6.9.5\r\nMongoDB Atlas version: 3.4.2\r\n\r\nWhen trying to connect via mongo shell, everything works fine, but when I trying from my express.js code, I get the following error:\r\n\r\n`name: 'MongoError', message: 'no valid seed servers in list'`\r\n\r\nHas anyone found a solution?"
      },
      {
        "user": "emaxedon",
        "created_at": "2017-04-07T17:33:56Z",
        "body": "It for some reason works for me now. Can I see your code?"
      },
      {
        "user": "gilalan",
        "created_at": "2017-04-07T20:47:21Z",
        "body": "Hello @emaxedon , I am using MEANJS generator from Yeoman. Here is my code:\r\n`var config.db.uri = 'mongodb://myUser:myPass@myCluster-shard-00-00-67fdt.mongodb.net:27017,myCluster-shard-00-01-67fdt.mongodb.net:27017,myCluster-shard-00-02-67fdt.mongodb.net:27017/myDatabase?ssl=true&replicaSet=myCluster-shard-0&authSource=admin'`\r\n\r\n`var db = mongoose.connect(config.db.uri, function (err) {\r\n    // Log Error\r\n    if (err) {\r\n      console.error(chalk.red('Could not connect to MongoDB!'));\r\n      console.log(err);\r\n    } else {\r\n\r\n      // Enabling mongoose debug mode if required\r\n      mongoose.set('debug', config.db.debug);\r\n\r\n      // Call callback FN\r\n      if (cb) cb(db);\r\n    }\r\n  });`\r\n\r\nIt returns the following error: \r\n`Could not connect to MongoDB!\r\n    { MongoError: no valid seed servers in list}`\r\n\r\nUsing this same String, I can successfully connect via mongo shell. Until I find a solution, I'm using an old database from Xervo.io, but my actual database is already set in Atlas. Any ideas ? "
      },
      {
        "user": "sobafuchs",
        "created_at": "2017-04-08T22:33:59Z",
        "body": "@emaxedon did you change anything between when it was working and when it started working? And is it still working?"
      },
      {
        "user": "emaxedon",
        "created_at": "2017-04-08T23:55:22Z",
        "body": "@gilalan @varunjayaraman \r\n\r\nNot sure if it makes a difference - but the only thing I changed that made it work (no idea why this works) is the following.\r\n\r\n```\r\nconst db = mongoose.connect(config.db.uri, {\r\n\tserver: {\r\n\t\tsocketOptions: {\r\n\t\t\tkeepAlive: 1\r\n\t\t}\r\n\t}\r\n}).connection;\r\n\r\ndb.on('error', (err) => {\r\n\tconsole.log(err);\r\n});\r\ndb.once('open', (err) => {\r\n\tif (err) {\r\n\t\tconsole.log(err);\r\n\t} else {\r\n\t\t// ...\r\n\t}\r\n});\r\n```"
      },
      {
        "user": "gilalan",
        "created_at": "2017-04-10T12:07:37Z",
        "body": "Not changed for me =( i'm stucked with that error.\r\nAnyway @emaxedon, thanks for your help!"
      },
      {
        "user": "BGTN",
        "created_at": "2017-05-09T17:13:33Z",
        "body": "I had the same issue like @gilalan. \"name: 'MongoError', message: 'no valid seed servers in list'\". I updated node to version v6.10.3 and mongoose to version 4.9.8. After these updates I was able to connect to Atlas via Mongoose.\r\n\r\n"
      },
      {
        "user": "kevinadi",
        "created_at": "2017-05-11T01:22:18Z",
        "body": "@gilalan I can confirm that mongoose 4.2.10 cannot connect to MongoDB Atlas with the error message `MongoError: no valid seed servers in list`.\r\n\r\nHowever, I can also confirm that upgrading to the latest mongoose (currently 4.9.8) fixed the issue, and enabled mongoose to connect to MongoDB Atlas.\r\n\r\nI believe this issue should be closed."
      },
      {
        "user": "gilalan",
        "created_at": "2017-05-11T01:45:47Z",
        "body": "It is fixed now! I don't know why but it's ok!."
      }
    ]
  },
  {
    "number": 5100,
    "title": "Mongoose select,populate and save behaving differently on Mac and Windows",
    "created_at": "2017-03-22T19:01:56Z",
    "closed_at": "2017-03-30T03:12:10Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/5100",
    "body": "I have a funciton in which i am selecting only 3 fields to go ahead with i.e billing,current_referral_program and referral. And populating user using the reference stored in billing.user\r\n\r\n`static populateReferralLinks(){\r\n\r\n    return Promise.coroutine(function*(){\r\n        let companies = yield Company.find({},'billing referral current_referral_program')\r\n        .populate('billing.user','emails name');\r\n        for(let i = 0 ; i < length ; i++){  \r\n            companies[i].referral.is_created = true;\r\n            companies[i].referral.referral_email = companies[i].billing.user.emails[0].email;\r\n            companies[i] = yield companies[i].save();\r\n       }\r\n       return companies;\r\n    })\r\n    .apply(this)\r\n    .catch((err) => {\r\n            throw err;\r\n    });\r\n} `\r\n\r\nNow when i call this function then on line\r\n\r\n`companies[i].save();`\r\n\r\nThe following command is shown in the terminal in windows\r\n\r\n`Mongoose: companies.update(\r\n{ _id: ObjectId(\"58d12e1a588a96311075c45c\") }, \r\n{ '$set': \r\n   { billing: \r\n      { configured: false, \r\n        user: ObjectId(\"58d12e16588a96311075c45a\") }, \r\n     referral: \r\n     { is_created: true,  \r\n       referral_email: 'jadon.devesh98@gmail.com', \r\n     }, \r\n     updatedAt: new Date(\"Wed, 22 Mar 2017 12:02:55 GMT\") \r\n   } \r\n}\r\n)`\r\n\r\nBut in Mac's terminal it shows this command\r\n\r\n`Mongoose: companies.update({ _id: ObjectId(\"58d12e1a588a96311075c45c\") }) { '$set': { billing: { configured: false, user: ObjectId(\"58d12e16588a96311075c45a\") }, current_limit: {}, current_usage: {},referral: { is_created: true, referral_email: 'jadon.devesh98@gmail.com'}}, '$unset': { updatedAt: 1 } }`\r\n\r\nNow, I haven't mentioned **current_limit** and **current_usage** to be empty. it's executing fine on windows but on Mac it's setting **current_limit** and **current_usage** empty thus updating my document with empty objects on Mac but not on windows.\r\n\r\nIt should behave same way on both OS but it is not.\r\n\r\nMy Company Schema is like this\r\n\r\n`const companySchema = new mongoose.Schema(\r\n    {\r\n       name: {\r\n            type: String,\r\n            trim: true,\r\n            required: true,\r\n            minlength: 3,\r\n            lowercase: true,\r\n        },\r\n        current_limit: {\r\n            leads: {\r\n                type: Number,\r\n                default: null\r\n            },\r\n            traffic: {\r\n                type: Number,\r\n                default: null\r\n            }\r\n        },\r\n        current_usage: {\r\n            leads: {\r\n                type: Number,\r\n                default: 0\r\n            },\r\n            traffic: {\r\n                type: Number,\r\n                default: 0\r\n            }\r\n        }\r\n        billing: {\r\n            user: {\r\n                type: mongoose.Schema.ObjectId,\r\n                ref: 'User'\r\n            },\r\n            configured: {\r\n                type: Boolean,\r\n                default: false\r\n            },\r\n        },\r\n        current_referral_program: {\r\n            type: String,\r\n            uppercase: true,\r\n            enum: ['FIRST', 'SECOND'],\r\n            default: 'FIRST'\r\n        },\r\n        referral: {\r\n            is_created:{\r\n                type: Boolean,\r\n                default: false\r\n            }\r\n            referral_email:{\r\n                type: String,\r\n                default:null\r\n            }\r\n        }\r\n    },\r\n    {\r\n        timestamps: true,\r\n        autoIndex: true\r\n    }\r\n);`\r\n\r\nand User Schema is like this\r\n\r\n`const userSchema = new mongoose.Schema(\r\n    {\r\n        name: {\r\n            type: String,\r\n            trim: true,\r\n            default: ''\r\n        },\r\n        username: {\r\n            type: String,\r\n            trim: true,\r\n            required: true,\r\n            minlength: 4,\r\n            lowercase: true,\r\n            unique: true\r\n        },\r\n        emails: [emailSchema],\r\n        password: {\r\n            type: String,\r\n            required: true,\r\n            minlength: 8\r\n        },\r\n    },\r\n    {\r\n        timestamps: true,\r\n        autoIndex: true\r\n    }\r\n);`\r\n\r\nNote : this happens only for fields like **current_limit** which store an object but not for fields like **name** which store single value but not whole object.\r\n\r\nMongoDb version is 3.4.0 on both systems\r\nMongoose version is 4.5.8",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/5100/comments",
    "author": "deveshjadon98",
    "comments": [
      {
        "user": "sobafuchs",
        "created_at": "2017-03-24T03:09:19Z",
        "body": "@deveshjadon98 can you try with mongoose 4.9.1. This is definitely a weird one... what version of node are you using?"
      },
      {
        "user": "deveshjadon98",
        "created_at": "2017-03-24T05:31:53Z",
        "body": "@varunjayaraman it worked fine after upgrading to mongoose 4.9.1 , now it's making the same query in both environments, which was earlier made in windows. i am using ubuntu instance on aws, On 4.5.8 it resulted in data loss because of different queries. \r\nNode version is 6.2.2 \r\nAll good now, Thanks."
      }
    ]
  },
  {
    "number": 5049,
    "title": "MongoError: the limit must be positive",
    "created_at": "2017-03-07T20:53:23Z",
    "closed_at": "2017-03-10T21:10:52Z",
    "labels": [
      "help wanted",
      "needs clarification"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/5049",
    "body": "BUG\r\n\r\n{ MongoError: the limit must be positive\r\n    at Function.MongoError.create (/var/app/current/node_modules/mongodb-core/lib/error.js:31:11)\r\n    at /var/app/current/node_modules/mongodb-core/lib/connection/pool.js:483:72\r\n    at authenticateStragglers (/var/app/current/node_modules/mongodb-core/lib/connection/pool.js:429:16)\r\n    at Connection.messageHandler (/var/app/current/node_modules/mongodb-core/lib/connection/pool.js:463:5)\r\n    at Socket.<anonymous> (/var/app/current/node_modules/mongodb-core/lib/connection/connection.js:317:22)\r\n    at emitOne (events.js:96:13)\r\n    at Socket.emit (events.js:188:7)\r\n    at readableAddChunk (_stream_readable.js:176:18)\r\n    at Socket.Readable.push (_stream_readable.js:134:10)\r\n    at TCP.onread (net.js:548:20)\r\n  name: 'MongoError',\r\n  message: 'the limit must be positive',\r\n  ok: 0,\r\n  errmsg: 'the limit must be positive',\r\n  code: 15958,\r\n  codeName: 'Location15958' }\r\n\r\nMongoose: 4.7.5\r\nMongoDB: 3.4\r\nNode.js: 6.9.1\r\n\r\nI'm trying to make [Find, Populate, Exec]\r\nI have two code, old and new. when I changed old code with new, this error appeared. In old version, \"population\" made by manually, with two search and in new code I use populate method to do this... \r\nI can't upgrade mongoose, because of mongoose's integrated promises is deprecated and now I don't have time to rewrite full project...",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/5049/comments",
    "author": "vkupar",
    "comments": [
      {
        "user": "sobafuchs",
        "created_at": "2017-03-08T15:26:07Z",
        "body": "Do you have a more helpful repro script?"
      },
      {
        "user": "vkupar",
        "created_at": "2017-03-09T02:28:18Z",
        "body": "I used ES6 promises incorrectly and it was the problem. My code looked like:\r\nModel\r\n.findOne()\r\n.then()\r\n.catch()\r\n\r\nNow I'm using .exec() method only and it works without errors"
      },
      {
        "user": "sobafuchs",
        "created_at": "2017-03-10T17:17:54Z",
        "body": "That isn't an incorrect use of promises Do you have more details?"
      },
      {
        "user": "vkupar",
        "created_at": "2017-03-10T19:03:16Z",
        "body": "@varunjayaraman No. I removed .then() promise and now it works very good."
      },
      {
        "user": "sobafuchs",
        "created_at": "2017-03-10T19:46:37Z",
        "body": "@vatex I'm saying that you shouldn't have to remove `.then()`. Can you show me how you used it?"
      },
      {
        "user": "vkupar",
        "created_at": "2017-03-10T19:50:22Z",
        "body": "```\r\nMyModel\r\n.findOne({ user: 'admin@gmail.com' }, 'email password createdAt')\r\nthen((result) => {\r\n    console.log(result);\r\n})\r\n.catch((error) => {\r\n    console.log(error);\r\n});\r\n```"
      },
      {
        "user": "sobafuchs",
        "created_at": "2017-03-10T20:02:25Z",
        "body": "chaining `.then()` works for me:\r\n\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nconst co = require('co');\r\nmongoose.Promise = global.Promise;\r\n\r\nconst GITHUB_ISSUE = `gh-5049`;\r\n\r\nexec()\r\n  .then(() => {\r\n    console.log('Program successful');\r\n    process.exit(0);\r\n  })\r\n  .catch(error => {\r\n    console.error(`Error: ${ error }\\n${ error.stack }`);\r\n    process.exit(2);\r\n  });\r\n\r\nfunction exec() {\r\n  return co(function*() {\r\n    const db = mongoose.connect(`mongodb://localhost:27017/${ GITHUB_ISSUE }`);\r\n    \r\n    const schema = new mongoose.Schema({\r\n      email: String,\r\n      password: String\r\n    }, { timestamps: true });\r\n\r\n    const Model = db.model('Model', schema);\r\n    yield Model.remove({});\r\n    \r\n    const doc = yield Model.create({\r\n      email: 'test@test.com',\r\n      password: 'test'\r\n    });\r\n\r\n    return Model\r\n      .findOne({ email: 'test@test.com' }, 'email password createdAt')\r\n      .then(result => {\r\n        console.log('result', result);\r\n      });\r\n  });\r\n}\r\n```"
      },
      {
        "user": "vkupar",
        "created_at": "2017-03-10T20:17:05Z",
        "body": "@varunjayaraman Yes but I missed this code: `mongoose.Promise = global.Promise;` and maybe it was problem"
      },
      {
        "user": "sobafuchs",
        "created_at": "2017-03-10T21:10:52Z",
        "body": "Ok sounds good"
      }
    ]
  },
  {
    "number": 3728,
    "title": "Performance Degradation: Fix for #3461 causes severe latency",
    "created_at": "2016-01-02T23:21:08Z",
    "closed_at": "2016-01-27T14:39:43Z",
    "labels": [
      "performance",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/3728",
    "body": "See below...\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/3728/comments",
    "author": "parisholley",
    "comments": [
      {
        "user": "parisholley",
        "created_at": "2016-01-03T02:51:12Z",
        "body": "i've isolated a single server in prod and have been testing jumps between different mongoose versions. at this point it appears that some commit introduced between 4.1.11 and 4.1.12 cause some serious performance degradation (for me). i'll try stepping up per version next...\n"
      },
      {
        "user": "parisholley",
        "created_at": "2016-01-03T07:14:03Z",
        "body": "Here is a breakdown of the performance degradation I am seeing. The performance impact is based upon my application response time increases as I moved from commit to commit. I was previously on the 4.0.x release before upgrading to get new features.\n\n| Commit | Performance Impact |\n| --- | --- |\n| 1f6aa7a91e36a8e6f7b8c1a45f2c87ba3eb71963 (4.1.11 Tag) | None |\n| 335513cae34fafbfe43e29f520965af28d60e255 (#3461 fix) | 33% Slower |\n| c8b3e273e8da3369ab4aa6e700f45f7c4839a3cb (#3461 refactor) | 100% Slower |\n| d7c10cbac3dc5208661a12289b33d626321a502e (4.3.4 Tag) w/ #3461 removed | None |\n\nperhaps @vkarpov15 / @boblauer can shed some light on why that \"fix\" could cause such an issue? it could be something deep within how I am using the resulting mongo objects (ie: passing arrays to modules like underscore or Lazy.js)s...\n"
      },
      {
        "user": "vkarpov15",
        "created_at": "2016-01-04T15:33:50Z",
        "body": "Hmm could you share your benchmarks? I don't see why you'd have such a big performance impact from that change.\n"
      },
      {
        "user": "parisholley",
        "created_at": "2016-01-04T16:39:34Z",
        "body": "@vkarpov15 The benchmarks were from watching new relic from deploy to deploy. I had this code take my cluster of 6 severs down twice when pushed live :) I unfortunately do not have much time to dig into a profiler, so I will just be running off a fork for now.\n"
      },
      {
        "user": "vkarpov15",
        "created_at": "2016-01-04T23:13:46Z",
        "body": "I'll mark this as help wanted. There's not really much I can do without being able to repro your performance degradation, and without more info I'll just be taking shots in the dark.\n"
      }
    ]
  }
]