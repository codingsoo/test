[
  {
    "number": 8911,
    "title": "Could not find a copier for type System.Func`",
    "created_at": "2024-03-15T08:15:55Z",
    "closed_at": "2024-03-16T01:34:00Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered"
    ],
    "url": "https://github.com/dotnet/orleans/issues/8911",
    "body": "hello\r\nI have a grain that has a method with the following input parameters:\r\n\r\nTask<List<T>> Where(Func<T, bool> exp);\r\n\r\nIs there a solution to fix the following error?\r\nCould not find a copier for type System.Func`",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/8911/comments",
    "author": "meisamhasani",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2024-03-15T16:07:33Z",
        "body": "This is simply not copyable/serializable: you cannot safely serialize a closure and deserialize it on another machine. I would guess what is happening is that you're passing or returning an IEnumerable<T> over the wire. You should enumerate it to a list/array first."
      },
      {
        "user": "meisamhasani",
        "created_at": "2024-03-15T18:10:49Z",
        "body": "I want to pass an action dir as a parameter"
      },
      {
        "user": "ReubenBond",
        "created_at": "2024-03-15T19:41:28Z",
        "body": "You can't: closures cannot be reliably serialized. You should find another way, one which does not involve serialization of Action/Func."
      },
      {
        "user": "meisamhasani",
        "created_at": "2024-03-16T01:34:00Z",
        "body": "Ok.thank you"
      }
    ]
  },
  {
    "number": 8899,
    "title": "How do I correctly call the DeactivateOnIdle() method within the Grain? Getting error!",
    "created_at": "2024-03-07T22:05:40Z",
    "closed_at": "2024-05-15T19:28:39Z",
    "labels": [
      "question",
      "Needs: author feedback",
      ":heavy_check_mark: Resolution: Answered"
    ],
    "url": "https://github.com/dotnet/orleans/issues/8899",
    "body": "I'm trying to make a simple application that will run time-based processes with Orleans.\r\n\r\nAll the codes of the application I am working on are as follows.\r\n\r\nI create 1 Grain (ExecutorGrain) on 1 Silo. This will be a logic that will run a time-based business within Grain.\r\n\r\nPS: ExecutorGrainV2 is a different example, I just added it to the code, ExecutorGrain and ExecutorGrainV2 are not active at the same time at run time.\r\n\r\nFor example; process data from a specific Event for 10 minutes and completely Dispose of the Grain when the time is up (like Kafka/RabbitMQ consumer).\r\n\r\nAfter this Grain is Disposed, I want it to be cleared from the system until it is called again, and when it is created again, I want it to run a completely new process (with the same business code).\r\n\r\nNOTE: Ideally, of course, my goal will be more than 1 Silo and more than 1 Grain.\r\n\r\nDeactivateOnIdle(); No matter where I call the method, I get an error. You can see the entire log of the error I received after running the code sample I gave below.\r\n\r\n- I reviewed the documentation and could not find sufficient information.\r\n- I reviewed other issues opened on the subject and tried similar things.\r\n- I couldn't find a method on StackOverflow.\r\n- I also checked the sample application codes, but I could not find a suitable reference for such a scenario.\r\n\r\nThe Dispose() operation seems to cause an error at runtime, but I couldn't understand why and how.\r\n\r\nI request your support regarding the code.\r\n\r\n### Packages\r\n\r\n<details>\r\n<summary>Packages</summary>\r\n\r\n```\r\n    <ItemGroup>\r\n        <PackageReference Include=\"Microsoft.Extensions.Hosting\" Version=\"8.0.0\"/>\r\n        <PackageReference Include=\"Microsoft.Extensions.Logging.Console\" Version=\"8.0.0\"/>\r\n        <PackageReference Include=\"Microsoft.Orleans.Server\" Version=\"8.0.0\"/>\r\n        <PackageReference Include=\"OrleansDashboard\" Version=\"7.2.2\"/>\r\n    </ItemGroup>\r\n```\r\n\r\n</details>\r\n\r\n### Code\r\n\r\n```\r\nusing Microsoft.Extensions.Hosting;\r\nusing Microsoft.Extensions.DependencyInjection;\r\nusing Microsoft.Extensions.Logging;\r\nusing Orleans.Configuration;\r\n\r\nclass Program\r\n{\r\n    static async Task Main(string[] args)\r\n    {\r\n        var builder = Host.CreateDefaultBuilder(args)\r\n            .UseOrleans(silo =>\r\n            {\r\n                silo.UseLocalhostClustering()\r\n                    .UseDashboard(x => x.HostSelf = true)\r\n                    .Configure<ClusterOptions>(options =>\r\n                    {\r\n                        options.ClusterId = \"dev\";\r\n                        options.ServiceId = \"Orleans\";\r\n                    })\r\n                    .ConfigureLogging(logging => logging.AddConsole());\r\n            })\r\n            .UseConsoleLifetime()\r\n            .ConfigureServices((hostContext, services) => { });\r\n\r\n        using var host = builder.Build();\r\n        await host.StartAsync();\r\n\r\n        var client = host.Services.GetRequiredService<IClusterClient>();\r\n        \r\n        var executorGrain = client.GetGrain<IExecutorGrain>(new Random().Next());\r\n        await executorGrain.Execute();\r\n        \r\n    }\r\n}\r\n\r\npublic interface IExecutorGrain : IGrainWithIntegerKey\r\n{\r\n    Task Execute(); \r\n}\r\n\r\npublic class ExecutorGrain : Grain, IExecutorGrain\r\n{\r\n    public async Task Execute()\r\n    {\r\n        Console.WriteLine($\">>> Executing\");\r\n\r\n        var counter = 0;\r\n\r\n        while (counter < 5)\r\n        {\r\n            // Here; there will be time-based processes\r\n\r\n            await Task.Delay(1000);\r\n            Console.WriteLine($\">>> Execute Counter: {counter++}\");\r\n        }\r\n        \r\n        Console.WriteLine($\">>> Executed\");\r\n\r\n        DeactivateOnIdle(); \r\n    }\r\n}\r\n\r\n\r\npublic class ExecutorGrainV2 : Grain, IExecutorGrain\r\n{\r\n    private IDisposable? _timer;\r\n    \r\n    public override Task OnActivateAsync(CancellationToken cancellationToken)\r\n    {\r\n        _timer = RegisterTimer(TimerAsync, null, TimeSpan.FromMilliseconds(10), TimeSpan.FromMilliseconds(10));\r\n        return base.OnActivateAsync(cancellationToken);\r\n    }\r\n\r\n    public async Task Execute()\r\n    {\r\n        Console.WriteLine($\">>> Executing\");\r\n\r\n        var counter = 0;\r\n\r\n        while (counter < 5)\r\n        {\r\n            // Here; there will be time-based processes\r\n            \r\n            await Task.Delay(1000);\r\n            Console.WriteLine($\">>> Execute Counter: {counter++}\");\r\n        }\r\n        \r\n        Console.WriteLine($\">>> Executed\");\r\n    }\r\n\r\n    private Task TimerAsync(object state = null)\r\n    {\r\n        Console.WriteLine($\">>> Timer Executed\");\r\n    \r\n        _timer?.Dispose();\r\n        _timer = null;\r\n        DeactivateOnIdle();\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n\r\n```\r\n\r\n### Console Logs after Run\r\n\r\n<details>\r\n<summary>Logs</summary>\r\n\r\n\r\n```\r\n\r\ninfo: Orleans.Runtime.Silo[100404]\r\n      Silo starting with GC settings: ServerGC=False GCLatencyMode=Interactive\r\nwarn: Orleans.Runtime.Silo[100405]\r\n      Note: Silo not running with ServerGC turned on - recommend checking app config : <configuration>-<runtime>-<gcServer enabled=\"true\">\r\nwarn: Orleans.Runtime.Silo[100405]\r\n      Note: ServerGC only kicks in on multi-core systems (settings enabling ServerGC have no effect on single-core machines).\r\ninfo: Orleans.Runtime.Silo[100403]\r\n      -------------- Initializing silo on host MSTFCCK.local MachineName MSTFCCK at 127.0.0.1:11111, gen 68851927 --------------\r\ninfo: Orleans.Runtime.Silo[100415]\r\n      Starting silo Silo_61487\r\nwarn: Orleans.Runtime.NoOpHostEnvironmentStatistics[100708]\r\n      No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet\r\ninfo: Orleans.Runtime.Silo[100422]\r\n      -------------- Started silo S127.0.0.1:11111:68851927, ConsistentHashCode 9DED6DA9 --------------\r\ninfo: Orleans.Hosting.SiloHostedService[0]\r\n      Starting Orleans Silo.\r\ninfo: Orleans.Runtime.SiloOptionsLogger[0]\r\n      Configuration Orleans.Configuration.ActivationCountBasedPlacementOptions: \r\n      ChooseOutOf: 2\r\n      \r\ninfo: Orleans.Runtime.SiloOptionsLogger[0]\r\n      Configuration Orleans.Configuration.ClusterMembershipOptions: \r\n      NumMissedTableIAmAliveLimit: 2\r\n      LivenessEnabled: True\r\n      ProbeTimeout: 00:00:05\r\n      TableRefreshTimeout: 00:01:00\r\n      DeathVoteExpirationTimeout: 00:02:00\r\n      IAmAliveTablePublishTimeout: 00:05:00\r\n      MaxJoinAttemptTime: 00:05:00\r\n      UseLivenessGossip: True\r\n      NumProbedSilos: 3\r\n      NumMissedProbesLimit: 3\r\n      NumVotesForDeathDeclaration: 2\r\n      DefunctSiloExpiration: 7.00:00:00\r\n      DefunctSiloCleanupPeriod: 01:00:00\r\n      LocalHealthDegradationMonitoringPeriod: 00:00:10\r\n      ExtendProbeTimeoutDuringDegradation: True\r\n      EnableIndirectProbes: True\r\n      \r\ninfo: Orleans.Runtime.SiloOptionsLogger[0]\r\n      Configuration Orleans.Configuration.ClusterOptions: \r\n      ClusterId: dev\r\n      ServiceId: Orleans\r\n      \r\ninfo: Orleans.Runtime.SiloOptionsLogger[0]\r\n      Configuration Orleans.Configuration.ConnectionOptions: \r\n      ProtocolVersion: Version1\r\n      ConnectionsPerEndpoint: 1\r\n      ConnectionRetryDelay: 00:00:01\r\n      OpenConnectionTimeout: 00:00:05\r\n      \r\ninfo: Orleans.Runtime.SiloOptionsLogger[0]\r\n      Configuration Orleans.Configuration.ConsistentRingOptions: \r\n      NumVirtualBucketsConsistentRing: 30\r\n      UseVirtualBucketsConsistentRing: True\r\n      \r\ninfo: Orleans.Runtime.SiloOptionsLogger[0]\r\n      Configuration Orleans.Configuration.DevelopmentClusterMembershipOptions: \r\n      PrimarySiloEndpoint: 127.0.0.1:11111\r\n      \r\ninfo: Orleans.Runtime.SiloOptionsLogger[0]\r\n      Configuration Orleans.Configuration.EndpointOptions: \r\n      AdvertisedIPAddress: 127.0.0.1\r\n      SiloPort: 11111\r\n      GatewayPort: 30000\r\n      SiloListeningEndpoint: \r\n      GatewayListeningEndpoint: \r\n      \r\ninfo: Orleans.Runtime.SiloOptionsLogger[0]\r\n      Configuration Orleans.Configuration.GrainCollectionOptions: \r\n      CollectionQuantum: 00:01:00\r\n      CollectionAge: 00:15:00\r\n      ActivationTimeout: 00:00:30\r\n      DeactivationTimeout: 00:00:30\r\n      \r\ninfo: Orleans.Runtime.SiloOptionsLogger[0]\r\n      Configuration Orleans.Configuration.GrainDirectoryOptions: \r\n      CachingStrategy: Adaptive\r\n      CacheSize: 1000000\r\n      InitialCacheTTL: 00:00:30\r\n      MaximumCacheTTL: 00:04:00\r\n      CacheTTLExtensionFactor: 2\r\n      LazyDeregistrationDelay: 00:01:00\r\n      \r\ninfo: Orleans.Runtime.SiloOptionsLogger[0]\r\n      Configuration Orleans.Configuration.GrainVersioningOptions: \r\n      DefaultCompatibilityStrategy: BackwardCompatible\r\n      DefaultVersionSelectorStrategy: AllCompatibleVersions\r\n      \r\ninfo: Orleans.Runtime.SiloOptionsLogger[0]\r\n      Configuration Orleans.Configuration.LoadSheddingOptions: \r\n      LoadSheddingEnabled: False\r\n      LoadSheddingLimit: 95\r\n      \r\ninfo: Orleans.Runtime.SiloOptionsLogger[0]\r\n      Configuration Orleans.Configuration.SchedulingOptions: \r\n      DelayWarningThreshold: 00:00:10\r\n      ActivationSchedulingQuantum: 00:00:00.1000000\r\n      TurnWarningLengthThreshold: 00:00:01\r\n      MaxPendingWorkItemsSoftLimit: 0\r\n      StoppedActivationWarningInterval: 00:01:00\r\n      \r\ninfo: Orleans.Runtime.SiloOptionsLogger[0]\r\n      Configuration Orleans.Configuration.SiloMessagingOptions: \r\n      SiloSenderQueues: 0\r\n      GatewaySenderQueues: 0\r\n      MaxForwardCount: 2\r\n      ClientDropTimeout: 00:01:00\r\n      ClientRegistrationRefresh: 00:05:00\r\n      ClientGatewayShutdownNotificationTimeout: 00:00:05\r\n      MaxEnqueuedRequestsSoftLimit: 0\r\n      MaxEnqueuedRequestsHardLimit: 0\r\n      MaxEnqueuedRequestsSoftLimit_StatelessWorker: 0\r\n      MaxEnqueuedRequestsHardLimit_StatelessWorker: 0\r\n      MaxRequestProcessingTime: 02:00:00\r\n      AssumeHomogenousSilosForTesting: False\r\n      ShutdownRerouteTimeout: 00:00:10\r\n      SystemResponseTimeout: 00:30:00\r\n      GrainWorkloadAnalysisPeriod: 00:00:05\r\n      RequestProcessingWarningTime: 00:00:05\r\n      RequestQueueDelayWarningTime: 00:00:10\r\n      WaitForMessageToBeQueuedForOutboundTime: 00:00:02\r\n      ResponseTimeout: 00:30:00\r\n      ResponseTimeoutWithDebugger: 00:30:00\r\n      DropExpiredMessages: True\r\n      MaxMessageHeaderSize: 10485760\r\n      MaxMessageBodySize: 104857600\r\n      \r\ninfo: Orleans.Runtime.SiloOptionsLogger[0]\r\n      Configuration Orleans.Configuration.SiloOptions: \r\n      SiloName: Silo_61487\r\n      \r\ninfo: Orleans.Runtime.Silo[100401]\r\n      Silo Start()\r\ninfo: Orleans.Runtime.Silo[100452]\r\n      Start local grain directory took 0 milliseconds to finish\r\ninfo: Orleans.Runtime.MembershipService.MembershipTableManager[100603]\r\n      MembershipOracle starting on host MSTFCCK.local with SiloAddress S127.0.0.1:11111:68851927 at 2024-03-07 21:32:07.987 GMT\r\ninfo: Orleans.Runtime.MembershipService.SystemTargetBasedMembershipTable[100635]\r\n      Creating in-memory membership table\r\ninfo: Orleans.Runtime.MembershipService.MembershipTableSystemTarget[100637]\r\n      GrainBasedMembershipTable Activated.\r\ninfo: Orleans.Runtime.Silo[0]\r\n      Grain Service OrleansDashboard.SiloGrainService registered successfully.\r\ninfo: Orleans.Runtime.Silo[100452]\r\n      Init grain services took 9 milliseconds to finish\r\ninfo: Orleans.Runtime.Silo[100452]\r\n      Start deployment load collector took 5 milliseconds to finish\r\ninfo: Orleans.Runtime.MembershipService.SystemTargetBasedMembershipTable[100631]\r\n      Connected to membership table provider.\r\ninfo: Orleans.Runtime.MembershipService.MembershipAgent[100663]\r\n      Joining\r\ninfo: Orleans.Runtime.MembershipService.MembershipAgent[100604]\r\n      -BecomeActive\r\ninfo: Orleans.Runtime.MembershipService.MembershipAgent[100605]\r\n      -Finished BecomeActive.\r\ninfo: OrleansDashboard.Dashboard[0]\r\n      Dashboard listening on 8080\r\ninfo: OrleansDashboard.SiloGrainService[102925]\r\n      Starting OrleansDashboard.SiloGrainService grain service on: S127.0.0.1:11111:68851927 x9DED6DA9, with range <(0 0], Size=x100000000, %Ring=100%>\r\ninfo: Orleans.Runtime.Silo[0]\r\n      Grain Service OrleansDashboard.SiloGrainService started successfully.\r\ninfo: OrleansDashboard.SiloGrainService[102934]\r\n      My range changed from <(0 0], Size=x100000000, %Ring=100%> to <(0 0], Size=x100000000, %Ring=100%> increased = True\r\ninfo: Orleans.Hosting.SiloHostedService[0]\r\n      Orleans Silo started.\r\ninfo: Microsoft.Hosting.Lifetime[0]\r\n      Application started. Press Ctrl+C to shut down.\r\ninfo: Microsoft.Hosting.Lifetime[0]\r\n      Hosting environment: Production\r\ninfo: Microsoft.Hosting.Lifetime[0]\r\n      Content root path: /Users/mustafacicek/Workplace/SWDev/DynamicEventManager/DynamicConsumerGenerator/bin/Debug/net8.0\r\n>>> Executing\r\ninfo: Orleans.Runtime.Management.ManagementGrain[0]\r\n      GetDetailedHosts OnlyActive=True\r\n>>> Execute Counter: 0\r\n>>> Execute Counter: 1\r\ninfo: Orleans.Runtime.Management.ManagementGrain[0]\r\n      GetDetailedHosts OnlyActive=True\r\ninfo: Orleans.Runtime.SiloControl[0]\r\n      GetSimpleGrainStatistics\r\n>>> Execute Counter: 2\r\n>>> Execute Counter: 3\r\ninfo: Orleans.Runtime.Management.ManagementGrain[0]\r\n      GetDetailedHosts OnlyActive=True\r\ninfo: Orleans.Runtime.SiloControl[0]\r\n      GetSimpleGrainStatistics\r\n>>> Execute Counter: 4\r\n>>> Executed\r\nwarn: Orleans.Grain[0]\r\n      Exception disposing activation [Activation: S127.0.0.1:11111:68851927/executor/562D707F@f18269b47f5340dda15ecd34342c0049#GrainType=ExecutorGrain,DynamicConsumerGenerator Placement=RandomPlacement State=Invalid]\r\n      System.ObjectDisposedException: Cannot access a disposed object.\r\n      Object name: 'IServiceProvider'.\r\n         at Microsoft.Extensions.DependencyInjection.ServiceLookup.ThrowHelper.ThrowObjectDisposedException()\r\n         at Microsoft.Extensions.DependencyInjection.ServiceProvider.GetService(ServiceIdentifier serviceIdentifier, ServiceProviderEngineScope serviceProviderEngineScope)\r\n         at Microsoft.Extensions.DependencyInjection.ServiceLookup.ServiceProviderEngineScope.GetService(Type serviceType)\r\n         at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetService[T](IServiceProvider provider)\r\n         at Orleans.Runtime.ActivationData.GetComponent[TComponent]() in /_/src/Orleans.Runtime/Catalog/ActivationData.cs:line 257\r\n         at Orleans.Runtime.ActivationData.SetGrainInstance(Object grainInstance) in /_/src/Orleans.Runtime/Catalog/ActivationData.cs:line 305\r\n         at Orleans.Runtime.ActivationData.UnregisterMessageTarget() in /_/src/Orleans.Runtime/Catalog/ActivationData.cs:line 1829\r\n         at Orleans.Runtime.ActivationData.FinishDeactivating(CancellationToken cancellationToken) in /_/src/Orleans.Runtime/Catalog/ActivationData.cs:line 1731\r\nfail: Orleans.Runtime.GrainTimer[101413]\r\n      Caught and ignored exception thrown from timer callback for timer GrainTimer.sys.svc.user.95B6CAE6/127.0.0.1:11111@68851927Timer TimerCallbackHandler:[SystemTarget: S127.0.0.1:11111:68851927/sys.svc.user.95B6CAE6/127.0.0.1:11111@68851927@0d73e76f00000000311eb42200000000]->System.Threading.Tasks.Task <Start>b__11_0(System.Object)\r\n      System.ObjectDisposedException: Cannot access a disposed object.\r\n      Object name: 'IServiceProvider'.\r\n         at Microsoft.Extensions.DependencyInjection.ServiceLookup.ThrowHelper.ThrowObjectDisposedException()\r\n         at Microsoft.Extensions.DependencyInjection.ServiceLookup.ServiceProviderEngineScope.GetService(Type serviceType)\r\n         at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.GetServiceOrCreateInstance[T](IServiceProvider provider)\r\n         at Orleans.Serialization.GeneratedCodeHelpers.OrleansGeneratedCodeHelper.GetService[TService](Object caller, ICodecProvider codecProvider) in /_/src/Orleans.Serialization/GeneratedCodeHelpers/OrleansGeneratedCodeHelper.cs:line 72\r\n         at OrleansCodeGen.Orleans.Runtime.Proxy_IManagementGrain..ctor(GrainReferenceShared arg0, IdSpan arg1) in /_/src/Orleans.Core/Orleans.CodeGenerator/Orleans.CodeGenerator.OrleansSerializationSourceGenerator/Orleans.Core.orleans.g.cs:line 1115\r\n         at Proxy_IManagementGrain(Object, GrainReferenceShared, IdSpan)\r\n         at Orleans.GrainReferences.GrainReferenceActivatorProvider.GrainReferenceActivator.CreateReference(GrainId grainId) in /_/src/Orleans.Core/GrainReferences/GrainReferenceActivator.cs:line 380\r\n         at Orleans.GrainReferences.GrainReferenceActivator.CreateReference(GrainId grainId, GrainInterfaceType interfaceType) in /_/src/Orleans.Core/GrainReferences/GrainReferenceActivator.cs:line 57\r\n         at Orleans.GrainFactory.GetGrain(Type interfaceType, IdSpan grainKey, String grainClassNamePrefix) in /_/src/Orleans.Core/Core/GrainFactory.cs:line 217\r\n         at Orleans.GrainFactory.GetGrain[TGrainInterface](Int64 primaryKey, String grainClassNamePrefix) in /_/src/Orleans.Core/Core/GrainFactory.cs:line 51\r\n         at OrleansDashboard.SiloGrainService.CollectStatistics(Boolean canDeactivate)\r\n         at Orleans.Runtime.GrainTimer.ForwardToAsyncCallback(Object state) in /_/src/Orleans.Runtime/Timers/GrainTimer.cs:line 116\r\n\r\n```\r\n\r\n</details>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/8899/comments",
    "author": "mstfcck",
    "comments": [
      {
        "user": "benjaminpetit",
        "created_at": "2024-03-14T18:42:20Z",
        "body": "In your sample, the silo will stop after `await executorGrain.Execute();` returns, no?"
      },
      {
        "user": "mstfcck",
        "created_at": "2024-03-18T09:47:25Z",
        "body": "> In your sample, the silo will stop after `await executorGrain.Execute();` returns, no?\r\n\r\n@benjaminpetit for this implementation, yes. But normally, it will keep running, and I plan to consume events."
      },
      {
        "user": "ReubenBond",
        "created_at": "2024-05-15T14:44:17Z",
        "body": "The problem in your example code is that you are missing the following line at the end of your `Main(string[] args)` method:\r\n\r\n```csharp\r\nawait host.WaitForShutdownAsync();\r\n```\r\n\r\nEDIT: I've opened #9001 and #9000 with defensive fixes to prevent the errors, but the above line of code still needs to be there."
      }
    ]
  },
  {
    "number": 8826,
    "title": "Will Orleans allocate underlying connections to each IGrainObserver instance?",
    "created_at": "2024-01-23T03:12:15Z",
    "closed_at": "2024-02-15T22:18:27Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered"
    ],
    "url": "https://github.com/dotnet/orleans/issues/8826",
    "body": "My question is whether all instances created by IGrainFactory.CreateObjectReference have a common connection under the surface or whether they have their own connection?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/8826/comments",
    "author": "paxhujing",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2024-01-23T03:21:30Z",
        "body": "They share the connection, Orleans does not create a connection per object. It creates a configurable number of connections between each host and the default number of connections between each host is 1."
      }
    ]
  },
  {
    "number": 8690,
    "title": "What is grainid in outside cluster client",
    "created_at": "2023-10-25T18:14:45Z",
    "closed_at": "2023-11-11T23:00:35Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/8690",
    "body": "Hello what is grainid in case of outside cluster stream client.\r\nI want to know boundary of where can be subscription shared (GetAllSubscriptionHandles).\r\nIs it whole process? Or thread?\r\nThanks for answer",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/8690/comments",
    "author": "spingee",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2023-11-03T21:47:59Z",
        "body": "Hi @spingee, I must apologize in case I do not understand the question. Are you asking whether calling `GetAllSubscriptionHandles()` on a client will return all client stream subscriptions in the entire application or just the process or thread? The answer is that it will return subscriptions in the current process, since every client generates a new, random `GrainId` when they initialize and that `GrainId` is used for the lifetime of the process. cc @benjaminpetit in case you have more info to add."
      },
      {
        "user": "ghost",
        "created_at": "2023-11-11T23:00:33Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 8687,
    "title": "GrainDirectory entities belonging to a dead silo are not removed from Azure Table Storage",
    "created_at": "2023-10-24T17:03:23Z",
    "closed_at": "2023-11-11T17:54:51Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered"
    ],
    "url": "https://github.com/dotnet/orleans/issues/8687",
    "body": "Hello,\n\nI noticed that grain directory entities are not removed from Azure Table Storage after manually shutting down the hosting silo.\n\nIs there any existant mechanism that can be used to remove ghost grains' activations from the directory stored in Azure Table Storage?\n\nRegards,\nAhmed",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/8687/comments",
    "author": "mhadhbi",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2023-11-03T21:50:14Z",
        "body": "This is by-design: the entries which point to defunct silos are ignored when they are read, so that they can be updated to point to valid silos."
      },
      {
        "user": "ReubenBond",
        "created_at": "2023-11-11T17:54:52Z",
        "body": "Closing this since it's intentional behavior (aligned with the characteristics of Azure Table Storage). An enhancement to perform background cleanup is possible, likely as an external contribution, but that can be a separate issue/PR."
      }
    ]
  },
  {
    "number": 8665,
    "title": "TestCluster has problems registering other Serializers",
    "created_at": "2023-10-16T10:11:13Z",
    "closed_at": "2023-11-11T17:00:34Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/8665",
    "body": "Hi, I am currently migrating a project to Orleans 7 and I have a problem with the TestCluster and NewtonsoftJson/SystemJson serializer. Some of the grains have an external Result class from the nuget package `CSharpFunctionalExtensions` as return type which needs an external Serializer. \r\n\r\nA simple grain which causes the problem:\r\n\r\n```csharp\r\npublic class HelloWorldGrain : Grain, IHelloWorldGrain\r\n{\r\n    public Task<Result<string>> Hello()\r\n    {\r\n        return Task.FromResult(Result.Success(\"Hello World\"));\r\n    }\r\n}\r\n```\r\n\r\nThe silo setup looks like this: \r\n\r\n```csharp\r\nIHostBuilder builder = Host.CreateDefaultBuilder(args)\r\n    .UseOrleans(silo =>\r\n    {\r\n        silo.UseLocalhostClustering()\r\n            .ConfigureLogging(logging => logging.AddConsole());\r\n\r\n        silo.Services\r\n            .AddAdditionalSerializers();\r\n    })\r\n    .UseConsoleLifetime();\r\n```\r\n\r\nThe serializer for the `CSharpFunctionalExtensions` namespace is added via an extensions method for `IServiceCollection` which looks like this:\r\n```csharp\r\n    public static IServiceCollection AddAdditionalSerializers(this IServiceCollection serviceCollection)\r\n    {\r\n        serviceCollection\r\n            .AddSerializer(serilzerBuilder =>\r\n                serilzerBuilder.AddNewtonsoftJsonSerializer(isSupported: type =>\r\n                    type.Namespace!.StartsWith(\"CSharpFunctional\")));\r\n\r\n        return serviceCollection;\r\n    }\r\n```\r\n\r\nIt works without a problem when you start the application as a console application but it does not work when starting a `TestCluster` for unittesting. When deploying the TestCluster an `Orleans.Runtime.OrleansConfigurationException` is thrown.\r\n\r\n## Sample unit test\r\n```csharp\r\npublic class UnitTest1\r\n{\r\n    [Fact]\r\n    public async Task Test1()\r\n    {\r\n        var builder = new TestClusterBuilder();\r\n        builder.AddSiloBuilderConfigurator<TestSiloConfigurations>();\r\n        var cluster = builder.Build();\r\n        await cluster.DeployAsync();\r\n\r\n        var factory = cluster.GrainFactory;\r\n        var grain = factory.GetGrain<IHelloWorldGrain>(\"Grain\");\r\n\r\n        var result = await grain.Hello();\r\n        result.IsSuccess.Should().BeTrue();\r\n    }\r\n}\r\n\r\npublic class TestSiloConfigurations : ISiloConfigurator\r\n{\r\n    public void Configure(ISiloBuilder siloBuilder)\r\n    {\r\n        siloBuilder.ConfigureServices(services =>\r\n        {\r\n            services.AddAdditionalSerializers();\r\n        });\r\n    }\r\n}\r\n```\r\n\r\nStacktrace: \r\n\r\n```\r\nFound unserializable or uncopyable types which are being referenced in grain interface signatures:\r\nType: CSharpFunctionalExtensions.Result`1[System.String] has no serializer and was referenced by the following:\r\n\t* Orleans.Example.IHelloWorldGrain,Orleans.Example methods: System.Threading.Tasks.Task`1[CSharpFunctionalExtensions.Result`1[System.String]] Test()\r\nEnsure that all types which are used in grain interfaces have serializers available for them.\r\nApplying the [GenerateSerializer] attribute to your type and adding [Id(x)] attributes to serializable properties and fields is the simplest way to accomplish this.\r\nAlternatively, for types which are outside of your control, serializers may have to be manually crafted, potentially using surrogate types.\r\n\r\n   at Orleans.SerializerConfigurationValidator.Orleans.IConfigurationValidator.ValidateConfiguration() in /_/src/Orleans.Core/Configuration/Validators/SerializerConfigurationValidator.cs:line 94\r\n   at Orleans.ClusterClient.<.ctor>g__ValidateSystemConfiguration|3_1(IServiceProvider serviceProvider) in /_/src/Orleans.Core/Core/ClusterClient.cs:line 59\r\n   at Orleans.ClusterClient..ctor(IServiceProvider serviceProvider, OutsideRuntimeClient runtimeClient, ILoggerFactory loggerFactory, IOptions`1 clientMessagingOptions) in /_/src/Orleans.Core/Core/ClusterClient.cs:line 33\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n   at System.Reflection.ConstructorInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr)\r\n   at System.Reflection.RuntimeConstructorInfo.Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite, RuntimeResolverContext context)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor`2.VisitCallSiteMain(ServiceCallSite callSite, TArgument argument)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitRootCache(ServiceCallSite callSite, RuntimeResolverContext context)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor`2.VisitCallSite(ServiceCallSite callSite, TArgument argument)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.Resolve(ServiceCallSite callSite, ServiceProviderEngineScope scope)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceProvider.CreateServiceAccessor(Type serviceType)\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceProvider.GetService(Type serviceType, ServiceProviderEngineScope serviceProviderEngineScope)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.ServiceProviderEngineScope.GetService(Type serviceType)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider, Type serviceType)\r\n   at Orleans.Configuration.Internal.ServiceCollectionExtensions.<>c__DisplayClass1_0.<AddFromExisting>b__0(IServiceProvider sp) in /_/src/Orleans.Core/Configuration/ServiceCollectionExtensions.cs:line 48\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitFactory(FactoryCallSite factoryCallSite, RuntimeResolverContext context)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor`2.VisitCallSiteMain(ServiceCallSite callSite, TArgument argument)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitRootCache(ServiceCallSite callSite, RuntimeResolverContext context)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor`2.VisitCallSite(ServiceCallSite callSite, TArgument argument)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitIEnumerable(IEnumerableCallSite enumerableCallSite, RuntimeResolverContext context)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor`2.VisitCallSiteMain(ServiceCallSite callSite, TArgument argument)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitRootCache(ServiceCallSite callSite, RuntimeResolverContext context)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor`2.VisitCallSite(ServiceCallSite callSite, TArgument argument)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.Resolve(ServiceCallSite callSite, ServiceProviderEngineScope scope)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceProvider.CreateServiceAccessor(Type serviceType)\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceProvider.GetService(Type serviceType, ServiceProviderEngineScope serviceProviderEngineScope)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceProvider.GetService(Type serviceType)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider, Type serviceType)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)\r\n   at Microsoft.Extensions.Hosting.Internal.Host.StartAsync(CancellationToken cancellationToken)\r\n   at Orleans.TestingHost.TestCluster.InitializeClientAsync() in /_/src/Orleans.TestingHost/TestCluster.cs:line 597\r\n   at Orleans.TestingHost.TestCluster.InitializeAsync() in /_/src/Orleans.TestingHost/TestCluster.cs:line 625\r\n   at Orleans.TestingHost.TestCluster.DeployAsync() in /_/src/Orleans.TestingHost/TestCluster.cs:line 166\r\n   at Orleans.TestingHost.TestCluster.DeployAsync() in /_/src/Orleans.TestingHost/TestCluster.cs:line 201\r\n   at Orleans.Example.Tests.UnitTest1.Test1() in D:\\Projects\\Orlenas.Example\\Orleans.Example.Tests\\UnitTest1.cs:line 16\r\n   at Xunit.Sdk.TestInvoker`1.<>c__DisplayClass48_0.<<InvokeTestMethodAsync>b__1>d.MoveNext() in /_/src/xunit.execution/Sdk/Frameworks/Runners/TestInvoker.cs:line 264\r\n--- End of stack trace from previous location ---\r\n   at Xunit.Sdk.ExecutionTimer.AggregateAsync(Func`1 asyncAction) in /_/src/xunit.execution/Sdk/Frameworks/ExecutionTimer.cs:line 48\r\n   at Xunit.Sdk.ExceptionAggregator.RunAsync(Func`1 code) in /_/src/xunit.core/Sdk/ExceptionAggregator.cs:line 90\r\n```",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/8665/comments",
    "author": "itsChekki",
    "comments": [
      {
        "user": "zeus82",
        "created_at": "2023-11-11T02:57:49Z",
        "body": "What version of Orleans are you running?  We had a similar issue with 7.2.1, but upgrading to 7.2.2 seemed to fix it for us."
      },
      {
        "user": "ReubenBond",
        "created_at": "2023-11-11T16:11:11Z",
        "body": "In the example code, the issue is that the custom serializer is added to the silos but not the client. You need to add a configurator for your client, similar to the one you have for your silo.\r\n\r\nI discerned this based on this line in the stack trace:\r\n\r\n```csharp\r\n   at Orleans.TestingHost.TestCluster.InitializeClientAsync() in /_/src/Orleans.TestingHost/TestCluster.cs:line 597\r\n```"
      },
      {
        "user": "ghost",
        "created_at": "2023-11-11T17:00:33Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 8647,
    "title": "Too many timeout errors due to persistence write",
    "created_at": "2023-09-25T11:59:55Z",
    "closed_at": "2023-11-11T23:00:41Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved",
      "area-persistence"
    ],
    "url": "https://github.com/dotnet/orleans/issues/8647",
    "body": "Hello!!\r\n\r\nWe have implemented a .NET 6 web application using Orleans 3.6.5 and we are using Dapper and Stored Procedures to read/write from MSSQL databases implementing `IGrainStorage`. The persistence state which we read and write is a List<> object.\r\nWe have a RabbitMQ consumer that consumes messages and inserts data to the list and we have web endpoints to retrieve the data and return it via web. So basically we have silos and client to Orleans on the same solution.\r\nOur Grain is instantiated in web retrieve/RabbitMQ consume and the read process (the SP that retrieves the data from db) is run for the first time.\r\nWe have a timer in our grain that writes to the database 5 minutes after the grain's activation and then every 15 minutes. We also write the persistence state when the grain is on `OnDeactivateAsync()` as a last step of trying not to lose our data.\r\nWe have set on startup `ClassSpecificCollectionAge` = 15 minutes and `ResponseTimeout` for silo/client = 30 seconds.\r\n\r\nWe released this in OpenShift and we noticed that when a lot of simultaneous calls come at the RabbitMQ consumer/web retrieval, a lot of grains are created with the Kubernetes in OpenShift uses AutoScales correctly by increasing the pods when needed but when the persistences writes are trying to be run (it seems to be on `OnDeactivateAsync` and not in timer's write), we get A LOT of errors with this message:\r\n```\r\nSystem.Data.SqlClient.SqlException (0x80131904): Timeout expired.  The timeout period elapsed prior to completion of the operation or the server is not responding.\r\n ---> System.ComponentModel.Win32Exception (258): Unknown error 258\r\n```\r\nAlso we get these errors (filtered due to sensitive data):\r\n```\r\nOrleans.Runtime.OrleansException: Current directory at SXXXXXXXXX:XXXXXX:XXXXXXX is not stable to perform the lookup for grainId *grn/XXXXXXXXXX/XXXXXXX (it maps to SXXXXXX:XXXXXX:XXXXXXX, which is not a valid silo). Retry later\r\n```\r\n\r\nSo, the grains are correctly created on simultaneous calls, the AutoScaler is correctly handling and increasing the pods when needed and the timer seems to correctly write the persistence state to the database. When no longer used, the grains are set to `OnDeactivateAsync` state and the persistence state is written yet again one last time. In this moment the simultaneous persistence writes go to timeout because of the massive amount of them (it is not the database per se, more like the application waiting for database response that has the issue, I think). The grains are deactivated and removed on a massive amount and the AutoScaler kills the extra pods as well and we are given those massive amounts of errors with no guaranty on not losing any data.\r\n\r\nSo, regarding this issue the following questions come in mind:\r\n\r\n- Is there a best practice on when/how to write the persistence state to database or doing it on `OnDeactivateAsync` is indeed the only way?\r\n- Is there a similar issue for anyone else and if yes, how did you manage to get around it and what workaround do you propose?\r\n- Is there any alternative suggested for this kind of handling? We need to be able to write one last time just before grains are removed to not lose data or maybe handling this better to lose less data instead\r\n- The way we handle Orleans it seems that these errors are ok to be thrown. Is this correct or is it a mishandling from our part?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/8647/comments",
    "author": "pkatsampiris",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2023-11-11T18:32:14Z",
        "body": "It looks like this may be occurring during shutdown. If all grains are performing a write at the same time (during shutdown), then you will likely run into connection pool capacity issues or overload the database. I would recommend only writing the state if it has changed and trying to space out the writes. To be clear, this looks like an issue with the database or database driver (client library).\r\n\r\nI also recommend that if state is important, you must write it to storage immediately, otherwise you have no guarantees that the state will ever be made durable (hosts can crash at any time). If state is not critical, then writing dirty state on a timer is acceptable. It's preferrable to write that state only if the state has changed,"
      },
      {
        "user": "ghost",
        "created_at": "2023-11-11T23:00:39Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      },
      {
        "user": "pkatsampiris",
        "created_at": "2023-11-14T08:57:03Z",
        "body": "We added a stateChanged variable and we only save if that has value, meaning if the state was changed. But we still did not get a definite answer about writing state in `OnDeactivateAsync`. Is that expected and can we handle this better alongside the stateChanged variable we already added?\r\n\r\nAlso, how would you handle a similar case? The space between writes has to do with the timer intervals, right? So, a lot of grains would be created at the same time (due to spikes in traffic) but we would add a space in the time the write state is occurred, Right?\r\n\r\nApart from that, there is no additional ways to handle those writes in `OnDeactivateAsync` right? So, we have a good approach it seems.\r\n\r\nCan we re-open it since the main questions seem unanswered?"
      }
    ]
  },
  {
    "number": 8638,
    "title": "Is there an offline mode supported?",
    "created_at": "2023-09-19T08:44:26Z",
    "closed_at": "2023-11-11T23:00:44Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/8638",
    "body": "Hello guys,\r\n\r\nI could not find in the documentation. I have an application that when is in offline mode (a local exe), it saves work on disk and when gets connection it will send work to the server,  (I'm not currently using orleans) I use WCF but it's time to kill it.\r\n\r\nI would like to get rid of this local storage mechanism (at least not manage it in my application), is orleans capable of managing the state automatically and  retry sending work when gets connection?  or am I totally lost?.\r\n\r\nthanks",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/8638/comments",
    "author": "mike7ang1rdz",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2023-11-11T18:35:19Z",
        "body": "It's not really intended to use Orleans offline (it's meant for cloud apps), but it can work. You can configure clustering using `UseLocalhostClustering` so that it has no external dependencies. You still need some database if you want to persist state, though. You could use SQLite for that."
      },
      {
        "user": "ghost",
        "created_at": "2023-11-11T23:00:42Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 8630,
    "title": "Why might setting the EntryExpiry attribute lead to duplicate activations in the cluster?",
    "created_at": "2023-09-12T09:45:48Z",
    "closed_at": "2023-09-12T23:01:08Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/8630",
    "body": "I noticed the comment on the EntryExpiry attribute of RedisGrainDirectoryOptions suggests that \"Setting a value different from null will cause duplicate activations in the cluster.\" Could you please explain under what circumstances this would happen?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/8630/comments",
    "author": "ximi522",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2023-09-12T13:51:39Z",
        "body": "Because if the entry is removed while the grain is active, then another silo may come and try to activate that same grain again. Since there is no existing entry in the directory (due to TTL expiry), it is free to do so."
      },
      {
        "user": "ximi522",
        "created_at": "2023-09-12T15:14:09Z",
        "body": "I am using Orleans under a k8s cluster, where the GrainDirectory is RedisGrainDirectory, and the implementation of IPlacementDirector selects the surviving silo in a Hash manner. When I restart one of the silos, the Grains on this silo correctly complete Deactivate and migrate to another silo. However, after the restart is complete, if there is access to those migrated Grains, some will try to activate on the restarted silo and return a Warning, even though these Grains have already been activated on other silos. Moreover, these warnings still occur after these Grains are Deactivated and then Activated again. I am not sure if this is because I set EntryExpiry = TimeSpan.FromDays(2). \r\nHere are the logs of the warnings.\r\n> 09-07 20:06:13.010\r\n__TAG__.pod_name:silo-planetserver-1__TAG__.pod_ip:172.21.21.65@m:Failed to register grain \\\"[Activation: S172.21.21.65:11111:53077893/mahjongroom/6496b45fc610cd229dcfaf38@98fb33a58942483fa6279436c1647777#Placement=ArchiveDbHashBasedPlacement State=Invalid]\\\" in grain directory@t:2023-09-07T12:06:12.6372506Z\r\n\r\n09-07 20:06:15.007\r\n__TAG__.pod_name:silo-planetserver-1__TAG__.pod_ip:172.21.21.65@m:Failed to register grain \\\"[Activation: S172.21.21.65:11111:53077893/mahjongroom/6496b45fc610cd229dcfaf38@8571d8b428f341188d41ff12ca37ba60#Placement=ArchiveDbHashBasedPlacement State=Invalid]\\\" in grain directory@t:2023-09-07T12:06:14.6398548Z\r\n\r\n09-08 14:00:14.011 \t\r\n2023-09-08T06:00:13.9136491Z\r\n__TAG__.pod_name:silo-planetserver-1__TAG__.pod_ip:172.21.21.65@m:Failed to register grain \\\"[Activation: S172.21.21.65:11111:53077893/mahjongroom/6496b45fc610cd229dcfaf38@7e0f0b3b762f491c8a0afa45fbbebaca#Placement=ArchiveDbHashBasedPlacement State=Invalid]\\\" in grain \r\n\r\n- > directory@t:2023-09-08T06:00:13.9136491Z\r\n\r\n09-08 14:03:57.008\r\n2023-09-08T06:03:56.2201857Z\r\n__TAG__.pod_name:silo-planetserver-1__TAG__.pod_ip:172.21.21.65@m:Failed to register grain \\\"[Activation: S172.21.21.65:11111:53077893/mahjongroom/6496b45fc610cd229dcfaf38@ec921c629b3f4756b0448eb925730f79#Placement=ArchiveDbHashBasedPlacement State=Invalid]\\\" in grain directory@t:2023-09-08T06:03:56.2201857Z\r\n\r\nAnd Here are the logs of the grain.\r\n\r\n> 09-07 15:51:50.010\r\n__TAG__.pod_name:silo-planetserver-1__TAG__.pod_ip:172.21.21.65id:6496b45fc610cd229dcfaf38@m:mahjongRoomGrain Activate, (roomId: \\\"6496b45fc610cd229dcfaf38\\\", state:Dissmiss)@t:2023-09-07T07:51:49.5599188Z\r\n09-07 16:13:36.012\r\n__TAG__.pod_name:silo-planetserver-1__TAG__.pod_ip:172.21.21.65id:6496b45fc610cd229dcfaf38@m:mahjongRoomGrain Deactivate, (roomId: \\\"6496b45fc610cd229dcfaf38\\\", state:Dissmiss)@t:2023-09-07T08:13:35.5903591Z\r\n\r\n09-07 20:06:11.008\r\n__TAG__.pod_name:silo-planetserver-2__TAG__.pod_ip:172.21.21.49id:6496b45fc610cd229dcfaf38@m:mahjongRoomGrain Activate, (roomId: \\\"6496b45fc610cd229dcfaf38\\\", state:Dissmiss)@t:2023-09-07T12:06:10.6372987Z\r\n09-07 21:01:32.011\r\n__TAG__.pod_name:silo-planetserver-2__TAG__.pod_ip:172.21.21.49id:6496b45fc610cd229dcfaf38@m:mahjongRoomGrain Deactivate, (roomId: \\\"6496b45fc610cd229dcfaf38\\\", state:Dissmiss)@t:2023-09-07T13:01:31.3187837Z\r\n\r\n09-07 22:48:13.011\r\n__TAG__.pod_name:silo-planetserver-2__TAG__.pod_ip:172.21.21.49id:6496b45fc610cd229dcfaf38@m:mahjongRoomGrain Activate, (roomId: \\\"6496b45fc610cd229dcfaf38\\\", state:Dissmiss)@t:2023-09-07T14:48:12.0882594Z\r\n09-07 23:10:32.010\r\n__TAG__.pod_name:silo-planetserver-2__TAG__.pod_ip:172.21.21.49id:6496b45fc610cd229dcfaf38@m:mahjongRoomGrain Deactivate, (roomId: \\\"6496b45fc610cd229dcfaf38\\\", state:Dissmiss)@t:2023-09-07T15:10:31.2649062Z\r\n\r\n09-08 09:36:07.013\r\n__TAG__.pod_name:silo-planetserver-2__TAG__.pod_ip:172.21.21.49id:6496b45fc610cd229dcfaf38@m:mahjongRoomGrain Activate, (roomId: \\\"6496b45fc610cd229dcfaf38\\\", state:Dissmiss)@t:2023-09-08T01:36:06.9451129Z\r\n09-08 09:58:31.012\r\n__TAG__.pod_name:silo-planetserver-2__TAG__.pod_ip:172.21.21.49id:6496b45fc610cd229dcfaf38@m:mahjongRoomGrain Deactivate, (roomId: \\\"6496b45fc610cd229dcfaf38\\\", state:Dissmiss)@t:2023-09-08T01:58:31.0058551Z\r\n"
      },
      {
        "user": "ghost",
        "created_at": "2023-09-12T17:01:09Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      },
      {
        "user": "ReubenBond",
        "created_at": "2023-09-12T18:42:02Z",
        "body": "What are you using for cluster membership and are all of your silos a part of the same cluster?\r\n"
      },
      {
        "user": "ghost",
        "created_at": "2023-09-12T23:01:07Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      },
      {
        "user": "ximi522",
        "created_at": "2023-09-13T09:15:05Z",
        "body": "> What are you using for cluster membership and are all of your silos a part of the same cluster?\r\n\r\nYes, all of silos are in the same cluster.Here is the cluster membership options set.\r\n\r\n ```\r\n  siloBuilder.Configure<ClusterMembershipOptions>(options =>\r\n  {\r\n          options.TableRefreshTimeout = TimeSpan.FromSeconds(60);\r\n          options.DefunctSiloExpiration = TimeSpan.FromMinutes(5); \r\n          options.DefunctSiloCleanupPeriod = TimeSpan.FromMinutes(5);\r\n          options.IAmAliveTablePublishTimeout = TimeSpan.FromSeconds(30);\r\n          options.NumMissedProbesLimit = 3;\r\n          options.NumVotesForDeathDeclaration = 2;\r\n          options.LocalHealthDegradationMonitoringPeriod = TimeSpan.FromSeconds(30);\r\n          options.EnableIndirectProbes = true;\r\n  });\r\n```"
      },
      {
        "user": "ximi522",
        "created_at": "2023-09-13T09:44:17Z",
        "body": "we used redis cluster as the clustering provider.Here is the redis options set\r\n\r\n```\r\nsiloBuilder.AddRedisGrainDirectory(Consts.RedisGrainDirectory, options =>\r\n  {\r\n      options.ConfigurationOptions = ConfigurationOptions.Parse(redisConnectionString);\r\n      options.EntryExpiry = TimeSpan.FromDays(2);\r\n  }\r\n);\r\nsiloBuilder.UseRedisClustering(redisConnectionString, \r\n    (int)ConfigurationOptions.Parse(redisConnectionString).DefaultDatabase);\r\nsiloBuilder.AddRedisGrainStorage(GrainStorageName.Redis,\r\n        options => options.ConnectionString = redisConnectionString);\r\n```"
      }
    ]
  },
  {
    "number": 8340,
    "title": "Cross grain storage type transactions",
    "created_at": "2023-03-07T11:45:23Z",
    "closed_at": "2023-03-14T20:20:41Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered"
    ],
    "url": "https://github.com/dotnet/orleans/issues/8340",
    "body": "Hi,\r\nwe are using Orleans to store some relational data. I was investigating how the transactional state works, but it appears to me that the transactions are supported only within grains with the same State type.\r\n\r\nIs that correct understanding, or have I missed something?\r\n\r\nThank you",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/8340/comments",
    "author": "tomhreb",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2023-03-08T17:50:08Z",
        "body": "Hi @tomhreb, that's not correct, transactions can mix various grains with different state types. What makes it appear that a single state type is supported per transaction?"
      },
      {
        "user": "ghost",
        "created_at": "2023-03-13T22:03:25Z",
        "body": "Hi @tomhreb We have added the \"Needs: Author Feedback\" label to this issue, which indicates that we have an open question for you before we can take further action. This issue will be closed automatically in 7 days if we do not hear back from you by then - please feel free to re-open it if you come back to this issue after that time."
      },
      {
        "user": "tomhreb",
        "created_at": "2023-03-14T20:20:41Z",
        "body": "Hi @ReubenBond , sorry for late anwer. If you're saying it's supported I trust you :) I need to take another look.\r\n\r\nI want to add support for transactional strorage to the mongodb repo, that's where my question popped up."
      }
    ]
  },
  {
    "number": 8339,
    "title": "[Orleans 7] Activation access violation",
    "created_at": "2023-03-07T10:50:00Z",
    "closed_at": "2023-03-13T23:01:47Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/8339",
    "body": "Hi,\r\n\r\nWe're seeing an issue (Orleans 7.1.0), which we didn't see when using Orleans 3.x, where GrainRuntime.CheckRuntimeContext is throwing an InvalidOperationException accessing Grain.GrainFactory from a grain call.\r\n\r\nThe grain in question also uses Orleans timers, and we have tried both with and without the workaround described in #2574 to ensure that these methods follow standard grain call semantics (Task.Run with this.AsReference<>)\r\n\r\nIf I disable the timers, then the exception is not thrown, so presumably the interplay of the timer with the grain is somehow resetting the RuntimeContext..?\r\n\r\nI can work around it by injecting the GrainFactory into the grain, but this feels like a sticking plaster rather than a genuine solution.\r\n\r\nThere are no external or long running tasks involved, nothing really unusual at all that I can see\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/8339/comments",
    "author": "fergusbown",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2023-03-13T22:09:26Z",
        "body": "@fergusbown aside from the cases you identified, this could be caused by a `ConfigureAwait(false)` call (you should remove those from grain code). The exception is an intentional guard-rail to detect these kinds of cases, since they usually indicate a mistake."
      },
      {
        "user": "ghost",
        "created_at": "2023-03-13T23:01:45Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 8327,
    "title": "[Orleans 3.x] Simple Message Stream provider hangs",
    "created_at": "2023-02-22T14:07:50Z",
    "closed_at": "2023-03-13T23:01:53Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/8327",
    "body": "I'm having an issue with the Simple Message Stream provider in Orleans 3.6.5. The setup is I have a grain in the silo where I'm publishing messages to the stream.\r\n\r\nExternally in a console application, I've instantiated a client and subscribed to the stream. My client is able to get messages from the stream. However, I've noticed that if I hard shutdown my client application without unsubscribing then the producer gets hung up on the following `OnNextAsync` task. No more messages come through and the task never errors or times out.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/8327/comments",
    "author": "benthepoet",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2023-03-13T22:06:55Z",
        "body": "Hi @benthepoet, when I've seen this in the past, the cause has been a cycle (deadlock) in the grain calls made by the SMS provider under the covers (producer grain calls the consumer grains). I recommend switching to MemoryStreams instead. If you think that is not happening in this situation, please feel free to respond with some more info and we'll take a look with you"
      },
      {
        "user": "ghost",
        "created_at": "2023-03-13T23:01:51Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 8078,
    "title": "Microsoft Faster  implementation in orleans",
    "created_at": "2022-10-27T11:51:55Z",
    "closed_at": "2022-11-28T19:12:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/8078",
    "body": "For trying  to replace concurrent dictionary in grain state with Microsoft Faster , we need to use  IDevice to access logs in file system .\r\n1- does it correct way to implement Microsoft faster in orleans cluster ?\r\n2- how cluster instances access to data in this way ?\r\nthank you \r\n ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/8078/comments",
    "author": "SalimiHabib",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2022-10-27T18:23:55Z",
        "body": "Hi @SalimiHabib, I'm not sure how to answer this. FASTER is an embedded data store, so you would need to be some work done to make that work well in a distributed setting.\r\n\r\nWhat benefit do you hope to gain from it?"
      },
      {
        "user": "SalimiHabib",
        "created_at": "2022-10-28T04:05:29Z",
        "body": "Hi @ReubenBond ,There is large database that need to be accessed by Orleans  , it managed by other active service and cannot be integrate in Orleans store , we don't know how Orleans performance affected by large database out of its own store ( may be by creating API to access it  from Orleans ) , also we have chance to create partitioned dataset and update data in schedule before using in Orleans.\r\nBase on these uncertainty and opportunity we found that Orleans store more reliable than outside of it (for this case)  \r\nand using FASTER is just about to prevent creating bottleneck( because of data size).\r\nbut as you pointed precisely to embedded data store , it is more complicated than it seems    \r\nMay be we go by API .\r\n\r\nThank you \r\n\r\n"
      }
    ]
  },
  {
    "number": 8060,
    "title": "Will Orleans 4/7 be compatible with .NET 6?",
    "created_at": "2022-10-25T13:11:10Z",
    "closed_at": "2022-10-25T23:01:53Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/8060",
    "body": "We have been using Orleans 3.x with our .NET apps. Does the recent change in version number mean Orleans 7 will be compatible with .NET 7 and not .NET 6?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/8060/comments",
    "author": "brijgogogo",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2022-10-25T21:30:43Z",
        "body": "Hi @brijgogogo, Orleans 7.0 relies on some features only available in .NET 7 and we intend to follow the versioning and dependencies of .NET and ASP.NET as Orleans continues to align with .NET & ASP.NET. It will not be compatible with .NET 6.0\r\n\r\nWe will continue releasing Orleans 3.x versions which support .NET 6.0 for the time being. Please let us know if that answers your question and if you have any concerns you'd like to raise."
      },
      {
        "user": "ghost",
        "created_at": "2022-10-25T23:01:51Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 8038,
    "title": "Question: Is Orleans 7.0.0-rc2 a real Release Candidate?",
    "created_at": "2022-10-20T03:08:13Z",
    "closed_at": "2022-10-20T23:02:24Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/8038",
    "body": "RC releases of .NET is guaranteed to make API almost stable and there is unlikely to be further breaking changes, and it could be safely based on in production.\r\n\r\nBut Orleans 4.0.0 used to stay in early previews, with even APIs moving among packages. I wonder if the so-called rc2 should be taken as a real go-to-live Release Candidate.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/8038/comments",
    "author": "AlseinX",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2022-10-20T03:27:30Z",
        "body": "We have no plans to change APIs between now and the final 7.0 release."
      },
      {
        "user": "ReubenBond",
        "created_at": "2022-10-20T03:57:12Z",
        "body": "Are you looking to go live before November?"
      },
      {
        "user": "AlseinX",
        "created_at": "2022-10-20T04:19:19Z",
        "body": "No, but it looks very weird to me because there the former milestones shows that there seems to be a long way to go before reaching RC. But now it turns to be 7.0.0-rc2 just because .NET 7 is rc2, so I wonder if it is really ready to be an RC, or just for alignment of versions (maybe as a prerequisite before merging into .NET sdk?)."
      },
      {
        "user": "ReubenBond",
        "created_at": "2022-10-20T04:39:12Z",
        "body": "Ah, I see the concern. The release was originally going to have been -rc1, but I mistyped it. Since -rc2 coincides with the current .NET RC which this RC builds against, we decided to keep it that way. Is there anything you're looking for which isn't in the release?"
      },
      {
        "user": "koenbeuk",
        "created_at": "2022-10-20T12:32:12Z",
        "body": "@ReubenBond Documentation! as the current docs are still referring to v3 and there seems to be no migration guide yet. "
      },
      {
        "user": "ghost",
        "created_at": "2022-10-20T23:02:22Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      },
      {
        "user": "bradygaster",
        "created_at": "2022-11-04T04:43:46Z",
        "body": "> @ReubenBond Documentation! as the current docs are still referring to v3 and there seems to be no migration guide yet.\r\n\r\nThis is something we're working on currently. The first article will inform customers on how to migrate from 3.x to 7. After that we'll start updating all the samples with help from @IEvangelist and the docs team. "
      }
    ]
  },
  {
    "number": 7991,
    "title": "Setting RequestContext by IIncomingGrainCallFilter from a gRPC service",
    "created_at": "2022-09-22T17:10:05Z",
    "closed_at": "2022-09-22T22:32:28Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7991",
    "body": "As far as I understood correctly, when RequestContext.Set is called the given metadata is passed to every grain method call from that point automatically. What is not clear for me in the docs whether the same metadata is being passed to another grain if that is created using GrainFactory.GetGrain<>() during a call that has the metadata passed to already by the mentioned mechanism.\r\n\r\nThe metadata I need to pass is a context identifier that can be used to identify the user and other contextual info. I would use the grain filter mechanism (IIncomingGrainCallFilter) for the purpose. However, I do not know how to pass the required information to the filter.\r\n\r\nI use a gRPC service endpoint that gets the IClusterClient from service provider, then creates a grain and calls some of its methods. The context information that I would like to set to the RequestContext comes from the ServerCallContext parameter of the gRPC method. These 3 (service endpoint, grain filter, grain) could run in different threads, I presume. The filter is instantiated by Orleans so I have no control over its life cycle.  As I experienced it is created as a singleton, no matter how I register it in the DI container.\r\n\r\nWhat is the suggested way of passing data to the grain filter?\r\nIn which thread is the Invoke method called? Can I use some thread synchronization mechanism to communicate between the gRPC method and the grain filter?\r\n\r\nAny suggestions are appreciated. Thank you.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7991/comments",
    "author": "danielleiszen",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2022-09-22T19:14:58Z",
        "body": "Thanks for the question, @danielleiszen.\r\n\r\n`GrainFactory.GetGrain<T>(...)` does not create a grain, it just creates a reference to a grain (think of it like creating a URI, but with a type). \r\n\r\nThe `RequestContext` is async-local, which means that it will flow along your async calls. So, to implement what you want, you should propagate the `ServerCallContext` to the `RequestContext` in your gRPC server method bodies. I'm not sure what a grain call filter would be necessary for here, unless you have some other ambient context which you could access from there to flow to `RequestContext`.\r\n\r\nDoes that answer it?"
      },
      {
        "user": "danielleiszen",
        "created_at": "2022-09-22T22:32:28Z",
        "body": "Thank you for your fast reply @ReubenBond \r\n\r\nYes that's clarifies everything. Now I just had to call RequestContext.Set from outside all grain code in my gRPC method body and all the subsequent grain method calls could use the given metadata.\r\n\r\nThank you for your help. This issue can be closed."
      }
    ]
  },
  {
    "number": 7974,
    "title": "4.0-preview2 missing IStartupTask and maybe other types as well",
    "created_at": "2022-09-12T21:06:39Z",
    "closed_at": "2022-09-15T23:02:31Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7974",
    "body": "I'm trying to use IStartupTask in 4.0-preview2 but the type appears to be missed in the consolidation work that occurred between preview1 and preview2.\r\n\r\nThe type is available in Microsoft.Orleans.Runtime.Abstractions 4.0-preview1 but adding that package ends up adding duplicate types across Microsoft.Orleans.Runtime.Abstractions 4.0-preview1 and Microsoft.Orleans.Runtime 4.0-preview2 which makes compiler all kinds of mad. 😊\r\n\r\nNot sure how close 4.0-preview3 is to release, but 4.0-preview2 is unusable for some scenarios due to this issue.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7974/comments",
    "author": "rjygraham",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2022-09-13T15:39:53Z",
        "body": "It's in `Orleans.Runtime` package in the `Orleans.Runtime` namespace (which is not a great namespace for it).\r\nThe abstractions package was removed"
      },
      {
        "user": "ghost",
        "created_at": "2022-09-15T23:02:29Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 7957,
    "title": "Cannot transform data from IEnumerable between two assemblies",
    "created_at": "2022-08-31T10:55:00Z",
    "closed_at": "2022-09-01T23:02:56Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7957",
    "body": "Hi! I have two services and one of them take a Grain which was specified in another service. So after i take it we execute method which shold return class object with fields smth like that\r\n```\r\nclass Person{\r\npublic string Name{get;set;}\r\npublic IEnumerable<Children> ChildrenList {get;set;}\r\n. . .\r\n}\r\n```\r\nAfter method execution we handle the break point in another service where we calculating that data in IEnumerable (we have local function that makes some calculations). Like this\r\n\r\n```\r\npublic class PeopleHandler{\r\npublic async Task ExecuteAsync(personName){\r\nvar name = _context.People.First(_ => _.Name == personName);\r\nvar children = GetChildren(name);\r\n\r\nreturn new Person(name, childrens)\r\n\r\nIEnumerable GetChildren (string personName){\r\nvar children =  _context.GetChildren.Select(. . .) . . .\r\n\r\n return children;\r\n }\r\n}\r\n}\r\n```\r\n\r\nAttention. We don't use ToList() at the end. We handle it like that to another service. So we execute method \r\n\r\n```\r\npublic async Task GetPersonInformation (personName){\r\n  var peopleHandler = _client.GetGrain<PeopleHandler>(grainId);\r\n  var person = await peopleHandler.ExecuteAsync(personName);\r\n\r\n var childrens = person.ChildrenList.ToList() // or any other method that makes programm to calculate data 'First() etc.'\r\n}\r\n```\r\n\r\nAfter that we got an exception about NullReferenceException in Children. We can't calculate data between services. I decided to make it ToList() before we return data from the ExecuteAsync method and i got a result but what was the reason of that? If it wasn't a local function i understand that private functions can be not visible in first assembly but this is local function and we need to know everything about public method including it's private methods inside of it. So i changed return Type of GetChildren and got my result. What do you think?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7957/comments",
    "author": "NikitaPozharskyi",
    "comments": [
      {
        "user": "mnmr",
        "created_at": "2022-09-01T08:45:47Z",
        "body": "When you call a method on a grain, the data (objects) get serialized into a stream of bytes. These bytes are then sent over the network to the receiving grain, where the objects are re-created. However, if you do not call ToList() before sending the data, there is no data to send (because LINQ lazy-evaluates the query).\r\n\r\nAs a general recommendation, use concrete types (i.e. List<T> instead of IList<T> or IEnumerable<T>) when passing data between grains. This avoids surprises and is more explicit than relying on the serialization logic to automagically do the right thing."
      },
      {
        "user": "NikitaPozharskyi",
        "created_at": "2022-09-01T09:00:46Z",
        "body": "> When you call a method on a grain, the data (objects) get serialized into a stream of bytes. These bytes are then sent over the network to the receiving grain, where the objects are re-created. However, if you do not call ToList() before sending the data, there is no data to send (because LINQ lazy-evaluates the query).\r\n> \r\n> As a general recommendation, use concrete types (i.e. List instead of IList or IEnumerable) when passing data between grains. This avoids surprises and is more explicit than relying on the serialization logic to automagically do the right thing.\r\n\r\nThanks for your message! I thought in that way too so i resolved that pretty fast so I just want to be sure that is working like that"
      },
      {
        "user": "ghost",
        "created_at": "2022-09-01T23:02:54Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 7898,
    "title": "[question]a little confusion about ProcessSiloAddEvent(SiloAddress addedSilo) ' in GrainDirectoryHandoffManager.cs",
    "created_at": "2022-08-06T07:41:14Z",
    "closed_at": "2022-08-16T03:34:48Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7898",
    "body": "in this function 'internal void ProcessSiloAddEvent(SiloAddress addedSilo) ' of GrainDirectoryHandoffManager.cs\r\n`\r\n                // Reset our follower list to take the changes into account\r\n                ResetFollowers();\r\n\r\n                // check if this is one of our successors (i.e., if I should hold this silo's copy)\r\n                // (if yes, adjust local and/or copied directory partitions by splitting them between old successors and the new one)\r\n                // NOTE: We need to move part of our local directory to the new silo if it is an immediate successor.\r\n                List<SiloAddress> successors = localDirectory.FindSuccessors(localDirectory.MyAddress, 1);\r\n                if (!successors.Contains(addedSilo))\r\n                {\r\n                    if (logger.IsEnabled(LogLevel.Debug)) logger.Debug($\"{addedSilo} is not one of my successors.\");\r\n                    return;\r\n                }\r\n`\r\nList<SiloAddress> successors = localDirectory.FindSuccessors(localDirectory.MyAddress, 1);  \r\n\r\nwhen the above code executes,  only the immediate successor of myAddress is returned.\r\nso, if the immediate silo is not \"addedSilo\", then the following if statement will always be true and the function return immediately. why only one successor is needed here.\r\ni get stuck in there why only pass \"1\" to the FindSuccessors function.\r\n\r\nlooking forward to your reply\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7898/comments",
    "author": "yulei1990",
    "comments": [
      {
        "user": "yulei1990",
        "created_at": "2022-08-14T09:03:44Z",
        "body": "can anyone help me about this question? why donot get all successors but only immediate successor. i think all successors should be got here..."
      },
      {
        "user": "ReubenBond",
        "created_at": "2022-08-15T23:57:49Z",
        "body": "It's only supposed to find a single successor. This is a process for splitting the grain directory when a new silo is added, so it does not need to know about any silos which come after the immediate successor: that successor is the one which it sends a portion of its directory entries to."
      },
      {
        "user": "yulei1990",
        "created_at": "2022-08-16T02:28:00Z",
        "body": "thank your for your reply. but if only immediate successor is supposed here.\r\nthen the following code's \"else\" part will never get a chance to execute.\r\n\r\n```\r\n// check if this is one of our successors (i.e., if I should hold this silo's copy)\r\n                // (if yes, adjust local and/or copied directory partitions by splitting them between old successors and the new one)\r\n                // NOTE: We need to move part of our local directory to the new silo if it is an immediate successor.\r\n                List<SiloAddress> successors = localDirectory.FindSuccessors(localDirectory.MyAddress, 1);\r\n                if (!successors.Contains(addedSilo))\r\n                {\r\n                    if (logger.IsEnabled(LogLevel.Debug)) logger.Debug($\"{addedSilo} is not one of my successors.\");\r\n                    return;\r\n                }\r\n\r\n                // check if this is an immediate successor\r\n                if (successors[0].Equals(addedSilo))\r\n                {\r\n                    // split my local directory and send to my new immediate successor his share\r\n                    if (logger.IsEnabled(LogLevel.Debug)) logger.Debug(\"Splitting my partition between me and \" + addedSilo);\r\n                    GrainDirectoryPartition splitPart = localDirectory.DirectoryPartition.Split(\r\n                        grain =>\r\n                        {\r\n                            var s = localDirectory.CalculateGrainDirectoryPartition(grain);\r\n                            return (s != null) && !localDirectory.MyAddress.Equals(s);\r\n                        }, false);\r\n                    List<ActivationAddress> splitPartListSingle = splitPart.ToListOfActivations(true);\r\n                    List<ActivationAddress> splitPartListMulti = splitPart.ToListOfActivations(false);\r\n\r\n                    EnqueueOperation(\r\n                        $\"{nameof(ProcessSiloAddEvent)}({addedSilo})\",\r\n                        () => ProcessAddedSiloAsync(addedSilo, splitPartListSingle, splitPartListMulti));\r\n                }\r\n                else\r\n                {\r\n                    // adjust partitions by splitting them accordingly between new and old silos\r\n                    SiloAddress predecessorOfNewSilo = localDirectory.FindPredecessors(addedSilo, 1)[0];\r\n                    if (!directoryPartitionsMap.TryGetValue(predecessorOfNewSilo, out var predecessorPartition))\r\n                    {\r\n                        // we should have the partition of the predcessor of our new successor\r\n                        logger.Warn(ErrorCode.DirectoryPartitionPredecessorExpected, \"This silo is expected to hold directory partition of \" + predecessorOfNewSilo);\r\n                    }\r\n                    else\r\n                    {\r\n                        if (logger.IsEnabled(LogLevel.Debug)) logger.Debug(\"Splitting partition of \" + predecessorOfNewSilo + \" and creating a copy for \" + addedSilo);\r\n                        GrainDirectoryPartition splitPart = predecessorPartition.Split(\r\n                            grain =>\r\n                            {\r\n                                // Need to review the 2nd line condition.\r\n                                var s = localDirectory.CalculateGrainDirectoryPartition(grain);\r\n                                return (s != null) && !predecessorOfNewSilo.Equals(s);\r\n                            }, true);\r\n                        directoryPartitionsMap[addedSilo] = splitPart;\r\n                    }\r\n                }\r\n```\r\ni think the following \"else part\" handles the situation that the spliting silo is not the immediate silo.\r\nif  List<SiloAddress> successors = localDirectory.FindSuccessors(localDirectory.MyAddress, 1);  is only supposed to find\r\nthe immediate successor. then the else part will never be executed.\r\nthat is the thing that has beening confusing me."
      },
      {
        "user": "ReubenBond",
        "created_at": "2022-08-16T03:22:44Z",
        "body": "That class is quite confusing. It did contain some dead code. Take a look at the current version, since it was updated recently"
      },
      {
        "user": "yulei1990",
        "created_at": "2022-08-16T03:34:48Z",
        "body": "i got the latest code. that class did change a lot. i will read the code soon. thank you for your patience."
      }
    ]
  },
  {
    "number": 7892,
    "title": "How to config Orleans in Worker?",
    "created_at": "2022-08-02T07:30:39Z",
    "closed_at": "2022-08-02T23:02:20Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7892",
    "body": "Hi, i am want to have Options and config Orleans. I am want to do like this\r\n\r\n``` C#\r\nvar builder = Host.CreateDefaultBuilder(args);\r\n\r\nbuilder.ConfigureServices((hostContext, services) =>\r\n{\r\n    var orleansSection = hostContext.Configuration.GetSection(OrleansConfiguration.SectionName);\r\n    var orleansConfig = orleansSection.Get<OrleansConfiguration>();\r\n    services.Configure<OrleansConfiguration>(orleans => orleansSection.Bind(orleans));\r\n\r\n    services.AddSingleton(orleansConfig);\r\n\r\n    hostContext.UseOrleans(siloBuilder =>\r\n    {\r\n        \r\n\r\n        siloBuilder.UseLocalhostClustering(siloPort, 30000, new IPEndPoint(IPAddress.Loopback, 11111))\r\n            .Configure<ClusterOptions>(opts =>\r\n            {\r\n                opts.ClusterId = orleansConfig.ClusterId;\r\n                opts.ServiceId = orleansConfig.ServiceId;\r\n            })\r\n            ;\r\n    });\r\n\r\n});\r\n   \r\nIHost host = builder.Build();\r\n\r\nawait host.RunAsync();\r\n```\r\n\r\nHow correct to call UseOrleans here?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7892/comments",
    "author": "P9avel",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2022-08-02T22:24:56Z",
        "body": "One way to do this is to build the configuration yourself, independent of the host builder, and then consume it.\r\nAn alternative is to use the new ASP.NET WebApplicationBuilder, with which you should be able to access Configuration wherever you like."
      },
      {
        "user": "ghost",
        "created_at": "2022-08-02T23:02:18Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 7828,
    "title": "Dear engineer,Can silO and silO grain communicate with each other?",
    "created_at": "2022-07-01T05:56:30Z",
    "closed_at": "2023-12-11T04:32:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7828",
    "body": "First, Thank you very much for answering my questions. \r\n        I've been watching silo for a while, and I know that the same silo can get Grain in silo via GrainFactory. Grain can be obtained from the Client for clusters with different silOS.Grain can be obtained from the Client after the end is connected to the cluster. But how to directly access Grain in one cluster and Grain in another silo. Can you give me an example? Thank you very much",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7828/comments",
    "author": "wz172",
    "comments": [
      {
        "user": "benjaminpetit",
        "created_at": "2022-07-05T13:49:07Z",
        "body": "Hi,\r\n\r\nLet me rephrase to be sure I understand what you want:\r\n\r\nA cluster is a set of silos that have the same configured `ClusterId`.\r\nYou have two clusters of silos, A and B. You want one client to be connected to both clusters, and this client has to be able to know to which cluster it is talking to.\r\n\r\nCorrect?"
      },
      {
        "user": "wz172",
        "created_at": "2022-07-06T02:34:24Z",
        "body": "Yes.\r\n\r\nThe purpose is that the grain of two different Silos in the cluster can call each other.But instead of accessing grain from an out-of-code client, it is accessed from within the cluster.\r\n\r\nI used the Redis component to form a cluster of heterogeneous SilOS. Is it possible to get the Grain interface objects in all clusters in one Grain, via silo's built-in hosted Iclusterclient object or IGrainFactory? Of course, I need to add the IGrain interface from the Silo of this Grain.\r\n\r\nThank you again for your answer, Your mind is sharp and clear. you`re very professional."
      }
    ]
  },
  {
    "number": 7749,
    "title": "discouple client and silohost cluster",
    "created_at": "2022-05-19T07:23:39Z",
    "closed_at": "2022-06-09T13:16:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7749",
    "body": "why client and silohost use long connection to bind together?\r\nI think use RestApi or something else to discouple the relationship  is a better solution. ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7749/comments",
    "author": "wuzhenda",
    "comments": [
      {
        "user": "benjaminpetit",
        "created_at": "2022-06-09T12:52:20Z",
        "body": "Sorry I meant to respond to you before.\r\n\r\nWe use raw TCP connections for performance reason. If you want to decouple, you can implement your own rest API on top of an Orleans client."
      }
    ]
  },
  {
    "number": 7688,
    "title": "Calling IGrainFactory.GetGrain<T>(pk) from constructor is a bad practice ?",
    "created_at": "2022-04-14T03:49:37Z",
    "closed_at": "2022-04-14T18:40:53Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7688",
    "body": "I'm doing some experiments with the Orleans.\r\n\r\nI tried to find the answer but i could not...\r\n\r\nIs it a bad idea reusing another grain gathered from the constructor like this ?\r\n\r\n```csharp\r\npublic class MainGrain : Grain, IMainGrain\r\n{\r\n    private readonly IOtherGrain _otherGrain;\r\n\r\n    public MainGrain(IGrainActivationContext context, IGrainFactory grainFactory) \r\n    {\r\n        _otherGrain = grainFactory.GetGrain<IOtherGrain>(context.GrainIdentity.PrimaryKeyString);\r\n    }\r\n\r\n    public ValueTask<Item> GetCurrentValue() =>\r\n        _otherGrain.GetItem();\r\n\r\n   //others methods here\r\n}\r\n````\r\n\r\nMainGrain stay in memory longer then IOtherGrain... (Calling GetCurrentValue() may call a already collected grain)",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7688/comments",
    "author": "fernandozago",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2022-04-14T03:53:19Z",
        "body": "It's fine to call GetGrain in the grain's constructor.\r\n\r\nGetGrain doesn't return the grain itself, just a reference to it. It's similar to a URL or a typed HttpClient wrapper. It's a fast, synchronous operation and doesn't perform any IO."
      },
      {
        "user": "fernandozago",
        "created_at": "2022-04-14T03:55:43Z",
        "body": "> It's fine to call GetGrain in the grain's constructor.\r\n> \r\n> GetGrain doesn't return the grain itself, just a reference to it. It's similar to a URL or a typed HttpClient wrapper. It's a fast, synchronous operation and doesn't perform any IO.\r\n\r\nThanks for the quick reply!\r\n\r\nEven if the `OtherGrain` eventually gets `Deactivated`, it should reactivate again when i call `GetItem()` ?\r\n\r\nThank you @ReubenBond "
      },
      {
        "user": "ReubenBond",
        "created_at": "2022-04-14T03:57:18Z",
        "body": "That's exactly right, Orleans will make sure to activate it on-demand for you"
      }
    ]
  },
  {
    "number": 7652,
    "title": "test issue",
    "created_at": "2022-03-26T00:57:30Z",
    "closed_at": "2022-03-26T01:37:17Z",
    "labels": [
      "question",
      "Needs: attention :wave:"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7652",
    "body": null,
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7652/comments",
    "author": "rafikiassumani-msft",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2022-03-26T00:59:36Z",
        "body": "Hi @rafikiassumani-msft We have added the \"Needs: Author Feedback\" label to this issue, which indicates that we have an open question for you before we can take further action. This issue will be closed automatically in 7 days if we do not hear back from you by then - please feel free to re-open it if you come back to this issue after that time."
      },
      {
        "user": "rafikiassumani-msft",
        "created_at": "2022-03-26T01:00:22Z",
        "body": "It's not an issue"
      },
      {
        "user": "ghost",
        "created_at": "2022-03-26T01:20:30Z",
        "body": "We're moving this issue to the `4.0-Planning` milestone for future evaluation / consideration. Because it's not immediately obvious that this is a bug in our framework, we would like to keep this around to collect more feedback, which can later help us determine the impact of it. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it's very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues."
      }
    ]
  },
  {
    "number": 7625,
    "title": "Query about deploying new codebase",
    "created_at": "2022-03-09T17:47:52Z",
    "closed_at": "2022-03-18T01:02:34Z",
    "labels": [
      "question",
      "Needs: author feedback",
      "Status: no recent activity"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7625",
    "body": "Hi all,\r\n\r\nI have a query regarding what happens to active grains when I deploy a new codebase. Take for example the following grain:\r\n\r\n```\r\npublic interface IUserGrain : IGrainWithGuidKey\r\n{\r\n    Task SendEmail();\r\n}\r\n\r\npublic class UserGrain: Grain, IUserGrain\r\n{\r\n    public Task SendEmail()\r\n    {\r\n    ....\r\n    }\r\n}\r\n```\r\n\r\nThese have methods on them but the content of them doesn't matter for this query.\r\n\r\nSo this version of the grain is deployed and I have activations for it. I then deploy a newer version which has a property on the grain implementation which is set on activation:\r\n\r\n```\r\npublic class UserGrain: Grain, IUserGrain\r\n{\r\n    private object _preferences;\r\n\r\n    public override Task OnActivateAsync()\r\n    {\r\n        _preferences = .....;\r\n    }\r\n\r\n    public Task SendEmail()\r\n    {\r\n        if(preferences....)\r\n    }\r\n}\r\n```\r\n\r\nSo for new activations the new property will be initialised and can be used by other methods on the grain. \r\n\r\nWhat I'm not sure about is what happens to existing activations after deployment? Will they cause a null reference exception as the grains are already activated and so won't initialise the property?\r\n\r\nIf so, is there a way of forcing reactivating active grains? Something to do with versioning? Or do I just need to be a bit more defensive in my coding and check for null references and initialise accordingly?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7625/comments",
    "author": "ADringer",
    "comments": [
      {
        "user": "benjaminpetit",
        "created_at": "2022-03-10T09:00:09Z",
        "body": "I am not sure to understand your question.\r\n\r\nActivations that are created on a silo with the old `UserGrain` will have the old implementation. Activations created on a silo with the new `UserGrain` will have the new implemention?\r\n\r\nWhen a silo shut down, all its activation will be deactivated. Then new activations will be created on another silo when needed (when there is a request made to them). When a new activation is created, `OnActivateAsync` will be called.\r\n\r\n`OnActivateAsync` is called everytime an activation is created."
      },
      {
        "user": "ghost",
        "created_at": "2022-03-14T20:00:52Z",
        "body": "This issue has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **4 days**. It will be closed if no further activity occurs **within 3 days of this comment**."
      }
    ]
  },
  {
    "number": 7570,
    "title": "SMS Stream provider: Ability to await for the queue to balance out ",
    "created_at": "2022-02-16T21:49:08Z",
    "closed_at": "2022-02-24T20:01:20Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7570",
    "body": "This is strictly a request to make testing simpler, consider the following contrived example that uses an SMS Provider with `FireAndForgetDelivery` set to true:\r\n\r\n```csharp\r\nawait fooGrain.DoSomething();\r\nawait Task.Delay(1000);\r\nvar barStatus = await barGrain.GetStatus();\r\nAssert.True(barStatus.FooHasDoneSomething);\r\n```\r\n\r\nBarGrain in this case has an explicit stream subscription to FooGrain, though this may be an indirect subscription through additional grains. The `Task.Delay` call is purely meant to ensure that all stream messages have been processed. 1s may or may not be sufficient depending on the environment where this test is running.\r\n\r\nI'm looking for an option to replace the `Task.Delay` call with something that can ensure that all the SMS Stream provider is clear and no longer has any messages to process. This also requires the SMS Stream provider to be aware when an Event has been processed and also needs to assumes that no OneWay grain calls have been queued up.\r\n\r\nHypothetically I could write a helper method in the form of:\r\n\r\n```csharp\r\nasync Task AwaitEmptyStreamQueue()\r\n{\r\n  var smsStatusProvider = Cluster.ServiceProvider.GetRequiredService<SMSStatusProvider>();\r\n  while (true){\r\n     if (smsStatusProvider.GetPendingMessagesCount() > 0){\r\n        await Task.Delay(10); // Short delay, not really affecting our test durations or reliability\r\n     }\r\n  }\r\n}\r\n```\r\n\r\nWith something like the above, we could cleanly ensure that all pending messages have been processed. \r\n\r\nI'm happy to champion this if this issue makes sense.\r\n\r\n(Outside of the scope of this issue, it would also be useful to look into the state of the cluster to see if any calls are still ongoing).\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7570/comments",
    "author": "koenbeuk",
    "comments": [
      {
        "user": "benjaminpetit",
        "created_at": "2022-02-18T08:54:32Z",
        "body": "SMS isn't a \"real\" stream provider and we are considering removing it for 4.0 final. I don't think we want to invest more in it.\r\n\r\nYour proposition could make sense for MemoryStreams though."
      }
    ]
  },
  {
    "number": 7567,
    "title": "PubSubRendezvousGrain.RegisterConsumer failure",
    "created_at": "2022-02-16T12:17:20Z",
    "closed_at": "2022-02-25T01:00:53Z",
    "labels": [
      "question",
      "Needs: author feedback",
      "Status: no recent activity"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7567",
    "body": "Hi all,\r\nhad anyone else encountered this issue\r\n\r\n```\r\n\"ClassName\":\"System.InvalidOperationException\",\r\n\"Message\":\"Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.\",\r\n\"Data\":null,\r\n\"InnerException\":null,\r\n\"HelpURL\":null,\r\n\"StackTraceString\":\"   at Orleans.Streams.PubSubRendezvousGrain.RegisterConsumer(GuidId subscriptionId, StreamId streamId, IStreamConsumerExtension streamConsumer, IStreamFilterPredicateWrapper filter)\r\n   at Orleans.Streams.OrleansCodeGenPubSubRendezvousGrainMethodInvoker.Invoke(IAddressable grain, InvokeMethodRequest request)\r\n   at Orleans.Runtime.GrainMethodInvoker.Invoke()\r\n   at OrleansDashboard.Metrics.GrainProfilerFilter.Invoke(IIncomingGrainCallContext context)\r\n   at Orleans.Runtime.GrainMethodInvoker.Invoke()\r\n   at <MyGrainInvoke>\",\r\n\"RemoteStackTraceString\":null,\r\n\"RemoteStackIndex\":0,\r\n\"ExceptionMethod\":null,\r\n\"HResult\":-2146233079,\r\n\"Source\":\"Orleans.Runtime\",\r\n\"WatsonBuckets\":null\r\n\r\n```\r\nIt occurs during consumer grain subscription to stream. One consumer grain opens more than one subscription (to different streams) and there is only one producer per stream.\r\n\r\nOrleans version 3.5.1 is used on net5.0 framework.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7567/comments",
    "author": "mradovcic",
    "comments": [
      {
        "user": "benjaminpetit",
        "created_at": "2022-02-16T12:49:08Z",
        "body": "I don't recall seeing this issue. Can you repro it reliably? "
      },
      {
        "user": "mradovcic",
        "created_at": "2022-02-16T13:53:38Z",
        "body": "I've tried but unfortunately no."
      },
      {
        "user": "rafikiassumani-msft",
        "created_at": "2022-02-17T19:18:44Z",
        "body": "@mradovcic as @benjaminpetit  suggested we will need a repro for this. "
      },
      {
        "user": "ghost",
        "created_at": "2022-02-21T20:00:56Z",
        "body": "This issue has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **4 days**. It will be closed if no further activity occurs **within 3 days of this comment**."
      }
    ]
  },
  {
    "number": 7454,
    "title": "Generate code for all types in another Assembly",
    "created_at": "2021-12-31T14:02:51Z",
    "closed_at": "2022-01-06T23:00:55Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7454",
    "body": "I want to Generate code for all types in another assembly\r\nI follow the steps of the official documentation:\r\n    1、Create a C# project.\r\n    2、Install the Microsoft.Orleans.CodeGenerator.MSBuild or the Microsoft.Orleans.OrleansCodeGenerator.Build package.\r\n    3、Add a reference to the target assembly.\r\n    4、Add [assembly: KnownAssembly(\"OtherAssembly\")] at the top level of a C# file.\r\nWhen I get to step 4, I find that KnownAssembly attribute cannot take a string as an argument.\r\nWho can help me?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7454/comments",
    "author": "suixin567",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2022-01-06T19:02:58Z",
        "body": "You can use any type in the other assembly instead of the assembly name"
      },
      {
        "user": "ghost",
        "created_at": "2022-01-06T23:00:52Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 7453,
    "title": "I cannot ues enum in orleans.",
    "created_at": "2021-12-31T07:10:24Z",
    "closed_at": "2022-01-14T01:00:53Z",
    "labels": [
      "question",
      "Needs: author feedback",
      "Status: no recent activity"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7453",
    "body": "i have a independent lib，and some class 、enum in it，when run multiple silos，the enum in lib will throw error，and classes in same lib works well，it seems like enum cannot be use in orleans.\r\nthe error is :\r\nNamed type \"ObjectType\" is invalid: Type string \"ObjectType\" cannot be resolved.\r\nfinaly，i find a way to resove the error is cite OrleansCodeGenerator.Build package in that lib，\r\nbut if use this package，my project will only run in NetCore3.1 and cannot run in .Net5.0\r\nand dashboard need .Net5.0\r\ni  can't stand the absence of dashboard.\r\nwho can help me ? thsnks very much!",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7453/comments",
    "author": "suixin567",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2022-01-06T19:05:33Z",
        "body": "I believe the answer to this is in #7454. In other words, the code generator needs to examine all assemblies which have types which are going to be sent over the wire\r\n"
      },
      {
        "user": "ghost",
        "created_at": "2022-01-10T20:00:55Z",
        "body": "This issue has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **4 days**. It will be closed if no further activity occurs **within 3 days of this comment**."
      }
    ]
  },
  {
    "number": 7451,
    "title": "Silos cannot find each other after a re-run when using RedisClustring",
    "created_at": "2021-12-27T08:24:05Z",
    "closed_at": "2021-12-27T10:34:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7451",
    "body": "Hi \r\nI'm trying to run orleans locally for development  but i'm using redis clustring.\r\nI have 2 silo each host different kind of grains. On first run everything work fine but when i try to re-run my silos they cannot find each other and they try to connect to dead silos for about 10 minutes.\r\n\r\n`Failed to get ping responses from 1 of 1 active silos. Newly joining silos validate connectivity with all active silos that have recently updated their 'I Am Alive' value before joining the cluster. Successfully contacted: []. Silos which did not respond successfully are: [S10.163.245.127:11111:378287550]. Will continue attempting to validate connectivity until 12/27/2021 08:08:04. Attempt #3`\r\n\r\nHere my configurations for silos:\r\n```\r\n    siloBuilder.UseRedisClustering(options => \r\n                    { \r\n                         options.ConnectionString = redisConnectionString; options.Database = 0; \r\n                    })\r\n                    .ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000)\r\n                    .Configure<ClusterOptions>(options =>\r\n                    {\r\n                        options.ClusterId = \"dev\";\r\n                        options.ServiceId = \"OrleansBasics\";\r\n                    })\r\n                    .ConfigureLogging(logging => logging.AddConsole())\r\n```\r\n\r\n```\r\nsiloBuilder\r\n                    .UseRedisClustering(options => \r\n                    { \r\n                        options.ConnectionString = redisConnectionString; options.Database = 0; \r\n                    })\r\n                    .ConfigureEndpoints(siloPort: 11112, gatewayPort: 30002)\r\n                    .Configure<ClusterOptions>(options =>\r\n                    {\r\n                        options.ClusterId = \"dev\";\r\n                        options.ServiceId = \"OrleansBasics\";\r\n                    })\r\n                    .ConfigureLogging(logging => logging.AddConsole())\r\n```",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7451/comments",
    "author": "zeinali0",
    "comments": [
      {
        "user": "benjaminpetit",
        "created_at": "2021-12-27T09:09:29Z",
        "body": "It's expected, previous silo instances did not shutdown properly. \r\n\r\nTwo solutions:\r\n\r\n- make sure that your silo can shutdown properly (might not be practical in dev environment, but you need to make sure it actually works for production)\r\n- use another `ClusterId`  every time you deploy a new cluster"
      },
      {
        "user": "zeinali0",
        "created_at": "2021-12-27T10:06:02Z",
        "body": "Even in production there is possibility to silo not shutdown properly \r\nwhat should we do if we want to immediately replace dead silo with new one?\r\nIs there any reason it configured such a long time to detect a silo is dead?\r\nUsing new `ClusterId` mean if one silo died we should re-run all other silos and clients again with new clusterId. this may cause no problem in development but it can be problematic in production."
      },
      {
        "user": "benjaminpetit",
        "created_at": "2021-12-27T10:21:31Z",
        "body": "What you are experiencing here is only happening because all silos from the cluster are dead. When a silo tries to join an existing cluster, it will tries to ping all silos marked alive (ignoring values not updated for more than `NumMissedTableIAmAliveLimit * IAmAliveTablePublishTimeout`, by default 10min).\r\n\r\nIf you have a 3-silo cluster, and one of them crashes, the two remaining would vote the 3rd dead quite quickly, updating the membership table. A new silo would be able to start without any troubles.\r\n\r\nIn your case the silo trying to join the cluster is a bit stuck: why it is not able to ping the silo marked `Alive` in the membership table? Is it because they are dead? Is it because of a network/config issue? It is safer in this case to just give up with a clear error message."
      },
      {
        "user": "zeinali0",
        "created_at": "2021-12-27T10:33:59Z",
        "body": "That make sense. I didn't know this happen only when all silos is dead. I thought it always happen for new silos when they gonna join cluster.\r\nThanks for Details."
      }
    ]
  },
  {
    "number": 7401,
    "title": "Doubt in Co-Hosting ASP.NET and Orleans",
    "created_at": "2021-11-21T16:24:37Z",
    "closed_at": "2023-11-21T07:44:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7401",
    "body": "In a co-hosting Orleans and ASP.NET, assuming I have hosted the application in multiple nodes. Should I place all my nodes behind a Load Balancer to distribute traffic to each silo/node? Or is there no need to put up an Load Balancer for distributing HTTP load among all the silos/nodes?\n\nI am fairly new to Orleans, kindly guide me if my fundamental understanding is wrong.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7401/comments",
    "author": "shyamsundarb-arch",
    "comments": [
      {
        "user": "SebastianStehle",
        "created_at": "2021-11-21T16:29:23Z",
        "body": "Yes, you should put your nodes behind a load balancer. \r\n There are 2 main reasons for that:\r\n \r\n1. Availability: If you have only one HTTP server your users will loose access to your backend if this server goes down. Even if it gets restarted after a few minutes, you don't want this.\r\n\r\n2. Your requests have many steps: JSON deserialization -> Orleans stuff -> JSON serialization (and many more). If you have only one server act as HTTP gateway you cannot scale the JSON / API stuff."
      },
      {
        "user": "shyamsundarb-arch",
        "created_at": "2021-11-21T16:43:56Z",
        "body": "> Yes, you should put your nodes behind a load balancer. \n> \n>  There are 2 main reasons for that:\n> \n>  \n> \n> 1. Availability: If you have only one HTTP server your users will loose access to your backend if this server goes down. Even if it gets restarted after a few minutes, you don't want this.\n> \n> \n> \n> 2. Your requests have many steps: JSON deserialization -> Orleans stuff -> JSON serialization (and many more). If you have only one server act as HTTP gateway you cannot scale the JSON / API stuff.\n\nThank you for the prompt reply. A small top up question is, does this mean when the ASP.NET controller invokes a GetGrain request, the grain gets created only in the node in which the controller received the request in? Or can it get created in any silo/node in the cluster? "
      },
      {
        "user": "SebastianStehle",
        "created_at": "2021-11-21T18:20:53Z",
        "body": "> Thank you for the prompt reply. A small top up question is, does this mean when the ASP.NET controller invokes a GetGrain request, the grain gets created only in the node in which the controller received the request in? Or can it get created in any silo/node in the cluster?\r\n\r\nUsually it is the same node, but if the grain already exists on another node or if you have a custom placement logic (it decides where grains will be created) it can also be another node."
      }
    ]
  },
  {
    "number": 7395,
    "title": "[Rafiki Test] - Testing",
    "created_at": "2021-11-17T03:21:40Z",
    "closed_at": "2021-11-17T03:23:02Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7395",
    "body": null,
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7395/comments",
    "author": "rafikiassumani-msft",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2021-11-17T03:23:02Z",
        "body": "This issue has been resolved and has not had any activity for **1 day**. It will be closed for housekeeping purposes."
      }
    ]
  },
  {
    "number": 7389,
    "title": "[Question] Is there a way to disable client connections to silo hosts with orleans server endpoint configuration?",
    "created_at": "2021-11-13T12:23:40Z",
    "closed_at": "2021-11-17T05:00:58Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7389",
    "body": "For some cases, like when silo hosts only process messages from message broker or like when grpc/web api service is hosted in same generic host with orleans silo, i don't need a gateway port to listen to client connections, and would like to disable it completely to reduce attack surface.\r\n\r\nIs there a way to configure silo host so that it will not accept client connections?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7389/comments",
    "author": "modabas",
    "comments": [
      {
        "user": "benjaminpetit",
        "created_at": "2021-11-15T12:34:04Z",
        "body": "If you set `EndpointOptions.GatewayPort` to `0` then the gateway will be disabled"
      },
      {
        "user": "ghost",
        "created_at": "2021-11-17T05:00:56Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 7371,
    "title": "Question: GrainObserver lifetime and Grain lifetime",
    "created_at": "2021-11-03T11:48:07Z",
    "closed_at": "2022-02-10T23:01:06Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7371",
    "body": "Hi\r\nI was checking Observer example in docs:\r\n```\r\nclass HelloGrain : Grain, IHello\r\n{\r\n    private readonly ObserverManager<IChat> _subsManager;\r\n\r\n    public HelloGrain(ILogger<HelloGrain> logger)\r\n    {\r\n        _subsManager = new ObserverManager<IChat>(TimeSpan.FromMinutes(5), logger, \"subs\");\r\n    }\r\n\r\n    // Clients call this to subscribe.\r\n    public Task Subscribe(IChat observer)\r\n    {\r\n        _subsManager.Subscribe(observer, observer);\r\n        return Task.CompletedTask;\r\n    }\r\n\r\n    //Clients use this to unsubscribe and no longer receive messages.\r\n    public Task UnSubscribe(IChat observer)\r\n    {\r\n        _subsManager.Unsubscribe(observer, observer);\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\nThere are some question:\r\nWhen a grain get Deactivate?\r\nIs it possible a grain get deactivate as long as some IGrainObserver subscibed to it?\r\nAnd If yes Can we use IPersistentState to store IGrainObserver subscibed to a grain?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7371/comments",
    "author": "zeinali0",
    "comments": [
      {
        "user": "benjaminpetit",
        "created_at": "2021-11-24T09:10:49Z",
        "body": "> When a grain get Deactivate?\r\n\r\nWhen it is idle for a given period of time, or if the silo hosting it is shutting down, or if the directory entry pointing to this activation is no more, etc.\r\n\r\n> Is it possible a grain get deactivate as long as some IGrainObserver subscibed to it?\r\n\r\nYes\r\n\r\n> And If yes Can we use IPersistentState to store IGrainObserver subscibed to a grain?\r\n\r\nYes you can."
      },
      {
        "user": "ghost",
        "created_at": "2022-02-10T23:01:04Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 7370,
    "title": "Microsoft.Orleans.CodeGenerator.MSBuild package is not in the CI NuGet feed",
    "created_at": "2021-11-02T17:24:02Z",
    "closed_at": "2023-12-11T03:40:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7370",
    "body": "The last version in the CI  feed is `3.9.9-ci.20210809.1` and everyone else is at or past `3.9.9-ci.20211030.1`.\r\n\r\nIs there a reason for this?\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7370/comments",
    "author": "fuocor",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2023-12-11T03:40:31Z",
        "body": "The .MSBuild package is no longer being published: it was replaced by the C# source generator in v7.0+ - use Microsoft.Orleans.Sdk"
      }
    ]
  },
  {
    "number": 7292,
    "title": "Question: How to extract data for reporting",
    "created_at": "2021-09-22T15:27:10Z",
    "closed_at": "2021-11-17T05:01:04Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7292",
    "body": "Hi Folks!\r\n\r\nOrleans seems to be great for any kind of Transaction-Processing: For hot data you never have to hit slow storage, you structure the data within the Grains as it is best for processing. No need to build complex DB style queries. Keeping all data for reporting within the Grain state seems to be a pretty awful idea, including historical data not needed for the processing itself. You also want to control the DB Schema, and don't use the generic DB Schema from Orleans to directly run any queries.\r\n\r\nAre there any best practices how to implement this? Should this just be a part of eachs Grain implementation? Would it be a good idea to use a Stream for individual events of data change? Should I look into features like Interceptors or Journaling for this?\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7292/comments",
    "author": "gprossliner",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2021-09-23T19:14:06Z",
        "body": "Hi @gprossliner, some internal services write events to an external stream for auditing/reporting purposes.\r\nI would probably make this a part of each grain's implementation. Another alternative is to use event sourcing (the pattern, not necessarily the Orleans.EventSourcing library) and emit events that can be analyzed by a report generation service.\r\n\r\nMembers of the community might have other ideas or experiences to share"
      },
      {
        "user": "ghost",
        "created_at": "2021-11-17T05:01:03Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 7277,
    "title": "Questions about activation timeouts",
    "created_at": "2021-09-18T10:25:53Z",
    "closed_at": "2021-11-17T05:01:07Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7277",
    "body": "There are a lot of such warns in both my development environment and production environment.I don't know how to fix it.\r\n`\r\n2021-09-18 18:13:19.3781 WARN Task [Id=302, Status=RanToCompletion] in WorkGroup [SystemTarget: S127.0.0.1:22222:369655980*stg/20/00000014@S00000014] took elapsed time 0:00:01.6575007 for execution, which is longer than 00:00:00.2000000. Running on thread 59\r\n2021-09-18 18:13:20.5353 WARN Task [Id=340, Status=RanToCompletion] in WorkGroup [SystemTarget: S127.0.0.1:22222:369655980*stg/20/00000014@S00000014] took elapsed time 0:00:01.0581741 for execution, which is longer than 00:00:00.2000000. Running on thread 59\r\n2021-09-18 18:13:22.4276 WARN Task [Id=453, Status=RanToCompletion] in WorkGroup [SystemTarget: S127.0.0.1:22222:369655980*stg/29/0000001d@S0000001d] took elapsed time 0:00:00.2665492 for execution, which is longer than 00:00:00.2000000. Running on thread 59\r\n2021-09-18 18:13:22.5709 WARN Task [Id=466, Status=RanToCompletion] in WorkGroup [SystemTarget: S127.0.0.1:22222:369655980*stg/22/00000016@S00000016] took elapsed time 0:00:00.2767715 for execution, which is longer than 00:00:00.2000000. Running on thread 49\r\n2021-09-18 18:13:23.6345 WARN Task [Id=615, Status=RanToCompletion] in WorkGroup [SystemTarget: S127.0.0.1:22222:369655980*stg/LifecycleScheduling/00000014@S00000014] took elapsed time 0:00:00.4187412 for execution, which is longer than 00:00:00.2000000. Running on thread 49\r\n2021-09-18 18:13:32.3105 WARN Task [Id=1202, Status=RanToCompletion] in WorkGroup [Activation: S127.0.0.1:22222:369655980*grn/OrleansDashboard.Metrics.Grains.SiloGrain/0+127.0.0.1:22222@369655980@e69a6a9c #GrainType=OrleansDashboard.Metrics.Grains.SiloGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.3288166 for execution, which is longer than 00:00:00.2000000. Running on thread 51\r\n2021-09-18 18:13:32.5925 WARN Task [Id=1212, Status=RanToCompletion] in WorkGroup [Activation: S127.0.0.1:22222:369655980*grn/Orleans.Runtime.Management.ManagementGrain/0@52ca08a0 #GrainType=Orleans.Runtime.Management.ManagementGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2192257 for execution, which is longer than 00:00:00.2000000. Running on thread 59\r\n2021-09-18 18:13:34.2540 WARN Task [Id=1264, Status=RanToCompletion] in WorkGroup [Activation: S127.0.0.1:22222:369655980*grn/OrleansDashboard.Metrics.Grains.SiloGrain/0+127.0.0.1:22222@369655980@e69a6a9c #GrainType=OrleansDashboard.Metrics.Grains.SiloGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2592585 for execution, which is longer than 00:00:00.2000000. Running on thread 48\r\n2021-09-18 18:13:34.4820 WARN Task [Id=1274, Status=RanToCompletion] in WorkGroup [Activation: S127.0.0.1:22222:369655980*grn/Orleans.Runtime.Management.ManagementGrain/0@52ca08a0 #GrainType=Orleans.Runtime.Management.ManagementGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.3773679 for execution, which is longer than 00:00:00.2000000. Running on thread 57\r\n2021-09-18 18:13:34.5479 WARN Task [Id=1260, Status=RanToCompletion] in WorkGroup [SystemTarget: S127.0.0.1:22222:369655980*stg/DeploymentLoadPublisher/00000016@S00000016] took elapsed time 0:00:00.3151025 for execution, which is longer than 00:00:00.2000000. Running on thread 59\r\n2021-09-18 18:13:34.9917 WARN Task [Id=1270, Status=RanToCompletion] in WorkGroup [SystemTarget: S127.0.0.1:22222:369655980*stg/DeploymentLoadPublisher/00000016@S00000016] took elapsed time 0:00:00.2521283 for execution, which is longer than 00:00:00.2000000. Running on thread 59\r\n2021-09-18 18:13:47.0841 WARN Task [Id=2175, Status=RanToCompletion] in WorkGroup [Activation: S127.0.0.1:22222:369655980*grn/***********************************/21248@ef6f21b1 #GrainType=*********************************** Placement=StatelessWorkerPlacement State=Valid] took elapsed time 0:00:00.4311407 for execution, which is longer than 00:00:00.2000000. Running on thread 50\r\n2021-09-18 18:13:52.7944 WARN Task [Id=3073, Status=RanToCompletion] in WorkGroup [Activation: S127.0.0.1:22222:369655980*grn/***********************************/512@ba641880 #GrainType=*********************************** Placement=StatelessWorkerPlacement State=Valid] took elapsed time 0:00:00.2306303 for execution, which is longer than 00:00:00.2000000. Running on thread 51\r\n2021-09-18 18:13:52.9957 WARN Task [Id=3124, Status=RanToCompletion] in WorkGroup [SystemTarget: S127.0.0.1:22222:369655980*stg/DeploymentLoadPublisher/00000016@S00000016] took elapsed time 0:00:00.2654527 for execution, which is longer than 00:00:00.2000000. Running on thread 58\r\n2021-09-18 18:13:53.3347 WARN Task [Id=3267, Status=RanToCompletion] in WorkGroup [Activation: S127.0.0.1:22222:369655980*grn/***********************************/9472@32c177a5 #GrainType=*********************************** Placement=StatelessWorkerPlacement State=Valid] took elapsed time 0:00:00.2330157 for execution, which is longer than 00:00:00.2000000. Running on thread 65\r\n2021-09-18 18:13:53.4279 WARN Task [Id=3286, Status=RanToCompletion] in WorkGroup [Activation: S127.0.0.1:22222:369655980*grn/***********************************/4352@a084d38f #GrainType=*********************************** Placement=StatelessWorkerPlacement State=Valid] took elapsed time 0:00:00.27929 for execution, which is longer than 00:00:00.2000000. Running on thread 66\r\n2021-09-18 18:14:01.8618 WARN Task [Id=4575, Status=RanToCompletion] in WorkGroup [SystemTarget: S127.0.0.1:22222:369655980*stg/DeploymentLoadPublisher/00000016@S00000016] took elapsed time 0:00:00.3278819 for execution, which is longer than 00:00:00.2000000. Running on thread 52\r\n\r\n`",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7277/comments",
    "author": "pughua",
    "comments": [
      {
        "user": "xinyi-joffre",
        "created_at": "2021-09-19T00:12:29Z",
        "body": "+1 @ReubenBond, we are also seeing these warnings in our environment. Is this related to thread starvation?"
      },
      {
        "user": "ReubenBond",
        "created_at": "2021-09-19T20:50:50Z",
        "body": "This kind of thing typically indicates a performance issue somewhere in your application. It could be an indication of long GC pauses, synchronous blocking, or potentially something more subtle like container CPU throttling which can pause your application for 10s of milliseconds at a time. The best way to determine the source usually involves CPU profiling.\r\n\r\nThe warning is issued as a kind of courtesy to help developers to identify the presence of other issues, but perhaps we should consider disabling the warning and allowing developers to discover the issues on their own."
      },
      {
        "user": "nkosi23",
        "created_at": "2021-09-20T10:08:18Z",
        "body": "> but perhaps we should consider disabling the warning and allowing developers to discover the issues on their own.\r\n\r\nPlease do not remove it, this behavior is actually quite useful since very often people do not have the time to profile their application thoroughly. This adds to the value added provided by Orleans out-of-the-box in that this is an additional way to help us build scalable application where we wouldn't have the time to set up this basic warning throughout the codebase otherwise."
      },
      {
        "user": "JorgeCandeias",
        "created_at": "2021-09-20T16:06:39Z",
        "body": "I support @nkosi23's comment. In my experience, 9/10 times I've seen this issue, it was a tell for poor coding practices, 1/10 times it was resource issues and 10/10 times the warning was useful."
      },
      {
        "user": "ghost",
        "created_at": "2021-11-17T05:01:06Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 7268,
    "title": "How to create grains working with SQL Server?",
    "created_at": "2021-09-08T14:19:38Z",
    "closed_at": "2021-11-17T05:01:10Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7268",
    "body": "How to create this or where can I find any sample like this style:\r\n\r\nThe server creates silo with grains to work with SQL Server database, for example:\r\nGetProduct(id)\r\nGetProducts()\r\nAddProduct(id)\r\nDelProduct(id)\r\nDelProducts()\r\n\r\nWhen clients (multiple, in any language) connect to the server and send commands like:\r\n/GetProduct?id=idx etc (REST, GRPC, GraphQL)\r\nthe server created the grains and each grain executes and returns status and data .\r\n\r\nI build a ASP.NET Core web server which works via (REST, GRPC, GraphQL). thats thy the question.\r\nThank you!",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7268/comments",
    "author": "ZedZipDev",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2021-09-08T22:04:08Z",
        "body": "Hi @Oleg26Dev, I'm not sure if there are any samples for this (grain calling into SQL directly), but it is relatively straightforward: you create grains and grain interfaces which have those methods and then call into SQL directly from the implementation.\r\n\r\nWhat benefit are you looking for Orleans to give you in this case, other than perhaps caching `GetProduct(id)` calls. Could you elaborate on what you'd like Orleans to handle here?\r\n"
      },
      {
        "user": "ZedZipDev",
        "created_at": "2021-09-09T09:31:46Z",
        "body": "Hi @ReubenBond , \r\nI have now WCF web service. It SOAP+REST. But it is legacy (as MS declared) and I am rewriting it using gRPC.NET, adding GraphQL endpoint and REST still exist.\r\nI see what yet new technologies can be used. \r\nI am going to add Orleans  to the server to use caching (as you correctly wrote), performance and scalability, i.e. to use clustering provided by Orleans. \r\nThe schema of my web service is: \r\nClient -> Web Service->Database Server->database\r\nEvery client passes to server Database (SQL Server or PostgreSQL) name, database name and query.\r\nI.e. \r\nN11 clients (SQL Server1+db11)->Web Service->SQL Server1->db1\r\nN12 clients (SQL Server1+db12)->Web Service->SQL Server1->db12\r\n...\r\nN101 clients (SQL Server2+db21)->Web Service->SQL Server2->db21\r\n...\r\nP1 clients (PGSQL1+dbp21)->Web Service->PGSQL1+dbp21\r\nand so on.\r\n\r\nThe loading can be different in different day/night time, including very high in some 1-2 hrs.\r\n\r\n"
      },
      {
        "user": "NTTAKR",
        "created_at": "2021-09-12T12:32:46Z",
        "body": "Hi @Oleg26Dev, @ReubenBond \r\n\r\nMy setup is not very different from your description, but I am using MongoDB as a database. \r\nWhat you should definitely have in mind is number of connections to the database. \r\nOrleans is easily scaling to multiple thousands of grains on a single machine, whereas your database would be very upset if every grain would make its own database connection. \r\nYou would quickly run out of instances. \r\n\r\nI was thinking about having a number of grains that work as database \"workers\" and they ask for work on some sort of coordinator.\r\nSo you have the client issueing work items to grains, the grains themselves putting their work-order into a coordinator grain and the database \"worker\" grains asking the coordinator for work items. \r\nYou can control how much worker grains are alive and even modify that during runtime if desired. \r\n\r\n@ReubenBond I am not sure if the coordinator thing could be solved more elegantly using PubSub or streams. That's where you have a much better overview on Orleans. \r\n\r\nBest of luck with your implementation!"
      },
      {
        "user": "ghost",
        "created_at": "2021-11-17T05:01:08Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 7210,
    "title": "Transactions error",
    "created_at": "2021-08-24T03:40:59Z",
    "closed_at": "2021-08-25T00:38:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7210",
    "body": " No ITransactionalStateStorageFactory nor IGrainStorage with the name TransactionStore was found while attempting to create transactional state storage.\r\n\r\n\r\nATMGrain.cs\r\nAccountGrain.cs",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7210/comments",
    "author": "107295472",
    "comments": [
      {
        "user": "107295472",
        "created_at": "2021-08-24T03:44:53Z",
        "body": "System.InvalidOperationException: No ITransactionalStateStorageFactory nor IGrainStorage with the name TransactionStore was found while attempting to create transactional state storage."
      },
      {
        "user": "benjaminpetit",
        "created_at": "2021-08-24T07:53:25Z",
        "body": "You probably need to configure a storage provider with the name \"TransactionStore\""
      },
      {
        "user": "107295472",
        "created_at": "2021-08-24T08:16:08Z",
        "body": "> You probably need to configure a storage provider with the name \"TransactionStore\"\r\n\r\nAddRedisGrainStorage"
      },
      {
        "user": "107295472",
        "created_at": "2021-08-24T08:20:19Z",
        "body": "TransactionStore  Write it yourself"
      }
    ]
  },
  {
    "number": 7206,
    "title": "[Question] - Same silo deployment for associated grains",
    "created_at": "2021-08-20T15:24:10Z",
    "closed_at": "2021-08-25T15:12:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7206",
    "body": "I am implementing a game application using orleans. For every instance of the game, I have `GameGrain`, `PlayerGrain `and `WeaponsGrain`. `GameGrain ` is keyed using a GameGuid. `PlayerGrain `is keyed using GameGuid+PlayerGuid and `WeaponsGrain `is keyed using GameGuid. I could potentially have hundreds of instances of games running. I want to implement a placement strategy that enables for any game instance i.e. `GameGrain `the associated `PlayerGrain `and `WeaponsGrain `to be activated on same silo.\r\n\r\nHashbased placement strategy could achieve something like this but that doesn't guarantee same silo placement because silos could go offline in a cluster. \r\n\r\nWondering if guys have any suggestions?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7206/comments",
    "author": "sheeri185adidam",
    "comments": [
      {
        "user": "nkosi23",
        "created_at": "2021-08-20T17:10:37Z",
        "body": "The difficulty here is that you are interested in an implementation detail that you shouldn't be interested in as Orleans is supposed to take care of that for you. What you would need is being able to override the PlacementService.GetCompatibleSilos(PlacementTarget target) method to alter the definition of what is a compatible silo. Right now the only discriminant is whether or not your grains are versioned, and if the silo has the right version of the grain it is deemed compatible. But this class is marked internal as users are not expected to be interested in this level of implementation details.\r\n\r\nBut even if the class wasn't internal, while your id generation scheme allows you to have convenient access to the id of the game grain, the Placement runtime has no API allowing you to know which grains are currently activated in a Silo. You are not supposed to be interested in the content of individual silos, this is out of intended usage.\r\n\r\nOnce this is said, what you could do is segment your silos in subnetworks and create a variation of the HashBased placement strategy (since the placement runtime gives you access to the IP addresses of compatible silos). This would allow you to ensure that a particular game id is only serviced by a particular silo.\r\n\r\nHowever, once you have done that, keep in mind that you will have no way to load balance the silo under heavy load (which is one of the key benefits of using Orleans). And if you want to add this capability, you are back to square one as this is exactly the behavior of built-in placement strategies.\r\n\r\nI strongly feel that you do not actually want to do that. Just ensure that your silos are all based in the same data center and latency shouldn't ever be an issue. LANs are very fast these days. I have a sense that this may be an unnecessary optimization concern. The magic of Orleans is that it takes care of that and many other things extremely well."
      },
      {
        "user": "sheeri185adidam",
        "created_at": "2021-08-20T17:21:03Z",
        "body": "@nkosi23 The more I think about this now the more I agree with you. I am leaning towards _prefer_ to have this placement. I am thinking to write a custom placement director that does the following. It will to some extent place these grains on same silo but if not, not a big deal. \r\n\r\n```\r\npublic Task<SiloAddress> OnAddActivation(PlacementStrategy strategy, PlacementTarget target,\r\n            IPlacementContext context)\r\n{\r\n\tvar allSilos = context.GetCompatibleSilos(target).OrderBy(s => s).ToArray();\r\n\tvar key = GetTargetPrimaryKey(target);\r\n\tvar hash = key.GetHashCode() & 0x7fffffff;\r\n\r\n\tvar index = hash % allSilos.Length;\r\n\treturn Task.FromResult(allSilos[index]);\r\n}\r\n\r\nprivate static string GetTargetPrimaryKey(PlacementTarget target)\r\n{\r\n\tvar key = target.GrainIdentity.PrimaryKeyString;\r\n\tvar result = key;\r\n\tif (key.Contains(\"__\"))\r\n\t{\r\n\t\tresult = key[..key.IndexOf(\"__\", StringComparison.Ordinal)].Trim();\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n```"
      },
      {
        "user": "benjaminpetit",
        "created_at": "2021-08-24T08:09:59Z",
        "body": "I agree with @nkosi23 , you should not **force** placement on a specific silo. Generally, the default random one is the best to use long term.\r\n\r\nHowever, you could experiment with `PreferLocalPlacement`. If the `GameGrain` is the one that do the first call to `PlayerGrain` `WeaponsGrain`, then they will be placed on the same silo if possible."
      }
    ]
  },
  {
    "number": 7164,
    "title": "Question: Migrating stream providers",
    "created_at": "2021-07-21T14:20:24Z",
    "closed_at": "2021-09-02T20:17:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7164",
    "body": "Currently we use AWS SQS for persistent streams in our and we're going to be switching over Azure Event Hubs. We're trying to find a migration strategy that will allow us to do the following while live migrating.\r\n\r\n* Read remaining messages from SQS\r\n* Read new messages from Event Hubs\r\n* Write new messages to Event Hubs\r\n\r\nIdeally would like to find a solution that allows us to have multiple readers from different providers like this (not long-lived, just until the old queue is cleared out) without changing the stream provider name that is referenced in our grains. Below are the approaches we've come up with.\r\n\r\n1. Implement a custom stream provider that allows reading from one-or-more named stream providers and writes to one. This seems like the most complicated option and not really worth the effort.\r\n2. Implement a hosted service that operates outside of Orleans and directly pulls any remaining messages from SQS and pushes them to Event Hubs.\r\n3. Use some kind of interceptor/extension to proxy reads from both stream providers?\r\n\r\nAre there any tricks we could take advantage of to do this easily? If not, I'm thinking that the second one probably sounds like the most reasonable solution.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7164/comments",
    "author": "benthepoet",
    "comments": [
      {
        "user": "nkosi23",
        "created_at": "2021-07-25T12:54:25Z",
        "body": "I am by no mean an authority on Orleans, but since there has not been an authoritative answer since you posted your question just wanted to add my 2 cents in case it is helpful.\r\n\r\nIf I were you, I'd go with option 2 as well, it is the simplest and probably the most architecturally sound solution (the single responsibility of the migration is encapsulated in a clean independent component). It is also the most transparent and the less risky (you do not depend on the hazards of the Orleans runtime which could make certain subtle assumptions that may make your life more difficult)."
      },
      {
        "user": "ReubenBond",
        "created_at": "2021-09-02T20:17:23Z",
        "body": "I agree with @nkosi23 - and thank you for answering. I'll close this, since there has been no follow-up to @nkosi23's response. We can re-open and move to discussion if someone wants."
      }
    ]
  },
  {
    "number": 7139,
    "title": "Question: Migrating reminders from DynamoDB to Azure Table Storage",
    "created_at": "2021-06-30T16:18:27Z",
    "closed_at": "2021-07-16T14:22:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7139",
    "body": "I'm currently working on migrating our Orleans backend from AWS over to Azure with minimal downtime. \r\n\r\nFor grain storage we took the approach of implementing a custom provider that checks if the grain state is present in Azure Blob Storage and if not then it pulls it from DynamoDB and writes the state into Azure. This allows us to live migrate grain states over as they're activated.\r\n\r\nNow we're looking at how to migrate our reminders from DynamoDB to Azure Table Storage. Is there a similar strategy to how we're migrating grain storage available? Can we do this live or does it require taking all the silos down? We have less than 100 reminders in production, so it's a rather small set of data.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7139/comments",
    "author": "benthepoet",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2021-07-06T13:14:07Z",
        "body": "Hi @benthepoet, you could potentially write a custom reminders provider which adapted both providers and assisted with the migration.\r\n\r\nAre these reminders updated frequently? If not, then a custom one-shot tool to read from DynamoDB and write to Azure Table Storage might also work."
      },
      {
        "user": "benthepoet",
        "created_at": "2021-07-06T18:44:13Z",
        "body": "That's helpful. So theoretically in a custom `IReminderTable` implementation it sounds like doing the following in `ReadRows(uint beginHash, uint endHash)` would work:\r\n* Read rows from DynamoDB for range\r\n* If rows are found then move them to Azure Table\r\n* Return rows from Azure Table for range"
      }
    ]
  },
  {
    "number": 7100,
    "title": "How Orleans can be used in an IoT project?",
    "created_at": "2021-06-07T12:24:34Z",
    "closed_at": "2021-09-02T20:43:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7100",
    "body": "Hi.\r\n\r\nFirst of all **thanks for the Orleans framework**. I appreciate your efforts to make distributed application development a lot easier.\r\n\r\nOrleans seems to be an exact match for IoT business where we need device twins on backend.\r\n\r\nBut unfortunately I can not seem to find a suitable example rather than the old GPS Tracker example which is working with an HTTP Frontend.\r\n\r\nI was wondering if you could point me in the right direction and your thoughts on the following architectures that come to my mind.\r\n\r\nI will use RabbitMQ and its MQTT Plugin to support MQTT connections from the devices on the field. They will periodically publish sensor data to given topics.\r\n\r\n**1-** Each grain can create its own connection + channel and subscribe/publish to related queue on RabbitMQ. This does not seem to be a reasonable solution to me, because each device already makes connections if the device twins do that too we double the connection count which will lead to performance loss on RabbitMQ.\r\n\r\n**2-** Each silo will have 2 connections (one for publish and one for subscribe) but each grain will create their own channels using the shared connections. This solution is ok for connection count but increase in channel count creates a lot less but almost the same effect on RabbitMQ. And how should I share the connections (1 stateless worker, IHostedService, GrainService?) Pooling connections come to my mind but first need to be sure.\r\n\r\n**3-** I may create different processes for subscribing and publishing, each create their own connections and subscribe/publish to RabbitMQ. When a message arrived I can use GrainClient to send data to Orleans cluster. That seems totally fine to me, this way I can scale subscription process seperate from the silos. But I'm not sure how can I publish from grains to RabbitMQ which requires orleans to communicate with the publisher process. (gRPC etc? Orleans streams?)\r\n\r\n**4-** I may have the subscriber process mentioned above but rather than a seperate publisher process, each grain can create their connection + channel and publish the data when required. And close the connection + cannel. Or share one connection per silo but seperate channel opened/closed in each grain.\r\n\r\n**5-** Stream Providers? I have seen some documentation about pulling agents but I want to use RabbitMQ push based. I have seen Stream provider for RabbitMQ bu I think that does not solve the problem here. Am I wrong?\r\n\r\nTihs is might be too much to ask and time consuming to read. :(\r\n\r\nHope to see an answer from your side.\r\n\r\nThanks for your time.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7100/comments",
    "author": "staviloglu",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2021-09-02T20:43:28Z",
        "body": "Hi @staviloglu, \r\nOrleans is indeed a good match for IoT and has been put to use in many IoT applications, including in the backend of Azure IoT Digital Twins. We typically do not provide much input into overall application architecture - maybe we should, but it's time-intensive and ambiguous, being more suitable for discussion than Q&A. Regardless, please accept my apology for not responding sooner, as unfulfilling as this response may be.\r\n\r\nI would generally use an `IHostedService` (eg `BackgroundService) over a `GrainService`. Using gRPC between services is a fine approach. Orleans streams are fine, too, and give you some benefits such as increased decoupling over gRPC (given gRPC is point-to-point and temporally coupled). Interfacing with RabbitMQ directly gives you more control, so perhaps that's suitable if your scenario doesn't fit into the virtual streams / firehose approach that Orleans Streams takes.\r\n\r\nIf anyone has opinions here, please feel free to chime in. I'll convert this to a discussion, since I think it's more suited for that"
      }
    ]
  },
  {
    "number": 7073,
    "title": "[Question]: Difference between MemoryStreams and SimpleMessageStreamProvider",
    "created_at": "2021-05-08T13:43:04Z",
    "closed_at": "2021-09-03T14:38:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7073",
    "body": "Hi;\r\nWhat is the difference between SimpleMessageStreamProvider and MemoryStreams? \r\nThe guide document only mentions SMS and there is no explanation for MemoryStreams.\r\nWhere can I study the difference between them?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7073/comments",
    "author": "doctorcode-org",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2021-09-02T20:50:29Z",
        "body": "Hi @doctorcode-org, the difference is roughly this:\r\n\r\nSMS (Simple Message Stream Provider) uses direct grain messaging from the producers of a message to all consumers.\r\nMemoryStream uses an in-memory buffer to decouple producers and consumers.\r\n\r\nBoth should be considered *best efforts* as neither uses persistent storage to store messages.\r\nI hope that helps.\r\n\r\ncc @benjaminpetit are we missing documentation here?"
      },
      {
        "user": "doctorcode-org",
        "created_at": "2021-09-03T03:57:33Z",
        "body": "Hi @ReubenBond \r\nThank you so much. Your explanation was excellent and helped me a lot. "
      }
    ]
  },
  {
    "number": 7042,
    "title": "[Question]: Orleans Observables vs Streams",
    "created_at": "2021-03-30T17:25:47Z",
    "closed_at": "2021-09-03T14:08:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7042",
    "body": "Hi:\r\nWhich observers and streams work best for the following scenario:\r\nWe have several consumers that receive messages from external services. Each consumer then processes the received message and then updates a grain state. The grain then notifies the clients of these changes. Grains notification fires and forget. my question is to notify clients with make grain as an observable or to use streams?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7042/comments",
    "author": "doctorcode-org",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2021-09-02T22:52:51Z",
        "body": "I would default to observers for push-notification style updates like you're describing. I would also have those observers resubscribe to the grain periodically to give the grain a chance to resend any missed messages.\r\n\r\nIt also depends on how many clients are being notified and how many grains each one is observing. If the answer is \"many\" to those questions, then I would consider streams instead, likely backed by Azure Event Hubs. If in doubt, I would go with observers for their simplicity."
      },
      {
        "user": "doctorcode-org",
        "created_at": "2021-09-03T04:11:00Z",
        "body": "Hi @ReubenBond \r\nThank you for your answer. \r\nI tried both methods and using streams worked much better. Periodic subscribing of grains in the expected scenario did not work well because some grains had no message to process at all and the use of observers allowed these grains to remain active in memory without the need for them.\r\nI'm currently using Orleans to develop a trading system, and thank you to Orleans, and its developer community for this magical framework."
      },
      {
        "user": "ReubenBond",
        "created_at": "2021-09-03T14:08:15Z",
        "body": "Very glad to hear it, @doctorcode-org. I'll close this issue"
      }
    ]
  },
  {
    "number": 7002,
    "title": "Using roslyn analyzer creates generated classes that are not picked up by orleans codegen",
    "created_at": "2021-03-01T17:48:43Z",
    "closed_at": "2021-09-02T23:05:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7002",
    "body": "So I've been trying to explore Orleans by creating some building blocks similarly to how I've worked before which involved creating models using roslyn. \r\n\r\nI do get a message from orleans codegen:\r\n\r\n`3>Orleans.CodeGenerator - command-line = SourceToSource C:\\projects\\TradingHub\\TradingHub.Domain\\obj\\Debug\\net5.0\\TradingHub.Domain.orleans.g.args.txt\r\n3>EXEC : warning : attempted to get TypeSyntax for unknown (error) type, \"CustomerQueryModel\". Possible reason: None. Possible candidates:\r\n3>TradingHub.Domain -> C:\\projects\\TradingHub\\TradingHub.Domain\\bin\\Debug\\net5.0\\TradingHub.Domain.dll`\r\n\r\nbut it builds and runs and even grains that return the base type \"CustomerQueryModel\" work but if I use this in a List it throws an exception: \r\n\r\n`Exception thrown: 'System.TypeAccessException' in System.Private.CoreLib.dll\r\nMicrosoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware: Error: An unhandled exception has occurred while executing the request.\r\n\r\nSystem.TypeAccessException: Named type \"TradingHub.Domain.Customer.Queries.CustomerQueryModel\" is invalid: Type string \"TradingHub.Domain.Customer.Queries.CustomerQueryModel\" cannot be resolved.\r\n   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader[TReader](TReader this, SerializationManager serializationManager)\r\n   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadFullTypeHeader[TReader](TReader this, SerializationManager serializationManager, Type expected)\r\n   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadGenericArguments(IBinaryTokenStreamReader this, SerializationManager serializationManager, Int32 n)\r\n   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader[TReader](TReader this, SerializationManager serializationManager)\r\n   at Orleans.Serialization.SerializationManager.DeserializeInner[TContext,TReader](SerializationManager sm, Type expected, TContext context, TReader reader)\r\n   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected, IDeserializationContext context)\r\n   at Orleans.Serialization.BuiltInTypes.DeserializeOrleansResponse(Type expected, IDeserializationContext context)\r\n   at Orleans.Serialization.SerializationManager.DeserializeInner[TContext,TReader](SerializationManager sm, Type expected, TContext context, TReader reader)\r\n   at Orleans.Runtime.Messaging.MessageSerializer.OrleansSerializer`1.Deserialize(ReadOnlySequence`1 input, T& value)\r\n   at Orleans.Runtime.Messaging.MessageSerializer.TryRead(ReadOnlySequence`1& input, Message& message)\r\n   at Orleans.Runtime.Messaging.Connection.ProcessIncoming()\r\n   at Orleans.Internal.OrleansTaskExtentions.<ToTypedTask>g__ConvertAsync|4_0[T](Task`1 asyncTask)\r\n   at TradingHub.GraphQl.ValuesController.Get(Guid customerId) in C:\\projects\\TradingHub\\TradingHub\\ValuesController.cs:line 35\r\n   at lambda_method4(Closure , Object )\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ActionMethodExecutor.AwaitableObjectResultExecutor.Execute(IActionResultTypeMapper mapper, ObjectMethodExecutor executor, Object controller, Object[] arguments)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.<InvokeActionMethodAsync>g__Awaited|12_0(ControllerActionInvoker invoker, ValueTask`1 actionResultValueTask)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.<InvokeNextActionFilterAsync>g__Awaited|10_0(ControllerActionInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Rethrow(ActionExecutedContextSealed context)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Next(State& next, Scope& scope, Object& state, Boolean& isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.<InvokeInnerFilterAsync>g__Awaited|13_0(ControllerActionInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.<InvokeFilterPipelineAsync>g__Awaited|19_0(ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.<InvokeAsync>g__Awaited|17_0(ResourceInvoker invoker, Task task, IDisposable scope)\r\n   at Microsoft.AspNetCore.Routing.EndpointMiddleware.<Invoke>g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)\r\n   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware.Invoke(HttpContext context)`\r\n\r\nIs this something thats supported? I guess the exception is because despite some resolution the actual generated model isnt mapped in the orleans codegen? ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7002/comments",
    "author": "ajvwray",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2021-03-01T17:52:07Z",
        "body": "I'd say that's not supported. I don't know of any way to specify an order for Roslyn Analyzers (or Source Generators) to run in.\r\n\r\nIf there was a way to define such an order, then it could potentially be supported."
      },
      {
        "user": "ajvwray",
        "created_at": "2021-03-01T18:47:47Z",
        "body": "I can output files instead (from the source generator) but then as you've said the order isn't guaranteed and you'd need to build it twice (I actually tried this but it was a little too hacky). \r\n\r\nI'm not a 100% sure if that's why it doesn't get picked up as I guess the Orleans codegen looks for files in the project? or is lookups to referenced assemblies? Would another project acting as a façade for the Orleans codegen to force the order help? "
      },
      {
        "user": "ReubenBond",
        "created_at": "2021-03-01T19:10:27Z",
        "body": "Using a separate project may help, you can include an attribute such as `[assembly: KnownAssembly(typeof(MyGeneratedType)]` to tell Orleans to inspect your other assembly."
      },
      {
        "user": "ajvwray",
        "created_at": "2021-03-01T22:23:15Z",
        "body": "Should you be able to reference grain interfaces from another assembly that way? "
      },
      {
        "user": "ReubenBond",
        "created_at": "2021-09-02T23:05:47Z",
        "body": "Yes, if you are generating grain interfaces in another assembly, then the solution I provided above ought to work, since any given assembly must be built before any assembly which references it is built."
      }
    ]
  },
  {
    "number": 6857,
    "title": "problem when shutdown silo",
    "created_at": "2020-12-15T08:33:34Z",
    "closed_at": "2021-11-17T05:01:13Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6857",
    "body": "there are two silos, siloA and siloB. \r\ngrainA on siloA.\r\nthen shutdown siloA, sometimes grainA  OnActivate on siloB before OnDeactivate on siloA.\r\nI save data when OnDeactivateAsync, \r\nI read data when OnActivateAsync,\r\nso i lost data what happend on siloA, \r\nIs there any way to solve this issue?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6857/comments",
    "author": "lpyvvvvvv",
    "comments": [
      {
        "user": "Cloud33",
        "created_at": "2020-12-16T03:57:56Z",
        "body": "\r\n\r\nWhen you close silos, `OnDeactivateasync` cannot be guaranteed to trigger. This is a best effort behavior.\r\n\r\n\r\nYou may have to change the method, such as calling `WriteStateAsync` synchronously when the data changes\r\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2020-12-16T06:20:09Z",
        "body": "+1\r\nThe general rule is to persist any state that you don't want to lose as part of the operation that updates it."
      },
      {
        "user": "freever",
        "created_at": "2020-12-16T06:22:54Z",
        "body": "Is there a recommended way to persist state asynchronously, so that the grain can release its caller while persisting? Or is that just generally a bad idea?"
      },
      {
        "user": "lpyvvvvvv",
        "created_at": "2020-12-16T07:03:05Z",
        "body": "> Is there a recommended way to persist state asynchronously, so that the grain can release its caller while persisting? Or is that just generally a bad idea?\r\n\r\n+1"
      },
      {
        "user": "rallets",
        "created_at": "2020-12-16T10:44:53Z",
        "body": "@freever @lpyvvvvvv it depends on how \"important\" the grain state is. \r\n1) If it's not ok for your business to lose \"some\" state in case of a crash, then you need to persist the grain state as soon it's changed (basically before leaving the grain method), awaiting the WriteStateAsync call to the storage to be able to handle exceptions, as then they are not swallowed. \r\n2) Instead, if you can get the risk of loosing the grain state in case of errors (silo crash, network failures, storage provider errors, etc), you can use a timer and persist the state only every x seconds."
      },
      {
        "user": "sergeybykov",
        "created_at": "2020-12-17T07:15:05Z",
        "body": "Nicely stated, @rallets."
      },
      {
        "user": "ghost",
        "created_at": "2021-11-17T05:01:11Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 6646,
    "title": "Detected application deadlock on message",
    "created_at": "2020-07-12T23:56:46Z",
    "closed_at": "2020-09-26T23:45:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6646",
    "body": "prerequisite: PerformDeadlockDetection = true;\r\n\r\nI need some help, I use Azure Event Hub for Streams. Following situation, GrainA publishes a message and GrainB receive it, do any jobs and publish an update about his state. GrainA can not receive this update because get a Deadlock exception. \r\n\r\n\r\nIsn't that possible?\r\n\r\nThx for your help",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6646/comments",
    "author": "ebbservices",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2020-07-14T23:44:15Z",
        "body": "If you use an external queue, such as EventHub, for streaming, the grain that publishes an event succeeds with that when a stream event is written to the queue, but before it is actually delivered and processed by subscribers to that stream. Because of that, you shouldn't get any deadlocks in the scenario you described.\r\n\r\nSuch deadlocks are possible with the SMS stream provider that doesn't use any external queues and instead delivers events directly as grain calls between grains."
      },
      {
        "user": "ebbservices",
        "created_at": "2020-07-15T15:03:19Z",
        "body": "Thx for your answer. That was also what I was thinking about streams with EventHub. But then I got this logs. I will search perhaps there is a other problem. :(\r\n\r\n\r\n{\r\n  \"_index\": \"2020.07.13\",\r\n  \"_type\": \"_doc\",\r\n  \"_id\": \"94yFRXMBxwDa4XbtRq1o\",\r\n  \"_score\": 1,\r\n  \"_source\": {\r\n    \"@timestamp\": \"2020-07-13T00:13:47.3171111+00:00\",\r\n    \"level\": \"Warning\",\r\n    \"messageTemplate\": \"Detected application deadlock on message {Message} and activation {Activation}\",\r\n    \"message\": \"Detected application deadlock on message \\\"Request S10.244.0.181:11111:332295207*stg/7872883655142754957/d6c34a8d@Sd6c34a8d->S10.244.0.181:11111:332295207*grn/E4F58DB0/9ccbb316@6285d9a0 #260\\\" and activation \\\"[Activation: S10.244.0.181:11111:332295207*grn/E4F58DB0/9ccbb316@6285d9a0 #GrainType=Grains.MemberGrain Placement=RandomPlacement State=Valid]\\\"\",\r\n    \"exceptions\": [\r\n      {\r\n        \"Depth\": 0,\r\n        \"ClassName\": \"Orleans.Runtime.DeadlockException\",\r\n        \"Message\": \"Deadlock Exception for grain call chain [*grn/E4F58DB0/9ccbb316, *grn/8206F545/7e16f2b1, *grn/E4F58DB0/9ccbb316].\",\r\n        \"Source\": \"Orleans.Runtime\",\r\n        \"StackTraceString\": \"   at Orleans.Runtime.Dispatcher.CheckDeadlock(Message message)\\n   at Orleans.Runtime.Dispatcher.ReceiveRequest(Message message, ActivationData targetActivation)\\n--- End of stack trace from previous location where exception was thrown ---\\n   at Orleans.Internal.OrleansTaskExtentions.<ToTypedTask>g__ConvertAsync|4_0[T](Task`1 asyncTask)\\n   at Orleans.Streams.PersistentStreamPullingAgent.DeliverBatchToConsumer(StreamConsumerData consumerData, IBatchContainer batch)\\n   at Orleans.Internal.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function, Int32 callCounter, Int32 maxNumSuccessTries, Int32 maxNumErrorTries, TimeSpan maxExecutionTime, DateTime startExecutionTime, Func`3 retryValueFilter, Func`3 retryExceptionFilter, IBackoffProvider onSuccessBackOff, IBackoffProvider onErrorBackOff)\",\r\n        \"RemoteStackTraceString\": null,\r\n        \"RemoteStackIndex\": 0,\r\n        \"HResult\": -2146233088,\r\n        \"HelpURL\": null\r\n      }\r\n    ],\r\n    \"fields\": {\r\n      \"Message\": \"Request S10.244.0.181:11111:332295207*stg/7872883655142754957/d6c34a8d@Sd6c34a8d->S10.244.0.181:11111:332295207*grn/E4F58DB0/9ccbb316@6285d9a0 #260\",\r\n      \"Activation\": \"[Activation: S10.244.0.181:11111:332295207*grn/E4F58DB0/9ccbb316@6285d9a0 #GrainType=Grains.MemberGrain Placement=RandomPlacement State=Valid]\",\r\n      \"EventId\": {\r\n        \"Id\": 101528,\r\n        \"Name\": \"Orleans.Messaging.Dispatcher.DetectedDeadlock\"\r\n      },\r\n      \"SourceContext\": \"Orleans.Messaging\"\r\n    }\r\n  },\r\n  \"fields\": {\r\n    \"@timestamp\": [\r\n      \"2020-07-13T00:13:47.317Z\"\r\n    ]\r\n  }\r\n}"
      },
      {
        "user": "sergeybykov",
        "created_at": "2020-07-17T00:17:19Z",
        "body": "What happens if you don't set `PerformDeadlockDetection` to `true`? I wonder if this is a false positive as deadlock detection is turned off by default."
      },
      {
        "user": "ebbservices",
        "created_at": "2020-07-17T00:24:49Z",
        "body": "If PerformDeadlockDetection is false then is working fine. Thx for your support. "
      },
      {
        "user": "Rohansi",
        "created_at": "2021-03-29T23:51:29Z",
        "body": "@sergeybykov I just ran into this as well. Are there any plans to correct this false positive? I'm using Orleans 3.4.1."
      },
      {
        "user": "sergeybykov",
        "created_at": "2021-03-30T05:46:36Z",
        "body": "@ReubenBond @benjaminpetit "
      },
      {
        "user": "ReubenBond",
        "created_at": "2021-03-31T00:53:48Z",
        "body": "@Rohansi is this an issue specific to Azure Queues? It may be worth opening a new issue referencing this. It's difficult for us to track closed issues."
      },
      {
        "user": "Rohansi",
        "created_at": "2021-03-31T01:03:55Z",
        "body": "Thanks @ReubenBond, I created a new issue"
      }
    ]
  },
  {
    "number": 6634,
    "title": "Is it possible to get cancellation token source for an already running grain?",
    "created_at": "2020-07-05T10:08:10Z",
    "closed_at": "2020-07-06T21:33:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6634",
    "body": "Hello.\r\nFor example I have a grain like: \r\n``` \r\npublic class GrainA : Grain, IGrainA\r\n{\r\n        public async Task LongWork(string message, GrainCancellationToken tc)\r\n        {\r\n            while(!tc.CancellationToken.IsCancellationRequested)\r\n            {\r\n                 Console.WriteLine(message);\r\n                 await Task.Delay(1000);\r\n            }\r\n        }\r\n|\r\n```\r\nThe grain is initialized from a client code.\r\n```\r\n var grain = client.GetGrain<IGrainA>(\"GrainA1\");\r\n var tcs = new GrainCancellationTokenSource();\r\n await grain.LongWork(\"Hello!\", tcs.CancellationToken);\r\n```\r\nIf Client is down or a load balancer redirected call to an another client, then the cancellationTokenSource is lost. Is it possible to cancel running task on the GrainA? Can I get a copy of the CancellationTokenSource by Grain name from the orleans infrastructure ?\r\nFor example some sort of:\r\n```\r\n var cts = client.GetCancellation<IGrainA>(\r\n\"GrainA1\", //GrainId\r\nnameof(IGrainA.LongWork)//Method name\r\n)\r\n await tcs.Cancel();\r\n```",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6634/comments",
    "author": "KirillJK",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2020-07-05T21:25:09Z",
        "body": "There's no built-in support for sharing cancellation tokens. While something like that could be added, I'm of the opinion that cancellation tokens are an anti-pattern here, and we made a mistake of adding `GrainCancellationToken`.\r\n\r\nI think the right pattern is to add an explicit `Cancel` method to the grain interface and make the grain reentrant, so that it can process a cancellation call while awaiting another async operation."
      },
      {
        "user": "KirillJK",
        "created_at": "2020-07-06T10:17:15Z",
        "body": "Ok. Thanks. My two cents. I understand the idea of single threaded grain. But unfortunatelly it means there is no way to stop a running flow of synchronious operations if the calling context is lost. It's an antipattern due to the asynchronius concept and internal implementaion of the framework.  Wouldn't be better to keep one place with 1 bit concurrency in order to have possibility to stop synchronious process? I believe anyway people may overcome this limitation by trying to come up with a workaround that includes a critical section or db-sync"
      },
      {
        "user": "sergeybykov",
        "created_at": "2020-07-06T19:52:29Z",
        "body": "I think it is important to stress a distinction here between a logically sequential operation/method and synchronous execution of code on a thread. I our experience, the vast majority of logically sequential operations take very little synchronous execution on a thread, and spend most of the time waiting for asynchronous dependency calls (IO and other services) with nothing to execute locally while waiting.\r\n\r\nNon-reentrant (default) grains don't allow any other requests in while in that idle waiting state. That's why the `GrainCancellationToken` feature helps but in a clumsy way because the grain code needs to be running and periodically checking the token for it to work.\r\n\r\nA reentrant grain though allows a cancellation call (or any other call for that matter) in while it is idle waiting for a dependency operation to complete. Unlike with `GrainCancellationToken`, it doesn't have to be cancellation and can also be a status or progress check call, for example. This will not work if the grain is busy executing a major computation synchronously on the thread. But like I said, the heavy compute cases are rather rare.\r\n\r\nReentrancy/interleaving requires a more careful handling of grain's state compared to the default non-reentrant case. That's the tradeoff one has to make of simplicity vs. power."
      }
    ]
  },
  {
    "number": 6532,
    "title": "Use case scenario",
    "created_at": "2020-05-14T12:26:28Z",
    "closed_at": "2020-09-26T23:49:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6532",
    "body": "I have no experience using an Actor based system. There's a pilot project coming up that involves just connecting to two different SOAP APIs (one payment system and another billing aggregator) and store the results in the DB. It looks simple enough.\r\n\r\nThe goal of the project though is to be able to eventually process 300 million transactions a year.\r\n\r\nNow is this the kind of problem that Orleans designed for? It looks like it but I have no experience style of programming so I can't tell for sure. This is obviously can be done by a straightforward ASP.NET Core app but I wonder if Orleans will make the issue of upgrading, deployment and resiliency easier.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6532/comments",
    "author": "dodyg",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2020-06-02T01:08:21Z",
        "body": "I think the first question to answer here is if the project would benefit from being a stateful app, that is one that keeps state in memory and tries to executes a series of requests against that in-memory state instead of going to storage to load the state upon every request. If the answer is yes, then the next step is typically to decide how that state would be partitioned, so that:\r\n\r\n1) requests would be able to execute in parallel without a central lock or other expensive synchronization point;\r\n2) execution of the requests could be distributed across a cluster of servers.\r\n\r\nThe typical state models that partition naturally are per-user/per-device/per-session states that are easy to encapsulate in respective grain classes in Orleans.\r\n\r\nI hope this provides an initial idea for your question. Sorry about delayed response."
      },
      {
        "user": "dodyg",
        "created_at": "2020-06-03T07:54:17Z",
        "body": "Thank you for your response. \r\n\r\nI think for this use case we would have to go back to the database every time. There isn't any temporary actions such as filling up cart or building flight itinerary. Every payment is either successful or not. "
      },
      {
        "user": "sergeybykov",
        "created_at": "2020-06-03T21:16:29Z",
        "body": "Even in that case you might benefit from serializing database operations for each entity (by routing them through respective grains) to prevent attempts of concurrent updates. I guess it depends how big of a problem that it in your case. May or may not be worth it."
      }
    ]
  },
  {
    "number": 6377,
    "title": "Slow access to Azure Table Reminders for ReadTableEntriesAndEtags",
    "created_at": "2020-03-02T16:37:47Z",
    "closed_at": "2020-03-09T12:43:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6377",
    "body": "I've recently started getting the following error:\r\n\r\n```\r\nwarn: Orleans.Reminders.AzureStorage.AzureTableDataManager[100815]\r\n      Slow access to Azure Table Reminders for ReadTableEntriesAndEtags, which took 00:00:03.1855454\r\n```\r\n\r\nMy Orleans Cluster is running 3 silo instances that are idle - there are no activations as nobody uses the system. It has its own dedicated Azure Storage Account for discovery, reminders et al.\r\n\r\nIs there something going terribly bad and will the system crash when actual traffic builds up?\r\n\r\nShould I provision more storage accounts?\r\n\r\nOrleans 2.4.x\r\n\r\ncc @ReubenBond ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6377/comments",
    "author": "turowicz",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2020-03-05T22:37:06Z",
        "body": "How many reminders (order of magnitude) do you have in that cluster? Is it running in Azure, same region as the storage account? How frequently do you see this?\r\n\r\nIn general, this should be benign, just an extra diagnostic to help people troubleshoot their services."
      },
      {
        "user": "turowicz",
        "created_at": "2020-03-06T11:15:37Z",
        "body": "While we don't register any reminders, we do make use of the (now legacy) Grain Observer pattern. Not many observations though, as nobody is using the service. Somewhere between 1 and 10."
      },
      {
        "user": "turowicz",
        "created_at": "2020-03-06T11:15:53Z",
        "body": "Yes it is all in the same region - West Europe."
      },
      {
        "user": "turowicz",
        "created_at": "2020-03-06T11:16:30Z",
        "body": "The cluster is Azure Kubernetes Service based on the Virtual Machine Scale Set."
      },
      {
        "user": "sergeybykov",
        "created_at": "2020-03-06T16:45:12Z",
        "body": "If you aren't using reminders, then this is 100% benign. I wonder if it's caused by such a low usage of the reminders table that a first call to it in a long while is slow (warm up of the table store frontends or something like that). I'm purely speculating here.\r\n\r\nObservers are completely unrelated."
      },
      {
        "user": "turowicz",
        "created_at": "2020-03-09T12:43:14Z",
        "body": "OK thanks"
      }
    ]
  },
  {
    "number": 6368,
    "title": "Explanation regarding IAsyncStream<T>.GetAllSubscriptionHandles()",
    "created_at": "2020-02-28T13:47:26Z",
    "closed_at": "2020-03-09T11:39:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6368",
    "body": "Hi,\r\n\r\nI am working on the subscription logic in our app to ensure that I resubscribe to a stream instead of creating a new handle each time (whenever possible).\r\nWhat I expected from the `IAsyncStream<T>.GetAllSubscriptionHandles()` function is to return the handles for a given grain type + primary key. Since we're only subscribing once to each stream in our grains, I assumed that I should only have one handle in the list (if a previous subscription already existed obviously) and that I could reuse it to resubscribe.\r\n\r\nBut after a few tests, I realized that different activations of a grain were retrieving the handles from other activations too.\r\n\r\nSo I decided to test this pattern in a sample project, and I couldn't reproduce it. In the end, when I created two activations of a grain, `IAsyncStream<T>.GetAllSubscriptionHandles()` only retrieved the handles for each specific activation (which is the pattern I expected). So I gave a look at the JSON payload and I noticed a few differences between my main and my test projects.\r\n\r\nHere is the JSON of my test project :\r\n```json\r\n{\r\n  \"$id\": \"1\",\r\n  \"$type\": \"Orleans.Streams.PubSubGrainState, Orleans.Runtime\",\r\n  \"Producers\": {\r\n    \"$type\": \"System.Collections.Generic.HashSet`1[[Orleans.Streams.PubSubPublisherState, Orleans.Core]], System.Collections\",\r\n    \"$values\": []\r\n  },\r\n  \"Consumers\": {\r\n    \"$type\": \"System.Collections.Generic.HashSet`1[[Orleans.Streams.PubSubSubscriptionState, Orleans.Core]], System.Collections\",\r\n    \"$values\": [\r\n      {\r\n        \"$id\": \"2\",\r\n        \"$type\": \"Orleans.Streams.PubSubSubscriptionState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$id\": \"3\",\r\n          \"$type\": \"Orleans.Streams.StreamId, Orleans.Core\",\r\n          \"Guid\": \"79dd573a-efc3-4e3a-9957-3f0b7452d51a\",\r\n          \"ProviderName\": \"SMS\",\r\n          \"Namespace\": \"test\"\r\n        },\r\n        \"SubscriptionId\": {\r\n          \"$id\": \"4\",\r\n          \"$type\": \"Orleans.Runtime.GuidId, Orleans.Core.Abstractions\",\r\n          \"Guid\": \"f0b37117-16db-4cf1-9cf6-3373740aaf22\"\r\n        },\r\n        \"consumerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamConsumerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"0000000000000000000000000000000103ffffffc024bd45\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      },\r\n      {\r\n        \"$id\": \"5\",\r\n        \"$type\": \"Orleans.Streams.PubSubSubscriptionState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$ref\": \"3\"\r\n        },\r\n        \"SubscriptionId\": {\r\n          \"$id\": \"6\",\r\n          \"$type\": \"Orleans.Runtime.GuidId, Orleans.Core.Abstractions\",\r\n          \"Guid\": \"99a2600d-c107-4485-a05f-1fcd51e15c7c\"\r\n        },\r\n        \"consumerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamConsumerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"0000000000000000000000000000000203ffffffc024bd45\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nEach subscription has a different `GrainId`, one for the activation with `1` as the primary key, and `2` for the other.\r\n\r\nHere is the one from my main project :\r\n```json\r\n{\r\n  \"$id\": \"1\",\r\n  \"$type\": \"Orleans.Streams.PubSubGrainState, Orleans.Runtime\",\r\n  \"Producers\": {\r\n    \"$type\": \"System.Collections.Generic.HashSet`1[[Orleans.Streams.PubSubPublisherState, Orleans.Core]], System.Collections\",\r\n    \"$values\": [\r\n      {\r\n        \"$id\": \"2\",\r\n        \"$type\": \"Orleans.Streams.PubSubPublisherState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$id\": \"3\",\r\n          \"$type\": \"Orleans.Streams.StreamId, Orleans.Core\",\r\n          \"Guid\": \"6395d740-6e55-11e8-b566-0800200c9a66\",\r\n          \"ProviderName\": \"SMS\",\r\n          \"Namespace\": \"M7.Heartbeat\"\r\n        },\r\n        \"producerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamProducerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"450a8ec3eeba4965f566fb006ede70950400000000000000\",\r\n          \"ObserverId\": \"23706d43-baaf-4a48-8301-4d6a767e0a82\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      }\r\n    ]\r\n  },\r\n  \"Consumers\": {\r\n    \"$type\": \"System.Collections.Generic.HashSet`1[[Orleans.Streams.PubSubSubscriptionState, Orleans.Core]], System.Collections\",\r\n    \"$values\": [\r\n      {\r\n        \"$id\": \"4\",\r\n        \"$type\": \"Orleans.Streams.PubSubSubscriptionState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$ref\": \"3\"\r\n        },\r\n        \"SubscriptionId\": {\r\n          \"$id\": \"5\",\r\n          \"$type\": \"Orleans.Runtime.GuidId, Orleans.Core.Abstractions\",\r\n          \"Guid\": \"75abe7f9-390f-4ce1-a26a-67d1cc028c2b\"\r\n        },\r\n        \"consumerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamConsumerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"450a8ec3eeba4965f566fb006ede70950400000000000000\",\r\n          \"ObserverId\": \"583016d5-3639-43e5-885b-5aa6b32c9df7\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      },\r\n      {\r\n        \"$id\": \"6\",\r\n        \"$type\": \"Orleans.Streams.PubSubSubscriptionState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$ref\": \"3\"\r\n        },\r\n        \"SubscriptionId\": {\r\n          \"$id\": \"7\",\r\n          \"$type\": \"Orleans.Runtime.GuidId, Orleans.Core.Abstractions\",\r\n          \"Guid\": \"a2338aff-2ef7-4acd-bef9-ee37c6488718\"\r\n        },\r\n        \"consumerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamConsumerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"450a8ec3eeba4965f566fb006ede70950400000000000000\",\r\n          \"ObserverId\": \"583016d5-3639-43e5-885b-5aa6b32c9df7\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      },\r\n      {\r\n        \"$id\": \"8\",\r\n        \"$type\": \"Orleans.Streams.PubSubSubscriptionState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$ref\": \"3\"\r\n        },\r\n        \"SubscriptionId\": {\r\n          \"$id\": \"9\",\r\n          \"$type\": \"Orleans.Runtime.GuidId, Orleans.Core.Abstractions\",\r\n          \"Guid\": \"a25178cd-61ec-4fa1-bd31-2803033b3142\"\r\n        },\r\n        \"consumerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamConsumerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"450a8ec3eeba4965f566fb006ede70950400000000000000\",\r\n          \"ObserverId\": \"583016d5-3639-43e5-885b-5aa6b32c9df7\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      },\r\n      {\r\n        \"$id\": \"10\",\r\n        \"$type\": \"Orleans.Streams.PubSubSubscriptionState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$ref\": \"3\"\r\n        },\r\n        \"SubscriptionId\": {\r\n          \"$id\": \"11\",\r\n          \"$type\": \"Orleans.Runtime.GuidId, Orleans.Core.Abstractions\",\r\n          \"Guid\": \"3aad6d49-6792-4bd2-b6a2-3c7320afa268\"\r\n        },\r\n        \"consumerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamConsumerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"450a8ec3eeba4965f566fb006ede70950400000000000000\",\r\n          \"ObserverId\": \"583016d5-3639-43e5-885b-5aa6b32c9df7\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      },\r\n      {\r\n        \"$id\": \"12\",\r\n        \"$type\": \"Orleans.Streams.PubSubSubscriptionState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$ref\": \"3\"\r\n        },\r\n        \"SubscriptionId\": {\r\n          \"$id\": \"13\",\r\n          \"$type\": \"Orleans.Runtime.GuidId, Orleans.Core.Abstractions\",\r\n          \"Guid\": \"35820dd5-adb6-4ce2-bf01-c7af0ff90a43\"\r\n        },\r\n        \"consumerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamConsumerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"450a8ec3eeba4965f566fb006ede70950400000000000000\",\r\n          \"ObserverId\": \"583016d5-3639-43e5-885b-5aa6b32c9df7\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      },\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nI have a few more activations subscribing to the same topic, but here is the thing : Every subscription has the same `GrainId` + an `ObserverId` which is also the same every time. I guess then this is why the `IAsyncStream<T>.GetAllSubscriptionHandles()` function returns all the handles everytime, but the thing is that these subscriptions are made in different activations and even in different grains.\r\nThis main project has a bit of a different pattern than my test one, especially regarding which class actually do the subscription, etc. But even when trying to reapply this pattern, I am not able to have that `ObserverId` in the JSON.\r\n\r\nEDIT : There is one thing that I forgot to mention and which seems to make a difference : The streams for which GrainId is always the same + there is an observer id, are streams that were created (and for which producers) are within a nugget package that is referenced in our main project. I don't see why this would make things behave differently, but I have been able to reproduce the pattern by subscribing with a simple client to streams in that nugget, whereas all the other streams in my app do have a different GrainId + no observerId.\r\n\r\nSo my questions are :\r\n- First of all, do I misinterpret how  `IAsyncStream<T>.GetAllSubscriptionHandles()`  should be working ?\r\n- What is the signification of that `ObserverId` inside the JSON payload ?\r\n- What could make different grains, and different activations have the same ids inside that JSON ?\r\n\r\nThank you in advance for your help.\r\n\r\nRegards,\r\nNicolas",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6368/comments",
    "author": "DiAifU",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2020-03-05T22:51:06Z",
        "body": "I'm a bit confused by the terminology here. When you say \"a grain activation\" I *think* you actually mean \"a grain\" as a grain with a unique key withing the grain class. Is this correct? We use the term \"grain activation\" for a different purpose, to mean \"instantiation of a grain at a certain point in time.\"\r\n\r\nThe scope of stream subscription is indeed the grain. So, when a grain calls `GetAllSubscriptionHandles()`, it receives only the its own subscriptions. There's also a way to subscribe on behalf of a grain, but I'll leave it out for now for simplicity.\r\n\r\n`ObserverId` is for client observers. Do you have clients producing events to or consuming them from the streams?"
      },
      {
        "user": "DiAifU",
        "created_at": "2020-03-06T00:24:42Z",
        "body": "Hi,\r\nSorry about the confusion, I am indeed talking about a grain with a unique key when I was using « grain activation ».\r\nSo in this case, let’s say I have a grain A (class name), with a primary key 1, producing on a stream with guid a-a-a-a, and grains B with different primary keys (1 to 10 for example), consuming that  a-a-a-a stream, should each B grain get 1 handle if they subscribe once, or get all the handles ?\r\n \r\nBecause depending on whether I run my test project or my main project, I seem to have different results.\r\n\r\nRegarding `ObserverId`, these specific streams have only grains producing and consuming them within the silo. No client is subscribed to these streams"
      },
      {
        "user": "sergeybykov",
        "created_at": "2020-03-06T00:31:19Z",
        "body": ">should each B grain get 1 handle if they subscribe once, or get all the handles ?\r\n\r\nEach grain would get only its own handle. Unless it subscribes more than once to the same stream, which is also supported."
      },
      {
        "user": "DiAifU",
        "created_at": "2020-03-06T00:39:33Z",
        "body": "And my problem is here. As you can see in the second json within my first post, each consumer seems to be from the same grain, but it is not. It's actually from different grains, and whenever I call `GetAllSubscriptionHandles()` from one of these grains, I also get the handles from the others."
      },
      {
        "user": "sergeybykov",
        "created_at": "2020-03-06T03:43:33Z",
        "body": "I'm not sure I understand. All consumers seem to have the same GrainId - `450a8ec3eeba4965f566fb006ede70950400000000000000`."
      },
      {
        "user": "DiAifU",
        "created_at": "2020-03-06T07:38:13Z",
        "body": "This is what I see too, but to build this JSON, I actually subscribed from different grains"
      },
      {
        "user": "sergeybykov",
        "created_at": "2020-03-06T19:17:06Z",
        "body": "Could this JSON be from a different case? Unless I'm missing something, it shows 5 subscriptions from the same grain - `450a8ec3eeba4965f566fb006ede70950400000000000000`. `ObserverId` confuses me. This looks as if these are for client subscriptions.\r\n\r\n/cc @jason-bragg in case he has a different insight."
      },
      {
        "user": "jason-bragg",
        "created_at": "2020-03-06T22:53:04Z",
        "body": "Is it possible that the test code is running the subscription logic outside of the grain's context?  I ask because that used to cause an error, but we added support for grain calls to be called from outside grains, which may also allow subscription creation from outside the context.  If this was done then all of the subscriptions from outside the grain context would all look like they are from the same grain.\r\n\r\nSubscribing to a stream from outside a grain context (unless through the client) is not supported, but it may be doing the wrong thing instead of failing, due to the change.  Please check storage and see what the pubsub state is for that stream.  If the grain ID in the pubsub is not the same as it should be it may be the ID of the system target that handles the grain calls made when outside the grain context instead of the grain the subscribe logic lives in."
      },
      {
        "user": "DiAifU",
        "created_at": "2020-03-09T11:39:40Z",
        "body": "That was exactly it, I made sure to stay in the orleans context for the grains calls, but not the subscriptions. It definitly fixed my problem, thank you for your help !"
      }
    ]
  },
  {
    "number": 6235,
    "title": "Question : Correct Placement attribute to use to have singelton instance of Grain per node (locally)",
    "created_at": "2020-01-14T19:28:08Z",
    "closed_at": "2021-11-17T05:01:19Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6235",
    "body": "#### Requirement \r\n\r\n- Single instance of grain available locally on every node. \r\n- Single instance of grain for given *key* locally. Let's say if there are 4 tenants then there should be 4 different instances of this grain and each of them addressable using the GUID\\string key of te tenant.\r\n- This grain has a Timer to do some work.\r\n- Also, registers itself as a Subscriber (IGrainObserver) for changes from other grain.\r\n\r\n**Can you suggest if there is already a placement strategy that I can use as-is for above requirement?**\r\n\r\n#### What I have tried so far?\r\n\r\nAfter searching through documentation and code for the correct placement strategy for above grain, I thought StatelessWorker(1) or PreferLocalPlacement would work for my case. Later  I realized PreferLocalPlacement  might not *always* have a local instance of grain on every node.  \r\n\r\n#### Issue with StatelessWorker\r\nI can see that StatelessWorker(1) creates one local instance of the grain. When I used made grain as StatelessWroker, it ran into LongRunning task issue. \r\n\r\n````cs\r\n\r\nfail: Orleans.Threading.ThreadPoolExecutor[101212]\r\nWork item WorkItem=WorkItemGroup:Name=[Activation: S127.0.0.1:11111:316653458*grn/BDB9242C/0edd30a9@f162738e \r\n\r\n#GrainType=Common.Telemetry.Tracing.Tracer Placement=StatelessWorkerPlacement],WorkGroupStatus=Running Executing for 00:00:24.0630592 WorkItemGroup Details: WorkItemGroup:Name=[Activation: S127.0.0.1:11111:316653458*grn/BDB9242C/0edd30a9@f162738e \r\n\r\n#GrainType=Common.Telemetry.Tracing.Tracer Placement=StatelessWorkerPlacement],WorkGroupStatus=Running. Currently QueuedWorkItems=2; Total EnQueued=12; Total processed=9; Quantum expirations=0;  Executing Task Id=20876 Status=Running for 00:00:24.0641348.TaskRunner=ActivationTaskScheduler-22:Queued=2; Detailed SchedulingContext=<[Activation: S127.0.0.1:11111:316653458*grn/BDB9242C/4fca1ce75f7666f8b45cbded0edd30a903ffffffbdb9242c-0xC296A8A1@f162738e \r\n\r\n_#GrainType=Common.Telemetry.Tracing.Tracer Placement=StatelessWorkerPlacement State=Valid NonReentrancyQueueSize=0 EnqueuedOnDispatcher=0 InFlightCount=0 NumRunning=0 IdlenessTimeSpan=00:00:24.0651795 CollectionAgeLimit=02:00:00]> has been executing for long time._\r\n````",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6235/comments",
    "author": "manums",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2020-01-14T19:40:32Z",
        "body": "I think this question is more about long-running tasks than about placement.\r\n\r\nWhat are you doing inside that grain, blocking a thread, taking an indefinite time to process a message?"
      },
      {
        "user": "manums",
        "created_at": "2020-01-14T23:33:58Z",
        "body": "There is an open question on placement too - What would be the *correct* placement for this grain? Should I write a custom placement strategy for the requirement explained in my question?\r\n\r\nAbout this grain: it is a tracer grain. There are two timer jobs. One that periodically publishes traces out to different providers and other that periodically polls for new provider registrations.\r\n\r\nAfter reading example for statelessworker, it does not look like StatelessWorker is right in this case. **Please correct me if I'm wrong.**"
      },
      {
        "user": "ReubenBond",
        "created_at": "2020-01-14T23:41:14Z",
        "body": "StatelessWorker may be the right kind for this grain, but I'm not convinced that a grain is the right fit here - you want one copy per silo, which doesn't fit the programming model of a grain well.\r\n\r\nInstead, you could consider just using a background task which you launch from either an `IHostedService` (from `Microsoft.Extensions.Hosting.Abstractions`) or an `IStartupTask` (from Orleans). They can subscribe to a grain for updates on a timer.\r\n\r\nRegardless, never block threads"
      },
      {
        "user": "manums",
        "created_at": "2020-01-15T04:08:55Z",
        "body": "Thanks for your suggestion. I agree *tracer grain* kind of aligns to the idea of a background worker. There needs to be many such backgroundworkers - one per each tenant that is running inside that silo. Each silo can have more than one tracer grain/one per each tenant. Probably I can have a named singleton instance per tenant and use factory around.\r\n\r\nI was considering these pros of making it as grain - It will provide ability to address through tenant id as primary key, support for observing other grain & notifying other grains. Also, with StatelessWorker I can scale if required to more than 1 tracer instance per tenant. \r\n\r\nI don't think threads are getting blocked in current scenario. Each timer task finishes quickly by just pushing down messages to different providers.\r\n\r\nTimer tasks are still on the same single thread of grain right? "
      },
      {
        "user": "ghost",
        "created_at": "2021-11-17T05:01:18Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 6206,
    "title": "Access DI service in Unit Test",
    "created_at": "2019-12-31T20:18:56Z",
    "closed_at": "2020-01-14T15:26:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6206",
    "body": "I'm using the ClusterFixture way of testing Orleans grains and trying to verify if a call to one of the methods inside a dependency injected service actually happened inside of a grain call. \r\n\r\nI'm correctly configuring the service using `ConfigureServices` of the test ClusterFixture. \r\nBut I still cannot access the injected service inside my unit test. \r\n\r\nCouple of ways I've tried are: \r\n`this._cluster.Cluster.ServiceProvider.GetServiceByName<MyServiceName>(nameof(MyServiceName))`\r\n`this._cluster.Cluster.Service.GetService<IMyServiceName>()` but none of them have worked. \r\n\r\nIs there any good way to do this? \r\nI'm basically looking to ensure that a call to `IMyServiceName.Test()` happened.\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6206/comments",
    "author": "pawanrao",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2020-01-01T02:05:24Z",
        "body": "You're injecting a service into a grain and you want to check that the grain is calling it?\r\nYou will need to get a handle on the `IServiceProvider` on the silo. You can either do that with a test grain which accesses that service, or you can get access to the silo from the cluster directly.\r\n\r\nSomething like this:\r\n\r\n``` C#\r\n((InProcessSiloHandle)_cluster.Primary).SiloHost.Services.GetService<IMyService>()\r\n```"
      },
      {
        "user": "lfzm",
        "created_at": "2020-01-04T03:40:21Z",
        "body": "@ReubenBond  How can I solve the problem of duplicate ports in batch unit tests?"
      },
      {
        "user": "ReubenBond",
        "created_at": "2020-01-14T15:26:09Z",
        "body": "@lfzm I am not sure. Limiting concurrency is one way. I think ultimately we should either move to an in-memory transport for TestCluster or add some kind of coordination between instances. If that's something you're interested in, please open a new issue on it.\r\n\r\nI'm closing this one for now, since I think the original issue is resolved."
      }
    ]
  },
  {
    "number": 6180,
    "title": "[Question] Best way to get data by \"friend list\"",
    "created_at": "2019-12-13T12:53:35Z",
    "closed_at": "2020-03-24T03:21:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6180",
    "body": "Hi!\r\n\r\nI have long been worried about the question: how do Orleans developers propose to receive the following kind of information from Silo.\r\n\r\nSuppose we have a `UserGrain` that stores a list of \"friends\" (or other entities). In what way should I get data about \"friends\" of the user? Suppose I need username, level an few more fields.\r\n\r\nThe naive way is that I simply call the corresponding UserGrains in the cycle:\r\n\r\n```\r\npublic Task<FriendInfo[]> GetFriends()\r\n{\r\n    var friendInfoCollection = new List<FriendInfo>();\r\n\r\n    foreach(var friendId in State.FriendIds)\r\n    {\r\n        var friendInfo = await GrainFactory.GetGrain<UserGrain>().GetFriendInfo();\r\n\r\n        friendInfoCollection.Add(friendInfo);\r\n    }\r\n\r\n    return friendInfoCollection;\r\n}\r\n```\r\n\r\nSuppose the user has 500 friends.\r\n\r\nIn this case I'll awake 500 `UserGrain`s, which will result in 500 read operations on the DB (reading state of each grain), although outside the MS Orleans paradigm it might be a single read operation (just some kind of \"select * from Users where UserId in (...)\").\r\n\r\nDo Orleans developers see this as a problem? Are there any best practices for such cases?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6180/comments",
    "author": "vyshkant",
    "comments": [
      {
        "user": "vyshkant",
        "created_at": "2019-12-14T19:54:46Z",
        "body": "Perhaps the solution could be the `IGrainFactory` method, such as\r\n```\r\nTGrainInterface[] GetGrains <TGrainInterface> (long primaryKey, string keyExtension);\r\n```\r\n?\r\n\r\nAnd when we call this method, the grains will going to be activated in some special way, which involves just one DB read operation?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-12-18T23:56:27Z",
        "body": "Orleans doesn't provide a built-in way to do what you described. It wouldn't be easy to activate a number of grains with a single DB read because these grains would get activated on different  silos and asynchronously.\r\n\r\nThe typical approach is to cache state of friends within the user grain state. That does allow to load it with a single read. However, the challenge now is how to update that cached state consistently with changes to friends states. Depending on the application requirements, it might be okay to return stale cached data for a period of time."
      },
      {
        "user": "vyshkant",
        "created_at": "2019-12-22T15:10:24Z",
        "body": "Thanks @sergeybykov. The way to cache everything does not sound good :(\r\n\r\nWhat do you think, is it possible to reduce read operations count NOT to the \"just one\" but to the \"number of silos\"?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-12-23T19:27:36Z",
        "body": "I don't believe there's a way to get a free lunch here. If we have 500 distributed entities that can be updated independently, one would have to either query the underlying data store directly, hence bypassing the grains, or hold a cached snapshot of their state in memory, hence potentially stale, or perform 500 reads. Am I missing something?"
      }
    ]
  },
  {
    "number": 6176,
    "title": "Orleans for digital signal processing system",
    "created_at": "2019-12-12T07:43:47Z",
    "closed_at": "2019-12-31T00:31:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6176",
    "body": "Hi, is it possible use Orleans to create a distributed real time digital signal processing system?\r\n\r\nFor example, I need to use web sockets to get the time series data stream - to process it with a pipeline of heavy algorithms (FFT) and give the result back to the web socket.\r\n\r\nIs Orleans good choice for same task?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6176/comments",
    "author": "rsulab",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-12-19T00:04:50Z",
        "body": "I think the answer depends on the latency budget and acceptable percentile of responses within that budget. If it's milliseconds, and occasional delayed responses (due to GC) are okay, then I think it might work."
      }
    ]
  },
  {
    "number": 6153,
    "title": "How Orleans (should) recover when one silo is not responsive?",
    "created_at": "2019-12-02T20:05:02Z",
    "closed_at": "2020-03-24T03:20:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6153",
    "body": "Hi,\r\n\r\nWe had a bug which blocked all orleans pool threads (we fixed it).\r\nIt happened in our Production environment, and only in one silo, so this silo became unresponsive to other silos which received many timeouts to their requests to this silo.\r\nIt went for a long time, about 10-15 minutes, until we restarted the system.\r\n\r\nMy question - doesn't orleans have a built-in mechanism to monitor and detect such an unresponsive silo and shut it down and/or restart it or remove it from the silo's pool to allow continue of normal operation? am I missing something?\r\n\r\nThanks\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6153/comments",
    "author": "shlomiw",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-12-04T22:05:28Z",
        "body": "So long as the silo responds to ping messages, it is considered healthy from the other silos' perspective. Blocking an application thread or a specific grain would not prevent pings from getting processed. In other words, silo-level pings are too low level to detect a situation like that.\r\n\r\nApplication code can do more than that, and implement its own health checks, such as synthetic transactions. People do that today to tell their hosting environment, such as k8s or SF, about an unhealthy node.\r\n\r\nThere's no way today to feed this information to Orleans other than by shutting down of restarting a silo. Maybe we should consider an integration point for application health probes."
      },
      {
        "user": "shlomiw",
        "created_at": "2019-12-05T10:38:52Z",
        "body": "@sergeybykov - thanks for your reply, I didn't know the pings are that low level. Now I understand.\r\nFor now I will implement a kind of monitor myself.\r\n\r\nI believe that since Orleans already have blocking task detection (which is great, this is how I was able to resolve the issue we had!), it could be enhanced that if *all* threads in the thread-pool are blocked for X minutes, then consider the silo node as faulted, try to shut-it-down, and remove from the silos pool, or raise an event so we could let the hosting infrastructure handle it.\r\n\r\nShould I close this issue, or let it open maybe for future revision?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-12-31T00:40:44Z",
        "body": ">it could be enhanced that if all threads in the thread-pool are blocked for X minutes, then consider the silo node as faulted, try to shut-it-down, and remove from the silos pool, or raise an event so we could let the hosting infrastructure handle it.\r\n\r\nWhat we see some people doing is they send health-probe-like grain calls to each of the silos to detect that a silo is not responsive. My intuition is that an outside probe like that is more reliable than trying to infer a failure from within a silo itself. Maybe we could define a standard way to register an application-specific health probe method, so that other silos and/or the hosting infrastructure would periodically call it in addition to the low-level cluster membership pings?"
      }
    ]
  },
  {
    "number": 6129,
    "title": "[Question] Possible integration scenario using Event Hub streaming",
    "created_at": "2019-11-18T20:31:44Z",
    "closed_at": "2019-11-25T07:17:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6129",
    "body": "Hello all,\r\n\r\nI was able to find a couple of topics around Orleans Streaming + Event Hub, but I haven't been able to find something around the scenario that I've just tried.\r\n\r\nI'd like to integrate a couple of applications and I'd like to take advantage of the rewindable streaming support from Orleans+Event Hub. Direct connection between those products is not doable, but the following setup seems to work fine. \r\n\r\nIf each application bootstraps their own localhost silo and configure the same Event Hub stream provider, they will be able to pass events between each other, maintain their own cursor, or if I start a new silo and create a new subscriber, it will just ingest everything until it catches up. Fortunately, this is exactly what I need.\r\n\r\nAm I missing something? Is this a valid approach? What are the possible issues I can get into (from the Orleans standpoint/Event Hub standpoint)?\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6129/comments",
    "author": "cosmintiru",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-11-20T04:38:57Z",
        "body": "As I understand, you are looking to connect two Orleans-based applications via EventHub streams. If that's indeed the case, I don't see a problem with your approach. It's the easiest case when events are produced to and consumed from streams by Orleans.\r\n\r\nA more elaborate case is when either producer or consumer of event is non-Orleans code. In that case one has to take care of formatting the event data, so that it would be correctly interpreted by both sides."
      },
      {
        "user": "cosmintiru",
        "created_at": "2019-11-25T07:17:22Z",
        "body": "Thank you @sergeybykov , from my point of view this can be closed. "
      }
    ]
  },
  {
    "number": 6116,
    "title": "Can two grains of the same interface handle one reminder?",
    "created_at": "2019-11-12T19:17:31Z",
    "closed_at": "2019-11-14T12:14:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6116",
    "body": "Hi!\r\n\r\nSuppose we have two grains implementing one grain interface. `Grain-1` defines a reminder that was persisted, so on the next silo start it will be rised. Can `Grain-2` consume this reminder if `Grain-1` wasn't registered after reboot (but `Grain-2` was)?\r\n\r\nSpecifically, my case is this: I need to implement a way to disable some functionality (`Grain-1`), while retaining the ability to dummy-access it (`Grain-2` - dummy). At the same time, `Grain-1` creates a reminder that must be processed in a dummy way.\r\n\r\nI hope for your help.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6116/comments",
    "author": "vyshkant",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-11-13T21:30:17Z",
        "body": "Reminders are registered per grain. So, only the grain that registered a reminder will receive ticks from it.\r\n\r\nI'm not sure what you mean by \"registered\" in the following sentence:\r\n> if Grain-1 wasn't registered after reboot (but Grain-2 was)?\r\n\r\nIf Grain-1 registered a reminder, it will be invoked when the time comes. It can call Grain-2 as that point if needed. Unless I misunderstood your question."
      },
      {
        "user": "vyshkant",
        "created_at": "2019-11-14T12:14:41Z",
        "body": "Thanks for the answer!"
      }
    ]
  },
  {
    "number": 6085,
    "title": "Saving references to Other grains",
    "created_at": "2019-11-01T11:33:23Z",
    "closed_at": "2019-12-31T00:58:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6085",
    "body": "Hey\r\n\r\nI've trying out Orleans for some simple projects to get my head around.\r\nI'd like to ask if this is an Orleans way to approach things.\r\n\r\nI have Player and player can have multiple inventories (which in turn store multiple items).\r\nRight now I have Player Grain and Inventory Grain. Player Grain can reference multiple Inventory grains.\r\n\r\n1. Should I store Inventory Grains IDs inside PlayerState ?\r\n2. Can I just store Inventory References inside PlayerState and will they be automatically serialized ?\r\n3. Should I simply put everything into single grain (Player) ?\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6085/comments",
    "author": "iniside",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-11-10T23:49:24Z",
        "body": "I think storing grain IDs is the most flexible approach. 2 will also work, but it wouldn't provide a material benefit over 1.\r\n\r\nIt's hard to tell if 3 is a good option. It depends on access patterns. If inventories can only be managed via their player's grain, then it might make sense to just keep them as part of player's state. If, on the other hand, inventories might be accessed independently, for example, for management, aggregation, etc., then it might be better to keep them as separate addressable entities (grains)."
      }
    ]
  },
  {
    "number": 5969,
    "title": "Is it safe to inject ITimerRegistry using DI?",
    "created_at": "2019-09-23T17:02:33Z",
    "closed_at": "2019-09-27T20:33:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5969",
    "body": "Hi everyone!\r\n\r\nI found out that there is `Orleans.Timers.ITimerRegistry` interface, which is injectable as a service using DI.\r\n\r\nSuppose we have `FooGrain`, `BarService` and `ITimerRegistry`:\r\n\r\n```\r\npublic class FooGrain : Grain\r\n{\r\n    private readonly BarService _barService;\r\n\r\n    public FooGrain(BarService barService)\r\n    {\r\n        _barService = barService;\r\n    }\r\n\r\n    public Task DoFoo()\r\n    {\r\n        _barService.DoBar();\r\n\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n\r\npublic class BarService\r\n{\r\n    private readonly ITimerRegistry _timerRegistry;\r\n\r\n    public BarService(ITimerRegistry timerRegistry)\r\n    {\r\n        _timerRegistry = timerRegistry;\r\n    }\r\n\r\n    public void DoBar()\r\n    {\r\n        _timerRegistry.RegisterTimer(\r\n            grain: null,\r\n            asyncCallback: _ =>\r\n            {\r\n                Console.WriteLine(nameof(DoBar));\r\n                return Task.CompletedTask;\r\n            },\r\n            state: null,\r\n            dueTime: TimeSpan.FromSeconds(1),\r\n            period: TimeSpan.FromSeconds(10)\r\n        );\r\n    }\r\n}\r\n```\r\n\r\nAs you can see, I've passed `null` as a `grain` parameter to `ITimerRegistry.RegisterTimer`, and it still works, the timer does tick.\r\n\r\nMy question is: is it safe? I AFAIR timers are participants of grain messaging system and are alvays scheduled with Orleans scheduler.\r\n\r\nBut if I passed `null` as a grain, what schedule does they participate? Can I be sure that timers, that were created in the way I've shown above, are scheduling in the correct way and never run concurrently with other tasks?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5969/comments",
    "author": "vyshkant",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2019-09-24T02:40:24Z",
        "body": "Users are not supposed to interact directly with `ITimerRegistry` but it's possible to inject it and use it. I would recommend that you do not pass `null` for the grain since that will *not* produce valid behavior. You must have an instance of the grain to register the timer for, otherwise the timer will not be associated with any grain and will be scheduled on a null context"
      },
      {
        "user": "vyshkant",
        "created_at": "2019-09-27T20:33:59Z",
        "body": "Thanks!"
      }
    ]
  },
  {
    "number": 5962,
    "title": "Custom Log Event Store",
    "created_at": "2019-09-18T11:57:29Z",
    "closed_at": "2021-11-24T13:01:02Z",
    "labels": [
      "question",
      "Needs: author feedback",
      "Status: no recent activity"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5962",
    "body": "Hi,\r\n\r\nI'm looking at implementing a custom storage provider - I would like to be storing the events for a Journaled Grains.  Could you please clarify if i need to implement a custom storage provider as well as the grains implement ICustomStorageInterface.\r\n\r\nAlso on storage providers, whats the difference between IStorageProvider and IGrainStorage - i.e. when is the IProvider implementation of IStorageProvider  used?\r\n\r\nI've been going through the documenation, just a little confused at the moment. Thanks,\r\nRoss",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5962/comments",
    "author": "rossbuggins",
    "comments": [
      {
        "user": "rafikiassumani-msft",
        "created_at": "2021-11-17T04:18:23Z",
        "body": "@rossbuggins Are you still looking for guidance on implementing a custom storage provider?"
      },
      {
        "user": "ghost",
        "created_at": "2021-11-21T08:00:56Z",
        "body": "This issue has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **4 days**. It will be closed if no further activity occurs **within 3 days of this comment**."
      }
    ]
  },
  {
    "number": 5882,
    "title": "Reminders spinning up on silos with different clusterId",
    "created_at": "2019-08-21T20:05:13Z",
    "closed_at": "2019-08-23T14:15:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5882",
    "body": "Hi, I have an orleans setup where we have different silos with different clusterId's (staging, dev, prod, etc). I noticed that every now and then a reminder that was created on staging would spin up in dev silos.\r\n\r\nI am using AdoNetReminderService with SQL Server, when I looked at the ReminderTable, I noticed that it only had ServiceId as the column, no reference to ClusterId, so I changed all of the silos to have different serviceId's to prevent the issue. However, it was brought to my attention that the Orleans documentation recommends keeping all of the ServiceId's of the silos the same. Am I missing anything? Are reminders supposed to be able to distinguish between silos with different clusterId's even with same ServiceId's?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5882/comments",
    "author": "TulkasLaugh",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-08-21T21:40:59Z",
        "body": "`ServiceId` acts as a high-level application ID. It stays the same over time through multiple subsequent versions of the application (clusters) getting deployed one after another. Hence, application state that needs continuity through those deployments id keyed off `ServiceId`. Reminders and grain state are examples of that.\r\n\r\n`ClusterId` is a unique ID for a set of silos (cluster) running at some point in time. Typically, only one cluster is up at a time for any `ServiceId`. `ClusterId` is used for silos and clients to discover each other.\r\n\r\nYou likely want to use different `ServiceId`s for staging, dev, and prod clusters, and for sure a unique `ClusterId` for each of them."
      },
      {
        "user": "TulkasLaugh",
        "created_at": "2019-08-23T14:15:19Z",
        "body": "Cool. Thank you."
      }
    ]
  },
  {
    "number": 5869,
    "title": "how to call outside method  in grains?",
    "created_at": "2019-08-15T10:32:59Z",
    "closed_at": "2019-08-16T09:10:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5869",
    "body": "I have netty as frontend. the msg from device can pass throuth netty then we have a cluster to handler the msg. but how to send response  through netty to device?\r\n\r\nI do got some method to do the job without orleans. but I 'd like to know the  orleans' way.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5869/comments",
    "author": "wuzhenda",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-08-15T21:27:52Z",
        "body": "If you need grains to send messages to devices, there's usually one of two ways.\r\n\r\n1. If you already have a system for sending messages to devices, you can have grains make calls to that system.\r\n\r\n2. If devices are connected to frontend web servers (via web sockets or HTTP long polling), you need grains to notify respective frontend servers. This can be done either via client observers or streams."
      },
      {
        "user": "wuzhenda",
        "created_at": "2019-08-16T01:22:28Z",
        "body": "thanks first.\r\n\r\nway 2:seems like the sample gps tracker do.\r\n\r\nway 1: can grains directly call the system's method,even we don't know where the grain exactly run in the cluster? the gps tracker sample use signalr's hub proxy to notify the web frontend,it not directly call the system's method.\r\n"
      }
    ]
  },
  {
    "number": 5858,
    "title": "How to deploy a new version of GrainService?",
    "created_at": "2019-08-13T09:58:08Z",
    "closed_at": "2019-08-22T10:35:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5858",
    "body": "Since a GrainService runs on the silo from startup to shutdown, what is the best strategy to deploy a new version on the same cluster?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5858/comments",
    "author": "diogomacedonatixis",
    "comments": [
      {
        "user": "JorgeCandeias",
        "created_at": "2019-08-13T11:19:49Z",
        "body": "We do not deploy a new version of a `GrainService` on its own. What we do is we redeploy the entire cluster, silo by silo, with new versions of all grains and other code. This is often done in either a rolling deployment fashion or a blue-green deployment fashion from your automated DevOps build and release schedule. This is the same strategy as you'd use to roll out a regular ASP.NET web site, there's nothing special about it.\r\n\r\nIf you're looking for hot code swapping in Erlang style, that is not supported at this time, AFAIK. With containerized micro-services hosts such as Service Fabric and Kubernetes making automated rolling deployments and rollbacks easier, I'm not sure it ever will for lack of need."
      }
    ]
  },
  {
    "number": 5797,
    "title": "How to structure Grains for fast loading of historical data?",
    "created_at": "2019-07-29T22:53:45Z",
    "closed_at": "2019-09-20T04:48:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5797",
    "body": "Hello and thanks for building such an incredible framework. I’m beginning the process of sorting out how to leverage Orleans in a major revision of a project that I work on and have several high level questions that I’m hoping to receive some guidance on so I can avoid starting down the wrong path. If there is a better place or way to ask these questions, I’d be happy to change venues. Also, since I feel that an example application to tie together some of these concepts would help me personally as well as other newcomers in the IoT space I am very interested in contributing an example/quick start once I have a solid path to head down.\r\n\r\nThe platform that I’m working on handles the dispatching of work to drivers with the complexity that it is a multi-tenant application so we need to ensure each organization’s data is exclusive to their users and tablets. We currently provide this by putting each tenant’s data in their own SQL DB that only their users have access to (every tenant has a connection string to the correct DB). The dispatchers are using a windows desktop back office application with a companion ReactJS web app for viewing realtime/historical locations and the drivers are using an Android tablet app. We currently tie this all together with a blend of RESTish (there’s some RPC endpoints in it too) WebAPI that makes heavy use of Azure Event Hubs for incoming data from the tablets (processing happens in windows services that are subscribed to the hubs something that we want to move to Orleans), uses SignalR for pushing realtime data to the browser, and loads most things out of each tenant’s SQL DB (which are not all in the same datacenter as the API).\r\n\r\nSo now that the “what” of what I’m trying to improve is out of the way, where I need help is how we’re going to best utilize Orleans to improve our API. Using Orleans for the basic activity of the application feels really straight forward (although perhaps I’m over simplifying it) in that we can easily assign a Job to a Driver and trigger a push notification to the Device that the driver is using. When data comes in from a Device we can use an Event Hub based stream to queue the processing of its data and push the new location to the web app in realtime with SignalR. The challenging part for me is how to structure all this so that historical data can be easily and quickly retrieved as well as avoid packing too much data into a single Grain.\r\n\r\nAn example of this is that dispatchers may want to see the path a driver traveled to get to a job. Currently we load that data from the tenant’s DB and I would assume that is still the best way to handle it since loading data for a single driver is relatively quick. Where performance becomes challenging is loading the location of all devices from a particular point in time. Would it be reasonable to have a `ITenantGrain.LoadDeviceLocationAsOf(DateTime time)` that returns a list of all devices with their last known location at that point in time? If so, what is the recommendation for implementing something like that? Would it work to asyncly iterate through all the devices asking each of them to figure out where they where (there can be 100 - 1000ish devices per tenant)? We currently make this perform reasonably well by constantly building per-minute time windowed data for each tenant that is persisted separately so we can grab the time window that holds the locations we’re looking for. This is expensive from a storage standpoint so we trash the time windows after 7 days and queries for older data become slow. This feels like an area of our application that we should be able to improve with the power of Orleans, but I’m struggling to come up with an architecture that feels like a winner (likely because my optics are based in the way we’ve already solved it). If the pre-calculated time windows are still the best bet, is there an example out there of how to do this in Orleans (essentially a per-minute list of all the location changes for all devices belonging to a tenant). \r\n\r\nThis question is getting too long, so I’ll leave it rooted in the historical data persistence and retrieval for now and as I gain a better understanding of the Orleans way of accomplishing some of this I’ll drill into other challenging aspects of the application.\r\n\r\nIf there’s some documentation that I should be reading to help come up with a solution or an example that I should be referencing instead of asking for help, please share and I’ll gladly keep trying to sort this out on my own. Thank you very much for your time!",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5797/comments",
    "author": "jeddawson",
    "comments": [
      {
        "user": "Cloud33",
        "created_at": "2019-08-06T03:28:03Z",
        "body": "Can i persist the statistics first? (I understand that the data should not change) dynamically calculate the thermal data"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-08-15T21:08:35Z",
        "body": "Sorry about delay. I was under the false impression this was replied to.\r\n\r\nMy impression is that you are asking a more general question of organizing data, and Orleans is only a factor in the picture because of how it helps load and keep pieces of state in memory on demand. The potential solutions seem to boil down to how to denormalize the data for efficient access in both OLTP style and querying of time series data. Did I get it right?\r\n\r\n>Would it work to asyncly iterate through all the devices asking each of them to figure out where they where (there can be 100 - 1000ish devices per tenant)?\r\n\r\nThis could work at a low scale, but I'm afraid it's not sustainable or efficient.\r\n\r\nThe approach with per-tenant location history grains seems more scalable to me. That would help retrieve (and potentially store) historical data in a way that is more suitable for querying state of drivers at a point in time. Per-tenant data could be further partitioned by larger time windows (e.g. a grain per day/hour) or geo-location (a grain per geographic tile), to help the system scale.\r\n\r\nI hope this helps. But I'm not 100% sure I answered your question."
      },
      {
        "user": "jeddawson",
        "created_at": "2019-08-23T23:37:54Z",
        "body": "@sergeybykov you definitely got it right and your advice on how to scope the grains does indeed help. I've taken a couple pretty naive stabs at this in our testing environment and feel like your advice has me on the right track. Thank you for taking the time to read my extra-long question and provide some valuable insight."
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-08-29T17:15:39Z",
        "body": "Great! Can we close this issue now?"
      },
      {
        "user": "jeddawson",
        "created_at": "2019-09-20T04:48:55Z",
        "body": "Yep, thanks @sergeybykov"
      }
    ]
  },
  {
    "number": 5789,
    "title": "Mechanism to fetch all states from a grain (Like Select * from table)",
    "created_at": "2019-07-26T09:37:15Z",
    "closed_at": "2019-07-27T03:12:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5789",
    "body": "",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5789/comments",
    "author": "AnikethNagansurya",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-07-26T16:23:06Z",
        "body": "Do you mean to fetch state from multiple grains of a grain type?"
      },
      {
        "user": "AnikethNagansurya",
        "created_at": "2019-07-26T16:28:32Z",
        "body": "No, meant to say like if we create grains with Guid n populate the states of that created grain and now want to fetch all the grains states at once from that silo. "
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-07-26T17:58:16Z",
        "body": "Doesn't \"we create grains with Guid n populate the states\" refer to multiple grains?"
      },
      {
        "user": "AnikethNagansurya",
        "created_at": "2019-07-26T18:07:51Z",
        "body": "Yes. Sorry for the confusion, can we fetch the states for multiple grains at once. "
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-07-26T18:11:10Z",
        "body": "In the application code you can fan-out calls to multiple grains in parallel, and then merge the responses after they arrive. There's no built-in support for that though."
      },
      {
        "user": "AnikethNagansurya",
        "created_at": "2019-07-27T03:12:10Z",
        "body": "Ok. Thank you 😊 "
      }
    ]
  },
  {
    "number": 5768,
    "title": "[Question]: Silo connection via bus.",
    "created_at": "2019-07-19T05:41:34Z",
    "closed_at": "2019-07-20T21:39:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5768",
    "body": "Hello, tell me please, is there a way to connect Silo nodes to a bus like Redis or Azure Queue?\r\nI tried to use Azure AppService as hosting my .net core webapi application, which also contains Silo, but the AppService does not allow opening a private endpoint for Silo connections. \r\nAnd I wondered if it was possible to connect the nodes without a direct connection.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5768/comments",
    "author": "KSemenenko",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-07-19T22:41:32Z",
        "body": "Currently, direct TCP connectivity between silo nodes is a requirement. "
      },
      {
        "user": "KSemenenko",
        "created_at": "2019-07-20T21:39:02Z",
        "body": "Thanks @sergeybykov "
      }
    ]
  },
  {
    "number": 5756,
    "title": "System.TimeoutException: Response did not arrive on time in 00:00:30 for message",
    "created_at": "2019-07-16T03:08:01Z",
    "closed_at": "2019-08-15T21:32:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5756",
    "body": "I Have 5 silo in a cluster .\r\n\r\nthe Error log\r\n```log\r\nSystem.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request S10.0.2.88:11111:300480702*stg/13/0000000d@S0000000d->S10.0.2.86:11111:300480703*stg/10/0000000a@S0000000a #13639713: . Target History is: <S10.0.2.86:11111:300480703:*stg/10/0000000a:@S0000000a>. at Orleans.OrleansTaskExtentions.<ToTypedTask>g__ConvertAsync|4_0[T](Task`1 asyncTask) at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.RegisterAsync(ActivationAddress address, Boolean singleActivation, Int32 hopCount) at Orleans.OrleansTaskExtentions.LogException(Task task, ILogger logger, ErrorCode errorCode, String message)\r\n```\r\n\r\nIt seems the request from 88 to 86 is timeout. And I  saw som warning about membership\r\n```log\r\n-Did not get ping response for ping #123682 from S10.0.2.88:11111:300480702. Reason = Original Exc Type: System.TimeoutException Message:Response did not arrive on time in 00:00:30 for message: Request S10.0.2.86:11111:300480703*stg/15/0000000f@S0000000f->S10.0.2.88:11111:300480702*stg/15/0000000f@S0000000f #2993755: . Target History is: <S10.0.2.88:11111:300480702:*stg/15/0000000f:@S0000000f>. \r\n```\r\nIt seems the ping request from 86 to 88 is timeout ,And I saw a vote in  silo 88 membership Entry . the option of NumVotesForDeathDeclaration is 2 ,So the silo 88 would not be killed. \r\n\r\n The member ping request from 86 to 88 is timeout , and  the request from 88 to 86 is timeout.  Other membership validations are normal . What happened to my orleans cluster ？\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5756/comments",
    "author": "dingsongjie",
    "comments": [
      {
        "user": "dingsongjie",
        "created_at": "2019-07-16T03:54:56Z",
        "body": "And  I find some logs  Before the timeout exception throwed\r\n```log\r\nSystem.Runtime.Serialization.SerializationException: Attempt to read past the end of the input stream: CurrentPosition=0, n=4, totalLength=0 at Orleans.Serialization.BinaryTokenStreamReader.CheckLength(Int32 n, Int32& offset, Boolean& safeToUse) at Orleans.Serialization.BinaryTokenStreamReader.CheckLength(Int32 n, Int32& offset) at Orleans.Serialization.BinaryTokenStreamReader.ReadInt() at Orleans.Runtime.Message.HeadersContainer.Deserializer(Type expected, IDeserializationContext context) at Orleans.Serialization.SerializationManager.DeserializeMessageHeaders(IDeserializationContext context) at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message& msg) at Orleans.Runtime.Messaging.IncomingMessageAcceptor.ReceiveCallbackContext.ProcessReceived(SocketAsyncEventArgs e) at Orleans.Runtime.Messaging.IncomingMessageAcceptor.ProcessReceive(SocketAsyncEventArgs e)\r\n```"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-07-19T23:29:48Z",
        "body": "It is difficult to judge based on the information you provided. If you share full logs of the silos during this period of time, that would make it easier. In general, thread-blocking operations in application code may lead to silo becoming unavailable. But it's just a wild guess based on the amount of information you shared."
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-08-15T21:32:54Z",
        "body": "Closing due to inactivity for now. Feel free to reopen."
      }
    ]
  },
  {
    "number": 5750,
    "title": "Get Guid of IGrainWithGuidCompoundKey in Grain",
    "created_at": "2019-07-12T16:01:46Z",
    "closed_at": "2019-08-15T21:32:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5750",
    "body": "In the grain implementation code, how can you get the actual Guid part of the key when using IGrainWithGuidCompoundKey?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5750/comments",
    "author": "rossbuggins",
    "comments": [
      {
        "user": "wanton7",
        "created_at": "2019-07-13T12:57:15Z",
        "body": "With `this.GetPrimaryKey(out _)`"
      }
    ]
  },
  {
    "number": 5725,
    "title": "hot grain best way to do?",
    "created_at": "2019-06-27T02:00:20Z",
    "closed_at": "2019-06-27T02:39:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5725",
    "body": "The grain is designed to obtain the tenant token. The token is from a third party and will be refreshed and updated every 2 hours. But there are more customers who visit a tenant token at the same time, and may reach thousands. Is this hot grain? If so, how to avoid it. Note that the token is not related to the customer and is only relevant to the tenant.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5725/comments",
    "author": "gwhzh21",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2019-06-27T02:21:25Z",
        "body": "@gwhzh21 here are two ways to alleviate pressure on a hot grain here:\r\n\r\n1. Create a local cache for the tenant token, eg a class which caches the value. Other grains can access the value using that cache.\r\n2. Use stateless workers so that there are multiple copies of the grain on each silo.\r\n\r\nI recommend option 1, since it's simple and most of the time you can avoid making a grain call."
      },
      {
        "user": "gwhzh21",
        "created_at": "2019-06-27T02:39:36Z",
        "body": "@ReubenBond good idea.thanks."
      }
    ]
  },
  {
    "number": 5556,
    "title": "Specify Bond Serializer for the MsBuildTask",
    "created_at": "2019-04-25T23:48:45Z",
    "closed_at": "2019-07-15T15:56:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5556",
    "body": "Question...\r\nHow do I tell the MsBuildTask to use the Bond Serializer?\r\n\r\nregards,\r\nrich",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5556/comments",
    "author": "fuocor",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2019-07-15T15:56:04Z",
        "body": "Apologies for the slow reply. The code generator does not specify a serializer, instead it generates serialization methods regardless of which serializer you plan to use. At runtime you can configure Bond as your preferred serializer using code similar to this on the client + silos:\r\n\r\n```C#\r\n// builder is ISiloBuilder or IClientBuilder\r\nbuilder.Configure<SerializationProviderOptions>(\r\n  options => options.SerializationProviders.Add(typeof(BondSerializer)))\r\n```"
      },
      {
        "user": "ReubenBond",
        "created_at": "2019-07-15T15:56:57Z",
        "body": "@fuocor I'll close this issue for now, but please feel free to open another or add a comment if there's anything I can help with"
      }
    ]
  },
  {
    "number": 5524,
    "title": "How to know whether a transaction is over or not.",
    "created_at": "2019-04-10T22:57:53Z",
    "closed_at": "2021-11-17T23:01:07Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5524",
    "body": "Is there any way to find out a transaction is over or not with transaction id?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5524/comments",
    "author": "danpat04",
    "comments": [
      {
        "user": "danpat04",
        "created_at": "2019-04-24T10:33:50Z",
        "body": "Is there any way for it?"
      },
      {
        "user": "jason-bragg",
        "created_at": "2019-04-26T18:11:31Z",
        "body": "A transactional grain call will be complete when the task resolves, unless the call throws a timeout or a OrleansTransactionInDoubtException.  In those cases, the transaction may still be in progress and retries may lead to cascading aborts."
      },
      {
        "user": "danpat04",
        "created_at": "2019-04-27T09:23:23Z",
        "body": "I know that, but I was wondering if there's any way to find out whether a transaction is over or not when I want to know."
      },
      {
        "user": "ghost",
        "created_at": "2021-11-17T23:01:05Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 5508,
    "title": "what is the best way to  transmit request from grainA to grainB.",
    "created_at": "2019-04-04T11:57:32Z",
    "closed_at": "2019-04-05T02:53:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5508",
    "body": "I don`t know how many IGrainB silos in the cluster,it is scaled.\r\nIf I use  GrainFactory.GetGrain<IGrainB>(0), it is inefficient.Only one grainB busy. \r\nIf I use  GrainFactory.GetGrain<IGrainB>(randomid) ,it means per request creates per grain.Im afraid It will  create amount of Gains there. \r\nHow should I do it? Thanks.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5508/comments",
    "author": "zjsjmvn",
    "comments": [
      {
        "user": "JorgeCandeias",
        "created_at": "2019-04-04T13:35:44Z",
        "body": "What does GrainA and GrainB mean in your use case?\r\n\r\nWe tend to model grains to match logical entities in the application. For example, a \"user\" entity could have a `IUserGrain` interface and a `UserGrain` class if that makes sense. Then each distrint user in the application would get its own grain instance via its key.\r\n\r\n``` csharp\r\nvar user1 = GrainFactory.GetGrain<IUser>(\"SomeUserNameHere1\");\r\nvar user2 = GrainFactory.GetGrain<IUser>(\"SomeUserNameHere2\");\r\n```\r\n\r\nYou can use integers, guids or strings as keys, so you're free to model it as it makes sense.\r\nOrleans will place these grain instances *randomly* on the cluster, which often works fine for most use cases.\r\nYou can also use other placement strategies if *random* is not good enough for the use case.\r\n\r\nFor stateless workloads and throw away stateful workloads there are other approaches too."
      },
      {
        "user": "zjsjmvn",
        "created_at": "2019-04-04T16:36:59Z",
        "body": "@JorgeCandeias \r\nThanks.GrainB is Gate ,when the orleans client get the message from others,I transmit it to the gate (GrainB).\r\nI don`t know the best way to get GrainB. \r\n"
      },
      {
        "user": "JorgeCandeias",
        "created_at": "2019-04-04T19:57:55Z",
        "body": "I do not yet understand your use case.\r\n\r\n* What is “Gate”?\r\n* What is “others”?\r\n* What do they represent in the application?\r\n* Are they things with business keys?\r\n\r\nCan you provide more background detail about your solution requirements?"
      }
    ]
  },
  {
    "number": 5494,
    "title": "does GrainServiceClient   accessing the GrainService is load balanced？",
    "created_at": "2019-04-01T12:38:56Z",
    "closed_at": "2019-04-02T01:16:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5494",
    "body": "",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5494/comments",
    "author": "zjsjmvn",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-04-01T20:52:15Z",
        "body": "It is hash-partitioned, but, strictly specking, not balanced (doesn't get repartitioned based on the actual load)."
      },
      {
        "user": "zjsjmvn",
        "created_at": "2019-04-02T01:03:04Z",
        "body": "thanks"
      }
    ]
  },
  {
    "number": 5485,
    "title": "Question: How can one access the IReminderRegistry from a static Grain extension method.",
    "created_at": "2019-03-29T14:10:19Z",
    "closed_at": "2019-05-05T11:24:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5485",
    "body": "I'm attempting to write a static extension method for the `Grain` type, which, in addition to other things, also registers a timer.\r\n\r\nThe easiest way would be to call `RegisterTimer()` from the grain, however that method is protected and hence not available to a static extension method.\r\n\r\nI'd like to avoid weird stuff like creating an extension `.UseSomething()` method on `IHostBuilder` to expose the timer registry to some static variable.\r\n\r\nIs there some nice way to reach the `ITimerRegistry` in this context?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5485/comments",
    "author": "JorgeCandeias",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2019-03-29T14:30:08Z",
        "body": "All of the important methods/properties of `Grain` are either `protected` or `internal`. If `Grain.Runtime` was exposed then you would be able to access `grain.Runtime.TimerRegistry`.\r\n\r\nTo the best of my knowledge, `Grain` is never exposed to user code directly except perhaps via `IIncomingGrainCallContext` (and in that case it's exposed as `IAddressable`).\r\n\r\nPerhaps we should expose `IGrainRuntime` via `Grain`'s `Runtime` property. What do you think?\r\n\r\nThere are protections in the `IGrainRuntime` impl to prevent access from outside of the grain's execution context (eg, you can't access it from `Task.Run`). I assume that's fine for you."
      },
      {
        "user": "ReubenBond",
        "created_at": "2019-03-29T14:44:58Z",
        "body": "If you only need this functionality for your own grains then you can create a grain base class or interface which exposes `IGrainRuntime` property in some way (inject it if needed)."
      },
      {
        "user": "JorgeCandeias",
        "created_at": "2019-03-29T16:45:16Z",
        "body": "This is to improve the ad-hoc reactive caching sample PR (and the improvement will spill into out own solutions here). I'm fine with deriving the class for my own solution. However I'd prefer having something less intrusive for the benefit of the sample users.\r\n\r\n---\r\n\r\n> Perhaps we should expose IGrainRuntime via Grain's Runtime property. What do you think?\r\n\r\nI'm always weary of exposing API surface *by default* without a good reason, as it's hard to go back on that decision. If it's just for this use case, I don't think that API change is warranted.\r\n\r\n> There are protections in the IGrainRuntime impl to prevent access from outside of the grain's execution context (eg, you can't access it from Task.Run). I assume that's fine for you.\r\n\r\nThat's fine - the extension is meant to be called from within the grain. It's a comfort method, nothing else.\r\n\r\n---\r\n\r\nRight now I'm considering the interface way, e.g.:\r\n\r\n* Create an interface that allows implementations to expose a timer registry, for example:\r\n``` csharp\r\npublic interface ISomeExposingInterface\r\n{\r\n    ITimerRegistry TimerRegistry { get; }\r\n}\r\n```\r\n* Implement the interface on the given grain, thereby *explicitly* exposing the TimerRegistry.\r\n* Extend the interface with the static method instead of the grain class.\r\n\r\nThis works, is explicit, is 100% application code... but it feels like over-engineering a very simple thing and pollutes the grain code.\r\n\r\nAnother way can be to just take the TimerRegistry in the extension method itself:\r\n\r\n``` csharp\r\npublic static IDisposable StartSomethingHere(this Grain grain, ITimerRegistry registry, ...) { }\r\n```\r\n\r\nBut it doesn't look very pretty either.\r\n\r\nI can also attempt to add support for the use case itself to grain in a generic way, e.g.\r\n\r\n``` csharp\r\npublic class Grain\r\n{\r\n    protected IDisposable CreateReactivePoll(...);\r\n}\r\n```\r\n\r\nBut it feels very very wrong to pollute wide-concern platform classes with narrow-concern comfort methods.\r\n\r\nSigh. Thumbs up/down on either? Or it there some other nice pattern that could fit here?"
      },
      {
        "user": "JorgeCandeias",
        "created_at": "2019-03-29T16:54:33Z",
        "body": "> If you only need this functionality for your own grains then you can create a grain base class or interface which exposes `IGrainRuntime` property in some way (inject it if needed).\r\n\r\nApologies, didn't notice this reply. I guess this replaces the first option of my previous reply."
      },
      {
        "user": "JorgeCandeias",
        "created_at": "2019-03-31T15:39:32Z",
        "body": "Hmm, the grain also has a protected `IServiceProvider` property. I think exposing this one as public could facilitate writing extension methods in general, in addition to this one. What do you think?"
      },
      {
        "user": "JorgeCandeias",
        "created_at": "2019-05-05T11:24:32Z",
        "body": "Closing this one. Further experience since opening this issue has shown me having a base Grain class to inherit from, (e.g. AppGrain) as a productive practice overall. Therefore we just pass whatever we need to the base class constructor as usual. This removes the need to open up any easy-to-misuse API surface."
      }
    ]
  },
  {
    "number": 5478,
    "title": "Question about registered reminders and cluster id",
    "created_at": "2019-03-27T18:44:17Z",
    "closed_at": "2019-03-29T19:50:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5478",
    "body": "We have a lot of errors like this one:\r\n```\r\nCould not deliver reminder tick for [Default, GrainReference:*grn/9827AB60/0000000000000000000000000000000006ffffff9827ab60+Default-0x0BF7DC4E, 00:30:00, 2019-02-03 20:15:18.833 GMT, W/\"datetime'2019-02-03T20%3A15%3A19.0436877Z'\", 34, Ticking], next 3/27/2019 6:15:21 PM.\r\n\r\n```\r\nI checked the reminders table and found that following reminder has been renamed and has cluster id that already not in use . We increment the cluster id during devops. This is like zombie record. Is this expected?\r\n\r\nFull error\r\n```\r\nCould not deliver reminder tick for [Default, GrainReference:*grn/9827AB60/0000000000000000000000000000000006ffffff9827ab60+Default-0x0BF7DC4E, 00:30:00, 2019-02-03 20:15:18.833 GMT, W/\"datetime'2019-02-03T20%3A15%3A19.0436877Z'\", 34, Ticking], next 3/27/2019 6:15:21 PM.\r\n\r\nOrleans.OrleansCodeGenRemindableMethodInvoker+<Invoke>d__0.MoveNext\r\n\r\nSystem.InvalidCastException:\r\n   at Orleans.OrleansCodeGenRemindableMethodInvoker+<Invoke>d__0.MoveNext (Orleans.Core, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null)\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)\r\n   at Orleans.Runtime.GrainMethodInvoker+<Invoke>d__21.MoveNext (Orleans.Runtime, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null)\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)\r\n   at Orleans.Runtime.InsideRuntimeClient+<Invoke>d__62.MoveNext (Orleans.Runtime, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null)\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)\r\n   at Orleans.Runtime.ReminderService.LocalReminderService+LocalReminderData+<OnTimerTick>d__20.MoveNext (Orleans.Runtime, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null)\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5478/comments",
    "author": "ifle",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-03-27T23:39:28Z",
        "body": "Reminders have a service wide scope - they survive changing of the cluster ID (by design). If you want a fresh deployment with no state like reminders or grain state carried from the old cluster, you need to deploy a new cluster with a difference Service ID."
      },
      {
        "user": "ifle",
        "created_at": "2019-03-29T19:50:41Z",
        "body": "Thanks for your clarification"
      }
    ]
  },
  {
    "number": 5419,
    "title": "Orleans Streaming - sparse streams scenario",
    "created_at": "2019-03-03T08:37:42Z",
    "closed_at": "2021-11-17T23:01:14Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5419",
    "body": "Hi! In our company we are trying to use Orleans for IoT scenario. We using IoT Hub/EventHub.\r\nI did a significant amount of research around how to do this properly using available possibilities in Orleans. It turned out that we cannot use Streaming with modified EventHub provider as current implementation has problems with huge number of sparse streams (if we would like to use Stream per Device). Each device can send relatively small amount of data in not so short period like one minute for example. But we can have them really huge number like half millions. That in average can give us around 8k messages per second to the system, but for each device - one message per minute. \r\nCurrently, using Orleans that way (Stream per Device) turns out really quickly to be inefficient (around 10-20k streams). For that reason we choose hosting EPH along with the silo (as GrainService) and just pass messages directly to the \"device\" grain. That easily could handle 500k grains (if machine RAM was enough). \r\nI did some time ago discussion about that with @jason-bragg and eventually possibilities of implementing/improving current Streams to handle sparse streams. \r\nNow i have a time to do more investigation on that and would like to play with it a bit. I wonder if we could have discussion here how this could be handled inside Orleans runtime - some guidance from you, guys, so i could know where to start looking at. ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5419/comments",
    "author": "darthkurak",
    "comments": [
      {
        "user": "koenbeuk",
        "created_at": "2019-03-03T16:10:22Z",
        "body": "I'm in the preparation phase for solving a very similar problem. Scale target for millions of iot devices, all publishing a few events each hour, that need to find their way to their respective grain. (each device is represented by a grain). The current proposal includes an Azure EventHub -> Azure function -> Grain\r\n\r\nBeing able to use Orleans streaming rather than having to capture events outside of Orleans and pushing to a grain directly would reduce cost and complexity and open up new doors (e.g. different subscribers for each event stream). Hence I'd like to contribute on this where I can. "
      },
      {
        "user": "darthkurak",
        "created_at": "2019-03-03T23:28:24Z",
        "body": "Small off top : why are you using azure functions but not event hub processor host directly? "
      },
      {
        "user": "koenbeuk",
        "created_at": "2019-03-04T04:13:36Z",
        "body": "That's what we have on paper right now, we may come back on that decision. The main reason being hosting. Using Azure functions, there is a single centralized source which distributes events throughout the silos. To my understanding, If I was to use a GrainService, then each Silo would have an instance of this service running. I would then have to go and either find a way to only have 1 instance running per cluster- which would unbalance load on the silo's- or find a way to have multiple instances running in parallel (which doesn't sound like a trivial job). Perhaps I'm wrong in my understanding of how the EventProcessorHost or GrainServices work. I would love to see your implementation."
      },
      {
        "user": "darthkurak",
        "created_at": "2019-03-04T11:48:44Z",
        "body": "PM me on gitter. EPH is written that way that it can be run in multi instances on the same EH (it has leasing manager). Actually AF using EPH underhood. I'm not saying that using Azure Functions is wrong, but maybe not needed and could save you a few bucks. It depends on your scenario. "
      },
      {
        "user": "jason-bragg",
        "created_at": "2019-03-05T20:47:43Z",
        "body": "I'd like to start with making sure I understand the requirements of your test senario.  Please vet my understanding:\r\n\r\n- 8k events / second total\r\n- 1 event / minute / stream\r\n\r\n**Deductions**\r\n- This results in about 480k active streams.\r\n- Using eventhub with a limit of 1k events / second / partition, this mean service would need hub with at least 8 partitions.\r\n- That comes out to be about 60k active streams per partition.\r\n\r\n**Questions**\r\nAre the streams using implicit or explicit subscriptions?\r\nHow many silos are in the cluster?\r\nWhat is the average size of the events?\r\n\r\nThe overhead of managing recoverable streams is likely too high for this pattern, but I want to make sure I'm understanding the senario befor exploring optimizations.\r\n\r\n"
      },
      {
        "user": "darthkurak",
        "created_at": "2019-03-06T06:44:03Z",
        "body": "More or less - yes. But this is ONLY example scenario. This can change. For example, like - one event per 30 seconds on device. Or one event per 5 minutes. But this example give idea of the problem - many streams, with relatively slow data.\r\nFew things to point out:\r\n- I would assume 32 partitions on EventHub as this could allow achieve more throughputs in terms of single cluster\r\n- Assuming empty grain logic I was able to achieve around 40k - 60k messages / s with Event Processor Host as Grain Service on single machine (Standard_F8s_v2) (32 partitions on Event Hub, 0.5M devices, EventHub data populated earlier, so - it grabs messages as quickly as possible)\r\n- Streams should use implicit subscriptions\r\n- As i did tests on single machine cluster, i would like to compare basing on that (Standard_F8s_v2)\r\n- Around 1 kB - 2 kB (in test scenario, but this could vary a lot depends on devices) \r\n- Requirements is that this should have at least one delivery, the best would be some de-duplication mechanism (exactly one delivery)"
      },
      {
        "user": "darthkurak",
        "created_at": "2019-03-28T07:58:14Z",
        "body": "@jason-bragg ? :)"
      },
      {
        "user": "ghost",
        "created_at": "2021-11-17T23:01:12Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 5383,
    "title": "How to access Orleans inside Service Fabric from outside? ",
    "created_at": "2019-02-21T16:47:18Z",
    "closed_at": "2019-02-22T13:00:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5383",
    "body": "Hi, I'm trying to deploy Orleans Silo to a Service Fabric cluster. I need my Orleans client to be outside of the SF cluster. With the sample code, the address saved in the Membership table is the internal SF ip.\r\nHow can I properly configure Orleans Silo to expose the external addresses for the client to use?\r\nOr maybe there is a way to use Static clustering to connect to the service fabric service?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5383/comments",
    "author": "drakerunner",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2019-02-21T16:59:53Z",
        "body": "You can change the `EndpointOptions.AdvertisedIPAddress` property, but you should only access the cluster from within a given network: it should not be exposed to the Internet.\r\n\r\nInstead, put a web server in front of it."
      },
      {
        "user": "drakerunner",
        "created_at": "2019-02-22T13:00:54Z",
        "body": "Thanks. I was trying to test as a proof of concept. But the real scenario everything will be in the same vnet. In that case I won't have any problems... "
      }
    ]
  },
  {
    "number": 5375,
    "title": "can i get more than then thousand streams?  any limit or side effect in large count stream?",
    "created_at": "2019-02-19T08:13:22Z",
    "closed_at": "2019-03-26T21:01:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5375",
    "body": "i am building mqtt server broker cluster by orleans. \r\n\r\none stream named cluster stream  to share mqtt packet between brokers in cluster,\r\neach broker has it`s own stream named broker stream.\r\nbroker grain subscribe from cluster stream  or publish mqtt packet to cluster stream.\r\nclient connect to one broker, publish or subscribe mqtt packet in broker.\r\n\r\nmy question is\r\nshould i get a stream for each client(over ten thousand clients), route mqtt packet at grain side.\r\nor just one stream one broker only, process mqtt packet at grain client side and route to mqtt client.\r\n\r\ncan anyone give me some suggestions? \r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5375/comments",
    "author": "ByteCopilot",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-03-01T00:41:51Z",
        "body": "Fundamentally, there is no hard limit on the number of streams. Practically though, some data structures will be stressed with too many streams. It's hard to tell where the limit after which one would experience the negative effects because it depends on a number of environmental factors. But thousands and tens of thousands of concurrently used streams sounds fine to me."
      }
    ]
  },
  {
    "number": 5367,
    "title": "OMG DDS vs Orleans",
    "created_at": "2019-02-14T14:06:45Z",
    "closed_at": "2019-03-26T21:01:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5367",
    "body": "",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5367/comments",
    "author": "AllamSudhakara",
    "comments": [
      {
        "user": "AllamSudhakara",
        "created_at": "2019-02-14T14:09:27Z",
        "body": "What are the comparisons between pub/sub middle ware architectures compared to Orleans such as OMG DDS Or any other broker frame works? I got involved in middle ware and came across Orleans platform and wondering how closely they match by funcitonality"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-03-01T00:47:35Z",
        "body": "I personally haven't heard of OMG DDS before. So I don't have a comparison. Can you formulate the comparison or at least the key questions answers to which would be the differentiators?"
      }
    ]
  },
  {
    "number": 5366,
    "title": "Question about Transaction",
    "created_at": "2019-02-14T01:24:34Z",
    "closed_at": "2019-03-12T05:40:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5366",
    "body": "I need some advice on using Orleans.Transaction.\r\n\r\nTo use Orleans.Transaction it is required to declare TransactionOption on the Grain interface.\r\nIt means that if you make a method that can be called in or not in Transaction, you have to double it.\r\n\r\nSo I thought this way would be easier to use this way.\r\n```csharp\r\nawait wallet.PerformUpdate(balance => balance.Pop(100));\r\n \r\n \r\nvar inventoryGrain = GetGrain<InventoryGrain>(userId, TransactionOption.Join);\r\nawait inventoryGrain.AddItem(\"Healing Potion\");\r\n```\r\nLike the code above, I thought it would be nice if a transaction starts when requester wants to.\r\nThis way there's no way to find out the method's TransactionOption on the declaration.\r\n\r\n```csharp\r\npublic interface ISomeGrain : IGrainWithStringKey\r\n{\r\n    [Transaction(TransactionOption.Create)]     \r\n    Task<TReturn> NoneTransactionalRequest<TReturn>(MethodInfo mi, params object[] parameters);\r\n\r\n    [Transaction(TransactionOption.Join)]\r\n    Task<TReturn> TransactionalRequest<TReturn>(MethodInfo mi, params object[] parameters);\r\n}\r\n```\r\nSo we made a custom layer and call it `Service` layer.\r\nA Service is matched with a Grain.\r\nWhen a Service request something to another Service, It sends through Grain.\r\nAnd at Grain level, we decide which way to go, NoneTransactionalRequest or TransactionalRequest.\r\n\r\nIf the request is NoneTransactionalRequest, create a new transaction.\r\nif the request is TransactionalRequest, join the current transaction.\r\n\r\nHere are the questions.\r\nFirst, I want to know how you think of this way.\r\nSecond, Is this way of using Orleans.Transaction is too much?\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5366/comments",
    "author": "danpat04",
    "comments": [
      {
        "user": "danpat04",
        "created_at": "2019-02-19T04:58:47Z",
        "body": "I thought I could get an immediate reply.  \r\nIs this a hard question? or need more details?"
      },
      {
        "user": "jason-bragg",
        "created_at": "2019-02-19T16:06:26Z",
        "body": "> To use Orleans.Transaction it is required to declare TransactionOption on the Grain interface.\r\n\r\nYes.  This is the case because most of the options (other than create) are relevant to the caller, so the information needs exist on the interface.\r\n\r\n> It means that if you make a method that can be called in or not in Transaction, you have to double it.\r\n\r\nYes.  Transactions deal with persisted state.  This state can only be operated on transactionally.  If is invalid to read or modify this state outside the context of a transaction.\r\n\r\n> If the request is NoneTransactionalRequest, create a new transaction.\r\nif the request is TransactionalRequest, join the current transaction.\r\n\r\nOne should be able to get this behavior by marking the transaction CreateOrJoin.  If the call is made from within a transaction, it will join it.  If the call is made from outside the context of a transaction it will create one.\r\n"
      },
      {
        "user": "danpat04",
        "created_at": "2019-02-26T05:17:08Z",
        "body": "Thanks for the explanations.\r\nBut my real questions were at the bottom of the issue.\r\n\r\n> First, I want to know how you think of this way.\r\nSecond, Is this way of using Orleans.Transaction is too much?"
      },
      {
        "user": "jason-bragg",
        "created_at": "2019-03-06T18:13:40Z",
        "body": "@danpat04,\r\n\r\n> I want to know how you think of this way.\r\n\r\nI don't think this is approach is necessary.\r\nI think you can get the same result with the supported TransactionOption CreateOrJoin.\r\n\r\n\"One should be able to get this behavior by marking the transaction CreateOrJoin. If the call is made from within a transaction, it will join it. If the call is made from outside the context of a transaction it will create one.\"\r\n\r\n> Is this way of using Orleans.Transaction is too much?\r\n\r\nNo, I don't think so, it's not too much, but it's just not necessary.\r\n"
      },
      {
        "user": "danpat04",
        "created_at": "2019-03-12T05:40:15Z",
        "body": "Thanks, I understood what your saying is."
      },
      {
        "user": "pellesantiago",
        "created_at": "2019-05-16T20:21:18Z",
        "body": "Hi there,\r\nI'm new to Orleans. I'm still learning from the  #documentation.\r\n\r\nIn my experience, transaction are related to BUSINESS LOGIC layer. \r\nI'm currently thinking in Orleans as a INFRAESTRUCTURE layer. ¿Maybe i'm wrong?\r\n\r\nIn the furure, if i want to change Orleans library for another library in the infrastructure layer, i should keep transaction operation logic in business layer, not in Orleans layer. Again...¿maybe i'm wrong?\r\n\r\nSo, i think that the solution proposed by danpat04 is more accurately. I dont know if its posible to develop inside Orleans..\r\n\r\nWith current Orleans solution, ¿can you manipulate transaction logic (create, join, commit,rollback) from business layer instead of Orleans layer?\r\n\r\nThanks for your reply.\r\n\r\nRegards,\r\nSantiago"
      }
    ]
  },
  {
    "number": 5363,
    "title": "Is GrainService support StorageProvider attribute?",
    "created_at": "2019-02-13T14:02:51Z",
    "closed_at": "2019-03-05T22:42:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5363",
    "body": "i tried to use GrainServices as documentation code.\r\nStorageProvider  only described used for Grain class, can i use it like this?\r\nand if StorageProvider not support ,how supposed i use storage in GrainService? thans\r\n\r\n```\r\n [Reentrant]\r\n [StorageProvider(ProviderName = \"PubSubStore\")]\r\n public class LightstreamerDataService : GrainService, IDataService {\r\n    readonly IGrainFactory GrainFactory;\r\n\r\n    public LightstreamerDataService(IServiceProvider services, IGrainIdentity id, Silo silo, ILoggerFactory\r\n         loggerFactory, IGrainFactory grainFactory) : base(id, silo, loggerFactory) {\r\n        GrainFactory = grainFactory;\r\n    }\r\n    public Task MyMethod() {\r\n    }\r\n }\r\n```",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5363/comments",
    "author": "ByteCopilot",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-02-13T23:02:04Z",
        "body": "I don't think we ever considered or tried using declarative persistence for grain services. If it works, it would be by accident. In general, code inside a grain service class (or grain class) is free to use any persistence technology directly (without going via a persistence provider), so long as all IO calls are asynchronous."
      },
      {
        "user": "ByteCopilot",
        "created_at": "2019-02-14T01:58:50Z",
        "body": "thanks. \r\ni read all documentation, test all sample codes,  but still fill confused to use orleans features **streams** and **observers** even after serach in github.\r\nany advises or provide more examples to help us understand streams or observers?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-02-14T06:43:27Z",
        "body": "Could you list your questions and confusions. That would help us understand what's not clear."
      },
      {
        "user": "ByteCopilot",
        "created_at": "2019-02-15T01:20:42Z",
        "body": "> Could you list your questions and confusions. That would help us understand what's not clear.\r\n\r\n```\r\nStreams Programming API documentation.\r\n\r\nCurrent Status of Rewindable Streams: Both SMS and Azure Queue providers are not-rewindable and \r\nOrleans currently does not include an implementation of rewindable streams. We are actively working on\r\n this.\r\n```\r\nwhich stream providers support rewindable streams now?  and if i want impl my own providers, what should i do, is there any examples? thanks\r\n\r\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-02-21T02:06:08Z",
        "body": "I submitter #5382 to update the outdated text."
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-03-05T22:42:51Z",
        "body": "The doc issue got resolved via #5382."
      }
    ]
  },
  {
    "number": 5330,
    "title": "Every call to the grain sends a packet over the network for a request? ",
    "created_at": "2019-01-23T16:46:36Z",
    "closed_at": "2019-01-24T02:49:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5330",
    "body": "Is there a way to get the requested data directly to silo, because each time the requested parameter is a complex object, it will take some time to make a memory copy and then send it over the network. Assuming my program is only running on one server, the above operations will waste a lot of performance.\r\nThank you for reading。",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5330/comments",
    "author": "guopenglun",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-01-23T16:55:57Z",
        "body": "If a call to a grain is made within the same silo where that grain is activated, no data is sent over the network, only memory copy of the arguments is performed. Memory copy can be eliminated by wrapping argument type with `Immutable<>`. However, in that case the code must not mutate the arguments after making a call."
      },
      {
        "user": "guopenglun",
        "created_at": "2019-01-24T02:49:56Z",
        "body": "Thank you for your reply, very helpful :)"
      }
    ]
  },
  {
    "number": 5324,
    "title": "Performance issue, how to read warnings from log",
    "created_at": "2019-01-21T12:52:04Z",
    "closed_at": "2019-03-05T22:35:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5324",
    "body": "Hello,\r\nhow to get more details about warnings visible in log ?\r\nI have faced performance issues, but I can't find what is the reason.\r\nI will appreciate your help.\r\nGreetings\r\n\r\nMy logs:\r\n>       Task [Id=8677620, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/7480126151777703339/87d1d5ab@S87d1d5ab] to\r\nok elapsed time 0:00:00.3293732 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8678501, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/1660678162373163416/72803998@S72803998] to\r\nok elapsed time 0:00:00.2571926 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8678514, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/16201652576789337278/b5d214be@Sb5d214be] t\r\nook elapsed time 0:00:00.2284598 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8678839, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/13243215104421926820/cf2817a4@Scf2817a4] t\r\nook elapsed time 0:00:00.487768 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8678990, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/2892194010405447811/03baa883@S03baa883] to\r\nok elapsed time 0:00:00.4912624 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8682400, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/10139444246793834898/46065192@S46065192] t\r\nook elapsed time 0:00:00.2345563 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8683635, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/7480126151777703339/87d1d5ab@S87d1d5ab] to\r\nok elapsed time 0:00:00.3088771 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8684277, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/3971411049396639124/d8591594@Sd8591594] to\r\nok elapsed time 0:00:00.2059425 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8684381, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/3262124382583873155/ad0d5e83@Sad0d5e83] to\r\nok elapsed time 0:00:00.2554212 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8684605, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/12365399726059551649/417dfba1@S417dfba1] t\r\nook elapsed time 0:00:00.2144696 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8689909, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/9962573138966299836/64ef44bc@S64ef44bc] to\r\nok elapsed time 0:00:00.2164671 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8692696, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/11452622014448957596/260c789c@S260c789c] t\r\nook elapsed time 0:00:00.3986481 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8693449, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/10939458234255134123/e7ffcdab@Se7ffcdab] t\r\nook elapsed time 0:00:00.356442 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8694469, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/8797984796704637060/12de0084@S12de0084] to\r\nok elapsed time 0:00:00.2079363 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8694695, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/3002566311248937147/dc8c40bb@Sdc8c40bb] to\r\nok elapsed time 0:00:00.2369492 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8695501, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/9974504408589424314/948a56ba@S948a56ba] to\r\nok elapsed time 0:00:00.8594778 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8697446, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/15212243947186492053/a4a31295@Sa4a31295] t\r\nook elapsed time 0:00:00.3273585 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8698355, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/17110226376080873662/34d1d8be@S34d1d8be] t\r\nook elapsed time 0:00:00.2694442 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8700250, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/13037136908939279520/e975bca0@Se975bca0] t\r\nook elapsed time 0:00:00.3555526 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8700861, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/14859631423479171972/c9b54b84@Sc9b54b84] t\r\nook elapsed time 0:00:00.3161251 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8702632, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/1981981633998696594/8dd73092@S8dd73092] to\r\nok elapsed time 0:00:00.2025749 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8702901, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/3002566311248937147/dc8c40bb@Sdc8c40bb] to\r\nok elapsed time 0:00:00.2669245 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8706348, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/3070772565396539313/ea79c7b1@Sea79c7b1] to\r\nok elapsed time 0:00:00.2264682 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8708324, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/13205469375169319353/5f4451b9@S5f4451b9] t\r\nook elapsed time 0:00:00.284403 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8708693, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/3002566311248937147/dc8c40bb@Sdc8c40bb] to\r\nok elapsed time 0:00:00.2148307 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8710148, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/4474990208853291151/ac0d308f@Sac0d308f] to\r\nok elapsed time 0:00:00.5519002 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8715341, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/15952853474205714349/83e347ad@S83e347ad] t\r\nook elapsed time 0:00:00.5413761 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8715823, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/16365102821271470515/56a101b3@S56a101b3] t\r\nook elapsed time 0:00:00.2770024 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8716471, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/4474990208853291151/ac0d308f@Sac0d308f] to\r\nok elapsed time 0:00:00.2164933 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8717287, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/3262124382583873155/ad0d5e83@Sad0d5e83] to\r\nok elapsed time 0:00:00.2459953 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8717470, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/3971411049396639124/d8591594@Sd8591594] to\r\nok elapsed time 0:00:00.3994595 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8717819, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/13243215104421926820/cf2817a4@Scf2817a4] t\r\nook elapsed time 0:00:00.2591515 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8717860, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/10939458234255134123/e7ffcdab@Se7ffcdab] t\r\nook elapsed time 0:00:00.2349099 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8719159, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/753007251491414656/0a706280@S0a706280] too\r\nk elapsed time 0:00:00.2772202 for execution, which is longer than 00:00:00.2000\r\n000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8719938, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/3070772565396539313/ea79c7b1@Sea79c7b1] to\r\nok elapsed time 0:00:00.3865724 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8720187, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/11444598981775634862/4988b1ae@S4988b1ae] t\r\nook elapsed time 0:00:00.393994 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8721865, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/9962573138966299836/64ef44bc@S64ef44bc] to\r\nok elapsed time 0:00:00.2093606 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8722921, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/1981981633998696594/8dd73092@S8dd73092] to\r\nok elapsed time 0:00:00.29118 for execution, which is longer than 00:00:00.20000\r\n00. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8723871, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/16201652576789337278/b5d214be@Sb5d214be] t\r\nook elapsed time 0:00:00.2281181 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8726620, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/812735807001527226/109103ba@S109103ba] too\r\nk elapsed time 0:00:00.3368624 for execution, which is longer than 00:00:00.2000\r\n000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8727268, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/17110226376080873662/34d1d8be@S34d1d8be] t\r\nook elapsed time 0:00:00.2351561 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8727378, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/10939458234255134123/e7ffcdab@Se7ffcdab] t\r\nook elapsed time 0:00:00.2045067 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8727801, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/10177662558882251144/79f84188@S79f84188] t\r\nook elapsed time 0:00:00.3269352 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8729143, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/6346276726719776131/16760583@S16760583] to\r\nok elapsed time 0:00:00.2939532 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8729889, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/9974504408589424314/948a56ba@S948a56ba] to\r\nok elapsed time 0:00:00.2711455 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8731870, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/15278920717608221610/0464fbaa@S0464fbaa] t\r\nook elapsed time 0:00:00.4368154 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8732476, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/17144885887817931434/a1fedaaa@Sa1fedaaa] t\r\nook elapsed time 0:00:00.387365 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8736383, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/9139807053803530884/3591aa84@S3591aa84] to\r\nok elapsed time 0:00:00.4033186 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8736448, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/404602148764222349/b873838d@Sb873838d] too\r\nk elapsed time 0:00:00.7389245 for execution, which is longer than 00:00:00.2000\r\n000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8736864, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/11199281674166864300/a84209ac@Sa84209ac] t\r\nook elapsed time 0:00:00.2407328 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8737603, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/14428427995014467459/fe238f83@Sfe238f83] t\r\nook elapsed time 0:00:00.338192 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8738574, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/15212243947186492053/a4a31295@Sa4a31295] t\r\nook elapsed time 0:00:00.2200619 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8739156, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/11867948782904102814/f9874f9e@Sf9874f9e] t\r\nook elapsed time 0:00:00.4196865 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8740236, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/9962573138966299836/64ef44bc@S64ef44bc] to\r\nok elapsed time 0:00:00.3324778 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8741554, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/8188424151639157946/bcae6cba@Sbcae6cba] to\r\nok elapsed time 0:00:00.2116091 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8743123, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/1981981633998696594/8dd73092@S8dd73092] to\r\nok elapsed time 0:00:00.3394255 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8743381, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/14428427995014467459/fe238f83@Sfe238f83] t\r\nook elapsed time 0:00:00.2190081 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8746322, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/11444598981775634862/4988b1ae@S4988b1ae] t\r\nook elapsed time 0:00:00.2179242 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8750120, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/18232931148661783190/0a23fa96@S0a23fa96] t\r\nook elapsed time 0:00:00.3155508 for execution, which is longer than 00:00:00.20\r\n00000. Running on thread System.Threading.Thread\r\nwarn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]\r\n      Task [Id=8750132, Status=RanToCompletion] in WorkGroup [LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/3002566311248937147/dc8c40bb@Sdc8c40bb] to\r\nok elapsed time 0:00:00.3163106 for execution, which is longer than 00:00:00.200\r\n0000. Running on thread System.Threading.Thread\r\n\r\n> ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5324/comments",
    "author": "darrrrek",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-01-23T17:18:37Z",
        "body": "These warnings point to LowPrioritySystemTargets that are used for streaming puling agents and grain services.\r\n>[LowPrioritySystemT\r\narget: S127.0.0.1:11111:285768451*stg/xyz/\r\n\r\nAre you using either of those?"
      },
      {
        "user": "darrrrek",
        "created_at": "2019-01-28T12:33:48Z",
        "body": "Hello @sergeybykov , yes I'm using Orleans Streams and Grain Services."
      },
      {
        "user": "darrrrek",
        "created_at": "2019-02-02T11:03:40Z",
        "body": "@sergeybykov how can I solve this ? or it's normal if I'm using streams and grain services ?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-02-05T05:00:30Z",
        "body": "The warnings likely point to thread blocking that happens somewhere in the grain service or stream pulling agents. What stream provider are you using? I'd suggest to start by checking the code for IO operations that aren't performed asynchronously."
      }
    ]
  },
  {
    "number": 5321,
    "title": "Message / Request Priority",
    "created_at": "2019-01-18T13:15:58Z",
    "closed_at": "2019-01-25T06:06:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5321",
    "body": "Hi, we are using Orleans as back-end in our IoT project, briefly it relies on ConnectionPoint's and Devices. Devices are connected to CP's. Each CP support only one connection in the same time so it's very suitable for CP's to work within single-threaded nature of grains. There are various reminders on CP for each Devices, like read device setup, read device data, heartbeat, health-check and some other domain specific operations. CPGrain is not re-entrant, and we are using asynchronous socket for communication.\r\n\r\nMy question is; there is being multiple request by reminders on the CPGrain's mailboxes naturally, but we also have some instant request that must be run instantly, so expected behavior would be like that, even if there are 20 messages in the mailbox, cancel current process first (we can handle it with grain cancellation token) and **process instant request before other requests in the mailbox (that is I am asking for) is there a way to do that with Orleans**\r\n\r\nCurrently we are using priority queue in CPGrain to schedule and prioritize messages/requests, but we have to check queue with timer to process. So we are loosing natural flow of Orleans by this custom solution, besides lower time interval for that timer would result with high CPU consumption, contrary higher time interval would result higher latency. Do you have any suggestion?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5321/comments",
    "author": "berataydin",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-01-18T19:16:33Z",
        "body": "A short answer is that there is no notion of priority of incoming requests and the runtime never cancels execution of a request. So requests to a grain always start executing in the order of their arrival. There were requests to allow reordering of incoming requests based on priority or other considerations. But that hasn't been implemented so far.\r\n\r\nA longer answer is based on the assumption that processing of requests and reminder callbacks doesn't take a significant amount of time on the thread, and the latency is primarily determined by asynchronous IO calls. Please correct me if that's not true for your application.\r\n\r\nIf my assumption is correct, then full or partial reentrancy might be a way to achieve what you are looking for. Toady `[Reentrant]` is a class level attribute. So it applies to all method of the grain. @jason-bragg is currently looking at making it also a method level, so that individual methods could be marked for reentrancy. That would allow to make 'priority' methods reentrant, and they would be able to start executing whenever the currently running methods hits an `await`. \r\n\r\nThere is also the `[AlwaysInterleave]`, which is a method level attribute. I personally consider it more of a 'hack', but it can also be useful until we improve and extend the reentrancy story. Semantics of `[AlwaysInterleave]` are different from `[Reentrant]` - it allows to interleave with other grain methods, but not with those also marked as `[AlwaysInterleave]`.\r\n\r\nWhat's not clear to me in your description though is that you are talking about potentially having 20 messages in a grain's queue. What is the reason for such a jam? You mentioned reminders. But they are intended to fire relatively infrequently, and mostly for fault tolerance purpose. Is a grain is managing a single device, I would assume it shouldn't get too many messages. Is that a real case or a potential corner case you want to be prepared for?"
      },
      {
        "user": "berataydin",
        "created_at": "2019-01-21T08:04:32Z",
        "body": "Ok let me explain my situation more detailed.\r\n\r\nIn some situations, we have more than 20+ devices connected to same ConnectionPoint (up to 32 devices). Each CP is a grain because of we have only one socket connection to communicate for all devices that are connected to same CP. \r\nWe are polling all devices per 5 minutes (read 400+ register data per device), so when the time is up we will have 20 poll request in our message queue at the same time. Each poll taking 5 to 10 seconds to finish(but all the communication is non-blocking as I told before).\r\n\r\nSo when there are 20 poll request in the queue that are currently processing, **there may come instant request from user interface like _'Read Device Setup'_, this request have more priority because when device polling is a background process that can be handled later, but this request is coming from UI by user interaction that must be replied asap, but it takes time to response because there are already 20 currently processing polling message in the queue.**\r\n\r\nFirst we designed each Device as a grain, but it would be meaningless because they have to use same connection that is related with Connection Point.\r\nAlso there is a Device model object that involves all register of device that is very heavy to serialize, so ve designed CP as a grain and devices are members by following Orleans Best Practices.\r\n \r\nWe couldn't be sure about using [Reentrant] because of our ConnectionPointGrain is statefull, has complex state operations and coarse grained by its nature. We were thinking about [AlwaysInterleave] working on some PoC currently. "
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-01-23T06:26:07Z",
        "body": ">We are polling all devices per 5 minutes (read 400+ register data per device), so when the time is up we will have 20 poll request in our message queue at the same time. Each poll taking 5 to 10 seconds to finish(but all the communication is non-blocking as I told before).\r\n\r\nWith CP grain being non-reentrant, poll requests at the end of the queue might take up to 200 seconds to start executing. Is that correct?\r\n\r\n>We couldn't be sure about using [Reentrant] because of our ConnectionPointGrain is statefull, has complex state operations and coarse grained by its nature. We were thinking about [AlwaysInterleave] working on some PoC currently.\r\n\r\nWhat are you concerns about `[Reentrant]`? Grain is still single-threaded. Are you worried about the complexity of thinking through possible interleaving cases? `[AlwaysInterleave]` will let you interleave read methods marked with it while awaiting inside poll requests. Is that what you think you need?"
      },
      {
        "user": "berataydin",
        "created_at": "2019-01-25T06:06:04Z",
        "body": "> With CP grain being non-reentrant, poll requests at the end of the queue might take up to 200 seconds to start executing. Is that correct?\r\n\r\nYes it's true.\r\n\r\n> What are you concerns about [Reentrant]? Grain is still single-threaded. Are you worried about the complexity of thinking through possible interleaving cases? [AlwaysInterleave] will let you interleave read methods marked with it while awaiting inside poll requests. Is that what you think you need?\r\n\r\nRather than complexity there are some operations like ReadDeviceSetup that shouldn't be interleaved so Grain can not be Re-entrant. In the light of these information, it looks best option for us signing all the other methods with [AlwaysInterleave] except critical one's like ReadDeviceSetup. Thank you very much."
      }
    ]
  },
  {
    "number": 5316,
    "title": "Is storing state data inside of a grain redundant?",
    "created_at": "2019-01-16T10:33:08Z",
    "closed_at": "2019-01-17T08:27:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5316",
    "body": "Hi guys.\r\nI'm wondering if it makes any sense to store State data inside a grain.\r\nI'm adding State to a `Foo` grain.\r\n\r\nWhen it was stateless (`Foo : Grain`), having `_bar` did make sense.\r\nNow that a state has been added and persisted, Foo's Bar can be accessed though its State, so I totally see `_bar` as redundant info, but just in case I'm missing something.\r\n\r\n```c#\r\n    [StorageProvider(ProviderName = \"MyProvider\")]\r\n    public class Foo : Grain<Bar>\r\n    {\r\n        private readonly Bar _bar;  // Redundant?\r\n        // ...\r\n    }\r\n\r\n    public class Bar\r\n    {\r\n        public int A { get; set; }\r\n\r\n        public double B { get; set; }\r\n    }\r\n```\r\n\r\nThanks in advance for your answers!",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5316/comments",
    "author": "eduherminio",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-01-16T17:55:28Z",
        "body": "Yes, if for `Foo : Grain<Bar>` it would be redundant to keep another copy of the same state of type `Bar` in `_bar`. "
      },
      {
        "user": "eduherminio",
        "created_at": "2019-01-17T08:27:25Z",
        "body": "Thanks for the clarification!"
      }
    ]
  },
  {
    "number": 5299,
    "title": "Grain Persistence and GrainCancellationTokenSource",
    "created_at": "2019-01-07T19:57:25Z",
    "closed_at": "2019-03-05T22:26:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5299",
    "body": "Hi, I am creating grain persistence for a master grain that manages the work of other worker grains. I am utilizing GrainCancellationTokenSource so the master grain can cancel all of the worker grains, however when I try to use Grain Persistence for the GrainCancellationTokenSource I get an error saying that GrainCancellationTokenSource cannot be deep copied. Do you guys have any recommendations around this error or have any recommendations for managing cancellation of worker grains? Thanks.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5299/comments",
    "author": "TulkasLaugh",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-01-08T00:00:06Z",
        "body": "`GrainCancellationTokenSource` is not meant to be persistent. It's a transient object that allows to try to cancel an in-flight requests. Why do you want to persist it when it has no meaning after the grain call it's used for completes?"
      },
      {
        "user": "TulkasLaugh",
        "created_at": "2019-01-08T17:46:58Z",
        "body": "I was thinking that if a silo goes down in the middle of polling a job that's taking a long time and needs to be reactivated it would need the same CancellationTokenSource in order to still be able to cancel. Do you have a recommendation on trying to handle that kind of scenario?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-01-08T21:19:05Z",
        "body": "The general recommendation is not to make long running calls. Instead, make a call to *initiate* a long running operation, and get later notified (via a grain call, an observer or a stream) about its completion. If the grain that is executing the long running operation (on a separate thread or on the thread pool to avoid blocking grain threads) is marked as `[Reentrant]`, it can receive an explicit request to cancel the operation (without using the cancellation token) or get polled about the progress of the operation.\r\n\r\nIn other words, the recommended pattern is to make quick grain calls and manage any long running process via a series of them instead of a one long call. This pattern is more robust in the face of failures and in general makes the app logic more responsive and flexible."
      },
      {
        "user": "TulkasLaugh",
        "created_at": "2019-01-09T21:02:54Z",
        "body": "Make sense, I'll follow your recommendations."
      }
    ]
  },
  {
    "number": 5286,
    "title": "Grain Persistence and polling",
    "created_at": "2019-01-02T19:36:18Z",
    "closed_at": "2019-03-05T22:26:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5286",
    "body": "I'm working on a project with a design where individual Grains would make Http calls to poll on web services. My code has it so the grain would do Task.Run(), to poll on the web service until it's finished. I'm trying to implement grain persistence and thinking through a scenario where a silo goes down while a grain is polling and I'm not sure how to ensure it will pick back up where it left off. \r\n\r\nDo you guys have a recommended way to do something like that?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5286/comments",
    "author": "TulkasLaugh",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-01-02T22:52:46Z",
        "body": "Why `Task.Run` and not regular asynchronous calls from within the grain cotext, e.g. from a timer callback?\r\n\r\nFor fault tolerance, in general, you likely want to persist the request and schedule a reminder (that will reactivate the grain if necessary) before returning success from the call that initiates polling. "
      },
      {
        "user": "TulkasLaugh",
        "created_at": "2019-01-03T15:27:20Z",
        "body": "In my scenario, once the asynchronous function finishes polling, it will pipe its result into a stream to notify another grain that it has completed. So that has to be awaited but the caller of the grain that does polling doesn't want to wait for polling to complete to report back that it started a polling job.\r\n\r\nSo to apply what you're recommending for fault tolerance, do I persist the request, schedule a reminder so that if a silo goes down, the reminder will start the grain back up again?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-01-04T00:08:08Z",
        "body": ">So to apply what you're recommending for fault tolerance, do I persist the request, schedule a reminder so that if a silo goes down, the reminder will start the grain back up again?\r\n\r\nYes, I think you need the polling grain to do all of that *before* responding to the caller that it started the polling job successfully. "
      },
      {
        "user": "TulkasLaugh",
        "created_at": "2019-01-04T23:46:01Z",
        "body": "Cool, I followed your advice and got the reminders to work with grain persistence. However, I am noticing that Console.Write that I would rely on for local development are no longer working when code is being executed inside of a reminder. It won't affect staging, or production because we use a logger, but is there any explanation for why code being executed within a Reminder is not being displayed in console and is there any way to set it up so that it can (having the logger send to console also is not working in context of Reminder)?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-01-09T19:24:27Z",
        "body": "That's strange. Console should work. I don't believe we are interfering with it in any way. Could it be buffering? Have you tried `Console.WriteLine()`?"
      }
    ]
  },
  {
    "number": 5283,
    "title": "What's the real benefit of stateless workers?",
    "created_at": "2018-12-31T08:38:03Z",
    "closed_at": "2019-01-04T05:02:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5283",
    "body": "I was just leaving a comment on someone's code, and I told them they could do something with a static class instead of using stateless workers. This got me thinking: what's the real benefit of stateless workers? They provide two benefits as far as I can tell:\r\n\r\n1. They'll limit the number of concurrent operations, but at the added cost of a grain method call (which I believe can be significant if the operation itself is simple).\r\n2. They'll provide single-thread guarantees.\r\n\r\nI don't really know about number 1 (someone with more knowledge could probably shed some light), but number two is rather meaningless if there *really is no state*. Rather, the main benefit I can think of is when a stateless worker has *some* state, but the state is transient. Then, you could have timers and do some work based on previous state and whatnot (take the aggregator pattern for example), which makes the name *stateless* worker rather counter-intuitive. I can only assume stateless actually means no *persistent* state.\r\n\r\nAm I missing something? More importantly, am I correct in assuming that any truly stateless operation can be implemented (probably with better performance) as a static method on a static class rather than a method on a stateless worker grain?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5283/comments",
    "author": "Arshia001",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-01-02T18:42:00Z",
        "body": "Consider the following scenario, which is actually how `StatelessWorker` grains came to be.\r\n\r\nClient sends encrypted messages to the cluster. Inside each message there's an identity of the target user (grain). Before the message can be send to the user grain for processing, it needs to get decrypted and the user ID extracted, so that it can be passed to `GetGrain<IUserGrain>(id)`. A `StatelessWorker` grain provides an 'endpoint' for clients to send such messages to. Activations of that grain are always local to the silo that receives a request (client gateway), and they automatically scale out with the load."
      },
      {
        "user": "Arshia001",
        "created_at": "2019-01-02T20:04:09Z",
        "body": "My nodes have always been symmetric, so I wasn't considering silo clients at all... Thanks! "
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-01-02T20:36:39Z",
        "body": "There are also scenarios for `StatelessWorker` grains that don't involve clients. For example, if you need to report an aggregate metric across many thousands of grains in the cluster, it won't work if you try to have each grain sends its report to a single aggregator grain because it would become the obvious bottleneck. Instead, you can have those grains call a `StatelessWorker` 'pre-aggregator' grain. That would cause them invoking local (within the same silo) 1 or N (depending on what you specify) activations of the pre-aggregator.\r\n\r\nThe pre-aggregator grains can then periodically, on timer, report their individual aggregates to the final aggregator grain. Since there will be much fewer of those calls, the final aggregator won't be overloaded with calls from the pre-aggregators.\r\n\r\nThis pattern has been successfully applied in multiple production systems."
      },
      {
        "user": "Arshia001",
        "created_at": "2019-01-03T05:51:06Z",
        "body": "Yes, that's exactly the transient state I was thinking about. I think it's safe to assume that \"putting stateless logic which is meant to be consumed from within silos inside static classes is a better choice\". This implies that maybe two thirds of my stateless workers so far have only been slowing the system down... 🤦‍♂️"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-01-04T00:11:57Z",
        "body": ">\"putting stateless logic which is meant to be consumed from within silos inside static classes is a better choice\".\r\n\r\nYes, unlike with statics, with stateless workers you get the single-threading guarantee."
      },
      {
        "user": "Arshia001",
        "created_at": "2019-01-04T05:02:55Z",
        "body": "Thanks! "
      }
    ]
  },
  {
    "number": 5260,
    "title": "What interface does Orleans have to get all Grain?",
    "created_at": "2018-12-14T07:32:14Z",
    "closed_at": "2019-01-08T14:34:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5260",
    "body": "What interface does Orleans have to get all Grain? ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5260/comments",
    "author": "lfzm",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-12-14T18:03:14Z",
        "body": "Orleans doesn't have a mechanism for that. Applications can build their own registration/indexing solutions or query directly in storage."
      },
      {
        "user": "lfzm",
        "created_at": "2019-01-08T14:34:52Z",
        "body": "This will get all the Grain and Grain Interface\r\n```\r\n      var context = (HostBuilderContext)this.serviceProvider.GetService(typeof(HostBuilderContext));\r\n      object key = context.Properties.Keys.Where(f => f.GetType() == typeof(object)).FirstOrDefault();\r\n      var partManager = (IApplicationPartManager)context.Properties[key];\r\n      var grainInterfaceFeature = partManager.CreateAndPopulateFeature<GrainInterfaceFeature>();\r\n      var grainClassFeature = partManager.CreateAndPopulateFeature<GrainClassFeature>();\r\n```"
      }
    ]
  },
  {
    "number": 5259,
    "title": "P2P network?",
    "created_at": "2018-12-14T03:36:34Z",
    "closed_at": "2019-01-04T22:32:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5259",
    "body": "I noticed in the adventure example that the host was also the client. This has me wondering: what is stopping you from axing the middle man altogether and making the client the host too? I.e. a P2P network?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5259/comments",
    "author": "tonytins",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-12-14T17:42:22Z",
        "body": "This was always possible - to host client and silo in the same process. We do that for testing and #3362 made it more efficient. The concern is usually about security, with most people wanted to physically separate their frontend nodes (web servers) from their silo nodes."
      }
    ]
  },
  {
    "number": 5256,
    "title": "Is there any way to get the type of the grain reference, which passed in the method parameters?",
    "created_at": "2018-12-13T10:08:01Z",
    "closed_at": "2018-12-29T02:30:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5256",
    "body": "Is there any way to get the type of the grain reference, which passed in the method parameters?\r\nLike below:\r\n\r\nCaller interfaces:\r\n```cs\r\n    public interface IClients : IGrainWithStringKey { }\r\n\r\n    public interface IGroup : IClients { }\r\n\r\n    public interface IUser : IClients { }\r\n```\r\n\r\nCaller implemetation:\r\n```cs\r\n    public abstract class Clients : Grain, IClients\r\n    {\r\n        // Here \"this\" is passed in the parameter.\r\n        // This method can be called by dedrived grain classes,\r\n        // like UserGrain, GroupGrain.\r\n        protected Task AddAsync(string connectionId)\r\n        {\r\n            return GrainFactory.GetGrain<IClient>(connectionId).OnAddAsync(this);\r\n        }\r\n    }\r\n\r\n    public class Group : Clients, IGroup { }\r\n\r\n    public class User : Clients, IUser { }\r\n```\r\n\r\nReceiver:\r\n```cs\r\n    public interface IClient : IGrainWithStringKey\r\n    {\r\n        Task OnAddAsync(IClients clients);\r\n    }\r\n\r\n    public class Client : Grain, IClient\r\n    {\r\n        public async Task OnAddAsync(IClients clients)\r\n        {\r\n            // // here it is, how to get its grain interface type?\r\n            switch (clients)\r\n            {\r\n                case IGroup group:\r\n                    // Do sth\r\n                    break;\r\n                case IUser user:\r\n                    // Do sth\r\n                    break;\r\n            }\r\n            await Task.CompletedTask;\r\n        }\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5256/comments",
    "author": "slango0513",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-12-27T18:40:11Z",
        "body": "A grain reference is a proxy object. It loses some type fidelity relative to the target grain class when passed as a parameter because it is disconnected from the actual target type. So it doesn't support quite what you are trying to do here."
      },
      {
        "user": "slango0513",
        "created_at": "2018-12-29T02:30:06Z",
        "body": "Clear, thank you for your reply."
      }
    ]
  },
  {
    "number": 5189,
    "title": "Question: Can an IGrainService or IGrainServiceClient be called from an Orleans Client?",
    "created_at": "2018-11-22T08:53:52Z",
    "closed_at": "2018-12-12T02:10:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5189",
    "body": "Can an IGrainService or IGrainServiceClient be called from an Orleans Client or is it only accessible within a silo?\r\n\r\nCan I get a handle to an IGrainService via clusterClient.GetGrain<T>?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5189/comments",
    "author": "jsukhabut",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-11-27T23:10:09Z",
        "body": "`GrainServiceClient` depends on `IConsistentRingProvider` (for mapping to silos) that is only available in a silo. So the only way to invoke a grain service is from within a silo."
      }
    ]
  },
  {
    "number": 5182,
    "title": "Message broadcasting",
    "created_at": "2018-11-19T13:44:44Z",
    "closed_at": "2018-11-30T18:23:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5182",
    "body": "Normally when a message is published into a stream is received by one grain that as subscribed that stream.\r\nThere is any stream provider that does broadcasting to all grain that has subscribed that channel ?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5182/comments",
    "author": "matteofabbri",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-11-27T22:56:21Z",
        "body": "All grains subscribed to a stream receive every event published to the stream. Is that not what you are seeing?"
      },
      {
        "user": "matteofabbri",
        "created_at": "2018-11-30T18:23:35Z",
        "body": "Thanks a lot "
      }
    ]
  },
  {
    "number": 5179,
    "title": "How to deal with the relationship between the gateway and transmission entity？",
    "created_at": "2018-11-18T04:19:04Z",
    "closed_at": "2018-12-12T02:12:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5179",
    "body": "Main Silo (gateway) seems to be quoted all transport entities, or the gateway will throw an exception.\r\n`Fail: Orleans.Runtine.Messaging. IncomingMessageAcceptor[101027]ProcessReceivedBuffer exception with RemoteEndPoint 10.10.10.140:1886: System.TypeAccessException: Named type \"Entity.GoodsEntity\" is invalid: Type str ing \"Entity.GoodsEntity\" t be resolued.`\r\nIf so, in the development, each time a colleague modify transport entities to restart gateway?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5179/comments",
    "author": "2821840032",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-11-27T22:54:44Z",
        "body": "Every time you add a new type or change an existing one that can be sent over the wire, you need to make both sides aware of it. Hence, restarting of the running gateway is needed. If I understood your question corretly."
      }
    ]
  },
  {
    "number": 5177,
    "title": "Expected request rate to OrleansSilos table",
    "created_at": "2018-11-15T14:34:06Z",
    "closed_at": "2019-02-05T00:45:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5177",
    "body": "What rate/volume of requests can be expected to the OrleansSilos table?\r\n\r\nContext:\r\nWe have a dev environment setup using DynamoDB for primary storage and for clustering. We are using default grain membership configuration. To save costs we have the provisioning limit set very low. We observed that with only a few users hitting the system we were hitting throttling on read requests to the OrleansSilos table.\r\nOne thing that might be impacting our workload is using `IManagementGrain` on a regular basis.\r\n\r\nWe can certainly increase the provisioning, but are a bit concerned about how those accesses might scale.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5177/comments",
    "author": "jsteinich",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-11-27T20:11:44Z",
        "body": "In a stable state, each silo should touch the cluster membership table only once a minute (by default)."
      },
      {
        "user": "jsteinich",
        "created_at": "2018-11-27T23:46:53Z",
        "body": "Thanks for the response. I'm pretty sure the issue is our use of the management grain to implement a sudo transaction hook while we are waiting for the 2.2 transaction changes."
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-11-28T01:23:17Z",
        "body": "Please close the issue when you confirm that, so that you can reopen it later if needed."
      },
      {
        "user": "jsteinich",
        "created_at": "2019-02-05T00:45:22Z",
        "body": "Usage has stabilized since removing that hook."
      }
    ]
  },
  {
    "number": 5147,
    "title": "Unexpected token 'Error' introducing type specifier when calling grain method. ",
    "created_at": "2018-10-30T12:41:33Z",
    "closed_at": "2018-10-31T15:17:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5147",
    "body": "Hi! Im getting\r\n\"Unexpected token 'Error' introducing type specifier \" every time when i call method Recieve on my grain  which have following signature:\r\n\r\n```\r\nTask Recieve(IEnumerable<GrainsInterfaces.EventData> messages)\r\n\r\npublic class EventData\r\n    {\r\n        public ArraySegment<byte> Body { get; set; }\r\n\r\n        public IDictionary<string, object> Properties { get; set; }\r\n\r\n        public SystemPropertiesCollection SystemProperties { get; set; }\r\n\r\n        public sealed class SystemPropertiesCollection : Dictionary<string, object>\r\n        {\r\n            public long SequenceNumber { get; set; }\r\n\r\n            public DateTime EnqueuedTimeUtc { get; set; }\r\n\r\n            public string Offset { get; set; }\r\n\r\n            public string PartitionKey { get; set; }\r\n        }\r\n    }\r\n```\r\n\r\nGrain has  [StatelessWorker] and [Reentrant] attributes.\r\n\r\nOther method, which has simplier signature:\r\n\r\n Task<string> SayHello(string greetings) works ok.\r\n\r\nDo you know what can cause this? Is there any limitation if comes to data contract? ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5147/comments",
    "author": "darthkurak",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-10-30T17:59:36Z",
        "body": "`IEnumerable<T>` is not supported as an argument or return type because it is evaluated lazily. Try using `IList<T>` or something like that instead."
      },
      {
        "user": "darthkurak",
        "created_at": "2018-10-31T08:55:19Z",
        "body": "Works now, thanks! "
      }
    ]
  },
  {
    "number": 5138,
    "title": "Does Orleans fit my case?",
    "created_at": "2018-10-26T10:20:31Z",
    "closed_at": "2018-10-26T17:21:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5138",
    "body": "Hello friends,\r\n\r\nsorry for posting a question here. I'd like to ask for some suggestions for my scenario and check if Orleans is a good fit for it. \r\nI have a bunch (about 30000-70000) of processing to perform and would like to split this among 5 high spec computers we have (16 processors, 32GB RAM and SSD each).  The processing consists of creating a small input text file and send it to a 3rd party app that process it and return a string as result. This 3rd party app can eat some CPU, sometimes it can take 1-3 seconds to process the input.\r\nSo the idea would be to create a Job list, dispatch this and get the result as its happens. \r\n\r\nDo you thing Orleans is a good pick for this or would you recommend something else?\r\n\r\nThank you ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5138/comments",
    "author": "quicoli",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-10-26T16:08:41Z",
        "body": "Not need to apologize. This is a 100% appropriate question to ask.\r\n\r\nI think Orleans is *a* way to build the system you described. It would help you easily run processing on those 5 nodes, especially if at some point you'll need to coordinate processing of different jobs.\r\n\r\nAt the same time, there are other ways to divide processing of a batch of jobs, statically or dynamically, among 5 nodes. So it is hard to tell if Orleans is a better approach here without knowing more detailed requirements and having an idea how they might evolve in the future. But I don't see anything wrong with using Orleans here based on the information you provided."
      },
      {
        "user": "quicoli",
        "created_at": "2018-10-26T17:21:00Z",
        "body": "Thank you very much @sergeybykov  👍 \r\n"
      }
    ]
  },
  {
    "number": 5125,
    "title": "System.InvalidOperationException : No default ITransactionalStateStorageFactory nor IGrainStorage was found while attempting to create transactional state storage.",
    "created_at": "2018-10-24T02:17:05Z",
    "closed_at": "2021-11-18T05:00:59Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5125",
    "body": "var builder = new SiloHostBuilder()\r\n                .Configure<ClusterOptions>(options =>\r\n                {\r\n                    options.ClusterId = \"dev\";\r\n                    options.ServiceId = \"fiiipay\";\r\n                })\r\n                .UseLocalhostClustering()\r\n                .Configure<EndpointOptions>(options => options.AdvertisedIPAddress = IPAddress.Loopback)\r\n                .ConfigureApplicationParts(parts =>\r\n                {\r\n                    parts.AddApplicationPart(typeof(HelloGrain).Assembly).WithReferences();\r\n                })\r\n                .AddAdoNetGrainStorage(\"store0\",configureOptions =>\r\n                {\r\n                    configureOptions.ConnectionString =\r\n                        \"Data Source=.;Database=FiiiPay.Account;Integrated Security=True;Pooling=False;Max Pool Size=200;\";\r\n                    configureOptions.Invariant = \"System.Data.SqlClient\";\r\n                })\r\n                .AddAdoNetGrainStorage(\"store1\",configureOptions =>\r\n                {\r\n                    configureOptions.ConnectionString =\r\n                        \"Data Source=.;Database=Test;Integrated Security=True;Pooling=False;Max Pool Size=200;\";\r\n                    configureOptions.Invariant = \"System.Data.SqlClient\";\r\n                })\r\n                .UseTransactions(); \r\nthis is my host code",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5125/comments",
    "author": "zhaoqinghai",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-10-26T16:20:33Z",
        "body": "For `.UseTransactions()` to work, you need to add a transactional state provider - one that implements `ITransactionalStateStorage<TState>`. `AddAdoNetGrainStorage` doesn't do that. We currently have a provider for Azure Table that you can add with `AddAzureTableTransactionalStateStorage()`. Alternatively, you can create and add your own provider."
      },
      {
        "user": "jason-bragg",
        "created_at": "2018-10-26T18:01:59Z",
        "body": "The transactional state storage will fallback to a configured grain state storage if no TransactionalStateStorage is found and a grain state store of the same name is found.  Your configuration does seem to have two grain state storages, \"store0\" and \"store1\", so if either of those are referenced in the transaction facet attribution, it should use them.  The fact that the error message mentions no 'default' indicates that the attribution has no storage specified so it looks for a store called 'default'.  If you want to keep the attribution the way it is, you can also add a grain state store named 'default', which will be used."
      },
      {
        "user": "jason-bragg",
        "created_at": "2018-10-26T18:17:00Z",
        "body": "As a side note about the 'fallback' behavior, the usage patterns needed by transactional storage differ from those needed by grain storage, that's why we have a different abstraction.  While we've bridged the two to allow transactions to be used with any grains state storage, storage specific implementations of ITransactionalStateStore will likely perform better than a bridged grain state storage."
      },
      {
        "user": "zhaoqinghai",
        "created_at": "2018-10-27T09:51:55Z",
        "body": "thank you, i want to use muti database by sqlserver, how i configure my silohostbuilder? i worry one database it will slow performance when data item arrive so much"
      },
      {
        "user": "ghost",
        "created_at": "2021-11-18T05:00:57Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 5118,
    "title": "gossip channels across Azure availability zones?",
    "created_at": "2018-10-22T17:14:51Z",
    "closed_at": "2019-03-04T20:17:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5118",
    "body": "What are the requirements for the gossip channel(s) to work correctly?\r\n\r\nWith Azure now having 3+ \"Availability Zones\" per region, is multi-cluster support needed for silos to span zones, or would these inter-zone hops be low enough latency to form a single cluster across zones within a single region?\r\n\r\nAny thoughts on hierarchical partitioning/silo-affinity (\"within zone, across zones, across regions\", for example)? Is it done anywhere, or considered for Orleans? Or does existing multi-cluster support in Orleans already cover every conceivable scenario?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5118/comments",
    "author": "danvanderboom",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-10-30T18:14:04Z",
        "body": "This is an interesting question. I suspect, it might be worthwhile to try running a single cluster spanning multiple availability zones within a region. That would be simpler than setting up a multi-cluster. Presumably, network reliability and latency should be pretty close to a single datacenter case."
      }
    ]
  },
  {
    "number": 5079,
    "title": "is it possible to prevent timers from starting?",
    "created_at": "2018-10-08T14:23:15Z",
    "closed_at": "2019-03-04T20:16:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5079",
    "body": "We have a case where we shut all silos down at once and start them again.\r\nthis is mainly when we need to rollback to a previous version or perform an upgrade that is not possible as a rolling upgrade (like upgrading to orleans 2.0).\r\n\r\nwhat we see is we have a lot of reminders ticking just as soon as some silos become available and therefore have a lot of stuff happening before we are ready for it.\r\nthis also causes most of the activations to go on the first silo that was ready, then we have to restart that one to rebalance the activations.\r\n\r\nwhat do you suggest doing?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5079/comments",
    "author": "talarari",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-10-08T16:56:02Z",
        "body": "What is driving most of the load on the cluster? Is it reminders or client requests?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-11-08T00:10:08Z",
        "body": "Sorry about delayed response.\r\n\r\nI can't think of a way currently to prevent reminders from starting right away. We probably need to add something here. The options I see are:\r\n\r\n- Configurable delay of starting the Reminder Service from silo start, with a default to, say, 5 minuets.\r\n- Configurable delay but from the last cluster state change (to wait until other silos join the cluster).\r\n- Configurable number or percentage of silos to join the cluster before starting the Reminder Service."
      }
    ]
  },
  {
    "number": 5048,
    "title": "Slow access to Azure Table \"OrleansReminders\" for \"ReadTableEntriesAndEtags\", which took 00:00:03.0158598",
    "created_at": "2018-10-01T09:03:34Z",
    "closed_at": "2018-10-04T19:09:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5048",
    "body": "Where is a problem in case of these warnings:\r\n`\r\nSlow access to Azure Table \"OrleansReminders\" for \"ReadTableEntriesAndEtags\", which took 00:00:03.0158598.\r\n`\r\n\r\n`\r\nSlow access to Azure queue \"xxx-app-appeventsstreamprovider-6\" for \"GetQueueMessages\", which took 00:00:04.1207254. \r\n`\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5048/comments",
    "author": "ifle",
    "comments": [
      {
        "user": "rmja",
        "created_at": "2018-10-01T12:28:43Z",
        "body": "Are you using the storage emulator? I am getting this warning a-lot when using the emulator. It is incredibly slow."
      },
      {
        "user": "ifle",
        "created_at": "2018-10-01T14:03:51Z",
        "body": "No, this is from production environment"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-10-02T02:36:51Z",
        "body": "If you only see them occasionally, they may simply indicate occasional delay response from Azure Storage. If you see them consistently, I would check that the .NET thread pool isn't overloaded (which can delay execution of storage call responses)."
      },
      {
        "user": "ifle",
        "created_at": "2018-10-02T18:52:38Z",
        "body": "I only see them occasionally"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-10-04T18:24:08Z",
        "body": "@ifle I think then there's nothing on the Orleans side we can do here. Should we close this issue?"
      },
      {
        "user": "ifle",
        "created_at": "2018-10-04T19:09:30Z",
        "body": "Yes, thanks"
      }
    ]
  },
  {
    "number": 5013,
    "title": "How to write a client in .NET Standard 2.0 that can connect to old v1.5 server?",
    "created_at": "2018-09-21T13:06:29Z",
    "closed_at": "2018-10-04T18:22:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5013",
    "body": "I have an old Orleans v1.5 cluster which cannot be updated to v2 ATM.\r\n\r\nI'm writing an Azure Function v2 which is a .NET Standard 2.0 application.\r\n\r\nThis applications needs an Orleans Client to connect to the old cluster. Unfortunately, the latest available client library (NuGet: Microsoft.Orleans.Client 1.5.5) does not work with .NET Standard 2.0 (there is an issue with dependency injection described in #3325).\r\n\r\nI tried using the latest v2 client (NuGet: Microsoft.Orleans.Client 2.0.3), but it is obviously not compatible with old cluster, since it fails with an exception during connection:\r\n\r\n``\r\nNotImplementedException\r\nOrleans: interfaceId=-1666714017,methodId=1041119701.\r\n``\r\n\r\nIs there some workaround (legacy mode?) to make new client work with old server? There was a fix that would make the old client work with .NET Standard 2.0 (issue #3356) but it was never implemented into 1.5 branch.\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5013/comments",
    "author": "expertsender-marcinsynak",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-09-21T15:46:11Z",
        "body": "No easy workaround I'm afraid other than maybe running a 1.5.5 client as a separate process and marshalling commands to and responses from it."
      },
      {
        "user": "expertsender-marcinsynak",
        "created_at": "2018-09-24T13:51:16Z",
        "body": "That's what I was afraid of.\r\n\r\nFor now, we've decided to write a simple web proxy. Instead of calling grains directly, we make HTTP calls. The proxy performs grain operations and returns JSON.\r\nMost of our grains are used to gather and return information when needed so it should be enough."
      }
    ]
  },
  {
    "number": 5009,
    "title": "Can a Grain subscribe to multiple streams at the same time?",
    "created_at": "2018-09-20T18:54:00Z",
    "closed_at": "2018-11-07T23:52:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5009",
    "body": "Hi, I've been trying to use Explicit Streams and have 2 separate clients calling the grain's method to subscribe to different streams. However, when the 2nd client is trying to have the grain subscribe to a second stream (after it subscribed to a different stream), nothing happens. No errors, no exceptions or anything. Can grains subscribe to multiple different streams at the same time (assuming all the OnNextAsync() are stubbed out)?.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5009/comments",
    "author": "TulkasLaugh",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-09-20T19:55:30Z",
        "body": "Yes, a grain can subscribe to multiple streams at the same time."
      },
      {
        "user": "TulkasLaugh",
        "created_at": "2018-09-20T20:25:45Z",
        "body": "My ultimate goal is to have a client input a List of Items into a stream. A QueueGrain that subscribes to that stream takes that input and then assign a set number of WorkerGrains to work on the items. I want WorkerGrains to inform QueueGrain that it is finished so that more Items can be assigned to WorkerGrains as they free up. \r\n\r\nI have the client getting a QueueGrain and then invoke its method SubscribeToQueueStream() to make the Grain subscribe to its specific stream and the WorkerGrain that the QueueGrain made to do work would get the QueueGrain after it's done doing work and invoke its method SubscribeToCompletionStream() to make QueueGrain subscribe to a different stream in order to be notified that the work is done. It just hangs though when WorkerGrain tries to get QueueGrain to subscribe to that stream.\r\n\r\nIs there anything obviously wrong with what I'm trying to do to cause things to hang?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-09-21T22:40:05Z",
        "body": "It's not 100% clear to me how you organized that. Make sure that you don't have call cycles between those grains: grain A calling grain B which while executing the call calls A. It shouldn't be happening is you are using streams, unless you are using the SMS provider."
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-10-04T18:22:06Z",
        "body": "@TulkasLaugh Any update?"
      }
    ]
  },
  {
    "number": 4985,
    "title": "Durability Guarantees",
    "created_at": "2018-09-14T04:57:53Z",
    "closed_at": "2018-10-04T18:17:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4985",
    "body": "When I save the actor state what are the durability guarantees?  How long before that data is actually persisted?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4985/comments",
    "author": "AceHack",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2018-09-14T05:09:50Z",
        "body": "@AceHack the data is saved immediately - it's durable by the time `WriteStateAsync()` returns. Of course, that's also contingent on the storage provider you're using (eg, the memory storage provider is not durable at all). All of the storage providers that I know operate in this way. Certainly, all of the storage providers we maintain do."
      }
    ]
  },
  {
    "number": 4975,
    "title": "Using streams with RabbitMQ",
    "created_at": "2018-09-12T19:46:14Z",
    "closed_at": "2019-07-12T20:57:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4975",
    "body": "Hi, I'm learning about Streams and am interested in using it together with a message queuing system like RabbitMQ. My use case can have potentially a large number of requests and I want to be able to implement throttling (such as limiting the number of Grains that are doing work at a time) and work priority. My use case is similar to a cloud base Borg Hivemind trying to conquer the universe.\r\n\r\nI was thinking to have a master queue like RabbitMQ hold all the tasks that a Borg unit would do and a large number of BorgUnitGrain would subscribe to and perform tasks listed in the RabbitMQ master queue as they receive them. \r\n\r\nI want to be able to control concurrency and throttling on a per planet basis for assimilation, so multiple planets could be marked, but I only want a set number of BorgUnitGrains to be working on a planet at a time. I was thinking that I can control concurrency by having an orchestrator control what tasks get pushed onto RabbitMQ to be divided up by the BorgUnitGrains. Do you guys have any recommendations for what I'm trying to do?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4975/comments",
    "author": "TulkasLaugh",
    "comments": [
      {
        "user": "xiazen",
        "created_at": "2018-09-17T20:14:54Z",
        "body": "Sounds like a cool use case, but I will need more information before I can give suggestions :) \r\n\r\nAre you planning to build a stream provider on top of RabbitMQ or do you want to use our existing stream provider with RabbitMQ somehow? \r\n\r\n\r\nYou mentioned throttling, limiting number of grains doing work at a time. Is this streaming specific or is it just in general you want maximum X amount of grain running in the cluster? \r\n\r\n> I want to be able to control concurrency and throttling on a per planet basis for assimilation\r\n\r\nwhat is a planet in this case, a queue, a silo? \r\n"
      },
      {
        "user": "TulkasLaugh",
        "created_at": "2018-09-18T14:32:13Z",
        "body": "I want to use the existing Simple Stream Provider but I was under the impression that RabbitMQ might be needed. The planet would be a queue. I want in general maximum X amount of grain running in a cluster. However, I want to divy up those grains appropriately to the correct planet as work for the planet comes in or new planets get marked. \r\n\r\nLet me run through a scenario.\r\n\r\nThe Borg mark Planet A for assimilation, it's determined that 2,000 BorgUnitGrain should be working on it at a time and overall there are 20,000 BorgUnitGrain available in the pool of resources (number of grains that could be simultaneously running at a time amongst all the silos I have). I give 10,000 tasks that need to be done for Planet A, I want a PlanetQueueGrain to only send 2,000 tasks at a time to be worked on by the BorgUnitGrain (which would update PlanetQueueGrain for when a task is completed). \r\n\r\nA new Planet B is marked for assimilation, 8,000 BorgUnitGrains should be working on the assimilation tasks at at time and I also mark Planet C for assimilation and I want 12,000 BorgUnitGrains to be working on assimilation tasks at a time. 50,000 tasks are given to Planet B to be worked on and 100,000 are given to Planet C to be worked on. \r\n\r\nSo I'm hoping to achieve 1 master stream, 20,000 BorgUnitGrains listening in on it and I control concurrency through PlanetQueueGrain only feeding a certain number of tasks at a time to be processed."
      },
      {
        "user": "xiazen",
        "created_at": "2019-03-18T22:11:33Z",
        "body": "By the look of it. I think it look more like a StatelessWorker scenario if no state is needed, or a general grain scenario. Since each BorgUnitGrain is going to work on a different task, which is distributed by the PlanetGrain. And there's no specialization difference between BorgUnitGrains, meaning they are identical in code. So to me, you just need a PlanetGrain constantly give task to available BorgUnitGrain in the pool (the 2000 BorgUnitGrain which is assigned to this task), and hang idle when no BorgUnitGrain available. In other words, it is more like a AsyncPipeLine use case applied to grains. \r\n\r\nI don't see many streaming traits in your scenario, but I maybe wrong. To me, streaming is needed when each consumer want to consume the same stream of tasks, but want to apply different processing to the tasks. Or each BorgUnitGrain has different specialization, so different type of BorgUnitGrain consume a different stream of a specific type of task, and do their own unique processing on the tasks. Neither of the two cases looks like your scenario. I'm not saying that's the only two cases which you should use stream with, but just listing the first two popped into my mind as an example. But I cannot wrap my head around why your scenario needs streaming, which is what I want to convey with my examples. \r\n\r\nAnd sorry for the late update. Has been busy. "
      },
      {
        "user": "xiazen",
        "created_at": "2019-07-12T20:57:08Z",
        "body": "close due to issue being months old. Hope I helped :) "
      }
    ]
  },
  {
    "number": 4960,
    "title": "Question about 2.0 ChatRoom example",
    "created_at": "2018-09-10T18:13:23Z",
    "closed_at": "2018-09-11T16:40:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4960",
    "body": "How can the Channel grain detect when a user disconnects/closes the Client app in order to remove them from the onlineMembers list?\r\n\r\nI know the client can leave the channel, but I wanted to know of a more reliable way to detect this since if a client just closes the app without leaving the channel, the user remains in the onlineMembers list indefinitely.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4960/comments",
    "author": "snarlynarwhal",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-09-11T00:44:11Z",
        "body": "Without client explicitly removing itself from the list, the Channel grain can implement a time-based expiration policy to remove registered clients if they don't rejoin periodically."
      },
      {
        "user": "snarlynarwhal",
        "created_at": "2018-09-11T00:50:55Z",
        "body": "Ahh okay thank you."
      }
    ]
  },
  {
    "number": 4908,
    "title": "ManagementGrain.ForceActivationCollection with zero ageLimit causes undesired effects",
    "created_at": "2018-08-29T07:50:01Z",
    "closed_at": "2021-12-30T05:00:57Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4908",
    "body": "Calling ManagementGrain.ForceActivationCollection(TimeSpan.Zero) collects every grain, including system grains and the ManagementGrain itself. Which effectively almost restarts the silo and causes the said grain call to timeout.\r\n\r\nShouldn't this exclude some grains (management grain, pubsub, etc.)? or at least make the TimeSpan.Zero value an invalid one? \r\n\r\nI can't think of a scenario where current behavior would be useful.\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4908/comments",
    "author": "alirezajm",
    "comments": [
      {
        "user": "alirezajm",
        "created_at": "2018-09-17T06:17:12Z",
        "body": "@benjaminpetit any word on this?"
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-09-17T07:31:04Z",
        "body": "I'm not convinced that we should be doing anything to prevent the user from calling with a zero or very short timespan.\r\n\r\nIf you'd like to submit a PR to implement a minimum value, then please feel free. I wouldn't be opposed to merging it.\r\n\r\nSome grains are already excluded from activation collection, so we could add a mechanism to exclude more grains or to exclude them more generally (eg an attribute, like the recently added attribute in #4890). I would be wary of a general mechanism, though, since it's an anti-pattern to have activations live forever."
      },
      {
        "user": "alirezajm",
        "created_at": "2018-09-18T14:30:38Z",
        "body": "> I'm not convinced that we should be doing anything to prevent the user from calling with a zero or very short timespan.\r\n> \r\n> If you'd like to submit a PR to implement a minimum value, then please feel free. I wouldn't be opposed to merging it.\r\n\r\nYeah it's not a big deal at all. It's just that you can't predict what will happen. \r\n\r\n>Some grains are already excluded from activation collection\r\nAre the ManagementGrain and the SiloGrain included in that exclusion? 🤔  If so I might have made a mistake about the managementGrain itself being collected (which was weird as how can it be collected while processing a call). \r\n\r\nAgreed about the anti-pattern but there are already some grains breaking that pattern. I personally haven't felt the need for that though. There were times I though about it but I could solve the issue another way. if interested I can tell you an example."
      },
      {
        "user": "ghost",
        "created_at": "2021-12-30T05:00:55Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 4885,
    "title": "What kind of scenario will the SiloName of the two nodes be the same?",
    "created_at": "2018-08-24T16:31:08Z",
    "closed_at": "2018-09-12T03:30:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4885",
    "body": "When I read the code, I saw the following code, from `Orleans.Runtime.MembershipService.MembershipOracle`.\r\n```csharp\r\nprivate async Task DetectNodeMigration(string myHostname)\r\n{\r\n    MembershipTableData table = await membershipTableProvider.ReadAll();\r\n\r\n    string mySiloName = SiloName;\r\n    MembershipEntry mostRecentPreviousEntry = null;\r\n    foreach (MembershipEntry entry in table.Members.Select(tuple => tuple.Item1).Where(data => mySiloName.Equals(data.SiloName)))\r\n    {\r\n        bool iAmLater = MyAddress.Generation.CompareTo(entry.SiloAddress.Generation) > 0;\r\n        // more recent\r\n        if (iAmLater && (mostRecentPreviousEntry == null || entry.SiloAddress.Generation.CompareTo(mostRecentPreviousEntry.SiloAddress.Generation) > 0))\r\n            mostRecentPreviousEntry = entry;\r\n    }\r\n\r\n    if (mostRecentPreviousEntry != null)\r\n    {\r\n        bool physicalHostChanged = !myHostname.Equals(mostRecentPreviousEntry.HostName) || !MyAddress.Endpoint.Equals(mostRecentPreviousEntry.SiloAddress.Endpoint);\r\n        if (physicalHostChanged)\r\n        {\r\n            string error = String.Format(\"Silo {0} migrated from host {1} silo address {2} to host {3} silo address {4}.\",\r\n                mySiloName, myHostname, MyAddress.ToLongString(), mostRecentPreviousEntry.HostName, mostRecentPreviousEntry.SiloAddress.ToLongString());\r\n            logger.Warn(ErrorCode.MembershipNodeMigrated, error);\r\n        }\r\n        else\r\n        {\r\n            string error = String.Format(\"Silo {0} restarted on same host {1} New silo address = {2} Previous silo address = {3}\",\r\n                mySiloName, myHostname, MyAddress.ToLongString(), mostRecentPreviousEntry.SiloAddress.ToLongString());\r\n            logger.Warn(ErrorCode.MembershipNodeRestarted, error);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis code first reads all the columns of the member table, then select the entry with the same silo name as the current node.\r\nBut according to the code, SiloName is generated by GUID.\r\nSo how can there be the same SiloName? Or what is the `DetectNodeMigration` method used to handle?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4885/comments",
    "author": "buzzers",
    "comments": [
      {
        "user": "benjaminpetit",
        "created_at": "2018-08-28T16:21:52Z",
        "body": "It's used to detect that a silo rebooted, or the silo migrated from one VM to another. You should be able to put your own `SiloName` if needed.\r\n\r\nWhen a new silo tries to join a cluster, it will try to connect to all silos in the cluster, to validate connectivity.\r\n\r\nSo this check tries to find a previous instance of the new silo. If the previous instance was killed ungracefully, the new instance is able to update its previous state to `Dead` in the membership table and start normally, without trying to connect to the `Dead` entry.\r\n\r\n\r\n"
      },
      {
        "user": "buzzers",
        "created_at": "2018-09-04T03:44:36Z",
        "body": "OK, I get it. That is, if a completely new instance is started, then the code here is not going to work, is it?"
      },
      {
        "user": "benjaminpetit",
        "created_at": "2018-09-05T08:04:42Z",
        "body": "Correct"
      }
    ]
  },
  {
    "number": 4828,
    "title": "Questions about the order of method calls ",
    "created_at": "2018-08-08T17:13:04Z",
    "closed_at": "2021-11-18T05:01:08Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4828",
    "body": "Hi, \r\n\r\nI am working on a stream processing system which might be sensitive to the orders of the method calls between grains. If I call an async method which sends messages from A to B multiple times, will the messages are processed in order? \r\n\r\nThanks!\r\n\r\n ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4828/comments",
    "author": "w14525555",
    "comments": [
      {
        "user": "jason-bragg",
        "created_at": "2018-08-08T18:01:30Z",
        "body": "If you do not await each message prior to sending the next, the messages can arrive out of order, especially under error conditions.\r\n\r\nIf you can't afford to await each message, due to performance reasons, I'd suggest batching all of the request into a single grain call, queuing up new messages while that grain call is pending, and then sending the next batch once the call returns."
      },
      {
        "user": "w14525555",
        "created_at": "2018-08-08T18:12:46Z",
        "body": "@jason-bragg Thanks for your answer! You are right. We cannot use await due to performance issues. Is the solution that you mentioned the only way to solve this problem? It seems it still needs use await to wait a batch. "
      },
      {
        "user": "ghost",
        "created_at": "2021-11-18T05:01:06Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 4822,
    "title": "Which code files are maintained for memberships tables and grain directory tables?",
    "created_at": "2018-08-07T14:35:42Z",
    "closed_at": "2018-08-16T09:10:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4822",
    "body": "  I'm studying the implementation of Orleans, but I've found that I can't find the specific maintenance code for the memberships table and the grain directory table. Including the entry of members, normal exit and abnormal exit, Grain activation and deactivation, and node failure when the table recovery operations.\r\n\r\n  Could you tell me which files are the specific implementation codes of these operations?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4822/comments",
    "author": "buzzers",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-08-13T18:27:39Z",
        "body": "Did you inside the following folders?\r\n\r\n`src\\Orleans.Runtime\\MembershipService`\r\n`src\\Orleans.Runtime\\GrainDirectory`\r\n\r\nIs that not what you are looking for?"
      },
      {
        "user": "buzzers",
        "created_at": "2018-08-14T10:01:11Z",
        "body": "I also read the code under these two folders, but I didn't know where the remote request was received and caused the two services to be invoked."
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-08-16T02:34:19Z",
        "body": "Take a look at `MembershipOracle` and `RemoteGrainDirectory` classes."
      },
      {
        "user": "buzzers",
        "created_at": "2018-08-16T09:10:27Z",
        "body": "Thank you.\r\nI use Visual Studio to do single step tracing to study the code. There is a clue. Thank you for your reply."
      }
    ]
  },
  {
    "number": 4708,
    "title": "What happens if I don't await an async operation",
    "created_at": "2018-06-23T17:59:22Z",
    "closed_at": "2018-07-13T07:32:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4708",
    "body": "We're using a timeout for slow storage request, but since the built in blob storage provider doesn't expose any time out configuration we just stop waiting for the task to complete instead of canceling it (basically racing it with a timeout task, we're using Polly's pessimistic timeout for this).\r\n\r\nWhat effect does something like that have in Orleans?\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4708/comments",
    "author": "talarari",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2018-07-05T22:10:24Z",
        "body": "It's fine to not await a storage call from the grain's perspective. Just be sure that you call `.Ignore()` on the result so that it does not bubble up to the UnobservedTaskException handler.\r\n\r\nAs soon as you return from the async grain method (or the task returned from the grain method completes), other messages can be processed and they will be interleaved on the activation's task scheduler with the new message.\r\n\r\nOne issue that may come up is that the interleaving of calls may result in inconsistent state exceptions. To guard against that, you can put your writes to storage behind an AysncLock (you can find implementations of such a lock in the Nito.AsyncEx library or in online articles, or in the Orleans codebase - but that one is not publicly exposed)."
      },
      {
        "user": "talarari",
        "created_at": "2018-07-13T07:32:54Z",
        "body": "We ended up copying over the blob storage provider code and adding a timeout with cancellation token. Thanks."
      }
    ]
  },
  {
    "number": 4705,
    "title": "Server Core OS support",
    "created_at": "2018-06-22T11:21:18Z",
    "closed_at": "2018-06-22T11:24:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4705",
    "body": "Hi,\r\n\r\nI can't find a list of supported operating systems in any documentation.  Is Orleans supported running on Server 2016 Core?  My assumption is it is but wanted confirmation.\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4705/comments",
    "author": "MatthewFawcett",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2018-06-22T11:23:16Z",
        "body": "@jjjurrb as long as it can run .NET Core then it can run Orleans"
      },
      {
        "user": "MatthewFawcett",
        "created_at": "2018-06-22T11:24:35Z",
        "body": "I'll take that as a yes 👍   Thanks."
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-06-22T11:25:42Z",
        "body": "Yes, sorry, I should have been more clear 😊"
      }
    ]
  },
  {
    "number": 4701,
    "title": "Clear the data generated by PubSubRendezvousGrain",
    "created_at": "2018-06-20T14:19:45Z",
    "closed_at": "2018-07-02T23:15:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4701",
    "body": "I use: \r\n`AddSimpleMessageStreamProvider`\r\n`AddAdoNetGrainStorage`\r\n\r\n1、When I generate Guid different, PubSubRendezvousGrain generates a lot of data, is there a function to clear them?\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4701/comments",
    "author": "lfzm",
    "comments": [
      {
        "user": "HermesNew",
        "created_at": "2018-06-21T07:27:00Z",
        "body": "I have the same question.\r\nHow to remove the data from the table storage？"
      },
      {
        "user": "lfzm",
        "created_at": "2018-06-21T07:41:57Z",
        "body": "@jason-bragg By setting it as invisible, there will not be a large amount of data, if you need to use explicit cancellation to delete the database data\r\n\r\n```\r\n.AddMemoryGrainStorage(\"PubSubStore\")\r\n                .AddSimpleMessageStreamProvider(\"SimpleStreamProvider\", (SimpleMessageStreamProviderOptions opt) =>\r\n                {\r\n                    opt.FireAndForgetDelivery = true;\r\n                    opt.OptimizeForImmutableData = true;\r\n                    opt.PubSubType = Streams.StreamPubSubType.ImplicitOnly;\r\n                });\r\n```"
      },
      {
        "user": "xiazen",
        "created_at": "2018-06-22T23:38:36Z",
        "body": "Hi, If you want to clear up old subscription data which isn't needed anymore, you can call `IStreamSubscriptionManager` to remove those subscription"
      },
      {
        "user": "xiazen",
        "created_at": "2018-07-02T23:15:10Z",
        "body": "close due to inactivity. Feel free to reopen if needed"
      }
    ]
  },
  {
    "number": 4700,
    "title": "Grain Disambiguation",
    "created_at": "2018-06-19T22:04:19Z",
    "closed_at": "2018-06-20T07:07:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4700",
    "body": "I am working on the project that some grain implementations inherit from an abstract grain implementation . \r\nSome just like this:\r\npublic abstract class A: Grain, IGrainInterface\r\n{\r\nabstract method(); \r\n}\r\n\r\npublic class B: A\r\n{\r\noverride method();\r\n}\r\n\r\npublic class C: A\r\n{\r\noverride method()\r\n}\r\n\r\nIt seems I can use a grainClassNamePrefix to solve this problem, but I haven't found any documents to describe how to use it. \r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4700/comments",
    "author": "w14525555",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-06-19T23:17:45Z",
        "body": "You can pass a fully qualified class name to `GetGrain()` as optional parameter:\r\n```csharp\r\nGetGrain<IGrainInterface>(key, \"your-namespace.B\");\r\nGetGrain<IGrainInterface>(key, \"your-namespace.C\");\r\n```\r\n\r\nor just a prefix of the fully qualified name, if the grain classes are defined in different namespaces:\r\n```csharp\r\nGetGrain<IGrainInterface>(key, \"B-namespace\");\r\nGetGrain<IGrainInterface>(key, \"C-namespace\");\r\n```\r\nThe namespace approach works well for switching between different implementations of multiple grain classes, for example, between test and production."
      },
      {
        "user": "w14525555",
        "created_at": "2018-06-20T06:58:16Z",
        "body": "@sergeybykov It works. Thanks a lot! "
      }
    ]
  },
  {
    "number": 4693,
    "title": "How to get Grain primary key from GrainReference string key",
    "created_at": "2018-06-15T11:33:54Z",
    "closed_at": "2020-01-14T18:58:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4693",
    "body": "Hey,\r\nwe're using azure blob storage for grain state persistence.\r\nall our grains are IGrainWithGuidKey.\r\nWe're investigating storage issues getting lots of 404 errors for blobs.\r\nour problem is the primary key in the grainState table looks like this:\r\nGrainReference=11e798b4058027ec3ea216eb790ad2bf03ffffff810989d7\r\n\r\nhow do we get the grain's primary key from this? i want to be able to troubleshoot this but this grainReference string means nothing to me.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4693/comments",
    "author": "talarari",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2018-06-21T21:37:52Z",
        "body": "@talarari there is a utility method called `Orleans.Runtime.Utils.FromKeyString(string key, IGrainReferenceRuntime runtime)` which I think can help you"
      },
      {
        "user": "ReubenBond",
        "created_at": "2020-01-14T18:58:45Z",
        "body": "Closing - this is answered + inactive"
      }
    ]
  },
  {
    "number": 4634,
    "title": "how do build distrubuted base on orleans framewrok",
    "created_at": "2018-05-29T04:35:38Z",
    "closed_at": "2018-07-12T18:03:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4634",
    "body": "",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4634/comments",
    "author": "bouyeijiang",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-06-08T20:26:55Z",
        "body": "@bouyeijiang Could you provide more details on what you are looking to build with Orleans. Otherwise, it's not clear what you mean by \"distributed base\"."
      },
      {
        "user": "jason-bragg",
        "created_at": "2018-07-12T18:03:43Z",
        "body": "closing due to inactivity.  Please feel free to reopen when more details are available."
      }
    ]
  },
  {
    "number": 4600,
    "title": "Grain activation",
    "created_at": "2018-05-16T16:23:26Z",
    "closed_at": "2018-06-19T16:17:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4600",
    "body": "Hello,\r\nFew queries on grain activation:\r\n\r\n1) Lets assume we have an application deployed in a cluster of three silos. Client connected to a silo and have grain activation with it. And now if that silo goes down for some reason, does orleans framework create entirely new grain activation in other silo? Will grain have new primary key?\r\n2) I have been experimenting explict stream subscription with RabbitMQ. \r\n\r\n\tAnd my application looke likes this:\r\n\t**SILOHOST** \r\n\r\n\t\t\t1.  CommandBusGrain \t\r\n                             1.  OnactivateAsync creates a stream (stream id: GUID.Empty)\r\n                             2.  Register method does subscription to the stream\r\n                             3.  Send method publish message to stream (that is _stream.OnNextAsync(msg))\r\n\t\t\t2.  On silo startup\r\n                             1.  calls CommandBusGrain register method to initiate subscription\r\n\t\t\t\r\n\t\t\t\r\n    **SILO Client**\r\n\r\n\t\t\t1.  Create CommandBusGrain reference (Graind id: GUID.Empty)\r\n\t\t\t2.  Triggers \"Send\" method to publish message.\r\n\r\n\t\t\r\n     This works fine, but I need some suggestion on whether to call grain method to publish message to \r\n     the stream or create stream reference in the client and publish message directly to stream instead of \r\n     calling grain.\r\n     Which one would be a better implementation?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4600/comments",
    "author": "srinathgnath",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-06-08T22:26:27Z",
        "body": "Sorry about delayed response.\r\n\r\n> if that silo goes down for some reason, does orleans framework create entirely new grain activation in other silo? Will grain have new primary key?\r\n\r\nYes, after the cluster learns that the silo went down, a new request to the grain will trigger a new activation of it on one of the remaining silos. The primary keys will stay the same - it's the key that the request was sent for.\r\n\r\n> 1.  OnactivateAsync creates a stream\r\n\r\nWhat is this exactly. Streams are virtual, just like grains. They always exist, and don't need to be created.\r\n\r\n>This works fine, but I need some suggestion on whether to call grain method to publish message to\r\nthe stream or create stream reference in the client and publish message directly to stream instead of\r\ncalling grain.\r\n\r\nPublishing directly from client is more efficient - the message will get written directly to the queue. No need to send it to the grain to be written to the queue from there I think."
      },
      {
        "user": "srinathgnath",
        "created_at": "2018-06-19T16:15:59Z",
        "body": "Thanks "
      }
    ]
  },
  {
    "number": 4588,
    "title": "Why is Microsoft.Orleans.Clustering.ServiceFabric not available for v2.0.0?",
    "created_at": "2018-05-12T17:46:45Z",
    "closed_at": "2018-10-04T21:45:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4588",
    "body": "Why is Microsoft.Orleans.Clustering.ServiceFabric not available for v2.0.0?\r\n\r\nIt is available for v2.0.0-rc2 but not v2.0.0.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4588/comments",
    "author": "jsukhabut",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-05-14T16:31:56Z",
        "body": "The community discovered a fundamental issue in the implementation we had, and we pulled the package for now. @ReubenBond had an idea of a proper implementation, but we ran out of time for 2.0.0 to try to get it in."
      },
      {
        "user": "jsukhabut",
        "created_at": "2018-05-15T18:42:40Z",
        "body": "@ReubenBond can you share your idea on the proper implementation?\r\n\r\nI am having issues using Azure Storage for clustering in Service Fabric.  If the Azure membership table is clean, all is well.  Repeated deleted, update, and upgrades of an application causes silos to never discover each other.\r\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-05-15T19:40:40Z",
        "body": "The Azure Table clustering provider is the most used and tested one, and it should just work with SF because it is completely independent from the hosting infrastructure. Just need to make sure the same `clusterId` is used for all silos, and accessible IP addresses are configured for their endpoints.\r\n\r\nCan you share more data (configuration and logs) about how you are setting it up?"
      },
      {
        "user": "jsukhabut",
        "created_at": "2018-05-15T22:22:27Z",
        "body": "I have a 15 node SF cluster.  Using one standard tier azure storage and all have the same cluster id.\r\n\r\nI was trying to figure out what was going on this weekend by deploying an app, then I would go to the management SF web UI and delete the application to initiate a shutdown of all nodes and wait.  I can see from the logs that a Shutdown() has been initiated.  Then I waited until the application is removed from all nodes while looking at the Azure membership table OrleansSiloInstances.\r\n\r\nAfter all silo have been deleted, the results reading the table rows are inconsistent.  I just tried this again with a cluster of 15 instances and the status table showed 9-Active, 2-Dead, 4-ShuttingDown even though all processes has been shutdown completely. \r\n\r\nAfter a redeployment of same package, 14 silos showed active right away and it took the last one a long time (about 5 min) to show up as active.\r\n\r\nOn the in-place update scenario where I click Publish from Visual Studio, after the deployment removes the previous application and just before it replaces it with a new package, the process leaves ALL silo states as Active.  This in-turn result to 30 active entries in the membership table before it settles and mark the other 15 rows dead.\r\n\r\nThe ultimate scenario that I am going to test is if the app will survive a rolling upgrade to a newer version.  I tried this once and there were many SiloUnavailableExceptions and timeout exceptions being thrown in the Silo process.  I still have to test that the webapi frontend would still be able to call the silos without errors while the upgrade is in progress. \r\n\r\n"
      },
      {
        "user": "ifle",
        "created_at": "2018-05-16T09:13:54Z",
        "body": "@jms69 I have small unrelated to this issue question.\r\nWhere you deploy the webapi frontend? On SF or Service App?\r\nI try to find the best way for us to deploy the silo's and frontend applications. "
      },
      {
        "user": "jsukhabut",
        "created_at": "2018-05-16T17:17:37Z",
        "body": "@ifle WebAPI frontend is another stateless service in SF.  There is AuthN in the API layer.  The WebAPI just protects and wraps the silo calls which does not have security."
      },
      {
        "user": "ifle",
        "created_at": "2018-05-16T18:36:37Z",
        "body": "Thanks. We have the classic asp.net application and can't use stateless service. In our case the best solution are containers."
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-05-17T10:37:28Z",
        "body": "@jms69 I see at least two related aspects here.\r\n\r\n1. Why silo that are getting shut down don't manage to update their status in the membership table. \r\n\r\nThe process of a graceful shutdown takes some time: to deactivate all grains, hand off directory partitions, etc. The last step in the shutdown process is updating silo's status in the membership table.\r\n\r\nI suspect that in this case silos aren't given enough time to complete the process successfully and get killed before they are done, which leads to the inconsistent states in the table. I suspect this is aggravated by shutting down *all* silos at once. To confirm that, you can try to stop silos (ungracefully) instead of shutting them down.\r\n\r\n2. When a new cluster is starting with the same Cluster ID as a previously run cluster, and the membership table contains fresh incorrect entries listing as `Active` silos that are actually aren't running, this slows down startup of the new cluster by up to a few minutes until those incorrect entries expire because the newly starting silos validate (by default) their connectivity with all `Active` silos in the cluster.\r\n\r\nIf you a new cluster with a new Cluster ID, this obviously won't happen. Otherwise, 2 is inherently dependent on 1."
      }
    ]
  },
  {
    "number": 4551,
    "title": "There is no support plan for the Http protocol？",
    "created_at": "2018-05-03T03:49:39Z",
    "closed_at": "2018-05-24T02:00:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4551",
    "body": "There is no support plan for the Http protocol？",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4551/comments",
    "author": "lfzm",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2018-05-03T04:11:00Z",
        "body": "There is a plan to support HTTP. The relevant issue is #2427.\r\n\r\nI hope that we are able to address it soon. Please let us know on that issue what your requirements for that feature are so that we can consider them in the design."
      },
      {
        "user": "lfzm",
        "created_at": "2018-05-24T02:00:24Z",
        "body": "#3362 Being implemented"
      }
    ]
  },
  {
    "number": 4531,
    "title": "Grain timeouts",
    "created_at": "2018-04-29T16:59:19Z",
    "closed_at": "2018-06-19T14:30:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4531",
    "body": "Hi. I want to use grain with different lifetime by type. Some my grains execute so long and this normal. Then i call grain from client, i can registered standardClient and longTimeLive client, but i can do this inside silo host. When i cal my grain A from grain B, i want that grain B can wait A more that another grains. How i can do this?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4531/comments",
    "author": "careless6666",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-06-05T16:18:08Z",
        "body": "You should be able to do the same - create a separate client for those calls. However, long running RPC calls aren't a recommended pattern in general. The preferred alternative is to make a quick call to start a long running operation and later have a quick call back to notify about completion."
      },
      {
        "user": "Kritner",
        "created_at": "2018-08-07T14:33:08Z",
        "body": "I know this was already closed, but I'd like to do something similar, are there any examples of how to accomplish this?  Would this require a stateful grain? Something like a `start` method that returns immediately, a private member representing the result, and a `getresult` method that returns either the result, or a \"not finished\" indicator?\r\n\r\n"
      }
    ]
  },
  {
    "number": 4523,
    "title": "Orleans call grain within a grain",
    "created_at": "2018-04-27T17:19:10Z",
    "closed_at": "2018-04-27T21:15:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4523",
    "body": "I've got a requirement to call a grain within a grain. I had tried this in version 1.5 not sure how it works in 2.0. If somebody can provide a sample it would be great. This was what I was trying.\r\n\r\n public class CustomerRule : Grain, ICustomerRule\r\n{\r\n    private ISomeGrain _someGrain;\r\n    public override async Task OnActivateAsync()\r\n        {\r\n              _someGrain = GrainFactory.GetGrain<ISomeGrain>(this.GetPrimaryKeyString());\r\n              await base.OnActivateAsync();\r\n         }\r\n     public Task<bool> TestHello(GrainCancellationToken tc, string customer)\r\n     {\r\n               var string =  _someGrain.SayHello(tc, customer);\r\n              return Task.FromResult(string);\r\n      }\r\n}\r\n\r\nDue to some reason SayHello() is not being invoked. \r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4523/comments",
    "author": "satishviswanathan",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-04-27T18:00:58Z",
        "body": "The code is missing `await` in front of `_someGrain.SayHello(tc, customer);`. Is this the exact code or pseudo-code?\r\n\r\n`GrainFactory.GetGrain(this.GetPrimaryKeyString());` doesn't look right either."
      },
      {
        "user": "satishviswanathan",
        "created_at": "2018-04-27T18:23:16Z",
        "body": "Sorry that was a psedo code.\r\n\r\npublic  async Task TestHello(GrainCancellationToken tc, string customer)\r\n{\r\nvar string = await _someGrain.SayHello(tc, customer);\r\nreturn await Task.FromResult(string);\r\n}\r\n\r\nWhat I'm not sure is how we can access another grain within the CustomerRule grain. Any sample code ?\r\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-04-27T18:37:18Z",
        "body": "You can simply do\r\n```csharp\r\npublic async Task TestHello(GrainCancellationToken tc, string customer)\r\n{\r\n  return await _someGrain.SayHello(tc, customer);\r\n}\r\n```\r\nor even\r\n```csharp\r\npublic Task TestHello(GrainCancellationToken tc, string customer)\r\n{\r\n  return _someGrain.SayHello(tc, customer);\r\n}\r\n```\r\ninstead of that code.\r\n\r\n>What I'm not sure is how we can access another grain within the CustomerRule grain. \r\n\r\nCalling a grain from another grain is a bread-and-butter scenario for Orleans. The code you wrote should just work for that. How do you determine that `SayHello` is not getting invoked? Do you get a error/exception?"
      },
      {
        "user": "satishviswanathan",
        "created_at": "2018-04-27T19:29:22Z",
        "body": "How is this _someGrain created on the calling grain in this case CustomerRule ?\r\n\r\nbasically I was not getting any results from the method SayHello(). also I had a break point and log return to see if it hits there but both didn't work."
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-04-27T19:33:47Z",
        "body": "@satishviswanathan `Grain` has a `GrainFactory` property, so you can create the grain reference, `_someGrain`, by using `this.GrainFactory.GetGrain<ICustomerGrain>(customer)`.\r\n\r\nIn the end, your method might look like this:\r\n\r\n```C#\r\npublic Task TestHello(GrainCancellationToken tc, string customer)\r\n{\r\n  var grain = this.GrainFactory.GetGrain<ICustomerGrain>(customer)\r\n  return grain.SayHello(tc, customer);\r\n}\r\n```\r\n\r\nHere I am assuming you have `ICustomerRuleGrain` with a `TestHello` method and it calls into `ICustomerGrain`'s `SayHello` method."
      },
      {
        "user": "satishviswanathan",
        "created_at": "2018-04-27T21:00:54Z",
        "body": "@ReubenBond The was my mistake I had an error being thrown from one of the grain and that was blowing the brain grain to return the result.\r\n\r\nThanks a lot for your support."
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-04-27T21:05:23Z",
        "body": "We are happy to help, @satishviswanathan :)\r\n\r\nIs this issue resolved now?"
      },
      {
        "user": "satishviswanathan",
        "created_at": "2018-04-27T21:07:24Z",
        "body": "Yes the issue is resolved now."
      }
    ]
  },
  {
    "number": 4478,
    "title": "Is it possible to configure silo using DNS name instead of IP address",
    "created_at": "2018-04-16T21:16:38Z",
    "closed_at": "2018-04-18T14:54:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4478",
    "body": "Team,\r\nBelow is code snippet for Silo host. Is there any option where I can configure endpoint using DNS name instead of IP address.\r\n\r\n            var siloPort = Convert.ToInt32(ConfigurationManager.AppSettings[\"SiloPort\"]);\r\n            var gatewayPort = Convert.ToInt32(ConfigurationManager.AppSettings[\"GatewayPort\"]);\r\n            var advertisedIp = IPAddress.Parse(ConfigurationManager.AppSettings[\"AdvertisedIP\"]);\r\n            var builder = new SiloHostBuilder()\r\n                .Configure<ClusterOptions>(options =>\r\n                {\r\n                    options.ClusterId = ConfigurationManager.AppSettings(\"CLUSTER_ID\");\r\n                    options.ServiceId = ConfigurationManager.AppSettings(\"SERVICE_ID\");\r\n                })\r\n                .ConfigureEndpoints(siloPort: siloPort, gatewayPort: gatewayPort, advertisedIP: advertisedIp)\r\n                .UseConsulClustering(gatewayOptions =>\r\n                {\r\n                    gatewayOptions.Address =\r\n                        new Uri(ConfigurationManager.AppSettings(\"ServiceDiscoverEndPoint\"));\r\n                })\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4478/comments",
    "author": "srinathgnath",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2018-04-16T21:36:52Z",
        "body": "HI @srinathgnath, there is an overload of ConfigureEndpoints which accepts a hostname:\r\n```C#\r\npublic static ISiloHostBuilder ConfigureEndpoints(\r\n    this ISiloHostBuilder builder, \r\n    string hostname, \r\n    int siloPort, \r\n    int gatewayPort,\r\n    AddressFamily addressFamily = AddressFamily.InterNetwork,\r\n    bool listenOnAnyHostAddress = false)\r\n```\r\n\r\nDoes that work for you?"
      },
      {
        "user": "srinathgnath",
        "created_at": "2018-04-18T14:54:36Z",
        "body": "Thanks"
      }
    ]
  },
  {
    "number": 4466,
    "title": "Question - Heterogenous Silo configuration in runtime",
    "created_at": "2018-04-13T11:32:38Z",
    "closed_at": "2020-01-14T18:15:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4466",
    "body": "Hello guys, \r\nis it possible to make Heterogenous Silos configuration by supplying the same build package with all grain implementations, but configuring which parts to host by AddApplicationParts or any similar way (but still referencing all grains)?\r\nWe are just considering to supply the silo with some config and select required set of grains ( and dependent services to inject etc. ) to host when starting the silo. \r\nIt will be very useful if you have the silo capable of hosting N feature-sets, and when the demand arises for some parts of functionality/services, you can choose for which features you need to allocate more resources (and resource configurations required) and start additional silos only for these, instead of running the one big silo.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4466/comments",
    "author": "tinpl",
    "comments": [
      {
        "user": "DarkCow",
        "created_at": "2018-04-13T15:21:46Z",
        "body": "I think placement directors are a better option... I made a role placement director. Then you decorate your Grain class with `[RolePlacement( \"fileserver\" )]`\r\n\r\nYou can use it by calling `siloHostBuilder.AddPlacementDirector<RolePlacementStrategy, RolePlacementDirector>( )`\r\n\r\nUsing this technique, I can change the roles of servers during runtime, and their cache will be fixed every min or so. I leave the implementation of m_SiloRoleRepository to you. But it is a service that returns SiloAddress <--> Supported Roles\r\n\r\n```\r\n    [Serializable]\r\n    public class RolePlacementStrategy : PlacementStrategy\r\n    {\r\n        public string RoleName { get; private set; }\r\n\r\n        internal RolePlacementStrategy( string roleName )\r\n        {\r\n            RoleName = roleName;\r\n        }\r\n\r\n        public override string ToString( )\r\n        {\r\n            return String.Format( $\"RolePlacementStrategy(role={RoleName})\" );\r\n        }\r\n\r\n        public override bool Equals( object obj )\r\n        {\r\n            if( obj is RolePlacementStrategy other )\r\n                return other.RoleName == RoleName;\r\n            else\r\n                return false;\r\n        }\r\n\r\n        public override int GetHashCode( )\r\n        {\r\n            return GetType( ).GetHashCode( ) ^ RoleName.GetHashCode( );\r\n        }\r\n    }\r\n```\r\n```\r\n    public class RolePlacementDirector : IPlacementDirector\r\n    {\r\n        public RolePlacementDirector( ISiloRoleRepository siloRoleRepository )\r\n        {\r\n            m_SiloRoleRepository = siloRoleRepository;\r\n        }\r\n\r\n        public virtual async Task<SiloAddress> OnAddActivation( PlacementStrategy strategy, PlacementTarget target, IPlacementContext context )\r\n        {\r\n            var allSilos = context.GetCompatibleSilos( target );\r\n            var rolePlacementStrategy = (RolePlacementStrategy)strategy;\r\n            var siloRoleInfos = await GetSiloRoleInfosAsync( );\r\n\r\n            var silosInRole = siloRoleInfos\r\n                .Where( r => r.Roles.Contains( rolePlacementStrategy.RoleName ) )\r\n                .Join( allSilos,\r\n                    r => r.IPAddress,\r\n                    s => s.Endpoint,\r\n                    ( r, s ) => new { SiloRoleInfo = r, SiloAddress = s } )\r\n                .ToList( );\r\n\r\n\r\n            if( silosInRole.Count == 0 )\r\n                throw new SiloRoleNotFoundException( rolePlacementStrategy.RoleName );\r\n\r\n            return silosInRole[ m_Random.Next( silosInRole.Count ) ].SiloAddress;\r\n        }\r\n\r\n        protected async Task<List<SiloRoleInfo>> GetSiloRoleInfosAsync( )\r\n        {\r\n            var siloRoleInfos = m_MemoryCache.Get<List<SiloRoleInfo>>( \"SiloRoleInfo\" );\r\n\r\n            if( siloRoleInfos == null )\r\n            {\r\n                await m_CacheLock.WaitAsync( );\r\n\r\n                try\r\n                {\r\n                    // Check twice\r\n                    siloRoleInfos = m_MemoryCache.Get<List<SiloRoleInfo>>( \"SiloRoleInfo\" );\r\n\r\n                    if( siloRoleInfos == null )\r\n                    {\r\n                        siloRoleInfos = await m_SiloRoleRepository.GetAsync( );\r\n\r\n                        m_MemoryCache.Set( \"SiloRoleInfo\", siloRoleInfos, DateTime.Now.Add( ms_Interval ) );\r\n                    }\r\n                }\r\n                finally\r\n                {\r\n                    m_CacheLock.Release( );\r\n                }\r\n            }\r\n\r\n            return siloRoleInfos;\r\n        }\r\n\r\n        private Random m_Random = new Random( );\r\n        private ISiloRoleRepository m_SiloRoleRepository;\r\n        private MemoryCache m_MemoryCache = new MemoryCache( new MemoryCacheOptions( ) );\r\n        private SemaphoreSlim m_CacheLock = new SemaphoreSlim( 1, 1 );\r\n        private ILogger m_Logger = Log.ForContext<RolePlacementDirector>( );\r\n        private static readonly TimeSpan ms_Interval = TimeSpan.FromMinutes( 1 );\r\n    }\r\n```\r\n```\r\n    /// <summary>\r\n    /// Directs Orleans to only place new activations on a Silo supporting the Role\r\n    /// </summary>\r\n    [AttributeUsage( AttributeTargets.Class, AllowMultiple = false )]\r\n    public sealed class RolePlacementAttribute : PlacementAttribute\r\n    {\r\n        public string Role { get; private set; }\r\n\r\n        public RolePlacementAttribute( string role ) :\r\n            base( new RolePlacementStrategy( role ) )\r\n        {\r\n            Role = role;\r\n        }\r\n    }\r\n```\r\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-04-16T04:02:49Z",
        "body": "I said I would comment on this, so here goes:\r\nThere are a few ways to exclude grains from a silo. The placement solution mentioned by @DarkCow is one of them. Another is using `GrainClassOptions.ExcludedGrainTypes`:\r\n``` C#\r\nsiloBuilder.Configure<GrainClassOptions>(options.ExcludedGrainTypes.Add(typeof(MyGrain).FullName)));\r\n```\r\n\r\nI was originally thinking of another method, but it's quite ugly. You would replace the default `ApplicationPartManager` / `IApplicationPartManager` with your own implementation which filters out the unwanted grain classes from `GrainClassFeature` when it's being populated (in `PopulateFeature`). I don't recommend that approach."
      },
      {
        "user": "tinpl",
        "created_at": "2018-04-20T19:00:08Z",
        "body": "Thank you for your responses, both of them do what we want to achieve!\r\n\r\n`ApplicationPartManager` seems to be more conventional way to configure the silo at the startup, if you don't want to change hosted types in the future. Kind of you are building the silo here, so that should be the place to define what should it host. Maybe adding one more class (similar to `AssemblyPart`),something like `GrainPart: IAssemblyPart { ... }`, which can be added like `builder.AddApplicationPart(typeof(GrainClass))` will do the work. So if you want to just put in the assembly, use one method. If you need more control -> add Grains explicitly one by one (or `IEnumerable<IAssemblyPart>` of them, probably, this will be more common usage).\r\nExcluded Grain types approach functionally seems to be good one, but intuitively you expect to tell what to Include, not what to Exclude (so if I don't say to Include this grain/assembly of grains -> it shouldn't be here). imho, seems to be slightly misleading.\r\nPlacement director seems to be the most flexible one, with the possibility to add additional rules etc. \r\n\r\nSeems my solution will look like:\r\n1. Set basic capabilities for a silo from config using `ExcludedGrainTypes` (when deploying you just don't want to have some kind of Grains to be on this silo because of this instance resource constraints)\r\n2. Arrange some custom placement strategy using the `PlacementDirector`, based on the Silo's capabilities in terms of hosted 'features' and results of monitoring/metrics, or something similar.\r\n\r\nAny drawbacks in this approach? Or maybe places I should consider to put more attention in, because of possible reliability/performance issues?"
      },
      {
        "user": "ReubenBond",
        "created_at": "2020-01-14T18:15:15Z",
        "body": "Apologies for the extremely slow response. Your points both look fine to me. Closing"
      }
    ]
  },
  {
    "number": 4458,
    "title": "Questions related to reliability",
    "created_at": "2018-04-12T13:00:14Z",
    "closed_at": "2018-06-21T21:55:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4458",
    "body": "Your implementation of the Actor pattern is obviously more geared around intuitiveness and implicit reliability than other implementations.  I do really like how intuitive things are however have 2 questions:\r\n\r\n1. You obviously support streams which means one grain can fire off some request into a stream and then exit.  My question is; should streams be optional?  My understanding from reading the docs is that the most simple and intuitive route to follow is to not use them and to block (asynchronously) while dependant grains execute. However I think that I could easily get into more trouble using Orleans in this way than I would by developing traditional locking code.\r\n\r\nSay I have a Grain A which depends on Grain B, which depends on Grain C, etc.  If Grain C maintains state but A and B don't then are potential activations of A and B blocked until C completes, even though work could be performed in A and B during this period - perhaps A and B don't even always lead to C.\r\n\r\nHopefully it's clear what I'm trying to say.  In a sentence, it makes perfect sense to make grains atomic however I'm not so sure about chains of grains.  \r\n\r\nHave I misinterpreted the architecture? Assuming I haven't, I'll repeat that I know I can use streams and there will be certain patterns I can follow to help me here.  I'm just wondering if there is any value in going the simple/intuitive route (if indeed it's better than a more traditional approach)?\r\n\r\n2. I understand why streams are reliable and it's very nice to have this.  I'm not clear how to best use them though.  I'll give an example to demonstrate my question - along with some extra detail so you can correct me if I'm missing something fundamental:\r\n\r\nGrain A posts a message to Stream A (it blocks while it's posting to the stream but after this can then return and handle further activations).  Now if for whatever reason the message posted to the stream isn't processed as expected (e.g. the grain which consumes the message doesn't die but somehow drops the message).  I'm assuming I have to build checks into my system for this type of thing?\r\n\r\nIf it is the case that I've got to build these checks into my system I'm wondering if it's worth paying the cost for the reliable stream?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4458/comments",
    "author": "tdinucci",
    "comments": [
      {
        "user": "jason-bragg",
        "created_at": "2018-04-12T20:47:34Z",
        "body": "**Regarding 1**\r\n\r\nStreams, imo, are separate from the actor model.  Streams are a feature we support and are integrated with the actor model but are logically separable and opt-in only.  Our implementations of streams are built (wisely or not) on top of the actor model which constrains the feature to limitations of the actor model, but that is mostly an implementation detail.\r\n\r\nThe behavior of streams, unfortunately, is very implementation specific.  For instance, the type of chaining behavior you describe is a concern when using the simple messaging streams (SMS), but would not be a concern while using any of the persistent streams (Memory Streams for instance).  This is due to the fact that the OnNextAsync task on a persistent stream resolves when the event is successfully stored in the queue rather than upon successful processing of the event by all subscribers (as is the behavior in SMS).\r\n\r\n**Regarding 2**\r\n\r\nStreams are not necessarily reliable, we support various levels of reliability.\r\n\r\nSMS and Memory streams are not reliable, as they keep messages in memory and can lose messages under some error conditions.\r\n\r\nSome persistent streams support limited recovery of unordered data.  Azure queue is an example of this.  It should reliably deliver all messages at least once to each subscriber, but the data is unordered, and duplicates are possible (even likely).\r\n\r\nSome persistent streams support ordered reliable data.  EventHub stream provider is an example.  These streams will deliver events in order with ordering information in the form of sequence tokens which can be used to remove duplicate events or rewind the stream to an earlier point in order to recover from transient errors.\r\n\r\nUnfortunately streaming, while conceptually simple, is non-trivial and means different things to different people.  Prior to a deeper dive into the subject, I advocate users consider their application needs.  While we make efforts to simplify the usage patterns, the ordered, reliable, recoverable, high speed processing of events in a distributed system is not something that we’ve managed to deliver an entirely simplified model of, nor have we managed to avoid technical tradeoffs which only the application developer can choose to make. :/\r\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2018-04-12T21:18:24Z",
        "body": "@tdinucci,\r\n\r\n>Grain A posts a message to Stream A (it blocks while it's posting to the stream but after this can then return and handle further activations). Now if for whatever reason the message posted to the stream isn't processed as expected (e.g. the grain which consumes the message doesn't die but somehow drops the message). I'm assuming I have to build checks into my system for this type of thing?\r\n\r\nAs described in my previous post, this sort of recoverable stream processing is only supported by persistent streams and may vary by implementation.  For ordered reliable streams, the expected behavior is that should an event delivered to a subscriber to be processed fail, the streaming infrastructure will retry until it succeeds or a set retry period is reached.  If the streaming infrastructure eventually gives up on delivering the event, the application layer is notified of this via the OnErrorAsync and a local callback to an IStreamFailureHandler, should the application provide one.  The local callback is necessary as the OnErrorAsync is unreliable, because if the grain is unreachable for event delivery then it may not be available for error notification.\r\n\r\nThe reliability in the recoverable streams is geared towards transient errors, allowing resilience against temporary outages (usually less than 5 minutes).  It doesn't ensure the processing of poison messages or message processing under other non-recoverable or long standing errors, only notifying the application layer that these have occurred, so either user or automated action can be taken.\r\n\r\nThese behaviors are tested using the ImplicitSubscritionRecoverableStreamTestRunner."
      },
      {
        "user": "tdinucci",
        "created_at": "2018-04-12T22:21:16Z",
        "body": "Thanks very much @jason-bragg for the thorough response :+1: \r\n\r\nYou said:\r\n> Streams, imo, are separate from the actor model.\r\n\r\nI had understood streams to be the broadly equivalent to the mailboxes which are part of the actor model - obviously the mailboxes would be at the ends of the streams.  \r\n\r\nWith this (potentially incorrect) understanding I would think that if you don't use streams then you don't have mailboxes.  If you don't have mailboxes then either; a) initiating actors/grains cannot receive responses, or b) chains are effectively synchronous and all grains within the chain are locked.  Is this correct?\r\n\r\nIn relation to stream reliability, in your second post you said:\r\n\r\n> For ordered reliable streams, the expected behavior is that should an event delivered to a subscriber to be processed fail, the streaming infrastructure will retry until it succeeds or a set retry period is reached.\r\n\r\nI'm not totally clear on what this means.  Is the assurance that if a message fails to be processed it's retried or just if it fails to be delivered?  I guess you could be opening a can of worms by retrying messages that failed to be processed on the stock streams.\r\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2018-04-12T23:58:01Z",
        "body": "@tdinucci\r\n\r\n>chains are effectively synchronous and all grains within the chain are locked. Is this correct?\r\n\r\nI'm unfamiliar with mail boxes, but regarding chaining behaviors, the default behavior for a chain of A->B->C would be that A,B, and C would not be able to process other grain calls until C returns, at which time only A and B would be unavailable until B returns, and so on.  Streaming, if configured to use a persistent stream, would avoid this since an event generated on a stream consumed by A could generate a new event on a different stream to be consumed by B and so on, avoiding blocking for long call chains at the cost of putting the event in a queue between each grain.  Am I understanding your question?\r\n\r\n>Is the assurance that if a message fails to be processed it's retried or just if it fails to be delivered?\r\n\r\nEither.  Delivery of a stream event to a consumer is performed as a grain call.  If the grain call does not succeed (due to application error, timeout, grain activation failure, duplicate activation, ..?), it will be redelivered.  This retry logic will persist for a configured period of time (default is 1 minute).  In the case of a silo failure, this retry logic may reactivate the grain on another silo.  If this leads to data loss from processed messages which may not have been persisted yet, the grain can rewind the stream to the last point the grain stored processed results and reprocess the lost events.  This ability to rewind the stream is limited by the amount of data the stream provider is configured to cache for recovery purposes.  The larger the cache, the further back in time a recovering grain can rewind its stream.\r\n\r\n"
      },
      {
        "user": "tdinucci",
        "created_at": "2018-04-13T00:29:56Z",
        "body": "@jason-bragg you have understood my questions and answered them.  Thanks very much for your time!"
      },
      {
        "user": "martinothamar",
        "created_at": "2018-04-18T11:02:19Z",
        "body": "For the grain call chain locking in the absence of streams, there is the `OneWay`-attribute which can be added to methods on the grains interface. When a grain calls on that attributed method it will immediately return. Not sure how persistent streams compare to this attribute in terms for performance and reliability."
      }
    ]
  },
  {
    "number": 4449,
    "title": "why my orleans being slow with 3 node?",
    "created_at": "2018-04-11T10:05:05Z",
    "closed_at": "2018-05-08T16:13:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4449",
    "body": "when 1 node was running, the client is fast,\r\nwhen 3 node was running ,the client is fast At first， but being slow after A few minutes。\r\n\r\n const string connectionString = \"Server=192.168.2.113;Database=TestOrleans;User Id=sa;Password=sa;\";\r\n\r\n            //  var  configuration = new ConfigurationBuilder()\r\n            //   .AddJsonFile(\"HostSettings.json\", true, true)\r\n            //   .Build();\r\n            //var port=  configuration.GetValue<int>(\"configProperties:Net.Port\");\r\n            //var gatePort=  configuration.GetValue<int>(\"configProperties:GateWay.Port\");\r\n            var netport = System.Configuration.ConfigurationManager.AppSettings[\"netport\"];\r\n            var gatewayport = System.Configuration.ConfigurationManager.AppSettings[\"gatewayport\"];\r\n\r\n            var silo = new SiloHostBuilder()\r\n                .Configure<ClusterOptions>(options =>\r\n                {\r\n                    options.ClusterId = \"mycluster\";\r\n                    options.ServiceId = \"product\";\r\n                    \r\n                })\r\n                .Configure <GrainCollectionOptions>(options=> {\r\n                    //配置grain的回收\r\n                    options.CollectionAge = TimeSpan.FromMinutes(10);\r\n                    options.CollectionQuantum = TimeSpan.FromMinutes(5);\r\n                })\r\n                .UseAdoNetClustering(options =>\r\n                {\r\n                    options.ConnectionString = connectionString;\r\n                    options.Invariant = \"System.Data.SqlClient\";\r\n                })\r\n                \r\n                .ConfigureEndpoints(System.Net.Dns.GetHostName(),int .Parse( netport),int .Parse( gatewayport))\r\n                \r\n                .ConfigureLogging(logging =>logging.SetMinimumLevel(LogLevel.Warning).AddConsole())\r\n                // .ConfigureLogging(builder => builder.SetMinimumLevel(LogLevel.Warning).AddConsole())\r\n                .Build();\r\n\r\n            silo.StartAsync().Wait();\r\n            Console.WriteLine(\"启动成功\");\r\n            Console.Read();\r\n            silo.Dispose();\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4449/comments",
    "author": "zhanlanghun",
    "comments": [
      {
        "user": "xiazen",
        "created_at": "2018-04-11T21:36:17Z",
        "body": "can you share more information, such as logs when client is slow, and what the client is doing etc"
      },
      {
        "user": "xiazen",
        "created_at": "2018-04-11T21:36:27Z",
        "body": "and which version of Orleans are you using "
      },
      {
        "user": "zhanlanghun",
        "created_at": "2018-04-12T01:13:16Z",
        "body": "client:\r\n\r\n var client = new ClientBuilder()\r\n             .Configure<ClusterOptions>(options =>\r\n             {\r\n                 options.ClusterId = \"mycluster\";\r\n                 options.ServiceId = \"product\";\r\n\r\n\r\n             })\r\n             .Configure<ClientMessagingOptions>(option =>\r\n             {\r\n                 option.ClientSenderBuckets = 100;\r\n             })\r\n             .UseAdoNetClustering(options =>\r\n             {\r\n                 options.ConnectionString = connectionString;\r\n                 options.Invariant = \"System.Data.SqlClient\";\r\n             })\r\n  \r\n             .Build();\r\n             await client.Connect();\r\n            int i = 1;\r\n\r\n            IProduct friend = null;\r\n            while (i < 10000000)\r\n            {\r\n                try\r\n                {\r\n                    friend = client.GetGrain<IProduct>(i);\r\n                    await friend.GetProduct(i);\r\n                   \r\n\r\n                }\r\n                catch (Exception e)\r\n                {\r\n                    \r\n                }\r\n\r\n                i++;\r\n\r\n                //await Task.Delay(1);\r\n                if (i >= 200000)\r\n                {\r\n                    i = 1;\r\n                }\r\n            }"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-04-18T22:53:07Z",
        "body": ">when 3 node was running ,the client is fast At first， but being slow after A few minutes。\r\n\r\nI see no measurement of timing in your code. How do you see that it's getting slow after a few minutes?\r\n\r\nBTW, running a loop with an `await` for each call is not exercising the capacity of the cluster, as only one grain call runs at any point in time. You can fan out a larger number of them (100 or 1000) in parallel and await them all."
      },
      {
        "user": "zhanlanghun",
        "created_at": "2018-04-19T01:14:29Z",
        "body": "@sergeybykov   ok！！thank you。"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-04-27T21:03:37Z",
        "body": "@zhanlanghun Do you have any update?"
      },
      {
        "user": "zhanlanghun",
        "created_at": "2018-04-28T01:54:56Z",
        "body": "@sergeybykov    The problem has been solved.  and thank you"
      }
    ]
  },
  {
    "number": 4331,
    "title": "Old data in zookeeper don't get  removed",
    "created_at": "2018-03-28T06:33:10Z",
    "closed_at": "2018-10-08T21:31:07Z",
    "labels": [
      "question",
      "help wanted"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4331",
    "body": "I find out when my orleans application restarts, there will be a new record in the deploy node in zookeeper, but it seems that the old record never get removed.  Will that cause performance or other problem?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4331/comments",
    "author": "bob-dawson",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-03-28T15:47:21Z",
        "body": "This is by design and should not cause any problem."
      }
    ]
  },
  {
    "number": 4311,
    "title": "[2.0 RC2]What's wrong with this?",
    "created_at": "2018-03-27T01:31:12Z",
    "closed_at": "2018-04-11T06:22:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4311",
    "body": "2018-03-27 04:30:08.626 +08:00 [fail] Runtime.Scheduler.WorkerPoolThread/2[101212]: Worker pool thread Runtime.Scheduler.WorkerPoolThread/2 (ManagedThreadId=26) has been busy for long time: Executing Task Id=158 Status=Running for 00:00:00.3903356 on WorkItem=System*WorkItemGroup:Name=*stg/0/00000000,WorkGroupStatus=Running Executing for 00:00:00.3903596. WorkItemGroup Details: System*WorkItemGroup:Name=*stg/0/00000000,WorkGroupStatus=Running. Currently QueuedWorkItems=25; Total EnQueued=4870; Total processed=4844; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-12:Queued=25; Detailed SchedulingContext=<[LowPrioritySystemTarget: S127.0.0.1:11111:259745611*stg/0/00000000@S00000000] CurrentlyExecuting=Response S127.0.0.1:11111:259745611*grn/44515979/e01548b0@4cb04888->S127.0.0.1:11111:259745611*stg/0/00000000@S00000000 #9896: >.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4311/comments",
    "author": "lfzm",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-03-27T21:47:06Z",
        "body": "Looks like the system target `stg/0/00000000` took 390ms to process a single request. Could be a sign that the silo is severely overloaded or is under a major GC pressure or running on a tiny VM. What's the environment here?"
      }
    ]
  },
  {
    "number": 4308,
    "title": "Does this make sense for Orleans or SF and if so guidance please",
    "created_at": "2018-03-26T18:52:33Z",
    "closed_at": "2018-04-10T05:34:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4308",
    "body": "We’re working to take our  software to Azure cloud and looking at Orleans and Service Fabric (SF) as potential frameworks.  We need to:\r\n\r\n1)\tPopulate our analysis engines with lots of data (e.g., 100MB to 2GB) per engine instance.\r\n2)\tMaintain that state, and if an engine instance goes idle for say 20 minutes or more, we’d like to unload it (i.e., and not pay for the engine instance resource).\r\n3)\tEach engine instance will support one to several end users with a specific data set.\r\n4)\tEach engine instance can be highly interactive generating lots of plot data near realtime.  We’re maintaining state as we don’t want to pay the price to populate engine instance for each engine interaction.\r\n5)\tAn engine instance action can take a few seconds, a few minutes, to even tens of minutes.  We’ll want some feedback.\r\n6)\tUsers may access an engine instance every few seconds (e.g., to steer the engine towards a result based on feedback) and will want live plot data.\r\n7)\tEach user will want to talk to a specific engine instance.\r\n8)\tAs a user expresses interest in running a simulation (i.e., standing up an engine instance), ideally we want him to choose small/medium/large computing resource to run his engine instance (i.e., based on the problem he’s trying to solve he may want more or less computing/memory power).\r\n\r\nWe’re considering Orleans and SF but we’re having difficulty specifying architecture based on above requirements.  We’ve considered:\r\n\r\n1)\tTrying to think about an SF node, or an Orleans silo as an ‘engine instance’ described above.\r\n2)\tLeveraging both Orleans and SF notion of fault tolerance through replication.\r\n3)\tLeveraging local (i.e., to node or silo) storage to store results and maintain state (i.e., for long periods or until idle for 20 minutes).\r\n\r\nWe’ve not understood how to:\r\n\r\n1)\tLimit a silo or a node to a single engine instance so that we can control resourcing of the engine instance.\r\n2)\tKeep a user’s engine instance data separate from another users engine instance data.  \r\n3)\tDirect a request from a user (e.g., through a web API) to a particular engine instance.\r\n\r\nDoes this make sense for Orleans, does it make more sense for SF?  Any pointers on how to implement the above would be helpful.\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4308/comments",
    "author": "MattWorkWeb",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2018-03-29T00:57:47Z",
        "body": "Hi @MattWorkWeb,\r\n\r\nCould one host hold multiple analysis engines? It might be that you could associate each engine instance with a grain. Is memory the only constraint, or do each of these engines require significant CPU resources, too?\r\n\r\nIf you know the size of an engine ahead of time, you could potentially use a custom placement director to select the silo with the most available memory to place each new instance on.\r\n\r\n> 1. Limit a silo or a node to a single engine instance so that we can control resourcing of the engine instance.\r\n\r\nSilos aren't really designed for hosting one thing at a time, but you can use custom placement directors to control what gets placed on each silo.\r\n\r\n> 2. Keep a user’s engine instance data separate from another users engine instance data.\r\n\r\nYou could include the user's id in the grain id so that a separate grain is used for each user. Alternatively you could share one engine instance between users and include the user id in the the calls to the grain (or in the `RequestContext` which is passed with the call). I think I'd need to understand more about the scenario to give a recommendation, but either way is likely fine. How much data does each user have?\r\n\r\n> 3. Direct a request from a user (e.g., through a web API) to a particular engine instance.\r\n\r\nIf you're using grains to handle the request, the code on the API side might look like this:\r\n```C#\r\n// Get a reference to the specified engine.\r\n// This doesn't perform any IO, that only happens when you use the reference.\r\nvar engineInstance = this.client.GetGrain<IEngineGrain>(engineId);\r\n\r\n// This will call that grain, no matter where it is in the cluster.\r\n// If the grain has not been activated yet, then it will first activate that grain.\r\n// If you are using a custom placement director to determine where that grain should\r\n// live, then that placement director will be asked where to activate the grain\r\nreturn engineInstance.SomeQueryOrCommand(user, args);\r\n```\r\n\r\nHow you determine `engineId` and create the authenticated `user` object is up to you. The `IEngineGrain` can perform authorization of the user. Alternatively you could perform AuthN & AuthZ in the Web API and not pass any representation of the user to the grain at all.\r\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-04-10T05:34:45Z",
        "body": "Closing this for now. We can continue the discussion here or via another channel"
      }
    ]
  },
  {
    "number": 4260,
    "title": "What is PubSubStore for? Running one night will produce more than 140,000 data",
    "created_at": "2018-03-21T02:08:30Z",
    "closed_at": "2018-04-27T08:59:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4260",
    "body": "What is PubSubStore for? Running one night will produce more than 140,000 data",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4260/comments",
    "author": "lfzm",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-03-21T15:25:18Z",
        "body": "This is where stream subscription information is stored."
      },
      {
        "user": "lfzm",
        "created_at": "2018-03-22T01:22:43Z",
        "body": "@sergeybykov Can I set it to not save, or he will delete it automatically? If there is a large amount of big data, it will cause database pressure"
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-03-22T06:35:59Z",
        "body": "@aqa510415008 you could use in-memory storage for `PubSubStore`, but just be aware that it means that your subscriptions can disappear. I am not certain how well it would work - in-memory storage might not work well for this, but you can experiment."
      },
      {
        "user": "lfzm",
        "created_at": "2018-03-22T07:43:22Z",
        "body": "@ReubenBond Thank you for your advice, I also plan to try Redis, but there is a situation where there is too much data, I do not want to save, I do not know whether it can be achieved?"
      },
      {
        "user": "jason-bragg",
        "created_at": "2018-03-22T18:32:04Z",
        "body": "@aqa510415008, What version of orleans are you using?\r\n\r\nThe amount of data in the pubsub should be proportional to the number of active producers and consumers.  Assuming producers and consumers are being cleaned up correctly, this data should not grow indefinitely, but only with active load.  So if your service, at peak load, stores 140,000 (k, mb, something?) data in storage, it shouldn't grow beyond that.  If it does, there may have some sort of resource leak in the service code.  For instance, not unsubscribing from streams when they become inactive, or dead producers left over from ungraceful shutdown of silo.\r\n\r\nSafest way to avoid pubsub state is to use implicit subscriptions, assuming the application needs fit the pattern.\r\n\r\nOne can also cleanup pubsub state programmatically using the IStreamSubscriptionManager, assuming one knows the stream Id's of inactive streams.\r\n\r\nAs @ReubenBond suggested, if the service can accept data loss during silo crashes and the stream subscriptions do not need to live beyond a specific cluster deployment, using memory storage for pubsub state may be a viable solution.\r\n\r\n"
      },
      {
        "user": "lfzm",
        "created_at": "2018-03-23T02:17:47Z",
        "body": "@jason-bragg @ReubenBond I am using RC2.0, the subscription data will not be automatically cleared, it is accumulating"
      },
      {
        "user": "jason-bragg",
        "created_at": "2018-04-12T19:56:54Z",
        "body": "@aqa510415008 what grain storage implementation are you using for the pubsub?\r\n\r\nSubscriptions are persistent.  You need to unsubscribe to remove the subscription, or they will remain forever.  Are you doing that?"
      },
      {
        "user": "lfzm",
        "created_at": "2018-04-13T02:11:04Z",
        "body": "@jason-bragg Is the subscription still stored after the subscription is completed? Can I choose not to store it?"
      }
    ]
  },
  {
    "number": 4237,
    "title": "How to represent a database table?",
    "created_at": "2018-03-16T08:01:40Z",
    "closed_at": "2018-04-02T21:30:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4237",
    "body": "Newbie question: Suppose I have a database table and would like to expose some basic methods like Add/Update/Delete through grains.\r\n1) Should the grain be the table, or the individual rows?\r\n2) If the table is represented with grains as individual rows, how do I create a master grain that can find the right grain to update?\r\nThanks\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4237/comments",
    "author": "itsamelambda",
    "comments": [
      {
        "user": "DarkCow",
        "created_at": "2018-03-16T21:41:27Z",
        "body": "There is no reason that an Actor (grain) should be a one-to-one relationship with your table. If that is the case, just use entity framework and be about your day.\r\n\r\nHowever there comes a point where it is worth it to realize complicated business logic using domain models for your company. That is IMO when a grain becomes pricesless. So I would make a grain per domain entity (model, row in table). \r\n\r\nIf you need to update a user, and a user is addressable by userId why not have...\r\n\r\n```\r\nvar userActor = grainClient.GetGrain<IUser>(userId); // No need to have a lookup table here!\r\nawait userActor.Update(userUpdateModel);\r\n```\r\n\r\nIf you do need to index on something, entity framework will do a bangup job.\r\n\r\n```\r\n// Entity framework repository\r\nvar userId = await _context.Users.Where( u => u.email == email ).Select( u => u.userId ).SingleOrDefaultAsync( )\r\n\r\n// NOTE: you can use the userRepository to update the user directly, but that ignores\r\n// business logic. Instead, the IUser grain implements business logic! Now you have\r\n// a clear separation of responsibilities and layers.\r\nvar userActor = grainClient.GetGrain<IUser>(userId);\r\nawait userActor.Update(userUpdateModel);\r\n```\r\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-03-20T20:01:23Z",
        "body": "Grains typically map to application entities, and in most cases that means they correspond to individual rows in a typical DB table. However, there are also cases where an entity is backed by a table as part of its state.\r\n\r\nFor example, a user is naturally represented with a grain as in the examples above. At the same time, as part of the user's state you might want to keep a set of related records like user purchase history. Those records will most likely be in a different table than user profile details.\r\n\r\nSo, in general grains naturally map to rows, but in the end it's up to the application developer to decide in each specific case."
      }
    ]
  },
  {
    "number": 4229,
    "title": "Is IServiceCollection.AddScoped seemingly invalid in Orleans?",
    "created_at": "2018-03-15T12:53:57Z",
    "closed_at": "2018-03-21T02:08:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4229",
    "body": "",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4229/comments",
    "author": "lfzm",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2018-03-16T02:23:21Z",
        "body": "@aqa510415008 each grain activation has its own scope, so when you call AddScoped, you are adding a service which is created per activation"
      },
      {
        "user": "xiazen",
        "created_at": "2018-03-20T20:14:49Z",
        "body": "Thanks reuben for answering. @aqa510415008 does this answer your question? or do you have further questions? "
      },
      {
        "user": "lfzm",
        "created_at": "2018-03-21T02:08:55Z",
        "body": "@ReubenBond @xiazen Thank you, I understand"
      }
    ]
  },
  {
    "number": 4168,
    "title": "RequestContext not available in next operation",
    "created_at": "2018-03-08T11:06:29Z",
    "closed_at": "2018-03-12T09:02:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4168",
    "body": "We have a Grain that uses the RequestContext to pass along the user information. When we use the same Grain instance twice in our calling code, the second call no longer has access to the RequestContext, which seems normal since it (the second operation) is completed on another thread. However it would seem to me that the RequestContext should be migrated to the new thread, or am I completely missing the point?\r\nShould every Grain instance be used only once? Likely refetching the instance would resolve the issue (not tested, will try this out later).\r\n\r\nClient:\r\nRequestContext.Set(\"User\", User.Id);\r\nvar grain = ClusterClient.GetGrain<OurGrain>();\r\ngrain.Operation1();\r\ngrain.Operation2();\r\n\r\nOurGrain:\r\nOperation1():\r\nRequestContext.Get(\"User\") => Fine\r\n\r\nOperation2():\r\nRequestContext.Get(\"User\") => null",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4168/comments",
    "author": "wiezykrwi",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-03-08T18:58:33Z",
        "body": "`RequestContext` is mean to be set per grain call.\r\n\r\nSince a grain can be called in parallel by multiple callers (clients and other grains), between `grain.Operation1()` and `grain.Operation2()` it could have processed a number of requests from other callers, and you probably don't want those calls to be process with the request context you set before `grain.Operation1()`. Likewise, you most likely don't want `grain.Operation2()` to operate with a context set by other caller. Hence, the behavior of request context only use for a single call."
      },
      {
        "user": "wiezykrwi",
        "created_at": "2018-03-12T09:02:09Z",
        "body": "I see your point, but still feel like the context could be reapplied when calling the second time as is done the first time. However I will close the issue, thank you for taking the time to answer!"
      },
      {
        "user": "Jens-G",
        "created_at": "2020-12-13T23:14:04Z",
        "body": "Old thread but ran into same situation today. And found it a bit unexpected, as the OP did. \r\n\r\n**Suggestion:** Can we have some sort of an optional flag that allows to have values persistent on a per-key basis?\r\nWould be perfectly fine to have the default set to the current behaviour."
      }
    ]
  },
  {
    "number": 4149,
    "title": "Silos start running timer",
    "created_at": "2018-03-07T03:11:07Z",
    "closed_at": "2018-03-12T03:13:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4149",
    "body": "What to do when the silo starts running the timer，Not through the client call\r\n\r\n public class Test: Orleans.Grain\r\n    {\r\n        public void TestTime()\r\n        {\r\n            Console.WriteLine(\"get..\");\r\n            TimeSpan t1 = TimeSpan.FromSeconds(10);\r\n            base.RegisterTimer(OnClientRefreshTimer, null, t1 - TimeSpan.FromSeconds(2), t1);\r\n        }\r\n\r\n        private async Task OnClientRefreshTimer(object data)\r\n        {\r\n            Console.WriteLine(\"write\");\r\n        }\r\n    }",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4149/comments",
    "author": "a641545621",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-03-07T19:01:05Z",
        "body": "What's the problem/question here? Looks like a correct way to start a grain timer to me. Except if `Test` is a grain class (which looks like it is, as it extends `Orleans.Grain`), then `TestTime()` needs to be invoked from a grain method which is part of a grain interface."
      },
      {
        "user": "a641545621",
        "created_at": "2018-03-08T03:47:57Z",
        "body": "I would like to start the timer immediately when the silo is started and not from the food"
      },
      {
        "user": "a641545621",
        "created_at": "2018-03-08T07:39:54Z",
        "body": "Starting background timers to perform periodic housekeeping tasks.  2.0.0-rc1"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-03-08T19:03:42Z",
        "body": "You can use a bootstrap provider (getting renamed to start task in 2.0) to execute code upon silo startup."
      }
    ]
  },
  {
    "number": 4113,
    "title": "[Question] Silo shutdown and OnDeactivateAsync",
    "created_at": "2018-03-02T15:17:50Z",
    "closed_at": "2018-03-13T09:59:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4113",
    "body": "I've been digging through the docs and the issues, but I didn't find an answer to the following question:\r\n\r\n_When a silo is shut down, what happens inside a grain's_ `OnDeactivateAsync` _method when another grain is referenced from there, which in turn is getting (or has got) deactivated due to silo shutdown?_\r\n\r\nAnd, to make things more obvious, imagine all silos have been shut down except for the last one; and now that last one is also shutting down, i.e. there are no other silos online. Say you reference another grain in `OnDeactivateAsync`, which already got deactivated - will an exception be thrown in this case? Or will that referenced grain become reactivated? If so, how will the reactivated grain eventually get deactivated? Is the silo trying to drain the silo from grains by retrying a deactivation again and again (until a timeout)?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4113/comments",
    "author": "peter-perot",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-03-03T00:41:22Z",
        "body": "To clarify, when you are saying \"you reference another grain\", I suspect you mean \"you call another grain\", right? Merely holding a reference to a grain doesn't impact that grain in any way.\r\n\r\nWhen silo gets into the `ShuttingDown` state, no new activations can be placed to it. So in your example of the last silo of the cluster shutting down, the grain call to a grain that is not already activated on that last silo will fail."
      },
      {
        "user": "peter-perot",
        "created_at": "2018-03-03T00:46:22Z",
        "body": "> To clarify, when you are saying \"you reference another grain\", I suspect you mean \"you call another grain\", right?\r\n\r\nYes, I call a method of another grain.\r\n\r\n> _[...]_ the grain call to a grain that is not already activated on that last silo will fail.\r\n\r\nIs there a special exception thrown, which lets me determine why the call failed?\r\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-03-03T00:58:16Z",
        "body": "I believe it's an `OrleansException`, but I don't remember which subclass exactly."
      },
      {
        "user": "peter-perot",
        "created_at": "2018-03-03T01:23:26Z",
        "body": "I wonder how to correctly implement a cleanup in `OnDeactivateAsync`, which involves calling other grains.\r\n\r\nOf course since grain calls are not guaranteed to succeed, one must always keep in mind that such a cleanup could be half-done (otherwise we would need some sort of distributed transaction).\r\n\r\nSo, is it generally bad practice to call other grains in `OnDeactivateAsync`?\r\n\r\nTo be specific:, there are cases where I deactivate other grains from `OnDeactivateAsync`. Those \"other grains\" have a `Deactivate` method (defined in their public grain interface) which in turn calls `DeactivateOnIdle`.\r\n\r\nWhen those \"other grains\" are activated, nothing special happens - they simply get deactivated forcibly.\r\n\r\nWhen those \"other grains\" are _not_ activated, they temporarily get activated, just to deactivate them afterwards.\r\n\r\nAnd the latter case could be a problem when the silo is shutting down gracefully.\r\n\r\nBut forced deactivation is not the only use-case (you might make the point that I should not deactivate grains forcibly, but let them alone until activation garbage collection comes into place). There are use-cases where I want - for example - unregister something in such \"other grains\".\r\n\r\nWhat is the correct way to accomplish this, and how to do it right when a silo is shutting down gracefully? Should I simply ignore those exceptions you mentioned?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-03-05T19:25:28Z",
        "body": "In general, `OnDeactivateAsync` is not supposed to be used for anything significant, other than a best effort notification of some other party that the grain is getting deactivated. I almost regret having `OnDeactivateAsync` in the API altogether. Because it's not 100% guaranteed to be invoked, is error prone, and has no good failure handling ability.\r\n\r\nSimilarly, forced deactivation is meant to be an optimization mechanism for releasing large resources, especially unmanaged ones.\r\n\r\nWith that in mind, I don't see a good way of accomplishing what you described in a clean way. I'd suggest to reframe the interactions between grains as one-way notifications of a grain shutting down, so that it is not concerned with success/failure of what that triggers, and there is less of expectation that such operations will succeed. And if the requirements allow you to get out of the business of explicitly deactivating grains, I'd do that as much as possible."
      },
      {
        "user": "peter-perot",
        "created_at": "2018-03-13T09:59:22Z",
        "body": "Thank you @sergeybykov."
      }
    ]
  },
  {
    "number": 4082,
    "title": "Can I connect Orleans server with golang，nodejs...  another language ？",
    "created_at": "2018-02-27T07:35:39Z",
    "closed_at": "2018-04-02T21:11:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4082",
    "body": "please ：\r\n\r\nCan I connect Orleans server with golang，nodejs...  another language ？",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4082/comments",
    "author": "zhanlanghun",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-02-27T17:48:06Z",
        "body": "You would have to do that via a frontend layer (usually an HTTP server) that would translate incoming requests to grain method calls."
      }
    ]
  },
  {
    "number": 4038,
    "title": "Grain Bulk Creation",
    "created_at": "2018-02-14T12:48:47Z",
    "closed_at": "2018-02-26T13:34:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4038",
    "body": "Does anyone have an ideas on how to create grains in batch? We use DynamoDB to store JSON records which I'm hoping to deserialize into Grains. I've tried code in two ways:\r\n\r\n1. Do a BatchGetItemAsync and then for each result create a grain and set the value\r\n2. Do a GetItemAsync in the Grain OnActivateAsync() and set the value\r\n\r\nOption 1 is much faster by doing the batch, but it means I have code in a different grain to do the BatchGetItemsAsync and then set the Grain values. Option 2 leads to cleaner code, but is significantly slower.\r\n\r\nI would like to have my Grain know how to initialize itself, but need to do it some way using Batch.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4038/comments",
    "author": "teedty1",
    "comments": [
      {
        "user": "tinpl",
        "created_at": "2018-02-14T17:40:30Z",
        "body": "not that I know the best possible way, but maybe something like like this could probably work? :\r\n```csharp\r\nclass GrainsConstructor {\r\n    async Task<IEnumerable<ISomeGrainInterface>> GetGrains() {  return BatchGetItemAsync().Select(x => { var g = await GrainFactory.GetGrain<ISomeGrainInterface>(someUid); g.SetValue(x); return g; });\r\n}\r\n```\r\n"
      },
      {
        "user": "teedty1",
        "created_at": "2018-02-15T22:08:57Z",
        "body": "@tinpl  That is pretty much how I am doing it right now with Option 1.  The problem with this is that I'm still needing a separate class that \"creates\" the grains from the BatchGetItemAsync call.  This may just be the only way to do this..."
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-02-20T22:37:41Z",
        "body": "Can you route `GetItemAsync` calls through a layer that would batch them, to get the benefits of both approaches?"
      },
      {
        "user": "teedty1",
        "created_at": "2018-02-26T13:34:21Z",
        "body": "I think we can close this.  I was able to work out a way using some of the suggestions here and in Gitter.  I added methods into my Record grain that can either load directly from DynamoDB or receive byte[] for when loading in bulk.  Thanks everyone for your suggestions."
      }
    ]
  },
  {
    "number": 3979,
    "title": "When is version 2.0 expected to be used in a production environment? We are now new system development, intended to be applied, if the time is too long, we can only choose other",
    "created_at": "2018-02-07T02:08:14Z",
    "closed_at": "2018-03-01T11:08:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3979",
    "body": "When is version 2.0 expected to be used in a production environment? We are now new system development, intended to be applied, if the time is too long, we can only choose other",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3979/comments",
    "author": "lfzm",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-02-07T17:54:14Z",
        "body": "Current beta3 can be used in a production environment. Upcoming rc1 (days out) will be even more so, will all new configuration APIs completed."
      }
    ]
  },
  {
    "number": 3924,
    "title": "I would like to ask, each request to call Grain can be viewed in EventSourcing?",
    "created_at": "2018-01-29T09:59:57Z",
    "closed_at": "2018-01-31T02:27:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3924",
    "body": "",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3924/comments",
    "author": "lfzm",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-01-29T19:40:08Z",
        "body": "It is the responsibility of a grain to turn incoming calls into an Event Sourcing style stream of updates to its state. There is no built-in mechanism in Orleans that would do that."
      },
      {
        "user": "lfzm",
        "created_at": "2018-01-30T02:40:02Z",
        "body": "@seralexeev Will Orleans.EventSourcing what is the use of this?"
      },
      {
        "user": "lfzm",
        "created_at": "2018-01-30T03:09:27Z",
        "body": "@sergeybykov\r\nSorry, I am a beginner, effective problem is very elementary, please excuse me.\r\nThe call between Grain, the client's request can be stored as a log?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-01-30T16:47:35Z",
        "body": ">Will Orleans.EventSourcing what is the use of this?\r\n\r\nOrleans.EventSourcing is *a* way to implement event sourcing of grain state. But there are other ways to do that in the application logic if needed.\r\n\r\n>Sorry, I am a beginner, effective problem is very elementary, please excuse me.\r\n\r\nNo need to apologize at all.\r\n\r\n>The call between Grain, the client's request can be stored as a log?\r\n\r\nIt can be stored as an event in a log, but that's the responsibility of the application code. Orleans doesn't do anything for that by itself."
      },
      {
        "user": "lfzm",
        "created_at": "2018-01-31T01:30:40Z",
        "body": "@sergeybykov Are there any specific examples of the lolo.eventsourcing?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-01-31T01:46:23Z",
        "body": "Have you looked at dotnet.github.io/orleans/Documentation/Event-Sourcing/Overview.html?"
      },
      {
        "user": "lfzm",
        "created_at": "2018-01-31T02:27:43Z",
        "body": "@sergeybykov Thank you, a lot of benefits"
      }
    ]
  },
  {
    "number": 3903,
    "title": "how to use IClusterClient ",
    "created_at": "2018-01-25T02:41:41Z",
    "closed_at": "2018-01-25T06:23:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3903",
    "body": "1.Create a static IClusterClient, all use it. ex: static IClusterClient clusterClient = clusterClient.Connect().Wait();\r\n\r\n2.or each client's method build a instance (IClusterClient clusterClient=IClientBuilder.Build() cost 0.5second),\r\nthen clusterClient.Connect()-> todo->clusterClient.Dispose(),  \r\nnext time IClusterClient clusterClient=IClientBuilder.Build()  clusterClient.Connect()-> todo->clusterClient.Dispose()\r\n\r\nWhich one? or other?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3903/comments",
    "author": "Qoooooooooooo",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2018-01-25T03:27:35Z",
        "body": "Use **1**. Share a single client.\r\nBuild & Connect the client when the app starts and stop it when the application finishes."
      },
      {
        "user": "Qoooooooooooo",
        "created_at": "2018-01-25T06:23:55Z",
        "body": "@ReubenBond thx:)"
      }
    ]
  },
  {
    "number": 3847,
    "title": "Dependency Injection in ASP.NET Core",
    "created_at": "2018-01-10T11:04:51Z",
    "closed_at": "2018-01-11T02:31:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3847",
    "body": "Hi there .. for orleans 2.0, what I should register to IServiceCollection? ClientBuilder? what will be its lifetimes? Transient or Scoped or Singleton? Thanks for help.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3847/comments",
    "author": "darting",
    "comments": [
      {
        "user": "alirezajm",
        "created_at": "2018-01-10T15:46:38Z",
        "body": "From my short experience with orleans:\r\nWithin a grain the scope is the lifetime of the grain activation.\r\n\r\nSo as the grains will live a long time normally (2 hours I believe is the default), which means the same instance will process requests, the services are injected only once per activation (If you're doing constructor injection). And when you resolve services within a grain yourself you'll get the same instance if you register them as scoped. So it's \"a little\" different compared to per request scopes like in asp.net mvc."
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-01-10T21:38:41Z",
        "body": "The lifetime is whatever you decide: Singleton, Scoped (per-activation), or Transient\r\n\r\nAs for what you should register to: there is only one IServiceCollection per ClientBuilder or SiloHostBuilder, so it doesn't matter how you register a service."
      },
      {
        "user": "SebastianStehle",
        "created_at": "2018-01-10T21:50:17Z",
        "body": "I think the question was, what he should register TO the asp.net core application.\r\n\r\nI would register the IClusterClient as Singleton to the Asp.Net Core DI. "
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-01-10T22:10:54Z",
        "body": "Oh, got it!\r\n\r\nYes, register the `IClusterClient` as a singleton.\r\nOptionally also register it as `IGrainFactory` in case that's all you need."
      },
      {
        "user": "SebastianStehle",
        "created_at": "2018-01-10T22:23:57Z",
        "body": "The `IGrainFactory` is also nice for co-hosting. Then you have 2 DI containers. One for the Silo and the other one for the asp.net part. But I need to access the grains from both parts. The IGrainFactory is a common interface and therefore you do not have to care, whether you are in the Silo or not."
      },
      {
        "user": "darting",
        "created_at": "2018-01-11T02:09:39Z",
        "body": "Hey all, got it .. thanks"
      }
    ]
  },
  {
    "number": 3827,
    "title": "Reentrant methods",
    "created_at": "2017-12-31T09:05:50Z",
    "closed_at": "2018-01-03T21:43:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3827",
    "body": "Is there a way to mark a single method as reentrant instead of marking the whole grain with [Reentrant]?\r\nFrom reading a bit it seemed that marking a method with [Readonly] should do that but it doesn't (at least not in v1.5.3).\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3827/comments",
    "author": "Gabrn",
    "comments": [
      {
        "user": "sebastianburckhardt",
        "created_at": "2018-01-02T17:55:31Z",
        "body": "You can put the attribute `[AlwaysInterleave]` on a grain interface method.\r\nIt allows the marked method to interleave with any other method.\r\n"
      }
    ]
  },
  {
    "number": 3822,
    "title": "Best practices for IO intensive stateless workers",
    "created_at": "2017-12-25T20:28:20Z",
    "closed_at": "2018-01-04T10:45:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3822",
    "body": "Suppose you have a message queue, and these messages are processed using stateless workers subscribing to a stream that all lead to some IO work.\r\nThe Orleans task scheduler will execute each worker activation code in turns, which is good in general but in case of heavily IO intensive work this will quickly become a bottleneck.\r\n\r\nQuick math:\r\nSay 40 activations with an average of 10ms IO wait for each message leads to 4000 message/sec throughput.\r\nThough in practice I reached a far smaller number and that 10 milliseconds can be much higher.\r\n\r\nOne way would be to increase the number of workers. Let's say you have 100ms of IO wait. To make sure you respond in just about 100ms while having 1000 messages pushed in the queue every second, you will need 1000 activations.  Let's say 10k, you'll need 100k activations and so on.\r\nI understand having a lot of grains is kinda the point of Orleans but this scenario can be solved with much less overhead (almost shouting on \"much\") and is pretty common.\r\n\r\nThe other way is obviously to break out of Orleans task scheduler to run these jobs on another scheduler. But what if you need the result of that IO work?\r\n\r\nI couldn't find any suggestions about this on the web. So I'm looking for a better approach to this problem here or maybe if lucky, support for non-turn-based-stateless-workers 😊 (in form of instructing the framework to run certain types of grains using another task scheduler, I would think 🤔 ).\r\n\r\n_To be clear I'm talking about asynchronous IO here._",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3822/comments",
    "author": "alirezajm",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-01-03T21:46:34Z",
        "body": ">Say 40 activations with an average of 10ms IO wait for each message leads to 4000 message/sec throughput.\r\n\r\nThis is true if the activations are non-reentrant (which is the default). If you make them reentrant, they can process many more messages while awaiting the 10ms IO calls."
      },
      {
        "user": "alirezajm",
        "created_at": "2018-01-04T10:45:20Z",
        "body": "I thought that would be the case with reentrant grains and I didn't see any performance gain while I tested it. It was probably something else causing the poor performance, will try to find the problem and benchmark again.\r\nThanks for the response 👍 "
      }
    ]
  },
  {
    "number": 3812,
    "title": "What is the difference between AddAzureQueueStreamProvider and AddAzureQueueStreamProviderV2?",
    "created_at": "2017-12-21T01:16:56Z",
    "closed_at": "2018-01-03T19:23:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3812",
    "body": "In Orleans.Streaming.AzureStorage, there are 2 confusing extensions:\r\n\r\n- AddAzureQueueStreamProvider\r\n- AddAzureQueueStreamProviderV2\r\n\r\nWhat are the differences? Is V2 superseding the other one? If I just start to use Orleans Stream, should I use V2?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3812/comments",
    "author": "Kimserey",
    "comments": [
      {
        "user": "jason-bragg",
        "created_at": "2017-12-21T22:13:47Z",
        "body": "The serialization of messages in azure stream provider initially used the fallback serializer, and hence couldn't take advantage of serialization features provided by our custom serialization.  This was, in a way, a bug as we'd intended it to use our custom serialization.  We could not simply 'fix' the bug, however, because it was already in use in many production environments, which would break if we changed the serialization format.\r\n\r\nInstead, we refactored the provider to support a plugable data adapter responsible for serialization, so the old format could continue to be supported, a new 'fixed' serialization could be introduced, and user defined serialization could be used.\r\n\r\nVersion 2 use a data adapter which uses generated seriazers, as was originally intended.\r\n\r\nIt should be noted that this was an issue because our serialization does not support versioning or format changes, and this is still the case.  If you expect to make changes to your streamed data over time, you may want to consider developing your own data adapter to control and version the data as needed."
      }
    ]
  },
  {
    "number": 3740,
    "title": "Differences between AddApplicationPart and AddApplicationPartsFromReferences in builders Orleans v2.0.0-beta1",
    "created_at": "2017-12-03T03:26:50Z",
    "closed_at": "2017-12-05T22:45:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3740",
    "body": "In Orleans v2.0.0-beta1, I am confused by the two extensions found In the `ISiloHostBuilder` extension and `IClientBuilder` extension:\r\n- `AddApplicationPart` \r\n- `AddApplicationPartsFromReferences` \r\n\r\nBoth take an assembly as input but in the samples only `AddApplicationPartsFromReferences` is used.\r\n\r\n__What are the differences between both of the functions and which should be used in which circumstances?__",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3740/comments",
    "author": "Kimserey",
    "comments": [
      {
        "user": "jdom",
        "created_at": "2017-12-05T22:45:05Z",
        "body": "Hi @Kimserey:\r\n- `AddApplicationPart` will just add the passed in assembly as an application part (and discover grains and serializers only in that one). \r\n- `AddApplicationPartsFromReferences` will add the passed in assembly, as well as the (deep) references of that assembly. This one is probably the one you want to use, as the scanning is very fast regardless. It's just checking for an assembly level attribute in each assembly, and if it doesn't contain anything Orleans related, it will just skip it.\r\n\r\nThe first one is just the basic logic, but you'll very likely use the second one, and only in very particular unit testing scenarios or something where you want to have very strict control of what you load, you might want to do something different (unlikely, but possible)."
      }
    ]
  },
  {
    "number": 3714,
    "title": "Muliti-cluster high availability",
    "created_at": "2017-11-27T17:00:07Z",
    "closed_at": "2018-01-24T01:27:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3714",
    "body": "We want to set up another cluster for high availability, We thought about using the multi cluster support for that.\r\n\r\nLets say i have two clusters joined in a multi cluster, lets say one is in east-us and the other is in west-us.\r\nBy default grain activation will be placed randomly in both clusters right? \r\nSo if i'm directing all traffic to east us, and a grain in east-us is activated and publishes a message in a stream, Grains will be activated in west-us to handle that message too right?\r\n\r\nIs there a way to tell Orleans to prefer staying in one cluster ?\r\n\r\nThat way we can enjoy good latency in the usual case, and when the main cluster is down for what ever reason, it will start using the secondary cluster.\r\n\r\nIs this something that is supported? How is high availability usually achieved? \r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3714/comments",
    "author": "talarari",
    "comments": [
      {
        "user": "sebastianburckhardt",
        "created_at": "2017-11-27T17:51:24Z",
        "body": "If you are using the  `[GlobalSingleInstance]` attribute on the grain class, its instances are activated in the cluster where it is *first accessed*. \r\n\r\nSo, if you are accessing all grains in east-us in the normal case, no grains are activated in west-us.\r\n"
      },
      {
        "user": "talarari",
        "created_at": "2017-11-28T09:09:04Z",
        "body": "Great, and that is true for streams as well as grain calls?"
      },
      {
        "user": "sebastianburckhardt",
        "created_at": "2017-11-28T16:44:48Z",
        "body": "Yes, I believe so, though I haven't worked with streams much myself, so maybe someone else can confirm.\r\n\r\nFrom what I understand, a stream activates a grain only if that grain has an implicit subscription. I am assuming that this activation proceeds via the normal grain activation procedure which uses the GlobalSingleInstance protocol.\r\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-11-28T23:56:11Z",
        "body": ">From what I understand, a stream activates a grain only if that grain has an implicit subscription.\r\n\r\nImplicit or explicit. Conceptually, stream events are handled just like other calls to grains.\r\n\r\nHowever, one needs to be more careful with streams and multi-clusters. For example, it would be rather confusing if more than one cluster were to pull events from the same set of queues and sending duplicates of every event, most of them going across the inter-cluster links. But if only one cluster pulls events, then availability will suffer if that cluster goes down. There's currently no support for inter-cluster coordination/balancing of stream pulling agents."
      }
    ]
  },
  {
    "number": 3712,
    "title": "How to write a circuit breaker in orleans",
    "created_at": "2017-11-27T02:06:11Z",
    "closed_at": "2017-11-29T02:53:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3712",
    "body": "Is there a demo?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3712/comments",
    "author": "Qoooooooooooo",
    "comments": [
      {
        "user": "jdom",
        "created_at": "2017-11-27T19:49:48Z",
        "body": "You mean against external services? It should be no different than from non-Orleans code. You can use Polly or some other library normally. Just be conscious of the total time it can take for the call to complete, as by default the grain call will time-out after 30 seconds. Total time starts ticking from the client perspective the moment it sent the request, so on a hot grain it means that even if total cut-off time for the retries and circuit breaker has calls taking 10 seconds in normal conditions, but you have more than 3 calls enqueued for that grain, then some calls might start timing out, even if they didn't start executing on the grain."
      },
      {
        "user": "Qoooooooooooo",
        "created_at": "2017-11-29T02:26:40Z",
        "body": "@jdom thx:)"
      },
      {
        "user": "ccerrato147",
        "created_at": "2020-05-28T03:40:26Z",
        "body": "> You mean against external services? It should be no different than from non-Orleans code. You can use Polly or some other library normally. Just be conscious of the total time it can take for the call to complete, as by default the grain call will time-out after 30 seconds. Total time starts ticking from the client perspective the moment it sent the request, so on a hot grain it means that even if total cut-off time for the retries and circuit breaker has calls taking 10 seconds in normal conditions, but you have more than 3 calls enqueued for that grain, then some calls might start timing out, even if they didn't start executing on the grain.\r\n\r\nFor calls between grains is the a circuit breaker not needed or implemented already inside Orleans?"
      },
      {
        "user": "jdom",
        "created_at": "2020-05-28T14:16:51Z",
        "body": "Retries is built-in. Circuit breaker isn't needed since the cluster will self-heal and reactivate a grain in another silo if the original activation is unreachable due to a dead silo."
      },
      {
        "user": "ccerrato147",
        "created_at": "2020-05-28T19:48:35Z",
        "body": "> Retries is built-in. Circuit breaker isn't needed since the cluster will self-heal and reactivate a grain in another silo if the original activation is unreachable due to a dead silo.\r\n\r\nThanks!"
      }
    ]
  },
  {
    "number": 3664,
    "title": "Orleans how to retrieve database timeout and implementation of eventually consisten.",
    "created_at": "2017-11-11T16:41:07Z",
    "closed_at": "2018-01-24T01:19:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3664",
    "body": "Orleans how to retrieve database timeout and implementation of eventually consisten.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3664/comments",
    "author": "Qoooooooooooo",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2017-11-21T22:18:27Z",
        "body": "Can you provide more details? It's not clear to me what you mean by the database timeout and what's the connection with eventual consistency."
      },
      {
        "user": "Qoooooooooooo",
        "created_at": "2017-11-27T02:11:22Z",
        "body": "A database operation timed out in grain，simple massage stream not to retrieve"
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-11-30T22:56:59Z",
        "body": "I don't believe there's a simple recipe for dealing with timeouts and retires. One tool we use is `.WithTimeout` extension method that allows to limit wait time for an async operation, so that it can be failed and retired. But retrying an operation that may or may not succeeded is tricky, unless the operation is idempotent. "
      }
    ]
  },
  {
    "number": 3655,
    "title": "Prevent deactive on activation garbage collection",
    "created_at": "2017-11-09T08:40:13Z",
    "closed_at": "2017-12-03T05:17:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3655",
    "body": "I have a problem about grain deactive \r\nexample:\r\n```\r\npublic class RoomGrain : Grain, IRoomGrain\r\n    {\r\n        private List<Player> players = new List<Player>();\r\n        // ...\r\n        public Task OnDeactivateAsync()\r\n        {\r\n            if (players.Count > 0) {\r\n\r\n                /// How to prevent deactive  ???  DelayDeactivation(TimeSpan) cannot  ;\r\n\r\n                return Task.CompletedTask;\r\n            } else\r\n                return base.OnDeactivateAsync();\r\n        }\r\n    }\r\n```\r\nHas some approach prevent grain deactive on activation garbage collection ,  except  configure grain agelimit ?\r\n\r\nMy current solutions is that use a grain Timer to manage the delay deactivation logic , but it's cause more and more grain Timer.\r\n\r\nI suggest using blow code in abstract grain class : \r\n```\r\n public abstract class Grain : IAddressable, ILifecycleParticipant<IGrainLifecycle>\r\n        {\r\n            /// if return false prevent deactive\r\n            public virtual async Task<bool> OnDeactiveAsync()\r\n            {\r\n\r\n            }\r\n        }\r\n```\r\nor using a ManualAGCAttribute class to skip activation garbage collection \r\n```\r\n[ManualAGC]\r\npublic class RoomGrain : Grain , IRoomGrain\r\n{\r\n     private List<Player> players = new List<Player>();\r\n\r\n     public Task RemovePlayer(Player player)\r\n     {\r\n          players.Remove(player);\r\n          if(players.Count <=0)  this.DeactivateOnIdle();\r\n          return Task.CompletedTask;\r\n     }\r\n}\r\n``` ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3655/comments",
    "author": "bluexo",
    "comments": [
      {
        "user": "AwsomeCode",
        "created_at": "2017-11-09T09:05:29Z",
        "body": "Basically you don't have to keep the grain active if its ideal. I recommend you to change your logic."
      },
      {
        "user": "jokin",
        "created_at": "2017-11-13T18:45:55Z",
        "body": "You can use DelayDeactivation, just not in the OnDeactivateAsync method. You should call whenever your grain starts, and it should work just like your \"ManualAGC\" attribute. "
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-11-21T22:14:06Z",
        "body": "@bluexo I believe the existing mechanisms mentioned above provide enough options for delaying deactivation when desired. `OnDeactivateAsync` shouldn't be used for trying to manage activation lifecycle or for any significant logic."
      },
      {
        "user": "bluexo",
        "created_at": "2017-11-22T05:10:17Z",
        "body": "@sergeybykov  I have a lot of grains need delay dactiveation and I have to implements the delaying logic everyone , why not add a mechanism like `\"ManaulAGCAttribute\"` to skip activation garbage collection without config `Agelimit` ? "
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-11-22T18:00:41Z",
        "body": ">why not add a mechanism like \"ManaulAGCAttribute\" to skip activation garbage collection without config Agelimit ?\r\n\r\n`ManaulAGCAttribute` would be equivalent to setting age limit to infinity (or a very long time), right? If so, then these two approaches are functionally identical. My preference to sticking with the age limit mechanism has the following reasons:\r\n\r\n1) Age limits are set at configuration time, and hence can be changed without recompiling grain code.\r\n2) Grains are virtual actors, and having them activated forever (as opposed to having a long age limit) goes ideologically against the virtual nature of them.\r\n3) Providing two mechanisms to achieve the same goal always adds some degree of confusion."
      }
    ]
  },
  {
    "number": 3648,
    "title": "[Question] Returning Tasks instead await",
    "created_at": "2017-11-07T22:44:17Z",
    "closed_at": "2017-11-09T21:21:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3648",
    "body": "I was wondering how returned Tasks in orleans grains behalf.\r\nAre they beeing awaited by orleans internaly before unlocking the grain for other requests? Would it break the single threaded gaurantee? Would task operations become interleaved?\r\n\r\nEg.:\r\n\r\n```\r\nclass MyGrain : Grain, IMyGrain\r\n{\r\n    public Task Foo() {\r\n        return Bar(); \r\n    }\r\n    public async Task Bar() {\r\n        await x(); \r\n        await y();\r\n    }\r\n}\r\n```\r\n\r\n\r\nIf another Grain or Client would call `await GetGrain<IMyGrain>(id).Foo()` would execution inside MyGrain be the same as if Foo() would have been async and Bar() awaited?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3648/comments",
    "author": "Xanatus",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2017-11-08T18:42:35Z",
        "body": "Execution will be the same in both cases."
      },
      {
        "user": "jdom",
        "created_at": "2017-11-09T21:21:10Z",
        "body": "the `async` keyword is syntactic sugar, but the end result is that both grain methods return a `Task` that completes when the `Bar` task completes in the first example or when the `y` task completes in the second."
      }
    ]
  },
  {
    "number": 3629,
    "title": "when the 2.0 release？",
    "created_at": "2017-11-02T09:04:15Z",
    "closed_at": "2017-11-29T00:09:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3629",
    "body": "when the 2.0 release？  please ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3629/comments",
    "author": "zhanlanghun",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2017-11-03T23:08:43Z",
        "body": "We plan at least 4 weeks for the beta. And there's still some work to finish before then."
      }
    ]
  },
  {
    "number": 3545,
    "title": "Controll staging production swap",
    "created_at": "2017-10-13T12:40:51Z",
    "closed_at": "2017-11-30T22:07:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3545",
    "body": "The docs say if you deploy a staging silo and also use a minimum version placement strategy, then untill you direct traffic to the staging silo - no activations will be created there.\r\n\r\nSo basically you can run some tests on the staging silo and then direct all traffic to it (swap).\r\n\r\nFrom what i understand the new silo will have no activations because of the minimum version placement strategy, meaning old clients will request v1 grains and none of those exist in the staging silo.\r\n\r\nMy question is, what happens if i only bump the version on one grain from v1 to v2 (since its the only one changed, lets say i added a method)?\r\nThe staging silo in this case will have v1 for all other grains, so they could start getting activations for v1 the second they the silo goes online.\r\nThis means i cant controll when the swap happens (which should be after i validate the new silo).\r\n\r\nIs my understanding correct? Or am i missing something?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3545/comments",
    "author": "talarari",
    "comments": [
      {
        "user": "benjaminpetit",
        "created_at": "2017-10-30T15:59:36Z",
        "body": "> From what i understand the new silo will have no activations because of the minimum version placement strategy, meaning old clients will request v1 grains and none of those exist in the staging silo.\r\n\r\nCorrect\r\n\r\n> My question is, what happens if i only bump the version on one grain from v1 to v2 (since its the only one changed, lets say i added a method)?\r\nThe staging silo in this case will have v1 for all other grains, so they could start getting activations for v1 the second they the silo goes online.\r\nThis means i cant controll when the swap happens (which should be after i validate the new silo).\r\n\r\nLet me rephrase so I am sure I understood:\r\n\r\nIn your cluster, your Silo 1 contains grains A(v1) and Grain B(v2). You deploy Silo 2 with A(v1) and B(v2). If the strategy use is \"minimum version placement \" then grains of type A could still be placed on Silo 1 and 2. SInce you didn't changed the version, Orleans consider this to be safe.\r\n\r\nIf you want to isolate the new silo for validation, you should bump the version of grain of type A too.\r\n\r\n"
      }
    ]
  },
  {
    "number": 3507,
    "title": "What is the purpose of specifying multiple seed nodes?",
    "created_at": "2017-10-06T01:44:25Z",
    "closed_at": "2017-11-30T22:04:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3507",
    "body": "In my development scenario with 2 silos, I am using MembershipTableGrain as Livenesstype and have only 1 seed node pointing to my primary node with the second silo being secondary node.\r\n\r\nI can see in Globals that seed node is an array of addresses therefore **what is the purpose of specifying multiple seed nodes?**",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3507/comments",
    "author": "Kimserey",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2017-10-06T23:48:02Z",
        "body": "Support for multiple seed nodes is there for historical reasons. In early prototypes of Orleans we had that. I'm almost sure it doesn't work anymore with more than one seed (a.k.a. primary) node configured. Should probably remove that in 2.0."
      },
      {
        "user": "xiazen",
        "created_at": "2017-10-07T00:15:51Z",
        "body": "It is confusing indeed. So We are thinking about reducing the confusion there by changing `List<SeedNode> SeedNodes` to be `IpEndpoint SeedNode` in 2.0. \r\n\r\nBut we are also migrating off GlobalConfiguration in 2.0, so that GlobalConfiguration will become obsolete after 2.0. So there maybe not much value in 2.0 to fix it. \r\n\r\nOr there's a third option: update the documentation on SeedNodes and warn user to not use more than one seed nodes. \r\n\r\nWhich one do you like personally? \r\n"
      },
      {
        "user": "Kimserey",
        "created_at": "2017-10-07T02:31:30Z",
        "body": "> Support for multiple seed nodes is there for historical reasons. In early prototypes of Orleans we had that. \r\n\r\nI got confused because I thought that if the seed node stated as primary would go down, the membership state together with the primary status would be passed to the next seed node alive.\r\n\r\n> Or there's a third option: update the documentation on SeedNodes and warn user to not use more than one seed node.\r\n\r\nI think this would be enough since GlobalConfiguration will be obsolete."
      },
      {
        "user": "gabikliot",
        "created_at": "2017-10-11T17:56:09Z",
        "body": "What Sergey said: we should remove seed nodes and move to a single primary node."
      },
      {
        "user": "xiazen",
        "created_at": "2017-10-11T18:17:36Z",
        "body": "But `GlobalConfiguration` are going to be deprecated in 2.0, its settings will be break down into a collection of smaller options (Microsoft.Extensions.Options) .  Do you still think it is worthy to fix it? "
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-11-30T22:04:11Z",
        "body": "Since we are deprecating `GlobalConfiguration` in 2.0, it doesn't seem like a worthwhile effort to change it with regards to seed/primary nodes."
      }
    ]
  },
  {
    "number": 3462,
    "title": "Best practices for bootstrapping many grains",
    "created_at": "2017-09-27T20:38:26Z",
    "closed_at": "2017-11-03T23:22:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3462",
    "body": "Hello,\r\n\r\nFirst, hats off to the Orleans team.  Orleans is a fantastic framework that our team feels fits our needs well.\r\n\r\nThat said, we are curious about the best practices for bootstrapping a large number of grains.  In our use case, we have ~30K grains we need to activate before our silo is finished starting.  Each of these grains represents a record in a legacy database.  We will also have new records/grains added throughout the silo/cluster run-time. For now, assume that updates/deletes are commuted correctly to the legacy system.\r\n\r\nWe are being forced to maintain BC with the legacy system, as our new Orleans-powered system will run alongside the legacy system for a brief period.  Our primary problem with this constraint is the dependence on SQL Server and resulting latency.\r\n\r\nFor clarification, we intend the term \"initialization\" to mean \"the first time a grain is activated in a given silo/cluster up-time period\".\r\n\r\nWe have tried the following methods for bootstrapping and met mixed results:\r\n- Placing initialization logic with direct SQL in the grains' OnActivateAsync(): results in 1 SQL request / grain. which is too much stress on our SQL server and too slow.\r\n- Adding a method on the grain to set initial state, then fetching all records and activating all the grains by setting this initial state: Only one SQL call, but we can't differentiate between initialization and subsequent re-activations.\r\n- Calling proxy grain(s) from the grains' OnActivateAsync() (proxy grain fetches all / subset of records on activate): SQL traffic is much less, but subsequent re-activations would fetch a stale record, and introducing a timer to refresh the records does not eliminate this possibility.\r\n\r\nThus, here is our question: **What is the best practice for bootstrapping/initializing these grains**?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3462/comments",
    "author": "kehigginbotham",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2017-10-02T17:09:28Z",
        "body": "Thank you for your kind words!\r\n\r\nI'm not sure I fully understand the need for\r\n>~30K grains we need to activate before our silo is finished starting\r\n\r\nAre these grains unusable individually unless they all are activated? The general model in Orleans is that grains are mostly independent from each other, and have their own activation-deactivation lifecycles. I wonder if all these 30K grains need to be activated together, does it make sense to model them as individual grains, and not a single grain or a small number of grains (for example, 100 grains each holding 300 items).\r\n\r\nIf you do need to model these items as 30K grains but with lower load on SQL, I suspect a variation of your method 3 can work. A local proxy grain could batch reads and cache the data in memory. You could eliminate staleness by invalidating records in the local cache before performing an update.\r\n\r\nThat being said, more details about the specifics of the requirements should help with suggesting the right pattern."
      },
      {
        "user": "kehigginbotham",
        "created_at": "2017-10-02T19:38:35Z",
        "body": "Thanks for the response @sergeybykov.  I will endeavor to be more specific.\r\n\r\nThe ~30K grains individually correspond to discrete domain models - specifically, each grain models an \"inventory item\" in our \"inventory\".  Each \"inventory item\" is individually mutable, and they are purely independent of each other.\r\n\r\nThe reason we need to activate them all before out silo is finished starting is exclusively UX.  When a user loads the front-end application (which in turn fetches the data from an Orleans client in Web Api), they are presented with a list of said \"inventory items\" according to a \"filter\" they have control over.  This \"filter\" may include all, none, or some of the \"inventory items\".  After silo startup, _if the \"inventory items\" are not initialized during bootstrap_, the first user to load the front-end application is forced to wait ~20 seconds before any data appears in their list.\r\n\r\nMethod 3 is what we've gravitated toward, especially since the total number of \"inventory items\" can fluctuate wildly throughout the day.  We also intend to spread the load across multiple re-entrant proxy grains, each responsible for a subset of \"inventory\".  Our only concern with this method is that the \"inventory items\" can be modified at the database level by the legacy system, out of band with the new system (yes, it is as ugly as it sounds). We aim to partially address that issue by refreshing the proxy grain(s) every 5 seconds or so and updating the proxy-cached \"inventory item\" from SQL prior to any update in the new system.\r\n\r\nThanks again for the feedback.  We appreciate any tips, recommendations, etc. that you all can offer.  Hopefully this discourse will help others in the future."
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-10-07T00:36:45Z",
        "body": "Thanks for the details. The background is more clear to me now. May I ask a stupid question though?\r\n>When a user loads the front-end application (which in turn fetches the data from an Orleans client in Web Api), they are presented with a list of said \"inventory items\" according to a \"filter\" they have control over. This \"filter\" may include all, none, or some of the \"inventory items\". After silo startup, if the \"inventory items\" are not initialized during bootstrap, the first user to load the front-end application is forced to wait ~20 seconds before any data appears in their list.\r\n\r\nDoes the UI immediately show data (or its derivatives) for all 30K inventory items, and no pagination is involved?\r\n\r\n>Our only concern with this method is that the \"inventory items\" can be modified at the database level by the legacy system, out of band with the new system (yes, it is as ugly as it sounds). We aim to partially address that issue by refreshing the proxy grain(s) every 5 seconds or so and updating the proxy-cached \"inventory item\" from SQL prior to any update in the new system.\r\n\r\nIf the underlying state can be mutated externally and the max staleness you can afford is 5 seconds, then the situation indeed looks tough. I can only think of potential optimizations. For example, make the proxy grains stateless workers to eliminate cross-silo traffic to them at the cost of duplicating the cached state in every silo (if memory and global consistency isn't a concern)."
      },
      {
        "user": "kehigginbotham",
        "created_at": "2017-10-10T14:07:06Z",
        "body": "Our UX guy has been pre-loading all 30K inventory items so that filtering, et. al. does not introduce any visual latency.  This solution obviously does not scale, and our team is working to gently prod our UX guy in that direction.  Even with the pagination, we hope to minimize latency on the client by having the next set of requested inventory items already initialized (which we would if all 30K are initialized).\r\n\r\nIndeed, our situation is a tough one.  We're currently exploring your stateless worker suggestion, but I fear global consistency will be a necessity.  We have had some success in expanding our proxy grains to hold ~1K inventory items each with periodic polling.  I'll report back periodically with our findings as we scale up our application.\r\n\r\nThanks!"
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-11-03T23:22:08Z",
        "body": "I'll close this for now, as I don't anything for us to do here. Feel free to reopen if needed."
      }
    ]
  },
  {
    "number": 3461,
    "title": "Orleans 1.3.0, Grain factory instance across app domains ",
    "created_at": "2017-09-27T19:20:24Z",
    "closed_at": "2017-11-03T23:20:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3461",
    "body": "Hello everyone,\r\n\r\nI have a use case where I need to sandbox a user request in another app domain from within a silo.\r\nHowever, the method to be sandboxed has a dependency on grain factory instance to be passed in to the method from within the silo. However since grain factories  are not serializable it seems a straightforward approach does not exist. \r\n\r\nPlease does anyone have any ideas as to how to accomplish this,  I. E marshal grain calls across app domains ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3461/comments",
    "author": "edikep2000",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2017-10-02T17:14:20Z",
        "body": "Can't you instead of passing a grain factory into the sandbox app domain give it a custom `MarshalByRefObject` object and invoke respective calls in the silo app domain? I don't think trying to marshal a grain factory will work. And app domains are largely going away in .NET Core anyway."
      }
    ]
  },
  {
    "number": 3435,
    "title": "Does the Orleans support the circuit-breaker",
    "created_at": "2017-09-25T09:21:33Z",
    "closed_at": "2017-09-26T00:57:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3435",
    "body": ":)",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3435/comments",
    "author": "Qoooooooooooo",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2017-09-25T15:22:09Z",
        "body": "There's no built-in support for circuit breaker in Orleans. It's application's responsibility to implement the pattern if needed."
      },
      {
        "user": "Qoooooooooooo",
        "created_at": "2017-09-26T00:57:41Z",
        "body": "oh, thx:)"
      }
    ]
  },
  {
    "number": 3417,
    "title": "When to use injected service instead of a worker",
    "created_at": "2017-09-19T09:00:46Z",
    "closed_at": "2017-09-22T05:43:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3417",
    "body": "I'm confused with workers and injected service.\r\nIt seems like that most workers in my project could be replaced by DI services, for example, I have a password hasher in my project, should it be a worker or DI service ?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3417/comments",
    "author": "suraciii",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2017-09-19T09:05:40Z",
        "body": "Injecting the password hasher is a fine approach 👍 Personally, I used workers for services like SMS, Email, push notifications (eg, GCM, APN). Those services could also have been injected, so perhaps that's not much guidance.\r\n\r\nOne case for using a `[StatelessWorker]` instead is when you have a fairly long-running process (sending 50 fire-and-forget push notifications, for example) and you want the calling grain to be free to process other requests while that's occurring."
      },
      {
        "user": "suraciii",
        "created_at": "2017-09-22T05:43:18Z",
        "body": "@ReubenBond thanks for your response"
      }
    ]
  },
  {
    "number": 3336,
    "title": "grain distribution in silo",
    "created_at": "2017-08-23T12:26:36Z",
    "closed_at": "2017-09-22T23:01:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3336",
    "body": "Cloud service is running with four instances. In cloud service starting, one or two instances are taking some time start.  In that time, grains activated in active cloud service instances. \r\nSo grains didn't distributed equally in silos. One silo was fully loaded. Other one was free. \r\n\r\nHow can i ensure that grain distributed equally in silos?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3336/comments",
    "author": "balakannanmca",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2017-08-23T16:53:03Z",
        "body": "When new silos join a cluster, there is no forced redistribution of already activated grains. Only new activation get distributed across all silos. Over time, as new grains get activated and idle ones get collected, you'll reach a balanced distribution across all silos.\r\n\r\nYou can choose to add a `[ActivationCountBasedPlacement]` attribute to your grain classes to expedite balancing. It makes all new activations to go to silos with lower counts of grains. There's a danger with that though of overloading the newly started silos by putting a disproportional share of new, and hence actively used, grains to a small number of newly joined silos and overloading them. That's why the default placement strategy is more conservative."
      },
      {
        "user": "elqueffo",
        "created_at": "2017-08-30T09:21:20Z",
        "body": "Is there a way to access activation counts per silo of a grain? This way the grain could check \"balance\" and decide to DeactivateOnIdle itself to be relocated."
      },
      {
        "user": "yevhen",
        "created_at": "2017-09-01T19:45:22Z",
        "body": "> Is there a way to access activation counts per silo of a grain? This way the grain could check \"balance\" and decide to DeactivateOnIdle itself to be relocated.\r\n\r\n:+1: Will save us some additional lines of code. Smth like `ManagementGrain.GetActivationCount(Silo.CurrentSiloName, typeof(IGrain))`"
      }
    ]
  },
  {
    "number": 3322,
    "title": "ServerGC recommendation warning incorrect in log files",
    "created_at": "2017-08-18T12:44:22Z",
    "closed_at": "2017-09-22T18:48:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3322",
    "body": "At the top of my log files I receive this warning\r\n\r\n`[2017-08-18 12:33:06.834 GMT     6\tWARNING\t100405\tSilo\t192.168.5.182:22222]\tNote: Silo not running with ServerGC turned on or with GCLatencyMode.Batch enabled - recommend checking app config : <configuration>-<runtime>-<gcServer enabled=\"true\"> and <configuration>-<runtime>-<gcConcurrent enabled=\"false\"/>\t`\r\n\r\nI thought the recommendation was to enable both of these settings? I guess this means this warning is incorrect?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3322/comments",
    "author": "chris-eaton",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2017-08-18T15:08:42Z",
        "body": "Yes, we switched the recommendation recently in #3271, and now we'll only warn you if ServerGC is off."
      },
      {
        "user": "chris-eaton",
        "created_at": "2017-08-18T15:19:54Z",
        "body": "Sorry, setting the original message to quote hid the XML, I've switched it to code now so it shows it all."
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-08-18T15:26:32Z",
        "body": "Yes, 1.5.0 still warns you about gcConcurrent=true. But 2.0 will not anymore. We made the change after 1.5.0 was released."
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-09-22T18:48:11Z",
        "body": "Resolved via #3271."
      }
    ]
  },
  {
    "number": 3321,
    "title": "Push messages with Orleans more more slower than parallel functions",
    "created_at": "2017-08-18T01:12:18Z",
    "closed_at": "2017-09-22T22:51:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3321",
    "body": "Hi everyone, I have some questions in orleans use.\r\n\r\nNow I'm build my MessagePush service with v2.0. I choose the orleans as the base toolkit.\r\nAt first I tested that I can push 10k messges / second in redis. \r\n ```\r\n           QueueService service = new QueueService();\r\n            var tsks = Enumerable.Range(1, 10001).Select(async i =>\r\n            {\r\n                var value = \"message\";\r\n                await service.Publish(JsonConvert.DeserializeObject<TransimissionMessage>(value));\r\n                Console.WriteLine(i);\r\n            });\r\n            Task.WhenAll(tsks).Wait();\r\n```\r\n\r\nBut when i used the orleans. I have a client to push the message to silo. But it run more slow\r\nthat only have 200 messages / second in redis.\r\n\r\n```\r\n        public async Task<Result<string>> Push(Immutable<TransimissionMessage> message)\r\n        {\r\n            if (message.IsNull() || message.Value.IsNull())\r\n            {\r\n                return await Task.FromResult<Result<string>>( new Result<string>() { Status = StatusType.InvalidArguments, Summary = \"can not be null or empty\" });\r\n            }\r\n            var queue = new QueueService();\r\n            var result=await queue.Publish(message.Value);\r\n        }\r\n```\r\nIt do the same work in grain.\r\n\r\nI think the Orleans engine will store all the workitems in the bolckedcollection and the engine take all workitem in queue from  blockedcollection. The all run in threadpool.\r\nSo Why both functions has so big different?\r\nI hope you can give me some advice. Thank you.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3321/comments",
    "author": "hidavidpeng",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2017-08-18T01:15:42Z",
        "body": "@hidavidpeng could you please provide some more information? What is `QueueService`? It seems in your grain method you're creating a new one in every call and then immediately publishing to it - but does that QueueService perform some kind of network call? If so, does it need to connect or be configured?\r\n\r\nIf `QueueService` is communicating with redis, then it sounds like you're comparing:\r\n1. Performing 10K writes to redis in parallel\r\n2. Performing 10K writes to redis in serial, creating a new connection to redis each time\r\n\r\n2 will be much slower, even if you were to keep the redis connection for the lifetime of the grain activation."
      },
      {
        "user": "hidavidpeng",
        "created_at": "2017-08-18T01:31:33Z",
        "body": "@ReubenBond \r\nThank you for your reply. \r\nThe details of QueueService is get the connected redis subscribe and push the message to redis server.\r\n I realize it base stackoverflow.redis and initialize the connect when the app start. \r\nSo its only purpose is to keep thread safe.\r\n```\r\n        public QueueService()\r\n        {\r\n            \r\n\r\n            _here I only try to mapping the fresh instance which has initialized when app start_\r\n\r\n            _messageQueue = new Lazy<RedisQueue<TransimissionMessage>>(()=> { return new RedisQueue<TransimissionMessage>(RedisNodeTypes.MessagePushQueue); });\r\n        }\r\n       \r\n        public async Task<bool> Publish(TransimissionMessage message)\r\n        {\r\n            var pattern = _messageQueue.Value.Pattern;\r\n            var result = await _messageQueue.Value.Publish(pattern, \"Transimission\", message);\r\n            ...\r\n         }\r\n```\r\n\r\n\r\nAlso I can new it only once. Both them do the same work.\r\nI watched that I push 10K message in redis with only 1 second by parallel\r\nand it cost almost 20 seconds by orleans.\r\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2017-08-18T01:36:12Z",
        "body": "If I understand correctly, @hidavidpeng, you're passing messages from a client to a grain and then to redis. Grains are single-threaded, so that will be slower than pushing those messages in parallel.\r\n\r\nComparing these two methods doesn't make sense to me: is the grain only there to act as an abstraction over the Redis queue? In that case, are you calling this grain from other grains or from a client?"
      },
      {
        "user": "hidavidpeng",
        "created_at": "2017-08-18T01:52:09Z",
        "body": "@ReubenBond \r\nyes my friend.\r\nActually I have a WebAPI to the others. \r\nbelow is my code that fake 10k webapi requests. It will collect the post message and send to to my messageRouter.\r\n**my fake requests**\r\n```\r\n           Parallel.For(1, 10001, index => {\r\n                var value = \"message\";\r\n                var item = new Immutable<TransimissionMessage>(JsonConvert.DeserializeObject<TransimissionMessage>(value));\r\n                routerGrain.Push(item);\r\n            });\r\n```\r\n**my parallel way**\r\n```\r\n           Parallel.For(1, 10001, index => {\r\n                var value = \"message\";\r\n                var item = new Immutable<TransimissionMessage>(JsonConvert.DeserializeObject<TransimissionMessage>(value));\r\n                routerGrain.Push(item);\r\n            });\r\n```\r\n\r\nIt seems that i have some misunderstood of it internal realize. How can I speed it up?  Can you give me some ideas? thank you."
      },
      {
        "user": "ReubenBond",
        "created_at": "2017-08-18T01:56:00Z",
        "body": "Hi @hidavidpeng you can use multiple `[StatelessWorker]` grains with different identifiers (eg, round robin 16 grains)"
      },
      {
        "user": "hidavidpeng",
        "created_at": "2017-08-18T02:07:21Z",
        "body": "@ReubenBond  thank you for you reply.\r\nyes I have tried this function. But it only speed it up to about 1.5k/s . It also far more slower than parallel function. and event i add the [statelesswork] to 32 or more it can't speed it up again.\r\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2017-08-18T04:41:24Z",
        "body": "@hidavidpeng it will necessarily be slower.\r\nOn one hand you have:\r\n`Client` -> `Redis`\r\nOn the other hand you have:\r\n`Client` -> `Something Else` -> `Redis`\r\n\r\nNo matter what the `Something Else` is, the same calls are being made from the client to redis, but with an extra step, which is an extra network call, which will be slower."
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-08-18T15:23:19Z",
        "body": "@hidavidpeng There are potentially other factors. Are you measuring this with silo(s) and client running on the same machine? Are you running with ServerGC=true?"
      }
    ]
  },
  {
    "number": 3242,
    "title": "What is ServiceId & DeploymentId when running under Service Fabric?",
    "created_at": "2017-07-20T12:40:43Z",
    "closed_at": "2017-07-22T12:11:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3242",
    "body": "I wanted to ask what we should be setting these to be while running under service fabric? Our deployment would look something like the following. We have one silo \"Silo A\" that is responsible for grains 1 & 2. The silo will be deployed on 3 nodes in the service fabric cluster.\r\n\r\n- Node 1\r\n-- Silo A\r\n--- Grain 1\r\n--- Grain 2\r\n- Node 2\r\n-- Silo A\r\n--- Grain 1\r\n--- Grain 2\r\n- Node 3\r\n-- Silo A\r\n--- Grain 1\r\n--- Grain 2\r\n\r\nDeploymentId is required for the Azure Queue stream provider so I need to set it to something. However, i wasnt sure what the semantics were around these two values and what they control.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3242/comments",
    "author": "charleszipp",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2017-07-21T03:37:36Z",
        "body": "@charleszipp set `ServiceId` and `DeploymentId` to a value which is consistent between all silos and clients in the cluster."
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-07-21T14:51:01Z",
        "body": "`ServiceId` is supposed to stay the same across multiple deployments of the same service over time as you deploy new versions of the deployment/cluster."
      },
      {
        "user": "charleszipp",
        "created_at": "2017-07-22T12:11:12Z",
        "body": "Thanks for the responses @ReubenBond and @sergeybykov ! That gives me what i needed to know."
      },
      {
        "user": "talarari",
        "created_at": "2017-11-08T17:48:44Z",
        "body": "@ReubenBond  @sergeybykov Does DeploymentId need to be different across deployments?\r\nwhat will happen if i just set it to a hardcoded string?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-11-22T22:02:52Z",
        "body": ">@ReubenBond @sergeybykov Does DeploymentId need to be different across deployments?\r\nwhat will happen if i just set it to a hardcoded string?\r\n\r\nThe danger here is that you may end up deploying at some point have a different service/cluster with the same DeploymentId. "
      },
      {
        "user": "talarari",
        "created_at": "2017-11-22T22:10:03Z",
        "body": "Im not sure i understand what's the purpose of deployment id.\r\nWhat is it used for?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-11-22T22:24:28Z",
        "body": "It should have been caller `ClusterId` instead. It is the unique identifier of a cluster, and silos in a cluster find each other using it as a key.\r\n"
      },
      {
        "user": "talarari",
        "created_at": "2017-11-22T22:41:03Z",
        "body": "Ok that sounds more clear to me.\r\nI was under the impression that deployment id should be different between two vervsion deployments to the same cluster, something like a versionid.\r\nSo basically if its the only orleans cluster running on those machines this can just be a costant name?\r\nOr is it used for things like versioned grains and placements strategies?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-11-22T22:46:30Z",
        "body": ">So basically if its the only orleans cluster running on those machines this can just be a costant name?\r\n\r\nYes.\r\n\r\n>Or is it used for things like versioned grains and placements strategies?\r\n\r\nNo.\r\n\r\nIt's just a key for silos and clients to find each other in the membership table."
      }
    ]
  },
  {
    "number": 3132,
    "title": "[Question] Bootstrapping DI and logging",
    "created_at": "2017-06-15T13:26:27Z",
    "closed_at": "2017-06-16T16:56:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3132",
    "body": "I have a simple question: when bootstrapping my services in the `Startup` class using dependency injection I want to do some logging using Orleans logger. But how will I get a logger instance in my `ConfigureServices` method?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3132/comments",
    "author": "peter-perot",
    "comments": [
      {
        "user": "jdom",
        "created_at": "2017-06-15T16:27:29Z",
        "body": "Hmmm, interesting question, but it is currently not possible. The logging infrastructure should be configured by then, but it's not really accessible from the startup type.\r\nIf this is temporary just to troubleshoot a few things, what you can do for now is use reflection to get the logger. Note that this might not be supported in the future, especially since we are looking to migrate to `Microsoft.Extensions.Logging` in the release following 1.5 (but this hack will work in 1.5 still). Nevertheless, once we move to that, the logger will be usable when configuring the silo, so hopefully no hack will be necessary.\r\n\r\nTo get the logger via reflection, you'd have to do something like this:\r\n```csharp\r\n// Call LogManager.GetLogger(this.GetType().Name) with reflection, as it's internal\r\nvar getLoggerMethod = typeof(LogManager).GetMethod(\"GetLogger\", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static, null, new Type[] { typeof(string) }, null);\r\nLogger logger = (Logger)getLoggerMethod.Invoke(null, new object[] { this.GetType().Name });\r\n\r\nlogger.Info(\"Now I can use the logger\");\r\n```"
      },
      {
        "user": "peter-perot",
        "created_at": "2017-06-16T08:54:40Z",
        "body": "@jdom Thank you, it works! :-)"
      }
    ]
  },
  {
    "number": 3009,
    "title": "Unable to immediately restart a Silo after entire cluster shuts down unexpectedly.",
    "created_at": "2017-05-10T14:02:06Z",
    "closed_at": "2017-05-11T16:23:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3009",
    "body": "Hey there,\r\n\r\nAs noted in the title, it appears that we are unable to restart a Silo after the entire cluster dies unexpectedly.\r\n\r\nTo replicate this issue, we have two Silos running together on the same machine. \r\nOne is using Port 22222 and Proxy Port 40000 (Silo A), the other Port 22223 and Proxy Port 40001 (Silo B). \r\nAfter them running for a period of time (the length of which doesn't seem to matter), we close both of them together.\r\nAt this point the OrleansMembershipTable displays both Silos as Active (3) due to nothing being able to update this.\r\nWe then restart the Silo A.\r\nThis then takes 5 minutes (almost exactly) before failing to initialize the Silo.\r\nIt then reports that Silo A became unavailable for messaging.\r\n\r\nUpon inspecting the OrleansMembershipTable at this point, we can see that Silo A has had its status changed to 'Joining' (2).\r\n\r\nAfter this, starting Silo A or B is fine, regardless of their current status in the OrleansMembershipTable.\r\n\r\nThrough some investigation, we've managed to determine that the issue is in SiloHost.StartOrleansSilo();\r\n\r\nWhat we're wanting to know is if there is any way around this issue.\r\n\r\nThank you\r\n\r\nExtra Info:\r\nOrleans Version 1.3\r\n\r\nStartupError Log (Side note: the C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\Silo\\Silo.cs is not my directory)\r\n\r\n>2017-05-10-10.34.19.856ZZ\r\n>ERROR starting Orleans silo name=[REDACTED] Exception=\r\n>Exc level 0: System.AggregateException: One or more errors occurred.\r\n>   at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)\r\n>   at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout, CancellationToken cancellationToken)\r\n>   at System.Threading.Tasks.Task.Wait(TimeSpan timeout)\r\n>   at Orleans.OrleansTaskExtentions.WaitWithThrow(Task task, TimeSpan timeout) in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\TaskExtensions.cs:line 210\r\n>   at Orleans.Runtime.Silo.DoStart() in C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\Silo\\Silo.cs:line 550\r\n>   at Orleans.Runtime.Silo.Start() in C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\Silo\\Silo.cs:line 439\r\n>   at Orleans.Runtime.Host.SiloHost.StartOrleansSilo(Boolean catchExceptions) in C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\Silo\\SiloHost.cs:line 178\r\n>Exc level 1: Orleans.Runtime.OrleansException: -Silo S127.0.0.1:22222:232108136 failed to update its status to Active in the table due to failures (socket failures or table read/write failures) after 38 attempts: ExecuteWithRetries has exceeded its max execution time of 00:05:00. Now is 2017-05-10 10:34:19.828 GMT, started at 2017-05-10 10:29:17.236 GMT, passed 00:05:02.5922384\r\n>   at Orleans.Runtime.MembershipService.MembershipOracle.<UpdateMyStatusGlobal>d__48.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\MembershipService\\MembershipOracle.cs:line 390\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.Runtime.MembershipService.MembershipOracle.<BecomeActive>d__30.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\MembershipService\\MembershipOracle.cs:line 168\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.Runtime.Scheduler.SchedulerExtensions.<>c__DisplayClass1_0.<<QueueTask>b__0>d.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\Scheduler\\ShedulerExtensions.cs:line 38\r\n>Exc level 2: System.TimeoutException: ExecuteWithRetries has exceeded its max execution time of 00:05:00. Now is 2017-05-10 10:34:19.828 GMT, started at 2017-05-10 10:29:17.236 GMT, passed 00:05:02.5922384\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 185\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.Runtime.MembershipService.MembershipOracle.<UpdateMyStatusGlobal>d__48.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\MembershipService\\MembershipOracle.cs:line 366",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3009/comments",
    "author": "Saraphite",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2017-05-10T14:34:09Z",
        "body": "This is by design. Silo A is waiting for silo B to respond. One workaround is to start both silos . Another workaround is to wipe the table before you restart.\r\nThere is also a way to shorten the wait period, so silo a will wait less time for b. I will add a details of the config parameter to do that later."
      },
      {
        "user": "gabikliot",
        "created_at": "2017-05-11T05:18:08Z",
        "body": "The third and easiest option is to set orleansConfig.Globals.ValidateInitialConnectivity to false. \r\n\r\nThat will completely disable the check in A of B. A will start OK and will just ignore this old entry of B saying Active.\r\nOnce B will start, it will mark its own old entry in the table as Dead and write a new entry and will be OK.\r\n"
      },
      {
        "user": "Saraphite",
        "created_at": "2017-05-11T15:34:26Z",
        "body": "Initial impressions seem to be that this worked!\r\n\r\nThank you."
      }
    ]
  },
  {
    "number": 2690,
    "title": "Question - which is the right configuration for Production?",
    "created_at": "2017-02-07T21:49:15Z",
    "closed_at": "2017-03-01T16:47:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2690",
    "body": "Can you please recommend which should be the right configuration for production, we are using SQL Server\r\n\r\n        <SeedNode Address=\"\" Port=\"11111\" />    \r\n(With this, we are seeing this as our startup log\r\n[2017-01-31 21:01:41.895 GMT     4\tINFO   \t100403\tSilo\t10.163.2.182:11111]\t-------------- Initializing Primary silo on host XXXXXXX MachineName)\r\n\r\nor\r\n       \r\n        <Liveness LivenessType=\"SqlServer\" />\r\n\r\n(With this, we are seeing, \r\n[2017-02-07 15:46:34.205 GMT    10\tINFO   \t100403\tSilo\t10.210.55.41:11111]\t-------------- Initializing Secondary silo on host XXXXXX MachineName )",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2690/comments",
    "author": "mohammad-sadiq",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2017-02-16T22:28:57Z",
        "body": "The latter is the right one. The configuration option with a primary is primarily for test scenarios, where reliability isn't a concern. "
      },
      {
        "user": "mohammad-sadiq",
        "created_at": "2017-02-21T18:44:01Z",
        "body": "@sergeybykov Thanks for answering this question..."
      }
    ]
  },
  {
    "number": 2685,
    "title": "Stream batching APIs are not fully implemented",
    "created_at": "2017-02-07T08:36:05Z",
    "closed_at": "2021-11-18T23:00:58Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2685",
    "body": "Currently `OnNextBatchAsync` creates a single message for all events passed in `OnNextBatchAsync` which may lead to Azure Queue message size limit of 64KB to be breached. Is it by design to create a single message per batch or can we detect the size of the resulting message in Azure Queue stream provider and split into multiple messages accordingly? ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2685/comments",
    "author": "DixonDs",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2017-02-07T20:21:15Z",
        "body": "It is by design. Re-batching at the provider level seems possible. Although I'm not sure if there could be implications. Wonder what @jason-bragg thinks."
      },
      {
        "user": "jason-bragg",
        "created_at": "2017-02-07T21:37:49Z",
        "body": "Some context on this issue can be found in a previous attempt to address it in \"Support messages over the max CloudQueueMessage size #2582 \"\r\n\r\n>Is it by design to create a single message per batch or can we detect the size of the resulting message in Azure Queue stream provider and split into multiple messages accordingly?\r\n\r\nIt is by design.  We've considered handling large messages using PersistentStreamProviders and have concluded that doing so in a general (or even specific) way is non-trivial.  My preference would be for the stream provider infrastructure to be constrained to the limits of the underlying persistent queuing system.  This is 64kb message for azure queues.\r\n\r\nThere are (at least) a couple different approaches that do not involve solving this within the PersistentStreamProviders:\r\n*  Multi-part messages - A large message can be broken into smaller pieces on the producer side, sent, and reassembled on the consumer side.  This is similar to #2582.  This multi-part messaging can be done at the application layer or as a stream provider decorator over any existing stream provider.\r\n*  Externally persisted message -A large message can be persisted to external storage (azure blob for instance) on the producer side, identifying information can be sent over the stream, and the large message can be read from the external storage on the consumer side.  This can be done at the application layer or as a stream provider decorator over any existing stream provider.\r\n\r\n\r\n"
      },
      {
        "user": "DixonDs",
        "created_at": "2017-02-08T06:52:40Z",
        "body": "@jason-bragg I am aware of the related discussion, but I think here the case is a bit different. If you split a big batch into smaller batches on the producer side, you don't have to reassemble the original message on the consumer side, thus there should be no additional failure cases to worry about."
      },
      {
        "user": "jason-bragg",
        "created_at": "2017-02-16T19:53:54Z",
        "body": "@DixonDs,\r\nI apologize for the delayed response.  I see your point.  You're not suggesting breaking up a single event that is too big, but rather breaking a single batch of events into multiple batches.\r\n\r\nI think this is reasonable, but should probably be a configurable switch, as I can easily envision an application batching a set of messages that it expects to receive and process together.\r\n\r\nThe stream batching api's have been grossly neglected, and there are a number of problems with those apis.  Earlier in the evolution of streams I'd advocated removing them until we had an opportunity to think through the pattern and implement batching correctly.  This remains my position.\r\n\r\nFor this problem (ignoring my preference to remove batching entirely until we can think through the pattern), I am still of the opinion that this would be best implemented as a stream provider decorator, rather than within the stream providers themselves.  The reason for this is that a single solution would address this issue in all stream providers, and it would not change the serialization patterns of the existing stream providers, which would break backwards compatibility.\r\n"
      },
      {
        "user": "ghost",
        "created_at": "2021-11-18T23:00:56Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 2677,
    "title": "[Question] Why is a new SchedulingContext created for each grain call?",
    "created_at": "2017-02-06T09:30:37Z",
    "closed_at": "2017-02-13T21:24:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2677",
    "body": "This question has been on the back of my mind for a while now: Why is a new `SchedulingContext` created for each grain call?\r\n\r\nCould we move the `ISchedulingContext` implementation to `ActivationData` either by making that class implement it itself or by including it as a property? `SystemTarget` does something like this. The current implementation seems a bit allocation-heavy.\r\n\r\nPerhaps @gabikliot or @sergeybykov or someone else can shed some light?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2677/comments",
    "author": "ReubenBond",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2017-02-07T01:01:44Z",
        "body": "There is no reason, as far as I remember. You can mimic the way it is done in system targets and store it inside the activation data. It is definitely bound to the life of the activation data."
      },
      {
        "user": "ReubenBond",
        "created_at": "2017-02-07T22:35:06Z",
        "body": "Thanks, @gabikliot. I've implemented this in #2692"
      }
    ]
  },
  {
    "number": 2586,
    "title": ".Net Garbage Collection not triggering",
    "created_at": "2017-01-11T19:59:25Z",
    "closed_at": "2017-01-20T13:59:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2586",
    "body": "I have the \r\n`<runtime>\r\n    <gcServer enabled=\"true\" />\r\n    <gcConcurrent enabled=\"false\" />\r\n</runtime>`\r\n\r\nconfigured however I am never seeing the log message coming that garbage collection has been fired. Is there something that I am missing or is this a bug\r\n\r\nThe specific log message I am looking for is this line \r\n`logger.Info(\"Forcing garbage collection on {0}\", Utils.EnumerableToString(silos));`\r\n\r\nin the ManagementGrain.cs\r\n\r\nCurrent version of orleans being used is 1.3.0",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2586/comments",
    "author": "jake-bauer",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2017-01-11T21:54:01Z",
        "body": "This code only executes when `ForceGarbageCollection` is explicitly called by application (usually some admin or test tool) to induce a .NET garbage collection in a silo or a set of silos. It is there for diagnostic and testing purposes, not for production use. So it is expected that you don't see the log message unless you call `ForceGarbageCollection`."
      }
    ]
  },
  {
    "number": 2544,
    "title": "AzureSilo Config TableName",
    "created_at": "2016-12-24T08:15:24Z",
    "closed_at": "2017-01-03T08:20:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2544",
    "body": "Hello\r\nIn AzureSilo's Config it is possible to configure TableName (by default OrleansGrainState). I was expecting to be able to configure TableName in AzureClient; I could no find how to set that value.\r\nEven changing TableName in the AzureSilo the AzureClient kept working, this raised a couple of questions:\r\n1. How does AzureClient know about AzureSilos?\r\n2. Having multiple silos (with different grains each), should I use different GrainState tables or just one is good enough?\r\nThank you",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2544/comments",
    "author": "mauriciomagni",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2017-01-03T05:30:07Z",
        "body": "There seems to be some confusion here. Grain state isn't visible or accessible to clients. So the `TableName` setting, when it comes to grain state, makes sense only on the silo side.\r\n\r\nThe cluster membership protocol, on the other hand, is what, among other things, allows clients to discover silos to connect to them. That's kind of the answer to your first question.\r\n\r\n>2. Having multiple silos (with different grains each), should I use different GrainState tables or just one is good enough?\r\n\r\nAll silo use the same configuration because grains are not permanently affiliated with any silo, and only get activated on a particular silo for some time. Hence, all silos need to write and read grain state to/from the same storage, table-based or nor."
      },
      {
        "user": "mauriciomagni",
        "created_at": "2017-01-03T08:20:48Z",
        "body": "Quite clear! very thank you @sergeybykov "
      }
    ]
  },
  {
    "number": 2530,
    "title": "Streams for communication between different Orleans deployments",
    "created_at": "2016-12-19T14:14:36Z",
    "closed_at": "2017-01-03T17:41:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2530",
    "body": "Will it possibly work, if I try to use a persistent stream provider in different Orleans deployments to pass messages from one deployment to another one? By different deployments I mean totally different codebase and servers, but obviously the message contract should be shared. ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2530/comments",
    "author": "DixonDs",
    "comments": [
      {
        "user": "galvesribeiro",
        "created_at": "2016-12-19T15:23:27Z",
        "body": "@DixonDs AFAIK you can do that. Just register the publishers in one cluster/deployment and the subscribers in another. In fact, I'll need it on my current project so I would be facing the same problem soon. Please let me know if you face any problems."
      },
      {
        "user": "DixonDs",
        "created_at": "2016-12-19T15:29:04Z",
        "body": "@galvesribeiro But I guess that will work only if you have subscribers in single Orleans deployment, right? I think if you have subscribers to the same stream in more than one Orleans deployment, the message could be removed by one Orleans deployment before the other one gets hold of it."
      },
      {
        "user": "galvesribeiro",
        "created_at": "2016-12-19T16:57:50Z",
        "body": "Yes, but I guess that depends on the provider's backend implementation... If you use Azure Queue Storage, for sure only 1 consumer will receive the message, since you need to mark it as readed and AQS remove the message from the queue. However, there are other pub/sub mechanisms like Service Bus which can have multiple consumers. I wonder if Orleans' implementation of Stream provider deal with that. I need to test.\r\n\r\nIn all cases, @jason-bragg is the Stream guru and he could put more input here."
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-12-20T21:03:28Z",
        "body": "If you use a rewindable stream backed by log-based queues, such as EventHub or Kafka, multiple deployments can consume from the same queues independently.\r\n\r\nWon't work with queueing systems, such as Azure Queues, that delete consumed events."
      }
    ]
  },
  {
    "number": 2504,
    "title": "Fire and forget long running actor method",
    "created_at": "2016-12-08T19:13:35Z",
    "closed_at": "2017-01-07T01:10:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2504",
    "body": "Let's assume we have actor Test which has method Start. In method Start actor should make up to 20 consecutive http requests and every request could take up to 2 sec. Final result is not matter for client, which calls Start method of actor test, so basically main responsibility for client is activate actor and start it and ideally method Start of Test actor should run some background task and immediately returns to client. Reminders looks overkill for this and Timers does not prevent actor deactivation, so what is best practices for such task?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2504/comments",
    "author": "MishaUliutin",
    "comments": [
      {
        "user": "jason-bragg",
        "created_at": "2016-12-08T23:11:57Z",
        "body": "I'll restate to verify that I understand the desired scenario.\r\n\r\nYou want a client to kick off some sort of action on the cluster, but the client does not care about the results, so it does not need to wait for action to complete.\r\nThe action you want to kick off is the generation of 20 consecutive http calls, each of which can take up to 2 seconds.\r\n\r\nIf that is correct, you should be able to spin off another task in the grain and simply return from the grain call.  Something like:\r\n\r\n    public interface ITestRunnerGrain : IGrainWithIntegerKey\r\n    {\r\n        Task StartTest();\r\n    }\r\n\r\n    public class TestRunnerGrain : Grain, ITestRunnerGrain \r\n    {\r\n        public Task StartTest()\r\n        {\r\n            StartTestInternal().Ignore();\r\n            return TaskDone.Done;\r\n        }\r\n\r\n        private async Task StartTestInternal()\r\n        {\r\n            for(int i=0; i<10; i++)\r\n            {\r\n                await HttpCall();\r\n            }\r\n        }\r\n    }\r\n"
      },
      {
        "user": "MishaUliutin",
        "created_at": "2016-12-09T08:01:37Z",
        "body": "> I'll restate to verify that I understand the desired scenario.\r\n\r\n> You want a client to kick off some sort of action on the cluster, but the client does not care about the results, so it does not need to wait for action to complete.\r\n\r\nyes, you are correct\r\n\r\n> If that is correct, you should be able to spin off another task in the grain and simply return from the grain call. Something like:\r\n\r\nhmm, probably I misunderstood something, but I was under impression that Orleans Runtime deactivates Actor when all messages have been processed and there is no message in the Actor queue and there is nothing in your code which can prevent Actor from deactivation.\r\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2016-12-09T17:30:10Z",
        "body": "For that scenario we have an option for a grain to ask to delay it's deactivation."
      },
      {
        "user": "jason-bragg",
        "created_at": "2016-12-09T19:19:53Z",
        "body": "As @gabikliot stated, one can delay deactivation, but I didn't think deactivation would be an issue in this case.  Deactivation does not occur immediately after all messages are processed.  Grains waits a period of time before deactivating, known as the collection age.\r\n\r\nThe default is 2 hours, but is configurable by setting the collection age limit.\r\nClusterConfiguration.Globals.Application.SetDefaultCollectionAgeLimit or for per grain type limits\r\nClusterConfiguration.Globals.Application.SetCollectionAgeLimit.\r\n\r\nThe system will deactivate the grain after the grain has received no grain calls for the collection age limit.  So by default it will wait 2 hours after the start call before shutting down the grain, well past the expected 40 seconds necessary to perform the operation.\r\n\r\nIf you've a strong concern about the grain shutting itself down, you can expose the web calls as part of the grain interface and have the grain call itself, but this is less performant.  Since each web call is performed as a grain call, the grain will always have messages to process until all of the web calls are complete.  Something like the below:\r\n\r\n    public interface ITestRunnerGrain : IGrainWithIntegerKey\r\n    {\r\n        Task StartTest(int count);\r\n        Task HttpCall(int callId, int max);\r\n    }\r\n\r\n    public class TestRunnerGrain : Grain, ITestRunnerGrain \r\n    {\r\n        public Task StartTest(int count)\r\n        {\r\n            CallNext(0,count);\r\n            return TaskDone.Done;\r\n        }\r\n\r\n        private async Task HttpCall(int callId, int max)\r\n        {\r\n            await HttpCall();\r\n            callId++;\r\n            CallNext(callId,count);\r\n        }\r\n\r\n        private void CallNext(int callId, int max)\r\n        {\r\n            if(callId < max)\r\n            {\r\n                GrainFactory.GetGrain<ITestRunnerGrain>(GetPrimaryKeyLong()).HttpCall(callId,max).Ignore();\r\n            }\r\n        }\r\n    }\r\n\r\n* I stress, this should not be necessary with even a 5 minute collection age.\r\n"
      }
    ]
  },
  {
    "number": 2503,
    "title": "Profiling length of SMS Provider stream length/contents",
    "created_at": "2016-12-08T12:39:48Z",
    "closed_at": "2017-01-07T01:07:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2503",
    "body": "We are using an SMS provider, is there a way to monitoring the length of the stream? Performance counters or a property that can be reference periodically?\r\n\r\nWe are using FireAndForgetDelivery = true and are happy after awaiting adding to the stream that it moves onto adding the next item in the stream, however we loose visibility at this point and would like to monitor if the messages in the streams could be backing up, ie if the further logic is taking longer to process.\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2503/comments",
    "author": "geoffperry",
    "comments": [
      {
        "user": "jason-bragg",
        "created_at": "2016-12-08T21:20:39Z",
        "body": "We don't have anything built-in for this.\r\n\r\nSome consumers have encoded timestamps and/or ordering information to detect delivery delays or data loss.\r\n\r\nRecently we've added another ephemeral stream provider (Like SMS) called the MemoryStreamProvider which has a little more support for recoverability  and ordering protections.  It passes an EventSequenceToken to the consumer that has a sequence number in it."
      }
    ]
  },
  {
    "number": 2479,
    "title": "TimeoutException calling IAsyncStream<T>.OnNextAsync from Orleans Timer invoked method",
    "created_at": "2016-12-03T15:34:38Z",
    "closed_at": "2016-12-06T23:18:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2479",
    "body": "I've been getting some of these TimeoutExceptions occasionally when calling IAsyncStream<T>.OnNextAsync from a method that is invoked by an Orleans Timer.\r\n\r\n```\r\nSystem.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request S192.168.21.94:40000:0*grn/5A31A490/00000000@421ddd8c->*cli/4155a6a0@64e0256f2a23c6b4-f4eb-4635-b508-bc50a0ed2731 #1458: global::Orleans.Streams.IStreamConsumerExtension:DeliverImmutable(). Target History is: <*cli/4155a6a0:@64e0256f>.  \r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)  \r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)  \r\n   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducerExtension.StreamConsumerExtensionCollection.<DeliverToRemote>d__7.MoveNext()  --- End of stack trace from previous location where exception was thrown ---  \r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)  \r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)  \r\n   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.<OnNextAsync>d__19.MoveNext()  --- End of stack trace from previous location where exception was thrown ---  \r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)  \r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)  \r\n   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()  \r\n   at NotificationServer.Grains.WellSubscriptionGrain.<CheckStaleWellConnections>d__10.MoveNext() in C:\\Source\\ProductName\\NotificationServer\\NotificationServer.Grains\\Grains\\WellSubscriptionGrain.cs:line 187\r\n```\r\n\r\nShould these calls to OnNextAsync be retried when encountering a TimeoutException? Or should we not be publishing messages to virtual streams from Orleans Timer-invoked methods? Is there some best practice or pattern to get around this?\r\n\r\n@gabikliot Thoughts?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2479/comments",
    "author": "danvanderboom",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2016-12-03T16:53:59Z",
        "body": "There is no problem publishing from the timer. Just make sure you await the call to onnext.\r\nHow much timeouts do you see? Percentage wise?\r\nIt may be just an occasional hiccup, and then exponential retry is ok, or it may be a sign of overload, and then you better rearchitecture the grains, so there are no bottlenecks."
      },
      {
        "user": "danvanderboom",
        "created_at": "2016-12-03T19:08:26Z",
        "body": "I was seeing a bunch of them before realizing I was looking at duplicate log entries. It seems less common now, the system can run for an hour or two before running into one. I'll add retries to those calls and see how that goes. Very possible it could be the network."
      },
      {
        "user": "gabikliot",
        "created_at": "2016-12-03T20:00:49Z",
        "body": "Sounds good, just use exponential retries with reasonable limit on the number of retries."
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-12-06T22:57:10Z",
        "body": "@danvanderboom Is there anything else to do here or this can be closed?"
      }
    ]
  },
  {
    "number": 2416,
    "title": "Serializing Entity with ObservableCollection",
    "created_at": "2016-11-14T12:22:59Z",
    "closed_at": "2016-11-15T08:46:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2416",
    "body": "Hello \r\n\r\nI have a PCL with entities to be shared between the backend and the frontend.\r\nIn order to use these entities in the frontend I want to take advantage of an observable collection. To avoid issues with the events raised by the observable collection during deserialization I created an additional array property. The code:\r\n```C#\r\n[IgnoreDataMember]\r\n[JsonIgnore]\r\n[NonSerialized]\r\npublic ObservableCollection<UserTenantEntity> TenantCollection { get; set; }\r\n[DataMember]\r\npublic UserTenantEntity[] TenantArray { get; set; }\r\n```\r\nI was trying to make Orleans ignore the property TenantCollection (you can see IgnoreDataMember, JsonIgrnore, NonSerialized). But Orleans keeps producing in DeepCopier method this line:\r\n```C#\r\nresult.@TenantCollection = (global::System.Collections.ObjectModel.ObservableCollection<global::Visible.Realm.UserTenantEntity>)global::Orleans.Serialization.SerializationManager.@DeepCopyInner(input.@TenantCollection);\r\n```\r\n\r\nWhen running the test I get this message:\r\n```\r\nType 'Visible.Realm.UserTenantEntity' in Assembly 'RealmService.Entities, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null' is not marked as serializable.\r\n```\r\nThis message disappears if instead of using an ObservableCollection is used a List.\r\n\r\nIs there any way to instruct Orleans not to serialize a property? \r\n\r\nThank you,\r\nMauricio.\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2416/comments",
    "author": "mauriciomagni",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2016-11-14T17:41:05Z",
        "body": "The serializer likely doesn't know how to serialize `ObservableCollection<T>`, so it is falling back to the 'fallback serializer', which uses `BinaryFormatter` by default. `BinaryFormatter` can only serialize types marked as `[Serializable]`, so it's unable to serialize `UserTenantEntity` and hence the exception.\n\nWhat I don't understand is how you're able to put `[NonSerialized]` on a property, when AFAICT, `[NonSerialized]` is for fields only.\n\n``` C#\n[AttributeUsage(AttributeTargets.Field, Inherited = false)]\n[ComVisible(true)]\npublic sealed class NonSerializedAttribute : Attribute\n```\n\nOrleans _does_ respect `[NonSerialized]` - we use it often. You will need to use a field instead of a property, though.\n\nDoes this answer your question?\n"
      },
      {
        "user": "mauriciomagni",
        "created_at": "2016-11-14T20:12:54Z",
        "body": "Hello Reuben\n\nThe NonSerialized attribute was a desperate intent using bait and switch to see if it worked, but it did not (the attribute was tweaked to accept properties).\nI was trying to instruct Orleans to just ignore my observablecollection property, I was unable to reached that goal. \n\nI even tried to create a class to force a json serialization but that make my testing failed in a really weird way (no message at all). \n\nIs it possible to ask Orleans code generator to ignore a property?\n\nThank you in advance,\nMauricio.\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2016-11-14T20:27:46Z",
        "body": "We could potentially include a NonSerialized attribute which is valid on autoproperties to instruct our serializer. As a work around, you can make this a field-backed property (manual get and set) and use NonSerialized on it. Does that work? \n"
      },
      {
        "user": "mauriciomagni",
        "created_at": "2016-11-15T08:46:02Z",
        "body": "I will implement it as a field, it should work and let me move forward.\nFor the future I would love to see custom Orleans attributes that could be used in Portable Libraries. \nThank you for your support.\n"
      }
    ]
  },
  {
    "number": 2398,
    "title": "Unity3d can use the Orleans client dll directly or not?",
    "created_at": "2016-11-08T01:40:42Z",
    "closed_at": "2016-11-08T02:28:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2398",
    "body": "",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2398/comments",
    "author": "Jesse1205",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2016-11-08T01:46:01Z",
        "body": "Typically Orleans is intended for deployment and access within a cloud service environment and should not be directly exposed to untrusted clients, so even if Unity3d could reference Orleans.dll directly, it would currently be strongly advised against.\n\nOne common architecture is to put Web frontend machines in front of an Orleans cluster. The Web front-ends handle authentication and make requests directly to the Orleans cluster.\n\nIf you describe your scenario in more detail, I can try to offer suggestions.\n\nHope that helps! 😄 \n"
      },
      {
        "user": "Jesse1205",
        "created_at": "2016-11-08T01:55:40Z",
        "body": "Thanks much ， If  use the socket server , I should create a console application to connect the Orleans?\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2016-11-08T02:25:15Z",
        "body": "@Jesse1205 yes, you can host a socket server online and use it to access Orleans\n"
      },
      {
        "user": "Jesse1205",
        "created_at": "2016-11-08T02:28:21Z",
        "body": "Thank you !\n"
      }
    ]
  },
  {
    "number": 2390,
    "title": "DI Into Storage Providers",
    "created_at": "2016-11-04T09:51:07Z",
    "closed_at": "2016-11-04T21:48:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2390",
    "body": "Hello Everyone,\r\n\r\nI am just curious to know if Custom Storage Providers (Classes Implementing IStorage Providers), currently Participate in Dependency Injection (Can have services Injected Into Them) .\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2390/comments",
    "author": "edikep2000",
    "comments": [
      {
        "user": "xiazen",
        "created_at": "2016-11-04T20:34:25Z",
        "body": "I think currently it's a service locator pattern. You can access to the service locator through `IProviderRuntime.ServiceProvider` in IProvider's `Init` method, though it is not technically a DI pattern. But there's a way to access to the services registered in the service locator\n"
      },
      {
        "user": "xiazen",
        "created_at": "2016-11-04T20:35:34Z",
        "body": "But we are trying to make DI in Orleans better, supporting DI in Providers is one of the tasks we are constantly talking about and making plans to make it better \n"
      },
      {
        "user": "attilah",
        "created_at": "2016-11-04T21:48:46Z",
        "body": "The short answer is no. They do have access to the ServiceProvider to retrieve services, but currently provider instances are not created or registered with DI, so we don't support ctor injection yet.\n\nAs @xiazen wrote it will change in the future as we're moving more classes towards DI support.\n"
      }
    ]
  },
  {
    "number": 2217,
    "title": "How To Use ServiceBusQueue",
    "created_at": "2016-09-23T06:46:40Z",
    "closed_at": "2016-11-04T23:04:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2217",
    "body": "In my Grains.cs file ,I want to use“QueueClient.CreateFromConnectionString(queueName)”   to create QueueClient ,but it dose not response.who can help me to  solve.\nThis is Code snippet:\n\n public async static Task SendAsync(string queueName,object objectData)\n        {\n            string connectionString = \"Endpoint=sb://test.servicebus.chinacloudapi.cn/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=\";\n            if (queueName.IsNullOrEmpty())\n            {\n                throw new ArgumentException(nameof(queueName));\n            }\n            NamespaceManager namespaceManager = NamespaceManager.CreateFromConnectionString(\n              connectionString);\n            if (!namespaceManager.QueueExists(queueName))\n            {\n                namespaceManager.CreateQueue(queueName);\n            }\n            if (queueClinet == null)\n            {\n                queueClinet = QueueClient.CreateFromConnectionString(connectionString, queueName);\n            }\n            BrokeredMessage message = new BrokeredMessage(objectData.ToJson());\n            await queueClinet.SendAsync(message);\n }\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2217/comments",
    "author": "DeepSkyJees",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-09-27T22:08:13Z",
        "body": "I'm not familiar with the API. Does `CreateFromConnectionString()` by chance perform a network operation, e.g. a DNS lookup in a blocking fashion? That would be a problem.\n/cc @jason-bragg @jdom \n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2016-09-27T22:18:46Z",
        "body": "Generally speaking, I didn't think the service bus apis had blocking calls without async counterparts, so if there is no CreateFromConnectionStringAsync then CreateFromConnectionString should not be blocking.  Having said that, I've not worked with service bus queues as much as EventHub, so my knowledge in this area is limited.\n\nThe QueueExists check and create queue operation are more likely to block than the CreateFromConnectionString.\n"
      }
    ]
  },
  {
    "number": 2194,
    "title": "Communication between Silos",
    "created_at": "2016-09-21T11:35:31Z",
    "closed_at": "2016-09-22T08:11:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2194",
    "body": "I am thinking of using Orleans to create an application using micro-services.\nMy goal is to have different services that interact between them, let's say the application will have:\nAuthenticationService, WarehouseService and InvoicingService.\nNow I need to communicate each service, I expect to have inside WarehouseService.Grain1 something like this:\n            GrainClient.Initialize(ClientConfiguration.LocalhostSilo(37888));\n            bool orleansClientInitialized = GrainClient.IsInitialized;\n            ISessionGrain grain = GrainClient.GrainFactory.GetGrain<Realm.ISessionGrain>(id);\nBut the first line (GrainClient.Initialize) raises an exception: \"WaWorkerHost.exe Error: 0 : [2016-09-21 11:05:39.363 GMT     5    ERROR   100319  OutsideRuntimeClient    127.0.0.1:37000]    !!!!!!!!!! OutsideRuntimeClient constructor failed.\"\n\nThis raises some questions:\n1. Does it make sense to implement micro-services using Orleans?\n2. What is the proper way to communicate grains in different services.\n\nThank you,\nMauricio\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2194/comments",
    "author": "mauriciomagni",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-09-21T14:52:31Z",
        "body": "From inside a grain there is no need to initialize client, the runtime environment is already set up within a silo. So you can simply call `this.GrainFactory.GetGrain<ISessionGrain>(id)`. Client needs to be explicitly initialized outside of silos, typically at the frontends.\n\nI see two options here:\n1. Implement multiple logical services as different grain classes (or sets of classes) that will directly call each other within a single silo cluster.\n2. Implement true microservices with each being one individually deployable.\n\n1 is simpler and more efficient with direct calls between grains belonging to different logical services, but bundles deployment and servicing of those services. \n2 requires each microservice to be deployed to a separate cluster of silos (but not necessarily to different servers). In this case calls between the services will have to be made via their respective frontends.\n"
      },
      {
        "user": "mauriciomagni",
        "created_at": "2016-09-21T15:31:46Z",
        "body": "Hello Sergey\n\nThank you for your response. \nI am trying to achieve option 2; in that case, you mentioned \"calls between the services will have to be made via their respective frontends\". Taking the risk of asking a silly question... this front-ends should be WCF services or Web APIs? or there is a kind of Orleans Fron-end for these cases?\n\nThank you,\nMauricio\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-09-21T15:36:24Z",
        "body": "The typical design includes one or more frontend web servers that receive HTTP/REST/WebSocket requests from clients and are responsible for authentication, authorization, admission control, DDoS protection, etc. Each of the web servers initializes (once) `OrleansClient` with configuration pointing to the backend silo cluster of the respective service.\n"
      },
      {
        "user": "mauriciomagni",
        "created_at": "2016-09-22T08:11:38Z",
        "body": "Thank you for your response, I will keep working based on it.\n"
      }
    ]
  },
  {
    "number": 2154,
    "title": "Async ObserverSubscriptionManager.Notify",
    "created_at": "2016-09-14T10:22:48Z",
    "closed_at": "2021-12-11T05:01:14Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2154",
    "body": "Just wanted to ask before starting actual PR. Could there be any issues with async version of `ObserverSubscriptionManager.Notify` so that we can pass async notification action?\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2154/comments",
    "author": "DixonDs",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-09-27T22:55:19Z",
        "body": "I don't see what would be a problem here\n"
      },
      {
        "user": "ghost",
        "created_at": "2021-12-11T05:01:12Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 2141,
    "title": "Allow grain states with private ctor",
    "created_at": "2016-09-12T14:15:50Z",
    "closed_at": "2021-11-18T23:01:04Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2141",
    "body": "Grain states are created using `statefulGrain.GrainState.State = Activator.CreateInstance(stateType);` in `GrainCreator`. Is there any specific reason why private constructors are not allowed? Otherwise, we could use `Activator.CreateInstance(stateType, true)` to allow grain states with private ctors as well\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2141/comments",
    "author": "DixonDs",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-09-12T14:36:21Z",
        "body": "I don't believe there's a specific reason other than that invoking a private method in general goes against the implied intent that caused the author to make it private in the first place, and hence is somewhat hacky.\n"
      },
      {
        "user": "DixonDs",
        "created_at": "2016-09-13T19:30:16Z",
        "body": "Another alternative could be to have some extension point that would allow to define custom default state creation logic, which would be used when the stateful grain is created, Grain<>.ClearStateAsync is called etc. \n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-09-13T22:43:01Z",
        "body": "I think that would be a cleaner approach than invoking somebody else's private constructors.\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2016-09-13T22:46:37Z",
        "body": "Should this be the responsibility of DI?\n\neg: try to use DI to construct grain state, if the state type is not available, use Activator.\n"
      },
      {
        "user": "ElanHasson",
        "created_at": "2016-09-13T23:47:50Z",
        "body": "I like the idea of using DI and falling back on Activator. Provides for more flexibility.\n"
      },
      {
        "user": "ghost",
        "created_at": "2021-11-18T23:01:02Z",
        "body": "Thanks for contacting us. We believe that the question you've raised has been answered. If you still feel a need to continue the discussion, feel free to reopen the issue and add your comments."
      }
    ]
  },
  {
    "number": 2112,
    "title": "how can i test my Grain which depends on another Grain?",
    "created_at": "2016-09-04T03:18:38Z",
    "closed_at": "2016-11-05T01:18:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2112",
    "body": "```\nclass GrainB : Grain, IGrainB\n{\n    public async override Task OnActivateAsync()\n    {\n        var grain = GrainFactory.GetGrain<IGrainA>(0);\n        await grain.Register(this.GetPrimaryKeyString());\n        await base.OnActivateAsync();\n    }\n\n}\n\nclass GrainA : Grain, IGrainA\n{\n    public Task Register(string grainKey);\n    public Task UnRegister(string grainKey);\n}\n```\n\nthere is two Grain named GrainA and GrainB. GrainB depends on GrainA. I saw the Orleans's sample and the TestGrainFactory can create a local grain which I can test. when Grain is simple, it can be tested easily. but in my problem, GrainB depends on GrainA, how can I complete the test?\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2112/comments",
    "author": "egmkang",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-09-06T16:00:37Z",
        "body": "You can run your test with GrainA and GrainB classes within a test silo. What I suspect you might need in addition is some test hooks (methods or interfaces) to query the state of the grains to verify that they did exactly what you intended them to do.\n\nUnless I missed something, run time dependencies between grains shouldn't preclude you from do that.\n"
      }
    ]
  },
  {
    "number": 2107,
    "title": "Persistence of Large amounts of data - Best Patterns?",
    "created_at": "2016-08-31T23:18:26Z",
    "closed_at": "2016-09-01T00:56:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2107",
    "body": "Hi guys,\nI am just getting into Orleans as a way to learn about the Actor model.\n\nFrom what I understand, whenever an actor is brought out of storage and into memeory, the state (if any) will be retrieved from the storage provider and placed into this.State.\n\nThe big issue I see with this is that After a while storing something like a game and it's statistics would take up allot of time to extract from the storage provider AND make the grains allot bigger.\n\nSay I were to persist the game history to an external source (TSQL) if I want to then access this data, is it still right to use an actor to save and query this data? Or am I missing the point of actors and all data should be stored using State?\n\nAny write ups about persisting large data within Orleans would be appreciated.\n\nCheers,\nMichael.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2107/comments",
    "author": "falconmick",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-08-31T23:46:06Z",
        "body": "There are two related but different things here to consider: 1) management of state and 2) declarative persistence feature (`Grain<TState>`).\n\n1) Grain code is free to manage its persistent state in any way it needs - loading all of it into memory upon activation, persisting a full snapshot or deltas or change log, lazily loading pieces of state on demand, etc.\n\n2) Declarative persistence is an optional opt-in feature that covers a small subset of such operations that we deemed most typical. \n\nIf 2) is sufficient for a particular grain type, it requires least amount of code but provided the limited subset of functionality.\n\nOtherwise, 1) allows for pretty much any other way of handling of persistent state.\n"
      },
      {
        "user": "falconmick",
        "created_at": "2016-09-01T00:15:02Z",
        "body": "So say for example you have an actor who accepts in readings of temperature every 10 seconds. One consumer of the application would like to just see the latest data every 10 seconds and therefore queries the api which talks to the grain and gets that value which is updated every 10 seconds. This is a happy scenario as the this.State.Temp will not grow over time and is therefor not going to grow out of control.\n\nAnother consumer however wants to see how the temperature changed over the course of a day.\nI can see two solutions, \nA) using an Orleans timed event, manually save a reading to a datetime in another DB storage device, the API then queries this table.\nB) using an Orleans timed event, create a new actor (say LongTimeStorageSensor) and pass in a snapshot of the temperature. This new actor maintains it's history and automatically compresses data as it gets old (i.e. keep every 10 seconds for the past minute, every min for the day, every hour for the month and every day for the remainder). Maybe this doesn't need to be another actor, but instead could be an internal process of the sensor grain\nC) Just have a list of readings that are stored inside of the this.State, after 1 year this list is then a behemoth.\n\nFrom what I understand of your reply, my A) maps to your 1) and my C) maps to your 2).\n\nFor data which grows over time like this, is it recomended to go with a solution like A)? From my understanding of a talk Caitie McCaffrey made, Halo 4 stored Game data inside of long time storage (slow, but not accessed as often) and the user actors held aggregate and slimmed down game data in their grains state.\nBut did they they then query the Map data (stored externally) via an actor? Or did they just use an API to talk to that persistant storage? \n\nSorry for the long and weird questions. I am just trying to see how the Actor system fits into a typical app. Like is it an acceptable design to have an actor who has no state or grain persistance and simply is used to call an external data store (like to retrieve game data)\n\nCheers.\nMichael.\n"
      },
      {
        "user": "falconmick",
        "created_at": "2016-09-01T00:24:43Z",
        "body": "I mean I understand I can probably do whatever I want, but I just don't want to violate the entire idea behind this programming model by doing Object Oriented coding. I want to code actors.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-09-01T00:54:18Z",
        "body": "> From what I understand of your reply, my A) maps to your 1) and my C) maps to your 2).\n\nI think so too.\n\nA) is the most universal option - you indeed can do whatever you want with it. I wouldn't go for B) with a separate actor type. Within the same actor type it pretty much becomes A).\n\nThere may also be a compromise middle ground there. For example, if temperature changes relatively infrequently, it may make sense to record only changes and their timestamps. If the historical data compresses very well, it may be fine to load it all if the whole history is a few kilobytes compressed. If that's the case, even C) may become a viable option.\n"
      },
      {
        "user": "falconmick",
        "created_at": "2016-09-01T00:56:45Z",
        "body": "Thanks.\nIt's amazing that at 1am (or whatever time it is in USA, I assume) that the lead developer of a tool used in systems that cost hundreds of thousands of dollars to run can reply so quickly and usefully.\n\nThank you\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-09-01T01:06:32Z",
        "body": "No problem. It's only 6pm here. :-)\n"
      }
    ]
  },
  {
    "number": 2101,
    "title": "Stream throwing an exception",
    "created_at": "2016-08-28T02:04:08Z",
    "closed_at": "2016-09-05T21:42:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2101",
    "body": "I'm writing a tracking service where the devices connect to the server via TCP and I need to report to a company the status of the devices, I have a DeviceGrain where I deserialize the message, make some calculations and then, via a stream, report the data to a CompanyGrain, on my OnActivateAsync I have the following piece of code:\n\n```\n_stream = GetStream();\n\n            //when a new message arrive\n            _stream.SubscribeAsync((data, token) =>\n            {\n                if (data.GetType().ToString().Contains(\"Alert\"))\n                {\n                    _notificationHub.Invoke(\"SendAlert\", new object());\n                }\n                else if(data.GetType().ToString().Contains(\"Notification\"))\n                {\n                    var status = (StatusNotification)data;\n                    DeviceStatus deviceStatus;\n                    var exists = devicesStatus.TryGetValue(status.Id, out deviceStatus);\n                    if (exists)\n                    {\n                        devicesStatus[status.Id] = status.Status;\n                    }\n                    else\n                    {\n                        devicesStatus.Add(status.Id, status.Status);\n                    }\n                }\n```\n\nThe method GetStream is written as follows:\n\n```\nprivate IAsyncStream<object> GetStream()\n\n        {\n            var streamProvider = base.GetStreamProvider(\"SMSProvider\");\n            var companyStream = streamProvider.GetStream<object>(this.GetPrimaryKey(), \"Devices\");\n            return companyStream;\n        }\n```\n\nEverything works fine, the code inside the SuscribeAsync gets executed as it should (when a message arrives) bue it always throws the exception written below.\n\nExtension not installed on grain GrainCollection.DeviceGrain attempting to invoke type Orleans.Streams.OrleansCodeGenStreamConsumerExtensionMethodInvoker from invokable Orleans.Runtime.ActivationData\nException = Orleans.Runtime.GrainExtensionNotInstalledException: Extension not installed on grain GrainCollection.DeviceGrain attempting to invoke type Orleans.Streams.OrleansCodeGenStreamConsumerExtensionMethodInvoker from invokable Orleans.Runtime.ActivationData\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2101/comments",
    "author": "miker1423",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2016-08-29T02:23:34Z",
        "body": "Is it possible you are missing await before subscribe?\n"
      },
      {
        "user": "miker1423",
        "created_at": "2016-08-29T02:28:34Z",
        "body": "I thought so, I added async and await and the error persisted.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-08-29T22:25:07Z",
        "body": "Just to clarify, you changed the code to `await _stream.SubscribeAsync((data, token) =>`?\n"
      },
      {
        "user": "miker1423",
        "created_at": "2016-08-29T22:28:27Z",
        "body": "Exactly.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-08-29T22:38:19Z",
        "body": "This is very strange. Even though the lambda should be totally fine. Can you try defining the callback as a method on the grain class? Just to compare.\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2016-08-30T00:59:22Z",
        "body": "As Sergey stated, you must await the subscribe call or this can occure.  Assuming you are:\n\nIs your grain marked reentrant?  That could cause this behavior.\n\nAre there any conditions under which your grain could activate without subscribing?\n\nWhat stream provider are you using?\n\nAre you using implicit subscriptions or explicit subscriptions?  Looks like implicit..\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2016-08-30T01:17:56Z",
        "body": "@jason-bragg even if the grain is marked as reentrant, we should not be allowing reentrancy before activation has completed - should we? It's like allowing calls to a half-constructed object.\n\n@miker1423 I think a larger code snippet would be useful here.\n"
      },
      {
        "user": "miker1423",
        "created_at": "2016-08-30T04:49:02Z",
        "body": "@jason-bragg answering your questions:\n1.- The grain isn't reentrant.\n2.- No, the stream is created inside the OnActivateAsync method as well as the suscribe method.\n3.- I'm using the simple message stream as my provider\n4.- I'm using Implicit subscriptions\n\n@ReubenBond, the thing is that the only thing I'm doing in the OnActivateAsync method...\nI'll omit all the trivial code only leaving the stream part.\n\n```\nusing Orleans;\nusing Orleans.Streams;\nusing Orleans.Runtime;\nnamespace GrainCollection\n{\n         [ImplicitStreamSubscription(\"Devices\")]\n         public class CompanyGrain : Grain, ICompanyGrain\n         {\n                 private IAsyncStream<DeviceNotification> _stream;\n\n                public override async Task OnActivateAsync()\n                {\n                        _stream = GetStream();\n                        await _stream.SuscribeAsync((data, token) => \n                          {\n                            if(data.IsAlert){ TriggerAlerts(data); }\n                            else { UpdateStatus(data); }\n                          }\n                }\n\n                private IAsyncStream<DeviceNotification> GetStream()\n                {\n                      var streamProvider = base.GetStreamProvider(\"SMSProvider\");\n                      var companyStream = streamProvider.GetStream<DeviceNotification>(this.GetPrimaryKey(), \"Devices\");\n                      return companyStream;\n                }\n\n         }\n}\n```\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2016-08-30T17:29:40Z",
        "body": "@miker1423 \nThe referenced exception reports that the grain having issue is \"GrainCollection.DeviceGrain\", but the code you've referenced is from GrainCollection.CompanyGrain.  Does GrainCollection.DeviceGrain have a [ImplicitStreamSubscription(\"Devices\")] attribute on it?\n"
      },
      {
        "user": "miker1423",
        "created_at": "2016-08-30T18:08:40Z",
        "body": "@jason-bragg sorry, my fault, wrong class, I'll edit it. \nEDIT: I remembered why I showed that code, the exception is raised when the Company grain is executed.\n\nBut here is the device grain Code also:\n\n```\nusing Orleans;\nusing Orleans.Streams;\nusing Orleans.Runtime;\nusing Orleans.Runtime.Configuration;\n\nnamespace GrainCollection\n{\n         [ImplicitStreamSubscription(\"Devices\")]\n         public class DeviceGrain : Grain, IDeviceGrain, IRemindable\n         {\n                private IAsyncStream<DeviceNotification> _stream;\n\n                public override Task OnActivateAsync()\n                {\n                       _stream = GetStream();\n                       return TaskDone.Done;\n                }\n\n                private Task UpdateLocation(Point newLocation)\n                {\n                       _stream.OnNextAsync(new DeviceNotification {\n                            Id = this.GetPrimaryKeyLong(),\n                            Status = _status, //Private variable\n                            Location = newLocation,\n                            IsAlert = false\n                        });\n                }\n         }\n}\n```\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2016-08-30T19:08:16Z",
        "body": "@miker1423 your `DeviceGrain` class has an `[ImplicitSubscription(...)]`, but you are not subscribing to that stream in `OnActivateAsync`\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2016-08-30T19:31:43Z",
        "body": "TL;DR - Remove the ImplicitSubscription attribute from the DeviceGrain.\n\nThe ImplicitSubscription attribute is used on grains that one wants to implicitly subscribe to a stream.  The DeviceGrain produces on the stream but does not subscribe to it.  By having an ImplicitSubscription attribute on the grain, the streaming infrastructure is trying to deliver events to DeviceGrains, and getting the referenced exception because those activations are not subscribing to the stream during grain activation.\n"
      },
      {
        "user": "miker1423",
        "created_at": "2016-09-05T21:42:24Z",
        "body": "Thanks! that made it. :smile: \n"
      }
    ]
  },
  {
    "number": 2028,
    "title": "Testing scenarios and approaches for unit testing user code",
    "created_at": "2016-08-08T08:20:45Z",
    "closed_at": "2017-01-26T17:49:06Z",
    "labels": [
      "question",
      "testing"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2028",
    "body": "I was updating the documentation in the Unit Tests page and I realized that the new awesome `TestCluster` doesn't work automatically simply if you derive from it like it was the case for `TestingSiloHost`\n\nIn the case of `TestingSiloHost` , the default constructor for the class was creating 2 silos and also a default memory storage provider was being created as well.\n\nNow the question is, should we add the configuration as a mandatory step for users which want to test their grain code? or we should modify the `TestCluster` ?\n\nI'm ok with both, want to know what should I do to do it and send a PR.\n\nAlso `TestingSiloHost` had a static method to stop all silos which could be used in MS test cleanup like this\n\n``` csharp\n[ClassCleanup]\n        private static void CleanUp()\n        {\n            StopAllSilosIfRunning();\n        }\n```\n\nShould we add that to the `TestCluster` as well?\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2028/comments",
    "author": "ashkan-saeedi-mazdeh",
    "comments": [
      {
        "user": "xiazen",
        "created_at": "2017-01-07T01:16:58Z",
        "body": "Hi @ashkan-saeedi-mazdeh \r\n\r\nThanks for updating our documentation, we really need that !! \r\n\r\nRegards the question of new `TestCluster`, it is indeed slightly different from the old `TestingSiloHost` in aspect of their default constructor, but I want to clarify couple points. \r\n\r\n1. when default constructor `new TestCluster()` is used, two silos are creating by default, with livenessServiceType as `MembershipTableGrain`. And it also init a client with default client config too. You can see a glimpse of part of the default `TestClusterOptions` in `TestClusterOPtions.FallbackOptions` class, where `initialSiloCount` are set to 2.  \r\n2. And also TestCluster has a `StopAllSilos()`, which I think it is equivalent to `StopAllSilosIfRunning()` but not a static method. \r\n\r\nBut you are right about that the default `TestCluster` doesn't have a storage provider configured. You need to configure it using \r\n```\r\noptions.ClusterConfiguration.AddMemoryStorageProvider(\"Default\");\r\noptions.ClusterConfiguration.AddMemoryStorageProvider(\"MemoryStore\");'\r\n```\r\nBut storage provider is not mandatory for every grain tests, only needed for cases like testing persistence. So I hold the opinion to not add this as a default config to default `TestCluster`. So default TestCluster is a working cluster with minimum resource configured (MVP!). \r\n"
      }
    ]
  },
  {
    "number": 1870,
    "title": "Question: Does global server side interceptor execute before or after grain is activated?",
    "created_at": "2016-06-23T12:02:18Z",
    "closed_at": "2016-06-24T20:10:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1870",
    "body": "I haven't had a chance to play with version 1.2.x yet and have a question regarding the global server side interceptor feature that was added. Let's assume my grain with <type, id> = <Consumer, 15> is about to receive a message (from client/another grain/reminder/etc.) but it's not yet activated. Will the global server side interceptor intercept the message before the grain is activated or will the interceptor run only after `OnActivateAsync` was executed successfully? \n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1870/comments",
    "author": "Eldar1205",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-06-24T04:16:51Z",
        "body": "> Will the global server side interceptor intercept the message before the grain is activated or will the interceptor run only after  OnActivateAsync  was executed successfully? \n\nGlobal interceptor gets invoked for an already activated grain, after `OnActivateAsync()` successfully executed.\n"
      }
    ]
  },
  {
    "number": 1815,
    "title": "Is there any concept of Silo 'Roles'?",
    "created_at": "2016-06-07T13:57:44Z",
    "closed_at": "2016-06-08T21:29:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1815",
    "body": "Long story short, I'm researching distribution solutions to retrofit an existing project.  Akka.Net is predictably one of the other options.  Akka.Cluster offers the concept of a role, which allows separation of responsibilities among nodes in the cluster.  Is there anything comparable in Orleans?\n\nMy suspicion is that the answer is no, and the only way to achieve such separation is with multiple clusters.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1815/comments",
    "author": "mtdaniels",
    "comments": [
      {
        "user": "shayhatsor",
        "created_at": "2016-06-07T20:22:24Z",
        "body": "@mtdaniels, I've read a bit about Akka.Cluster roles. I believe Orleans can answer that requirement with a custom `PlacementStrategy`. this is being discussed in #1806.\n"
      },
      {
        "user": "mtdaniels",
        "created_at": "2016-06-08T21:29:59Z",
        "body": "Fair enough.  Thanks!\n"
      }
    ]
  },
  {
    "number": 1773,
    "title": "Serialization error in Orleans state",
    "created_at": "2016-05-17T16:00:15Z",
    "closed_at": "2016-06-02T05:41:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1773",
    "body": "Hi,\n\nI am trying to add another string  property to the saved state in Orleans, and got a serialization  error on string type (see below.) How can I update scheme without getting these errors? \nThe error:\norlenas unsupported type 'System.String' encountered. Perhaps you need to mark it [Serializable] or define a custom serializer for it?\"}\n\nThe Alert added property is:\n[Serializable]\nclass Alert{\n..\n public string InstanceIdString { get; set; }\n}\n\nThe serialized state includes:\n[Serializable]\npublic class MyAlertsState{\n\nLinkedList<Alert> _alerts = new LinkedList<Alert>();\n…\n}\n\nThe Orleans version is: V4.0.30319\n\nThanks,\nMaya. \n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1773/comments",
    "author": "mayamai",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-05-17T21:11:23Z",
        "body": "Are you getting the error trying to serialize or deserialize state? Are these types defines in the grain interface/class assembly?\n\nBTW, V4.0.30319 is not Orleans version. It must be .NET.\n"
      },
      {
        "user": "mayamai",
        "created_at": "2016-05-17T21:47:53Z",
        "body": "Thanks for the response.\nThe error is with deserialization of the former state:\nOrleans.Serialization.SerializationManager.DeserializeInner(Type expected, BinaryTokenStreamReader stream) at ..\nBTW-My Orleans version is 1.1.3.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-05-17T21:58:51Z",
        "body": "Currently, there is no auto-versioning support that would automatically properly deserialize an old version of object into a new one. You have two options I think:\n\n1) Convert data in storage with a tool. You can use old generated serializer code to deserialize and new one to serialize back in the new format.\n2) Take the new generated serializer code as a basis, tweak it to handle deserialization of old format correctly, and remove `[Serializable]` from the type, so that Orleans codegen wouldn't generate a conflicting serializer for it. \n"
      },
      {
        "user": "mayamai",
        "created_at": "2016-05-17T22:13:14Z",
        "body": "1. Is there an existing tool for such migration?\n2. As I understand,the second option means tweaking the old de-serializer code to support both versions (until all former state are re-written). Right?  \n\nThanks again!\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-05-17T22:17:28Z",
        "body": "> 1. Is there an existing tool for such migration?\n\nI'm not aware of it.\n\n> 1. As I understand,the second option means tweaking the old de-serializer code to support both versions (until all former state are re-written). Right?\n\nOld or new, whichever is easier, to support both versions. The problem with \"until all former state are re-written\" is how do you know that.\n"
      }
    ]
  },
  {
    "number": 1751,
    "title": "Active Grains List",
    "created_at": "2016-05-12T09:21:13Z",
    "closed_at": "2016-10-03T17:20:12Z",
    "labels": [
      "enhancement",
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1751",
    "body": "Is there any way to get a list of all active grains. I understand this goes against the Orleans model, but will be used purely for a Dashboard to be able to visualise a Orleans Silo.\n\nCurrently we can get the count of active grains using the \n\n`IManagementGrain.GetTotalActivationCount().`\n\nI managed to get the information using the following. But the methods and classes are internal, so there is no way to use this from an application.\n\n```\nvar systemManagement = GrainClient.GrainFactory.GetGrain<IManagementGrain>(1);\nvar silos = GetSiloAddresses();\nif (silos == null || silos.Count == 0) return;\n\nvar siloControl = GrainClient.InternalGrainFactory.GetSystemTarget<ISiloControl>(Constants.SiloControlId, silos[0]);\nvar grainStats = await siloControl.GetGrainStatistics();\n```\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1751/comments",
    "author": "Dewaldf",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-05-12T14:46:12Z",
        "body": "I think the right solution here is to add `GetGrainStatistics()` to `IManagementGrain` and implement it similarly to `GetSimpleGrainStatistics()`. Would you submit a PR for that?\n"
      },
      {
        "user": "Dewaldf",
        "created_at": "2016-05-12T14:48:11Z",
        "body": "Will do.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-10-03T17:20:12Z",
        "body": "Resolved via #1772.\n"
      }
    ]
  },
  {
    "number": 1736,
    "title": "Configuring Reminders with the silo process",
    "created_at": "2016-05-05T18:56:46Z",
    "closed_at": "2016-05-06T16:10:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1736",
    "body": "We have implemented our silohost in a windows service. We have a number of grains, which should run \"batch-like\". Some with 2-hour interval, some with 24-hour interval and some with monthly interval. We thought a good implementation of that would be as reminders.\n\nWe need a place to configure these reminders in Orleans, and we thought a natural place for that is when starting the windows, service which holds the silo. Something like the below.\n\nHowever, Orleans will not let use GrainClient to get a reference to a grain. And as I understand we need a grain to register a reminder. We get an error \"You are running inside the provider code, on the silo. GrainClient.GrainFactory should only be used on the client side. Inside the provider code use GrainFactory that is passed via IProviderRuntime (use providerRuntime.GrainFactory).\"\n\nIs there any way to register a grain when starting the silo host process?\n\n```\n        _siloHost = new SiloHost(\"MySilo\", ClusterConfiguration.LocalhostPrimarySilo());\n        _siloHost.InitializeOrleansSilo();\n        _siloHost.StartOrleansSilo();\n\n        GrainClient.GrainFactory.GetGrain<IMyBatchGrain>(\"MyBatchGrain\").Register();\n```\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1736/comments",
    "author": "FenrisWolfAtMiddleEarth",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2016-05-05T19:14:10Z",
        "body": "You should write this code inside bootstrap provider.\n\nYour other option is to create a grain client inside a separate app domain, or even process. But it cannot be in the same memory domain with the silo and not inside provider or grain.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-05-05T21:58:09Z",
        "body": "> We need a place to configure these reminders in Orleans, and we thought a natural place for that is when starting the windows, service which holds the silo. Something like the below.\n\nIf those reminders need to be registered once, then trying to do the same upon each restart of each node seems excessive to me. Reminders survive restarts and redeployments of a service. I think it would be more logical to execute an explicit 'configuration' task once right after a first deployment via a separate process or something, and not deal with that after.\n"
      },
      {
        "user": "FenrisWolfAtMiddleEarth",
        "created_at": "2016-05-06T16:10:42Z",
        "body": "Thanks\nBootstrapprovider seems to do the job nicely for us.\nWe understand your suggestion about an explicit configuration task which just runs once. however that just complicates spinning up a fresh system on a phoenix server. (We do that for automated integration tests etc.)\nHopefully silo nodes are rarely restarted, so re-registering at those rare occasions should not be a problem.\n"
      }
    ]
  },
  {
    "number": 1690,
    "title": "Warning from WindowsPerfCountersStatistics about counters not found",
    "created_at": "2016-04-19T10:43:15Z",
    "closed_at": "2016-04-27T08:54:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1690",
    "body": "I found a warning in traces of my Orleans based cloud service regarding windows perf counters not found, and would like to know if Orleans expects me too run OrleansCounterControl.exe as startup task of my worker role, or is there something else that I can do to my worker role/cloud service in order to have the perf counters Orleans is looking for? Any help would be appreciated. The trace:\n\n[2016-04-19 06:56:44.580 GMT     7  WARNING 100701  WindowsPerfCountersStatistics   100.108.102.18:30000]   Windows perf counters not found -- defaulting to in-memory counters. Run OrleansCounterControl.exe as Administrator to create perf counters for Orleans.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1690/comments",
    "author": "Eldar1205",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-04-19T20:33:54Z",
        "body": "Yes, you need to run `OrleansCounterControl.exe` as an elevated task before starting a silo, so that the perf counter categories are registered.\n"
      },
      {
        "user": "Eldar1205",
        "created_at": "2016-04-27T08:54:06Z",
        "body": "Worked, thank you very much\n"
      }
    ]
  },
  {
    "number": 1687,
    "title": "Can I access other silos from within a silo",
    "created_at": "2016-04-18T10:27:16Z",
    "closed_at": "2016-04-19T05:08:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1687",
    "body": "Is it possible to access other silo's from within a silo?\n\nMy use case is this: We would like to have a silo with all of our business logic grains, and another silo with all of our database-grains. The business logic grains will of course use the database-grains. The purpose of separating the two is that we can \"mock\" the database grains in an automated test by simply replacing the silo with the database grains with a corresponding silo mocking the database.\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1687/comments",
    "author": "FenrisWolfAtMiddleEarth",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-04-18T14:29:08Z",
        "body": "This is not directly supported, and even if it was, it would be an anti-pattern - to try to use a silo as an isolation container. Silo are meant to be simply an abstraction over available compute resources that are shared by all grains in the cluster and can be added/removed to/from a cluster on an as needed basis for resource management or as a result of a failure.\n\nThere are other, more straightforward, ways to achieve mocking, for example, by passing an explicit class name prefix to `GetGrain()` methods of `GrainFactory`, so that you can switch between production and test versions of the grain class by changing a single string in config.\n"
      },
      {
        "user": "FenrisWolfAtMiddleEarth",
        "created_at": "2016-04-19T05:07:57Z",
        "body": "Right. Understood.\n\nAs I see it, passing an explicit class to GetGrain / GrainFactory is more for unit-testing. That is at least how we use it. I am looking for the next step in our CI / CD pipeline, which is integration test.\n\nBut I guess what would work just as well is in our CI / CD pipeline is to have the database-grains in one dll and then take that out of the silo in the integration-test step and replace them with mocking-grains from a separate dll.\n\nThanks for your input. It is much appreciated.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-04-19T21:12:17Z",
        "body": "> As I see it, passing an explicit class to GetGrain / GrainFactory is more for unit-testing.\n\nYes, but no necessarily. You can also have multiple grain classes that implement the same grain interface, and explicitly choose the desired grain class to use.\n"
      }
    ]
  },
  {
    "number": 1686,
    "title": "Warnings from AssemblyLoader not finding Applications directory",
    "created_at": "2016-04-17T16:36:10Z",
    "closed_at": "2016-04-27T08:54:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1686",
    "body": "I found the following warning in traces when running Orleans on my cloud service, it wasn't there first time I ran that cloud service with Orleans. Can someone please tell me why Orleans is looking for that directory and what are my options to make the warning go away?\n\n[2016-04-17 16:21:03.792 GMT     7  WARNING 101705  AssemblyLoader.Silo 100.106.4.23:30000] Unable to find directory E:\\approot\\Applications; skipping. \n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1686/comments",
    "author": "Eldar1205",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-04-18T14:46:16Z",
        "body": "`Applications` is the hardcoded path where silo looks for app assemblies. The warning is harmless. If you create such a directory before starting a silo, the warning will go away.\n"
      },
      {
        "user": "Eldar1205",
        "created_at": "2016-04-19T10:41:03Z",
        "body": "And if there won't be any assemblies in that directory, won't that cause issues for the silo?\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-04-19T20:38:30Z",
        "body": "No issues. This warning probably should change to an info.\n"
      },
      {
        "user": "Eldar1205",
        "created_at": "2016-04-27T08:54:54Z",
        "body": "Added code that creates the directory on startup and it worked, thanks\n"
      }
    ]
  },
  {
    "number": 1660,
    "title": "Question: How to build Orleans and generate Nugets from source?",
    "created_at": "2016-04-06T23:24:06Z",
    "closed_at": "2016-04-08T18:41:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1660",
    "body": "I've downloaded Orleans solution from master branch and would like to build it from source (Release build) and generate the Nugets. I looked at the contribution guide and didn't see an instruction on how to do so, can someone please tell me?\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1660/comments",
    "author": "Eldar1205",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-04-06T23:43:39Z",
        "body": "Run `src\\Build.cmd`.\n"
      },
      {
        "user": "jasonholloway",
        "created_at": "2016-04-07T07:18:40Z",
        "body": "And if you're tweaking your own version, make sure to change `src\\Build\\Version.txt` first to stop NuGet getting confused - stick your name on the end of it or something.\n"
      }
    ]
  },
  {
    "number": 1659,
    "title": "Question: Grain context in Orleans",
    "created_at": "2016-04-06T21:31:20Z",
    "closed_at": "2016-04-14T07:26:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1659",
    "body": "In my Orleans based service, I use DI container and DI heavily. In some cases there's a singleton object in the grain's dependency graph, a.k.a object graph, usually a factory of some sort. I have a case where I want the factory to use the grain's `Logger` to log traces on behalf of the grain requesting something from the factory. With WebApi (for example) you have a static HttpContext you can access to get data on current request. With Orleans there's the RequestContext that serves a similar purpose - is there a problem with putting a reference to the grain itself in the RequestContext, as a way to achieve a so called \"GrainContext\"?\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1659/comments",
    "author": "Eldar1205",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-04-08T16:39:28Z",
        "body": "I'm not sure I understand - do you want to put a reference to the grain activation object to `RequestContext`?\n\nThe main purpose of `RequestContext` is to facilitate passing additional environment information along the grain call chain, e.g. an auth token. Passing a reference to a local object obviously won't work. Did I misunderstand your question?\n"
      },
      {
        "user": "Eldar1205",
        "created_at": "2016-04-08T20:09:49Z",
        "body": "You understood the question correctly, I ask about putting the grain reference, e.g. instance of class inheriting `Grain`, on the `RequestContext`. The motivation is having a `GrainContext.Current` similar to other request handling frameworks (WebApi, WCF, etc.). Given the current request is handled by a certain grain, I think it's a good idea to have access to current grain as well. I actually don't want the local grain reference to pass along grain call chain, since the next grain in the chain should put its own reference on the `RequestContext`. So question is will putting a local reference on `RequestContext` cause an exception or will Orleans won't pass such local references and work seamlessly? \n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-04-08T21:23:03Z",
        "body": "What code would access that variable? Since grains are reactive in nature, why can't grain explicitly pass `this` to that code instead of relying on the ambient state in `RequestContext`?\n"
      },
      {
        "user": "Eldar1205",
        "created_at": "2016-04-08T21:33:03Z",
        "body": "Passing `this`isn't DI friendly and hinders loose coupling. The grain reference will have to be passed along the call stack until it reaches the destination somewhere in the object graph, along the way passing through business objects that shouldn't be aware of Orleans existence at all, hence hindering loose coupling. With ambient state, I can have any part of the grain object graph access the current grain, without other parts knowing about it. \n"
      }
    ]
  },
  {
    "number": 1552,
    "title": "Non-timeout Messaging Delivery Errors",
    "created_at": "2016-03-11T15:39:35Z",
    "closed_at": "2016-03-14T07:49:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1552",
    "body": "Hello, I'd like to ask whether the deliverance status is unknown or known-not-delivered in a situation when some network-based exception (other than Timeout) error is thrown when calling await OtherGrain.MyFunction();\n\nThank you !\nAbe\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1552/comments",
    "author": "Astorlights",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2016-03-11T15:43:40Z",
        "body": "Are you asking what types of exceptions could be thrown from a grain call?\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2016-03-11T15:46:57Z",
        "body": "A grain call will succedd, or throw some exception, or if both didn't happen, timeout exception will be thrown. So the task returned from a grain call will never stay unresolved forever. It is guaranteed it will timeout after a configurable time.\n"
      },
      {
        "user": "Astorlights",
        "created_at": "2016-03-11T15:48:26Z",
        "body": "So when an exception is thrown (immediately or some time before the timeout), is it guaranteed that the Tagret grain method was not invoked ? \n"
      },
      {
        "user": "gabikliot",
        "created_at": "2016-03-11T15:50:16Z",
        "body": "No, that is not guaranteed. The target grain could have been invoked, but the reply didn't arrive.\n"
      },
      {
        "user": "Astorlights",
        "created_at": "2016-03-11T16:29:09Z",
        "body": "Simply put, I'm asking about the situation when the exception is thrown upon calling some target grain method, and it is _not_ the TimeoutException, but it's some network-related exception like \"Target network unreachable\" or something like that (thrown from whatever lies between caller grain and target grain). In this situation, is it still possible that the target grain method was invoked and is \"running\", even though the caller got the exception? Thanks again.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2016-03-11T17:30:03Z",
        "body": "Yes, the situation you described is totally possible.\n"
      }
    ]
  },
  {
    "number": 1551,
    "title": "Runtime grain code generation",
    "created_at": "2016-03-11T14:00:24Z",
    "closed_at": "2016-04-08T19:11:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1551",
    "body": "Is there any reason why you should generate code on compile time? Isn't it much easy to do on Silo Host startup to generate all this Proxy classes?\nWith this we also can have an ability to codegen grain classes in runtime before Silo starts (for whatever reason we want that).\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1551/comments",
    "author": "stgolem",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-03-11T17:51:39Z",
        "body": "Main reasons for compile time codegen are early error detection and better determinism about the generated code that can be saved for debugging or compliance.\n\nYou are free not to use compile time codgen, and run time codegen should happen automatically. I'm less sure about codegen'ing of grain classes that you mentioned. Today that would have to happen before a silo starts.\n"
      },
      {
        "user": "stgolem",
        "created_at": "2016-03-13T09:07:53Z",
        "body": "Oh! That is a great news. We are currently use Nemerle as part of our domain model language. So all grains classes are created also at compile time. But no godegen happens on Silo start.\nIs there any config or whatever else for this to happen?\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-03-14T21:14:46Z",
        "body": "You shouldn't need anything.\n"
      }
    ]
  },
  {
    "number": 1548,
    "title": "Grain Access Violation : \"Attempted to read or write protected memory. This is often an indication that other memory is corrupt.\"",
    "created_at": "2016-03-10T13:37:37Z",
    "closed_at": "2016-04-08T19:14:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1548",
    "body": "Hi, \n\nI got System.AccessViolationException after getting  a grain reference and call an interface method. What could be the problem?  \n\n```\npublic interface IxGrain : IGrainWithGuidKey, IGrain, IAddressable\n{\n    Task<string> Test();\n}\n\n public class xGrain : Grain, IxGrain\n {\n    public Task<string> Test()\n    {\n        return Task.FromResult(\"Test String\");\n    }\n }\n\n\n if (!GrainClient.IsInitialized) \n {\n    GrainClient.Initialize(\"DevTestClientConfiguration.xml\");\n }\n var xService = GrainClient.GrainFactory.GetGrain<IxGrain>(Guid.NewGuid());\n Task<string> result = xService.Test();\n```\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1548/comments",
    "author": "ozang",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-03-10T15:24:26Z",
        "body": "What the call stack in the exception? I can't imagine Orleans being the culprit here but am curious. \n"
      },
      {
        "user": "ozang",
        "created_at": "2016-03-10T16:20:49Z",
        "body": "Somehow Grain is corrupted.\n\n```\n   at Portfolio.AppService.ApplicationServiceImpls.PortfolioAppServiceImpl_ClientApi.TestOrleans() in ***\\Portfolio.AppService\\ApplicationServiceImpls\\PortfolioAppServiceImpl_ClientApi.cs:line 269\n   at InformixPofConcept.OrleansTest.TestOrleans() in ***\\OrleansTest.cs:line 18\n   at InformixPofConcept.Program.Main(String[] args) in ***\\InformixPofConcept\\Program.cs:line 24\n   at System.AppDomain._nExecuteAssembly(RuntimeAssembly assembly, String[] args)\n   at Microsoft.VisualStudio.HostingProcess.HostProc.RunUsersAssembly()\n   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)\n   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)\n   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)\n   at System.Threading.ThreadHelper.ThreadStart()\n```\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-03-10T16:22:52Z",
        "body": "I don't see any Orleans code on the stack.\n"
      }
    ]
  },
  {
    "number": 1545,
    "title": "Heartbeat setting in GrainClient or Client Configuration.",
    "created_at": "2016-03-09T22:49:38Z",
    "closed_at": "2016-04-28T22:43:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1545",
    "body": "This is a question. \n\nIs there some kind of HeartBeat setting / duration I can set in the GrainClient or the Orleans Client configuration to keep the tcp connection active. \n\nThanks.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1545/comments",
    "author": "loneshark99",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-03-09T22:54:11Z",
        "body": "You don't need to - the client keeps connection alive until you uninitialized it or the app domain gets unloaded.\n"
      },
      {
        "user": "loneshark99",
        "created_at": "2016-03-10T01:33:40Z",
        "body": "I am connecting to the silo from the client using Gateway Address=\"servername\" Port=\"30000\" . If I don't access for certain period of time > 10 mins then I am seeing following exception and the application hangs.\n\n  <Gateway Address=\"localhost\" Port=\"30000\"/>\n\nWARNING 100158  Messaging.GatewayClientReceiver/gwy.tcp://xx.xx.xx.xx:30000/0   10.125.78.40:0] Exception receiving from gateway gwy.tcp://xx.xx.xx.xx:30000/0: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond  \nWarning: 0 : [2016-03-10 01:07:07.165 GMT    16 WARNING 100913  Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://xx.xx.xx.xx:30000/0   10.125.78.40:0] Marking gateway at address gwy.tcp://xx.xx.xx.xx:30000/0 as Disconnected  \nif I restart the application, everything works fine.\n\nThanks.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2016-03-10T02:27:55Z",
        "body": "Please share both silo and client logs, at info level.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2016-03-10T02:29:47Z",
        "body": "Also, this is a Warning in the log. Nothing bad by itself. Do you get any exception in the application? If not, the all is fine, this is just a warning which you can ignore.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2016-03-12T05:43:54Z",
        "body": "@loneshark99 , do you have the logs to share? Without them there is not much we can help with.\n"
      },
      {
        "user": "loneshark99",
        "created_at": "2016-03-14T18:10:38Z",
        "body": "Actually we are not using with the orleans standard deployment model.  We have opened the public tcp ports on the Azure VM where orleans is deployed.  \n\n  InputEndpoint name=\"OrleansSiloEndpoint\" protocol=\"tcp\" port=\"11111\" localPort=\"11111\" />\n  <InputEndpoint name=\"OrleansProxyEndpoint\" protocol=\"tcp\" port=\"30000\" localPort=\"30000\" /\n\nAnd then in the ClientConfiguration we are connecting to that Gateway using the below clientconfiguration.\n\nGateway Address=\"servicename.cloudapp.net\" Port=\"30000\"/>\n\nI think since in the recommended deployment model, OrleansClient and Orleans are both in the same virtual network , heartbeat is not required.  But with the way we are using it will have to go through different firewalls etc. the tcp connection drops and it just hangs with the logs I posted earlier.\n\nIf we send the traffic to the orleans cluster after every few minutes then this issue does not happen.Just to keep the connection open.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2016-03-15T04:11:43Z",
        "body": "At any event, even if Azure does close the connection, you should NOT see any impact in your application: all grain calls should succeed, since Orleans will automatically re-open closed connections.\nYou will see the warning in the log, just like the warning you posted above, but there should be no application impact. If that is not what you see, then we should investigate.\n\nAs to why/if Azure decides to shoot off the TCP connection - it sounds strange to me. You might want to open this with Azure support. Sounds like an infrastructure bug to me. Or perhaps some mis-configuration.\n"
      },
      {
        "user": "ChunyangMS",
        "created_at": "2016-03-16T20:31:44Z",
        "body": " The problem is when client establish a TCP Connection to an Orleans Azure Service, which is a long live, there are many network devices(i.e firewall) in between that will monitor all the TCP Sessions. There are TCP Connection Idle settings on all the network devices which will kill the sessions that have been idled over the setting value, typically in minutes. When that happens, both the client and server would not know because it is simply removed from the network devices sessions. However, when the client or server try to send any traffic over, the packets will be dropped because it is not in the active sessions any more. What you typical see in the network trace, is a bunch of retries with a TCP Reset that gives up.  We have implemented a temp fix in the application layer that send a dummy request every 30 seconds and we do not see that problem any more. However, we are still concerned there were no retries after the TCP Connection Timeout which we typically see in other Applications. I guess we need to dive into the OrleansClient Code to find out.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2016-03-17T04:39:06Z",
        "body": "Did you see my comment from above?\n\n> At any event, even if Azure does close the connection, you should NOT see any impact in your application: all grain calls should succeed, since Orleans will automatically re-open closed connections.\n> You will see the warning in the log, just like the warning you posted above, but there should be no application impact. If that is not what you see, then we should investigate.\n\nIf you do see application errors, this is NOT what we  expect. In such a case, please  provide a full silo and client logs, both at Info level.\n"
      },
      {
        "user": "ChunyangMS",
        "created_at": "2016-04-04T16:41:07Z",
        "body": "We did observe Application Timeout after we sit the client idle for over a few mintues. The reason is Orleans client and Server does not know the connection has been silently killed. We implemented a heartbeat mechanism in our client and the issue went away.\n\nThe issue can be reproed if you use a Orleans Client connect to a Silo Gateway(the VIP of Cloud Service, you will not see the issue if you have Client and Server deployed on the same VNnet because there is no layer 3/4 devices in between). let it idle for say 30 minutes, try send some traffic over, you should see the Application Error. \n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-04-04T17:37:04Z",
        "body": "This sounds like \"by design\" to me. If the socket from client to gateway stays open, Orleans has no idea that the connection was actually closed. I'm not convinced we should try to detect such situations at the Orleans Runtime layer.\n"
      },
      {
        "user": "ChunyangMS",
        "created_at": "2016-04-08T17:04:39Z",
        "body": "We do not expect Orleans to detect such failure, However, it seems like Orleans client could not recover from such state by reestablishing a new connection at least from our experience.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-04-08T18:06:05Z",
        "body": "@simonycs How would you except `OrleansClient` to recover if it's unaware of the connection loss?\n"
      }
    ]
  },
  {
    "number": 1507,
    "title": "Question: detection source of activation in OnActivateAsync",
    "created_at": "2016-02-29T12:48:28Z",
    "closed_at": "2021-11-26T13:00:52Z",
    "labels": [
      "question",
      "help wanted",
      "Needs: author feedback",
      "Status: no recent activity"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1507",
    "body": "I'd like to have a grain that acts as cache and has activation logic based on source of activation:\n1. If activated by client, then should register a timer to refresh its in-memory & persisted state every 1 minute\n2. If activated by reminder, should not register that timer, since the reminder represents a periodic task to refresh persisted state for inactive clients. \n\nMy current solution is registering the timer from the method called by the client on first invocation. Is there a better way? Below is a stub of my current grain code:\n\n```\npublic class DiscoveryResponse : GrainState\n    {\n\n    }\n\n    public interface IDiscoveryGrain : IGrainWithGuidKey // Key is subscription id\n    {\n        Task<DiscoveryResponse> GetDiscovered();\n    }\n\n    [StorageProvider(ProviderName = \"AzureTable\")]\n    public class DiscoveryGrain : Grain<DiscoveryResponse>, IDiscoveryGrain, IRemindable\n    {\n        public override async Task OnDeactivateAsync()\n        {\n            await RegisterOrUpdateReminder(\n                reminderName: \"InactiveCacheRefresh\", \n                dueTime: TimeSpan.FromHours(1), \n                period: TimeSpan.Zero);\n        }\n\n        async Task IRemindable.ReceiveReminder(string reminderName, TickStatus status)\n        {\n            await RefreshCache(null);\n            DeactivateOnIdle(); // So the grain's would be immedietly deactivated and GC could collect its memory  \n        }\n\n        public Task<DiscoveryResponse> GetDiscovered()\n        {\n            if (_activeCacheRefresh == null)\n            {\n                _activeCacheRefresh = RegisterTimer(\n                    asyncCallback: RefreshCache,\n                    state: null,\n                    dueTime: TimeSpan.Zero,\n                    period: TimeSpan.FromMinutes(1));\n            }\n\n            return Task.FromResult(_cachedResponse);\n        }\n\n        private IDisposable _activeCacheRefresh;\n\n        #region Helpers\n        private async Task RefreshCache(object ignored)\n        {\n            var subscriptionId = this.GetPrimaryKey();\n            var refreshedResponse = await DiscoverResources(subscriptionId);\n\n            _cachedResponse = refreshedResponse;\n            await WriteStateAsync();\n        }\n\n        private DiscoveryResponse _cachedResponse;\n\n        private Task<DiscoveryResponse> DiscoverResources(Guid subscriptionId) { throw new NotImplementedException(); }\n\n        private void AfterRefresh(Task refreshTask) { throw new NotImplementedException(); } \n        #endregion\n    }\n```\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1507/comments",
    "author": "Eldar1205",
    "comments": [
      {
        "user": "rafikiassumani-msft",
        "created_at": "2021-11-18T22:31:25Z",
        "body": "@Eldar1205 are you still looking for a better to implement this ? "
      },
      {
        "user": "ghost",
        "created_at": "2021-11-23T08:00:54Z",
        "body": "This issue has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **4 days**. It will be closed if no further activity occurs **within 3 days of this comment**."
      }
    ]
  },
  {
    "number": 1490,
    "title": "How to scale cache with highly variable hot pieces",
    "created_at": "2016-02-22T15:50:08Z",
    "closed_at": "2016-04-28T22:45:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1490",
    "body": "From Gitter by @creyke:\n\n> Consider a cluster of multiple, complex data structures, each represented by a grain instance, each with a vastly varying load profile. The data in these grains could be required by over 80% of client requests, or less than 1%... it's impossible to programmatically infer which of these is true for a given grain in advance. Some hot grains, some cold grains, and the load profile is consistently changing basically. Data cannot be stale (more than 100ms) and polling to cache data into a stateless worker with a sub second TTL on its model is arguably heavy as the data objects are complex... temptation from an application developer perspective would therefore be to use stateless workers which scale magically, hydrate initial state from the grain that backs them, after making an implicit stream subscription to get deltas.\n> When a grain is \"hot\" it will be for some time (maybe at least an hour) so there is huge value in layered caching, it's just a case of identifying the best way to both scale cache grains dynamically, and distribute data to them efficiently both in terms of time and CPU.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1490/comments",
    "author": "sergeybykov",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-02-22T16:26:01Z",
        "body": "Assuming this is read-only cache from the client requests perspective that gets updated by some internal process, I see two parts of the potential solution.\n\nIt is tempting to use a layer of `StatelessWorker` grains as targets for client requests for automatic scale-out and locality. Let's call them Reader grains. Multiple activation of the same `StatelessWorker` grain within a silo can either each have a copy of the data or use a shared data structure in a safe manner, e.g. if the update process performs pointer swaps. This part is relatively straightforward. The downside of this approach is that each silo will eventually end up with one or more activation of each cache grain. Not sure if this is a problem.\n\nThe more interesting part is about how to deliver updates to the data structures used by the  Reader grains. That's where the idea of `StatelessWorker` grains subscribing to streams came from. The problem here, streams or not, is that `StatelessWorker` grains aren't externally addressable (from outside of their silos).\n\nIf we leave the notion of `StatelessWorker` grains as is, we need a normal remotely addressable grain in each silo that will act as a writer for the Reader grain. Let's call it Writer. A Writer grain can subscribe for updates, via a stream or not, and update the Reader by calling it of by directly swapping the shared data structure. One approach would be to use a `[PreferLocalPlacement]` grain as a Writer and have Reader grain activate one with a random ID from within its `OnActivateAsync()`. We may need a little bit of coordination here to avoid activating multiple Writer grains by that part is easy.\n\nWith silos restarting we will end up with more than one Writer grain per silo because the ones from rebooted silos will get reactivated (unless they unsubscribe as part of a graceful shutdown, which we cannot expect in 100% of cases) somewhere else by updates to their subscriptions in addition to the new Writers getting activated by Readers. But this inefficiency can be eliminated with a bit of local coordination.\n\nI mentioned directly accessing shared data structures by different grain activations several times. Technically, this would be a violation of grain isolation. But we aren't religiously opposed to such violations of the pure model if they are done for significant performance gains and safely.\n"
      },
      {
        "user": "sxam",
        "created_at": "2016-03-10T06:47:55Z",
        "body": "Hi,\nI have one more question on the subject. The idea came to us since one of the guys pointed out that I can, in fact, control the number of stateless grains in a silo by using the number in the attribute - StatelessWorker(1) . Hence, that guarantees that I have maximum 1 stateless grain per silo. Now, this is also a drawback, of course, since it reduces scalability for Reader grains to number of silos the service is deployed in. But, let's assume we will go for it. But now how can I approach specific Silos (lets even assume I have their ips) and tell them explicitly that I want to get Your stateless grain of type X (and since there is only one per silo that way I will be able to revoke all of them). Is there some management API that can help me approach a specific Silo and ask for Its local stateless grain?\n"
      },
      {
        "user": "sxam",
        "created_at": "2016-03-16T09:08:57Z",
        "body": "Another remark  - @sergeybykov , you proposed the following:\n\"I mentioned directly accessing shared data structures by different grain activations several times\"\nBut it seems problematic since the cached info we need is not divided by ids and not general. For example, its metadata per some site and if Stateless layer grains receives \"getMetadataForSite(11)\" then how will they access some static metadata in Reader grain. Reader grains could, of course, hold static Dictionary with metadata for all sites in the system, reading it from single Master grain. But I am afraid its too much to handle, even with all this 3 layers structure. I would keep grains per Site separated.\nSo this is a problem I don't currently know how to overcome.\n"
      },
      {
        "user": "creyke",
        "created_at": "2016-03-21T07:52:24Z",
        "body": "To a certain level of concurrency there may be a straightforward solution to scaling reads of real time data on a single silo. If a stateless worker acts as a proxy to another grain which in turn implicitly subscribes to a stream from the persistent grain, the stateless workers can, as they scale, generate a unique GUID on activation, throw away say 96bits of it, and use the other 32 to randomly address and therefore activate the real intermediary grain that backs it. The other 96bits can be used to define the virtual instance of that grain. The intermediary grain would then implicitly subscribe on activation to the stream from the persistent grain. Effectively stateless workers elastically scale and take a real grain with them as they are created or deactivated. To do this cross-silo, where you need more threads than a single server can provide, you would need a way of (before any elastic scaling) synchronising a QueuedGrain<X,Y> across each silo in a cluster. Similar to the functionality in the meta cluster which providers OneInstancePerCluster. I believe there is something internal which could potentially be exposed at the application level?\n\nSo for me, this proposal could solve (with an extra hop) elastic scaling of stream consuming grains on a single node, and that leaves the missing piece being how (it may already be possible) to synchronise a single grain across each node in a cluster.\n"
      },
      {
        "user": "gavinrunsdavies",
        "created_at": "2018-01-04T13:23:43Z",
        "body": "@sergeybykov your comment \"The problem here, streams or not, is that StatelessWorker grains aren't externally addressable (from outside of their silos).\" above. Is this still true? We're calling a Stateless Worker grain from a Grain Client outside the silo and are not seeing the work (CPU) distributed across the cluster when we put it under load.\r\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-01-17T19:05:44Z",
        "body": ">Is this still true?\r\n\r\nYes.\r\n\r\n>We're calling a Stateless Worker grain from a Grain Client outside the silo and are not seeing the work (CPU) distributed across the cluster when we put it under load.\r\n\r\nThe load should be distributed more or less evenly. How man silos do you have in the cluster? Do you see in the logs or metrics the client connecting to all of them?"
      }
    ]
  },
  {
    "number": 1481,
    "title": "Question: Best way to deal with returning a big message?",
    "created_at": "2016-02-19T16:16:08Z",
    "closed_at": "2016-03-03T11:26:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1481",
    "body": "You can skip to the end to save time.\n\nIt seems like the server takes a very long time when it has to send a large message.\n\nHere is an example:\n\n```\n  [2016-02-17 17:51:37.369 GMT    24    INFO    101018  Message 169.183.186.58:0]   Preparing to send large message Size=288414 HeaderLength=251 BodyLength=288155 #ArraySegments=74. Msg=Request *cli/0984e7a1@50b9f88b->S169.183.186.58:30000:0*grn/B9FC61B7/00000000 #5: global::Server.GrainInterface.IInstrumentQueryGrain:Add()   \n```\n\nSize here is 288155 which is less than 300 KB, so really not that big. I'm also running everything on the same PC. However, I remember it actually taking more than 5 seconds to send which seems extremely long to me considering the size.\n\nI solved this problem when sending to a grain by **sending the message in batches**. My message was a list of items, so it was easy to just split them into smaller lists.\n\nThe problem now is that I don't see how this can be done when it's the other way around i.e. **a grain is returning a big message to its caller**.\n\n---\n\n**TL;DR**\n1- Am I supposed to send only small messages?\n2- Why does it take so long to send a 300 KB message on the same PC?\n3- How to handle this when returning a big message from a grain to the caller?\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1481/comments",
    "author": "amamh",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-02-20T00:46:47Z",
        "body": "This is very strange. There is no restriction on sending small messages, and of course 300KB cannot take even close to that long. The warning is for information purposes and is a bit historical. It was more important before we implemented the buffer pool and Large Object Heap was an issue.\n\nCan you double-check what you are measuring? Is it possible that you included the grain activation time, and the grain is somehow slow in its OnActivateAsync()? Just guessing. Or maybe there is some other one-time initialization that's happening upon a first call.\n"
      },
      {
        "user": "amamh",
        "created_at": "2016-02-20T00:48:36Z",
        "body": "@sergeybykov \n\nThanks for the reply, I'll do further testing. If I can get a sample project to reproduce the problem, I'll post it here.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-02-20T01:21:46Z",
        "body": ":+1:\nTo be clear, many of Orleans-based services send large messages. Even internally, cache validator sends huge messages to directory partitions. And it's always fast.\n"
      },
      {
        "user": "amamh",
        "created_at": "2016-03-03T11:26:57Z",
        "body": "I think this could have been a mistake on my part somehow, but unfortunately I cannot investigate further at the moment.\n"
      }
    ]
  },
  {
    "number": 1473,
    "title": "Considerations when upgrade from 1.0.9 to 1.1.2 ?",
    "created_at": "2016-02-18T02:40:24Z",
    "closed_at": "2016-02-24T02:02:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1473",
    "body": "Hi,\n\nWe are upgrading from Orleans 1.0.9 to 1.1.2, besides required code changes, we are facing exceptions when load 1.0.9's GrainStates and Reminders, are there any known-issues when upgrade? like breaking changes with old data?\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1473/comments",
    "author": "hyha600",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-02-18T05:54:13Z",
        "body": "I'm almost sure 1.0.10, 1.1.1 and 1.1.2 are not backward compatible with 1.0.9 because of the serializer change and likely some other changes. I'm afraid a manual conversion of stored data to the new format is needed.\n"
      },
      {
        "user": "hyha600",
        "created_at": "2016-02-18T07:48:44Z",
        "body": "Thanks Sergey for fast response, then is there any best practice to read/load the binary content (grainstate) independently from an active Orleans environment ? or anyway to convert them into readable JSON?\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-02-18T16:23:19Z",
        "body": "The version story is still in its infancy. It should get better developed as part of the storage API improvements that @jason-bragg has been thinking about.\n\nOne option I can think of is that you could use serializers generated in your code with 1.0.9 for state objects to deserialize persisted state and export it into JSON or reserialize with 1.1.2. Reminders are a bit trickier because they are internal, but it should be possible to migrate them in a similar way using 1.0.9 sources.\n\nMaybe there is a better way to do it that I can't think of right away.\n"
      },
      {
        "user": "hyha600",
        "created_at": "2016-02-24T02:02:05Z",
        "body": "Thank you, now we are creating a migration tool that uses a 1.0.9 silo host with mocked grains for that task.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-02-24T06:01:10Z",
        "body": "Could you share the tool and/or write a doc page for others.\n"
      }
    ]
  },
  {
    "number": 1465,
    "title": "Best way to maintain a list of active grains?",
    "created_at": "2016-02-16T17:56:31Z",
    "closed_at": "2016-02-18T10:47:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1465",
    "body": "I have a number of grains of type A and I want to have another grain of type B (or anything else) to be able to give me a list of ID's for all active type A grains.\n\nI thought of having grain B as:\n\n```\n    Task Register(string key);\n\n    Task Unregister(string key);\n\n    Task<List<string>> GetAll();\n```\n\nBut that is a bad idea because this will have to be a single grain that all A grains call when they activate/deactivate, so it's a bottleneck.\n\nMy questions are:\n- **Is it possible to make this grain Reentrant to get rid of the bottleneck? The problem is that \"List\" is not thread-safe and I have a feeling that using \"lock\" inside a grain is a bad idea.**\n- **Is there another way to maintain a list of active grains of type A?** There has to be a better way of doing this.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1465/comments",
    "author": "amamh",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-02-18T01:44:12Z",
        "body": "There is nothing better way at the moment. There are separate relevant discussions of adding support for querying and about broadcast messaging.\n\nYou can make B reentrant. Using a List is safe because the grain is still single-threaded even if reentrant. However, reentrancy can only help here if within the methods you await other async operations, e.g. IO or calls to other grains. If methods are simple with a single turn, then reentrant won't give you anything.\n\nTo avoid the bottleneck, you could consider partitioning a single B into a grain pool of multiple B grains, where each A grain would register with a B grain deterministically picked based on its own ID, e.g. by calculating a modulo. For querying, you would have to fan out a call to all B grains and merge their responses.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2016-02-18T06:13:42Z",
        "body": "Just to add the obvious (for a random person reading this issue) that what you are asking about is non-idiomatic in Orleans and basically breaks the fundamental abstraction of Virtual Actors. With Virtual Actors you should NOT be asking or be interested to know \"all active type A grains\" (I presume by active you mean those that have activation in memory).\n"
      },
      {
        "user": "amamh",
        "created_at": "2016-02-18T10:47:22Z",
        "body": "@gabikliot  Thanks, but what if I want to have a monitoring grain that keeps track of how many grains are currently alive for example?\n\n@sergeybykov \n\n> Using a List is safe because the grain is still single-threaded even if reentrant. \n\nThanks for pointing that out.. there was some serious misunderstanding on my part. I thought that Reentrant means multiple calls can execute in parallel. I have read the documentation again and I understand now it means methods can interleave but are still single threaded.\n\nI think since I had the wrong idea of what \"Reentrant\" means, this issue should be closed now.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2016-02-18T15:54:45Z",
        "body": "We have statistics API via management grain for that.\n"
      }
    ]
  },
  {
    "number": 1453,
    "title": "MQTT Broker as Orleans Grain",
    "created_at": "2016-02-12T21:29:15Z",
    "closed_at": "2016-04-28T22:46:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1453",
    "body": "High Guys, \nI was wondering if anyone could help me with guidelines to building MQTT broker as an Orleans client. I am trying to implement a setup where the broker can be spread up as Grains for clients to subscribe. \nEach grain will be identified by the ID of the group/Organization(Primary Key).\n\nThanks in advance\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1453/comments",
    "author": "SteveOmondi",
    "comments": [
      {
        "user": "amamh",
        "created_at": "2016-02-15T15:39:19Z",
        "body": "Hey,\n\nI think your question needs to be a bit more specific if you want people to help. Just a thought :)\n"
      },
      {
        "user": "ernestjohn",
        "created_at": "2016-03-04T10:02:07Z",
        "body": "Hey Steve, sure you need to be more specific please. Please elaborate the context :-)\n"
      }
    ]
  },
  {
    "number": 1373,
    "title": "Are Reminder Names unique per grain?",
    "created_at": "2016-02-04T18:45:10Z",
    "closed_at": "2016-02-11T00:59:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1373",
    "body": "Breaking my head here...\n\nHave 2 grain types: Sites and Nodes.\n\nBoth implement reminders.\nThis is how I register the reminder:\n`await RegisterOrUpdateReminder(REMINDER_NAME, TimeSpan.FromMinutes(TMO), TimeSpan.FromMinutes(PERIOD));`\n\nREMINDER_NAME, TMO and PERIOD are private constants per class, obviously different for Site than for Node.\n\nIn TableStorage I see a Reminder row per site as expected\nBut I only see one reminder for all the nodes, like if it is reused.\n\nQuestion: Do I need to append the unique identity to the ReminderName?\n\nThx!\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1373/comments",
    "author": "ukluk",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-02-04T18:48:31Z",
        "body": "Each grain has its own set (sort of a namespace) of reminders. Reminder names can be safely reused across grains and grain types. I suspect the issue is probably somewhere else. Are you sure `RegisterOrUpdateReminder` is successfully called from more than one grain?\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2016-02-09T04:12:59Z",
        "body": "@ukluk , were you able to make more progress on that?\nCan that issue be closed?\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-02-11T00:59:10Z",
        "body": "I'll close it. @ukluk please reopen if something isn't working as expected.\n"
      }
    ]
  },
  {
    "number": 1367,
    "title": "How to get all the activated GrainIds at any given point in time",
    "created_at": "2016-02-03T21:53:28Z",
    "closed_at": "2016-03-18T07:05:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1367",
    "body": "This is a question.  Is there a way to get all the GrainIds that are currently active i.e those grain actually activated in the Silos.\n\nThe ManagementGrain Interface currently only returns, the count of grains per type.  Is this stored in one of the Azure Tables which orleans uses.\n\nThanks.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1367/comments",
    "author": "loneshark99",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2016-02-06T02:03:48Z",
        "body": "No, it is not stored in any table.\nEvery silo stores in memory the set of activations it currently hosts, an in addition there is a distributed directory that stores, also in memory the mapping from grain ID to the silo that currently has an activation for this silo.\nIt is possible to add methods to MgmtGrain to retrieve this information. As long is it is very clear that this should be used for management/troubleshooting only, and not as part of the programming model, it should be fine.\n\nIt should be also interesting to use Streams to stream back the (potentially large) list.\n"
      }
    ]
  },
  {
    "number": 1253,
    "title": "Suggest to Add a Method if State Load fails",
    "created_at": "2016-01-08T18:20:26Z",
    "closed_at": "2021-04-06T19:13:48Z",
    "labels": [
      "enhancement",
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1253",
    "body": "\"Dealing with extensible state and binary serialization\"\n\nNice if the grain has a callback if the state fails after activation\nOnReadStateFailed\n\nIn here programmers can add transformation code from old to new state models. Example\nLoad **Grain01v2**.\nif it failed, try to load **Grain01v1** State, convert the object with some DTO and then serialize back the transformed state.\n\nOr do you guys recommend a better path to extend state using binary formatter?\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1253/comments",
    "author": "ukluk",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2016-01-09T03:38:04Z",
        "body": "One way to handle it is inside the storage provider.\nYou can have your storage provider handle failed reads. Your storage provider can be based upon (extend by inheritance vs composition) an existing storage provider - \"decorate\" it with extra version tolerance.\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2021-04-06T19:13:48Z",
        "body": "Closing this due to inactivity. I think it's a fair request. I'm not sure how actionable it would be for the user in most cases, however.\r\nGabi's suggestion is still applicable. There is also #2653 to track version-tolerant serialization in general and a PR to implement per-provider pluggable storage: #6936. There is a similar issue opened on being able to evolve grain state: #61"
      }
    ]
  },
  {
    "number": 1220,
    "title": " Hosting AzureSilo and Web layer on the same worker role",
    "created_at": "2015-12-31T20:21:25Z",
    "closed_at": "2016-01-07T03:37:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1220",
    "body": "This is a question . In Azure, can a same worker role be a Client (http but selfhosted webapi)  as well as host the Orleans Silo.  As per the examples I have seen they are separate roles.  \n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1220/comments",
    "author": "loneshark99",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2016-01-01T01:35:45Z",
        "body": "They can. But you need to host the client in a separate app domain. There are some examples in samples and unit tests.\n"
      },
      {
        "user": "loneshark99",
        "created_at": "2016-01-07T02:49:14Z",
        "body": "@gabikliot thank you, worked perfectly.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2016-01-07T03:37:33Z",
        "body": "Great.\n"
      }
    ]
  },
  {
    "number": 1025,
    "title": "Orleans Namespace Convention",
    "created_at": "2015-11-16T20:55:05Z",
    "closed_at": "2015-11-17T15:24:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1025",
    "body": "It's not so obvious for most of us what is the rationale behind Orleans namespace structure.\n\nFor example the file `Orleans\\Logging\\ILogConsumer.cs` is under namespace `Orleans.Runtime`...\n\nIs that any reason for it? Its a bit confusing for newcomers to get handy on Orleans code since VS automatically creates namespaces based on directories under the project and following the Default Namespace setting on project properties.\n\nSo, should we normalize all the projects in order to follow VS conventions or should be just follow as is?\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1025/comments",
    "author": "galvesribeiro",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-11-17T05:46:56Z",
        "body": "Yes, there was a reasoning behind that.\nBasically, the thinking was: put most useful APIs in the one root namespace, `Orleans`. Keep it slim and only for the core programming abstractions, so the new user can  see only what is really required and not all the advanced stuff.\nThe rest, more advanced stuff, put in derived namespaces. \nAlso, don't have to follow Java practice of matching folders to packages. Again, the goal is to make it easier for the user of Orleans: simple stuff is in one namespace `Orleans`, more advanced stuff is in a couple (and not 25) namespaces.\nWe got advice to organize it this way from a professional .NET API design gurus in MS.\n\nClearly, this is quite subjective and can be reviewed and changed.\n"
      },
      {
        "user": "galvesribeiro",
        "created_at": "2015-11-17T15:24:25Z",
        "body": "Ok no problem. Lets close this issue and move forward.\n\nThanks\n"
      }
    ]
  },
  {
    "number": 988,
    "title": "Dependency Injection: register IGrainFactory",
    "created_at": "2015-11-04T10:53:43Z",
    "closed_at": "2016-09-21T22:50:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/988",
    "body": "Currently I cannot construct objects which require `IGrainFactory` using DI in Orleans because the implementation is not registered.\n\nExample of a failure scenario:\n\n``` C#\npublic HasDeps : Grain, IHasDeps\n{\n  public HasDeps(SomeDep someDep) { /* ... */ }\n}\n\n// Imagine I register SomeDep in the container...\npublic SomeDep\n{\n  public SomeDep(IGrainFactory grainFactory) { /* ... */ }\n}\n```\n\n Is there a good reason for `IGrainFactory` (and friends?) not to be in the container?\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/988/comments",
    "author": "ReubenBond",
    "comments": [
      {
        "user": "nehmebilal",
        "created_at": "2015-11-04T22:46:25Z",
        "body": "Can you register the `IGrainFactory` yourself the same way you register any other dependency?\n\nI think the long term plan is to potentially have multiple instances of the `IGrainFactory` (client connecting to multiple silos or silo connecting to another silo, see #467) in which case you'll need to use named dependencies or to inject some sort of service locator that allows you to retrieve the appropriate `GrainFactory` inside `SomeDep`.\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2015-11-04T22:52:11Z",
        "body": "This is on the silo, not the client. The `IGrainFactory` which is injected into `SomeDep` should be the same as the one injected into `HasDeps`.\n"
      },
      {
        "user": "nehmebilal",
        "created_at": "2015-11-04T22:56:22Z",
        "body": "How do you know? If the Silo is connecting to another Silo, there will be another instance of `IGrainFactory` that is associated with the second Silo. `SomeDep` is just a class and there is no way to tell if it's looking for currentSilo.GrainFactory or OtherSilo.GrainFactory.\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2015-11-04T23:06:37Z",
        "body": "It should take the instance from the current lifetime/scope, right? It would be weird if the `IGrainFactory` in `HasDeps` differs from that in `SomeDep` without me explicitly saying it should differ.\n\nHow do you propose we actually provide `IGrainFactory` to dependency classes?\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2015-11-04T23:34:09Z",
        "body": "> \"Can you register the  IGrainFactory  yourself \"\n\nNot currently, its implementation is internal.\n\n> \"If the Silo is connecting to another Silo, there will be another instance of  IGrainFactory  that is associated with the second Silo\"\n\n???  This breaks the virtual actor model, does it not ???  I don't want to side track this discussion, but this statement seems to be counter to the fundamentals of the programing model.\n\nAt tertiary glance it looks like we can add the grain factory to the list of services (IServiceCollection) in RegisterSystemTypes().  We'll need to get it from the service provider when setting it in the runtime, or removed it from the runtime and always get it from the service provider (and other such cleanup).  Does not look hard...?\n"
      },
      {
        "user": "nehmebilal",
        "created_at": "2015-11-05T00:11:07Z",
        "body": "> ??? This breaks the virtual actor model, does it not ??? I don't want to side track this discussion, but this statement seems to be counter to the fundamentals of the programing model.\n\nThat's a good point, I don't know, up to you guys to decide :smiley:  You still have the issue on the client side if you're trying to connect to multiple silos. \n\nI am not sure what DI framework is Orleans using right now, but here is how I would do it with Unity:\n\n``` csharp\ncontainer.RegisterType<IGrainFactory>(\"Silo1Factory\", new ContainerControlledLifetimeManager(), new InjectionFactory(\n    c =>\n    {\n        GrainClient.Initialize(\"OrleansClientConfiguration1.xml\");\n        return GrainClient.GrainFactory;\n    }));\n\ncontainer.RegisterType<IGrainFactory>(\"Silo2Factory\", new ContainerControlledLifetimeManager(), new InjectionFactory(\n    c =>\n    {\n        GrainClient.Initialize(\"OrleansClientConfiguration2.xml\");\n        return GrainClient.GrainFactory;\n    }));            \n\ncontainer.RegisterType<SomeDep>(\n    new InjectionConstructor(                        \n        new ResolvedParameter<IRepository>(\"Silo1Factory\")\n    )\n);\n```\n\nSorry that doesn't help for the server side `GrainFactory` which I am not sure how to retrieve.\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2015-11-05T00:11:18Z",
        "body": "> > If the Silo is connecting to another Silo, there will be another instance of IGrainFactory that is associated with the second Silo\n> \n> ??? This breaks the virtual actor model, does it not ??? I don't want to side track this discussion, but this statement seems to be counter to the fundamentals of the programing model.\n\nI believe @nehmebilal meant to say \"cluster\" instead of \"silo\"\n"
      },
      {
        "user": "nehmebilal",
        "created_at": "2015-11-05T00:23:54Z",
        "body": "> I believe @nehmebilal meant to say \"cluster\" instead of \"silo\"\n\n:+1: \n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-11-05T01:08:10Z",
        "body": "We definitely want a client to be able to connect to multiple clusters. However, I do not see a case for needing the same on the silo side. Mocking for testing is a different question, of course.\n"
      },
      {
        "user": "nehmebilal",
        "created_at": "2015-11-05T17:38:37Z",
        "body": "Then we just need to register the `IGrainFactory` as part of Silo initialization as suggested by @ReubenBond and @jason-bragg. That should solve the server side dependency injection of `IGrainFactory`.\n"
      },
      {
        "user": "vidrir",
        "created_at": "2016-01-27T02:49:06Z",
        "body": "I would love to see this resolved.  We need a way to pass the IGrainFactory when constructing our Mocks for DI in testing.\n"
      },
      {
        "user": "michaelahern",
        "created_at": "2016-01-27T14:58:38Z",
        "body": "+1\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2016-01-27T22:27:28Z",
        "body": "I took a pass at this in \"Injection of grain factory #1342\"\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2016-02-03T20:13:22Z",
        "body": "I withdrew PR #1342\".  My first pass at this simply registered the GrainFactory with the set of Orleans services provided to the container during it's initialization.  This allows for users to replace this implementation, but this does not really work because, while GrainFactory conforms to a public interface IGrainFactory, Orleans internals relies on internal calls in the concrete GrainFactory implementation.  These call's can't be mimicked by an external class, so the GrainFactory can't be injected in any practical manner.\n\nThis is not, as i'd initially assumed, simply a case of registering the grain factory with the DI system and requesting it from the service provider when needed.\n\nTo do this, we'll need to separate the public GrainFactory capabilities (described in IGrainFactory) from the internal capabilities, which is more than I was willing to take on at this time.\n"
      },
      {
        "user": "xiazen",
        "created_at": "2016-08-24T23:34:12Z",
        "body": "so step 1: separate public capabilities in concrete GrainFactory implementation to a new class PublicGrainFacotry, clean original GrainFactory class to reduce code redundancy.\nstep 2: figure out DI on public GrainFactory. \n\nI can take the initiate to look at step 1, and then step 2.  \n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2016-08-25T00:38:59Z",
        "body": "> \"separate public capabilities in concrete GrainFactory implementation to a new class PublicGrainFactory\"\n\nI don't think we want a PublicGrainFactory class as much as we want the Interface to contain all of the publicly necessary calls.  Am I missing something?  Is there a need for a public grain factory concrete class?\n\n> \"Figure out DI on public GrainFactory\"\n\nAgreed, but I think we want to register the grain factory by interface rather than concrete type.\n\nStep 3: Profit!\n"
      },
      {
        "user": "xiazen",
        "created_at": "2016-08-25T01:05:29Z",
        "body": "addressed comments in person \n"
      },
      {
        "user": "jdom",
        "created_at": "2016-09-21T22:50:28Z",
        "body": "Resolved by #2192\n"
      }
    ]
  },
  {
    "number": 984,
    "title": "Edge Grain Strategy ",
    "created_at": "2015-11-03T22:13:58Z",
    "closed_at": "2015-11-16T17:20:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/984",
    "body": "Im hoping someone can give me a hand with a general sanity check on how I pass data to my edge grains. We receive our messages from a 3rd party ESB(java) that can send messages over tcp or write to our mongo db directly.(or call a WS, etc.) The current plan is to create a persistentstreamprovider that feeds itself from the mongodb. The alternate option that I considered was to create a simple tcp listener that fed a stateful(mongo storage provider) edge grain. This application will receive 10 transactions/second initially and will need to perform parsing/rules processing in near real-time, but we expect that the throughput to scale linearly and the processing to scale somewhat exponentially as we add customers.(the average message size is ~30kb) I considered creating an orleans client layer(perhaps webapi), but I was hoping to avoid the need to manage another possible point of failure. There are times in which I will need to refeed old transactions and I do need this system to be durable, so I was really leaning toward the db-driven approach as it seems I could handle re-feeding old messages, re-feeding unprocessed messages(after a fatal system failure), and feeding new messages all from the same queue. Im a little concerned about the performance hits I may take by adding the overhead of a polling pull, but maybe Im trying to overengineer this...Any guidance/thoughts are much appreciated!\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/984/comments",
    "author": "bstead",
    "comments": [
      {
        "user": "jason-bragg",
        "created_at": "2015-11-04T02:19:15Z",
        "body": "Questions:\n    In processing (or reprocessing) messages from mongodb, does order matter?\n    How tolerant is your message processing to duplicated messages?\n"
      },
      {
        "user": "bstead",
        "created_at": "2015-11-04T02:58:50Z",
        "body": "Order does not matter and I think we can handle dupes at every stage in the processing....To the point where if the system went down and some messages were mid-process, re-feeding them completely could produce the same result.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-11-04T04:08:32Z",
        "body": "So effectively you are considering using MongoDB as a persistent queue, right? That's a sensible design to me if you want to receive those messages from the 3rd party and persist on your side.\n\nThe alternative without a queue is for the 3rd party to send (and resend if necessary) those messages to your HTTP frontend with an Orleans Client. The benefit of this approach is that you would not only eliminate MongoDB from the picture (fewer moving parts), but you could reduce latency, and have a way return meaningful responses (e.g. results of processing) to the sender. The downside is that you'd lose the loose coupling property of the solution with a queue.\n\nOf course, this completely depends on what kind of system you have on the other end and what the requirements are. I'm not suggesting this as a better solution, only using it for a comparison.\n"
      },
      {
        "user": "bstead",
        "created_at": "2015-11-04T15:42:15Z",
        "body": "Thanks a lot for your help. I think we are on the same page.\n\nIm going to go with the Mongo approach for now since Ill need something similar anyway to refeed old messages and I am up against an ambitious deadline. (At times we will change how we process messages and will need to parse new data from the old data.) I may need to reassess immediately upon testing :) but, hopefully this gets the job done.\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2015-11-04T21:12:35Z",
        "body": "Processing data from mongoDB, two options come to mind.\n\n**Work Dispatcher Role**\nDevelop an Orleans Client role that reads from mongoDB and dispatches work to the Orleans silo worker roles.  This is very strait forward, but you'd need to write your own message dispatching, replay, and error handling logic.  This may also include availability issues like dealing with rebalancing responsibilities when reader roles become unavailable for extended periods of time.\n\n**Streams**\nThe streaming interfaces support your needs, but the out-of-the-box stream providers don't fully support your scenario.  This means you'd probably need to build your own stream provider (I would suggest a modified version of the PersistentStreamProvider).\n\n_Considerations_\n- The existing PersistentStreamProvider enforces ordered delivery, which may work for your environment but is not necessary and could introduce processing delays, especially when errors occur (poison message problem for instance).\n- The existing PersistentStreamProvider supports only limited rewind/replay capabilities.  It can replay recent events from a message cache, but if events are no longer in the message cache, the replay attempt will not go back and reread them from the store (mongoDB).\n\nThe PersistentStreamProvider could be customized to address these capabilities allowing you to take advantage of much of the stream processing infrastructure (queue balancing, subscription management, event delivery, recovery/error handling).  It should be noted that while the stream processing infrastructure is being used in large scale production environments, it is one of the newest Orleans feature sets, so it has not as mature as much as the virtual actor model.\n"
      },
      {
        "user": "bstead",
        "created_at": "2015-11-10T01:05:00Z",
        "body": "Thanks for the details on this. Given the feedback and some further research/testing, Ive decided to start with a simpler approach using actors. \n\nIdeally, Id like to begin dispatching work on silo startup.Since this is an on-premise system, roles did not appear to be an option for me. It sounds as if a windows service to pass messages to the grains would be the advisable alternative? I also considered kicking off a timer on init(or bootstrapping it). This seemed straight forward(but perhaps messier). Am I missing something that may be more applicable here for on-premise solutions?\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2015-11-10T01:18:51Z",
        "body": "> \"Am I missing something that may be more applicable here ...?\"\n\nNot that I can see.\n\n> \"It sounds as if a windows service to pass messages to the grains would be the advisable alternative?\"\n\nThis seems comparable to the 'Work Dispatcher Role' approach raised previously.  A windows service as an Orleans client could read from MongoDB and dispatch the processing to grains distributed among Orleans Silos. I think this is a reasonable approach.  It's really a question of tradeoffs, but this is probably the more strait forward approach.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-11-16T17:20:23Z",
        "body": "@bstead Feel free to reopen if needed.\n"
      }
    ]
  },
  {
    "number": 934,
    "title": "Orleans service provider not available to application layer.",
    "created_at": "2015-10-23T00:26:59Z",
    "closed_at": "2017-08-23T22:56:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/934",
    "body": "A while back an IServiceProvider was introduced into the Silo to allow application developers to inject dependencies into Orleans.  The service provider is initialized with a configurable hook that creates a service provider from a service collection.\n\nFrom test code:\npublic class TestStartup\n{\n  public IServiceProvider ConfigureServices(IServiceCollection services)\n  {\n    services.AddSingleton<IInjectedService, InjectedService>();\n    services.AddTransient<SimpleDIGrain>();\n    return services.BuildServiceProvider();\n  }\n}\n\nThis allows application developers to provide Orleans a service provider to use.  However, there is, to my knowledge, not currently a way for application logic to actually use this provider.  It is marked as internal and accessible only to Orleans code.\n\nAs it is, if I want to use the same service provider as Orleans uses, I need to provide my own service provider (as in the test code from above) but do it in a way where I can also return the same provider to my application code.  This is peculiarly inconvenient.\n\n1) Is this isolation intended, or just an unfortunate implementation detail of the first pass implementation?\n2) If we wanted to expose the Orleans service provider to the application layer, how should this be done?  Singleton?  Attach to static data like Silo? ...?\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/934/comments",
    "author": "jason-bragg",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-10-23T03:09:15Z",
        "body": "Cc @attilah\n"
      },
      {
        "user": "attilah",
        "created_at": "2015-10-23T10:43:40Z",
        "body": "I owe the community a document page, but meanwhile the unit test for the DI would be a great starting point.\n\nSince Orleans provides a precompiled host and usually you get a chance to add your own logic via Bootstrap providers, DI is implemented similar.\n\nYou can define a Startup type in the configuration file like:\n\n```\n    <Startup Type=\"UnitTests.General.TestStartup,Tester\" />\n```\n\nWe're utilizing Asp.Net vNext DI implementation, so their rules are our rules.\n\nIn this startup type you must define a ConfigureServices method, where you can register your own grains, services, etc. which will be later injected into your grains' ctor when you're using it.\n\nHere is the Startup class from the test:\n\n```\n    public class TestStartup\n    {\n        public IServiceProvider ConfigureServices(IServiceCollection services)\n        {\n            services.AddSingleton<IInjectedService, InjectedService>();\n\n            services.AddTransient<SimpleDIGrain>();\n\n            return services.BuildServiceProvider();\n        }\n    }\n```\n\nIf you are like me and like to use another DI container like Autofac (my preference), in this method you can configure that container and return the provider built by the Autofac adapter.\n\nI hope this helps!\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2015-10-24T07:43:01Z",
        "body": "Thanks @attilah, but I'm familiar with how to configure the service provider, my question was in regards to getting access to it at the application layer.  The IServiceProvider created the ConfigureServices call is stored in an internal property Silo.CurrentSilo.Services.  This property being internal means there is no way for the application layer (my grains, for example) to get access to it.\n\nIn my service provider builder, I can place the service provider into my own singleton, so I can access it in the grain, but that is quite hacky.  This kind of kludge should not be necessary.\n\nI would like the service provider created for Orleans to be available to the application layer, so it can be used to get access to other injected dependencies.\n"
      },
      {
        "user": "attilah",
        "created_at": "2015-10-24T12:40:30Z",
        "body": "Can you please describe the use case for it? And why not ctor or property injection of services are suffice?\n\nImho using the serviceprovider in code without a common service locator is an antiattern.\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2015-10-25T22:36:14Z",
        "body": "@attilah \nThe particular instance where I've encountered this is that I'm writing a stream provider with dependencies I'd like to inject.  There are a number of ways I can achieve this, but my preference is to use Orleans's service provider, but as I previously mentioned, it is internal.\n\nFrom what you've put forward so far, I'm guessing the approach you'd prefer would be to have stream providers be constructed using the ServiceProvider, that way the service provider can inject itself at construction time or in properties for stream providers that need access to it.  Is this correct?\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2015-10-30T20:20:59Z",
        "body": "Tinkering with this more, I've encountered some difficulties using the current DI infrastructure.  To use the common service locator in any grains, providers, or any other constructed classes, the constructed class 'should' have the ServiceProvider injected into it at construction time.  To do this requires the following:\n1) The Orleans infrastructure must use the service provider to create the object\n2) The service provider must be able to create the class of interest.\n3) The service provider must support constructor or property injection.\n\n1 Can be addressed buy updating Orleans code to use the service provider to create other classes of interest.\n2 and 3 are the real problem.  Using the default service provider, we get 2, but not 3.  Since Orleans infrastructure must work with the default service provider, we can't use property or constructor injection without providing a custom service provider.  If we fix this, by replacing the default service provider with one that can use property and constructor injection, we then need a way for it to know about application layer grains.\n\nI think we need a public way to register classes (grains at least) in the IServiceCollection prior to creating the service provider, and the default service provider needs to support constructor injection.\n\nWith this we can properly use dependency injection in grain, provider, and or any other Orleans created components.  \n\nThoughts?\n\nIf there is general agreement on this, I'll open a feature request issue for this and close out this thread.\n"
      },
      {
        "user": "attilah",
        "created_at": "2015-10-31T01:06:40Z",
        "body": "Extending Orleans usage into more parts of the framework itself to instantiate and register the logging, plugin and provider classes for example is on my personal roadmap. That is what will enable the broad usage is DI for application code, which is currently limited to services and grains. Beside grains, no other Orleans constructs can leverage the DI capabilities. For first we'd like to have a solid ground for DI within Orleans, and now that we've that we can enhance it.\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2015-10-31T01:47:49Z",
        "body": "Understood.  To see where some of these questions were coming from, please check out PR #972 \nSpecifically GeneratorAdapterFactory.\n"
      }
    ]
  },
  {
    "number": 920,
    "title": "Concurrent Writes State = TableStorage",
    "created_at": "2015-10-16T20:48:23Z",
    "closed_at": "2015-10-23T00:58:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/920",
    "body": "We are seeing an exception thrown by TableStorage, and after investigation it seams that ETag is dirty meaning that we are seeing concurrent writes.\n\nQ1) If the grains are single threaded how can it be that we are seeing ETag exceptions when Writing the state?\nQ2) What is you recommendation to avoid Grain concurrency, as the client can get multiple requests almost simultaneously\nQ3) What is your recommendation to handle state if we get non transient errors? Ignore? Clear? wait and retry?\n\nThis is the offending code\npublic async Task AggregateAsync(DateTime msgTimeUtc, Guid messageId, NodeState nodeState, Guid resourceId)\n        {\n                //some aggregation\n                await WriteStateAsync();\n\nAnd this is the unraveled exception:\n\nOrleans.Runtime.OrleansException\nError from storage provider during WriteState for grain Type=Mesh.Ratatouille.Devices.SiteGrain Pk=_grn/A866C8EA/0000000000000000ffffffffffffffff03ffffffa866c8ea-0x4362189B Id=GrainReference:_grn/A866C8EA/ffffffff Error=UpdateConditionNotSatisfied\n\nExc level 0: Microsoft.WindowsAzure.Storage.StorageException: Message = The remote server returned an error: (412) Precondition Failed., HttpStatusCode = 412, HttpStatusMessage = Precondition Failed, ExtendedErrorInformation.ErrorCode = UpdateConditionNotSatisfied, ExtendedErrorInformation.ErrorMessage = The update condition specified in the request was not satisfied.\nRequestId:e4453aae-0002-0036-4751-08fc92000000\nTime:2015-10-16T20:30:49.3055925Z.\n   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndExecuteAsync[T](IAsyncResult result)\n   at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at Orleans.AzureUtils.AzureTableDataManager`1.<UpdateTableEntryAsync>d__1e.MoveNext()\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at Orleans.Storage.AzureTableStorage.GrainStateTableDataManager.<Write>d__1f.MoveNext()\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at Orleans.Storage.AzureTableStorage.<WriteStateAsync>d__9.MoveNext()\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at Orleans.Core.GrainStateStorageBridge.<WriteStateAsync>d__5.MoveNext()\nExc level 1: System.Net.WebException: The remote server returned an error: (412) Precondition Failed.\n   at Microsoft.WindowsAzure.Storage.Table.Protocol.TableOperationHttpResponseParsers.TableOperationPreProcess(TableResult result, TableOperation operation, HttpWebResponse resp, Exception ex)\n   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndGetResponse[T](IAsyncResult getResponseResult)\n   at Orleans.Core.GrainStateStorageBridge.<WriteStateAsync>d__5.MoveNext()\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at Mesh.Ratatouille.Devices.SiteGrain.<UpdateFieldGatewayStateAsync>d__19.MoveNext() in c:\\Users\\Uriel\\Source\\Repos\\ActiveSense\\Mesh.Ratatouille.Devices\\SiteGrain.cs:line 183\n----------Inner Exception----------\nMicrosoft.WindowsAzure.Storage.StorageException\nThe remote server returned an error: (412) Precondition Failed.\n   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndExecuteAsync[T](IAsyncResult result)\n   at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at Orleans.AzureUtils.AzureTableDataManager`1.<UpdateTableEntryAsync>d__1e.MoveNext()\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at Orleans.Storage.AzureTableStorage.GrainStateTableDataManager.<Write>d__1f.MoveNext()\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at Orleans.Storage.AzureTableStorage.<WriteStateAsync>d__9.MoveNext()\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at Orleans.Core.GrainStateStorageBridge.<WriteStateAsync>d__5.MoveNext()\n    RequestResult:\n        HTTPStatusCode:    412\n        HttpStatusMessage: Precondition Failed\n        TargetLocation:    Primary\n        ServiceRequestID:  e4453aae-0002-0036-4751-08fc92000000\n        ContentMd5:  \n        Etag:  \n        RequestDate:       Fri, 16 Oct 2015 20:30:48 GMT\n        StartTime:         10/16/2015 8:30:49 PM\n        EndTime:           10/16/2015 8:30:49 PM\n\n----------Inner Exception----------\nSystem.Net.WebException\nThe remote server returned an error: (412) Precondition Failed.\n   at Microsoft.WindowsAzure.Storage.Table.Protocol.TableOperationHttpResponseParsers.TableOperationPreProcess(TableResult result, TableOperation operation, HttpWebResponse resp, Exception ex)\n   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndGetResponse[T](IAsyncResult getResponseResult)\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/920/comments",
    "author": "ukluk",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2015-10-20T22:35:19Z",
        "body": "Q1) There is a small window during a silo failure when if you are unlucky you may get two activations of the same grain activated at the same time. One of them will get removed after the cluster state settles. You shouldn't see that in the absence of silo failures.\n\nQ2) Again, shouldn't be a concern in general.\n\nQ3) In case you got into an eTag mismatch, you have two basic options:\n- Call ReadStateAsync() to reload the state object, then reapply changes, and call WriteStateAsync()\n- Call DeactivateOnIdle() and then throw an exception. If the client retries, the request will be redelivered to a new activation with the latest persistent state.\n"
      }
    ]
  },
  {
    "number": 890,
    "title": "Receiving events from Azure Queue Stream Provider multiple times",
    "created_at": "2015-10-08T22:57:40Z",
    "closed_at": "2015-11-16T17:26:03Z",
    "labels": [
      "bug",
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/890",
    "body": "I appear to have an issue which I have been chasing for a few weeks now, where when I push messages down a stream the consumer/handler is not receiving them.\n\nI have this issue in my main solution which has 23 projects, but managed to replicate it in a simple solution as well.\n\nI'll take some time to explain the set up I have: \n\nI have three grain types: Red, Blue and Green.\n\nThe Red grain has one function which takes a string and posts it as a byte array down into two separate streams, both with an id of `guid.empty`\n\nThe Blue and Green grains have an `ImplicitStreamSubscription` to `TestStream` and `TestStream2` respectively.\n\nTo start with, everything works as expected, the Red grain sends the events down `TestStream` and `TestStream2` and the handlers in both the Blue and Green grains receive the events, but within a few minutes (I appear unable to work out 'why') the handlers stop receiving the events, even though they appear to be submitted.\n\nWhen trying to replicate the issue, just having one stream, it didn't appear to cause any issues and firing at streams with different id's for each request didn't have an issue either. It only appeared to be an issue if firing off to a stream which had already had data sent to it. \n\nHowever, after reading #884 it could be the cause of the issue, as I am getting a log full of `QueueCacheMissExceptions` - if it is will reverting back to an older version of Orleans be a workaround until the next release?\n\n```\n[2015-10-08 22:44:48.073 GMT    17  ERROR   103315  PullingAgentSystemTarget/FF/821b63b5-QueueStore 127.0.0.1:11111]    !!!!!!!!!! Ignored RunConsumerCursor Error  \nExc level 0: Orleans.Streams.QueueCacheMissException: Item not found in cache.  Requested: [EventSequenceToken: SeqNum=31, EventIndex=0], Low: [EventSequenceToken: SeqNum=190, EventIndex=0], High: [EventSequenceToken: SeqNum=191, EventIndex=0]\n   at Orleans.Providers.Streams.Common.SimpleQueueCache.InitializeCursor(SimpleQueueCacheCursor cursor, StreamSequenceToken sequenceToken)\n   at Orleans.Providers.Streams.Common.SimpleQueueCache.TryGetNextMessage(SimpleQueueCacheCursor cursor, IBatchContainer& batch)\n   at Orleans.Providers.Streams.Common.SimpleQueueCacheCursor.MoveNext()\n   at Orleans.Streams.PersistentStreamPullingAgent.<RunConsumerCursor>d__46.MoveNext()\n```\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/890/comments",
    "author": "BenjaminGibbs",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-10-08T23:02:59Z",
        "body": "@BenjaminGibbs , you are using Azure queue stream provider, right?\n\nIf you try the latest version from master, including #884, does it work? There indeed have been a number of fixes around those issues lately (multiple streams, some cache miss exceptions), and unfortunately you need all of them for things to work properly.\n"
      },
      {
        "user": "BenjaminGibbs",
        "created_at": "2015-10-08T23:04:14Z",
        "body": "Sorry yes I am using the Azure Queue Provider, sorry I should have mentioned that.\n\nI have not tried the master, I will download it and try it next.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-10-08T23:08:24Z",
        "body": "Yes, try the master. There is a good chance it will fix the issue.\n"
      },
      {
        "user": "BenjaminGibbs",
        "created_at": "2015-10-12T17:51:13Z",
        "body": "On the surface the issues appear to be fixed when using the master. I am going to do a bit more testing this evening and see if anything else pops up.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-10-12T20:37:13Z",
        "body": "Sounds encouraging. Please keep us posted.\n"
      },
      {
        "user": "BenjaminGibbs",
        "created_at": "2015-10-13T01:18:35Z",
        "body": "So it works fine on the surface, when I push a similar workload to before it works like a dream, however when I push the workload so the streams get a backlog I start losing items and they don't get delivered. This is looking like a different error to before.\n\nFrom the log: I am using the AzureQueueStreamProvider with the default settings, queue count and cache size.\n\n```\n[2015-10-13 00:20:52.053 GMT    19  ERROR   103211  AzureQueueDataManager   127.0.0.1:11111]    !!!!!!!!!! Error doing DeleteMessage for Azure storage queue beta-queuestore-3 \nException = Microsoft.WindowsAzure.Storage.StorageException: The remote server returned an error: (404) Not Found. ---> System.Net.WebException: The remote server returned an error: (404) Not Found.\n   at Microsoft.WindowsAzure.Storage.Shared.Protocol.HttpResponseParsers.ProcessExpectedStatusCodeNoException[T](HttpStatusCode expectedStatusCode, HttpStatusCode actualStatusCode, T retVal, StorageCommandBase`1 cmd, Exception ex) in c:\\Program Files (x86)\\Jenkins\\workspace\\release_dotnet_master\\Lib\\Common\\Shared\\Protocol\\HttpResponseParsers.Common.cs:line 50\n   at Microsoft.WindowsAzure.Storage.Queue.CloudQueue.<DeleteMessageImpl>b__3a(RESTCommand`1 cmd, HttpWebResponse resp, Exception ex, OperationContext ctx) in c:\\Program Files (x86)\\Jenkins\\workspace\\release_dotnet_master\\Lib\\ClassLibraryCommon\\Queue\\CloudQueue.cs:line 2676\n   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndGetResponse[T](IAsyncResult getResponseResult) in c:\\Program Files (x86)\\Jenkins\\workspace\\release_dotnet_master\\Lib\\ClassLibraryCommon\\Core\\Executor\\Executor.cs:line 299\n   --- End of inner exception stack trace ---\n   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndExecuteAsync[T](IAsyncResult result) in c:\\Program Files (x86)\\Jenkins\\workspace\\release_dotnet_master\\Lib\\ClassLibraryCommon\\Core\\Executor\\Executor.cs:line 50\n   at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at Orleans.AzureUtils.AzureQueueDataManager.<DeleteQueueMessage>d__20.MoveNext()\nRequest Information\nRequestID:a09f9118-0003-0044-0f4c-052ccc000000\nRequestDate:Tue, 13 Oct 2015 00:20:34 GMT\nStatusMessage:The specified message does not exist.\nErrorCode:MessageNotFound\n\nExc level 0: Microsoft.WindowsAzure.Storage.StorageException: Message = The remote server returned an error: (404) Not Found., HttpStatusCode = 404, HttpStatusMessage = The specified message does not exist., ExtendedErrorInformation.ErrorCode = MessageNotFound, ExtendedErrorInformation.ErrorMessage = The specified message does not exist.\nRequestId:a09f9118-0003-0044-0f4c-052ccc000000\nTime:2015-10-13T00:20:35.0431917Z.\n   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndExecuteAsync[T](IAsyncResult result) in c:\\Program Files (x86)\\Jenkins\\workspace\\release_dotnet_master\\Lib\\ClassLibraryCommon\\Core\\Executor\\Executor.cs:line 50\n   at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at Orleans.AzureUtils.AzureQueueDataManager.<DeleteQueueMessage>d__20.MoveNext()\nExc level 1: System.Net.WebException: The remote server returned an error: (404) Not Found.\n   at Microsoft.WindowsAzure.Storage.Shared.Protocol.HttpResponseParsers.ProcessExpectedStatusCodeNoException[T](HttpStatusCode expectedStatusCode, HttpStatusCode actualStatusCode, T retVal, StorageCommandBase`1 cmd, Exception ex) in c:\\Program Files (x86)\\Jenkins\\workspace\\release_dotnet_master\\Lib\\Common\\Shared\\Protocol\\HttpResponseParsers.Common.cs:line 50\n   at Microsoft.WindowsAzure.Storage.Queue.CloudQueue.<DeleteMessageImpl>b__3a(RESTCommand`1 cmd, HttpWebResponse resp, Exception ex, OperationContext ctx) in c:\\Program Files (x86)\\Jenkins\\workspace\\release_dotnet_master\\Lib\\ClassLibraryCommon\\Queue\\CloudQueue.cs:line 2676\n   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndGetResponse[T](IAsyncResult getResponseResult) in c:\\Program Files (x86)\\Jenkins\\workspace\\release_dotnet_master\\Lib\\ClassLibraryCommon\\Core\\Executor\\Executor.cs:line 299\n[2015-10-13 00:20:52.061 GMT    19  ERROR   103211  AzureQueueDataManager   127.0.0.1:11111]    !!!!!!!!!! Error doing DeleteMessage for Azure storage queue beta-queuestore-3 \nException = Microsoft.WindowsAzure.Storage.StorageException: The remote server returned an error: (404) Not Found. ---> System.Net.WebException: The remote server returned an error: (404) Not Found.\n   at Microsoft.WindowsAzure.Storage.Shared.Protocol.HttpResponseParsers.ProcessExpectedStatusCodeNoException[T](HttpStatusCode expectedStatusCode, HttpStatusCode actualStatusCode, T retVal, StorageCommandBase`1 cmd, Exception ex) in c:\\Program Files (x86)\\Jenkins\\workspace\\release_dotnet_master\\Lib\\Common\\Shared\\Protocol\\HttpResponseParsers.Common.cs:line 50\n   at Microsoft.WindowsAzure.Storage.Queue.CloudQueue.<DeleteMessageImpl>b__3a(RESTCommand`1 cmd, HttpWebResponse resp, Exception ex, OperationContext ctx) in c:\\Program Files (x86)\\Jenkins\\workspace\\release_dotnet_master\\Lib\\ClassLibraryCommon\\Queue\\CloudQueue.cs:line 2676\n   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndGetResponse[T](IAsyncResult getResponseResult) in c:\\Program Files (x86)\\Jenkins\\workspace\\release_dotnet_master\\Lib\\ClassLibraryCommon\\Core\\Executor\\Executor.cs:line 299\n   --- End of inner exception stack trace ---\n   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndExecuteAsync[T](IAsyncResult result) in c:\\Program Files (x86)\\Jenkins\\workspace\\release_dotnet_master\\Lib\\ClassLibraryCommon\\Core\\Executor\\Executor.cs:line 50\n   at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at Orleans.AzureUtils.AzureQueueDataManager.<DeleteQueueMessage>d__20.MoveNext()\nRequest Information\nRequestID:c7b6bad1-0003-002f-364c-05719a000000\nRequestDate:Tue, 13 Oct 2015 00:20:34 GMT\nStatusMessage:The specified message does not exist.\nErrorCode:MessageNotFound\n```\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-10-13T01:33:09Z",
        "body": "This indeed looks a different issue.\nMy guess is that we try to delete twice from the queue and second time it fails, naturally.\nJason, I would check how we handle failed deletes. What happened for example if first delete succeeded but response timed out, would we retry and how. It can explain this log error.\n\nIt does looks though as a benign issue, if we failed to delete (maybe second time) its not a problem.\nBenjamin, is there any application visible problem? If not, it may be the 2nd delete case, and there is no problem \n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2015-10-13T01:37:37Z",
        "body": "I'll review the error handling logic.  We set a retry policy on the storage account, which would make this a natural error to receive any time the azure client library retries due to timeouts.  Our error handling should catch, log, and ignore this error when deleting messages.  If it does not, this is a bug.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-10-13T01:43:58Z",
        "body": "Thanks Jason. Agree with what you wrote. Of course, it could also be, in theory,  a different bug where we somehow try to delete a wrong msg that was never in the queue,,but I doubt.\n\nThe most important thing I think is to make sure that if the above error happens, we do ignore it and keep processing as nothing happened. If the msg was not deleted, it will re appear and we will re deliver, later on, in accordance with azure queue at least once semantics.\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2015-10-13T01:53:55Z",
        "body": "I've confirmed that we don't ignore this error.  It is logged and re-thrown, which will cause the main reader loop in the agent to exit until the next timer.  In general, this is not good, but should not cause data loss.\n\nTo mitigate this some, until we get a fix, you can set \"GetQueueMessagesTimerPeriod\" to TimeSpan.FromMilliseconds(10) in the provider configuration.  This will reduce the effect of this exception.\n\n\"When I push the workload so the streams get a backlog I start losing items and they don't get delivered\"\nThe posted exceptions 'should' not be causing data loss.  Can you log any OnErrorAsync calls to your grains?  If the stream infrastructure is having difficulties delivering events, it will attempt to notify the grain of these errors via the OnErrorAsync handler.\n"
      },
      {
        "user": "BenjaminGibbs",
        "created_at": "2015-10-13T17:27:52Z",
        "body": "So after somewhat alot more testing in the last 12 hours, I am not losing message they are being delivery multiple times - my mistake.\n\nI am now sending Random GUID's down 4 different streams with the aim that at the end of each run they state should be the same - And it is; \n\nHowever I am also counting how many times we try to add an item which is already in the state and it fails, ie it is a re submission. - This is not triggering onErrorAsync.\n\nIf I push 10,000 items at once it gets backloged but in the end it all the states match, however the reprocess count is up to 10 times that of the times in the list, each stream has a different reprocess count. \n\nBut if I drop the cache size to a low value like 10 this doesn't happen. It should be noted I an intentionally creating a backlog on the grain at the moment, to see how it would handle a spike in traffic.\n\nA possible explanation could be that the the stream cache could be holding the items longer than the time out which means the AzureQueue is making the items reappear which then get re-added to the Stream Cache so in effect an never ending loop as in items are getting processed multiple times.\n\nI was able to replicate this theory by adding a delay to the processing of the grain that consumes the message, I could push in 100 items in to the streams and when I had the delay it re-processed in excess of 1700 extra messages, on top of the items. - If I repeated I get the same number of excess if I increase the delay it goes up, reduce the delay it goes down.\n\nOn error is not being fired.\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2015-10-13T18:21:56Z",
        "body": "\"This is not triggering onErrorAsync\"\nThat is correct.  It should not.  Azure queues allow multiple delivery, so this is not an error.  If you see data loss, you should see OnErrorAsync calls.\n\n\"the AzureQueue is making the items reappear\"\nThis can happen.  When using azure queue's it's important to keep event processing time lower than azure queues re-add time.\n\nSetting the GetQueueMessagesTimerPeriod as mentioned before should help some with this, but in general, you'll need to perform some load tests and capacity planning to ensure that you've enough processing power for your load.\nTuning queue count and cache size can also help.\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2015-10-13T18:38:24Z",
        "body": "Depending on how much effort you want to put into this, a custom queue cache could be developed, based off of SimpleQueueCache, which tracks how long messages have been in the cache and adjusts back pressure with this info.  Basically, if the time in the cache starts to approach the (configured) redelivery time, the cache could trigger the reader to back off, thereby reducing load.\n\nThis is more work of course, but it would be a more robust solution for azure queues with unbounded load.\n"
      },
      {
        "user": "BenjaminGibbs",
        "created_at": "2015-10-13T19:06:21Z",
        "body": "Thanks Jason for clarification.\n\nI am pleased the original Issue I posted is fixed, I think extending the SimpleQueueCache would be a useful thing to do to in long run so I will look at doing that, currently I can control this with cache size and timer period.\n"
      },
      {
        "user": "veikkoeeva",
        "created_at": "2015-10-13T19:16:32Z",
        "body": "@BenjaminGibbs, @jason-bragg A very enlightening exchange of thoughts and conclusion. :+1: \n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2015-10-13T19:43:25Z",
        "body": "@BenjaminGibbs The SimpleQueueCache, as its name probably indicates, is a general all-purpose queue cache.  It is not queue specific.  If you do decide to make a custom adapter cache that is more tuned to azure queues, I could see that being useful to others in the community.  I fully expect that you're primary focus will be to build out the tech you need, but If you find the time, I'd be interested in seeing a issue opened regarding contributing your azure queue adapter cache to Orleans to be maintained as an alternative implementation of IQueueCache.\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2015-10-13T21:57:50Z",
        "body": "@BenjaminGibbs A question in issue \"Talk about the stream (Feedback on the stream and QueueCacheMissException) #850\" reminded me of a cache behavior that may explain why you see more redeliveries with larger cache sizes. \n\nEvents are removed from the queue (via the MessagesDeliveredAsync call) once they are purged from the cache.  In general they are purged from the cache when all consumers have delivered the event, however the SimpleQueueCache purges events in bulk, not on an individual event by event basis.  It has buckets of events and does not purge a bucket until all of the events in the bucket have been delivered.  If the cache size is increased the bucket size will be increased, increasing the number of events that must be delivered before all events in the bucket can be released.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-10-15T09:44:42Z",
        "body": "We can also allow to configure the number of buckets.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-10-19T11:22:18Z",
        "body": "Can we please rename this issue to better represent what it is about: Something along the lines of: receiving events from azure queue stream provider multiple times.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-10-23T10:42:58Z",
        "body": "@benjamingibbs, did you manage to solve it, by playing with cache size and number of buckets?\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-11-16T17:26:03Z",
        "body": "@BenjaminGibbs Feel free to reopen if you are still experiencing this issue.\n"
      }
    ]
  },
  {
    "number": 854,
    "title": "Question - What happen when a stream producer fails?",
    "created_at": "2015-09-29T02:33:23Z",
    "closed_at": "2015-09-30T19:42:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/854",
    "body": "Question\n\nI have a scenario where a need to return a lot of results ~10,000 and fetching them could be long. Long enough to exceed the request timeout. I was thinking on leveraging the Orleans Streams to achieve this and avoid time outs. Delegating the load to another grain which I will not wait on, and that will stream back the results.\n\nIf I'm in a at-least-one delivery scenario.\nWhat happen if the producer of the stream results fails? Will the producer be reactivated? and will it re-execute the `LoadRawData` or will the message be lost forever and I will receive no more results in my `MyGrain`?\n\nAlso, if you have any better solution so handle this kind of scenario, I'm open to suggestions :D\n\nthis is a simple example of what it could look like\n\n```\npublic class MyGrain : IGrain\n{\n    public Task LoadStuff()\n    {\n        var pg = GrainFactory.GetGrain<ProducerGrain>(\"foo\");\n\n        // Subscribe on stream X (streamHandleX)\n        // ...\n\n        // Don't wait on the return as this is a long running operation that will result in a time out\n        pg.LoadRawData();\n    }\n\n    public Task OnNext(object item)\n    {\n        // Save result in state\n    }\n\n    public Task OnCompleted()\n    {\n        // Set load as completed\n    }\n}\n\npublic class ProducerGrain : IGrain\n{\n    public async Task LoadRawData()\n    {\n        // This is a potentially long operation\n        // ...\n        // Get stream handle and stream each result as they come in\n        foreach(var result in results)\n        {\n            await streamHandleX.OnNext(result);\n        }\n\n        await streamHandleX.OnCompleted();\n    }\n}\n\n```\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/854/comments",
    "author": "mbernard",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-09-29T22:44:48Z",
        "body": "If a `ProducerGrain` fails in the middle, it will not be recreated by itself. You need someone to send it a new message to reactivate it. The options are:\n\n1) Make `MyGrain` watch the production process and keep periodically pocking the producer. So for example,  `MyGrain` will create a timer (not a reminder) that will periodically check when was the last OnNext called and it looks like  producer was idle for some time, just pick it, also telling him - hei, I got X chunks (this part of the data), where is the rest? The not failed producer will ignore, while the failed producer will be reactivated and can restart from the latest point. \n\n2) Use reminder. `ProducerGrain` will subscribe to a reminder that will tick periodically. Once all data was produced, it can unregister the reminder. In that solution, producer will need to remember by itself how much it already produced, so it does not start from the beginning (unless you don't care to resend all). He will need to store this reliably in storage. \n\nIf the `ProducerGrain`  is non reentrant (default), you will actually not get neither consumer pocks nor reminder ticks until `LoadRawData` is done. Which is fine, just need to be aware. And after you are done, just ignore them.\n"
      },
      {
        "user": "mbernard",
        "created_at": "2015-09-30T19:42:29Z",
        "body": "Thank you, very usefull information.\nI was thinking about writer a \"watcher\" anyway, good to know that I'm in the right direction\n"
      }
    ]
  },
  {
    "number": 767,
    "title": "Bootstrap providers not called while running tests inherited from TestingSiloHost",
    "created_at": "2015-09-08T17:31:18Z",
    "closed_at": "2015-09-08T18:40:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/767",
    "body": "I have a test class inherired from **TestingSiloHost**\nAnd I have configured BootStrap provider in **OrleansConfigurationForTesting.xml** as below\n\n```\n <Globals>\n<StorageProviders>\n  <Provider Type=\"Orleans.Storage.AzureTableStorage\" Name=\"AzureStore\" DataConnectionString=\"UseDevelopmentStorage=true\" />\n</StorageProviders>\n<SeedNode Address=\"localhost\" Port=\"22222\"/>\n<BootstrapProviders>\n  <Provider Type=\"DependencyInjectionWrapper.DependencyRegistration\"\n           Name=\"dependencyinjection\"\n           InstanceCount=\"1\"/>\n</BootstrapProviders>\n<Messaging ResponseTimeout=\"30s\"/>\n```\n\n  </Globals>\n\nBut DependencyRegistration class is not called when running the tests. Is Bootstrap supported for test cases as well?\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/767/comments",
    "author": "ponsakthi",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-09-08T17:46:09Z",
        "body": "you also need to make sure the dll with that provider is copied to test dir. Add `[DeploymentItem(\"My.dll\")]` to the test class. Is it still does not work, please share your full silo log, at Info tracing level.\n"
      },
      {
        "user": "ponsakthi",
        "created_at": "2015-09-08T18:40:32Z",
        "body": "With help of @gabikliot , I was able to figure out the issue\n\nThe issue is that , the “OrleansConfigurationForTesting.xml” file was not directly under the test project. I had moved it under a subfolder “config”. Hence when the test project was built the intended config file was not copied to output folder. Instead, it referred an old config file in output folder which did not have “BootStrapProvider” tags.\n\nThanks a lot @gabikliot \n"
      }
    ]
  },
  {
    "number": 741,
    "title": "Accessing GrainFactory from IBootstrapProvider in 1.0.9.",
    "created_at": "2015-08-26T21:17:31Z",
    "closed_at": "2015-08-27T13:38:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/741",
    "body": "I have been working through the process of upgrading to orleans 1.0.9 from 1.0.8.  We have some code that implements IBootstrapProvider, which is used to load some starting data into the system at startup.  \nBefore: \n`var cropGrain = GrainFactory.GetGrain<ICrop>(crop.CropId);`\n\nAfter:\n`var cropGrain = GrainClient.GrainFactory.GetGrain<ICrop>(crop.CropId);`\n\nThis was working fine in 1.0.8.  Now, the calls to get grain references from the GrainFactory are failing due to the GrainClient not being initialized.  Since this code is running on the Silo, I wouldn't expect to need to configure a client.  Attempts to do so have failed.\n\nAre there any examples of how to properly interact with grains in the bootstrap providers, which are set up to be deployed on Azure?  \n\nThanks\nPhil\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/741/comments",
    "author": "philreindl",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-08-26T21:24:37Z",
        "body": "The `GrainFactory` is available via a member field in `IProviderRuntime` that is passed to `IBootstrapProvider.Init()`.\n"
      },
      {
        "user": "philreindl",
        "created_at": "2015-08-27T13:38:38Z",
        "body": "So it is.  Thanks for getting me straightened out!\n"
      }
    ]
  },
  {
    "number": 713,
    "title": "How to Extend State",
    "created_at": "2015-08-18T20:44:41Z",
    "closed_at": "2015-08-24T05:42:00Z",
    "labels": [
      "enhancement",
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/713",
    "body": "This is probably a common question, but could not find any similar entry.\nToday I had to delete the State table, after adding properties to the grain state.\n\nIt is clear that the serializer needs a strong data contract, but either I did something wrong or there is no path for evolution.\n\nSuggestions, Questions:\n1) Don't support reorder, change of types or delete fields, but support appending new fields without breaking. As an example, BLE protocol uses a memory serializer that supports flexible, extensible fields. (If this is interesting I am happy to explore implementation)\n2) Be tolerant for corrupted state, the silo crashed or stop responding after grains broke the state signature. What I saw was the following message from the client:\nOrleans.Runtime.OrleansException: Could not find any gateway in Orleans.AzureUtils.AzureGatewayListProvider. Orleans client cannot initialize.\nNote: After deleting the state table and recycle roles, everything started to work, but I lost state\n3) Suggest best practices approach for versioning the state and support evolution\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/713/comments",
    "author": "ukluk",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-08-18T22:28:01Z",
        "body": "@ukluk , in general you are correct: the persistent state evolution story in Orleans is currently not very advanced.\n\nBut lets look specifically into it:\n1) If we are talking about **application grain state** that this actually **is** supported, indirectly, via storage providers. One can write any storage provider and inside it deal with state schema evolution. The AzoreTable storage provider that we include by default in Orleans is not doing that, but this is merely since it is more like a sample. It is not the most advanced or feature rich storage provider. You can write your own, that will support thing like you mentioned: delete fields,  appending field, what ever. You can be tolerant to corrupted applications state there, in any way you want to.\n\n2) **Runtime state**: we definitely need to be very careful about changing runtime state behavior and make it version tolerant. In general I think we are pretty OK on that, but could be better. Our internal runtime state changes very infrequently. For example, the membership format did not change for a while, so is reminders. And when we do change it, we try to make it backward compat.\n\nAs for the exception of \"Orleans.AzureUtils.AzureGatewayListProvider. Orleans client cannot initialize.\", I a not sure it was necessary related to storage format change. Unless the old version was 0.9, prio to 1.0, which was released in January. \n"
      }
    ]
  },
  {
    "number": 699,
    "title": "Usage of C# 6.0 features breaks code generation",
    "created_at": "2015-08-15T20:40:05Z",
    "closed_at": "2015-08-15T23:29:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/699",
    "body": "What is the status of being able to use C#6 features?\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/699/comments",
    "author": "ellern",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2015-08-15T23:26:27Z",
        "body": "When #528 merges, the new language features will be available.\n"
      },
      {
        "user": "ellern",
        "created_at": "2015-08-15T23:29:53Z",
        "body": "Great, then this can be closed.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-08-15T23:40:50Z",
        "body": "Searching for the like button on @ReubenBond's comment. \n:+1: \n"
      }
    ]
  },
  {
    "number": 692,
    "title": "Grain faulted state",
    "created_at": "2015-08-12T15:55:13Z",
    "closed_at": "2015-08-12T20:32:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/692",
    "body": "Trying to figure out what is the approach for the following scenario.\n\nThere is operation (async method) in grain which updates the state and the state persisted at the end. In case there is failure during state change (logical Exception) or while writing to storage, I want to \"rollback\". By \"rollback\" I mean:\n- Either re-read the state from storage and throw exception, so the caller will be aware that operation failed\n- Or kill (deactivate?) the grain\n\nIn first case there also possibility that the re-read state will also fail, which takes me to second approach. \n\nWhat is the best practice to handle faulted state of actors in Orleans?\n\nThanks.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/692/comments",
    "author": "jenyayel",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-08-12T18:01:57Z",
        "body": "Both are valid approaches. You can force activation to deactivate by calling `DeactovateOnIdle`. On the other hand, the 1st approach allows you a more fined grained and application specific error recovery.\nWe deliberately did not want to constrain the system to only do 1 or 2, and allow the app to pick its own.\n\nWe do have an open work item to treat eTag mismatch exceptions from the storage automatically. We will use strategy 2 - if the grain got eTag mismatch exception upon write, we plan to automatically deactivate this activation. The reason is that eTag mismatch exception basically means we got 2 activations of that grain, which is an error condition, and one of the activations should be deactivated anyway. But for other errors we leave it to the app code to handle.\n"
      },
      {
        "user": "jenyayel",
        "created_at": "2015-08-12T20:32:32Z",
        "body": "I understand. For me, instead of figuring out how to rollback in each specific case, the simpler approach is just to deactivate the grain. Thanks for clarifying. \n"
      }
    ]
  },
  {
    "number": 662,
    "title": "grain call from grain: \"You must initialize the Grain Client before accessing the GrainFactory\"",
    "created_at": "2015-07-29T10:06:41Z",
    "closed_at": "2015-07-29T17:02:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/662",
    "body": "Hi,\n\nSince I updated to 1.09 I have a problem with a grainfunction that calls another grain. The call throws an exception \"You must initialize the Grain Client before accessing the GrainFactory\".\n\nThe problem only occurs if I get the grain with \"GrainClient.GrainFactory.GetGrain<IMyGrain>(grainid)\". If I use the autogenerated (deprecated) grainfactory everything works as before. \n\nIn GrainClient.cs from the orleanscode I see the comment \"//TODO: prevent client code from using this from inside a Grain\". Does that mean, that you should not (or cannot) use a grain from another grain?\n\nThanks for any hints.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/662/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2015-07-29T16:04:14Z",
        "body": "From within a grain it's `this.GrainFactory.GetGrain(grainid)`. `GrainClient` is to be used only from outside of a silo.\n"
      },
      {
        "user": "ghost",
        "created_at": "2015-07-29T16:43:34Z",
        "body": "oh, i see.  thanks!\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-07-29T17:49:32Z",
        "body": "I added a more explicit and more helpful exception here: #663.\n"
      }
    ]
  },
  {
    "number": 580,
    "title": "AzureSilo.Start() - missing info on why it did not start",
    "created_at": "2015-07-03T11:14:40Z",
    "closed_at": "2015-07-27T07:32:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/580",
    "body": "Is there a way find out why AzureSilo.Start() does not start?\nA call takes approx 5 mins before it returns false.\nUsing defaults:\n   MaxRetries: 120\n   StartUpRetryPause: 00:00:05\nThere is no indication on what could be the issue.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/580/comments",
    "author": "RaleS",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-07-03T15:39:26Z",
        "body": "Do you have the silo logs? If yes, please share them. If not, can you try deploying to local emulator and share the console output.\nUsually, the problem is either misconfiguration or wrong version of deployed dependency dlls.\n"
      },
      {
        "user": "RaleS",
        "created_at": "2015-07-05T11:41:08Z",
        "body": "It is an upgrade of multi-instance Azure cloud service running Orleans 0.9 to cloud service that runs Orleans 1.0. Is this scenario supported?\n\nExcerpt from the log file:\n\n[2015-07-05 11:15:08.644 GMT    20    WARNING    101215    Scheduler.MembershipOracle.WorkItemGroup    xx.xx.xx.xx:11111]    Task [Id=1, Status=RanToCompletion] in WorkGroup [SystemTarget: Sxx.xx.xx.xx:11111:173790896MembershipOracle@S0000000f] took elapsed time 0:00:00.8223173 for execution, which is longer than 00:00:00.2000000. Running on thread <Runtime.Scheduler.WorkerPoolThread/1, ManagedThreadId=20, Executing Task Id=1 Status=RanToCompletion for 00:00:00.8125143>  \n[2015-07-05 11:15:08.769 GMT    22    ERROR      100860    AzureSiloMembershipTable    xx.xx.xx.xx:11111]    !!!!!!!!!! Intermediate error parsing SiloInstanceTableEntry to MembershipTableData: [OrleansSilo [ Deployment=cc64d29220804abf869cae20fa6acd75 LocalEndpoint=xx.xx.xx.31 LocalPort=11111 Generation=173688340 Host=RDxxACB Status=Active ProxyPort=30000 RoleName=CloudRealtimeHost Instance=CloudRealtimeHost_IN_1 UpgradeZone=1 FaultZone=1 StartTime=2015-07-04 06:45:40.363 GMT IAmAliveTime=2015-07-05 11:11:07.400 GMT], OrleansSilo [ Deployment=eb64d29220804abf869cae20fa6acd75 LocalEndpoint=xx.xx.xx.xx LocalPort=11111 Generation=173688294 Host=RDxx086 Status=Dead ProxyPort=30000 RoleName=CloudRealtimeHost Instance=CloudRealtimeHost_IN_0 UpgradeZone=0 FaultZone=0 SuspectingSilos=xx.xx.xx.xx:11111@173688294 SuspectingTimes=2015-07-05 11:14:28.044 GMT StartTime=2015-07-04 06:44:54.408 GMT IAmAliveTime=2015-07-05 11:14:28.044 GMT], OrleansSilo [ Deployment=eb64d29220804abf869cae20fa6acd75 LocalEndpoint=xx.xx.xx.xx LocalPort=11111 Generation=173790896 Host=RDxx086 Status=Created ProxyPort=30000 RoleName=CloudRealtimeHost Instance=CloudRealtimeHost_IN_0 UpgradeZone=0 FaultZone=0 StartTime=2015-07-05 11:14:56.372 GMT IAmAliveTime=], VersionRow [eb64d29220804abf869cae20fa6acd75 Deployment=eb64d29220804abf869cae20fa6acd75 MembershipVersion=]].  \nExc level 0: System.ArgumentNullException: Value cannot be null. \nParameter name: String \n   at System.Number.StringToNumber(String str, NumberStyles options, NumberBuffer& number, NumberFormatInfo info, Boolean parseDecimal) \n   at System.Number.ParseInt32(String s, NumberStyles style, NumberFormatInfo info) \n   at Orleans.Runtime.MembershipService.AzureBasedMembershipTable.Convert(List`1 entries) \n[2015-07-05 11:15:08.769 GMT    22    WARNING    100821    AzureSiloMembershipTable    xx.xx.xx.xx:11111]    Intermediate error reading all silo entries OrleansSiloInstances.     \nExc level 0: System.ArgumentNullException: Value cannot be null. \nParameter name: String \n   at System.Number.StringToNumber(String str, NumberStyles options, NumberBuffer& number, NumberFormatInfo info, Boolean parseDecimal) \n   at System.Number.ParseInt32(String s, NumberStyles style, NumberFormatInfo info) \n   at Orleans.Runtime.MembershipService.AzureBasedMembershipTable.Convert(List`1 entries) \n   at Orleans.Runtime.MembershipService.AzureBasedMembershipTable.<ReadAll>d__c.MoveNext() \n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-07-05T13:21:39Z",
        "body": "Could you please try completely deleting the whole Orleans silo instance table and try again.\n"
      },
      {
        "user": "RaleS",
        "created_at": "2015-07-06T14:19:39Z",
        "body": "Deleted content of OrleansSiloInstances table but it looks like a row (for each instance) is created/updated every 5 mins (depending instance start time). So while updating I had to monitor and zap any new rows that were created.\n\nFirst instance started upgrading and Orleans 1.0 silo could be initialized.\n\nThe instance running Orleans 0.9 began throwing following error:\n\nSystem.AggregateException: One or more errors occurred. ---> System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request _cli/d5b197bc@10766493->Sx.x.x.76:30000:173885527_grn/DDE6E6E2/ac2e0607 #120: BK.EMS.OutputProcessingInterfaces.BK.EMS.OutputProcessingInterfaces.IOutputProcessing:Process(). Target History is: Sx.x.x.76:30000:173885527:*grn/DDE6E6E2/ac2e0607: \n   --- End of inner exception stack trace --- \n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) \n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) \n   at Orleans.Runtime.GrainReference.<InvokeMethodAsync>d__0`1.MoveNext() \n--- End of stack trace from previous location where exception was thrown --- \n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) \n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) \n   at BK.EMS.CloudRealtime.Service.OutputPublisher.<ConsumeItemAsync>d__9.MoveNext() in e:\\bld\\13\\ENM\\NS-R6.6.3\\Sources\\src\\prod\\CloudRealtime\\Service\\OutputPublisher.cs:line 194 \n---> (Inner Exception #0) System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request _cli/d5b197bc@10766493->Sx.x.x.76:30000:173885527_grn/DDE6E6E2/ac2e0607 #120: BK.EMS.OutputProcessingInterfaces.BK.EMS.OutputProcessingInterfaces.IOutputProcessing:Process(). Target History is: Sx.x.x.76:30000:173885527:*grn/DDE6E6E2/ac2e0607:<--- \n\n10 minutes into initialization of the instance running Orleans 1.0 following client error has been logged:\n\n[2015-07-06 13:56:12.614 GMT    65    INFO       100801    OrleansSiloInstanceManager    ]    Attached to Azure storage table OrleansSiloInstances  \n[2015-07-06 13:56:12.645 GMT    67    INFO       100836    OrleansSiloInstanceManager    ]    Initialized schema for Azure storage table OrleansSiloInstances  \n[2015-07-06 13:56:12.645 GMT     9    INFO       100277    OrleansSiloInstanceManager    ]    Searching for active gateway silos for deployment a1b23f283ac245378566a1f52b150729 ...  \n[2015-07-06 13:56:12.661 GMT     9    INFO       100278    OrleansSiloInstanceManager    ]    Found 0 active Gateway Silos.  \n[2015-07-06 13:56:12.661 GMT     9    ERROR      101313    Messaging.GatewayManager    ]    !!!!!!!!!! Could not find any gateway in Orleans.AzureUtils.AzureGatewayListProvider. Orleans client cannot initialize.  \n[2015-07-06 13:56:12.661 GMT     9    ERROR      100319    OutsideRuntimeClient    ]    !!!!!!!!!! OutsideRuntimeClient constructor failed.  \nExc level 0: Orleans.Runtime.OrleansException: Could not find any gateway in Orleans.AzureUtils.AzureGatewayListProvider. Orleans client cannot initialize. \n   at Orleans.Messaging.GatewayManager..ctor(ClientConfiguration cfg, IGatewayListProvider gatewayListProvider) \n   at Orleans.Messaging.ProxiedMessageCenter..ctor(ClientConfiguration config, IPAddress localAddress, Int32 gen, GrainId clientId, IGatewayListProvider gatewayListProvider) \n   at Orleans.OutsideRuntimeClient..ctor(ClientConfiguration cfg, Boolean secondary) \n\nThe instance with Orleans 1.0 kept recycling\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-07-06T17:34:59Z",
        "body": "I'm afraid an in-place upgrade from 0.9 won't work. You likely need to shut the existing service down, delete the table, and deploy start the new version.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-07-06T17:37:22Z",
        "body": "I agree with Sergey. I afraid there were some bugs in 0.9 that were fixed a long time ago (0.9 is really old!) that were not backward compatible with 1.0.X.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-07-24T22:18:41Z",
        "body": "@RaleS,  were you able to resolve this? Can we close this issue or do you need more help with it?\n"
      },
      {
        "user": "RaleS",
        "created_at": "2015-07-27T07:32:32Z",
        "body": "I've found a workaround.\nWill this scenario be supported in future releases?\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-07-27T17:05:35Z",
        "body": "Yes, we are usually trying (hard) to maintain backward compatibility, but sometimes we have to break it. From 0.9 to 1.0 was definitely a big move and it wasn't backward compat. See #646.\n"
      }
    ]
  },
  {
    "number": 530,
    "title": "A number of small ZK MBR table cleanup fixes.",
    "created_at": "2015-06-17T21:45:47Z",
    "closed_at": "2015-06-22T21:09:08Z",
    "labels": [
      "enhancement",
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/pull/530",
    "body": "Only set maxStaleness for GatewayListProvider.\nNo need in log4Net.\nUse CultureInfo.InvariantCulture when converting ZK rowVersion to string eTag.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/530/comments",
    "author": "gabikliot",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-06-17T21:57:30Z",
        "body": "@shayhatsor , these are small cleanup fixes. Nothing major, nothing was wrong. Just tidying up.\n\nI did have a number of questions to you about the implementation:\n1) In `InitializeMembershipTable` it seems like you are creating an empty node for Table Version. How do you make sure the first version is zero? Would it just be zero since default empty `int` value is zero?\n2) You seem to handle etags for  table version and regular row differently. \nFor regular row you use `(await rowDataTask).Stat.getVersion();`.\nWho sets/changes this value upon every write?\nFor table version are you doing the same?\n3) For table version `expectedTableVersion` is the table version - 1. This works correctly now I think, but that was not the intent. You should be checking the table version row **etag**, not the table version **value** itself. You are relying now on the way MBR protocol increments those, but I would prefer you did not take this dependency.\n3) Could you please add some high level description in the code about the data organization inside ZK: what kinds of node you have, how the MBR data is mapped to ZK nodes/data.\n4) I did not understand how you map `IAmAlive`. `.setData(rowIAmAlivePath, newRowIAmAliveData, -1));` Is it a separate additional node? Does it have to be?\n\nThanks!\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-06-19T18:47:32Z",
        "body": "Put back the log4net.\n"
      },
      {
        "user": "shayhatsor",
        "created_at": "2015-06-20T20:37:20Z",
        "body": "@gabikliot look at #545 \n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-06-22T21:09:08Z",
        "body": "Closing since @shayhatsor implemented all those and more in #545.\n"
      }
    ]
  },
  {
    "number": 525,
    "title": "Connection Silos from Multiple Cloud services",
    "created_at": "2015-06-16T18:14:48Z",
    "closed_at": "2015-07-14T16:26:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/525",
    "body": "We currently have our Orleans Silo and Client running within the same cloud service so we are just using the basic Azure Configuration using the AzureSilo and AzureClient. Everything is working very well.\n\nWe now want to start up another version of that cloud service and we want the silos from both the be in the same \"Silo Cluster\". Is it possible to continue using Azure Silo and AzureClient(They will both be using the same AzureTable storage) or do I have to instead use SiloHost and GrainClient to implement the the silo so that we can set the Deployment Id??\n\nThanks in advance!\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/525/comments",
    "author": "clintonsweetnam",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2015-06-16T19:41:26Z",
        "body": "Yes, this should be possible, so long as you have direct TCP connectivity between the two services, e.g. via a vNet.\n"
      },
      {
        "user": "clintonsweetnam",
        "created_at": "2015-06-17T09:16:38Z",
        "body": "Thanks for the quick response.\n\nAnd if they were not able to share AzureTable storage. Would that require a switch to a SiloHost and a GrainClient?\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-06-17T14:15:51Z",
        "body": "Why would they not share Azure Table storage? They have to use the same cluster membership table.\n"
      },
      {
        "user": "clintonsweetnam",
        "created_at": "2015-06-17T14:36:56Z",
        "body": "Hi Sergey,\n\nI guess the issue we are predicting is that even though both cloud services will be sharing the same Azure Storage Table, they will have different deployment Id's. Even if these deployment Id's don't match will it still allow the Silos on both Cloud Services to act as a Silo Cluster. In essence will deployments with different DeploymentId's share the same customer membership table?\n\nJust a a reference we are using hte standard azure configurations for both our Silo's and Clients as detailed in the samples.\n\nThanks,\n\nClinton\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-06-17T14:44:03Z",
        "body": "Deployment ID is the primary key in the membership table. So both deployments have to use the same deployment ID, in this case different from Azure Hosted Service deployment ID. So you'll need to use SiloHost and GrainClient directly, instead of the AzureSilo and AzureClient wrapper classes.\n"
      },
      {
        "user": "clintonsweetnam",
        "created_at": "2015-06-18T08:15:46Z",
        "body": "Hi Sergey,\n\nOk we will look at changing our implementation. Thanks very much for your help!\n\nClinton\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-07-13T23:53:13Z",
        "body": "Hi @clintonsweetnam . Do you still have open questions on this issue? Can it be closed?\n"
      },
      {
        "user": "clintonsweetnam",
        "created_at": "2015-07-14T08:30:43Z",
        "body": "Hey Gabriel\n\nWe implemented it by using the SiloHost and GrainClient directly with a self-generated deployment Id and using AzureTable as a backing store.\n\nAppears to be be working very well!\n\nThanks for you help guys!\n\nClinton\n"
      }
    ]
  },
  {
    "number": 524,
    "title": "Orleans azure deployment ",
    "created_at": "2015-06-16T15:11:21Z",
    "closed_at": "2015-07-14T09:07:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/524",
    "body": "Hi, \nI have an Orleans application with silos planned to be deployed as azure worker roles and an existing client application hosted as azure web roles. If I want silos and client to live in separate deployments, I need to specify the deployment ID of silos during AzureClient initialization when web roles started. So when a new silo version is deployed I need to roll all my clients roles with the new deployment ID. Is it right or is there a better practice for aligning the clients when silos deployment changed?\nThanks.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/524/comments",
    "author": "2mike2",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2015-06-16T15:30:20Z",
        "body": "You don't necessarily have to use Azure's Hosted Service deployment ID (that's what AzureSilo class does). Instead you can instantiate SiloHost class directly, and pass it your own deployment ID that's independent from Hosted Service deployment. Similarly on the client side, instead of using AzureClient with its logic of using Hosted Service deployment ID, you can use GrainClient directly pass your own deployment ID.\n\nOne other thing to ensure is direct network connectivity between these client and silo deployments. You may need to use an Azure Virtual Network for that.\n"
      },
      {
        "user": "2mike2",
        "created_at": "2015-06-16T16:47:22Z",
        "body": "Thank you for getting back. \n1. By connectivity issue you mean that client deployment wont have access to the silo endpoints (the TCP ports) unless it is in the same deployment as silo or in the same virtual network as you've suggested?\n2. If I use SiloHost class directly in azure worker and use the appropriate initialize / start / stop interfaces, are there any other nuances I should be aware of when SiloHost is used in worker role as opposed to AzureSilo?\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-06-16T17:05:24Z",
        "body": "1. Yes. My understanding is two hosted services cannot talk to each other's internal endpoints unless connected with a vNet.\n2. The other thing that's a bit complicated with Azure is finding location of the config file, especially client config in web role. But that code is in ClientConfiguration.StandardLoad() that is used by GrainClient underneath.\n"
      },
      {
        "user": "2mike2",
        "created_at": "2015-06-16T17:16:38Z",
        "body": "Ok,Thank you.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-06-16T17:20:49Z",
        "body": "No problem.\n"
      },
      {
        "user": "2mike2",
        "created_at": "2015-06-16T18:46:34Z",
        "body": "On the worker side, I see that AzureSilo class has a couple of start overloads that accepts deploymentId:\npublic bool Start(string deploymentId, RoleInstance myRoleInstance, ClusterConfiguration config)\nso can I use it for providing custom deploymentId instead of using SiloHost? \n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-06-16T19:37:40Z",
        "body": "These overloads have been recently refactored/removed (post 1.0.8).\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-07-13T23:52:33Z",
        "body": "Hi @2mike2 . Do you still have open questions on this issue? Can it be closed?\n"
      },
      {
        "user": "2mike2",
        "created_at": "2015-07-14T09:07:54Z",
        "body": "Yes. thank you.\n"
      }
    ]
  },
  {
    "number": 494,
    "title": "Tutorial code doesn't compile(?)",
    "created_at": "2015-06-08T18:56:54Z",
    "closed_at": "2015-06-11T16:44:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/494",
    "body": "Following the tutorial and get stuck at this point:\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Text;\nusing Orleans;\n\nnamespace OrleansTutorial1\n{\n    /// <summary>\n\n\n    /// Orleans grain implementation class PlayerGrain\n    /// </summary>\n\n\n    public class PlayerGrain : Orleans.Grain, IPlayerGrain\n    {\n        private IGameGrain currentGame;\n\n```\n    // Game the player is currently in. May be null. \n    public Task<IGameGrain> GetCurrentGameAsync()\n    {\n        return TaskDone<IGameGrain>.Finished(currentGame);\n    } \n}\n```\n\n}\n\nThe return statement gives: 'The non-generic type Orleans.TaskDone cannot be used with type arguments.\"  I created the project from the suggested template.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/494/comments",
    "author": "misterspeedy",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2015-06-08T19:05:54Z",
        "body": "Fixed - should be `return Task.FromResult(currentGame);`.\n"
      }
    ]
  },
  {
    "number": 351,
    "title": "Good fit or not? Imaging documents",
    "created_at": "2015-04-21T02:56:41Z",
    "closed_at": "2015-04-23T20:04:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/351",
    "body": "Let's say I have a billion word documents and I need to image them (create images out of every page).\nIdeally I would use something that can expand to 100 of servers, process documents and then reduce to few servers and continue working on smaller jobs until another billion word documents come in.\n\nI was thinking that each grain can be responsible for processing a document or a page of a document using third-party imaging api? \n\nIs orleans a good fit for above?\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/351/comments",
    "author": "mishakogan",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2015-04-21T14:42:21Z",
        "body": "In my opinion this is a borderline app. It is doable with Orleans but it appears to be more of batch processing in nature, at least from my interpretation of your description. Orleans is better suited for interactive workloads, e.g. if you had to image these documents and return results to the callers within milliseconds/seconds. It can be used to distribute and orchestrate a parallelizable batch job like this one, but there are more options for parallel batch job execution out there.\n"
      }
    ]
  },
  {
    "number": 350,
    "title": "Grain implementing more than one IGrain-derived interface?",
    "created_at": "2015-04-20T15:55:44Z",
    "closed_at": "2015-04-20T18:54:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/350",
    "body": "Hi.\n\nI'd like to \"partition\" Grains public interface according to access from different front-ends.\n\nIs possible and/or convenient implementing different IGrain-derived interfaces on same Grain?\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/350/comments",
    "author": "maiorfi",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2015-04-20T16:50:23Z",
        "body": "Yes, it's totally possible and easy for a grain to implement more than one grain interface.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-04-20T18:32:42Z",
        "body": "@maiorfi , it is currently supported and works.\n"
      },
      {
        "user": "maiorfi",
        "created_at": "2015-04-20T18:54:42Z",
        "body": "Great news, thanks!\n"
      }
    ]
  },
  {
    "number": 321,
    "title": "Receiving events (from a non Orleans-Scheduled thread/task) in grains",
    "created_at": "2015-04-13T13:02:15Z",
    "closed_at": "2015-04-13T16:22:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/321",
    "body": "Hi.\n\nI'm working on a sample where a grain contains a reference to (well, kind of) a TCP client.\nOnce TCP client is connected to a listener, it can receive unsolicited data by mean of a .NET event.\nIn my grain code, I subscribe to such event using a private grain method as an handler.\n\nWhile locking members shared between grain methods and event handler seems enough to protect concurrent access, it seems that grain can't update its State (yes, with capital case since my grain is a stateful one, using Orleans state persistence infrastructure) within handler.\n\nIs it due to accessing State from outside Orleans-managed task scheduler?\n\nShould it be the reason, how could I \"schedule\" a method/delegate/lambda call (like one usually does managing UI affinity issues, like Dispatcher.Invoke in WPF or Control.Invoke in WindowsForms) in such a way that it can update grain state?\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/321/comments",
    "author": "maiorfi",
    "comments": [
      {
        "user": "richorama",
        "created_at": "2015-04-13T13:33:29Z",
        "body": "Hi,\n\nI don't think you should put a TCP client in a grain and leave it open to receive messages, as calls to this lambda won't be scheduled by the Orlean task scheduler.\n\nYou should place this code outside Orleans, and send messages to a grain when messages are received on the socket.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-04-13T15:36:22Z",
        "body": "@maiorfi I agree with @richorama - usually you want to open such connections from outside of Orleans silo. However, if you need to do that from within a grain or for a demo purpose, you can marshal a call to the grain's context by capturing it first, e.g. from within OnActivateAsync(), along with a reference to the grain:\n\n``` csharp\nprivate TaskFactory factory;\nprivate me = this.AsReference<IFoo>();\nfactory = new TaskFactory(TaskScheduler.Current);\n```\n\nYou can then schedule a call via\n\n``` csharp\nfactory.StartNew(async () => await me.Bar());\n```\n\nwhere IFoo is your grain interface and Bar() is a method of it.\n"
      },
      {
        "user": "maiorfi",
        "created_at": "2015-04-13T15:49:06Z",
        "body": "@richorama You're absolutely right: what I'm doing is trying (improperly) to split front-end stuff among grains: is there any suggested pattern for that? Maybe making grains observe a OrleansStream \"filled\" with data coming from an external service?\n\n@sergeybykov Thanks, I'm going to try it just now!\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-04-13T16:00:30Z",
        "body": "@maiorfi One purpose of the streaming extensions is to help decouple ingestion of data from the processing logic. In this pattern, the client receives incoming data (e.g. over TCP connections) and publishes it to streams (e.g. per-user or per-device). Grains do processing by implicitly or explicitly subscribing to the streams. By choosing a stream provider you define desired reliability, latency, and throughput of the event flow.\n"
      }
    ]
  },
  {
    "number": 258,
    "title": "is StatelessWorker single-thread  necessary?",
    "created_at": "2015-03-23T13:56:59Z",
    "closed_at": "2015-03-24T16:40:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/258",
    "body": "StatelessWorker Grain may have many activations. if one client and 10 silo. Message processing is not in order.  \n     Do ,why make  StatelessWorker Grain  single-thread? if not single-thread, will improve throughput.  \n     Imagine why? \n     Do you want to control the maximum request count in one StatelessWorker grain? like the example code TweetDispatcherGrain,  HashtagGrain which is a  common grain  could do this. Doesn't need   TweetDispatcherGrain controls the maximum amount of request.  \n     Please consider giving a new implementation for StatelessWorker Grain. if something wrong ,please correct me.\n\n``` csharp\n[StatelessWorker]\npublic class TransferTransactionProcessManager : Orleans.Grain, ITransferTransactionProcessManager\n { \n        private int counter = 0;\n        async Task ITransferTransactionProcessManager.ProcessTransferTransaction(Guid fromAccountId, Guid toAccountId, decimal amount)\n        {\n            counter += 1;\n            Console.WriteLine(\"<---------------------before delay\" + counter + \"----------------------------------->\");\n            var tcs = new TaskCompletionSource<int>();\n\n            Task.Delay(5 * 1000).ContinueWith((t) =>\n            {\n                Console.WriteLine(\"<---------------------------delay\"+counter+\"----------------------------------->\");\n                tcs.SetResult(1);\n            });\n            await tcs.Task;\n            return;\n         }\n}\n```\n\nconsole \n\n```\n<---------------------before delay1----------------------------------->\n<---------------------------delay1----------------------------------->\n<---------------------before delay2----------------------------------->\n<---------------------------delay2----------------------------------->\n<---------------------before delay3----------------------------------->\n<---------------------------delay3----------------------------------->\n```\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/258/comments",
    "author": "witterlee",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2015-03-23T14:35:18Z",
        "body": "The main reason for the single-threaded execution of grain activations is to prevent concurrency issues and a need for thread synchronization in the grain code. A StatelessWorker grain may have private data structures that in general would have to be protected with locks in case of a multi-threaded execution. So the thought is that having multiple single-threaded activations is safer than a single multi-threaded activation.\n"
      },
      {
        "user": "witterlee",
        "created_at": "2015-03-23T14:52:52Z",
        "body": "If I have two choices  \nA : control concurrency safe by myself,and get better throughput  \nB : control concurrency safe by single-threaded execution of grain.\n\nI perfer A much more than B.\nlike the code I show.\n1start-->wait 5 seconds-->1end -->2start-->wait 5senonds-->2end.\n\nif 100 request/seconds, when sending 6-8 request， subsequent requests will timeout.  but the request queue maybe not long enough to create a new activation for this StatelessWorker grain.\n\nSo,I suggestion implement StatelessWorker grain not single-threaded. \nLike the blow code,I only add a syncLocker protect counter for multi-thread update, but I get better throughput.\n\n``` csharp\n[StatelessWorker]\npublic class TransferTransactionProcessManager : Orleans.Grain, ITransferTransactionProcessManager\n { \n        private int counter = 0;\n        private object syncLocker=new object();\n        async Task ITransferTransactionProcessManager.ProcessTransferTransaction(Guid fromAccountId, Guid toAccountId, decimal amount)\n        {\n            lock(syncLocker) counter += 1;\n            Console.WriteLine(\"<---------------------before delay\" + counter + \"----------------------------------->\");\n            var tcs = new TaskCompletionSource<int>();\n\n            Task.Delay(5 * 1000).ContinueWith((t) =>\n            {\n                Console.WriteLine(\"<---------------------------delay\"+counter+\"----------------------------------->\");\n                tcs.SetResult(1);\n            });\n            await tcs.Task;\n            return;\n         }\n}\n```\n\nanybody agree with me?\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-03-23T15:21:25Z",
        "body": "If a grain becomes such a bottleneck that it makes you consider making it multi-threaded, I would take a harder look at the decomposition of the app logic. The grain model assumes that grains are small enough pieces of state and logic that none of them individually requires a lot of resources. Such an approach has its limits, of course, but in our opinion it helps scalability a great deal.\n\nLeveraging thread synchronization mechanisms from within grain code can easily reduce throughput or block execution altogether by preventing other grains from running. If you believe you have a need for such a multi-threaded high throughput component, I would suggest to consider putting it outside Orleans.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-03-23T16:13:50Z",
        "body": "You have lots of alternatives: \n1) use a set of StatelessWorker grains and round robin between them (different grain ids). \n2) use Thread Pool for concurrency (Task.Run) within the StatelessWorker activation and manage concurrency yourself.\n3) Consider re-design, as Sergey suggested.\n\nActors are single threaded, by definition. I doubt we will consider changing such a fundamental programming model guarantee.\n"
      },
      {
        "user": "alan-geller",
        "created_at": "2015-03-23T22:14:11Z",
        "body": "A subtle reason for keeping actors single-threaded is that it lets the Orleans scheduler make some simplifying assumptions about processor usage that allow it to run very efficiently in most situations. By default, Orleans allocates a worker thread per logical core, and runs a single actor per worker thread. There’s no preemption; it’s cooperative multiprocessing.\n\nBecause the number of threads matches the number of logical cores, in general the threads don’t block and there are no thread context switches. This isn’t quite true because of threads used for messaging and other IO, but the number of thread switches per minute on Orleans is much, much lower than is common on more highly multi-threaded platforms. In particular, the number of context switches per minute doesn’t go up when system load increases.\n\nAll of this lets Orleans run smoothly at over 90% CPU usage, where (in my experience) typical rule of thumb is to limit servers to no more than 80% usage because otherwise context switch (and other kernel) overhead will bring things to a screeching halt…\n\nDoing a bunch of multithreaded computation within a grain will break this assumption and likely make the silo as a whole perform worse. If you split the computation out of the grain and run it in a logically separate compartment that you make asynch requests to, as if it were an IO service, then you can play with the Orleans config to tell the Orleans scheduler to use fewer worker threads; this will let the silo run smoothly on one set of cores while the computation runs using its own separate set.\n"
      },
      {
        "user": "witterlee",
        "created_at": "2015-03-24T05:16:46Z",
        "body": "Thanks for correct me. I have a wrong understand about grain single-thread.\n"
      }
    ]
  },
  {
    "number": 135,
    "title": "Namespaces do not match project settings",
    "created_at": "2015-02-15T20:24:16Z",
    "closed_at": "2015-02-25T15:47:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/135",
    "body": "Apparently the namespaces in the .cs files do not match the settings of the 'Default namespace' and the folder in which the files are located. \n\nIs it ok to make a pull request for just fixing namespaces? \n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/135/comments",
    "author": "MovGP0",
    "comments": [
      {
        "user": "MovGP0",
        "created_at": "2015-02-15T20:43:26Z",
        "body": "I would put files who are in the right namespace but wrong folder into the correct folder. \n\nI um unsure how to handle files that are in the wrong namespace but correct folder. Moving public classes would be a breaking change and since it is in production now that might cause some unwanted issues. \n\nWould it be ok to move the internal classes and not the public ones? \n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-02-15T23:04:37Z",
        "body": "Could you clarify what definition of 'right' and 'wrong' you are applying here. Do you mean namespaces exactly matching the folder structure? The folder structure tries to organize the source files around related pieces of functionality. I'm not sure what we'll gain by blindly assigning namespaces to follow that structure or rearranging files according to the namespaces.\n\nFor example, we have a bunch of types in the Orleans.Runtime namespace that are spread across a number of folders. If we were to follow the rule and move, say, Catalog related types to Orleans.Runtime.Catalog and GrainTypeManager related types to Orleans.Runtime.GrainTypeManager, etc., would that be cleaner or just a bunch of extra namespaces with no added value?\n\nAnother example is the Orleans\\IDs folder that holds types with some relation to identities from different parts of the runtime: QueueId and StreamId from Orleans.Streams and SiloAddress from Orleans.Runtime. With the proposal, would we have to move the source files to different folders to match their respective namespaces or to move them all to a single Orlean.IDs namespace? \n"
      },
      {
        "user": "jthelin",
        "created_at": "2015-02-24T22:45:01Z",
        "body": "Merged PR #160 which is a partial solution to this question / issue.\n\nMost of this is historic cruft based on the way the code evolved and restructured over time, so there may be other simple things that can be done to clean things up here without breaking changes to APIs.\n\nIf anyone spots any other major discrepancies, please flag them and/or submit small targeted pull requests.\n"
      }
    ]
  },
  {
    "number": 106,
    "title": "Unordered attribute",
    "created_at": "2015-02-10T19:30:10Z",
    "closed_at": "2015-03-25T22:50:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/106",
    "body": "This one is not documented anywhere but is visible on API's public surface.. It' also the only one which targets grain interface (all other attributes target grain implemenation classes).\n\nWhat does it do? \n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/106/comments",
    "author": "yevhen",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-02-10T21:37:00Z",
        "body": "By default calls to a grain are ordered. You can mark the grain as unordered and then ordering is not maintained.\n\nOne place it is used now is if the grain is stateless worker it is implicitly unordered. We take advantage of that in the way we pick gateways. For ordered grains all msgs to the same grain go via the same gw, to maintain order. For stateless workers msgs sent to a stateless worker grain will be round robined between different gateways. That way if let’s say you have one client and 10 silos, and you have some heavy operation you want to load balance across multiple stateless workers on multiple silos, this will happen since we will send msgs to different gateways and each gateway will have local stateless workers.\n"
      },
      {
        "user": "yevhen",
        "created_at": "2015-02-18T20:59:09Z",
        "body": "@gabikliot \n\n> One place it is used now is if the grain is stateless worker it is implicitly unordered. \n\nSo that attribute doesn't make sense in conj with `StatelessWorker`, right?\n\nI'm not sure I completely understand what _order_ means here. I'd like to understand why it's needed and when I (as developer) would want to change it? What would you write in the documentation? What are the use-cases?\n\nP.S. Awaiting the task naturally orders message delivery, from the perspective of single sender (per-session order).  But, when there multiple autonomous senders - then order doesn't really matter. They cannot make decisions that rely on global order, since there is no global ordering in Orleans.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-02-19T06:49:12Z",
        "body": "'Ordered' is probably too strong of a claim here. Client (frontend) when talking to silos (gateways) tries to maintain order by sending messages to a particular grain through a single gateway (via consistent hashing). In other words, even though a client is connected to a number of gateways, it spreads messages across them via a consistent mapping based on the target grain IDs.\n\nNow, StatelessWorkers are a special case. They may have multiple activations per grain ID, and even on different silos. If client were to send messages to a StatelessWorkers grain with the 'ordering' scheme described above, it would only send them to a single gateway, which would limit its throughput. StatelessWorkers are a good fit for scenarios when they perform a functional operation with no affinity to a context. An example is the Presence sample. In these scenarios is it desirable to evenly spread messages across all gateways, and often time a single ID is used for all StatelessWorkers grain activations in the system. Hence, Unordered is automatically implied for StatelessWorker grains.\n"
      },
      {
        "user": "yevhen",
        "created_at": "2015-02-19T15:49:31Z",
        "body": "Ok. It looks like this attribute is something internal, no?\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-02-19T18:43:29Z",
        "body": "I can't think of another use case for it other than StatelessWorker off the top of my head. So it is kind of internal in that sense.\n"
      },
      {
        "user": "yevhen",
        "created_at": "2015-03-25T22:50:06Z",
        "body": "Answered. Thanks!\n"
      }
    ]
  },
  {
    "number": 97,
    "title": "Does Task.Delay break actor concurrency constraints?",
    "created_at": "2015-02-07T20:24:40Z",
    "closed_at": "2015-02-07T20:34:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/97",
    "body": "",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/97/comments",
    "author": "rogeralsing",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-02-07T22:51:25Z",
        "body": "It does not. All works correctly, due to the usage of our custom TaskScheduler. \n"
      }
    ]
  },
  {
    "number": 7985,
    "title": "Make it possible to tune the deactivation of grains in relation to memory usage",
    "created_at": "2022-09-17T12:41:49Z",
    "closed_at": "2023-11-11T17:34:15Z",
    "labels": [
      "help wanted",
      "area-grains"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7985",
    "body": "Make it possible to tune the deactivation of grains in relation to memory usage, both for the GC-reported usage and host environment. Orleans implements `IHostEnvironmentStatistics` and `IAppEnvironmentStatistics` and these can be queried against configuration to see if deactivation of grains should be suppressed.\r\n\r\nThe implementation should have functional parity with the current implementation to make any configurable new behavior not come off as surprising.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7985/comments",
    "author": "COCPORN",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2022-09-22T18:44:38Z",
        "body": "We've moved this issue to the Backlog. This means that it is not going to be worked on for the coming release. We review items in the backlog at the end of each milestone/release and depending on the team's priority we may reconsider this issue for the following milestone. "
      },
      {
        "user": "ReubenBond",
        "created_at": "2023-11-11T17:34:15Z",
        "body": "Closing in favor of the existing issue, #370"
      }
    ]
  },
  {
    "number": 7837,
    "title": "Provide a [Timeout(TimeSpan)] attribute to specify timeouts for grain method calls",
    "created_at": "2022-07-06T18:31:49Z",
    "closed_at": "2023-08-31T11:53:53Z",
    "labels": [
      "help wanted",
      "Status: Fixed",
      "area-grains"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7837",
    "body": "I propose a `[Timeout(TimeSpan)]` attribute that can be applied to a grain method to specify the timeout for that method call, overriding the default global timeout configured by the `SiloMessagingOptions.ResponseTimeout` and `ClientMessagingOptions.ResponseTimeout` options.\r\n\r\nAn infinite timeout could also be specified by decorating a method with `[Timeout(TimeSpan.InfiniteTimeSpan)]`. This could be used in place of the `[LongRunning]` attribute proposed in #7649.\r\n\r\nThis may also be relevant to #4328.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7837/comments",
    "author": "bill-poole",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2022-07-07T18:28:51Z",
        "body": "We're moving this issue to the `4.0-Planning` milestone for future evaluation / consideration. Because it's not immediately obvious that this is a bug in our framework, we would like to keep this around to collect more feedback, which can later help us determine the impact of it. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it's very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues."
      },
      {
        "user": "htxryan",
        "created_at": "2022-12-09T11:48:02Z",
        "body": "I really like this idea, and it would be a huge help to our team.\r\n\r\nIn theory could something like this also work for the `ReceiveReminder` handler? Right now we have to essentially implement a polling loop to monitor a longer running task that is kicked off by a reminder, which is not ideal."
      },
      {
        "user": "ReubenBond",
        "created_at": "2023-01-12T00:56:59Z",
        "body": "I *think* we should do this, or at least something similar. I'll keep this open for now as an alternative / complement to #7649"
      },
      {
        "user": "DunetsNM",
        "created_at": "2023-08-30T23:00:12Z",
        "body": "Imo it'd be more flexible to specify timeout imperatively via code rather than attribute with a static timeout value"
      },
      {
        "user": "ReubenBond",
        "created_at": "2023-08-30T23:42:38Z",
        "body": "It would be more flexible. How do you imagine specifying it? The two main options which I see are:\r\n1. Use a named policy, specified via an attribute\r\n2. Use a strongly typed policy, specified via a generic attribute\r\n\r\nSpecifying the type from the call site could be accomplished using `RequestContext` with either option."
      },
      {
        "user": "DunetsNM",
        "created_at": "2023-08-31T04:05:09Z",
        "body": "I'm not sure about the feasibility but I would imagine it like an extension method to either a task returned by a grain method (similar to `.ConfigureAwait`) or the `IGrainFactory.GetGrain` extension / overload\r\n\r\n```\r\nawait grain.DoSomething().ConfigureGrainTimeout(TimeSpan);\r\n```\r\n\r\nor\r\n \r\n```\r\nvar grain = grainFactory.GetGrain<...>(...).WithTimeout(TimeSpan);\r\nawait grain.DoSomething();\r\n```"
      },
      {
        "user": "ghost",
        "created_at": "2023-08-31T06:29:59Z",
        "body": "> I'm not sure about the feasibility but I would imagine it like an extension method to either a task returned by a grain method (similar to `.ConfigureAwait`) or the `IGrainFactory.GetGrain` extension / overload\r\n> \r\n> ```\r\n> await grain.DoSomething().ConfigureGrainTimeout(TimeSpan);\r\n> ```\r\n> \r\n> or\r\n> \r\n> ```\r\n> var grain = grainFactory.GetGrain<...>(...).WithTimeout(TimeSpan);\r\n> await grain.DoSomething();\r\n> ```\r\n\r\nThat would even make the timeout different _per call_.\r\n\r\nAnother possibility could be to use `Microsoft.Extensions.Options` in some way, although I'm not sure how it would work to have options per grain type. Can you have `IOptions<GrainOptions<TGrain>>`, or perhaps `GrainOptions` could have an `IDictionary<Type, SingleGrainTypeOptions>`? \r\n\r\nI'm presuming it would be beneficial to know before each invocation what the timeout will be, especially in the light of the `[LongRunning]` discussion. And if Orleans wants to support changing the timeout at runtime after startup, supporting `IOptionsMonitor` is always an option. (hah!)\r\n\r\nP.S. I am also in favor of not being constrained by attributes that need constant values. I prefer things like this to be configurable _somehow_, but I would be okay with this configuration being \"static\". "
      },
      {
        "user": "ReubenBond",
        "created_at": "2023-08-31T16:26:43Z",
        "body": "Having a `.WithTimeout(x)` extension on `IGrain` which returns a new grain reference could work. It's a little allocation-heavy for my liking, though, and the API feels a little awkward to me.\r\n\r\nThe `await grain.DoSomething().ConfigureGrainTimeout(TimeSpan);` option is not workable without some hackery or using a different return type for grain calls (eg, `Rpc<T>`/`Request<T>` instead of `Task<T>`/`ValueTask<T>`, etc). The core reason is that `Task` in .NET is _hot_: they start execution eagerly, before `await`. For contrast, `IAsyncEnumerable<T>` methods are _cold_: they do not begin execution until you begin enumerating the result.\r\n\r\nAs for attributes which reference a configurable policy, I think that is a viable approach. The difficulty will be in ensuring that the result is still very fast. Having a per-call dictionary lookup (eg, via DI) or additional allocations would be expensive. It can be done, but it will require a lot of work at the codegen level to generate efficient code."
      }
    ]
  },
  {
    "number": 7723,
    "title": "`AddFromExisting` should throw when no existing implementation is present",
    "created_at": "2022-05-06T04:48:42Z",
    "closed_at": "2022-05-20T19:05:03Z",
    "labels": [
      "help wanted",
      "Needs: triage :mag:",
      "Status: Fixed"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7723",
    "body": "... rather than just silently ignoring the issue.\r\n\r\nA different variant of the method can be added if we need the current behavior.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7723/comments",
    "author": "ReubenBond",
    "comments": [
      {
        "user": "ElanHasson",
        "created_at": "2022-05-07T00:02:54Z",
        "body": "I'll take this one and do tonight."
      }
    ]
  },
  {
    "number": 7202,
    "title": "Unify the Orleans HostingEnvironment and the Microsoft.Extensions.Hosting implementations",
    "created_at": "2021-08-17T17:27:48Z",
    "closed_at": "2022-02-19T21:49:19Z",
    "labels": [
      "enhancement",
      "help wanted"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7202",
    "body": "As a suggested papercut item for Milestone 4",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7202/comments",
    "author": "icanhasjonas",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2021-09-02T18:43:43Z",
        "body": "@icanhasjonas apologies for the slow response. I agree with you. We should remove our version of `HostingEnvironment` and use `Microsoft.Extensions.Hosting.Abstractions` instead."
      },
      {
        "user": "ReubenBond",
        "created_at": "2022-02-19T21:49:19Z",
        "body": "Fixed in #7276"
      }
    ]
  },
  {
    "number": 7189,
    "title": "Vulnerable version of Newtonsoft.Json in Microsoft.Orleans.Core/3.4.3",
    "created_at": "2021-08-09T05:47:38Z",
    "closed_at": "2022-02-19T21:50:42Z",
    "labels": [
      "help wanted",
      "good-first-issue"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7189",
    "body": "The Newtonsoft.Json NuGet being used in Microsoft.Orleans.Core is vulnerable and needs an upgrade to the 13.0.1 version to be remediated. \r\n\r\nHere is the description of vulnerability for reference: Newtonsoft.Json is vulnerable to denial-of-service (DoS) due to a stack overflow that can occur whenever nested objects are being processed. A remote attacker could cause a vulnerable application to crash by causing it to process a maliciously crafted JSON object.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7189/comments",
    "author": "pranjalmathur",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2022-02-19T21:50:42Z",
        "body": "Fixed via #7272. v3.6.0 and 4.0.0-preview1 have the latest library versions"
      }
    ]
  },
  {
    "number": 6194,
    "title": "If a grain implementation class doesn't derive from Grain, the error message is unhelpful",
    "created_at": "2019-12-19T13:09:59Z",
    "closed_at": "2021-02-22T01:07:02Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6194",
    "body": "I had a project with IMyGrain which inherited from IGrainWithIntegerKey, but I forget to derive the implementation class from Grain.\r\n\r\nThis all compiles with no warning (as IGrainWithIntegerKey has no methods to implement), but at runtime fails with \"cannot find an implementation class\" when I call GetGrain<IMyGrain>().\r\n\r\nI feel this could be more helpfully spotted.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6194/comments",
    "author": "OracPrime",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-12-30T20:16:04Z",
        "body": "We are looking into making inheriting from `Grain` unnecessary in 4.0. In the meantime, is there a way to give a useful warning? By flagging any non-abstract class that implements `IGrainWithXKey` and doesn't inherit from `Grain`?"
      },
      {
        "user": "gulbanana",
        "created_at": "2020-01-15T12:47:39Z",
        "body": "An analyzer could be used for this, the way Xunit does it."
      },
      {
        "user": "RiskRunner0",
        "created_at": "2021-02-22T00:52:23Z",
        "body": "Can this be closed?"
      }
    ]
  },
  {
    "number": 4906,
    "title": "Migrate DynamoDB transaction state provider to new interface",
    "created_at": "2018-08-28T23:33:27Z",
    "closed_at": "2018-11-29T22:39:30Z",
    "labels": [
      "help wanted",
      "hacktoberfest"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4906",
    "body": "DynamoDB was originally submitted and merge with #4056. It implemented the `ITransactionLogStorage` interface which no longer exists.\r\n\r\nThe provider project was deleted from the sources when transitioning to the distributed transaction manager (TM), which removed the ITransactionLogStorage.  The project can be reintroduced for a DynamoDB implementation of `ITransactionalStateStorage`.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4906/comments",
    "author": "sergeybykov",
    "comments": [
      {
        "user": "jsteinich",
        "created_at": "2018-09-04T13:23:32Z",
        "body": "For what it's worth, I don't have plans to use this. We are already using a custom DynamoDB storage provider."
      }
    ]
  },
  {
    "number": 2650,
    "title": "Log / Trace File does not rollover automatically",
    "created_at": "2017-01-27T21:41:57Z",
    "closed_at": "2020-06-02T22:23:00Z",
    "labels": [
      "enhancement",
      "help wanted",
      "hacktoberfest"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2650",
    "body": "The trace file name & path is configured thru <Tracing..> element in the xml or corresponding property in the code.  But there is no way to specify automatic rollovers of this trace/log file.  When a silo runs for multiple days/weeks without restart, the log file grew very huge and no popular text editors can open the file.  Need this automatic rollovers in a production environment, so we can get separate log files for each hour or day, depending on the configuration.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2650/comments",
    "author": "sarmut",
    "comments": [
      {
        "user": "erictuvesson",
        "created_at": "2020-05-27T20:43:19Z",
        "body": "@sergeybykov This seems to be an issue from Orleans 1.x, is that still relevant? "
      },
      {
        "user": "sergeybykov",
        "created_at": "2020-06-02T22:23:00Z",
        "body": "Thank you, @erictuvesson. This is obsolete indeed. Closing."
      }
    ]
  },
  {
    "number": 2180,
    "title": "add \"last edited\" and \"last reviewed\" dates to each documentation page",
    "created_at": "2016-09-20T12:49:20Z",
    "closed_at": "2021-08-05T19:02:16Z",
    "labels": [
      "Needs: documentation 📄",
      "help wanted"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2180",
    "body": "When documentation lags behind current versions of Orleans (or any open source project) and the recommended best practices in using it, it can be helpful for developers to know how old that documentation is, how long ago it's been reviewed for relevance and current recommended practices, etc., before one blindly adopts the code in documentation. It doesn't have to be displayed prominently at the top necessarily, just consistently placed in the same location on every page.\n\n\"Originally written\" and \"last edited\" might work better, or maybe just the one \"last edited\" date.\n\nThere's likely some open source tool that could automate updating these dates in the docs.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2180/comments",
    "author": "danvanderboom",
    "comments": [
      {
        "user": "danvanderboom",
        "created_at": "2016-09-20T12:55:01Z",
        "body": "Not that anyone should blindly adopt code from any online documentation :) but you all know what I mean.\n"
      },
      {
        "user": "ashkan-saeedi-mazdeh",
        "created_at": "2016-09-22T17:50:01Z",
        "body": "This is a very good suggestion.\nMS has this alongside the name of the editor on its docs I guess, so we might be able to do it using whatever they use.?\n\nNot that we can force people to adapt good practices, otherwise I would crash any computer which a developer copied code from the browser and is trying to paste in the IDE containing a project more than 3.14 hours old :)\n"
      },
      {
        "user": "JillHeaden",
        "created_at": "2018-06-05T19:51:10Z",
        "body": "I like this idea! I am adding it to the pages as I edit them."
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-06-05T21:26:47Z",
        "body": "Wait. If we have to add/update such timestamps manually, I'm afraid that's too much manual work. That should be automatable I hope."
      },
      {
        "user": "JillHeaden",
        "created_at": "2018-06-05T21:33:43Z",
        "body": "I hope so, too. I don't know how to do it yet, but I am looking into it. "
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-06-06T22:32:10Z",
        "body": "Let's not add those markers manually then, so that we don't end up with a partial mess."
      },
      {
        "user": "ReubenBond",
        "created_at": "2021-08-05T19:02:16Z",
        "body": "I'm closing this for now as it's not actionable, but the point is well noted. I believe that moving documentation to docs.microsoft.com would be the best solution, since that version of DocFx supports this."
      }
    ]
  },
  {
    "number": 1747,
    "title": "ImplicitStreamSubscription via Regex(or other)",
    "created_at": "2016-05-10T22:52:57Z",
    "closed_at": "2017-05-10T00:04:42Z",
    "labels": [
      "enhancement",
      "help wanted",
      "hacktoberfest"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1747",
    "body": "When multiple namespaces need to be subscribed to it would be nice to be able to use a RegEx or some function.\n\n`[ImplicitStreamSubscription(RegEx=@\"(?<pets>cats) and dogs|(?<pets>pigs) and whistles\")]`\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1747/comments",
    "author": "amccool",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2017-05-10T00:04:42Z",
        "body": "Resolved via #2988."
      }
    ]
  },
  {
    "number": 1650,
    "title": "Question: Why doesn't TraceLogger TrackTrace respect current severity level?",
    "created_at": "2016-04-05T20:35:14Z",
    "closed_at": "2023-11-03T22:22:28Z",
    "labels": [
      "bug",
      "help wanted"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1650",
    "body": "I noticed the implementation of `TrackTrace`doesn't check if the message's severity level is equal/lower to current logger's severity level. That means that DefaultTraceLevel, TraceLevelOverride and runtime control using `ManagementGrain`don't apply when using `TrackTrace`, but apply when using Error/Warn/Info/etc. Is this like that by design? If so, will the `Error`/`Warn`/`Info`/etc. APIs remain for the long run? I'm asking since I was told the `ILogConsumer`will be deprecated in favor of the different `ITelemetryConsumer` interfaces, so maybe the original logging APIs are planned to be deprecated as well.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1650/comments",
    "author": "Eldar1205",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-04-05T23:10:20Z",
        "body": "Looks like a bug to me. We are keeping both `ILogConsumer` and `ITelemetryConsumer` until we are certain `ITelemetryConsumer` does everything that `ILogConsumer` does and correctly. After that we can deprecate `ILogConsumer`.\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2023-11-03T22:22:28Z",
        "body": "Closing since this has been obviated by the move to `ILogger` in later Orleans releases."
      }
    ]
  },
  {
    "number": 1402,
    "title": "PVS-Studio: Tests - TesterInternal RequestContextTest has some suspicious formatting",
    "created_at": "2016-02-06T06:11:56Z",
    "closed_at": "2021-02-18T22:24:59Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1402",
    "body": "Some hard to read formatting that is error prone\n\n**V3043 The code's operational logic does not correspond with its formatting. The statement is indented to the right, but it is always executed. It is possible that curly brackets are missing. TesterInternal RequestContextTest.cs 87**\n\n**... TesterInternal RequestContextTest.cs 97**\n\n**... TesterInternal RequestContextTest.cs 111**\n\n**... TesterInternal RequestContextTest.cs 155**\n\n**... TesterInternal RequestContextTest.cs 181**\n\nAll code is like this one: \n\n```\n            if(msg.RequestContextData != null) foreach (var kvp in msg.RequestContextData)\n            {\n                headers.Add(kvp.Key, kvp.Value);\n            };\n```\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1402/comments",
    "author": "centur",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2021-02-18T22:24:59Z",
        "body": "I think we can close this and maybe run more static analysis soon."
      }
    ]
  },
  {
    "number": 1400,
    "title": "PVS-Studio: Some TesterInternal warnings",
    "created_at": "2016-02-06T05:35:05Z",
    "closed_at": "2021-02-18T22:23:16Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1400",
    "body": "Some medium severity warnings around the code in TesterInternal tests. \n\n**V3032 Waiting on this expression is unreliable, as compiler may optimize some of the variables. Use volatile variable(s) or synchronization primitives to avoid this. TesterInternal LoggerTest.cs 468**\n\n**V3051 An excessive type check. The object is already of the 'Exception' type. TesterInternal PersistenceGrainTests.cs 178**\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1400/comments",
    "author": "centur",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2021-02-18T22:23:16Z",
        "body": "I think we can close this and maybe run more static analysis soon. Thanks for reporting it, Alexey :)"
      }
    ]
  },
  {
    "number": 1397,
    "title": "PVS-Check: incorrect check in Orleans.UniqueKey.NewKey method",
    "created_at": "2016-02-06T05:24:48Z",
    "closed_at": "2017-02-17T21:36:08Z",
    "labels": [
      "bug",
      "Status: investigating",
      "help wanted"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1397",
    "body": "Actually comment is correct and describes different behavior than an actual check\n\n**V3022 Expression 'n1 == 0 && n1 != 0' is always false. Unsigned type value is always >= 0. Probably the '||' operator should be used here. Orleans UniqueKey.cs 113**\n\n```\n        private static UniqueKey NewKey(ulong n0, ulong n1, Category category, long typeData, string keyExt)\n        {\n            // in the string representation of a key, we grab the least significant half of n1.\n            // therefore, if n0 is non-zero and n1 is 0, then the string representation will always be\n            // 0x0 and not useful for identification of the grain.\n\n            if (n1 == 0 && n1 != 0)\n                throw new ArgumentException(\"n0 cannot be zero unless n1 is non-zero.\", \"n0\");\n```\n\nShould be `if (n1 == 0 && n0 != 0)`\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1397/comments",
    "author": "centur",
    "comments": [
      {
        "user": "jthelin",
        "created_at": "2016-02-08T19:32:31Z",
        "body": "Seems like there are slightly conflicting statements here:\n\nin the comment \"if n0 is non-zero and n1 is 0\" ... then bad things happen ...\n  -> `if (n0 != 0 && n1 == 0)` then bad\n\nvs the exception message \"n0 cannot be zero unless n1 is non-zero\" \n  -> `if (n0 == 0 && n1 != 0) then throw ...`\n\nDo you think we should include which one or both checks @gabikliot @sergeybykov ?\n\nBut then how does GrainId == `0L` get represented correctly? [always N0 == 0 for long keys]\n\nShould the [grain key type] `Category == Category.KeyExtGrain` be factored into the comparison because that is what the comment is about?\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2016-02-13T06:20:18Z",
        "body": "I have no idea if that comment is correct or not. I never liked bit tweaking there.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-02-17T21:36:07Z",
        "body": "Resolved via #2728."
      }
    ]
  },
  {
    "number": 1391,
    "title": "PVS-Studio: same implementations for semantically different methods  in test and utility grains.",
    "created_at": "2016-02-06T04:58:50Z",
    "closed_at": "2021-02-18T22:24:49Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1391",
    "body": "Set of warnings about  copy-pasted implementation of semantically different methods:\nI've sorted them out by projects and put the runtime and utility ones on top. \nMany of these may be false positives but still worth to look through for \"copy-paste\" errors.\n\n---\n\nOrleans project:\n\n**... 'OnDeliveryFailure' function is fully equivalent to the body of 'OnSubscriptionFailure' function (23, line 29). NoOpStreamFailureHandler.cs 23**\n\n**... 'UnregisterProducer' function is fully equivalent to the body of 'UnregisterConsumer' function (36, line 50). ImplicitStreamPubSub.cs 36**\n\n**... 'ProducerCount' function is fully equivalent to the body of 'ConsumerCount' function (55, line 60). ImplicitStreamPubSub.cs 55**\n\n**... 'Start' function is fully equivalent to the body of 'Close' function (41, line 46). SimpleMessageStreamProvider.cs 41**\n\n---\n\nBondUtils project:\n\n**... 'ReadUInt16' function is fully equivalent to the body of 'ReadVarUInt16' function (22, line 57). InputStream.cs 22**\n\n**... 'ReadUInt32' function is fully equivalent to the body of 'ReadVarUInt32' function (27, line 62). InputStream.cs 27**\n\n**... 'ReadUInt64' function is fully equivalent to the body of 'ReadVarUInt64' function (32, line 67). InputStream.cs 32**\n\n---\n\nTesterInternal project:\n\n**...'StartTimer' function is fully equivalent to the body of 'StopTimer' function (183, line 188). TesterInternal TimerOrleansTest.cs 183**\n\n**... 'SplitScript' function is fully equivalent to the body of 'ConvertToExecutableBatches' function (13, line 44). MySqlStorageForTesting.cs 13**\n\n**... 'TestInitialize' function is fully equivalent to the body of 'TestCleanup' function (32, line 39). GatewaySelectionTest.cs 32**\n\n**... 'TestInitialize' function is fully equivalent to the body of 'TestCleanup' function (44, line 52). ConfigTests.cs 44**\n\n**... 'GrainReference_DotNet_Serialization' function is fully equivalent to the body of 'GrainReference_DotNet_Serialization_Unresolved' function. GrainReferenceTest.cs 53**\n\n**... 'PredFunc' function is fully equivalent to the body of 'StaticPredFunc' function (806, line 811). BuiltInSerializerTests.cs 806**\n\n**... 'Init' function is fully equivalent to the body of 'Close' function (76, line 82). MockStatsCollectors.cs 76**\n\n**... 'Init' function is fully equivalent to the body of 'Close' function (129, line 135). MockStatsCollectors.cs 129**\n\n**... 'ClassCleanup' function is fully equivalent to the body of 'TestInitialize' function (42, line 48). LocalStoreTests.cs 42**\n\n**... 'Persistence_Grain_Write' function is fully equivalent to the body of 'Persistence_Write' function (210, line 318). PersistenceGrainTests.cs 210****\n\n---\n\nTestGrains project\n\n**... 'OnCompletedAsync' function is fully equivalent to the body of 'OnErrorAsync' function (33, line 38). ConsumerEventCountingGrain.cs 33**\n\n**... 'GetAxB_Async' function is fully equivalent to the body of 'GetAxB' function (24, line 57). PromiseForwardGrain.cs 24**\n\n**... 'GetAxB_Async' function is fully equivalent to the body of 'GetAxB' function (28, line 61). PromiseForwardGrain.cs 28**\n\n**... 'GetA_Async' function is fully equivalent to the body of 'GetA' function (44, line 69). PromiseForwardGrain.cs 44**\n\n**... 'DoIt' function is fully equivalent to the body of 'DoMore' function (39, line 44). GrainInterfaceHierarchyGrains.cs 39**\n\n**... 'DoIt' function is fully equivalent to the body of 'DoThat' function (72, line 77). GrainInterfaceHierarchyGrains.cs 72**\n\n**... 'DoIt' function is fully equivalent to the body of 'DoMore' function (122, line 144). GrainInterfaceHierarchyGrains.cs 122**\n\n**... 'SetState' function is fully equivalent to the body of 'SetStateData' function (20, line 37). ValueTypeTestGrain.cs 20**\n\n---\n\nTestInternalGrains project:\n\n**... 'Ping' function is fully equivalent to the body of 'Send' function (81, line 91). StressTestGrain.cs 81**\n\n**... 'OnActivateAsync' function is fully equivalent to the body of 'DoSomething' function (43, line 66). PersistenceTestGrains.cs 43**\n\n**... 'ProduceSequentialSeries' function is fully equivalent to the body of 'ProduceParallelSeries' function (618, line 625). StreamingGrain.cs 618**\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1391/comments",
    "author": "centur",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2021-02-18T22:24:49Z",
        "body": "I think we can close this and maybe run more static analysis soon."
      }
    ]
  },
  {
    "number": 1389,
    "title": "PVS-Studio: excessive prefix check - StartsWith(\"boot\") check also covers \"bootstrap\" cases",
    "created_at": "2016-02-06T04:34:16Z",
    "closed_at": "2018-10-05T22:05:23Z",
    "labels": [
      "help wanted",
      "hacktoberfest"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1389",
    "body": "We can get rid of first check as second check covers all cases which first one does.\n\n**V3053 An excessive expression. Examine the substrings '/bootstrap' and '/boot'. ClientGenerator.cs 310**\n\n```\n else if (arg.StartsWith(\"/bootstrap\") || arg.StartsWith(\"/boot\"))\n```\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1389/comments",
    "author": "centur",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2016-02-06T04:41:58Z",
        "body": "This is very much benign, but we should get rid of one and probably be more strict in parsing codegen args.\n"
      },
      {
        "user": "noamyogev84",
        "created_at": "2018-10-05T19:56:41Z",
        "body": "I think this issue no longer exits. :)"
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-10-05T22:05:23Z",
        "body": "Thanks, @noamyogev84!"
      }
    ]
  },
  {
    "number": 1277,
    "title": "VS 2015 C# Templates not Rendering Correctly",
    "created_at": "2016-01-12T13:18:41Z",
    "closed_at": "2018-07-19T21:51:57Z",
    "labels": [
      "bug",
      "help wanted",
      "hacktoberfest"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1277",
    "body": "With version 1.1.0 of the VS extension, when I try to create a new Orleans Grain Interface, the resulting C# is:\n\n``` C#\nusing System.Threading.Tasks;\nusing Orleans;\n\nnamespace $safeprojectname$\n{\n    /// <summary>\n    /// Grain interface IMyGrain1\n    /// </summary>\n    public interface IMyGrain1 : IGrainWithGuidKey\n{\n\n}\n}\n\n```\n\n$safeprojectname$ should be the appropriate namespace, same thing happens when trying to create an Orleans Grain Class.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1277/comments",
    "author": "zeus82",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2016-01-12T15:06:19Z",
        "body": "What version of VS is this with? Have you tried uninstalling/reinstalling the VSIX?\n"
      },
      {
        "user": "zeus82",
        "created_at": "2016-01-12T16:42:04Z",
        "body": "I have tried uninstalling and re-installing, still get the same problem.  I'm running VS 2015 Update 1 (Enterprise)\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-01-13T23:57:49Z",
        "body": "@zeus82 I can't seem to repro this. VS 2015 Update 1 Enterprise. Maybe a VS corruption or something? Can you try on a different machine?\n"
      },
      {
        "user": "angshuman-agarwal",
        "created_at": "2016-01-14T00:59:41Z",
        "body": "Even I got the same issue with VS 2015 Enterprise - Orleans 1.1.0\n"
      },
      {
        "user": "zeus82",
        "created_at": "2016-01-14T01:12:45Z",
        "body": "I just tried it on my personal computer with VS 2015 Community with Update 1.  I installed Orleans 1.1.0 for the first time and I got the same problem.  I don't know if this helps, but the name of the project I created was \"Test.Backend.Orleans\" and so is the default namespace.  The project is a .NET 4.6.1 \"Orleans Grain Interface Collection\"\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-01-14T16:51:56Z",
        "body": "I am still unable to reproduce this, even after I uninstalled and re-downloaded the VSIX, targeted 4.6.1 I specified \"Test.Backend.Orleans\" as the project name. There must be a missing repro step here I think but I can't think what it can be. Do you have system local set to a different language by chance?\n"
      },
      {
        "user": "zeus82",
        "created_at": "2016-01-14T17:13:40Z",
        "body": "My Work machine is Windows 10 Enterprise (64 bit) and my Language is English (Canada).  I also have English (United States), but its second in the list, so I assume Canada is the default.  All formatting follows my language defaults.\n\nI'm pretty stumped as well.  I poked around in the code, and it looks good!\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-01-15T17:57:50Z",
        "body": "I tried on both Windows 8.1 and 10 with VS 2015.1, and was unable to reproduce the problem that you are seeing. I'm dumbfounded. I suspect this might be a VS bug, but without a stable repro it's impossible to say for sure.\n"
      },
      {
        "user": "timfun",
        "created_at": "2016-06-22T07:22:13Z",
        "body": "I have the same issue here with the latest version of vs extension. I get the same outcome.\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2018-07-19T21:51:57Z",
        "body": "on vs2017+ now"
      }
    ]
  },
  {
    "number": 1263,
    "title": "TODO: Turn on Code Analysis for the Orleans.dll developer API assembly.",
    "created_at": "2016-01-09T20:27:46Z",
    "closed_at": "2016-10-27T04:41:53Z",
    "labels": [
      "help wanted",
      "hacktoberfest"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1263",
    "body": "Recording this work item as a relatively easy Up-For-Grabs issue that anyone wanting to get more involved with Orleans project could take on.\n\nTODO: Turn on Code Analysis to run automatically during build of the main developer API in `Orleans.dll` assembly by ticking the \"Enable Code Analysis on Build\" checkbox in project properties.\n\nThen need to make minor code changes to fix any issues identuified by Code Analysis -- mostly missing IDisposable functions on some classes that use other IDisposable resources.\n\nThe main goal is to get a clean pass (zero CA warnings) from \"_MIcrosoft Minimal Recommended Ruleset_\" when running Build.cmd of Visual Studio build.\n\nA stretch goal would be to use \"_MIcrosoft Managed Recommended Ruleset_\", but that is a significantly more onerous task requiring more code fixes.\n\nExtra credit: \n`OrleansAzureUtils.dll` is the other \"developer facing\" assembly containing often use public Orleans APIs. Would be good to turn on Code Analysis for that assembly too, either as separate PR or combined with this one.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1263/comments",
    "author": "jthelin",
    "comments": [
      {
        "user": "leonpw",
        "created_at": "2016-10-23T12:38:39Z",
        "body": "I will look into this\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-10-27T04:41:53Z",
        "body": "Resolved via #2335.\n"
      }
    ]
  },
  {
    "number": 993,
    "title": "Serializer specification with attributes",
    "created_at": "2015-11-05T05:07:03Z",
    "closed_at": "2023-12-10T05:29:48Z",
    "labels": [
      "enhancement",
      "help wanted",
      "hacktoberfest"
    ],
    "url": "https://github.com/dotnet/orleans/issues/993",
    "body": "This is an attempt to capture the points regarding external serializers.\n\nAn attribute type will be able to be applied on:\n- method parameters - a single parameter will be serialized using the specified serializer\n- method - all of the parameters being serialized will use the specified serializer\n- type - all instances of that type will use the specified serializer\n- grain interface - all methods in the grain interface will be serialized using the specified serializer\n\nThe functionality will be rolled out in phases starting with:\n1) single/multiple serializer support\n2) type-specific serializer\n3) grain interface serializer\n4) parameter serializer\n\nModify built-in storage providers to utilize those attributes\n- Question: How would we guarantee that the data isn't corrupted if the attributes change?\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/993/comments",
    "author": "Carlm-MS",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2023-12-10T05:29:43Z",
        "body": "Serialization is pluggable now and fairly flexibile, even on the method parameter (per-parameter [Immutable] attributes for example), but we haven't received strong signal for this level of granularity in picking serializer: serializer selection is currently per type and I believe thst is a good decision since it leads to a simple mental model. I will close this, but feel free to open a new issue to discuss further."
      }
    ]
  },
  {
    "number": 940,
    "title": "Support returning IAsyncObservable<T> from Grain methods",
    "created_at": "2015-10-26T08:43:55Z",
    "closed_at": "2018-04-17T03:19:13Z",
    "labels": [
      "enhancement",
      "Status: investigating",
      "help wanted"
    ],
    "url": "https://github.com/dotnet/orleans/issues/940",
    "body": "This is a feature request. I may implement it, but I am looking for input before I make an attempt.\n\nCurrently, Grains can return `Task` & `Task<T>` to consumers. This represents the asynchronous nature of distributed systems programming well and encapsulates the possibility of failure. `Task<T>` is restricted to returning only a single value, though.\n\nIdeally, Grains should be able to return `IObservable<T>` or `IAsyncObservable<T>` (depending on whether or not back-pressure/ack is required) in addition to `Task` & `Task<T>`.\n\nThis differs from the Virtual Streams offered by Orleans in a few ways:\n1. Observables are temporary (like tasks), Streams are eternal (like grains)\n2. Observables are 1:1 by default, Streams may be many:many\n3. Observables can take parameters, Streams are identified by `(type, key)`.\n\nSemantics:\n-  Observable methods are invoked on `SubscribeAsync`, not when the client obtains the `IAsyncObservable<T>`.\n- Silo failures are propagated to observers through `OnErrorAsync`. Clients can at that point re-`SubscribeAsync`, at which point the grain method is invoked again.\n\nAny obvious issues which aren't covered here?\n\nInput is be greatly appreciated :)\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/940/comments",
    "author": "ReubenBond",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-10-26T09:27:57Z",
        "body": "What is wrong with Task<IAsyncObs>?\nI also totally didn't understand your semantics. I think I don't understand how you propose to use it.\n"
      },
      {
        "user": "dVakulen",
        "created_at": "2015-10-26T09:30:47Z",
        "body": "Good idea! Some initial thoughts:\nObservables may be 1:many, so there will be a need to store multiple subscriber grains references. \n\n<blockquote>Silo failures are propagated to observers through OnErrorAsync</blockquote> Orleans handles silo failures automatically, also such failures doesn't happen too often, and making user handle it would add seemingly unnecessary boilerplate code. \n<blockquote>Observables can take parameters</blockquote>\n\n can you please explain in more detail - what kind of parameters they would take? \n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-10-26T09:31:23Z",
        "body": "Commenting from phone!!!\nMeant to write what is wrong with Task<IAsyncObs>.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-10-26T09:32:24Z",
        "body": "Ufff....\nTask of IAsyncObs of T as generic parameter.\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2015-10-26T09:40:55Z",
        "body": "@gabikliot: `Task<IAsyncObservable<T>>` is alright, but this feature necessarily requires some core work. `IAsyncObservable<T>` more clearly represents what's going on and shows that grains can return reactive streams directly.\n\n@dVakulen: I mean to say that Grain interfaces can look like this:\n\n``` C#\ninterface ILocationGrain : IGrainWithGuidKey\n{\n  IAsyncObservable<Deal> FindDeals(SearchFilter filter);\n}\n```\n\nI can pass some parameter, `filter`, to the grain when creating the observable. The grain can hold onto the observer and push updates to it when they arrive as long as they match the filter. So we can implement a standing query.\n\nAnother example might be a grain which emits events of different priorities and I only want high-priority events, so I pass that in.\n\nEventually we might be able to return `IAsyncQbservable<T>`, but we will look into that when Rx 3.0 is released.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-10-26T10:32:32Z",
        "body": "So same semantics as Task of IAsyncObs, just different syntax, right? Sure, sounds doable.\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2015-10-26T12:02:57Z",
        "body": "Very similar semantics, yes. One difference is that the Grain method which returns the `IAsyncObservable<T>` is treated similarly to `Observable.Create()` - it is lazily invoked on subscription. That allows it to be reinvoked upon resubscription (consumer-side retry).\n\nThe implementation could involve a consumer-side proxy representing the grain method invocation used to get the `IAsyncObservable<T>`. A copy of the arguments/etc would be kept in that proxy so that the grain method could be invoked every time `SubscribeAsync` is called on the consumer-side object.\n"
      },
      {
        "user": "yevhen",
        "created_at": "2015-10-28T20:25:15Z",
        "body": "LOL. Tell me the truth, are you secretly watching into Orleankka's codebase? :smile:\n\nI have this feature implemented already. So that `StreamRef` can be passed around much the same way like `ActorRef`. \n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-10-28T20:28:30Z",
        "body": "Streams can be passable around in Orleans. `IAsyncStream` should be passable. If not, it's a bug. As I understood, Reuben asks for something else.\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2015-10-28T21:18:40Z",
        "body": "This feature is about extending actor interfaces to support returning streams of values (IAsyncObservable) and would not use the Virtual Streams infrastructure. It's just the logical conclusion of actor interfaces that if I can return a single value asynchronously, I should be able to return multiple values, too.\n\n-----Original Message-----\nFrom: \"Gabriel Kliot\" notifications@github.com\nSent: ‎10/‎29/‎2015 7:28 AM\nTo: \"dotnet/orleans\" orleans@noreply.github.com\nCc: \"Reuben Bond\" reuben.bond@gmail.com\nSubject: Re: [orleans] Support returning IAsyncObservable<T> from Grainmethods (#940)\n\nStreams can be passable around in Orleans. IAsyncStream should be passable. If not, it's a bug. As I understood, Reuben asks for something else.\n—\nReply to this email directly or view it on GitHub.\n"
      },
      {
        "user": "yevhen",
        "created_at": "2015-10-28T21:46:58Z",
        "body": "Understood. Like temporary channels? Isn't is what observers were for?\n"
      },
      {
        "user": "jthelin",
        "created_at": "2015-10-31T04:15:40Z",
        "body": "+1 Nice idea @ReubenBond \n\n> This feature is about extending actor interfaces to support returning streams of values (IAsyncObservable)\n\nI am currently working on another project that would greatly benefit from having this feature available in Orleans too.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-10-31T04:25:09Z",
        "body": "Just to be clear again: we can, now, without any changes, return from the grain method `Task<IAsyncStream<T>>`, and since `IAsyncStream<T>` is also `IAsyncObservable<T>`, we can return `Task<IAsyncObservable<T>>`.  So we already support \"returning streams of values\".\n\n@ReubenBond is asking for more. As I understood, he is asking for syntactic sugar of returning `IAsyncObservable<T>` instead of `Task<IAsyncStream<T>>` and being able to subscribe to the returned `IAsyncObservable` immediately, without first awaiting the Task.\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2015-12-03T20:20:47Z",
        "body": "@gabikliot just to be clear: returning `Task<IAsyncStream<T>`, etc, only work if that `IAsyncStream<T>` is a virtual stream reference - right?\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-12-03T20:30:49Z",
        "body": "Well, currently, we have only one implementation of the `IAsyncStream<T>` interface, so yes.\n\nWe do actually need to create a test and check it. It \"should\" work, as it was designed this way, but I don't remember having a test for that, so it is possible there is some field we don't serialize properly or don't reconstruct properly when deserializing.\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2015-12-03T20:39:24Z",
        "body": "I want to be able to return physical streams: streams which will break when the grain is deactivated, forcing the user to resubscribe in order to continue receiving values.\n\nFor example, I might want to return results to a search query from the grain. Eg, imagine I have an  `IChatRoomGrain` and I want to return only messages which satisfy a custom query, for example, messages which contain the user's name. The client can include the last known `messageId` in the request to ensure they don't miss anything.\n\nMore generally when Bonsai is released, I want methods which take an expression, apply it to a stream (eg, traffic reports), and return the resulting stream.\n\nDoes that sound like desirable functionality to you?\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-12-03T20:44:48Z",
        "body": "Yes, it does. I thought quite a lot about a similar scenario, recently and also originally, when we just started thinking about streams. I will open a new issue and describe my thoughts on that, but a bit later (give me a day or two).\n"
      },
      {
        "user": "danvanderboom",
        "created_at": "2016-08-02T18:48:28Z",
        "body": "@ReubenBond It sounds like this idea is to Timers what Virtual Streams are to Reminders. We need both durable and non-durable versions of each of these core concepts. A grain instance stream sounds very useful, in addition to the grain streams currently supported. \n"
      }
    ]
  },
  {
    "number": 36,
    "title": "Project template/wizard for Azure deployment ",
    "created_at": "2015-01-28T15:50:31Z",
    "closed_at": "2018-07-05T21:35:09Z",
    "labels": [
      "enhancement",
      "help wanted"
    ],
    "url": "https://github.com/dotnet/orleans/issues/36",
    "body": "Worker role for silos (in our experience it is better to star a silo as a standalone process and wait on the process handle in the worker roles code)\nWorker/web role for frontend clients\nConfiguration of diagnostics, ETW tracing, etc.\nTry Azure SDK plug-in as suggested here by @richorama.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/36/comments",
    "author": "sergeybykov",
    "comments": [
      {
        "user": "jason-bragg",
        "created_at": "2018-07-05T21:35:08Z",
        "body": "Samples should be sufficient."
      }
    ]
  }
]