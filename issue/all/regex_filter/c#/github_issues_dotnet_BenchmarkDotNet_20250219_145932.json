[
  {
    "number": 2509,
    "title": "Set PackagesRestorePath",
    "created_at": "2024-01-23T08:14:02Z",
    "closed_at": "2024-02-08T16:23:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/2509",
    "body": "Is there any additional documentation on how to set the PackagesRestorePath? Is it possible to pass it as a command line argument or adjust the runner options without having to configure an entire Job? Thanks. ",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/2509/comments",
    "author": "VA-01",
    "comments": [
      {
        "user": "timcassell",
        "created_at": "2024-02-08T16:01:52Z",
        "body": "Currently, no. The only way is to configure a job with MsBuildArguments. We do support `--wasmArgs` as a command line argument, but no support for MsBuild atm. It could be added."
      },
      {
        "user": "timcassell",
        "created_at": "2024-02-08T16:23:45Z",
        "body": "Sorry, I just checked and saw we do support `--packages` command line option for this purpose.\r\n\r\n```\r\nThe directory to restore packages to (optional).\r\n```"
      }
    ]
  },
  {
    "number": 2340,
    "title": "I want to have a custom attribute to stop benchmark by parameter passed in",
    "created_at": "2023-06-22T05:11:46Z",
    "closed_at": "2023-06-26T10:15:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/2340",
    "body": "As title, I want to develop one custom attribute which can use something like app settings value as parameter of attribute to temporary turn off benchmark process. Anyone can guide me how to do it ? Thanks you very much.",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/2340/comments",
    "author": "hoangnguyen-storai",
    "comments": [
      {
        "user": "AndreyAkinshin",
        "created_at": "2023-06-24T07:45:54Z",
        "body": "Hello @hoangnguyen-storai,\r\n\r\nCould you please provide more context for your questions? Why do want such an attribute? What do you want to achieve?"
      },
      {
        "user": "hoangnguyen-storai",
        "created_at": "2023-06-26T10:15:06Z",
        "body": "Hello @AndreyAkinshin , thanks you for your response but I have figured it out. but still thank you very much."
      }
    ]
  },
  {
    "number": 2327,
    "title": "NU1108 Cycle detected. BenchmarkDotnet -> BenchmarkDotNet (>= 0.13.5). BenchmarkDotnet",
    "created_at": "2023-06-12T07:27:35Z",
    "closed_at": "2023-06-12T07:42:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/2327",
    "body": "Created brand new console .NET7 app in VS 2022, trying to install nuget, getting: \r\n\r\n`NU1108 Cycle detected. BenchmarkDotnet -> BenchmarkDotNet (>= 0.13.5). BenchmarkDotnet`\r\n\r\ntried to clean solution, restart VS etc. nothing works. ",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/2327/comments",
    "author": "maxima120",
    "comments": [
      {
        "user": "AndreyAkinshin",
        "created_at": "2023-06-12T07:42:49Z",
        "body": "@maxima120 the name of your project could not be the same as a name of a NuGet package that you are referencing. It's a \"feature\" of NuGet, it has nothing to do with BenchmarkDotNet. Just use another name for your project (`BenchmarkDotNet` is reserved), and it will work fine."
      }
    ]
  },
  {
    "number": 2291,
    "title": "How to pass configuration to benchmark?",
    "created_at": "2023-03-22T10:33:41Z",
    "closed_at": "2023-05-10T15:30:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/2291",
    "body": "I use parser for CLI application which gets some data from user. How to make a benchmark use it?\r\nHow I see it: when I run benchmark with Run method I pass key-value dictionary which can be used inside benchmark",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/2291/comments",
    "author": "FreePhoenix888",
    "comments": [
      {
        "user": "AndreyAkinshin",
        "created_at": "2023-05-09T17:26:01Z",
        "body": "@FreePhoenix888 what about passing data via environment variables?"
      },
      {
        "user": "FreePhoenix888",
        "created_at": "2023-05-10T14:58:50Z",
        "body": "> @FreePhoenix888 what about passing data via environment variables?\r\n\r\nI have already  solved my problem by using environment variables. Is this the only way?"
      },
      {
        "user": "AndreyAkinshin",
        "created_at": "2023-05-10T15:30:51Z",
        "body": "Yes, we do not have any additional APIs for passing data to a benchmark via the command line. However, we do support passing environment variables throw native BenchmarkDotNet args like this:\r\n\r\n```sh\r\ndotnet run -c Release -- --envVars VARIABLE_NAME:variable_value\r\n```"
      }
    ]
  },
  {
    "number": 2273,
    "title": "Non-attribute version docs.",
    "created_at": "2023-02-21T10:57:37Z",
    "closed_at": "2023-05-10T14:49:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/2273",
    "body": "After 10 min of searching it is still unclear how to run a basic test without attribute-based class. This should be way simpler.\r\nThe example here is very confusing\r\n```\r\nManualConfig.CreateEmpty() // A configuration for our benchmarks\r\n    .AddJob(Job.Default // Adding first job\r\n        .WithRuntime(ClrRuntime.Net472) // .NET Framework 4.7.2\r\n        .WithPlatform(Platform.X64) // Run as x64 application\r\n        .WithJit(Jit.LegacyJit) // Use LegacyJIT instead of the default RyuJIT\r\n        .WithGcServer(true) // Use Server GC\r\n    ).AddJob(Job.Default // Adding second job\r\n        .AsBaseline() // It will be marked as baseline\r\n        .WithEnvironmentVariable(\"Key\", \"Value\") // Setting an environment variable\r\n        .WithWarmupCount(0) // Disable warm-up stage\r\n    );\r\n```\r\nThe first thing and most important I expect to see is the way how the lib knows which code to run. But this is not specified anywhere, aside from what I can imply from a `BenchmarkAttribute`",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/2273/comments",
    "author": "0xorial",
    "comments": [
      {
        "user": "AndreyAkinshin",
        "created_at": "2023-02-22T15:21:38Z",
        "body": "@0xorial the current BenchmarkDotNet design assumes that you always provide a class with a set of methods marked with the `[Benchmark]` attribute (while other configuration options can be set via attributes or via the fluent API).\r\n\r\nWhat's the problem with creating a separate class?"
      },
      {
        "user": "AndreyAkinshin",
        "created_at": "2023-05-09T17:32:52Z",
        "body": "@0xorial ping"
      },
      {
        "user": "0xorial",
        "created_at": "2023-05-10T08:34:40Z",
        "body": "@AndreyAkinshin TBH, I think it just triggers some kind of OCD here :) \r\nIn my case, I wanted to benchmark a tiny piece of code in scope of a single process, which seems like a very easy subset of what this library is doing, so the API for that could be like\r\n\r\n```\r\nBenchmark.Run(() => Method1(), () => Method2(), b => b.WarmupIterations(2).Iterations(100).ExportConsole())\r\n```\r\n\r\nHaving to figure out the processes, jobs, etc felt needlessly tedious..\r\n"
      },
      {
        "user": "AndreyAkinshin",
        "created_at": "2023-05-10T14:49:52Z",
        "body": "@0xorial Thank you for your feedback and for expressing your concerns about the current API design of BenchmarkDotNet. I appreciate your input and understand that you're looking for a more straightforward way to benchmark small pieces of code.\r\n\r\nHowever, at the current moment, I don't want to support the API you proposed for the following reasons:\r\n\r\n* **Complexity of implementation and maintenance**: Implementing an additional set of APIs that allow running benchmarks without attribute-based classes would add a significant level of complexity to the codebase, making it harder to maintain, test, and evolve the library.\r\n* **Limited feature scope**: Not all the features offered by BenchmarkDotNet, such as setup and cleanup methods, parameterization, and automatic iteration count determination, can be easily implemented with the proposed approach. This would lead to a fragmented and potentially confusing user experience.\r\n* **Challenges with lambda expressions and closures**: Passing lambda expressions to a separate benchmarking process, especially in the case of closures, is tricky and error-prone. BenchmarkDotNet relies on a separate process to provide accurate measurements, and the current attribute-based design ensures that all necessary method calls and states are correctly transferred.\r\n* **Validation difficulties**: Validating benchmarks with the proposed API is much harder compared to the default attribute-based API. There is a higher chance of mistakes, which could lead to inaccurate results or unexpected behavior. The attribute-based API provides a more structured and bulletproof way of defining benchmarks, reducing the likelihood of such issues.\r\n\r\nWhile I understand that the current API may not be ideal for some specific scenarios, our priority is to maintain the robustness and reliability of BenchmarkDotNet. I believe that the trade-offs associated with implementing the proposed feature outweigh the potential benefits."
      },
      {
        "user": "0xorial",
        "created_at": "2023-05-11T13:33:35Z",
        "body": "In either case thanks for taking time!"
      }
    ]
  },
  {
    "number": 2053,
    "title": "How to specify SolutionDir for the dotnet build stage of BenchmarkDotNet",
    "created_at": "2022-07-27T12:41:01Z",
    "closed_at": "2022-08-02T13:37:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/2053",
    "body": "Our projects require the SolutionDir to be defined for msbuild to work. Otherwise, the calls BenchmarkDotNet makes into dotnet build fail.\r\n\r\nHow do we specify it?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/2053/comments",
    "author": "ShaharPrishMSFT",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2022-07-28T06:44:54Z",
        "body": "Hi @ShaharPrishMSFT \r\n\r\nYou can pass MSBuild properties by specyfing them in the following way:\r\n\r\n```cs\r\njob.With(new Argument[] { new MsBuildArgument(\"/p:SomeProperty=Value\")})\r\n```\r\n\r\nFull config:\r\n\r\n```cs\r\nusing BenchmarkDotNet.Configs;\r\nusing BenchmarkDotNet.Jobs;\r\nusing BenchmarkDotNet.Running;\r\n\r\nnamespace BenchmarkDotNet.Samples\r\n{\r\n    public class Program\r\n    {\r\n        public static void Main(string[] args)\r\n            => BenchmarkSwitcher\r\n                .FromAssembly(typeof(Program).Assembly)\r\n                .Run(args,\r\n                    DefaultConfig.Instance\r\n                        .AddJob(Job.Default.WithArguments(new Argument[] { new MsBuildArgument(\"/p:SomeProperty=Value\") })));\r\n    }\r\n}\r\n```\r\n"
      }
    ]
  },
  {
    "number": 2032,
    "title": "Exception when using System.Text.Json.Nodes.JsonNode",
    "created_at": "2022-07-04T13:16:10Z",
    "closed_at": "2022-07-08T11:22:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/2032",
    "body": "When running a benchmark using v0.13.1 on net6.0, I get an exception when the code-under-inspection attempts to set a property on a JSON node. This is done via code in `JsonPatch.Net` 2.0.2 (available on nuget)\r\n\r\nThe same benchmark class, when compiled and run in a net60 console app explicitly calling the methods *does not* throw this exception.\r\n\r\nThe manually-created console application project has been updated to reflect the settings seen in the generated csproj file, to test as close to like-for-like as possible, without the reflection element in the job runner.\r\n\r\nIf this is not a well-known problem, I can produce a minimal repro project and attach it to this issue.\r\n\r\n```\r\n// Benchmark Process Environment Information:\r\n// Runtime=.NET 6.0.5 (6.0.522.21309), X64 RyuJIT\r\n// GC=Concurrent Workstation\r\n// Job: Dry(OutlierMode=RemoveAll, IterationCount=1, LaunchCount=1, RunStrategy=Throughput, UnrollFactor=1, WarmupCount=1)\r\n```\r\n\r\n```\r\nSystem.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation.\r\n ---> System.InvalidOperationException: The node already has a parent.\r\n   at System.Text.Json.ThrowHelper.ThrowInvalidOperationException_NodeAlreadyHasParent()\r\n   at System.Text.Json.Nodes.JsonNode.AssignParent(JsonNode parent)\r\n   at System.Text.Json.Nodes.JsonObject.<>c__DisplayClass9_0.<SetItem>b__0()\r\n   at System.Text.Json.JsonPropertyDictionary`1.SetValue(String propertyName, T value, Action assignParent)\r\n   at System.Text.Json.Nodes.JsonObject.SetItem(String propertyName, JsonNode value)\r\n   at System.Text.Json.Nodes.JsonNode.set_Item(String propertyName, JsonNode value)\r\n   at Json.Patch.AddOperationHandler.Process(PatchContext context, PatchOperation operation)\r\n   at Json.Patch.JsonPatch.Apply(JsonNode source)\r\n   at Benchmarks.GeneratedBenchmark0.PatchJsonEverything() in C:\\Users\\matth\\source\\repos\\Corvus.JsonSchema\\Solutions\\Corvus.JsonPatch.Benchmarking\\Benchmarks\\Generated\\GeneratedBenchmark0.cs:line 50\r\n   at BenchmarkDotNet.Autogenerated.Runnable_1.WorkloadActionUnroll(Int64 invokeCount) in C:\\Users\\matth\\source\\repos\\Corvus.JsonSchema\\Solutions\\Corvus.JsonPatch.Benchmarking\\bin\\Release\\net6.0\\bda76d8b-1bc5-4df5-8893-94a55f871a58\\bda76d8b-1bc5-4df5-8893-94a55f871a58.notcs:line 1279\r\n   at BenchmarkDotNet.Engines.Engine.RunIteration(IterationData data)\r\n   at BenchmarkDotNet.Engines.EnginePilotStage.RunAuto()\r\n   at BenchmarkDotNet.Engines.EnginePilotStage.Run()\r\n   at BenchmarkDotNet.Engines.Engine.Run()\r\n   at BenchmarkDotNet.Autogenerated.Runnable_1.Run(IHost host, String benchmarkName) in C:\\Users\\matth\\source\\repos\\Corvus.JsonSchema\\Solutions\\Corvus.JsonPatch.Benchmarking\\bin\\Release\\net6.0\\bda76d8b-1bc5-4df5-8893-94a55f871a58\\bda76d8b-1bc5-4df5-8893-94a55f871a58.notcs:line 766\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Span`1& arguments, Signature sig, Boolean constructor, Boolean wrapExceptions)\r\n   at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n   at System.Reflection.MethodBase.Invoke(Object obj, Object[] parameters)\r\n   at BenchmarkDotNet.Autogenerated.UniqueProgramName.AfterAssemblyLoadingAttached(String[] args) in C:\\Users\\matth\\source\\repos\\Corvus.JsonSchema\\Solutions\\Corvus.JsonPatch.Benchmarking\\bin\\Release\\net6.0\\bda76d8b-1bc5-4df5-8893-94a55f871a58\\bda76d8b-1bc5-4df5-8893-94a55f871a58.notcs:line 54\r\n```\r\nAutomatically created csproj file:\r\n\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <ImportDirectoryBuildProps>false</ImportDirectoryBuildProps>\r\n    <ImportDirectoryBuildTargets>false</ImportDirectoryBuildTargets>\r\n    <AssemblyTitle>4697048a-e3d0-4620-a8af-39b655eb70e0</AssemblyTitle>\r\n    <TargetFramework>net6.0</TargetFramework>\r\n    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\r\n    <PlatformTarget>x64</PlatformTarget>\r\n    <AssemblyName>4697048a-e3d0-4620-a8af-39b655eb70e0</AssemblyName>\r\n    <OutputType>Exe</OutputType>\r\n    <OutputPath>bin\\Release</OutputPath>\r\n    <TreatWarningsAsErrors>False</TreatWarningsAsErrors>\r\n    <DebugType>pdbonly</DebugType>\r\n    <DebugSymbols>true</DebugSymbols>\r\n    <UseSharedCompilation>false</UseSharedCompilation>\r\n    <CodeAnalysisRuleSet></CodeAnalysisRuleSet>\r\n    <Deterministic>true</Deterministic>\r\n    <!-- needed for custom build configurations (only \"Release\" builds are optimized by default) -->\r\n    <Optimize Condition=\" '$(Configuration)' != 'Debug' \">true</Optimize>\r\n    \r\n    <!-- we set LangVersion after  which might contain LangVersion copied from the benchmarks project -->\r\n    <LangVersion Condition=\"'$(LangVersion)' == '' Or ($([System.Char]::IsDigit('$(LangVersion)', 0)) And '$(LangVersion)' &lt; '7.3')\">latest</LangVersion>\r\n    <AppendTargetFrameworkToOutputPath>true</AppendTargetFrameworkToOutputPath>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <Compile Include=\"4697048a-e3d0-4620-a8af-39b655eb70e0.notcs\" Exclude=\"bin\\**;obj\\**;**\\*.xproj;packages\\**\" />\r\n  </ItemGroup>\r\n\r\n  <ItemGroup>\r\n    <ProjectReference Include=\".[..snipped...]Corvus.JsonSchema\\Solutions\\Corvus.JsonPatch.Benchmarking\\Corvus.JsonPatch.Benchmarking.csproj\" />\r\n  </ItemGroup>\r\n  <PropertyGroup>\r\n<ServerGarbageCollection>false</ServerGarbageCollection>\r\n<ConcurrentGarbageCollection>true</ConcurrentGarbageCollection>\r\n</PropertyGroup>\r\n\r\n\r\n</Project>\r\n\r\n```\r\n\r\nManually created csproj file:\r\n\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n\t<PropertyGroup>\r\n\t\t<ImportDirectoryBuildProps>false</ImportDirectoryBuildProps>\r\n\t\t<ImportDirectoryBuildTargets>false</ImportDirectoryBuildTargets>\r\n\t\t<TargetFramework>net6.0</TargetFramework>\r\n\t\t<AllowUnsafeBlocks>true</AllowUnsafeBlocks>\r\n\t\t<PlatformTarget>x64</PlatformTarget>\r\n\t\t<OutputType>Exe</OutputType>\r\n\t\t<OutputPath>bin\\Release</OutputPath>\r\n\t\t<TreatWarningsAsErrors>False</TreatWarningsAsErrors>\r\n\t\t<DebugType>pdbonly</DebugType>\r\n\t\t<DebugSymbols>true</DebugSymbols>\r\n\t\t<UseSharedCompilation>false</UseSharedCompilation>\r\n\t\t<CodeAnalysisRuleSet></CodeAnalysisRuleSet>\r\n\t\t<Deterministic>true</Deterministic>\r\n\t\t<!-- needed for custom build configurations (only \"Release\" builds are optimized by default) -->\r\n\t\t<Optimize Condition=\" '$(Configuration)' != 'Debug' \">true</Optimize>\r\n\r\n\t\t<!-- we set LangVersion after  which might contain LangVersion copied from the benchmarks project -->\r\n\t\t<LangVersion Condition=\"'$(LangVersion)' == '' Or ($([System.Char]::IsDigit('$(LangVersion)', 0)) And '$(LangVersion)' &lt; '7.3')\">latest</LangVersion>\r\n\t\t<AppendTargetFrameworkToOutputPath>true</AppendTargetFrameworkToOutputPath>\r\n\t</PropertyGroup>\r\n\r\n\t<PropertyGroup>\r\n\t\t<ServerGarbageCollection>false</ServerGarbageCollection>\r\n\t\t<ConcurrentGarbageCollection>true</ConcurrentGarbageCollection>\r\n\t</PropertyGroup>\r\n\r\n\r\n</Project>\r\n```",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/2032/comments",
    "author": "mwadams",
    "comments": [
      {
        "user": "mawosoft",
        "created_at": "2022-07-07T15:58:21Z",
        "body": "Keep in mind that the benchmark method is called multiple times. Most likely (I only took a quick look), the second call operates on a node already modified by the first call."
      },
      {
        "user": "AndreyAkinshin",
        "created_at": "2022-07-08T11:21:34Z",
        "body": "> Keep in mind that the benchmark method is called multiple times. Most likely (I only took a quick look), the second call operates on a node already modified by the first call.\r\n\r\nI believe it's the right guess. BenchmarkDotNet assumes that all the benchmark methods don't have any side effects. If this guess is correct, the problem could be workaround using one of the following options:\r\n\r\n* Include the initialization logic of your JSON objects to the benchmark method (in this case, BenchmarkDotNet measurements will include the initialization time as well)\r\n* Initialize a new JSON object in `[IterationSetup]` and set `InvocationCount = 1` in the job settings (this approach produces reliable measurements only for benchmarks that take a reasonable about of time, e.g., >1ms)\r\n* Preallocate a list of JSON objects in `[GlobalSetup]` and use the following object from this list in each benchmark invocation\r\n\r\nIt's hard to provide any other guidance without a stable repro."
      },
      {
        "user": "timcassell",
        "created_at": "2022-07-08T11:52:34Z",
        "body": "> * Preallocate a list of JSON objects in `[GlobalSetup]` and use the following object from this list in each benchmark invocation\r\n\r\nIf using default configuration, that's unreliable, as we can't know how many invocations will be done thanks to heuristics. What configuration settings makes that reliable (what should the count of the list be)?"
      },
      {
        "user": "AndreyAkinshin",
        "created_at": "2022-07-08T12:17:36Z",
        "body": "> What configuration settings makes that reliable (what should the count of the list be)?\r\n\r\nIt's hard to say in advance because BenchmarkDotNet uses tricky heuristics to determine the optimal number of invocations on the fly based on obtained measurements. I could suggest the following approach:\r\n\r\n* Try to guess a sufficient number using the trial and error method (make sure that BenchmarkDotNet correctly perform all the measurements without any exceptions).\r\n* Check you the obtained number of invocations and jit/warmup/target iterations. Fix them using the Job settings.\r\n* Adjust the number of pre-allocated objects according to the obtained settings.\r\n\r\nIt's not an elegant solution, but it would provide a stable set of benchmarks."
      }
    ]
  },
  {
    "number": 1977,
    "title": "More Data for JSON and XML Export",
    "created_at": "2022-03-30T18:52:08Z",
    "closed_at": "2022-10-05T10:45:43Z",
    "labels": [
      "question",
      "Area:Exporters"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1977",
    "body": "I am looking at the export to JSON and XML for benchmark tests, to see if I can load it into something like Power BI, etc. I feel there is a bit more data in the output like the benchmark name and the date time of the run. Below is an example. Is this possible?\r\n\r\n```\r\n{\r\n  \"Title\": \"dotNetTips.CodePerf.Example.App.BenchmarkTests.GeneralBenchmark-20220322-154421\",\r\n  \"HostEnvironmentInfo\": {\r\n    \"BenchmarkDotNetCaption\": \"BenchmarkDotNet\",\r\n    \"BenchmarkDotNetVersion\": \"0.13.1\",\r\n    \"OsVersion\": \"Windows 10.0.19043.1586 (21H1/May2021Update)\",\r\n    \"ProcessorName\": \"Intel Core i7-7660U CPU 2.50GHz (Kaby Lake)\",\r\n    \"PhysicalProcessorCount\": 1,\r\n    \"PhysicalCoreCount\": 2,\r\n    \"LogicalCoreCount\": 4,\r\n    \"RuntimeVersion\": \".NET 5.0.15 (5.0.1522.11506)\",\r\n    \"Architecture\": \"X64\",\r\n    \"HasAttachedDebugger\": false,\r\n    \"HasRyuJit\": true,\r\n    \"Configuration\": \"RELEASE\",\r\n    \"DotNetCliVersion\": \"6.0.200\",\r\n    \"ChronometerFrequency\": {\r\n      \"Hertz\": 10000000\r\n    },\r\n    \"HardwareTimerKind\": \"Unknown\",\r\n    \"Benchmark\": \"dotNetTips.CodePerf.Example.App.BenchmarkTests.GeneralBenchmark\",\r\n    \"RunDate\": \"2021-01-07T15:36:39\"\r\n  },\r\n```",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1977/comments",
    "author": "RealDotNetDave",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2022-10-05T10:45:43Z",
        "body": "Hi @RealDotNetDave \r\n\r\nYes, #2081 which was included in 0.13.2 made it possible to define your own custom JSON exporter that derives from the one provided by BDN and override `virtual IReadOnlyDictionary<string, object> GetDataToSerialize(Summary summary)`"
      }
    ]
  },
  {
    "number": 1948,
    "title": "questions to help with future PRs",
    "created_at": "2022-03-17T19:51:13Z",
    "closed_at": "2022-10-05T10:50:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1948",
    "body": "1. `DotNetCliExecutor` uses `SynchronousProcessOutputLoggerWithDiagnoser`, which reads stdout (only) synchronously, and once it gets `AfterAll` signal, it stops reading. But this means that we miss any output after that line, which could be some error messages. And these can be helpful if, say, the process didn't quit in the 2s after this.\r\n    - Would it be acceptable to make this similar to `AsyncProcessOutputReader`, such that you have a `ProcessInput(exitTimeout)`, which continues to read the output for 2s after `AfterAll`, and then returns?\r\n    - Or maybe refactor a bit to use AsyncProcessOutputReader instead (+message processing)?\r\n\r\n2. ~I want to add support for showing build output, for long running builds like wasm AOT. Should I plumb that as `--showBuildOutput` to `ConfigOptions.ShowBuildOutput`, and then through the call chain to the output readers? Or would it be fine to maybe add a environment variable to control this?~\r\n\r\n3. If a build fails, then we try again with `--no-dependencies`. Why is that? That can hide issues, and cause incorrect builds to be run. If it's needed, then it might be useful to add an option to skip it, not via command line but when defining the toolchain.\r\n\r\ncc @adamsitnik",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1948/comments",
    "author": "radical",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2022-10-05T10:50:38Z",
        "body": "1.  got solved by #2092 (we are using `AsyncProcessOutputReader ` now\r\n3. got solved by #1982\r\n"
      }
    ]
  },
  {
    "number": 1891,
    "title": "Reading result data via C# code",
    "created_at": "2022-01-13T11:41:50Z",
    "closed_at": "2022-01-13T17:37:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1891",
    "body": "Hello there\r\n\r\nI've set up BenchmarkDotNet, but I would like to use it not via the default exporters and statistics, but more in the means of an integration-test. Unfortunately, I didn't see a way to get the actual results as just plain values via the provided API.\r\nIs this in fact not possible or even a good idea? The statistics and the printing are neat, but I wouldn't want to check the results manually.\r\nI've also tried to toy around with a  custom-exporter and basically make this one the test, but this seems also very complicated and doesn't look to be your intention.",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1891/comments",
    "author": "DrMueller",
    "comments": [
      {
        "user": "mawosoft",
        "created_at": "2022-01-13T17:04:05Z",
        "body": "The BenchmarkRunner/Switcher that you call to execute the benchmarks returns `Summary` or `Summary[]`, which contains all the individual measurements in `BenchmarkReport[] Reports`.\r\n\r\nYou can also add one of the other existing exporters, like `JsonExporter.Full` to get these data.\r\n"
      },
      {
        "user": "DrMueller",
        "created_at": "2022-01-13T17:37:07Z",
        "body": "@mawosoft Thank you very much, trying that out as fast as possible."
      }
    ]
  },
  {
    "number": 1693,
    "title": "Estimate Date for Supporting .NET 6",
    "created_at": "2021-04-21T17:19:53Z",
    "closed_at": "2021-04-22T07:23:20Z",
    "labels": [
      "question",
      "Area:Toolchains"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1693",
    "body": "Is there an estimate when BenchmarkDotNet will support .NET 6?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1693/comments",
    "author": "RealDotNetDave",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2021-04-21T17:31:43Z",
        "body": "It already does, but you need to use a preview package from our NuGet feed"
      }
    ]
  },
  {
    "number": 1640,
    "title": "How to eliminate \"Extra Premature Test Invocation\"?",
    "created_at": "2021-01-15T00:46:19Z",
    "closed_at": "2021-02-20T20:37:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1640",
    "body": "I have tried numerous attribute configurations including this one:\r\n`[SimpleJob(RunStrategy.Monitoring, launchCount: 0, warmupCount: 0, targetCount: 1, invocationCount: 1)]`\r\n\r\nNothing I can do seems to prevent a benchmark method from being prematurely run once before the test invocations.\r\nI would expect there is a way to accomplish this:\r\n\r\n1. Execute GlobalTest method.\r\n2. Execute MethodUnderTest method.\r\n3. Record result.\r\n\r\nWhat I'm seeing instead is this:\r\n\r\n1. Execute GlobalTest method.\r\n2. Execute MethodUnderTest method (apparently before the actual test run).\r\n3. Execute MethodUnderTest method.\r\n4. Record result.\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1640/comments",
    "author": "pha3z",
    "comments": [
      {
        "user": "timcassell",
        "created_at": "2021-01-15T06:26:30Z",
        "body": "Did you try running with `RunStrategy.ColdStart`?"
      },
      {
        "user": "adamsitnik",
        "created_at": "2021-02-20T20:37:28Z",
        "body": "@timcassell is right, `RunStrategy.ColdStart` is what you are looking for"
      }
    ]
  },
  {
    "number": 1514,
    "title": "Setup/Cleanup once per process",
    "created_at": "2020-08-12T08:00:45Z",
    "closed_at": "2020-08-17T13:08:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1514",
    "body": "Currently, we can use GlobalSetup/GlobalCleanup and IterationSetup/IterationCleanup for specific classes and test methods.\r\nIn our case, we have some third party graphics libraries that can only be initialized/terminated once per process.\r\nSo, we need to initialize them before the first test is executed and terminate them after the last test is executed.\r\nWould it be possible to add some API to achieve that? Or is there an existing (even hacky) way to do that?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1514/comments",
    "author": "gpetrou",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2020-08-12T08:24:45Z",
        "body": "hi @gpetrou \r\n\r\nBenchmarkDotNet by default executes every benchmark in a standalone process, so using a `[GlobalSetup]` and `[GlobalCleanup]` should be fine."
      }
    ]
  },
  {
    "number": 1468,
    "title": "Controlling host exe name",
    "created_at": "2020-06-09T01:48:30Z",
    "closed_at": "2020-10-21T14:38:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1468",
    "body": "Couldn't find this in the documents. \r\n\r\n1) Is it possible to NOT have the benchmark runner be a randomly named exe (some GUID)? It would make debugging failures that only happen in benchmarks a LOT easier if it had a predictable name so I could use something like procdump to capture exceptions.\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1468/comments",
    "author": "ryanmolden",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2020-10-21T14:38:29Z",
        "body": "Hi @ryanmolden \r\n\r\nWe use random names to avoid files in use exceptions which in the past were very often caused by various anti-virus software (that was scanning the `.exe` while we were trying to remove it after running the benchmarks).\r\n\r\nTo differentiate the benchmarks we pass `--benchmarkName` argument to the process:\r\n\r\n```log\r\n// Execute: C:\\Projects\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\net461\\594aa796-d4c7-4bb6-8bfd-a6cf7ea74937.exe --benchmarkName \"BenchmarkDotNet.Samples.IntroBasic.Sleep\" --job \"Default\" --benchmarkId 0 in\r\n```\r\n\r\nAnd print PID when it quits:\r\n\r\n```log\r\n// AfterAll\r\n// Benchmark Process 26608 has exited with code 0\r\n```\r\n\r\nIf this is not enough, you can use `Job.WithId(string)` method to give Job an ID and combine it with `KeepBenchmarkFiles` method. This will make BDN use provided ID as exe name. But it will also make BDN keep the auto-generated files after running the benchmarks.\r\n\r\n```cs\r\nusing BenchmarkDotNet.Configs;\r\nusing BenchmarkDotNet.Jobs;\r\nusing BenchmarkDotNet.Running;\r\n\r\nnamespace BenchmarkDotNet.Samples\r\n{\r\n    public class Program\r\n    {\r\n        public static void Main(string[] args) \r\n            => BenchmarkSwitcher\r\n                .FromAssembly(typeof(Program).Assembly)\r\n                .Run(args, DefaultConfig.Instance.AddJob(Job.Default.WithId(\"name\")).KeepBenchmarkFiles());\r\n    }\r\n}\r\n```\r\n\r\n```log\r\n// Execute: C:\\Projects\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\net461\\name.exe --benchmarkName \"BenchmarkDotNet.Samples.IntroBasic.Sleep\" --job \"name\" --benchmarkId 0 in\r\n```\r\n\r\nI know that it's far from perfect, but this is the best thing we can offer.\r\n\r\nThanks,\r\nAdam"
      }
    ]
  },
  {
    "number": 1406,
    "title": "BenchmarkSwitcher Throws FileLoadException",
    "created_at": "2020-03-26T18:42:55Z",
    "closed_at": "2020-03-30T05:54:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1406",
    "body": "## Issue\r\n\r\nBuilding with .NET Framework 4.7.2. After upgrading NuGet package `CommandLine` to version `2.7.82`. Running with `BenchmarkSwitcher` throws `FileLoadException` where it's looking for `CommandLine 2.4.3`. \r\n\r\n## Steps To Reproduce\r\n\r\n1. Create a .NET Framework Console App, targeting 4.7.2, add `BenchmarkDotNet` NuGet package.\r\n2. Upgrade `CommandLine` to `2.4.3`\r\n3. Run the following modified version of the sample code \r\n\r\n``` C#\r\n    public class Md5VsSha256\r\n    {\r\n        private const int N = 10000;\r\n        private readonly byte[] data;\r\n\r\n        private readonly SHA256 sha256 = SHA256.Create();\r\n        private readonly MD5 md5 = MD5.Create();\r\n\r\n        public Md5VsSha256()\r\n        {\r\n            data = new byte[N];\r\n            new Random(42).NextBytes(data);\r\n        }\r\n\r\n        [Benchmark]\r\n        public byte[] Sha256() => sha256.ComputeHash(data);\r\n\r\n        [Benchmark]\r\n        public byte[] Md5() => md5.ComputeHash(data);\r\n    }\r\n    public class Program\r\n    {\r\n        public static void Main(string[] args)\r\n        {\r\n            var benchmarkSwitcher = new BenchmarkSwitcher(new []{typeof(Md5VsSha256)});\r\n            benchmarkSwitcher.Run(args);\r\n        }\r\n    }\r\n```\r\nException occurs at `Run`\r\n\r\n## Details\r\n\r\nThis pops up for us while performing a routine NuGet update. We saw `BenchmarkDotNet` NuGet specifies dependency `CommandLine >= 2.4.3` so we thought `CommandLine 2.7.82` will work. This occurs both on `Release` and `Debug`. Regular `BenchmarkRunner` still runs which I assume does not depend on `CommandLine`. Maybe we are doing something wrong?\r\n\r\nBest,\r\nMichael",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1406/comments",
    "author": "Yamazaki93",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2020-03-27T11:25:06Z",
        "body": "> where it's looking for CommandLine 2.4.3.\r\n\r\nIt's most probably a binding redirect issue. Could you please check if upgrading CommandLine is also changing the binding redirect for it?\r\n\r\nAlso, does it work if you just don't update it?"
      },
      {
        "user": "Yamazaki93",
        "created_at": "2020-03-29T21:23:20Z",
        "body": "Hi @adamsitnik,\r\nIt appears to not change the binding redirect after updating NuGet. And yes it works without updating it.\r\nBest,"
      },
      {
        "user": "adamsitnik",
        "created_at": "2020-03-30T05:54:14Z",
        "body": "> It appears to not change the binding redirect after updating NuGet. And yes it works without updating it.\r\n\r\nThank you for the confirmation. In such a case, it's an IDE bug that we can do nothing about.\r\n\r\nIf you just want to get it working, please update the binding redirect manually (or remove the `CommandLine` entry and install it again).\r\n\r\nIf you want to get it fixed, please report it as a bug in your IDE bug tracking system.\r\n\r\n"
      }
    ]
  },
  {
    "number": 1400,
    "title": "Include tested Generic parameter as column in various default outputs",
    "created_at": "2020-03-21T14:37:13Z",
    "closed_at": "2020-03-24T18:43:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1400",
    "body": "The current output formats: Console, markdown, csv, html are all lacking the generic type parameter when exporting benchmarks that were configured with `[GenericTypeArguments]`.\r\n\r\nThis makes compiling combined reports needlessly more complicated.\r\nFor example, it would make sense to be enable merging the generated CSVs for all the generic types that were benchmarked and enable generating some sort of grouped visualization with a different tool.\r\n\r\nI'm opening this issue to make sure I'm not missing something obvious about this.\r\n\r\nIf this is indeed the case, and there are no objections, I'll try to add such an output column be default and submit a PR.\r\n\r\nAny thoughts?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1400/comments",
    "author": "damageboy",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2020-03-23T11:20:46Z",
        "body": "By default, BDN generates a single report per type. If given report belongs to one type, the type information is not included in the report because it's part of the file name.\r\n\r\nI think that what you are looking for is the `--join` switch:\r\n\r\nSample benchmarks:\r\n\r\n```cs\r\nusing BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Running;\r\n\r\nnamespace Generic\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args);\r\n    }\r\n\r\n    [GenericTypeArguments(typeof(int))]\r\n    [GenericTypeArguments(typeof(string))]\r\n    public class Some<T>\r\n    {\r\n        [Benchmark] public bool IsValueType() => typeof(T).IsValueType;\r\n    }\r\n\r\n    [GenericTypeArguments(typeof(int))]\r\n    [GenericTypeArguments(typeof(int))]\r\n    public class Other<T> where T : new()\r\n    {\r\n        [Benchmark] public T Create() => new T();\r\n    }\r\n}\r\n```\r\n\r\nSample command:\r\n\r\n```cmd\r\ndotnet run -c Release --filter '*' --join --job dry\r\n```\r\n\r\nSample output:\r\n\r\n``` ini\r\n\r\nBenchmarkDotNet=v0.12.0, OS=Windows 10.0.18363\r\nIntel Xeon CPU E5-1650 v4 3.60GHz, 1 CPU, 12 logical and 6 physical cores\r\n.NET Core SDK=5.0.100-preview.2.20119.13\r\n  [Host] : .NET Core 3.1.1 (CoreCLR 4.700.19.60701, CoreFX 4.700.19.60801), X64 RyuJIT\r\n  Dry    : .NET Core 3.1.1 (CoreCLR 4.700.19.60701, CoreFX 4.700.19.60801), X64 RyuJIT\r\n\r\nJob=Dry  IterationCount=1  LaunchCount=1  \r\nRunStrategy=ColdStart  UnrollFactor=1  WarmupCount=1  \r\n\r\n```\r\n|         Type |      Method |     Mean | Error |\r\n|------------- |------------ |---------:|------:|\r\n| Other&lt;Int32&gt; |      Create | 391.7 us |    NA |\r\n| Other&lt;Int32&gt; |      Create | 385.1 us |    NA |\r\n|  Some&lt;Int32&gt; | IsValueType | 368.8 us |    NA |\r\n| Some&lt;String&gt; | IsValueType | 378.4 us |    NA |\r\n\r\n@damageboy if `--join` is not enough I am perfectly fine with including the type name as a new column"
      },
      {
        "user": "damageboy",
        "created_at": "2020-03-24T18:43:16Z",
        "body": "No, I think it's good enough for me, Thanks!"
      }
    ]
  },
  {
    "number": 1398,
    "title": "Support for .net standard 2.1",
    "created_at": "2020-03-18T14:30:15Z",
    "closed_at": "2020-03-18T15:37:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1398",
    "body": "When will we see support for .net standard 2.1?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1398/comments",
    "author": "frankhaugen",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2020-03-18T15:37:28Z",
        "body": "Hi @frankhaugen \r\n\r\n.NET Standard X library can reference .NET Standard Y library if `X >= Y`.\r\n\r\nThere is no need for BenchmarkDotNet to upgrade to .NET Standard 2.1, all our key dependencies like Roslyn and TraceEvent support .NET Standard 2.0 and it's all we need.\r\n\r\nIf there is some specific scenario that is currently not supported, please feel free to reopen the issue.\r\n\r\nHave a nice day,\r\nAdam\r\n\r\n\r\n"
      }
    ]
  },
  {
    "number": 1391,
    "title": "How to verify values returned by benchmarks",
    "created_at": "2020-03-13T17:53:11Z",
    "closed_at": "2020-03-13T17:58:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1391",
    "body": "I often write a new version of the benchmarked code but I am not sure if it actually does what it needs to do (whether the new version is not buggy). Then I write some code to check the values for each benchmarked method.\r\n\r\nIt would be a nice to have to have some build in support for results comparer that can launch once before each method is invoked (and for each parameter).",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1391/comments",
    "author": "tkstanczak",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2020-03-13T17:58:37Z",
        "body": "Hi @tkstanczak \r\n\r\nWe already have such a feature, it's called `ReturnValueValidator`\r\n\r\nYou can enable it by using an attribute `[ReturnValueValidatorAttribute]` or by using the fluent config API: `config.AddValidator(ReturnValueValidator.FailOnError))`\r\n\r\nI am going to close this issue now, feel free to reopen it if you have more questions or there are some issues with `ReturnValueValidator`"
      }
    ]
  },
  {
    "number": 1346,
    "title": "Benchmark Crashing on AssemblyCache in .NET Core 3.0.100",
    "created_at": "2020-01-08T00:01:09Z",
    "closed_at": "2020-04-20T14:54:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1346",
    "body": "I've setup my environment before in .NET Framework and my benchmarks worked really great in the past! Kudos for this great lib!\r\n\r\nMy current issue now is that I'm trying to run benchmarks in a new project, this time, in .NET Core 3.0. After writing my last benchmark and executing them, I stumbled upon this error: \r\n\r\n```\r\nC:\\Program Files\\dotnet\\sdk\\3.0.100\\Microsoft.Common.CurrentVersion.targets(4563,5): error MSB3030: Could not copy the file \"C:\\Users\\Kevin.Avignon\\Documents\\Dev\\GitHub\\R.RC\\Robotmaster.CollectionRecommendation\\Robotmaster.CollectionRecommendation.Benchmarks\\bin\\Release\\netcoreapp3.0\\f66f5594-78e5-4bd4-a083-3d1539baf8a9\\obj\\Release\\netcoreapp3.0\\f66f5594-78e5-4bd4-a083-3d1539baf8a9.exe\" because it was not found. [C:\\Users\\Kevin.Avignon\\Documents\\Dev\\GitHub\\R.RC\\Robotmaster.CollectionRecommendation\\Robotmaster.CollectionRecommendation.Benchmarks\\bin\\Release\\netcoreapp3.0\\f66f5594-78e5-4bd4-a083-3d1539baf8a9\\BenchmarkDotNet.Autogenerated.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\3.0.100\\Microsoft.Common.CurrentVersion.targets(2106,5): warning MSB3101: Could not write state file \"obj\\Release\\netcoreapp3.0\\BenchmarkDotNet.Autogenerated.csprojAssemblyReference.cache\". The file 'C:\\Users\\KavignonUserDir\\Documents\\Dev\\GitHub\\R.RC\\Project\\Project.Benchmarks\\bin\\Release\\netcoreapp3.0\\f66f5594-78e5-4bd4-a083-3d1539baf8a9\\obj\\Release\\netcoreapp3.0\\BenchmarkDotNet.Autogenerated.csprojAssemblyReference.cache' already exists. [C:\\Users\\KavignonUserDir\\Documents\\Dev\\GitHub\\R.RC\\Project\\Project.Benchmarks\\bin\\Release\\netcoreapp3.0\\f66f5594-78e5-4bd4-a083-3d1539baf8a9\\BenchmarkDotNet.Autogenerated.csproj]\r\n```\r\n\r\nI made sure of the following before running my benchmarks: \r\n- Release mode\r\n- Passing some arguments to the library: -m --allStats -f *\r\n- Unchecked the option \"Prefer 32 bit.\"\r\n- My benchmarks functions are public\r\n\r\nWhat's the catch here?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1346/comments",
    "author": "Kavignon",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2020-01-10T13:10:06Z",
        "body": "Hello @Kavignon !\r\n\r\nMy gut feeling tells me that MSBuild struggles with long paths. Could you please move the project closer to the root and try again?\r\n\r\nSth like:\r\n\r\n```diff\r\n- C:\\Users\\Kevin.Avignon\\Documents\\Dev\\GitHub\\R.RC\\Robotmaster.CollectionRecommendation\\Robotmaster.CollectionRecommendation.Benchmarks\r\n+ C:\\benchmarks\r\n```"
      },
      {
        "user": "Kavignon",
        "created_at": "2020-04-20T14:54:10Z",
        "body": "Sorry for a long time with no updates. That was precisely the problem! Thanks a lot @adamsitnik "
      }
    ]
  },
  {
    "number": 1330,
    "title": "How to join the results from multiple types?",
    "created_at": "2019-12-13T21:50:28Z",
    "closed_at": "2019-12-17T09:52:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1330",
    "body": "Hi, \r\nI want merge benchmark results. \r\nI use \r\nBenchmarkDotNet version=\"0.12.0\" \r\ntargetFramework=\"net461\"\r\n\r\n` \r\n        \r\n            BenchmarkRunner.Run<MyBenchmark>(ManualConfig\r\n                    .Create(DefaultConfig.Instance)\r\n                    .With(ConfigOptions.JoinSummary)\r\n                    .With(ConfigOptions.DisableLogFile));\r\n\r\n            BenchmarkRunner.Run<MyBenchmark1>(ManualConfig\r\n                    .Create(DefaultConfig.Instance)\r\n                    .With(ConfigOptions.JoinSummary)\r\n                    .With(ConfigOptions.DisableLogFile));\r\n//-------------------------------------------------------------------------\r\n\r\n    public class MyBenchmark\r\n    {\r\n        [Benchmark]\r\n        public void Fn1() => Thread.Sleep(10);\r\n\r\n        [Benchmark]\r\n        public void Fn2() => Thread.Sleep(10);\r\n    }\r\n\r\n    public class MyBenchmark1\r\n    {\r\n        [Benchmark]\r\n        public void Fn__1() => Thread.Sleep(10);\r\n\r\n        [Benchmark]\r\n        public void Fn__2() => Thread.Sleep(10);\r\n    }\r\n`\r\n\r\nbut did'nt obtain merged results in  BenchmarkDotNet.Artifacts . That is correct way to merge benchmarks results?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1330/comments",
    "author": "Wizard2007",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2019-12-17T09:52:53Z",
        "body": "Hello @Wizard2007 \r\n\r\n`BenchmarkRunner.Run` stores no state between the runs. \r\n\r\nTo join the results from multiple types you need to pass all types|assemblies info to a single `BenchmarkRunner.Run` call.\r\n\r\nExample:\r\n\r\n```cs\r\nBenchmarkRunner.Run(\r\n    typeof(MyBenchmark).Assembly, // all benchmarks from given assembly are going to be executed\r\n    ManualConfig\r\n                .Create(DefaultConfig.Instance)\r\n                .With(ConfigOptions.JoinSummary)\r\n                .With(ConfigOptions.DisableLogFile));\r\n```"
      },
      {
        "user": "Wizard2007",
        "created_at": "2019-12-17T21:43:22Z",
        "body": "Thank you, it was very help full, and  I can solve my issue.\r\nI use such code, to run only this two benchmark and join results.\r\n\r\n`            \r\n            \r\n       var config = ManualConfig.Create(DefaultConfig.Instance)\r\n             .With(ConfigOptions.JoinSummary)\r\n             .With(ConfigOptions.DisableLogFile);\r\n\r\n        BenchmarkRunner.Run(new[]{\r\n                BenchmarkConverter.TypeToBenchmarks( typeof(MyBenchmark), config),\r\n                BenchmarkConverter.TypeToBenchmarks( typeof(MyBenchmark1), config) \r\n                });\r\n\r\n`"
      },
      {
        "user": "VAllens",
        "created_at": "2024-12-29T13:44:22Z",
        "body": "> Thank you, it was very help full, and I can solve my issue. I use such code, to run only this two benchmark and join results.\n> \n> `\n> \n> ```\n>    var config = ManualConfig.Create(DefaultConfig.Instance)\n>          .With(ConfigOptions.JoinSummary)\n>          .With(ConfigOptions.DisableLogFile);\n> \n>     BenchmarkRunner.Run(new[]{\n>             BenchmarkConverter.TypeToBenchmarks( typeof(MyBenchmark), config),\n>             BenchmarkConverter.TypeToBenchmarks( typeof(MyBenchmark1), config) \n>             });\n> ```\n> \n> `\n\nIt's an effective solution and it works for me."
      }
    ]
  },
  {
    "number": 1284,
    "title": "Group by benchmark class in joined summary",
    "created_at": "2019-10-16T16:08:24Z",
    "closed_at": "2020-10-23T18:44:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1284",
    "body": "Let's say I have a benchmark like:\r\n\r\n```csharp\r\npublic class MyBenchmark1\r\n{\r\n    [Benchmark]\r\n    public int A() { /* ... */ }\r\n\r\n    [Benchmark]\r\n    public int B() { /* ... */ }\r\n}\r\n\r\npublic class MyBenchmark2\r\n{\r\n    [Benchmark]\r\n    public int A() { /* ... */ }\r\n\r\n    [Benchmark]\r\n    public int B() { /* ... */ }\r\n}\r\n```\r\n\r\nWhen I run with `--join` it shows a summary like:\r\n\r\n|         Type | Method |      Mean |     Error |    StdDev |\r\n|------------- |------- |----------:|----------:|----------:|\r\n| MyBenchmark1 |      A |  6.536 ns | 0.0768 ns | 0.0680 ns |\r\n| MyBenchmark2 |      A | 27.053 ns | 0.2639 ns | 0.2469 ns |\r\n| MyBenchmark1 |      B |  1.450 ns | 0.0439 ns | 0.0411 ns |\r\n| MyBenchmark2 |      B | 33.090 ns | 0.5051 ns | 0.4477 ns |\r\n\r\nIs it possible to let it group by benchmark class so it shows like:\r\n\r\n|         Type | Method |      Mean |     Error |    StdDev |\r\n|------------- |------- |----------:|----------:|----------:|\r\n| MyBenchmark1 |      A |  6.536 ns | 0.0768 ns | 0.0680 ns |\r\n| MyBenchmark1 |      B |  1.450 ns | 0.0439 ns | 0.0411 ns |\r\n|              |        |           |           |           |\r\n| MyBenchmark2 |      A | 27.053 ns | 0.2639 ns | 0.2469 ns |\r\n| MyBenchmark2 |      B | 33.090 ns | 0.5051 ns | 0.4477 ns |\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1284/comments",
    "author": "JeffreyZhao",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2020-10-23T18:44:42Z",
        "body": "Hi @JeffreyZhao \r\n\r\nPlease excuse me for the delay...\r\n\r\nIt's possible by using `SummaryOrderPolicy.Declared`:\r\n\r\n```cs\r\nusing BenchmarkDotNet.Running;\r\nusing BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Configs;\r\nusing BenchmarkDotNet.Order;\r\n\r\nnamespace BenchmarkDotNet.Samples\r\n{\r\n    public class Program\r\n    {\r\n        public static void Main(string[] args)\r\n            => BenchmarkSwitcher\r\n                .FromAssembly(typeof(Program).Assembly)\r\n                .Run(args, DefaultConfig.Instance.WithOrderer(new DefaultOrderer(SummaryOrderPolicy.Declared, MethodOrderPolicy.Declared)));\r\n    }\r\n\r\n    public class MyBenchmark1\r\n    {\r\n        [Benchmark]\r\n        public void A() { /* ... */ }\r\n\r\n        [Benchmark]\r\n        public void B() { /* ... */ }\r\n    }\r\n\r\n    public class MyBenchmark2\r\n    {\r\n        [Benchmark]\r\n        public void A() { /* ... */ }\r\n\r\n        [Benchmark]\r\n        public void B() { /* ... */ }\r\n    }\r\n}\r\n```\r\n\r\nThe results I got for the following command:\r\n\r\n```cmd\r\ndotnet run -c Release -f net461 --filter *MyBenchmark* --join --job dry\r\n```\r\n\r\n|         Type | Method |     Mean | Error |\r\n|------------- |------- |---------:|------:|\r\n| MyBenchmark1 |      A | 296.2 us |    NA |\r\n| MyBenchmark1 |      B | 280.7 us |    NA |\r\n| MyBenchmark2 |      A | 318.6 us |    NA |\r\n| MyBenchmark2 |      B | 436.9 us |    NA |"
      }
    ]
  },
  {
    "number": 1272,
    "title": "ArgumentsSource for large complex type",
    "created_at": "2019-10-04T01:42:16Z",
    "closed_at": "2020-03-11T13:58:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1272",
    "body": "Hi,\r\n\r\nI want to generate a large amount of test input data to benchmark my query.\r\nBasically I will combine predefined params into a large amount of test input:\r\n\r\n` public IEnumerable<TestParam> Data() `\r\n`{`\r\n            `  var dimensions = new string[] { \"A\", \"B\" };`\r\n           `   var kpis = new string[] { \"C\" };`\r\n            `  parameters = CombineArray.generateParams(dimensions, kpis);`\r\n           `   return parameters.AsEnumerable();`\r\n`}`\r\n\r\nThen use it as argumentSource of my benchmark ` [ArgumentsSource(nameof(Data))]`\r\nThe problem is eveytime benchmark method run, it again executes Data method, which can be slow if I try to put large amount of dimensions and kpis, it can generate million of test input.\r\n\r\nI think I can put it on `GlobalSetup`, but don't know how to setup benchmark method to run all of the test input there.\r\nPlease help,\r\nThank you!!!",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1272/comments",
    "author": "valentinoNguyen",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2019-10-05T16:00:50Z",
        "body": "Hello @valentinoNguyen !\r\n\r\n> The problem is eveytime benchmark method run, it again executes Data method, which can be slow if I try to put large amount of dimensions and kpis, it can generate million of test input.\r\n\r\nThis is unfortunately by design. We simply run something like `argumentSource().ToArray()[argumentIndex]` in the auto-generated code.\r\n\r\nThe good news is that as you said moving it to `[GlobalSetup]` should work:\r\n\r\n```cs\r\n[Params(\"A\", \"B\")]\r\npublic string Dimension {get; set;}\r\n\r\n[Params(\"C\", \"D\")]\r\npublic string KPI { get; set;\r\n\r\nprivate TestParam _testParam;\r\n\r\n[GlobalSetup]\r\npublic void Setup() => _testParam = generateParams(Dimension, KPI);\r\n``` \r\n\r\nThe key thing here is that when you are using multiple `Params` in your type with benchmarks, BDN creates a cartesian product of all params. For the example above (ABxCD), we would have the following 4 benchmark cases:\r\n\r\n* A, C\r\n* A, D\r\n* B, C\r\n* B, D"
      },
      {
        "user": "valentinoNguyen",
        "created_at": "2019-10-06T04:07:21Z",
        "body": "Thank you for your quick response!\r\nBut I am curious if is there any way to allow `Params()` take a function or something to generate a set of input params instead of hardcode it like this."
      },
      {
        "user": "adamsitnik",
        "created_at": "2019-10-06T09:12:46Z",
        "body": "> But I am curious if is there any way to allow Params() take a function or something to generate a set of input params instead of hardcode it like this.\r\n\r\nUnfortunately not. The reason is that we need to run the benchmark in a separate process and things like functions are hard to serialize and deserialize (in our case the host and parent process can be two different runtimes: for example .NET Core and Mono or Full .NET Framework and .NET Core)"
      },
      {
        "user": "adamsitnik",
        "created_at": "2020-03-11T13:58:33Z",
        "body": "I am closing since the question got answered."
      }
    ]
  },
  {
    "number": 1246,
    "title": "Summary output isn't ordered by namespace/class/benchmark",
    "created_at": "2019-09-15T18:00:55Z",
    "closed_at": "2020-10-23T19:09:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1246",
    "body": "When I run all benchmarks for the entire assembly, the output isn't logically ordered by namespace->class->method->parameter-job, but it appears each benchmark is only grouped with the job itself. It makes it hard to especially compare benchmarks with a different set of parameters, and in general look at all benchmarks by category/class.\r\n\r\nThe benchmark run is executed using:\r\n```cs\r\n  config.Options = ConfigOptions.JoinSummary;\r\n  Summary[] summaries = BenchmarkRunner.Run(typeof(Program).Assembly, config);\r\n```\r\n\r\n\r\nBelow is an example of a benchmark output. Notice how class and types are interleaved. or `GraphicsOverlayDraw` is more or less in order by parameters, but has other benchmarks stuffed in between them.\r\n\r\n``` ini\r\n\r\nBenchmarkDotNet=v0.11.5, OS=Windows 10.0.17763.529 (1809/October2018Update/Redstone5)\r\nIntel Xeon CPU E5-1620 v3 3.50GHz, 1 CPU, 8 logical and 4 physical cores\r\n.NET Core SDK=3.0.100-preview9-014004\r\n  [Host]  : .NET Core ? (CoreCLR 4.700.19.42102, CoreFX 4.700.19.42104), 64bit RyuJIT\r\n  100.6.0 : .NET Core 3.0.0-preview9-19423-09 (CoreCLR 4.700.19.42102, CoreFX 4.700.19.42104), 64bit RyuJIT\r\n  100.7.0 : .NET Core 3.0.0-preview9-19423-09 (CoreCLR 4.700.19.42102, CoreFX 4.700.19.42104), 64bit RyuJIT\r\n\r\nJit=RyuJit  Platform=X64  Arguments=/p:RestorePackagesPath=E:\\apps\\output\\intermediate\\BenchmarkStaging\\src\\Scripts\\..\\..\\NugetPackageCache /p:RestoreConfigFile=E:\\apps\\output\\intermediate\\BenchmarkStaging\\src\\Scripts\\..\\nuget.config  \r\nToolchain=64 bit cli  InvocationCount=1  \r\n\r\n```\r\n|                Namespace |                      Type |                                                                                                                                                                                                                         Method |     Job |                NuGetReferences | UnrollFactor |  Count | WithMapView |          LayerType |                 Mean |               Error |              StdDev |               Median | Ratio | RatioSD |      Gen 0 |      Gen 1 |     Gen 2 |  Allocated |\r\n|------------------------- |-------------------------- |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |-------- |------------------------------- |------------- |------- |------------ |------------------- |---------------------:|--------------------:|--------------------:|---------------------:|------:|--------:|-----------:|-----------:|----------:|-----------:|\r\n|      **Benchmarks.Geometry** |                  **Geometry** | **&#39;MapPoint avoids interop calls on the coordinates - this test should catch any changes to that behavior. The allocation should be the size of a single object (120 bytes), confirming the native reference isn&#39;t instantiated&#39;** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |           **16** |      **?** |           **?** |                  **?** |             **66.74 ns** |           **0.8748 ns** |           **0.7755 ns** |             **66.36 ns** |  **1.00** |    **0.00** |     **0.0229** |          **-** |         **-** |      **120 B** |\r\n|      Benchmarks.Geometry |                  Geometry | &#39;MapPoint avoids interop calls on the coordinates - this test should catch any changes to that behavior. The allocation should be the size of a single object (120 bytes), confirming the native reference isn&#39;t instantiated&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |            713.13 ns |          12.3039 ns |          11.5090 ns |            710.85 ns | 10.69 |    0.21 |     0.0391 |     0.0191 |    0.0010 |      208 B |\r\n|      Benchmarks.Geometry |                  Geometry | &#39;MapPoint avoids interop calls on the coordinates - this test should catch any changes to that behavior. The allocation should be the size of a single object (120 bytes), confirming the native reference isn&#39;t instantiated&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |             29.29 ns |           0.0944 ns |           0.0837 ns |             29.31 ns |  0.44 |    0.00 |     0.0138 |          - |         - |       72 B |\r\n|      Benchmarks.Geometry |                  Geometry | &#39;MapPoint avoids interop calls on the coordinates - this test should catch any changes to that behavior. The allocation should be the size of a single object (120 bytes), confirming the native reference isn&#39;t instantiated&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |            632.02 ns |           4.6166 ns |           4.3184 ns |            632.15 ns |  9.47 |    0.14 |     0.0305 |     0.0153 |         - |      160 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Geometry |          GeometryBuilders |                                                                                                                                                                                                       MapPointBuilder_GetSetXY | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |             58.63 ns |           0.1267 ns |           0.1124 ns |             58.59 ns |  1.00 |    0.00 |          - |          - |         - |          - |\r\n|      Benchmarks.Geometry |          GeometryBuilders |                                                                                                                                                                                                       MapPointBuilder_GetSetXY | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |             60.64 ns |           0.1670 ns |           0.1562 ns |             60.68 ns |  1.03 |    0.00 |          - |          - |         - |          - |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                             CreateEmptyGraphic | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |          3,286.65 ns |          27.3316 ns |          25.5660 ns |          3,286.32 ns |  1.00 |    0.00 |     0.0343 |     0.0153 |         - |      224 B |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                             CreateEmptyGraphic | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |          3,581.10 ns |          69.5066 ns |          68.2648 ns |          3,593.19 ns |  1.09 |    0.03 |     0.0343 |     0.0153 |         - |      224 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|         Benchmarks.Views |               MapViewLoad |                                                                                                                                                      &#39;Times the amount of time it takes to load a blank mapview to completion&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |  1,064,129,807.69 ns |  17,086,093.2179 ns |  14,267,661.6700 ns |  1,057,963,700.00 ns |  1.00 |    0.00 |          - |          - |         - |          - |\r\n|         Benchmarks.Views |               MapViewLoad |                                                                                                                                                      &#39;Times the amount of time it takes to load a blank mapview to completion&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |  1,056,081,571.43 ns |   8,658,626.0564 ns |   7,675,646.4681 ns |  1,054,007,500.00 ns |  0.99 |    0.01 |          - |          - |         - |          - |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Geometry |  SpatialReferenceCreation |                                                                                                                                                                         &#39;Looks up wrapper and CoreSpatialReference from cache&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |        176,702.74 ns |       2,449.2428 ns |       2,291.0233 ns |        176,563.87 ns | 1.000 |    0.00 |    21.7285 |     0.2441 |         - |   114044 B |\r\n|      Benchmarks.Geometry |  SpatialReferenceCreation |                                                                                                                                                                         &#39;Looks up wrapper and CoreSpatialReference from cache&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |          1,263.88 ns |           1.5334 ns |           1.2805 ns |          1,263.69 ns | 0.007 |    0.00 |          - |          - |         - |          - |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Geometry |          GeometryBuilders |                                                                                                                                                                                                         MapPointBuilder_Create | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |          1,082.07 ns |          21.3198 ns |          23.6969 ns |          1,086.06 ns |  1.00 |    0.00 |     0.0305 |     0.0095 |    0.0019 |      168 B |\r\n|      Benchmarks.Geometry |          GeometryBuilders |                                                                                                                                                                                                         MapPointBuilder_Create | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |          1,018.65 ns |          11.7654 ns |           9.8246 ns |          1,016.31 ns |  0.94 |    0.02 |     0.0229 |     0.0095 |         - |      120 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                         CreateGraphicWithGeometryAndAttributes | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |         11,816.14 ns |          71.3652 ns |          63.2634 ns |         11,823.25 ns |  1.00 |    0.00 |     0.1526 |     0.0763 |         - |      816 B |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                         CreateGraphicWithGeometryAndAttributes | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |         12,427.64 ns |         189.6960 ns |         177.4418 ns |         12,410.94 ns |  1.05 |    0.02 |     0.1526 |     0.0763 |         - |      816 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Geometry |  SpatialReferenceCreation |                                                                                                                                                                       &#39;Creates a wrapper around a cached CoreSpatialReference&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |         89,422.01 ns |       1,737.4394 ns |       1,706.3978 ns |         89,745.29 ns |  1.00 |    0.00 |    22.2168 |          - |         - |   116643 B |\r\n|      Benchmarks.Geometry |  SpatialReferenceCreation |                                                                                                                                                                       &#39;Creates a wrapper around a cached CoreSpatialReference&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |          6,277.36 ns |         353.7962 ns |       1,032.0401 ns |          6,535.69 ns |  0.06 |    0.02 |     1.2283 |     0.1984 |         - |     6447 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Geometry |                  Geometry |                                                                                                                                                                                                   &#39;Creates a 4-vertex polygon&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |          3,537.22 ns |          17.1819 ns |          16.0720 ns |          3,535.16 ns |  1.00 |    0.00 |     0.1221 |     0.0038 |         - |      648 B |\r\n|      Benchmarks.Geometry |                  Geometry |                                                                                                                                                                                                   &#39;Creates a 4-vertex polygon&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |          3,523.05 ns |         251.9599 ns |         247.4584 ns |          3,419.19 ns |  1.00 |    0.07 |     0.1144 |     0.0038 |         - |      600 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Geometry |          GeometryBuilders |                                                                                                                                                                                                     MapPointBuilder_ToGeometry | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |        125,042.24 ns |       1,043.5640 ns |         976.1504 ns |        124,777.81 ns |  1.00 |    0.00 |  1000.0000 |  1000.0000 | 1000.0000 |      168 B |\r\n|      Benchmarks.Geometry |          GeometryBuilders |                                                                                                                                                                                                     MapPointBuilder_ToGeometry | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |        123,830.20 ns |         972.2244 ns |         909.4193 ns |        123,916.58 ns |  0.99 |    0.01 |  1000.0000 |  1000.0000 | 1000.0000 |      152 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                          CreateGraphicSetGeometryAndAttributes | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |         13,436.51 ns |         177.2488 ns |         165.7986 ns |         13,400.60 ns |  1.00 |    0.00 |     0.3052 |     0.1526 |         - |     1608 B |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                          CreateGraphicSetGeometryAndAttributes | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |         13,864.90 ns |          98.7907 ns |          92.4089 ns |         13,882.95 ns |  1.03 |    0.01 |     0.3052 |     0.1526 |         - |     1608 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Geometry |                  Geometry |                                                                                                                                                                                                  &#39;Creates a 4-vertex Polyline&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |          3,540.40 ns |          22.3764 ns |          19.8361 ns |          3,542.20 ns |  1.00 |    0.00 |     0.1221 |     0.0038 |         - |      648 B |\r\n|      Benchmarks.Geometry |                  Geometry |                                                                                                                                                                                                  &#39;Creates a 4-vertex Polyline&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |          3,514.92 ns |          60.0666 ns |          50.1583 ns |          3,512.68 ns |  0.99 |    0.01 |     0.1144 |     0.0038 |         - |      600 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Geometry |          GeometryBuilders |                                                                                                                                                                                        PolygonBuilder_Create4Vertex_ToGeometry | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |          3,979.86 ns |          76.6460 ns |          96.9326 ns |          3,973.92 ns |  1.00 |    0.00 |     0.0687 |     0.0305 |         - |      368 B |\r\n|      Benchmarks.Geometry |          GeometryBuilders |                                                                                                                                                                                        PolygonBuilder_Create4Vertex_ToGeometry | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |          3,631.64 ns |          50.4606 ns |          47.2008 ns |          3,615.83 ns |  0.91 |    0.03 |     0.0572 |     0.0267 |         - |      304 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                             SetStringAttribute | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |          2,194.24 ns |           6.9875 ns |           5.8349 ns |          2,193.62 ns |  1.00 |    0.00 |     0.2861 |          - |         - |     1512 B |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                             SetStringAttribute | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |          2,183.10 ns |          15.6537 ns |          12.2214 ns |          2,187.78 ns |  0.99 |    0.01 |     0.2861 |          - |         - |     1512 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Geometry |                  Geometry |                                                                                                                                                                                                &#39;Creates a 4-vertex Multipoint&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |          1,432.20 ns |          23.8251 ns |          22.2860 ns |          1,425.45 ns |  1.00 |    0.00 |     0.0763 |     0.0038 |         - |      400 B |\r\n|      Benchmarks.Geometry |                  Geometry |                                                                                                                                                                                                &#39;Creates a 4-vertex Multipoint&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |          1,375.75 ns |          18.6364 ns |          17.4325 ns |          1,371.04 ns |  0.96 |    0.02 |     0.0668 |     0.0324 |         - |      352 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                             GetStringAttribute | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |             36.29 ns |           0.1537 ns |           0.1438 ns |             36.31 ns |  1.00 |    0.00 |     0.0122 |          - |         - |       64 B |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                             GetStringAttribute | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |             35.98 ns |           0.1618 ns |           0.1514 ns |             35.95 ns |  0.99 |    0.01 |     0.0122 |          - |         - |       64 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                               SetDateAttribute | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |          2,410.69 ns |           7.6053 ns |           5.9377 ns |          2,409.92 ns |  1.00 |    0.00 |     0.0381 |          - |         - |      208 B |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                               SetDateAttribute | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |          2,444.00 ns |          14.7242 ns |          11.4957 ns |          2,445.57 ns |  1.01 |    0.01 |     0.0381 |          - |         - |      208 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                               GetDateAttribute | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |             40.63 ns |           0.8473 ns |           0.8321 ns |             41.15 ns |  1.00 |    0.00 |     0.0122 |          - |         - |       64 B |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                               GetDateAttribute | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |             35.88 ns |           0.0918 ns |           0.0859 ns |             35.91 ns |  0.88 |    0.02 |     0.0122 |          - |         - |       64 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                             SetDoubleAttribute | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |          1,562.91 ns |          22.0147 ns |          18.3833 ns |          1,573.38 ns |  1.00 |    0.00 |     0.0343 |          - |         - |      184 B |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                             SetDoubleAttribute | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |          1,672.81 ns |         165.8504 ns |         221.4056 ns |          1,552.90 ns |  1.10 |    0.16 |     0.0343 |          - |         - |      184 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                             GetDoubleAttribute | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |             40.84 ns |           0.0877 ns |           0.0821 ns |             40.83 ns |  1.00 |    0.00 |     0.0122 |          - |         - |       64 B |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                             GetDoubleAttribute | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |             44.69 ns |           0.2064 ns |           0.1931 ns |             44.61 ns |  1.09 |    0.00 |     0.0122 |          - |         - |       64 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                                    SetGeometry | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |      ? |           ? |                  ? |            133.61 ns |           0.3066 ns |           0.2560 ns |            133.56 ns |  1.00 |    0.00 |     0.0122 |          - |         - |       64 B |\r\n|      Benchmarks.Graphics |         GraphicAttributes |                                                                                                                                                                                                                    SetGeometry | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |                  ? |            136.88 ns |           0.2397 ns |           0.2242 ns |            136.87 ns |  1.02 |    0.00 |     0.0122 |          - |         - |       64 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n| **Benchmarks.FeatureTables** |         **FeatureTableQuery** |                                                                                                                                                                                                              **QueryPolygonTable** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |           **16** |      **0** |           **?** |                  **?** |        **235,663.29 ns** |       **1,260.7751 ns** |       **1,117.6443 ns** |        **235,654.57 ns** |  **1.00** |    **0.00** |     **0.2441** |          **-** |         **-** |     **1400 B** |\r\n| Benchmarks.FeatureTables |         FeatureTableQuery |                                                                                                                                                                                                              QueryPolygonTable | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      0 |           ? |                  ? |        214,116.50 ns |       1,169.9009 ns |       1,094.3260 ns |        214,488.23 ns |  0.91 |    0.01 |     0.2441 |          - |         - |     1400 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                          &#39;Uses the AddFeature overload to add a number of features one-by-one&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |            1 |      0 |           ? |                  ? |          7,460.00 ns |       1,740.2407 ns |       5,131.1388 ns |          4,850.00 ns |  1.00 |    0.00 |          - |          - |         - |          - |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                          &#39;Uses the AddFeature overload to add a number of features one-by-one&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |            1 |      0 |           ? |                  ? |          4,788.16 ns |         268.4609 ns |         683.3188 ns |          4,600.00 ns |  0.74 |    0.34 |          - |          - |         - |          - |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                         &#39;Uses the AddFeatures collection overload to add a number of features&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |            1 |      0 |           ? |                  ? |        184,350.00 ns |      11,448.3699 ns |      33,395.4323 ns |        174,450.00 ns |  1.00 |    0.00 |          - |          - |         - |          - |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                         &#39;Uses the AddFeatures collection overload to add a number of features&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |            1 |      0 |           ? |                  ? |        178,150.00 ns |       9,971.5951 ns |      28,770.3319 ns |        174,000.00 ns |  1.00 |    0.21 |          - |          - |         - |          - |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      **Benchmarks.Graphics** |       **GraphicsOverlayDraw** |                                                                                                                                                                                 **&#39;Times the amount of time one Draw call takes&#39;** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |           **16** |   **1000** |           **?** |                  **?** |         **22,287.57 ns** |         **441.6132 ns** |         **807.5147 ns** |         **22,191.84 ns** |  **1.00** |    **0.00** |          **-** |          **-** |         **-** |       **32 B** |\r\n|      Benchmarks.Graphics |       GraphicsOverlayDraw |                                                                                                                                                                                 &#39;Times the amount of time one Draw call takes&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |   1000 |           ? |                  ? |         59,138.14 ns |       1,120.5088 ns |       1,048.1246 ns |         58,602.05 ns |  2.61 |    0.09 |          - |          - |         - |       32 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      **Benchmarks.Graphics** |       **GraphicsOverlayDraw** |                                                                                                                                                                                 **&#39;Times the amount of time one Draw call takes&#39;** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |           **16** |   **5000** |           **?** |                  **?** |         **36,368.49 ns** |         **715.9831 ns** |       **1,093.3818 ns** |         **36,622.33 ns** |  **1.00** |    **0.00** |          **-** |          **-** |         **-** |       **32 B** |\r\n|      Benchmarks.Graphics |       GraphicsOverlayDraw |                                                                                                                                                                                 &#39;Times the amount of time one Draw call takes&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |   5000 |           ? |                  ? |         69,763.00 ns |       1,362.8562 ns |       2,081.2253 ns |         69,374.96 ns |  1.92 |    0.09 |          - |          - |         - |       32 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n| **Benchmarks.FeatureTables** |         **FeatureTableQuery** |                                                                                                                                                                                                              **QueryPolygonTable** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |           **16** |  **10000** |           **?** |                  **?** |    **149,267,915.38 ns** |     **470,864.1733 ns** |     **393,192.9102 ns** |    **149,241,150.00 ns** |  **1.00** |    **0.00** |  **1500.0000** |   **750.0000** |         **-** |          **-** |\r\n| Benchmarks.FeatureTables |         FeatureTableQuery |                                                                                                                                                                                                              QueryPolygonTable | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |  10000 |           ? |                  ? |    150,005,550.00 ns |   1,403,021.8240 ns |   1,171,586.7662 ns |    149,862,675.00 ns |  1.00 |    0.01 |  1500.0000 |   750.0000 |         - |          - |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Graphics |       GraphicsOverlayDraw |                                                                                                                                                                                 &#39;Times the amount of time one Draw call takes&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |           16 |  10000 |           ? |                  ? |        356,977.60 ns |       6,418.6929 ns |       6,004.0493 ns |        354,742.99 ns |  1.00 |    0.00 |          - |          - |         - |       32 B |\r\n|      Benchmarks.Graphics |       GraphicsOverlayDraw |                                                                                                                                                                                 &#39;Times the amount of time one Draw call takes&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |  10000 |           ? |                  ? |        375,807.90 ns |       2,833.3253 ns |       2,650.2942 ns |        376,194.73 ns |  1.05 |    0.02 |          - |          - |         - |       32 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                          &#39;Uses the AddFeature overload to add a number of features one-by-one&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |            1 |  10000 |           ? |                  ? |  6,112,836,353.85 ns |  25,338,486.7966 ns |  21,158,784.0610 ns |  6,114,995,100.00 ns |  1.00 |    0.00 |  6000.0000 |  3000.0000 |         - |          - |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                          &#39;Uses the AddFeature overload to add a number of features one-by-one&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |            1 |  10000 |           ? |                  ? |  6,131,686,723.08 ns |  30,646,340.8676 ns |  25,591,082.6042 ns |  6,127,659,700.00 ns |  1.00 |    0.01 |  6000.0000 |  3000.0000 |         - |          - |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                         &#39;Uses the AddFeatures collection overload to add a number of features&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |            1 |  10000 |           ? |                  ? |  1,841,530,129.41 ns |  35,889,390.5592 ns |  36,855,761.7608 ns |  1,830,645,100.00 ns |  1.00 |    0.00 |  8000.0000 |  4000.0000 |         - | 21361512 B |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                         &#39;Uses the AddFeatures collection overload to add a number of features&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |            1 |  10000 |           ? |                  ? |  1,774,537,792.86 ns |  17,252,784.6703 ns |  15,294,144.2276 ns |  1,776,773,200.00 ns |  0.97 |    0.02 |  7000.0000 |  3000.0000 |         - | 20881512 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      **Benchmarks.Graphics** | **GraphicsOverlayUpdatePerf** |                                                                                                                                                                                                   **AddPointGraphic_GeometryOnly** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |            **1** |  **20000** |       **False** |                  **?** |    **129,606,010.87 ns** |   **2,567,960.1404 ns** |   **3,247,647.3505 ns** |    **128,452,450.00 ns** |  **1.00** |    **0.00** |  **2000.0000** |  **1000.0000** |         **-** | **18560000 B** |\r\n|      Benchmarks.Graphics | GraphicsOverlayUpdatePerf |                                                                                                                                                                                                   AddPointGraphic_GeometryOnly | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |            1 |  20000 |       False |                  ? |    121,753,303.85 ns |     813,384.9185 ns |     679,213.2454 ns |    121,765,450.00 ns |  0.94 |    0.03 |  2000.0000 |  1000.0000 |         - | 17600000 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Graphics | GraphicsOverlayUpdatePerf |                                                                                                                                                                                                 AddPointGraphic_WithAttributes | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |            1 |  20000 |       False |                  ? |    292,544,910.00 ns |   4,012,736.4891 ns |   3,753,516.2016 ns |    291,292,350.00 ns |  1.00 |    0.00 |  5000.0000 |  1000.0000 |         - | 33920120 B |\r\n|      Benchmarks.Graphics | GraphicsOverlayUpdatePerf |                                                                                                                                                                                                 AddPointGraphic_WithAttributes | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |            1 |  20000 |       False |                  ? |    295,677,536.67 ns |   3,760,051.3592 ns |   3,517,154.3743 ns |    296,334,150.00 ns |  1.01 |    0.01 |  5000.0000 |  1000.0000 |         - | 33920072 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Graphics | GraphicsOverlayUpdatePerf |                                                                                                                                                                                                            UpdatePointGeometry | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |            1 |  20000 |       False |                  ? |     23,618,546.15 ns |     347,173.3101 ns |     289,905.4375 ns |     23,691,700.00 ns |  1.00 |    0.00 |          - |          - |         - |  2400040 B |\r\n|      Benchmarks.Graphics | GraphicsOverlayUpdatePerf |                                                                                                                                                                                                            UpdatePointGeometry | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |            1 |  20000 |       False |                  ? |     24,557,343.75 ns |     789,181.9271 ns |     775,082.1754 ns |     24,268,200.00 ns |  1.04 |    0.04 |          - |          - |         - |  1440040 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      Benchmarks.Graphics | GraphicsOverlayUpdatePerf |                                                                                                                                                                                                               UpdateAttributes | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |            1 |  20000 |       False |                  ? |    154,800,235.71 ns |   2,256,797.2246 ns |   2,000,591.9569 ns |    154,825,100.00 ns |  1.00 |    0.00 |  2000.0000 |  1000.0000 |         - | 12000040 B |\r\n|      Benchmarks.Graphics | GraphicsOverlayUpdatePerf |                                                                                                                                                                                                               UpdateAttributes | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |            1 |  20000 |       False |                  ? |    155,254,993.33 ns |   1,450,106.6435 ns |   1,356,430.6540 ns |    155,206,900.00 ns |  1.00 |    0.01 |  2000.0000 |  1000.0000 |         - | 12000040 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n| **Benchmarks.FeatureTables** |         **FeatureTableQuery** |                                                                                                                                                                                                              **QueryPolygonTable** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |           **16** |  **20000** |           **?** |                  **?** |    **291,042,253.33 ns** |   **2,343,212.8335 ns** |   **2,191,842.7383 ns** |    **290,925,400.00 ns** |  **1.00** |    **0.00** |  **3000.0000** |  **1500.0000** |         **-** |          **-** |\r\n| Benchmarks.FeatureTables |         FeatureTableQuery |                                                                                                                                                                                                              QueryPolygonTable | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |  20000 |           ? |                  ? |    301,506,323.08 ns |   3,381,254.4551 ns |   2,823,500.6078 ns |    300,486,550.00 ns |  1.04 |    0.01 |  3000.0000 |  1500.0000 |         - |          - |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                          &#39;Uses the AddFeature overload to add a number of features one-by-one&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |            1 |  20000 |           ? |                  ? | 12,136,609,620.00 ns |  23,338,238.2150 ns |  21,830,602.5064 ns | 12,139,581,300.00 ns |  1.00 |    0.00 | 12000.0000 |  6000.0000 |         - |          - |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                          &#39;Uses the AddFeature overload to add a number of features one-by-one&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |            1 |  20000 |           ? |                  ? | 12,181,827,620.00 ns |  31,865,504.4303 ns |  29,807,012.6149 ns | 12,177,286,400.00 ns |  1.00 |    0.00 | 12000.0000 |  6000.0000 |         - |          - |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                         &#39;Uses the AddFeatures collection overload to add a number of features&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |            1 |  20000 |           ? |                  ? |  3,698,568,693.33 ns |  36,170,829.6042 ns |  33,834,216.4538 ns |  3,708,763,500.00 ns |  1.00 |    0.00 | 16000.0000 |  8000.0000 |         - | 42721512 B |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                         &#39;Uses the AddFeatures collection overload to add a number of features&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |            1 |  20000 |           ? |                  ? |  3,705,602,166.67 ns |  50,034,942.2787 ns |  46,802,716.0514 ns |  3,699,115,500.00 ns |  1.00 |    0.01 | 15000.0000 |  7000.0000 |         - | 41761512 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      **Benchmarks.Graphics** |       **GraphicsOverlayDraw** |                                                                                                                                                                                 **&#39;Times the amount of time one Draw call takes&#39;** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |           **16** |  **25000** |           **?** |                  **?** |        **607,247.16 ns** |       **4,703.0041 ns** |       **4,399.1929 ns** |        **609,035.60 ns** |  **1.00** |    **0.00** |          **-** |          **-** |         **-** |       **32 B** |\r\n|      Benchmarks.Graphics |       GraphicsOverlayDraw |                                                                                                                                                                                 &#39;Times the amount of time one Draw call takes&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |  25000 |           ? |                  ? |        618,265.89 ns |       2,785.8338 ns |       2,605.8707 ns |        619,055.76 ns |  1.02 |    0.01 |          - |          - |         - |       32 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n| **Benchmarks.FeatureTables** |         **FeatureTableQuery** |                                                                                                                                                                                                              **QueryPolygonTable** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |           **16** |  **30000** |           **?** |                  **?** |    **437,736,066.67 ns** |   **5,690,116.5153 ns** |   **5,322,538.5188 ns** |    **436,311,000.00 ns** |  **1.00** |    **0.00** |  **4000.0000** |  **2000.0000** |         **-** |          **-** |\r\n| Benchmarks.FeatureTables |         FeatureTableQuery |                                                                                                                                                                                                              QueryPolygonTable | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |  30000 |           ? |                  ? |    460,579,846.15 ns |   8,146,467.7037 ns |   6,802,669.4880 ns |    459,555,400.00 ns |  1.05 |    0.02 |  4000.0000 |  2000.0000 |         - |          - |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                          &#39;Uses the AddFeature overload to add a number of features one-by-one&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |            1 |  30000 |           ? |                  ? | 18,197,286,307.14 ns |  45,265,430.3282 ns |  40,126,624.9590 ns | 18,195,757,350.00 ns |  1.00 |    0.00 | 18000.0000 |  9000.0000 |         - |          - |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                          &#39;Uses the AddFeature overload to add a number of features one-by-one&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |            1 |  30000 |           ? |                  ? | 18,252,114,446.15 ns |  55,062,919.3694 ns |  45,980,031.4856 ns | 18,260,563,400.00 ns |  1.00 |    0.00 | 18000.0000 |  9000.0000 |         - |          - |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                         &#39;Uses the AddFeatures collection overload to add a number of features&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |            1 |  30000 |           ? |                  ? |  6,035,937,533.33 ns |  47,336,346.3672 ns |  44,278,447.7614 ns |  6,031,974,800.00 ns |  1.00 |    0.00 | 24000.0000 | 12000.0000 |         - | 64081512 B |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                         &#39;Uses the AddFeatures collection overload to add a number of features&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |            1 |  30000 |           ? |                  ? |  6,064,161,560.00 ns |  60,344,634.8323 ns |  56,446,408.8626 ns |  6,071,863,600.00 ns |  1.00 |    0.01 | 23000.0000 | 11000.0000 |         - | 62641512 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n| **Benchmarks.FeatureTables** |         **FeatureTableQuery** |                                                                                                                                                                                                              **QueryPolygonTable** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |           **16** |  **40000** |           **?** |                  **?** |    **602,636,384.21 ns** |  **11,733,676.4569 ns** |  **13,041,950.2922 ns** |    **604,128,200.00 ns** |  **1.00** |    **0.00** |  **6000.0000** |  **3000.0000** |         **-** |          **-** |\r\n| Benchmarks.FeatureTables |         FeatureTableQuery |                                                                                                                                                                                                              QueryPolygonTable | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |  40000 |           ? |                  ? |    609,482,800.00 ns |   7,411,104.4906 ns |   6,932,351.7387 ns |    606,529,200.00 ns |  1.01 |    0.02 |  6000.0000 |  3000.0000 |         - |          - |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                          &#39;Uses the AddFeature overload to add a number of features one-by-one&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |            1 |  40000 |           ? |                  ? | 24,356,595,073.33 ns |  35,954,298.6191 ns |  33,631,673.2359 ns | 24,354,624,200.00 ns |  1.00 |    0.00 | 25000.0000 | 12000.0000 |         - |          - |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                          &#39;Uses the AddFeature overload to add a number of features one-by-one&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |            1 |  40000 |           ? |                  ? | 24,283,528,823.08 ns |  52,767,142.2222 ns |  44,062,953.5915 ns | 24,273,645,400.00 ns |  1.00 |    0.00 | 24000.0000 | 12000.0000 |         - |          - |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                         &#39;Uses the AddFeatures collection overload to add a number of features&#39; | 100.6.0 | Esri.ArcGISRuntime.WPF 100.6.0 |            1 |  40000 |           ? |                  ? |  8,509,798,506.67 ns | 111,599,197.0033 ns | 104,389,958.1180 ns |  8,515,113,000.00 ns |  1.00 |    0.00 | 32000.0000 | 16000.0000 |         - | 85441512 B |\r\n| Benchmarks.FeatureTables |       FeatureTableAddRows |                                                                                                                                                         &#39;Uses the AddFeatures collection overload to add a number of features&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |            1 |  40000 |           ? |                  ? |  8,639,963,213.33 ns | 140,584,667.0411 ns | 131,502,984.7752 ns |  8,595,986,600.00 ns |  1.02 |    0.01 | 31000.0000 | 15000.0000 |         - | 83521512 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      **Benchmarks.Graphics** |       **GraphicsOverlayDraw** |                                                                                                                                                                                 **&#39;Times the amount of time one Draw call takes&#39;** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |           **16** |  **50000** |           **?** |                  **?** |      **1,019,645.54 ns** |      **11,435.3062 ns** |      **10,696.5926 ns** |      **1,015,022.51 ns** |  **1.00** |    **0.00** |          **-** |          **-** |         **-** |       **32 B** |\r\n|      Benchmarks.Graphics |       GraphicsOverlayDraw |                                                                                                                                                                                 &#39;Times the amount of time one Draw call takes&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |  50000 |           ? |                  ? |      1,032,860.63 ns |       6,067.5276 ns |       5,675.5691 ns |      1,032,908.06 ns |  1.01 |    0.01 |          - |          - |         - |       32 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      **Benchmarks.Graphics** |       **GraphicsOverlayDraw** |                                                                                                                                                                                 **&#39;Times the amount of time one Draw call takes&#39;** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |           **16** | **100000** |           **?** |                  **?** |      **1,899,677.99 ns** |      **18,164.8859 ns** |      **16,991.4455 ns** |      **1,900,672.07 ns** |  **1.00** |    **0.00** |          **-** |          **-** |         **-** |       **32 B** |\r\n|      Benchmarks.Graphics |       GraphicsOverlayDraw |                                                                                                                                                                                 &#39;Times the amount of time one Draw call takes&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 | 100000 |           ? |                  ? |      1,780,817.63 ns |      34,650.1307 ns |      37,075.2516 ns |      1,784,201.42 ns |  0.94 |    0.02 |          - |          - |         - |       32 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|      **Benchmarks.Graphics** |       **GraphicsOverlayDraw** |                                                                                                                                                                                 **&#39;Times the amount of time one Draw call takes&#39;** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |           **16** | **200000** |           **?** |                  **?** |      **3,213,814.79 ns** |      **35,614.2933 ns** |      **33,313.6320 ns** |      **3,219,890.38 ns** |  **1.00** |    **0.00** |          **-** |          **-** |         **-** |       **32 B** |\r\n|      Benchmarks.Graphics |       GraphicsOverlayDraw |                                                                                                                                                                                 &#39;Times the amount of time one Draw call takes&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 | 200000 |           ? |                  ? |      2,657,572.39 ns |      15,227.7740 ns |      13,499.0250 ns |      2,660,496.19 ns |  0.83 |    0.01 |          - |          - |         - |       32 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|         **Benchmarks.Views** |          **MapViewLayerDraw** |                                                                                                                                                                       **&#39;Measures the amount of time is spent rendering a frame&#39;** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |           **16** |      **?** |           **?** | **BackgroundGridOnly** |         **17,403.61 ns** |         **760.8174 ns** |         **747.2244 ns** |         **17,072.23 ns** |  **1.00** |    **0.00** |          **-** |          **-** |         **-** |       **32 B** |\r\n|         Benchmarks.Views |          MapViewLayerDraw |                                                                                                                                                                       &#39;Measures the amount of time is spent rendering a frame&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? | BackgroundGridOnly |         15,636.81 ns |         306.4536 ns |         458.6853 ns |         15,630.93 ns |  0.90 |    0.04 |          - |          - |         - |       32 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|         **Benchmarks.Views** |          **MapViewLayerDraw** |                                                                                                                                                                       **&#39;Measures the amount of time is spent rendering a frame&#39;** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |           **16** |      **?** |           **?** |            **Streets** |         **48,701.20 ns** |         **964.2859 ns** |       **1,031.7751 ns** |         **48,713.36 ns** |  **1.00** |    **0.00** |          **-** |          **-** |         **-** |       **32 B** |\r\n|         Benchmarks.Views |          MapViewLayerDraw |                                                                                                                                                                       &#39;Measures the amount of time is spent rendering a frame&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |            Streets |         49,675.69 ns |       1,238.9260 ns |       1,098.2757 ns |         49,478.69 ns |  1.01 |    0.03 |          - |          - |         - |       32 B |\r\n|                          |                           |                                                                                                                                                                                                                                |         |                                |              |        |             |                    |                      |                     |                     |                      |       |         |            |            |           |            |\r\n|         **Benchmarks.Views** |          **MapViewLayerDraw** |                                                                                                                                                                       **&#39;Measures the amount of time is spent rendering a frame&#39;** | **100.6.0** | **Esri.ArcGISRuntime.WPF 100.6.0** |           **16** |      **?** |           **?** |      **StreetsVector** |         **48,456.27 ns** |         **124.0324 ns** |          **96.8363 ns** |         **48,488.78 ns** |  **1.00** |    **0.00** |          **-** |          **-** |         **-** |       **32 B** |\r\n|         Benchmarks.Views |          MapViewLayerDraw |                                                                                                                                                                       &#39;Measures the amount of time is spent rendering a frame&#39; | 100.7.0 | Esri.ArcGISRuntime.WPF 100.7.0 |           16 |      ? |           ? |      StreetsVector |         49,010.88 ns |         977.2567 ns |       1,235.9168 ns |         48,439.09 ns |  1.02 |    0.03 |          - |          - |         - |       32 B |\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1246/comments",
    "author": "dotMorten",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2020-10-23T19:09:54Z",
        "body": "Hi @dotMorten \r\n\r\nYou should be able to change the default ordering by using the `Orderer` type.\r\n\r\nExample:\r\n\r\n```cs\r\nusing BenchmarkDotNet.Running;\r\nusing BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Configs;\r\nusing BenchmarkDotNet.Order;\r\n\r\nnamespace BenchmarkDotNet.Samples\r\n{\r\n    public class Program\r\n    {\r\n        public static void Main(string[] args)\r\n            => BenchmarkSwitcher\r\n                .FromAssembly(typeof(Program).Assembly)\r\n                .Run(args, DefaultConfig.Instance.WithOrderer(new DefaultOrderer(SummaryOrderPolicy.Declared, MethodOrderPolicy.Alphabetical)));\r\n    }\r\n}\r\n\r\nnamespace BenchmarkDotNet.Samples.A\r\n{\r\n    public class MyBenchmark2\r\n    {\r\n        [Benchmark] public void B() {}\r\n        [Benchmark] public void A() { }\r\n    }\r\n}\r\n\r\nnamespace BenchmarkDotNet.Samples.B\r\n{\r\n    public class MyBenchmark1\r\n    {\r\n        [Benchmark] public void A() { }\r\n        [Benchmark] public void B() { }\r\n    }\r\n}\r\n\r\nnamespace BenchmarkDotNet.Samples.A\r\n{\r\n    public class MyBenchmark1\r\n    {\r\n        [Benchmark] public void B() { }\r\n        [Benchmark] public void A() { }\r\n    }\r\n}\r\n\r\nnamespace BenchmarkDotNet.Samples.B\r\n{\r\n    public class MyBenchmark2\r\n    {\r\n        [Benchmark] public void A() { }\r\n        [Benchmark] public void B() { }\r\n    }\r\n}\r\n```\r\n\r\n```cmd\r\ndotnet run -c Release -f net461 --filter *MyBenchmark* --join --job dry\r\n```\r\n\r\n```ini\r\nBenchmarkDotNet=v0.12.1.20201023-develop, OS=Windows 10.0.18363.1139 (1909/November2019Update/19H2)\r\nIntel Xeon CPU E5-1650 v4 3.60GHz, 1 CPU, 12 logical and 6 physical cores\r\n  [Host] : .NET Framework 4.8 (4.8.4250.0), X64 RyuJIT\r\n  Dry    : .NET Framework 4.8 (4.8.4250.0), X64 RyuJIT\r\n\r\nJob=Dry  IterationCount=1  LaunchCount=1\r\nRunStrategy=ColdStart  UnrollFactor=1  WarmupCount=1\r\n\r\n|                 Namespace |         Type | Method |     Mean | Error |\r\n|-------------------------- |------------- |------- |---------:|------:|\r\n| BenchmarkDotNet.Samples.A | MyBenchmark1 |      A | 305.6 us |    NA |\r\n| BenchmarkDotNet.Samples.A | MyBenchmark1 |      B | 284.9 us |    NA |\r\n| BenchmarkDotNet.Samples.A | MyBenchmark2 |      A | 282.1 us |    NA |\r\n| BenchmarkDotNet.Samples.A | MyBenchmark2 |      B | 288.2 us |    NA |\r\n| BenchmarkDotNet.Samples.B | MyBenchmark1 |      A | 296.3 us |    NA |\r\n| BenchmarkDotNet.Samples.B | MyBenchmark1 |      B | 301.5 us |    NA |\r\n| BenchmarkDotNet.Samples.B | MyBenchmark2 |      A | 301.2 us |    NA |\r\n| BenchmarkDotNet.Samples.B | MyBenchmark2 |      B | 284.5 us |    NA |"
      }
    ]
  },
  {
    "number": 1192,
    "title": "Comparing project reference against package reference",
    "created_at": "2019-07-05T18:10:01Z",
    "closed_at": "2019-07-08T10:20:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1192",
    "body": "I know it is possible to compare between different NuGet versions, but is it possible to compare a local build of a library (a ProjectReference to Foo.csproj) against an existing NuGet package reference.\r\n\r\nIf not, is it possible to emit a custom MSBuild define on a Job that could be used in a csproj condition for the Reference block?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1192/comments",
    "author": "MihaZupan",
    "comments": [
      {
        "user": "WojciechNagorski",
        "created_at": "2019-07-07T09:47:41Z",
        "body": "I don't know about normal solution for this. But you can try to use local feeds as a workaround. You can publish new version of your package to local directory and then configure your nuget.config in benchmark project to use it."
      },
      {
        "user": "MihaZupan",
        "created_at": "2019-07-07T11:58:14Z",
        "body": "I thought about doing this but didn't think of the nuget config, thanks."
      },
      {
        "user": "MihaZupan",
        "created_at": "2019-07-08T10:20:04Z",
        "body": "Tested it on a few projects and it seems to be working. Thanks again."
      },
      {
        "user": "WojciechNagorski",
        "created_at": "2019-07-08T11:16:12Z",
        "body": "@MihaZupan Thanks for the information."
      }
    ]
  },
  {
    "number": 1140,
    "title": "Targeting .NET 4.6.2 but executing as 4.7.2",
    "created_at": "2019-04-28T17:57:36Z",
    "closed_at": "2019-04-28T21:07:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1140",
    "body": "I have a small benchmark project that is targeting netcoreapp2 and net462.\r\n\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFrameworks>netcoreapp2;net462</TargetFrameworks>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include=\"BenchmarkDotNet\" Version=\"0.11.5\" />\r\n  </ItemGroup>\r\n\r\n</Project>\r\n```\r\n\r\n\r\nHowever when running this benchmark it only seems to respect the netcoreapp target and not the full framework one. It states that the CLR job was run targeting net472. Could I be doing this wrong or is this an issue? I have targeted only two jobs [CoreJob, ClrJob].\r\n\r\n>   [Host] : .NET Core 2.0.9 (CoreCLR 4.6.26614.01, CoreFX 4.6.26614.01), 64bit RyuJIT\r\n>   Clr    : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3394.0\r\n>   Core   : .NET Core 2.0.9 (CoreCLR 4.6.26614.01, CoreFX 4.6.26614.01), 64bit RyuJIT\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1140/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2019-04-28T19:34:11Z",
        "body": "I have also noticed that even if I remove the explicit job attributes and only target my project to net462 the run summary still shows it executes with net472."
      },
      {
        "user": "ghost",
        "created_at": "2019-04-28T21:07:48Z",
        "body": "After asking on SO someone pointed out that unlike .net core the full framework does not have side by side installs but a runtime that is upgraded in place. So even with net462 but having 4.7.2 installed means that will be the runtime. Makes sense."
      },
      {
        "user": "adamsitnik",
        "created_at": "2019-04-29T13:02:24Z",
        "body": "This is the default behavior of Full .NET Framework. No matter what version your app targets, it's always executed with the latest .NET Runtime installed on your machine.\r\n\r\nYou can test it with the following example\r\n\r\n```cs\r\nvoid Main() => System.Console.WriteLine(Microsoft.DotNet.PlatformAbstractions.RuntimeEnvironment.FrameworkDescription);\r\n```"
      }
    ]
  },
  {
    "number": 1060,
    "title": "[Question] How does virtualization affect measurements?",
    "created_at": "2019-02-09T17:58:16Z",
    "closed_at": "2020-10-23T21:13:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1060",
    "body": "What does the following notification mean?\r\n>Benchmark was executed on the virtual machine with Hyper-V hypervisor. Virtualization can affect the measurement result.\r\n\r\nIs there any good source about how virtualization can affect the measurement? I have not seen anything about this topic in the documentation. Could you please point me to some pivot points?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1060/comments",
    "author": "ladeak",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2019-02-21T08:06:27Z",
        "body": "@AndreyAkinshin do you have some good reads?"
      },
      {
        "user": "adamsitnik",
        "created_at": "2020-10-23T21:13:14Z",
        "body": "Hi @ladeak \r\n\r\nPlease excuse us for not responding for so long. I don't have any good references, but I am sure that if you ask this question at StackOverflow someone is going to provide a great answer.\r\n\r\nThank you,\r\nAdam"
      }
    ]
  },
  {
    "number": 1056,
    "title": "Fails to build when targeting .NET Core 3.0 and .NET Framework",
    "created_at": "2019-02-07T20:27:37Z",
    "closed_at": "2019-02-08T06:06:41Z",
    "labels": [
      "question",
      "Area:Toolchains"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1056",
    "body": "Created a new .NET Core 3.0 console application in VS 2019 and added BenchmarkDotNet via nuget. Changed line in proj.csproj:\r\n```\r\n<TargetFramework>netcoreapp3.0</TargetFramework>\r\nto\r\n<TargetFrameworks>net472;netcoreapp3.0</TargetFrameworks>\r\n```\r\n\r\nI receive the following in console output (after CLR job has been successful completed):\r\n```\r\n// Build Exception: Standard output:\r\ncompleted \"proj.csproj\".\r\nproj \\ bin \\ Release \\ net472 \\ 21078fb3-513f-4d7f-807a-57e8bfabfb62 \\ BenchmarkDotNet.Autogenerated.csproj: error NU1201: The proj project is not compatible with **netcoreapp2.0** (.NETCoreApp, version = v2.0). The proj project supports the following:\r\nproj \\ bin \\ Release \\ net472 \\ 21078fb3-513f-4d7f-807a-57e8bfabfb62 \\ BenchmarkDotNet.Autogenerated.csproj: error NU1201: - net472 (.NET Framework, Version = v4.7.2)\r\nproj \\ bin \\ Release \\ net472 \\ 21078fb3-513f-4d7f-807a-57e8bfabfb62 \\ BenchmarkDotNet.Autogenerated.csproj: error NU1201: - netcoreapp3.0 (.NETCoreApp, Version = v3.0)\r\n   Error recovering to \"106.14 ms\" for \"proj \\ bin \\ Release \\ net472 \\ 21078fb3-513f-4d7f-807a-57e8bfabfb62 \\ BenchmarkDotNet.Autogenerated.csproj\".\r\n```\r\n\r\nFor some reason it tries to compile it on .Net Core 2.0 and obviously as the project doesn't support it (target framework is set to .NET Core 3.0), it fails. However when I change the project to .NET Core 2.0 it (not much surprising) \"magically\" works and complete the core benchmark. Like this:\r\n\r\n`<TargetFrameworks>net472;netcoreapp2.0</TargetFrameworks>`\r\n\r\nNow I have another project using BenchmarkDotNet which targets netcoreapp3.0 only and I can run benchmarks on it so I have no idea what's different or the problem.\r\n\r\n//edit, fyi:\r\n**Works:**\r\n`<TargetFrameworks>net472;netcoreapp2.0</TargetFrameworks>`\r\n`<TargetFrameworks>netcoreapp3.0</TargetFrameworks>`\r\n**Fails:**\r\n`<TargetFrameworks>net472;netcoreapp3.0</TargetFrameworks>`",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1056/comments",
    "author": "Symbai",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2019-02-08T06:06:09Z",
        "body": "Hi @Symbai \r\n\r\nBDN generates a project with all boilerplate code that is required to avoid common benchmarking pitfalls. This project has `TargetFramework` property as well.\r\n\r\nDepending on what is the target framework of your host process (the thing that you run in the console) we try to determine `TargetFramework`.\r\n\r\nWith .NET Framework, it's easy, because we just read the entries from Windows Registry which tells use which .NET SDK you have installed.\r\n\r\nBut when your host process is  .NET Framework (`dotnet run -f net472`) and you want to run a .NET Core benchmark we can't determine which .NET Core version you want to target and we use .NET Core 2.0 which is our default.\r\n\r\nTo get it working you need to tell BDN which .NET Core to use:\r\n\r\n```cs\r\nBenchmarkRunner.Run<Program>(\r\n    DefaultConfig.Instance\r\n        .With(Job.Default.With(CsProjCoreToolchain.NetCoreApp30)));\r\n```\r\n\r\nor using the `--runtimes` console line arguments:\r\n\r\n```cmd\r\n--runtimes net472 netcoreapp3.0\r\n```\r\n\r\n```cs\r\nstatic void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args);\r\n```"
      },
      {
        "user": "adamsitnik",
        "created_at": "2019-02-08T06:07:05Z",
        "body": "@Symbai please feel free to reopen if something is not clear"
      }
    ]
  },
  {
    "number": 1019,
    "title": "Generate Exception: Unable to find <Project> in <Folder> and its subfolders",
    "created_at": "2019-01-16T20:45:34Z",
    "closed_at": "2019-01-17T17:08:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1019",
    "body": "I have a project Tests.Performance.csproj DotNet Core 2.2, with BenchmarkDotNet 0.11.3\r\nThe output Tests.Performance.dll is in sub-folder: \\bin\\Release. The program runs fine when the solution file is in this folder. When the solution is in another folder I get the following exceptions:\r\n\r\nUnable to find .sln file. Will use current directory D:\\S6\\pc\\src\\Tests\\Tests.Performance\\bin\\Release to search for project file. If you don't use .sln file on purpose it should not be a problem.\r\n\r\n// Generate Exception: Unable to find Tests.Performance in D:\\SW\\pc\\src\\Tests.Performance\\bin\\Release and its subfolders. Most probably the name of output exe is different than the name of the .(c/f)sproj\r\n\r\nCould you please help with it?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1019/comments",
    "author": "ilyaext",
    "comments": [
      {
        "user": "AndreyAkinshin",
        "created_at": "2019-01-17T08:26:59Z",
        "body": "@adamsitnik could you take a look?"
      },
      {
        "user": "ilyaext",
        "created_at": "2019-01-17T13:18:26Z",
        "body": "Would also be very helpfully if I could add a path to project by configuration. In this case I will not be required to have the same assembly name as the project name. It would probably solve and the problem above"
      },
      {
        "user": "adamsitnik",
        "created_at": "2019-01-17T16:38:48Z",
        "body": "When we generate the boilerplate code we need to reference the project that actually defines the benchmarks.\r\n\r\nWhat we do as of today is that we walk the folders down until we find a folder with `.sln` file. From there, we search for `$dllName.csproj` including subfolders. \r\n\r\n> Would also be very helpfully if I could add a path to project by configuration. In this case I will not be required to have the same assembly name as the project name. \r\n\r\nI think that this is too rare edge case to extend our configuration with another option. The error message is clear, this is our requirement to make it work.\r\n\r\nIf you have a better idea for how we can search for the project file, please let me know."
      },
      {
        "user": "ilyaext",
        "created_at": "2019-01-17T17:32:48Z",
        "body": "The message: \"If you don't use .sln file on purpose it should not be a problem\". In my case the project is in one from upper folder and you could find it without .sln. Could you please add such case?"
      }
    ]
  },
  {
    "number": 1017,
    "title": "Can you please split out Runtime/Environment Info into it's own assembly?",
    "created_at": "2019-01-15T20:23:33Z",
    "closed_at": "2019-01-26T07:10:40Z",
    "labels": [
      "question",
      "wontfix"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1017",
    "body": "I would really like to be able to get all the same runtime info as this project but I don't want to pull in the entire project.",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1017/comments",
    "author": "AceHack",
    "comments": [
      {
        "user": "AndreyAkinshin",
        "created_at": "2019-01-26T07:10:40Z",
        "body": "@AceHack BenchmarkDotNet has a lot of different features which are not directly benchmark-related. We are not going to release and support separate NuGet packages for every feature."
      }
    ]
  },
  {
    "number": 993,
    "title": "How to run Clr and Core jobs at the same time?",
    "created_at": "2018-12-29T14:11:17Z",
    "closed_at": "2018-12-30T17:08:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/993",
    "body": "Hi\r\n\r\nFirst I tried to run Core and Clr jobs on .net core project but in this case only Core job finished successfully.\r\n\r\n``` ini\r\n\r\nBenchmarkDotNet=v0.11.3, OS=Windows 10.0.17134.472 (1803/April2018Update/Redstone4)\r\nIntel Core i7-5500U CPU 2.40GHz (Broadwell), 1 CPU, 4 logical and 2 physical cores\r\n.NET Core SDK=2.2.100\r\n  [Host] : .NET Core 2.2.0 (CoreCLR 4.6.27110.04, CoreFX 4.6.27110.04), 64bit RyuJIT\r\n  Core   : .NET Core 2.2.0 (CoreCLR 4.6.27110.04, CoreFX 4.6.27110.04), 64bit RyuJIT\r\n\r\n\r\n```\r\n|  Method |  Job | Runtime |     Mean |    Error |   StdDev |   Median |\r\n|-------- |----- |-------- |---------:|---------:|---------:|---------:|\r\n| Replace |  Clr |     Clr |       NA |       NA |       NA |       NA |\r\n| Replace | Core |    Core | 20.38 us | 1.389 us | 4.095 us | 18.77 us |\r\n\r\nBenchmarks with issues:\r\n  StringBenchmark.Replace: Clr(Runtime=Clr)\r\n\r\nWhen I checked logs and I found message that project is not compatible with net 472:\r\n\r\n// Build Exception: Standard output: \r\n   Restoring packages for C:\\Dev\\TheCodeManual\\StringPerformance\\StringPerformanceComparison\\bin\\Release\\netcoreapp2.2\\68bc1c9b-f1a8-4730-8f05-3d8e1e81d768\\BenchmarkDotNet.Autogenerated.csproj...\r\n  Restore completed in 72.18 ms for C:\\Dev\\TheCodeManual\\StringPerformance\\StringPerformanceComparison\\StringPerformanceComparison.csproj.\r\nC:\\Dev\\TheCodeManual\\StringPerformance\\StringPerformanceComparison\\bin\\Release\\netcoreapp2.2\\68bc1c9b-f1a8-4730-8f05-3d8e1e81d768\\BenchmarkDotNet.Autogenerated.csproj : error NU1201: Project StringPerformanceComparison is not compatible with net472 (.NETFramework,Version=v4.7.2). Project StringPerformanceComparison supports: netcoreapp2.2 (.NETCoreApp,Version=v2.2)\r\nC:\\Dev\\TheCodeManual\\StringPerformance\\StringPerformanceComparison\\bin\\Release\\netcoreapp2.2\\68bc1c9b-f1a8-4730-8f05-3d8e1e81d768\\BenchmarkDotNet.Autogenerated.csproj : error NU1201: Project StringPerformanceComparison is not compatible with net472 (.NETFramework,Version=v4.7.2) / win7-x64. Project StringPerformanceComparison supports: netcoreapp2.2 (.NETCoreApp,Version=v2.2)\r\n  Restore failed in 194.61 ms for C:\\Dev\\TheCodeManual\\StringPerformance\\StringPerformanceComparison\\bin\\Release\\netcoreapp2.2\\68bc1c9b-f1a8-4730-8f05-3d8e1e81d768\\BenchmarkDotNet.Autogenerated.csproj.\r\n\r\n\r\nSo I tried slightly different approach. I created full .NET framework console app and check what happens. It ended in similar fashion but this time Clr job finished successfully.\r\n\r\n``` ini\r\n\r\nBenchmarkDotNet=v0.11.3, OS=Windows 10.0.17134.472 (1803/April2018Update/Redstone4)\r\nIntel Core i7-5500U CPU 2.40GHz (Broadwell), 1 CPU, 4 logical and 2 physical cores\r\n  [Host] : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3260.0\r\n  Clr    : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3260.0\r\n\r\n\r\n```\r\n|  Method |  Job | Runtime |     Mean |     Error |   StdDev |\r\n|-------- |----- |-------- |---------:|----------:|---------:|\r\n| Replace |  Clr |     Clr | 16.49 us | 0.6754 us | 1.981 us |\r\n| Replace | Core |    Core |       NA |        NA |       NA |\r\n\r\nBenchmarks with issues:\r\n  StringBenchmark.Replace: Core(Runtime=Core)\r\n\r\n\r\nAnd this time there were confilcts with resolving proper dependencies due to different versons:\r\n\r\n// Build Exception: Standard output: \r\n Microsoft (R) Build Engine version 15.9.20+g88f5fadfbe for .NET Core\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n  Restore completed in 45.65 ms for C:\\Dev\\TheCodeManual\\StringPerformance\\StringPerformanceComparisonFull\\bin\\Release\\f30272d9-c3c3-4011-8f75-7264f756e91d\\BenchmarkDotNet.Autogenerated.csproj.\r\nC:\\Program Files\\dotnet\\sdk\\2.2.100\\Microsoft.Common.CurrentVersion.targets(2110,5): warning MSB3277: Found conflicts between different versions of \"System.Collections.Immutable\" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed. [C:\\Dev\\TheCodeManual\\StringPerformance\\StringPerformanceComparisonFull\\bin\\Release\\f30272d9-c3c3-4011-8f75-7264f756e91d\\BenchmarkDotNet.Autogenerated.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\2.2.100\\Microsoft.Common.CurrentVersion.targets(2110,5): warning MSB3277: Found conflicts between different versions of \"System.Reflection.Metadata\" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed. \r\n\r\nDid I do something worng or there is an issue on dotnetbenchmark side?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/993/comments",
    "author": "kmadof",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-12-30T17:08:01Z",
        "body": "Hi @kmadof \r\n\r\n```log\r\nProject StringPerformanceComparison is not compatible with net472 (.NETFramework,Version=v4.7.2). Project StringPerformanceComparison supports: netcoreapp2.2 (.NETCoreApp,Version=v2.2)\r\n```\r\n\r\nTo run projects for .NET and .NET Core the project that defines benchmarks must target both frameworks. In your case it should be:\r\n\r\n```xml\r\n<TargetFrameworks>netcoreapp2.2;net472</TargetFrameworks>\r\n```\r\n\r\nPlease feel free to reopen the issue if it does not help."
      },
      {
        "user": "kmadof",
        "created_at": "2018-12-31T00:19:01Z",
        "body": "Thanks a lot. It helped! "
      }
    ]
  },
  {
    "number": 975,
    "title": "Why can not run a .NET Core benchmark with LINQPad?",
    "created_at": "2018-11-26T12:54:53Z",
    "closed_at": "2018-11-28T09:41:10Z",
    "labels": [
      "question",
      "wontfix"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/975",
    "body": "I'm pretty sure I'm doing something wrong but can't work out what. Using `ClrJob`, the benchmark runs flawlessly. Using `CoreJob`, I get errors like \"Generate Exception: Unable to find LINQPadQuery in {Path}...\"\r\n\r\nI thought it might have been around the .Net SDK version so I downloaded the latest and installed it - still having the exact same error.\r\n\r\nOne thing I will note with my LINQPad configuration is that I created (and gave permission for) the \"BenchmarkDotNet.Artifacts\" folder and files to be written to \"C:\\Program Files (x86)\\LINQPad5\\BenchmarkDotNet.Artifacts\". I tried with various other paths from auto-generated ones to just using the system temp path, they all come back with this issue for `CoreJob`.\r\n\r\nLINQPad: v5.36.03 (Optimisations enabled for build)\r\nBDN: v0.11.3 (default Nuget feed)\r\nCode:\r\n```csharp\r\nvoid Main()\r\n{\r\n\tvar summary = BenchmarkRunner.Run<Md5VsSha256>();\r\n}\r\n\r\n// Define other methods and classes here\r\n[CoreJob]\r\npublic class Md5VsSha256\r\n{\r\n\tprivate SHA256 sha256 = SHA256.Create();\r\n\tprivate MD5 md5 = MD5.Create();\r\n\tprivate byte[] data;\r\n\r\n\t[Params(1000, 10000)]\r\n\tpublic int N;\r\n\r\n\t[GlobalSetup]\r\n\tpublic void Setup()\r\n\t{\r\n\t\tdata = new byte[N];\r\n\t\tnew Random(42).NextBytes(data);\r\n\t}\r\n\r\n\t[Benchmark]\r\n\tpublic byte[] Sha256() => sha256.ComputeHash(data);\r\n\r\n\t[Benchmark]\r\n\tpublic byte[] Md5() => md5.ComputeHash(data);\r\n}\r\n```\r\n\r\nFull Output:\r\n```\r\n// Validating benchmarks:\r\n\r\nAssembly LINQPadQuery, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null is located in temp. If you are running benchmarks from xUnit you need to disable shadow copy. It's not supported by design.\r\n\r\n// ***** BenchmarkRunner: Start   *****\r\n\r\n// ***** Building 1 exe(s) in Parallel: Start   *****\r\n\r\nUnable to find .sln file. Will use current directory C:\\Program Files (x86)\\LINQPad5 to search for project file. If you don't use .sln file on purpose it should not be a problem.\r\n\r\n// ***** Done, took 00:00:00 (0.02 sec)   *****\r\n\r\n// Found benchmarks:\r\n\r\n//   Md5VsSha256.Sha256: Core(Runtime=Core) [N=1000]\r\n\r\n//   Md5VsSha256.Md5: Core(Runtime=Core) [N=1000]\r\n\r\n//   Md5VsSha256.Sha256: Core(Runtime=Core) [N=10000]\r\n\r\n//   Md5VsSha256.Md5: Core(Runtime=Core) [N=10000]\r\n\r\n\r\n// Generate Exception: Unable to find LINQPadQuery in C:\\Program Files (x86)\\LINQPad5 and its subfolders. Most probably the name of output exe is different than the name of the .(c/f)sproj\r\n\r\n\r\n// Generate Exception: Unable to find LINQPadQuery in C:\\Program Files (x86)\\LINQPad5 and its subfolders. Most probably the name of output exe is different than the name of the .(c/f)sproj\r\n\r\n\r\n// Generate Exception: Unable to find LINQPadQuery in C:\\Program Files (x86)\\LINQPad5 and its subfolders. Most probably the name of output exe is different than the name of the .(c/f)sproj\r\n\r\n\r\n// Generate Exception: Unable to find LINQPadQuery in C:\\Program Files (x86)\\LINQPad5 and its subfolders. Most probably the name of output exe is different than the name of the .(c/f)sproj\r\n\r\n\r\n// ***** BenchmarkRunner: Finish  *****\r\n\r\n\r\n// * Export *\r\n\r\n  BenchmarkDotNet.Artifacts\\results\\UserQuery.Md5VsSha256-report.csv\r\n\r\n  BenchmarkDotNet.Artifacts\\results\\UserQuery.Md5VsSha256-report-github.md\r\n\r\n  BenchmarkDotNet.Artifacts\\results\\UserQuery.Md5VsSha256-report.html\r\n\r\n\r\n// * Detailed results *\r\n\r\nMd5VsSha256.Sha256: Core(Runtime=Core) [N=1000]\r\n\r\nRuntime = ; GC = \r\n\r\nThere are not any results runs\r\n\r\n\r\nMd5VsSha256.Md5: Core(Runtime=Core) [N=1000]\r\n\r\nRuntime = ; GC = \r\n\r\nThere are not any results runs\r\n\r\n\r\nMd5VsSha256.Sha256: Core(Runtime=Core) [N=10000]\r\n\r\nRuntime = ; GC = \r\n\r\nThere are not any results runs\r\n\r\n\r\nMd5VsSha256.Md5: Core(Runtime=Core) [N=10000]\r\n\r\nRuntime = ; GC = \r\n\r\nThere are not any results runs\r\n\r\n\r\n// * Summary *\r\n\r\n\r\nBenchmarkDotNet=v0.11.3, OS=Windows 10.0.17134.407 (1803/April2018Update/Redstone4)\r\n\r\nIntel Core i5-6600K CPU 3.50GHz (Skylake), 1 CPU, 4 logical and 4 physical cores\r\n\r\nFrequency=3421874 Hz, Resolution=292.2375 ns, Timer=TSC\r\n\r\n  [Host] : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3221.0\r\n\r\nJob=Core  Runtime=Core  \r\n\r\n Method |     N | Mean | Error |\r\n\r\n------- |------ |-----:|------:|\r\n Sha256 |  1000 |   NA |    NA |\r\n    Md5 |  1000 |   NA |    NA |\r\n Sha256 | 10000 |   NA |    NA |\r\n    Md5 | 10000 |   NA |    NA |\r\n\r\n\r\nBenchmarks with issues:\r\n\r\n  Md5VsSha256.Sha256: Core(Runtime=Core) [N=1000]\r\n\r\n  Md5VsSha256.Md5: Core(Runtime=Core) [N=1000]\r\n\r\n  Md5VsSha256.Sha256: Core(Runtime=Core) [N=10000]\r\n\r\n  Md5VsSha256.Md5: Core(Runtime=Core) [N=10000]\r\n\r\n\r\n// * Legends *\r\n\r\n  N     : Value of the 'N' parameter\r\n\r\n  Mean  : Arithmetic mean of all measurements\r\n\r\n  Error : Half of 99.9% confidence interval\r\n\r\n  1 ns  : 1 Nanosecond (0.000000001 sec)\r\n\r\n\r\n// ***** BenchmarkRunner: End *****\r\n\r\nRun time: 00:00:00 (0.01 sec), executed benchmarks: 0\r\n\r\n\r\n// * Artifacts cleanup *\r\n```\r\n\r\nAnd just as an example, this is a truncated (working) output when running under `ClrJob`:\r\n```\r\n// Validating benchmarks:\r\n\r\nAssembly LINQPadQuery, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null is located in temp. If you are running benchmarks from xUnit you need to disable shadow copy. It's not supported by design.\r\n\r\n// ***** BenchmarkRunner: Start   *****\r\n\r\n// ***** Building 1 exe(s) in Parallel: Start   *****\r\n\r\nBuildScript: C:\\Users\\james.TURNER\\AppData\\Local\\Temp\\LINQPad5\\_scdinnox\\uxlsni\\29d3dd53-bfda-415d-ad0b-89460264f0d1.bat\r\n\r\n// ***** Done, took 00:00:00 (0.07 sec)   *****\r\n\r\n// Found benchmarks:\r\n\r\n//   Md5VsSha256.Sha256: Clr(Runtime=Clr) [N=1000]\r\n\r\n//   Md5VsSha256.Md5: Clr(Runtime=Clr) [N=1000]\r\n\r\n//   Md5VsSha256.Sha256: Clr(Runtime=Clr) [N=10000]\r\n\r\n//   Md5VsSha256.Md5: Clr(Runtime=Clr) [N=10000]\r\n\r\n\r\n// **************************\r\n\r\n// Benchmark: Md5VsSha256.Sha256: Clr(Runtime=Clr) [N=1000]\r\n\r\n// *** Execute ***\r\n\r\n// Launch: 1 / 1\r\n\r\n// Execute: C:\\Users\\james.TURNER\\AppData\\Local\\Temp\\LINQPad5\\_scdinnox\\uxlsni\\29d3dd53-bfda-415d-ad0b-89460264f0d1.exe --benchmarkName \"UserQuery+Md5VsSha256.Sha256(N: 1000)\" --job \"Clr\" --benchmarkId 0\r\n\r\n// BeforeAnythingElse\r\n\r\n\r\n// Benchmark Process Environment Information:\r\n\r\n// Runtime=.NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3221.0\r\n\r\n// GC=Concurrent Workstation\r\n\r\n// Job: Clr(Runtime=Clr)\r\n\r\n\r\nOverheadJitting  1: 1 op, 309771.78 ns, 309.7718 us/op\r\n\r\nWorkloadJitting  1: 1 op, 211579.97 ns, 211.5800 us/op\r\n\r\n\r\nOverheadJitting  2: 16 op, 615160.00 ns, 38.4475 us/op\r\n\r\nWorkloadJitting  2: 16 op, 779689.73 ns, 48.7306 us/op\r\n\r\n\r\nWorkloadPilot    1: 16 op, 156639.32 ns, 9.7900 us/op\r\n\r\nWorkloadPilot    2: 32 op, 308895.07 ns, 9.6530 us/op\r\n\r\n...\r\n\r\n\r\n// * Summary *\r\n\r\n\r\nBenchmarkDotNet=v0.11.3, OS=Windows 10.0.17134.407 (1803/April2018Update/Redstone4)\r\n\r\nIntel Core i5-6600K CPU 3.50GHz (Skylake), 1 CPU, 4 logical and 4 physical cores\r\n\r\nFrequency=3421874 Hz, Resolution=292.2375 ns, Timer=TSC\r\n\r\n  [Host] : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3221.0\r\n  Clr    : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3221.0\r\n\r\nJob=Clr  Runtime=Clr  \r\n\r\n Method |     N |      Mean |     Error |    StdDev |\r\n\r\n------- |------ |----------:|----------:|----------:|\r\n Sha256 |  1000 |  9.652 us | 0.0507 us | 0.0474 us |\r\n    Md5 |  1000 |  3.262 us | 0.0148 us | 0.0139 us |\r\n Sha256 | 10000 | 91.198 us | 0.4853 us | 0.4540 us |\r\n    Md5 | 10000 | 18.259 us | 0.1437 us | 0.1274 us |\r\n\r\n\r\n// * Hints *\r\n\r\nOutliers\r\n\r\n  Md5VsSha256.Md5: Clr -> 1 outlier  was  removed\r\n\r\n\r\n// * Legends *\r\n\r\n  N      : Value of the 'N' parameter\r\n\r\n  Mean   : Arithmetic mean of all measurements\r\n\r\n  Error  : Half of 99.9% confidence interval\r\n\r\n  StdDev : Standard deviation of all measurements\r\n\r\n  1 us   : 1 Microsecond (0.000001 sec)\r\n\r\n\r\n// ***** BenchmarkRunner: End *****\r\n\r\nRun time: 00:01:08 (68.59 sec), executed benchmarks: 4\r\n\r\n\r\n// * Artifacts cleanup *\r\n```\r\n\r\nLet me know if there are any other details you need.",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/975/comments",
    "author": "Turnerj",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-11-28T09:41:10Z",
        "body": "hello @Turnerj \r\n\r\nTo generate a .NET app with benchmarks we need to reference a .NET .dll which defines the benchmarks. This is something provided by LinqPad which is a .NET app itself.\r\n\r\nBut LinqPad does not provide us a .NET Core .dll with benchmarks, so can't build it for .NET Core. This is why it's not a supported scenario. "
      },
      {
        "user": "Turnerj",
        "created_at": "2018-11-29T00:46:24Z",
        "body": "Thanks for the explanation @adamsitnik . Is it worth having something to detect LinqPad and come back with a more specific error in this case? (I only mention this as I believe there is already some specific LinqPad checks BDN is already doing)"
      },
      {
        "user": "adamsitnik",
        "created_at": "2018-11-30T18:36:46Z",
        "body": "> Is it worth having something to detect LinqPad and come back with a more specific error in this case? (I only mention this as I believe there is already some specific LinqPad checks BDN is already doing)\r\n\r\nIt would be great to have it. If you send a PR I can review it and merge it."
      }
    ]
  },
  {
    "number": 918,
    "title": "Create a ParamsSummary column",
    "created_at": "2018-10-19T22:30:57Z",
    "closed_at": "2018-10-19T23:19:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/918",
    "body": "Is this technically doable?\r\n\r\nI need a column that would concatenate all the param names and values from the run.\r\nRight now I need to add as many columns, but I'd like the config to be fixed for any Benchmark I a running.",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/918/comments",
    "author": "sebastienros",
    "comments": [
      {
        "user": "sebastienros",
        "created_at": "2018-10-19T23:19:47Z",
        "body": "I was able to create one like this:\r\n\r\n```csharp\r\nusing BenchmarkDotNet.Columns;\r\nusing BenchmarkDotNet.Reports;\r\nusing BenchmarkDotNet.Running;\r\n\r\nnamespace BenchmarkDotNet.Attributes\r\n{\r\n    public class ParamsSummaryColumn : IColumn\r\n    {\r\n        public string Id => nameof(ParamsSummaryColumn);\r\n        public string ColumnName { get; } = \"Params\";\r\n        public bool IsDefault(Summary summary, Benchmark benchmark) => false;\r\n        public string GetValue(Summary summary, Benchmark benchmark)\r\n        {\r\n            return benchmark.Parameters.DisplayInfo;\r\n        }            \r\n\r\n        public bool IsAvailable(Summary summary) => true;\r\n        public bool AlwaysShow => true;\r\n        public ColumnCategory Category => ColumnCategory.Params;\r\n        public int PriorityInCategory => 0;\r\n        public override string ToString() => ColumnName;\r\n        public bool IsNumeric => false;\r\n        public UnitType UnitType => UnitType.Dimensionless;\r\n        public string GetValue(Summary summary, Benchmark benchmark, ISummaryStyle style) => GetValue(summary, benchmark);\r\n        public string Legend => $\"Summary of all parameter values\";\r\n    }\r\n}\r\n```\r\n\r\nI can create a PR if that makes sense to you ... and maybe it's already in there somewhere ;)"
      },
      {
        "user": "adamsitnik",
        "created_at": "2018-10-20T14:15:35Z",
        "body": "Hello @sebastienros\r\n\r\nBy default, BDN should display a column in summary for every argument/param you are using.\r\n\r\n Is it doing that, but you don't want to have many columns, just a single one with everything?"
      }
    ]
  },
  {
    "number": 884,
    "title": "System.InvalidOperationException Benchmark takes to long to run",
    "created_at": "2018-09-26T08:18:03Z",
    "closed_at": "2018-09-28T11:26:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/884",
    "body": "Hi I have a Benchmark console app deployed using the self contained option of .net core. and Inprocess ToolChain.\r\nThis is the config of my benchmark\r\n```\r\npublic MainConfig() : ManualConfig\r\n{ \r\n    Add(Job.InProcess\r\n           .With(InprocessToolChain.Instance)\r\n           .With(Platform.X64)\r\n           .WithUnrollFactor(2)\r\n           .WithTargetCount(4)\r\n           .WithId(\"InProcess\"));\r\n\r\n   Add(new ConsoleLogger);\r\n}\r\n```\r\nwhen I execute the Benchmark in a machine with the following configuration:\r\n\r\n- Windows NT Version 6.2 Server Edition (Windows Server 2012 R2)\r\n- AMD Athlon 64 X2 Dual Core Processor 4200 2.2 GHz\r\n- RAM 4GB\r\n- dotnet not installed \r\n-  60% of free ram before running the app \r\n\r\n I get the following error: \r\n\r\n> executiong fail with a System.InvalidOperationException Benchmark takes to long to run. Prefer to use out-of-process toolchains for long-runing benchmarks.\r\n\r\nI try the benchmark in other machine that have the dotnet installed and worked fine with a mean execution time of 4 seconds.\r\n\r\nAny Ideas would be appreciated.",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/884/comments",
    "author": "germandb",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-09-28T11:25:46Z",
        "body": "Hi @germandb \r\n\r\nYou are hitting the default timeout. The solution is to create your own instance of  `InprocessToolChain`.\r\n\r\nAn example: `.With(new InprocessToolChain(TimeSpan.FromMinutes(5), BenchmarkActionCodegen.ReflectionEmit, true)` instead of `.With(InprocessToolChain.Instance)`\r\n\r\n\r\n"
      }
    ]
  },
  {
    "number": 883,
    "title": "Console app Benchmark self-contained and configure inprocess faile because dotnet cli toolchain is not installed",
    "created_at": "2018-09-25T08:13:44Z",
    "closed_at": "2018-09-25T10:35:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/883",
    "body": "Hi, I have a Benchmark console app that need to run in diferent machines, that machines could or could not have the .net core installed so I publish the console app using the self-contained configuration.\r\nI read that you use the dotnet cli to build the app and try to run it, but also that the inprocess toolchain configuration omit that step. So I try to config my benchmark to use inprocess my code is like this:\r\n\r\n```\r\npublic MainConfig() : ManualConfig\r\n{ \r\n    Add(Job.InProcess\r\n           .With(InprocessToolChain.Instance)\r\n           .With(Platform.X64)\r\n           .With(CsProjCoreToolchain.NetCoreApp21)\r\n           .WithTargetCount(4)\r\n           .WithId(\"InProcess\"));\r\n\r\n   Add(new ConsoleLogger);\r\n}\r\n```\r\n\r\nWhen I try to run the benchmark in a machine without dotnet I get the following error:\r\nBenchmarkDotNet requires dotnet cli toolchain to be installed, benchmark 'BenchmarkBI.'Get all rows from table test.': InProcess(Platform=X64, Toolchain=.NET Core 2.1, IterationCount=4)' will not be executed\r\n\r\n\r\nAny Idea if I need to change anything in the config?\r\n\r\n\r\n\r\n\r\n ",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/883/comments",
    "author": "germandb",
    "comments": [
      {
        "user": "AndreyAkinshin",
        "created_at": "2018-09-25T08:20:41Z",
        "body": "@germandb, try to remove `.With(CsProjCoreToolchain.NetCoreApp21)` from your config (if you want to run the benchmark *in process*, you can't configure the version of .NET Core). It's impossible to use two different toolchains at the same time."
      },
      {
        "user": "germandb",
        "created_at": "2018-09-25T10:23:06Z",
        "body": "Hi Andrey thanks for the quick response. That did the trick to solve that exception.\r\nBut now the executiong fail with a System.InvalidOperationException Benchmark takes to long to run. Prefer to use out-of-process toolchains for long-runing benchmarks.\r\n\r\nI try the benchmark in other machine that have the dotnet installed and worked fine the method have a mean execution time of 4 seconds."
      }
    ]
  },
  {
    "number": 861,
    "title": "How to benchmark against few different .NET frameworks",
    "created_at": "2018-08-24T18:31:08Z",
    "closed_at": "2018-08-27T18:49:29Z",
    "labels": [
      "question",
      "Area:Toolchains"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/861",
    "body": "I just started using BenchmarkDotNet from a .NET Core 2.1 console app. The benchmarks work great for .NET Core, but I also have it set to benchmark .NET Framework, but I am getting this error:\r\n\r\n// Build Exception:   Restoring packages for S:\\src\\git\\dotnetTips\\dotNetTips.CodePerf.Example.App\\PerfBin\\netcoreapp2.1\\fde8c2e5-2096-446b-aae9-96dc703f5245\\BenchmarkDotNet.Autogenerated.csproj...\r\nS:\\src\\git\\dotnetTips\\dotNetTips.CodePerf.Example.App\\PerfBin\\netcoreapp2.1\\fde8c2e5-2096-446b-aae9-96dc703f5245\\BenchmarkDotNet.Autogenerated.csproj : error NU1201: Project dotNetTips.CodePerf.Example.App is not compatible with net472 (.NETFramework,Version=v4.7.2). Project dotNetTips.CodePerf.Example.App supports: netcoreapp2.1 (.NETCoreApp,Version=v2.1)\r\nS:\\src\\git\\dotnetTips\\dotNetTips.CodePerf.Example.App\\PerfBin\\netcoreapp2.1\\fde8c2e5-2096-446b-aae9-96dc703f5245\\BenchmarkDotNet.Autogenerated.csproj : error NU1201: Project dotNetTips.CodePerf.Example.App is not compatible with net472 (.NETFramework,Version=v4.7.2) / win7-x64. Project dotNetTips.CodePerf.Example.App supports: netcoreapp2.1 (.NETCoreApp,Version=v2.1)\r\n  Generating MSBuild file S:\\src\\git\\dotnetTips\\dotNetTips.CodePerf.Example.App\\PerfBin\\netcoreapp2.1\\fde8c2e5-2096-446b-aae9-96dc703f5245\\obj\\BenchmarkDotNet.Autogenerated.csproj.nuget.g.props.\r\n  Generating MSBuild file S:\\src\\git\\dotnetTips\\dotNetTips.CodePerf.Example.App\\PerfBin\\netcoreapp2.1\\fde8c2e5-2096-446b-aae9-96dc703f5245\\obj\\BenchmarkDotNet.Autogenerated.csproj.nuget.g.targets.\r\n  Restore failed in 168.46 ms for S:\\src\\git\\dotnetTips\\dotNetTips.CodePerf.Example.App\\PerfBin\\netcoreapp2.1\\fde8c2e5-2096-446b-aae9-96dc703f5245\\BenchmarkDotNet.Autogenerated.csproj.\r\n\r\nI'm not sure how to fix this?\r\nThanks,\r\nDavid McCarter",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/861/comments",
    "author": "RealDotNetDave",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-08-24T18:34:31Z",
        "body": "Hi @RealDotNetDave \r\n\r\n> Project dotNetTips.CodePerf.Example.App is not compatible with net472 (.NETFramework,Version=v4.7.2). Project dotNetTips.CodePerf.Example.App supports: netcoreapp2.1 (.NETCoreApp,Version=v2.1)\r\n\r\nYour benchmark project needs to target .NET 4.7.2 as well. Your `.csproj` should look like:\r\n\r\n`<TargetFrameworks>ne472;netcoreapp2.1</TargetFrameworks>`"
      },
      {
        "user": "adamsitnik",
        "created_at": "2018-08-27T18:49:29Z",
        "body": "@RealDotNetDave I am closing, if my answer did not solve the issue please feel free to reopen."
      },
      {
        "user": "RealDotNetDave",
        "created_at": "2018-09-04T20:40:37Z",
        "body": "I changed my csproj to:\r\n\r\n<TargetFramework>netcoreapp2.1;net472</TargetFramework>\r\n\r\nBut keep getting this new build error:\r\n \"ResolvePackageAssets\" task failed unexpectedly.\r\nNuGet.Frameworks.FrameworkException: Invalid framework identifier ''.\r\n\r\nAny ideas?\r\nDavid"
      },
      {
        "user": "RealDotNetDave",
        "created_at": "2018-09-04T20:53:33Z",
        "body": "Never mind. I figured it out. Thanks."
      },
      {
        "user": "phonglt7",
        "created_at": "2019-02-14T16:05:22Z",
        "body": "> Never mind. I figured it out. Thanks.\r\n\r\nHi, do you mind sharing how you figured it out? The \"Invalid framework identifier '' \" issue,"
      },
      {
        "user": "adamsitnik",
        "created_at": "2019-02-15T05:33:55Z",
        "body": "> The \"Invalid framework identifier '' \" issue,\r\n\r\n@phonglt7  I have seen this issue once or twice, but only when building the project in VS. Did you try to run `dotnet restore` and `dotnet build -c Release` from the console?"
      }
    ]
  },
  {
    "number": 841,
    "title": "parse error in the follow ",
    "created_at": "2018-07-24T09:24:33Z",
    "closed_at": "2018-07-24T09:58:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/841",
    "body": "I want to use BenchmarkDotNet to known the difference between Enum Attribute and property\r\nso I use this test \r\n```C#\r\nnamespace EnumAndProperty\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            BenchmarkRunner.Run<GetTextClass>();\r\n           \r\n            Console.ReadLine();\r\n        }\r\n\r\n    }\r\n    public class GetTextClass\r\n    {\r\n        [Benchmark]\r\n        public void GetTextByAttribute()\r\n        {\r\n            for (int i = 0; i < 10; i++)\r\n            {\r\n                Console.WriteLine(MetaEnum.TestEnum.Default.GetDescription() + i);\r\n            }\r\n        }\r\n        [Benchmark]\r\n        public void GetTextByProperty()\r\n        {\r\n            for (int i = 0; i < 10; i++)\r\n            {\r\n                Console.WriteLine(MetaEnum.Test + i);\r\n            }\r\n        }\r\n    }\r\n    public class MetaEnum\r\n    {\r\n        public enum TestEnum\r\n        {\r\n            /// <summary>\r\n            /// 默认\r\n            /// <remarks>值为1</remarks>\r\n            /// </summary>\r\n            [Description(\"默认\")]\r\n            Default = 1,\r\n        }\r\n        public const string Test = \"测试\";\r\n    }\r\n    public static class EnumHelper\r\n    {\r\n        /// <summary>\r\n        /// 获得枚举设定的值\r\n        /// </summary>\r\n        /// <typeparam name=\"T\">枚举值的类型，一般为<see cref=\"Int32\"/></typeparam>\r\n        /// <param name=\"enumValue\"></param>\r\n        /// <returns>枚举对应的值</returns>\r\n        public static T GetValue<T>(this Enum enumValue)\r\n        {\r\n            return (T)Convert.ChangeType(enumValue, enumValue.GetTypeCode());\r\n        }\r\n\r\n        /// <summary>\r\n        /// 获取特性 (DescriptionAttribute) 的说明；如果未使用该特性，则返回枚举的名称。\r\n        /// </summary>\r\n        /// <param name=\"enumValue\"></param>\r\n        /// <returns></returns>\r\n        public static string GetDescription(this Enum enumValue)\r\n        {\r\n            FieldInfo fieldInfo = enumValue.GetType().GetField(enumValue.ToString());\r\n            DescriptionAttribute[] attrs =\r\n                fieldInfo.GetCustomAttributes(typeof(DescriptionAttribute), false) as DescriptionAttribute[];\r\n\r\n            return attrs.Length > 0 ? attrs[0].Description : enumValue.ToString();\r\n        }\r\n\r\n\r\n    }\r\n}\r\n```\r\nand i always get the error\r\n**parse error in the follow line**\r\nmy BenchmarkDotNet version is 0.11.0.0\r\nI use visual studio 2017 and .NET 4.6.1 in windows 10 pro 1803\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/841/comments",
    "author": "wangshuai-007",
    "comments": [
      {
        "user": "AndreyAkinshin",
        "created_at": "2018-07-24T09:32:58Z",
        "body": "@w371987114, you benchmark can't use `Console.WriteLine` calls because BenchmarkDotNet uses it for communication between the host process and the benchmark runner process. Why do you need it?"
      },
      {
        "user": "wangshuai-007",
        "created_at": "2018-07-24T09:53:57Z",
        "body": "@AndreyAkinshin \r\nI want to know the progress of the test, by the way, I can accept my return value.\r\nI just removed the `Console.WriteLine`  It works fine now, thank you for your answer."
      },
      {
        "user": "AndreyAkinshin",
        "created_at": "2018-07-24T09:58:58Z",
        "body": "BenchmarkDotNet prints progress messages automatically."
      }
    ]
  },
  {
    "number": 812,
    "title": "When will the next release be available on NuGet?",
    "created_at": "2018-06-30T18:22:51Z",
    "closed_at": "2018-07-23T09:36:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/812",
    "body": "Current version of BenchmarkDotNet on NuGet is 0.10.14 which was released in April. This is an issue because I want to benchmark code that uses types introduced in Framework 4.7.2 (`Span<T>` and `MemoryMarshal` to be precise), and 0.10.14 doesn't support 4.7.2. There isn't a prerelease package either. :(\r\n\r\nIs there any intention to release an updated version anytime soon?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/812/comments",
    "author": "IanKemp",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-07-03T12:07:05Z",
        "body": "> This is an issue because I want to benchmark code that uses types introduced in Framework 4.7.2 (Span<T> and MemoryMarshal to be precise), and 0.10.14 doesn't support 4.7.2.\r\n\r\nWhat do you mean by that? 0.10.14 targets .NET 4.6 which can be installed and consumed by .NET 4.7.2 app.\r\n\r\n> Is there any intention to release an updated version anytime soon?\r\n\r\n1-2 weeks"
      }
    ]
  },
  {
    "number": 807,
    "title": "How to use [GenericTypeArguments]",
    "created_at": "2018-06-28T02:22:45Z",
    "closed_at": "2018-07-09T10:22:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/807",
    "body": "Hi everyone,\r\n\r\nI have encountered a strange bug (`BenchmarkDotNet=v0.10.14.660-nightly`).\r\n\r\nIf I have the following:\r\n\r\n```csharp\r\n/// <typeparam name=\"C\">Ciphertext type</typeparam>\r\n/// <typeparam name=\"K\">Key type</typeparam>\r\n[MemoryDiagnoser]\r\n[JsonExporterAttribute.Full]\r\n[Orderer(SummaryOrderPolicy.FastestToSlowest)]\r\n[RankColumn]\r\npublic class Benchmark<C, K>\r\n\twhere C : IGetSize\r\n\twhere K : IGetSize\r\n{\r\n\t// some code here\r\n}\r\n```\r\n\r\nattribute are not working.\r\nAllocated column does not show up, no JSON file gets produced, columns are not ordered.\r\n\r\nHowever, if I supply these the other way\r\n\r\n```csharp\r\nprivate class CustomConfig : ManualConfig\r\n{\r\n\tpublic CustomConfig()\r\n\t{\r\n\t\tAdd(MemoryDiagnoser.Default);\r\n\t\tAdd(JsonExporter.Full);\r\n\t\tAdd(DefaultConfig.Instance.GetLoggers().ToArray()); // manual config has no loggers by default\r\n\t\tAdd(DefaultConfig.Instance.GetExporters().ToArray()); // manual config has no exporters by default\r\n\t\tAdd(DefaultConfig.Instance.GetColumnProviders().ToArray()); // manual config has no columns by default\r\n\t}\r\n}\r\n```\r\n\r\neverything works just fine.\r\n\r\nP.S. That also applies to \"GenericType\" attribute.\r\nI have to use \r\n\r\n```csharp\r\nBenchmarkSwitcher.FromTypes(\r\n\tnew[] {\r\n\t\ttypeof(Schemes.Benchmark<OPECipher, BytesKey>),\r\n\t\ttypeof(Schemes.Benchmark<ORESchemes.SchemOne.Ciphertext, BytesKey>),\r\n\t\ttypeof(Schemes.Benchmark<ORESchemes.SchemeTwo.Ciphertext, ORESchemes.SchemeTwo.Key>),\r\n\t\ttypeof(Schemes.Benchmark<ORESchemes.SchemeThree.Ciphertext, ORESchemes.SchemeThree.State>),\r\n\t\ttypeof(Primitives.Benchmark)\r\n\t}\r\n).Run(new[] { $\"--namespace=Benchmark.{@namespace}\", \"--join\" }, new CustomConfig());\r\n```",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/807/comments",
    "author": "dbogatov",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-06-28T10:55:22Z",
        "body": "@Rizzen could you take a look into this issue?"
      },
      {
        "user": "Rizzen",
        "created_at": "2018-06-28T13:59:58Z",
        "body": "Ok, I'll take a look today."
      },
      {
        "user": "Rizzen",
        "created_at": "2018-06-28T20:28:55Z",
        "body": "@dbogatov Thank you for report!\r\nSo, I made some workaround and doesn't have repro. Here is my workaround:\r\n``` C#\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        BenchmarkSwitcher.FromTypes(new Type[] { typeof(BenchmarkGeneric<,>) }).Run();\r\n    }\r\n}\r\n\r\n[MemoryDiagnoser]\r\n[JsonExporterAttribute.Full]\r\n[Orderer(SummaryOrderPolicy.FastestToSlowest)]\r\n[RankColumn]\r\n[GenericTypeArguments(typeof(SizeTypeOne), typeof(SizeTypeTwo))]\r\npublic class BenchmarkGeneric<C, K>\r\n        where C : IGetSize\r\n        where K : IGetSize\r\n{\r\n    [Benchmark] public C CreateC() => Activator.CreateInstance<C>();\r\n\r\n    [Benchmark] public K CreateK() => Activator.CreateInstance<K>();\r\n}\r\n\r\npublic interface IGetSize\r\n{\r\n        \r\n}\r\n\r\npublic class SizeTypeOne : IGetSize {}\r\npublic class SizeTypeTwo : IGetSize {}\r\n```\r\nIt works fine as far I see.\r\nDid you use GenericTypeArguments Attribute? Could you provide more detailed repro?\r\n\r\n@adamsitnik @AndreyAkinshin Also I see that there is no Intro for GenericTypeArguments after refactoring. So I think that is makes sense to add it. What do you think?"
      },
      {
        "user": "adamsitnik",
        "created_at": "2018-06-28T20:33:12Z",
        "body": "> So I think that is makes sense to add it. What do you think\r\n\r\nGreat idea!"
      },
      {
        "user": "Rizzen",
        "created_at": "2018-06-28T20:42:59Z",
        "body": "Aww, sorry, it exists in IntroGenericTypeArguments.cs"
      },
      {
        "user": "dbogatov",
        "created_at": "2018-06-28T20:44:50Z",
        "body": "It does, but could you also mention it in docs?\r\n\r\nI will try to come up with MWE for the issue.\r\nThank you for prompt replies!\r\n\r\nAlso, am I right that this feature is not in release yet?\r\nI am using nightly build."
      },
      {
        "user": "Rizzen",
        "created_at": "2018-06-28T20:48:21Z",
        "body": "I guess it's coming in 0.11.0, docs for it is not released yet, also all docs for BDN is under refactoring by @AndreyAkinshin , so for now I don't know how to document it."
      },
      {
        "user": "dbogatov",
        "created_at": "2018-06-28T20:49:14Z",
        "body": "At least it will appear in release docs.\r\nThat it good enough for me."
      },
      {
        "user": "adamsitnik",
        "created_at": "2018-07-09T10:22:38Z",
        "body": "@Rizzen was unable to reproduce, @dbogatov did not provide repro for 11 days so I am closing"
      },
      {
        "user": "dbogatov",
        "created_at": "2018-07-09T10:29:49Z",
        "body": "My bad, I am on a conference now. \r\nLet me reopen the issue when (and if) repro is ready. "
      }
    ]
  },
  {
    "number": 804,
    "title": "What is the point of BuildScriptFilePath ?",
    "created_at": "2018-06-25T05:23:10Z",
    "closed_at": "2018-06-25T10:04:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/804",
    "body": "I'm in the process of attempting to implement #290 and noticed that the Generators create a `.bat` build script which seems quite handy, but then the Builders don't actually use the build script generated.\r\n\r\nFor example the `DotNetCliBuilder` runs it's own `restore` and `build` commands and doesn't use the generated build script to do the building.  The Roslyn Builder outputs a log entry for the `BuildScriptFilePath` but then doesn't use it at all.\r\n\r\nThis might be intentional, so sorry if I'm being naive (the solution is quite a learning curve :) \r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/804/comments",
    "author": "Shazwazza",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-06-25T10:04:17Z",
        "body": "Hi @Shazwazza \r\n\r\nIt's a very good question!\r\n\r\nBDN used to generate **and run** this script. At some point of time, we moved from doing this to calling Roslyn API directly. The script was preserved for situations when we fail to build the benchmark project, apply `[KeepBenchmarkFiles]` attribute and run it manually to reproduce the problem. So we keep it only for eventual troubleshooting.\r\n\r\nYou can ignore it if you are developing a custom toolchain."
      },
      {
        "user": "Shazwazza",
        "created_at": "2018-06-25T11:07:32Z",
        "body": "Ah, ok thanks :) I might add some code docs to those classes in my PR. "
      }
    ]
  },
  {
    "number": 775,
    "title": "Few questions related to understanding of results",
    "created_at": "2018-06-04T20:05:03Z",
    "closed_at": "2018-06-04T22:01:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/775",
    "body": "### 1. What is a difference between DryCore and Core?\r\nResult in Core:   0.2182 ns\r\nResult in DryCore: 647,800.0000 ns\r\n\r\n### 2. What is the meaning of histograms?\r\n\r\n[-0.002 ns ; 0.074 ns) | @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n[ 0.074 ns ; 0.178 ns) | @@@@@@@@@@@@@@@@@@\r\n[ 0.178 ns ; 0.280 ns) | @@@@@@@@\r\n[ 0.280 ns ; 0.355 ns) | @@@@@@@@@@@@@@@@@\r\n[ 0.355 ns ; 0.444 ns) | @@@@@@@@\r\n[ 0.444 ns ; 0.528 ns) | @@@\r\n[ 0.528 ns ; 0.604 ns) | @@@@@\r\n[ 0.604 ns ; 0.651 ns) |\r\n[ 0.651 ns ; 0.727 ns) | @@\r\n[ 0.727 ns ; 0.797 ns) |\r\n[ 0.797 ns ; 0.873 ns) | @\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/775/comments",
    "author": "ddobric",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-06-04T22:01:40Z",
        "body": "Hi @ddobric \r\n\r\n1. `DryJob` runs the benchmark exactly once, without any warmup. You can use it to measure the JIT overhead or to test your benchmark if it works\r\n\r\n2. Each `@` represents a single iteration\r\n`[ 0.444 ns ; 0.528 ns) | @@@` - means that there were 3 iterations for which the average time of benchmark execution was between 0.444 ns to 0.528 ns"
      },
      {
        "user": "ddobric",
        "created_at": "2018-06-06T11:15:35Z",
        "body": "thanks"
      }
    ]
  },
  {
    "number": 768,
    "title": "Why installing BenchmarkDotNet adds so many packages to packages.config file?",
    "created_at": "2018-05-29T11:53:47Z",
    "closed_at": "2018-05-29T12:13:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/768",
    "body": "Installing BenchmarkDotNet nuget packages adds lots (48) of \"framework\" packages like `System.Collections`, `System.Linq` etc.\r\n\r\n````\r\n<package id=\"Microsoft.CodeAnalysis.Analyzers\" version=\"1.1.0\" targetFramework=\"net47\" />\r\n<package id=\"Microsoft.CodeAnalysis.Common\" version=\"2.6.1\" targetFramework=\"net47\" />\r\n<package id=\"Microsoft.CodeAnalysis.CSharp\" version=\"2.6.1\" targetFramework=\"net47\" />\r\n<package id=\"Microsoft.DotNet.InternalAbstractions\" version=\"1.0.0\" targetFramework=\"net47\" />\r\n<package id=\"Microsoft.DotNet.PlatformAbstractions\" version=\"1.1.1\" targetFramework=\"net47\" />\r\n<package id=\"Microsoft.Win32.Registry\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.AppContext\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Collections\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Collections.Concurrent\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Collections.Immutable\" version=\"1.3.1\" targetFramework=\"net47\" />\r\n<package id=\"System.Console\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Diagnostics.Debug\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Diagnostics.FileVersionInfo\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Diagnostics.StackTrace\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Diagnostics.Tools\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Dynamic.Runtime\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Globalization\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.IO\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.IO.Compression\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.IO.FileSystem\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.IO.FileSystem.Primitives\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Linq\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Linq.Expressions\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Reflection\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Reflection.Metadata\" version=\"1.4.2\" targetFramework=\"net47\" />\r\n<package id=\"System.Resources.ResourceManager\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Runtime\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Runtime.Extensions\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Runtime.InteropServices\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Runtime.Numerics\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Security.Cryptography.Algorithms\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Security.Cryptography.Encoding\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Security.Cryptography.Primitives\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Security.Cryptography.X509Certificates\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Text.Encoding\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Text.Encoding.CodePages\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Text.Encoding.Extensions\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Threading\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Threading.Tasks\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Threading.Tasks.Extensions\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Threading.Tasks.Parallel\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Threading.Thread\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.ValueTuple\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Xml.ReaderWriter\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Xml.XDocument\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Xml.XmlDocument\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Xml.XmlSerializer\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Xml.XPath\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n<package id=\"System.Xml.XPath.XDocument\" version=\"4.3.0\" targetFramework=\"net47\" />\r\n````\r\n\r\nThese should not be needed, especially on net46 target.",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/768/comments",
    "author": "wojciechrak",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-05-29T12:13:13Z",
        "body": "Hi Wojciech\r\n\r\nThis is how the tooling that you are using (NuGet client) works. We just list our dependencies as:\r\n\r\n```xml\r\n    <PackageReference Include=\"Microsoft.DotNet.InternalAbstractions\" Version=\"1.0.0\" />\r\n    <PackageReference Include=\"Microsoft.DotNet.PlatformAbstractions\" Version=\"1.1.1\" />\r\n    <PackageReference Include=\"Microsoft.Win32.Registry\" Version=\"4.5.0-preview1-26216-02\" />\r\n    <PackageReference Include=\"System.Management\" Version=\"4.5.0-preview1-26216-02\" />\r\n    <PackageReference Include=\"System.ValueTuple\" Version=\"4.3.0\" />\r\n    <PackageReference Include=\"System.Xml.XmlSerializer\" Version=\"4.3.0\" />\r\n    <PackageReference Include=\"System.Diagnostics.FileVersionInfo\" Version=\"4.3.0\" />\r\n    <PackageReference Include=\"System.Runtime.Serialization.Primitives\" Version=\"4.3.0\" />\r\n    <PackageReference Include=\"System.Xml.XPath.XmlDocument\" Version=\"4.3.0\" />\r\n    <PackageReference Include=\"System.Reflection.Emit.Lightweight\" Version=\"4.3.0\" />\r\n    <PackageReference Include=\"System.Threading.Tasks.Extensions\" Version=\"4.3.0\" />\r\n    <PackageReference Include=\"Microsoft.CodeAnalysis.CSharp\" Version=\"2.6.1\" />\r\n    <PackageReference Include=\"System.Collections.Immutable\" Version=\"1.4.0\" />\r\n    <PackageReference Include=\"System.Reflection.Metadata\" Version=\"1.5.0\" />\r\n```\r\n\r\nwhich gets resolved to the list that you have uploaded.\r\n\r\nIf you believe that it can be avoided please provide a PR."
      },
      {
        "user": "wojciechrak",
        "created_at": "2018-05-29T12:41:20Z",
        "body": "I'd say that most of these are required only for netstandard/netcore target. I'll try to work on a PR."
      }
    ]
  },
  {
    "number": 759,
    "title": "Using BenchmarkDotNet with Unity",
    "created_at": "2018-05-22T09:25:15Z",
    "closed_at": "2018-05-27T19:32:59Z",
    "labels": [
      "question",
      "Area:Toolchains",
      "help wanted"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/759",
    "body": "Hello! \r\nI'm working with a semester project at my university where i would like to benchmark some of my code. \r\n\r\nI have an issue with using BenchmarkDotNet with VS2017 code which i have created through Unity. \r\nIve been trying to find several guides and other stuff which did not help me. first of I've changed the Scripting Runtime Version to .NET 4.x Equivelant and the API Compatibility Level to .NET 4.x in Unity. \r\n\r\nNext up i tried changing the Target Framework in Visual Studio to .NET Framework 4.6 since it would seem that is what i needed to do since that is what is said on the NuGet Website. \r\nWhen i try to install the BenchmarkDotNet from the NuGet Manager in VS i get the error: \r\n\r\n\"Could not install package 'BenchmarkDotNet 0.10.14'. You are trying to install this package into a project that targets '.NETFramework,Version=v4.6', but the package does not contain any assembly references or content files that are compatible with that framework. For more information, contact the package author.\"\r\n\r\nI've tried to install the BenchmarkDotNet.Core and BenchmarkDotNet.Toolchains.Roslyn without any problems to my knowledge. \r\n\r\nThis is about as far as I've gotten and i dont know what to do about it. Maybe I'm missing something obvious but I'm completely new to the .NET scene and i dont know what to do!\r\n\r\nHave a nice day! \r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/759/comments",
    "author": "AndreasObel",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-05-23T14:48:27Z",
        "body": "Hi @AndreasObel \r\n\r\nI don't have Unity installed now, but perhaps @xoofx has some experience with using BenchmarkDotNet, Unity and Visual Studio all together?"
      },
      {
        "user": "xoofx",
        "created_at": "2018-05-23T20:18:25Z",
        "body": "@AndreasObel the projects generated by the Unity editor are not standard .NET projects so they are likely not playing nicely with NuGet, which is a bit unfortunate I agree...\r\n\r\nI checked and you can maybe workaround this by editing csproj manually before trying to install a NuGet package, and then edit back the project once it is installed... but as you will see, that's not something I would try to do...\r\n\r\nYou need to comment the lines in your csproj\r\n\r\n```xml\r\n    <!-- <NoConfig>true</NoConfig>\r\n    <NoStdLib>true</NoStdLib> -->\r\n```\r\n\r\nand all the System/Netstandard assemblies :\r\n\r\n```xml\r\n!--  \r\n <Reference Include=\"netstandard\">\r\n <HintPath>C:/Work/unity/build/WindowsEditor/Data/NetStandard/ref/2.0.0/netstandard.dll</HintPath>\r\n </Reference>\r\n <Reference Include=\"Microsoft.Win32.Primitives\">\r\n <HintPath>C:/Work/unity/build/WindowsEditor/Data/NetStandard/compat/2.0.0/shims/netstandard/Microsoft.Win32.Primitives.dll</HintPath>\r\n </Reference>\r\n....\r\n <Reference Include=\"System.Xml.Serialization\">\r\n <HintPath>C:/Work/unity/build/WindowsEditor/Data/NetStandard/compat/2.0.0/shims/netfx/System.Xml.Serialization.dll</HintPath>\r\n </Reference> -->\r\n```\r\n\r\nThen you should be able to install a NuGet package.\r\n\r\nThe problem is that it will install also a bunch `System.*` package reference that you will have to remove by hand into your project, then uncomment what was commented before.... and it should compile.\r\n\r\nBut not sure BenchmarkDotNet will work anyway in the end. You need to have a console program for this (and then, why bother using a Unity project to create it, as it is actually not really supported)\r\n\r\nBottom line is that you can only use BenchmarkDotNet with regular .NET code. If you try to use some Unity code, it will likely fail at some point on Unity API (the UnityEngine DLL requiring a custom Unity .NET runtime)\r\n\r\nBut if it is to benchmark some .NET code, then you can setup a regular C# project from VS that collect the same files used by your Unity csproj project and test this more easily from there..."
      },
      {
        "user": "adamsitnik",
        "created_at": "2018-05-27T19:32:59Z",
        "body": "@xoofx big thanks for help!\r\n\r\n@AndreasObel I am afraid that benchmarking Unity is not supported as of today.\r\n\r\n@xoofx if you are ever interested in adding such support please let me know. It should not be hard to implement"
      },
      {
        "user": "DeathArrow01",
        "created_at": "2018-11-03T19:14:17Z",
        "body": "@xoofx would it be possible to use UnityEngine.dll in a .net project? I don't need to benchmark Unity methods but I need Unity data types like Transform. "
      },
      {
        "user": "xoofx",
        "created_at": "2018-11-03T21:25:34Z",
        "body": "> @xoofx would it be possible to use UnityEngine.dll in a .net project? I don't need to benchmark Unity methods but I need Unity data types like Transform.\r\n\r\n@DeathArrow01 you can, but if you start to use some methods on Unity objects, you can quickly hit an internal call that would not run on a .NET standard runtime (even from static initializers, so it can be impossible in that case)"
      },
      {
        "user": "DeathArrow01",
        "created_at": "2018-11-05T08:10:19Z",
        "body": "@xoofx thank you!\r\nIt seems it's not a trivial task to use BenchmarkDotNet with Unity scripts. It will require either modifying Unity engine code, which I doubt someone from Unity will have time, either modifying BenchmarkDotNet, so it can be imported into Unity project and call Unity methods on Unity's Main Thread. "
      },
      {
        "user": "hiradyazdan",
        "created_at": "2019-07-06T22:03:20Z",
        "body": "@xoofx is it possible to use a unity class library which only references `UnityEngine.dll` and `UnityEngine.UI.dll`, only the mode is set to a different profile than release (not debug, but a custom one with optimize tag to true)? \r\n\r\nThe methods under performance test are not unity related at all, the only reason for having a unity class library is only that I can have an output to use for benchmark.\r\n\r\nIt looks like the build compiles fine with BenchmarkDotNet, but when running with ClrJob I still get these errors:\r\n\r\n```shell\r\nAssembly myproject.Benchmark.Unity which defines benchmarks references non-optimized UnityEngine\r\n        If you own this dependency, please, build it in RELEASE.\r\n        If you don't, you can disable this policy by using 'config.With(ConfigOptions.DisableOptimizationsValidator)'.\r\n```\r\n\r\n```shell\r\nAssembly myproject.Benchmark.Unity which defines benchmarks references non-optimized UnityEngine.UI\r\n        If you own this dependency, please, build it in RELEASE.\r\n        If you don't, you can disable this policy by using 'config.With(ConfigOptions.DisableOptimizationsValidator)'.\r\n```"
      }
    ]
  },
  {
    "number": 708,
    "title": "Error of DisassemblyDiagnoser(printAsm: true, printSource: true) in MultiTarget project",
    "created_at": "2018-03-31T21:56:58Z",
    "closed_at": "2018-04-03T13:58:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/708",
    "body": "I have a multitarget project with windows diagnoser enabler for NET47:\r\n\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFrameworks>netcoreapp2.0;net47</TargetFrameworks>\r\n\t<LangVersion>latest</LangVersion>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include=\"BenchmarkDotNet\" Version=\"0.10.13\" />\r\n    \r\n    <PackageReference Include=\"DynamicExpresso.Core\" Version=\"2.0.0\" />\r\n    <PackageReference Include=\"Newtonsoft.Json\" Version=\"11.0.2\" />\r\n  </ItemGroup>\r\n  \r\n    <ItemGroup Condition=\"'$(TargetFramework)' == 'net47'\">\r\n\t\t<PackageReference Include=\"BenchmarkDotNet.Diagnostics.Windows\" Version=\"0.10.13\" />\r\n\t</ItemGroup>\r\n\r\n  <ItemGroup>\r\n    <ProjectReference Include=\"..\\..\\Routines\\Routines.csproj\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nDisassembler configuration enabled on conditional compiling:\r\n\r\n```\r\n#if !NETCOREAPP2_0\r\n    [DisassemblyDiagnoser(printAsm: true, printSource: true)]\r\n#endif\r\n    public class BenchmarkConverAll\r\n    { \r\n\r\n```\r\nInlining diagnoser enabled that way works, when dissasembly diagnoser returns an error:\r\n\r\nTest executed as \r\n& dotnet run -c Release -f net47 -p \"$BenchmarkProjectPath\"\r\n\r\n\r\n```\r\nPS D:\\cot\\DashboardCode\\Routines> D:\\cot\\DashboardCode\\Routines\\BenchmarkWindows.ps1\r\nMicrosoft (R) Build Engine version 15.6.82.30579 for .NET Core\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n  Restore completed in 64.03 ms for D:\\cot\\DashboardCode\\Routines\\Routines\\Routines.csproj.\r\n  Restore completed in 64.46 ms for D:\\cot\\DashboardCode\\Routines\\Tests\\Benchmark\\Benchmark.csproj.\r\n  Routines -> D:\\cot\\DashboardCode\\Routines\\Routines\\bin\\Release\\netstandard2.0\\DashboardCode.Routines.dll\r\n  Benchmark -> D:\\cot\\DashboardCode\\Routines\\Tests\\Benchmark\\bin\\Release\\netcoreapp2.0\\Benchmark.dll\r\n  Benchmark -> D:\\cot\\DashboardCode\\Routines\\Tests\\Benchmark\\bin\\Release\\net47\\Benchmark.exe\r\n\r\nBuild succeeded.\r\n    0 Warning(s)\r\n    0 Error(s)\r\n\r\nTime Elapsed 00:00:05.85\r\nMicrosoft (R) Build Engine version 15.6.82.30579 for .NET Core\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n  Restore completed in 104.64 ms for D:\\cot\\DashboardCode\\Routines\\Routines\\Routines.csproj.\r\n  Restore completed in 121.11 ms for D:\\cot\\DashboardCode\\Routines\\Tests\\Benchmark\\Benchmark.csproj.\r\n// ***** BenchmarkRunner: Start   *****\r\n// Found benchmarks:\r\n//   BenchmarkConverAll.TestConverAll: RyuJitX64(Jit=RyuJit, Platform=X64)\r\n\r\n// Validating benchmarks:\r\n// ***** Building 1 benchmark(s) in Parallel: Start   *****\r\n// ***** Done, took 00:00:05 (5.29 sec)   *****\r\n// **************************\r\n// Benchmark: BenchmarkConverAll.TestConverAll: RyuJitX64(Jit=RyuJit, Platform=X64)\r\n// *** Execute ***\r\n// Launch: 1 / 1\r\n// Execute: D:\\cot\\DashboardCode\\Routines\\Tests\\Benchmark\\bin\\Release\\net47\\74d4fd8a-270d-46ab-bde8-907d0dfaa814.exe diagnoserAttached\r\n// BeforeAnythingElse\r\n\r\n// Benchmark Process Environment Information:\r\n// Runtime=.NET Framework 4.7 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.2633.0\r\n// GC=Concurrent Workstation\r\n// Job: RyuJitX64(Jit=RyuJit, Platform=X64)\r\n\r\nPilot  1: 16 op, 3459366.51 ns, 216.2104 us/op\r\n\r\n..............................\r\n\r\n// AfterAll\r\n\\ ---------------------------\r\nFailed to read source code location!\r\nPlease make sure that the project, which defines benchmarks contains following settings:\r\n\t <DebugType>pdbonly</DebugType>\r\n\t <DebugSymbols>true</DebugSymbols>\r\n\\ ---------------------------\r\ndotnet.exe : \r\nAt D:\\cot\\DashboardCode\\Routines\\BenchmarkWindows.ps1:17 char:1\r\n+ & dotnet run -c Release -f net47 -p \"$BenchmarkProjectPath\"\r\n+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    + CategoryInfo          : NotSpecified: (:String) [], RemoteException\r\n    + FullyQualifiedErrorId : NativeCommandError\r\n \r\nUnhandled Exception: \r\nSystem.InvalidOperationException: There is an error in XML document (0, 0). ---> System.Xml.XmlException: Root element is missing.\r\n   at System.Xml.XmlTextReaderImpl.Throw(Exception e)\r\n   at System.Xml.XmlTextReaderImpl.ParseDocumentContent()\r\n   at System.Xml.XmlReader.MoveToContent()\r\n   at Microsoft.Xml.Serialization.GeneratedAssembly.XmlSerializationReaderDisassemblyResult.Read9_DisassemblyResult()\r\n   --- End of inner exception stack trace ---\r\n   at System.Xml.Serialization.XmlSerializer.Deserialize(XmlReader xmlReader, String encodingStyle, XmlDeserializationEvents events)\r\n   at BenchmarkDotNet.Diagnosers.WindowsDisassembler.Dissasemble(DiagnoserActionParameters parameters)\r\n   at BenchmarkDotNet.Diagnosers.DisassemblyDiagnoser.Handle(HostSignal signal, DiagnoserActionParameters parameters)\r\n   at BenchmarkDotNet.Extensions.CommonExtensions.ForEach[T](IList`1 source, Action`1 command)\r\n   at BenchmarkDotNet.Loggers.SynchronousProcessOutputLoggerWithDiagnoser.ProcessInput()\r\n   at BenchmarkDotNet.Toolchains.Executor.Execute(Process process, Benchmark benchmark, SynchronousProcessOutputLoggerWithDiagnoser loggerWithDiagnoser, ILogger logger)\r\n   at BenchmarkDotNet.Toolchains.Executor.Execute(Benchmark benchmark, ILogger logger, String exePath, String workingDirectory, String args, IDiagnoser diagnoser, IResolver \r\nresolver, IConfig config)\r\n   at BenchmarkDotNet.Toolchains.Executor.Execute(ExecuteParameters executeParameters)\r\n   at BenchmarkDotNet.Running.BenchmarkRunnerCore.Execute(ILogger logger, Benchmark benchmark, IToolchain toolchain, BuildResult buildResult, IConfig config, IResolver \r\nresolver)\r\n   at BenchmarkDotNet.Running.BenchmarkRunnerCore.RunCore(Benchmark benchmark, ILogger logger, ReadOnlyConfig config, String rootArtifactsFolderPath, Func`2 \r\ntoolchainProvider, IResolver resolver, BuildResult buildResult)\r\n   at BenchmarkDotNet.Running.BenchmarkRunnerCore.Run(BenchmarkRunInfo benchmarkRunInfo, ILogger logger, String title, String rootArtifactsFolderPath, Func`2 \r\ntoolchainProvider, IResolver resolver, List`1 artifactsToCleanup)\r\n   at BenchmarkDotNet.Running.BenchmarkRunnerCore.Run(BenchmarkRunInfo benchmarkRunInfo, Func`2 toolchainProvider)\r\n   at Benchmark.Program.Main(String[] args)\r\n```",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/708/comments",
    "author": "rpokrovskij",
    "comments": [
      {
        "user": "AndreyAkinshin",
        "created_at": "2018-04-02T21:49:12Z",
        "body": "@adamsitnik, could you take a look?"
      },
      {
        "user": "adamsitnik",
        "created_at": "2018-04-03T13:58:39Z",
        "body": "Hi @rpokrovskij \r\n\r\nThe answer is in the output you provided:\r\n\r\n```\r\nFailed to read source code location!\r\nPlease make sure that the project, which defines benchmarks contains following settings:\r\n\t <DebugType>pdbonly</DebugType>\r\n\t <DebugSymbols>true</DebugSymbols>\r\n```\r\n\r\nPlease feel free to reopen if it does not help."
      },
      {
        "user": "rpokrovskij",
        "created_at": "2018-04-03T16:22:29Z",
        "body": "I have noticed this but thougth that this works only for classic proj file (when I use `<Project Sdk=\"Microsoft.NET.Sdk\">` )...\r\nI will check does this works in this case.\r\nYes it works! Thank you.\r\n"
      }
    ]
  },
  {
    "number": 705,
    "title": "How to allow debug configuration",
    "created_at": "2018-03-28T14:28:23Z",
    "closed_at": "2018-03-28T16:09:24Z",
    "labels": [
      "question",
      "Area:Validators"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/705",
    "body": "I tried this config without success\r\n```\r\nManualConfig cfg = ManualConfig.Create(DefaultConfig.Instance);\r\n\r\n            cfg.Add(JitOptimizationsValidator.DontFailOnError);\r\n            cfg.Add(InProcessValidator.DontFailOnError);\r\n            cfg.Add(ExecutionValidator.DontFailOnError);\r\n\r\n var summary = BenchmarkRunner.Run<VMBenchmark>(cfg);\r\n```",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/705/comments",
    "author": "shargon",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-03-28T16:09:24Z",
        "body": "Hi @shargon \r\n\r\n`DefaultConfig` has `JitOptimizationsValidator.FailOnError` so when you create a manual config from it, you get it too. The solution is following:\r\n\r\n```cs\r\npublic class AllowNonOptimized : ManualConfig\r\n{\r\n    public AllowNonOptimized()\r\n    {\r\n        Add(JitOptimizationsValidator.DontFailOnError); // ALLOW NON-OPTIMIZED DLLS\r\n\r\n        Add(DefaultConfig.Instance.GetLoggers().ToArray()); // manual config has no loggers by default\r\n        Add(DefaultConfig.Instance.GetExporters().ToArray()); // manual config has no exporters by default\r\n        Add(DefaultConfig.Instance.GetColumnProviders().ToArray()); // manual config has no columns by default\r\n    }\r\n}\r\n```\r\n\r\nPlease feel free to reopen the issue if something remains not clear"
      }
    ]
  },
  {
    "number": 690,
    "title": "Local DLL dependencies",
    "created_at": "2018-03-16T17:03:38Z",
    "closed_at": "2018-03-16T23:33:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/690",
    "body": "I'm testing a p/invoke scenario on .NET Core 2.1 Preview 1 so my benchmark depends on a local native DLL. \r\nThe DLL is in the bin folder but the benchmark can't find it.\r\nIs there any way to make this work locally?\r\nThanks!",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/690/comments",
    "author": "aalmada",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-03-16T18:53:44Z",
        "body": "hello @aalmada \r\n\r\nhow do you reference this native dll on the `.csproj` level? \r\n\r\n"
      },
      {
        "user": "aalmada",
        "created_at": "2018-03-16T23:33:08Z",
        "body": "hi @adamsitnik \r\nI was using just a post-build event command but, when I read your question, realized a reference with 'build action' set to 'none' and 'copy to output directory' set to 'copy if newer' could do the trick. It does!\r\nThanks!"
      }
    ]
  },
  {
    "number": 668,
    "title": "Can ParamsSource be evaluated after GlobalSetup?",
    "created_at": "2018-02-27T14:28:15Z",
    "closed_at": "2018-03-02T20:29:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/668",
    "body": "I have to initialize several objects that are generating parameters. Therefore my idea was to initialize these objects in the GlobalSetup area. \r\n\r\n        private IProjectInfo _generatedProject1;\r\n        private IProjectInfo _generatedProject2;\r\n\r\n        [GlobalSetup]\r\n        public void BenchmarkSetup()\r\n        {\r\n            var loader = new ProjectLoader();\r\n            _generatedProject1 = loader.GetSample();\r\n            _generatedProject2 = loader.GetBigSample();\r\n        }\r\n\r\n        [ParamsSource(nameof(Projects))]\r\n        public IProjectInfo Project;\r\n\r\n        public IEnumerable<IParam> Projects()\r\n        {\r\n            yield return new ProjectParameter { Project = _generatedProject1};\r\n            yield return new ProjectParameter { Project = _generatedProject2};\r\n        }\r\n\r\n        [Benchmark]\r\n        public IProject OpenProject()\r\n        {\r\n            var project = OpenProject(Project);\r\n            return project;\r\n        }\r\n\r\n        public class ProjectParameter : IParam\r\n        {\r\n            public IProjectInfo Project { get; set; }\r\n            public string ToSourceCode() => \"\";\r\n            public object Value => Project;\r\n            public string DisplayText => Project.Name;\r\n        }\r\n\r\nBut unfortunately the parameters are built before, so I get an exception. Is there any workaround?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/668/comments",
    "author": "chriga",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-02-27T15:38:59Z",
        "body": "Parameters are generated before the call to `Setup` method(s), to make it possible for the setup to use their values.\r\n\r\nYou could do sth like:\r\n\r\n```cs\r\nprivate Dictionary<string, IProjectInfo> _projectsByName;\r\n\r\nprivate IProjectInfo _project;\r\n\r\n[ParamsSource(nameof(Projects))]\r\npublic string CurrentProjectName;\r\n\r\npublic IEnumerable<IParam> Projects()\r\n{\r\n\tyield return \"generatedProject1\"\r\n\tyield return \"generatedProject2\";\r\n}\r\n\r\n\r\n[GlobalSetup]\r\npublic void BenchmarkSetup()\r\n{\r\n\tvar loader = new ProjectLoader();\r\n\t_projectsByName = new Dictionary<string, IProjectInfo>\r\n\t{\r\n\t\t{ \"_generatedProject1\", loader.GetSample() },\r\n\t\t{ \"_generatedProject2\", loader.GetBigSample() },\r\n\t}\r\n\r\n\t_currentProject = _projectsByName[CurrentProjectName];\r\n}\r\n\r\n[Benchmark]\r\npublic IProject OpenProject()\r\n{\r\n\tvar project = OpenProject(_currentProject);\r\n\treturn project;\r\n}\r\n```"
      },
      {
        "user": "chriga",
        "created_at": "2018-03-02T16:00:17Z",
        "body": "Hi Adam,\r\n\r\nthanks for your input. Your idea seems to work with some modification:\r\n\r\n    private Dictionary<string, IProjectInfo> _projectsByName;\r\n    \r\n    [ParamsSource(nameof(Projects))]\r\n    public string CurrentProjectName;\r\n\r\n    public IEnumerable<string> Projects()\r\n    {\r\n\t    yield return \"generatedProject1\"\r\n\t    yield return \"generatedProject2\";\r\n    }\r\n\r\n    [GlobalSetup]\r\n    public void BenchmarkSetup()\r\n    {\r\n\t    var loader = new ProjectLoader();\r\n\t    _projectsByName = new Dictionary<string, IProjectInfo>\r\n        {\r\n\t\t    { \"generatedProject1\", loader.GetSample() },\r\n\t\t    { \"generatedProject2\", loader.GetBigSample() }\r\n\t    }\r\n    }\r\n\r\n    [Benchmark]\r\n    public IProject OpenProject()\r\n    {\r\n\t    var project = OpenProject(_projectsByName[CurrentProjectName]);\r\n\t    return project;\r\n    }\r\n\r\nOriginal I wanted that the project names are used from loaded projects. But I can get over it."
      },
      {
        "user": "FreePhoenix888",
        "created_at": "2023-03-17T10:19:27Z",
        "body": "I would be glad to be able call some code before ParamsSource evaluation"
      },
      {
        "user": "FreePhoenix888",
        "created_at": "2023-03-17T11:15:55Z",
        "body": "I have found out that static constructor is evaluated before ParamsSource evaluation. @chriga , you can try this solution"
      },
      {
        "user": "timcassell",
        "created_at": "2023-03-17T11:50:38Z",
        "body": "@FreePhoenix888 So is a non-static constructor (just make sure it's public, parameter-less). In any case, I wouldn't recommend that. By default, benchmarks are ran in a separate process from the host process that evaluated the params, so if you're trying to use that instead of `[GlobalSetup]`, you could be in for a surprise."
      },
      {
        "user": "FreePhoenix888",
        "created_at": "2023-03-17T12:21:31Z",
        "body": "> @FreePhoenix888 So is a non-static constructor (just make sure it's public, parameter-less). In any case, I wouldn't recommend that. By default, benchmarks are ran in a separate process from the host process that evaluated the params, so if you're trying to use that instead of `[GlobalSetup]`, you could be in for a surprise.\r\n\r\nThank you for fast response.\r\nAs I know initializing a field right on the declaration line is equivalent to having aconstructor because C# automatically creates it under the hood. Is not it ? :)"
      }
    ]
  },
  {
    "number": 656,
    "title": "Question: is it possible to access method, mean and scale programmatically once the benchmarks have ran?",
    "created_at": "2018-02-22T16:43:55Z",
    "closed_at": "2018-02-28T14:43:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/656",
    "body": "Is it possible to access method, mean and scale programmatically once the benchmarks have ran?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/656/comments",
    "author": "PonchoPowers",
    "comments": [
      {
        "user": "PonchoPowers",
        "created_at": "2018-02-22T17:34:24Z",
        "body": "Use case being I would like to run the benchmarks on the command line as part of an automatic build system, and I'd like to flag up when the benchmarks are too slow, so would like to programmatically parse the results to then indicate on the build system summary page whether the build has passed or failed.\r\n\r\nI couldn't see anywhere in the docs which specified I could and I took a look at the Summary class and it wasn't immediately apparent if I could access this data via the API or not."
      },
      {
        "user": "PonchoPowers",
        "created_at": "2018-02-28T12:45:18Z",
        "body": "I know artifacts are created which contain this information, but I was hoping to programmatically parse the Summary class but can't see how to. Should I parse the artifacts after the benchmarks have ran or is there another way?"
      },
      {
        "user": "adamsitnik",
        "created_at": "2018-02-28T13:07:16Z",
        "body": "```cs\r\nvar summary = BenchmarkRunner.Run<Program>();\r\n\r\nforeach (var report in summary.Reports)\r\n{\r\n    report.ResultStatistics.Mean // ResultStatistics has all you need\r\n}\r\n```"
      },
      {
        "user": "PonchoPowers",
        "created_at": "2018-02-28T14:36:27Z",
        "body": "Ah cool got to loop the reports first. Got it thanks."
      }
    ]
  },
  {
    "number": 523,
    "title": "Add support for stats on benchmark return result",
    "created_at": "2017-08-07T23:07:53Z",
    "closed_at": "2017-08-20T16:52:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/523",
    "body": "I believe it would be useful to have the same statistical analysis that is performed on benchmark timing on a numeric return type of a benchmark method `float`, `double`, `int`, etc.\r\n\r\nCertain implementations of certain algorithms can be more or less accurate based on the parameters and therefore the return result of my benchmark is important data. \r\nE.g.: Let's say I have an algorithm to find the area under a curve, and am splitting that curve into sections and using a thread per segment. I'd like to scale up threads and see the performance benefits (easily done with `[Params(1, 2, 4, 8)]` and compare the precision that I gain by increasing the number of thread jobs (decreasing the size of the segment) which as far as I can tell is not easily done using BenchmarkDotNet. \r\n\r\nApologies if this already exists I was unable to find something like this after digging through the docs, I figured a custom column would do the trick but it appears that the data there is loaded at some time not during the benchmark process. If it doesn't exist and someone can point me in the right direction I'd be happy to implement!",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/523/comments",
    "author": "jschneidereit",
    "comments": [
      {
        "user": "AndreyAkinshin",
        "created_at": "2017-08-20T16:52:38Z",
        "body": "Hey @jschneidereit,\r\n\r\nWe don't support such feature by design: BenchmarkDotNet supposes that the return value can be used only for preventing dead code elimination. Everyone who ask about an additional column for benchmark result has own needs, and it's really hard to implement a general approach which will make everyone happy and doesn't introduce additional troubles for common benchmarking scenarious.\r\n\r\nSo, you should implement own custom column and decide how to collect data and how to display it."
      }
    ]
  },
  {
    "number": 402,
    "title": "Any chance in removing F# dependency",
    "created_at": "2017-03-27T17:03:35Z",
    "closed_at": "2017-03-28T22:02:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/402",
    "body": "Am considering the project for client VM work but don't like F# dependency.  Will review impact on DLL size and ease of use in using on remote VM clients and post back.",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/402/comments",
    "author": "AcousticGuitar",
    "comments": [
      {
        "user": "AndreyAkinshin",
        "created_at": "2017-03-27T17:06:40Z",
        "body": "Hey @AcousticGuitar. Which dependency do you mean?"
      },
      {
        "user": "AcousticGuitar",
        "created_at": "2017-03-27T17:37:05Z",
        "body": "Hi Andrey, when I cloned the project to my desktop and tried to build, it immediately forced a F# install to my Visual Studio Instance.  I think I know now why, there are F# samples and I don't have F# component installed."
      },
      {
        "user": "AndreyAkinshin",
        "created_at": "2017-03-28T04:02:12Z",
        "body": "> I think I know now why, there are F# samples and I don't have F# component installed.\r\n\r\nExactly.\r\n\r\nWhy do you want to build BenchmarkDotNet from source code on remote client VM? We have NuGet packages which can be installed to your project without any F# dependencies. If you want to develop new features in BenchmarkDotNet, you have to install the F# component (or unload F# projects)."
      },
      {
        "user": "AcousticGuitar",
        "created_at": "2017-03-28T22:02:51Z",
        "body": "I'm a dummy.  When I saw the samples, I cloned and try to bring up in VS2015.   I just tried it again today in 2017 and it loaded just fine, samples and all. "
      }
    ]
  },
  {
    "number": 323,
    "title": "Dead code elimination - is this safe?",
    "created_at": "2016-12-10T17:12:36Z",
    "closed_at": "2016-12-12T13:07:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/323",
    "body": "I have a benchmark like so:\r\n\r\n```cs\r\n[Params(1, 10, 100, 500, 1000, 10000)]\r\npublic int NumberOfMatches { get; set; }\r\n\r\n[Benchmark]\r\npublic List<bool> DotNetGlobIsMatch()\r\n{\r\n    // we collect all results in a list \r\n    // and return it to prevent dead code elimination (optimisation)\r\n    var results = new List<bool>(NumberOfMatches);\r\n    for (int i = 0; i < NumberOfMatches; i++)\r\n    {\r\n        var testString = _testData[i];\r\n        var result = _dotnetGlob.IsMatch(testString);\r\n        results.Add(result);\r\n    }\r\n    return results;\r\n}\r\n```\r\n\r\nI would use `[OperationsPerInvoke]` except it's not dynamic, so I use  `[Params(1, 10, 100, 500, 1000, 10000)]` instead.\r\n\r\nMy question is, I don't really like having to construct and return a list in my Benchmark method, however I need to ensure that something is done with each result in the iteration so that dead code elimination doesn't remove it.\r\n\r\nIs this safe to do instead?\r\n\r\n```cs\r\n[Benchmark]\r\npublic IEnumerable<bool> DotNetGlobIsMatch()\r\n{\r\n    for (int i = 0; i < NumberOfMatches; i++)\r\n    {\r\n        var testString = _testData[i];\r\n        var result = _dotnetGlob.IsMatch(testString);\r\n        yield return result;\r\n    }\r\n}\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/323/comments",
    "author": "dazinator",
    "comments": [
      {
        "user": "AndreyAkinshin",
        "created_at": "2016-12-12T12:52:53Z",
        "body": "In both cases, you will have some overhead. Here is an almost overhead-free benchmark:\r\n```cs\r\n[Benchmark]\r\npublic bool DotNetGlobIsMatch()\r\n{\r\n    var result = false;\r\n    for (int i = 0; i < NumberOfMatches; i++)\r\n    {\r\n        var testString = _testData[i];\r\n        result ^= _dotnetGlob.IsMatch(testString);\r\n    }\r\n    return result;\r\n}\r\n```"
      },
      {
        "user": "dazinator",
        "created_at": "2016-12-12T13:07:31Z",
        "body": "ah nice! Thanks @AndreyAkinshin !"
      }
    ]
  },
  {
    "number": 1242,
    "title": "bug JSON Exporter exports NaN for some properties. This fails most JSON parsers",
    "created_at": "2019-09-08T04:03:07Z",
    "closed_at": "2020-11-04T17:17:58Z",
    "labels": [
      "up-for-grabs",
      "help wanted",
      "Hacktoberfest",
      "hacktoberfest-accepted"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1242",
    "body": "The JSON Exporter writes NaN values in some properties.  This is invalid according to online JSON Parser, and fails with the javascript JSON.Parse.\r\n\r\nProperties found with NaN:\r\n\r\n```\r\nStatistics.Skewness\r\nStatistics.Kurtosis\r\nConfidenceInterval.Margin\r\nConfidenceInterval.Lower\r\nConfidenceInterval.Upper\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1242/comments",
    "author": "jafin",
    "comments": [
      {
        "user": "marcnet80",
        "created_at": "2020-11-02T10:53:08Z",
        "body": "Hello, @AndreyAkinshin, @adamsitnik. Please review PR:  Json exporter fix #1581 \r\nThanks. "
      }
    ]
  },
  {
    "number": 1106,
    "title": "Allow user defined namespace filter for InliningDiagnoser",
    "created_at": "2019-03-18T17:48:25Z",
    "closed_at": "2019-04-17T13:23:32Z",
    "labels": [
      "enhancement",
      "up-for-grabs",
      "Area:Diagnosers",
      "help wanted"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1106",
    "body": "When I'm working on something that I want to optimize & test with BenchmarkDotNet, I usually set up a solution with a pair of projects, with a library DLL that I'm testing & a console app test harness that runs BenchmarkDotNet. Unfortunately this means my benchmarks are by default in a different namespace than the code I want to test; it would be convenient if I could choose which namespace is used by the InliningDiagnoser to filter inlining messages.",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1106/comments",
    "author": "Zhentar",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2019-03-19T15:02:19Z",
        "body": "@Zhentar good idea, I have marked it as up for grabs. Hopefully someone is going to implement it soon (it should be easy)"
      },
      {
        "user": "MarekM25",
        "created_at": "2019-04-06T21:07:14Z",
        "body": "@adamsitnik, @AndreyAkinshin, could I give it a try?"
      },
      {
        "user": "AndreyAkinshin",
        "created_at": "2019-04-07T05:15:19Z",
        "body": "@MarekM25 sure!"
      }
    ]
  },
  {
    "number": 989,
    "title": "[Suggestion] add API for detecting benchmark run failures.",
    "created_at": "2018-12-15T18:18:30Z",
    "closed_at": "2022-10-17T20:15:56Z",
    "labels": [
      "up-for-grabs",
      "Area:Validators",
      "help wanted",
      "Hacktoberfest"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/989",
    "body": "There's no way to detect run failures such as incompatible target platform.\r\n\r\nUse case:\r\n```cs\r\n\t\t[Fact]\r\n\t\tpublic void InProcessCannotRun()\r\n\t\t{\r\n\t\t\tvar otherPlatform = IntPtr.Size == 8\r\n\t\t\t\t? Platform.X86\r\n\t\t\t\t: Platform.X64;\r\n\r\n\t\t\tvar otherPlatformConfig = new ManualConfig()\r\n\t\t\t\t.With(Job.Dry.With(InProcessToolchain.Instance).WithInvocationCount(UnrollFactor).WithUnrollFactor(UnrollFactor).With(otherPlatform))\r\n\t\t\t\t.With(new OutputLogger(Output))\r\n\t\t\t\t.With(DefaultColumnProviders.Instance);\r\n\r\n\t\t\tvar runInfo = BenchmarkConverter.TypeToBenchmarks(typeof(BenchmarkAllCases), otherPlatformConfig);\r\n\t\t\tvar summary = BenchmarkRunner.Run(runInfo);\r\n\r\n\t\t\t// summary is empty; no way to detect from code what vent wrong;\r\n\t\t\t// output is:\r\n\t\t\t/*\r\n\t\t\t\t// Benchmark BenchmarkAllCases.InvokeOnceVoid: Dry(Platform=X86, Toolchain=InProcessToolchain, InvocationCount=16, IterationCount=1, LaunchCount=1, RunStrategy=ColdStart, UnrollFactor=16, WarmupCount=1)\r\n\t\t\t\t// cannot be run in-process. Validation errors:\r\n\t\t\t\t//    * Job Dry, EnvironmentMode.Platform was run as X64 (X86 expected). Fix your test runner options.\r\n\t\t\t */\r\n\r\n\t\t\t// Workaround (not reliable)\r\n\t\t\tAssert.Empty(summary.BenchmarksCases);\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n```\r\n\r\nSuggestions:\r\n* call the `IToolchain.IsSupported` method from validator and add the result into summary.ValidationErrors\r\n* add a property that indicates that benchmark completed without errors, `summary.CompletedWithoutErrors` or something like this.",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/989/comments",
    "author": "ig-sinicyn",
    "comments": [
      {
        "user": "AndreyAkinshin",
        "created_at": "2018-12-15T18:46:04Z",
        "body": "> call the IToolchain.IsSupported method from validator and add the result into summary.ValidationErrors\r\n\r\nIt's a good idea!\r\n\r\n> add a property that indicates that benchmark completed without errors, summary.CompletedWithoutErrors or something like this.\r\n\r\nWe already have a benchmark report in the summary. Currently, `MarkdownExporter` uses the following code to detect broken benchmarks:\r\n\r\n```cs\r\nvar benchmarksWithTroubles = summary.Reports.Where(r => !r.GetResultRuns().Any()).Select(r => r.BenchmarkCase).ToList();\r\n```\r\n\r\nCurrently, `BenchmarkReport` contains `GenerateResult`, `BuildResult`, and the list of result runs. I think we can introduce `Status` property which contains the final conclusion about benchmark status (including error text messages in case of any problems). In this case, we can implement an extension method for `CompletedWithoutErrors` based on the status values."
      },
      {
        "user": "ig-sinicyn",
        "created_at": "2019-01-12T11:12:21Z",
        "body": "@AndreyAkinshin \r\nJust checked, the `summary.Reports` is empty too. To repro: copy the code into the `InProcessTest`.\r\n\r\n```cs\r\n\t\t[Fact]\r\n\t\tpublic void InProcessCannotRun()\r\n\t\t{\r\n\t\t\tvar otherPlatform = IntPtr.Size == 8\r\n\t\t\t\t? Platform.X86\r\n\t\t\t\t: Platform.X64;\r\n\r\n\t\t\tvar otherPlatformConfig = new ManualConfig()\r\n\t\t\t\t.With(Job.Dry.With(InProcessToolchain.Instance).WithInvocationCount(UnrollFactor).WithUnrollFactor(UnrollFactor).With(otherPlatform))\r\n\t\t\t\t.With(new OutputLogger(Output))\r\n\t\t\t\t.With(DefaultColumnProviders.Instance);\r\n\r\n\t\t\tvar runInfo = BenchmarkConverter.TypeToBenchmarks(typeof(BenchmarkAllCases), otherPlatformConfig);\r\n\t\t\tvar summary = BenchmarkRunner.Run(runInfo);\r\n\r\n\t\t\t// proof:\r\n\t\t\tAssert.Empty(summary.BenchmarksCases);\r\n\t\t\tAssert.Empty(summary.Reports);\r\n\t\t}\r\n```"
      },
      {
        "user": "adamsitnik",
        "created_at": "2020-10-23T21:16:52Z",
        "body": "I've marked this issue as `up-for-grabs`. The contributor who is going to work on this should make sure that the errors are present in `summary.ValidationErrors`"
      },
      {
        "user": "emanuel-v-r",
        "created_at": "2022-10-13T15:19:01Z",
        "body": "Hi,\r\n\r\nCan I grab this one?"
      }
    ]
  },
  {
    "number": 865,
    "title": "Truncated parameter strings used as group causes problems",
    "created_at": "2018-08-30T14:05:22Z",
    "closed_at": "2018-09-01T12:51:43Z",
    "labels": [
      "bug",
      "up-for-grabs",
      "help wanted",
      "good first issue"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/865",
    "body": "If a benchmark has parameters which are long strings, they get truncated to \r\n(_first five chars_)…(_last five chars_) [_length_]\r\n\r\nIf two parameters are the same length and have the same first/last five characters, they benchmarks get grouped together. \r\nIf one of the methods is marked as a baseline, BenchmarkDotNet complains that the group has two baselines.\r\n\r\n```csharp\r\nusing BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Running;\r\nusing System.Threading;\r\n\r\nnamespace RunnerCS\r\n{\r\n    public class ThingsToBenchmark\r\n    {\r\n        [Params(\"12345thisisaLongparameter54321\", \r\n                \"12345thisisaRongparameter54321\")]\r\n        public string Parameter { get; set; }\r\n\r\n        [Benchmark(Baseline = true)]\r\n        public void Unmodified()\r\n        {\r\n            Thread.Sleep(100);\r\n        }\r\n\r\n        [Benchmark]\r\n        public void Faster()\r\n        {\r\n            Thread.Sleep(90);\r\n        }\r\n    }\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var summary = BenchmarkRunner.Run<ThingsToBenchmark>();\r\n        }\r\n    }\r\n}\r\n```\r\nproduces `Only 1 benchmark method in a group can have \"Baseline = true\" applied to it, group DefaultJob-[Parameter=12345(...)54321 [30]] in class ThingsToBenchmark has 2`\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/865/comments",
    "author": "marklam",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-08-31T08:26:56Z",
        "body": "@marklam big thanks for the very good bug report!"
      }
    ]
  }
]