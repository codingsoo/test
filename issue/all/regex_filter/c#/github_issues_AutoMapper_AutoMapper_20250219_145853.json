[
  {
    "number": 3614,
    "title": "10.1.1 broke mapping in special cases",
    "created_at": "2021-03-26T13:03:06Z",
    "closed_at": "2021-03-26T15:08:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3614",
    "body": "Hi guys! I'm afraid but you broke something in the most recent version 10.1.1 or 10.1.0 :smiley:\r\n\r\nAfter upgrading from **10.0.0** to **10.1.1** (Nuget doesn't offer 10.1.0, so I can't test that version) one of our mapping profiles stopped working, i. e. one property didn't get mapped at all and our main test that calls AssertConfigurationIsValid() failed.\r\n\r\nIt took me quite a while to figure out what's actually going on: **if your mapping source class has two properties with the same name but different capitalisation (i. e. Foo and FOO) mapping will break**!\r\n\r\nThe reason is that if your destination class has a property Destination.FOO and you want to map from Source.FOO, AutoMapper actually tries to map from Source.Foo. I've provided a working (in terms of not working :smirk:) example in form of a unit test. If you copy paste that into a test project with AutoMapper 10.1.1 you can reproduce the behaviour.\r\n\r\n### Source/destination types\r\n\r\n```csharp\r\nclass Documenttype { }\r\n\r\nclass Source\r\n{\r\n\tpublic short? DOCUMENTTYPE { get; set; }\r\n\tpublic Documenttype Documenttype { get; set; }\r\n}\r\n\r\nclass Destination\r\n{\r\n\tpublic short? DOCUMENTTYPE { get; set; }\r\n}\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\nclass MappingProfile : Profile\r\n{\r\n\tpublic MappingProfile()\r\n\t{\r\n\t\tCreateMap<Source, Destination>(MemberList.Destination);\r\n\t}\r\n}\r\n```\r\n\r\n\r\n### Test\r\n\r\n```csharp\r\n[Test]\r\npublic void ShouldMapFromCorrectProperty()\r\n{\r\n\tMapperConfiguration configuration = new MapperConfiguration(cfg =>\r\n\t{\r\n\t\tcfg.AddProfile(typeof(MappingProfile));\r\n\t});\r\n\r\n\tMapper mapper = new Mapper(configuration);\r\n\t\r\n\t// Notice how Destination.DOCUMENTTYPE is null\r\n\tDestination destination = mapper.Map<Destination>(new Source { DOCUMENTTYPE = 99 });\r\n\t\r\n\t// Exception thrown because \"destination member DOCUMENTTYPE could not be found in source type\".\r\n\t// This is nonsense, the underlying error is that AutoMapper tries to map from\r\n\t// Source.Documenttype -> Destination.DOCUMENTTYPE (notice the capitalisation, it's the wrong property!)\r\n\tconfiguration.AssertConfigurationIsValid();\r\n}\r\n```\r\n\r\n### Version: 10.1.1\r\n\r\n### Expected behavior\r\n\r\nTest should pass, in older Versions <= 10.0.0 the correct property would have been taken for mapping (DOCUMENTTYPE).\r\n\r\n### Actual behavior\r\n\r\nTest fails with a misleading error \"destination member DOCUMENTTYPE could not be found in source type\".\r\n\r\n### Steps to reproduce\r\n\r\nExecute the unit test I provided.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3614/comments",
    "author": "mortan",
    "comments": [
      {
        "user": "jbogard",
        "created_at": "2021-03-26T13:31:20Z",
        "body": "This is an odd edge case we have no unit tests for. PR is welcome!"
      },
      {
        "user": "lbargaoanu",
        "created_at": "2021-03-26T14:00:21Z",
        "body": "We are case insensitive, so what happens in such a case is not relevant."
      },
      {
        "user": "buddde",
        "created_at": "2021-03-26T14:25:35Z",
        "body": "Can you check names and types?"
      },
      {
        "user": "lbargaoanu",
        "created_at": "2021-03-26T14:38:07Z",
        "body": "In a case like this you have to explicitly say what you want, you cannot relay on the default matching."
      },
      {
        "user": "jbogard",
        "created_at": "2021-03-26T14:41:48Z",
        "body": "You can alter the naming convention if you don't like these defaults, to ignore all upper case or something."
      },
      {
        "user": "mortan",
        "created_at": "2021-03-29T11:02:50Z",
        "body": "I don't know why you are case-insensitive (while C# is case sensitive and having two properties with the same name but different capitalisation is perfectly valid - not to argue that this is good practice), but what about the misleading error message? That's probably what bugs me most:\r\n\r\n```csharp\r\nAutoMapper.AutoMapperConfigurationException : The following member on XXX.WebTests.Destination cannot be mapped: \r\n\tDOCUMENTTYPE \r\nAdd a custom mapping expression, ignore, add a custom resolver, or modify the destination type XXX.Destination.\r\nContext:\r\n\tMapping to member DOCUMENTTYPE from XXX.WebTests.Source to XXX.WebTests.Destination\r\nException of type 'AutoMapper.AutoMapperConfigurationException' was thrown.\r\n   at AutoMapper.ConfigurationValidator.AssertConfigurationIsValid(IEnumerable`1 typeMaps)\r\n   at XXX.WebTests.MappingProfileTests.ShouldMapFromCorrectProperty() in YYY\\Web.UnitTests\\MappingProfileTests.cs:line 86\r\n```\r\nEspecially: **Mapping to member DOCUMENTTYPE from XXX.WebTests.Source to XXX.WebTests.Destination**\r\n\r\nThat is the same message you would get if the property does not exist in the Source type. That AutoMapper finds \"Documenttype\" instead of \"DOCUMENTYPE\" and can not map because the former is a **complex type** (if it wasn't a complex type it would straight up map from the wrong property without notice!) is not clear at all. Again, it took me quite a while to figure that out in our code base because \"Documenttyp\" is in a different spot.\r\n\r\nIs there a way to get a check for such a case or at least a better error message? Also  @lbargaoanu could you elaborate why AutoMapper is case-insensitive?\r\n\r\n@jbogard Would it be possible to override the naming convention as you suggested and check for a property in the Source type with the exact name and capitalisation and if not found delegate to the normal AutoMapper naming convention code?\r\n\r\nGreetings"
      },
      {
        "user": "jbogard",
        "created_at": "2021-03-29T13:56:08Z",
        "body": "That the mapping worked in the first place was just coincidence, it was never intentional. AutoMapper does its member configuration by first matching member names, then later trying to figure out the type conversion. Because a later map could add a conversion, we don't make any kind of type conversion comparisons or assumptions in the first member mapping phase. Any more complex and we'd be a compiler."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2021-05-02T00:06:21Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3567,
    "title": "IAsyncEnumerable support",
    "created_at": "2021-01-27T15:10:07Z",
    "closed_at": "2021-01-27T15:27:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3567",
    "body": "Opening this since #3239 is locked/closed.  With modern C# it is going to become increasingly common having IAsyncEnumerable data, so it would be great to support Projecting that data.\r\n\r\nAnd no, not everybody is using EF/EF Core, there are other backing stores that IAsyncEnumerable is a great fit for, such as Cosmos's SDK.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3567/comments",
    "author": "onionhammer",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2021-01-27T15:27:26Z",
        "body": "You'll have to write your async code outside AM."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2021-01-27T15:30:09Z",
        "body": "If you're talking about `ProjectTo`, the `async` part comes after the projection, so still outside AM."
      },
      {
        "user": "jbogard",
        "created_at": "2021-01-27T15:32:29Z",
        "body": "In-memory AutoMapper (`Mapper.Map`) will NEVER support async, by design. It's an absolute awful mess to introduce async to a sync library.\r\n\r\nAs @lbargaoanu said, `ProjectTo` supports async just fine, since it's merely a shortcut to `Select(x => { })`.\r\n\r\nI've used `ProjectTo` with EF, EF Core, MongoDB, CosmosDB, all works just fine. Unless there's something I'm missing, show code that does *not* use AutoMapper that does `IAsyncEnumerable` with projection."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2021-02-28T00:21:24Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3566,
    "title": "AutoMapper 10.1.1 doesn't ignore generic types with UseDestinationValue()",
    "created_at": "2021-01-26T12:00:57Z",
    "closed_at": "2021-01-26T12:32:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3566",
    "body": "### Source/destination types\r\nI have problems with AutoMapper copying the values from the ViewModel to the Entity. I've an ViewModel like this:\r\n\r\n`public class BusinessPartnerAppModel<TKey> : TableBaseDefault<TKey> where TKey : IEquatable<TKey>{ \r\n   public string CardCode { get; set; } = string.Empty;\r\n   public string CardName { get; set; } = string.Empty;\r\n   public List<AccessDbModel<TKey>> AccessDatas { get; set; } = new List<AccessDbModel<TKey>>();\r\n}\r\n\r\npublic class AccessAppModel<TKey> : TableBaseLines<TKey> where TKey : IEquatable<TKey>\r\n{\r\n    public TKey BusinessPartnerId { get; set; }\r\n    public string URL { get; set; } = string.Empty;\r\n    public string Name { get; set; } = string.Empty;\r\n    public string UserName { get; set; } = string.Empty;\r\n    public string Password { get; set; } = string.Empty;\r\n}`\r\n\r\nAn i've an DbModel like this:\r\n\r\n`public class BusinessPartnerDbModel<TKey> : TableBaseDefault<TKey> where TKey : IEquatable<TKey>{ \r\n   public string CardCode { get; set; } = string.Empty;\r\n   public string CardName { get; set; } = string.Empty;\r\n   public List<AccessDbModel<TKey>> AccessDatas { get; set; } = new List<AccessDbModel<TKey>>();\r\n}\r\n\r\npublic class AccessDbModel<TKey> : TableBaseLines<TKey> where TKey : IEquatable<TKey>\r\n{\r\n    public TKey BusinessPartnerId { get; set; }\r\n    [ForeignKey(\"BusinessPartnerId\")]\r\n    public BusinessPartnerModel<TKey> BusinessPartner { get; set; }\r\n    public string URL { get; set; } = string.Empty;\r\n    public string Name { get; set; } = string.Empty;\r\n    public string UserName { get; set; } = string.Empty;\r\n    public string Password { get; set; } = string.Empty;\r\n}`\r\n\r\n### Mapping configuration\r\nTKey is in my case \"GUID\"\r\n\r\n public override TResult Save(BusinessPartnerAppModel entity)\r\n\r\n`var config = new MapperConfiguration(cfg =>\r\n        {\r\n            cfg.CreateMap<AccessAppModel<TKey>, AccessDbModel<TKey>>()\r\n            .ForMember(dest => dest.BusinessPartner, opt => opt.UseDestinationValue());\r\n            cfg.CreateMap<BusinessPartnerAppModel<TKey>, BusinessPartnerDbModel<TKey>>();\r\n        });\r\n        IMapper iMapper = config.CreateMapper();\r\n        \r\n        BusinessPartnerModel<TKey> dbEntity = _businessPartnerManager.FindByKey(entity.Id);\r\n        _businessPartnerManager.Attach(dbEntity);\r\n        \r\n        iMapper.Map(entity, dbEntity);\r\n        \r\n        this._businessPartnerManager.Save();\r\n}`\r\n\r\n### Version: 10.1.1\r\nI use .Net 5 with Microsoft.EntityFrameworkCore 5.0.2\r\n\r\n### Expected behavior\r\n\r\nI expect the \"BusinessPartner\" attribute to be ignored and not set to the value \"null\" \r\n\r\n### Actual behavior\r\n\r\nThe \"BusinessPartner\" attribute has the value \"null\" after the execution of \"iMapper.Map\" \r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3566/comments",
    "author": "zornic84",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2021-01-26T12:32:06Z",
        "body": "I think this is better suited for StackOverflow."
      }
    ]
  },
  {
    "number": 3554,
    "title": "Record types",
    "created_at": "2021-01-08T14:25:56Z",
    "closed_at": "2021-01-08T14:29:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3554",
    "body": "Just trying to map record types and it seems Automapper sees them as Object. Am I right in assuming it's a bit too early to think Automapper should map record types successfully?\r\n\r\nFor instance:\r\n```\r\n// command.Scopes is of type Scope[]\r\nvar mapS = _mapper.Map<Scope>(command.Scopes);\r\n```\r\nthrows\r\n```\r\nMissing type map configuration or unsupported mapping.\r\n\r\nMapping types:\r\nObject -> Scope\r\nSystem.Object -> Scope\r\n```\r\n\r\nI have `CreateMap<Scope, Scope>();` in my Mapping profile so this in theory should work?\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3554/comments",
    "author": "jameswoodley",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2021-01-08T14:29:20Z",
        "body": "It should work. Check the older discussion about it."
      },
      {
        "user": "jbogard",
        "created_at": "2021-01-08T15:03:18Z",
        "body": "Records are just classes with compile time sugar. Otherwise they look like normal classes with private setters and/or a constructor.\r\n\r\nRecords work with serialization, EF Core, anything that uses reflection/expression trees/Reflection.Emit."
      },
      {
        "user": "jbogard",
        "created_at": "2021-01-08T15:04:39Z",
        "body": "Also above it looks like you're trying to map something to itself? And then an array of something to a single thing at runtime? All that is a bit weird."
      },
      {
        "user": "jameswoodley",
        "created_at": "2021-01-08T15:11:48Z",
        "body": "I'll give the full story:\r\n\r\nI have a record that has multiple properties within it, one of which is another record.\r\n```\r\npublic record Scope(string Description, string Value);\r\n\r\npublic record ApiCreateRequest(string Name, string Identifier, Scope[] Scopes,\r\n        bool IncludePermissionsInScopeClaim, bool SkipConsentIfFirstParty, bool AllowOfflineAccess,\r\n        int? TokenLifetimeSeconds);\r\n```\r\n\r\nI then have a MediatR command object that I'd like to map to the ApiCreateRequest record\r\n```\r\npublic class CreateApiCommand : IRequest<ApiReadModel>\r\n{\r\n    public string Name { get; init; } = default!;\r\n    public string Identifier { get; init; } = default!;\r\n    public Scope[] Scopes { get; init; } = Array.Empty<Scope>();\r\n    public bool IncludePermissionsInScopeClaim { get; init; } = true;\r\n    public bool SkipConsentIfFirstParty { get; init; } = true;\r\n    public bool AllowOfflineAccess { get; init; }\r\n    public int? TokenLifetimeSeconds { get; init; }\r\n}\r\n```\r\nand my mapping profile\r\n```\r\nCreateMap<CreateApiCommand, ApiCreateRequest>();\r\n```\r\n\r\nWhen running my unit tests, I noticed that equality wasn't preserved even though both records should be equal value, so:\r\n```\r\nvar map = _mapper.Map<ApiCreateRequest>(command);\r\nvar map1 = _mapper.Map<ApiCreateRequest>(command);\r\nvar equality = map.Equals(map1);      <-- False\r\n```\r\n\r\nI took out the inner Scope[] and then it was preserved. So I thought OK I'll try mapping just the scopes and checking that for equality, so added\r\n```\r\nCreateMap<Scope, Scope>()\r\n``` \r\nto my profile (as the docs say you don't need to worry about enumerator, arrays, lists etc?) and tried again. This time I got the Object -> Scope exception\r\n\r\nMy end goal here really is to be able to run map twice on the same source, get 2 different result objects, call .Equals on it and get a true.\r\n\r\n"
      },
      {
        "user": "jameswoodley",
        "created_at": "2021-01-08T15:26:19Z",
        "body": "Got an email with a new comment @jbogard but it seems to have disappeared on here, anyway in terms of the Command not being a record, not intentional per se, could probably just be a standard POCO. No real business need for immutability there I don't think"
      },
      {
        "user": "jbogard",
        "created_at": "2021-01-08T15:37:22Z",
        "body": "Record equality isn't doing what you think it's doing:\r\n\r\n```csharp\r\nvar request1 = new ApiCreateRequest(\r\n    Name: \"Joe\",\r\n    Identifier: \"1234\",\r\n    Scopes: new[]\r\n    {\r\n        new Scope(\r\n            Description: \"Description1\",\r\n            Value: \"Value1\"),\r\n        new Scope(\r\n            Description: \"Description2\",\r\n            Value: \"Value2\")\r\n    },\r\n    IncludePermissionsInScopeClaim: true,\r\n    SkipConsentIfFirstParty: false,\r\n    AllowOfflineAccess: true,\r\n    TokenLifetimeSeconds: 10\r\n);\r\nvar request2 = new ApiCreateRequest(\r\n    Name: \"Joe\",\r\n    Identifier: \"1234\",\r\n    Scopes: new[]\r\n    {\r\n        new Scope(\r\n            Description: \"Description1\",\r\n            Value: \"Value1\"),\r\n        new Scope(\r\n            Description: \"Description2\",\r\n            Value: \"Value2\")\r\n    },\r\n    IncludePermissionsInScopeClaim: true,\r\n    SkipConsentIfFirstParty: false,\r\n    AllowOfflineAccess: true,\r\n    TokenLifetimeSeconds: 10\r\n);\r\nConsole.WriteLine(request1.Equals(request2)); // prints false\r\n```\r\n\r\n```csharp\r\nvar scopes = new[]\r\n{\r\n    new Scope(\r\n        Description: \"Description1\",\r\n        Value: \"Value1\"),\r\n    new Scope(\r\n        Description: \"Description2\",\r\n        Value: \"Value2\")\r\n};\r\nvar request1 = new ApiCreateRequest(\r\n    Name: \"Joe\",\r\n    Identifier: \"1234\",\r\n    Scopes: scopes,\r\n    IncludePermissionsInScopeClaim: true,\r\n    SkipConsentIfFirstParty: false,\r\n    AllowOfflineAccess: true,\r\n    TokenLifetimeSeconds: 10\r\n);\r\nvar request2 = new ApiCreateRequest(\r\n    Name: \"Joe\",\r\n    Identifier: \"1234\",\r\n    Scopes: scopes,\r\n    IncludePermissionsInScopeClaim: true,\r\n    SkipConsentIfFirstParty: false,\r\n    AllowOfflineAccess: true,\r\n    TokenLifetimeSeconds: 10\r\n);\r\nConsole.WriteLine(request1.Equals(request2)); // prints true\r\n```\r\n\r\nThis is because it's using `EqualityComparer<T>` for each member. Arrays do not implement `IEquatable<T>`. So it'll use the default `Equals` method, which is reference equality.\r\n\r\nWomp womp"
      },
      {
        "user": "jameswoodley",
        "created_at": "2021-01-08T16:24:07Z",
        "body": "Makes so much sense now you spell it out, and I feel foolish. Thanks so much!"
      },
      {
        "user": "jbogard",
        "created_at": "2021-01-08T16:26:59Z",
        "body": "I had to pull it up in DotPeek to see what was happening, but it makes sense now."
      },
      {
        "user": "jameswoodley",
        "created_at": "2021-01-08T17:28:15Z",
        "body": "Is there something clever I can do in a .ForMember config to help this, or should I map without the scopes and manually copy?"
      },
      {
        "user": "jbogard",
        "created_at": "2021-01-08T17:40:13Z",
        "body": "Fundamentally, records do not support the behavior you want (removing AutoMapper from the equation). You have some options:\r\n\r\n- Use a collection type that DOES implement `IEquatable<T>` and uses `Enumerable.SequenceEquals`. I don't see one offhand so you'll likely need to create this yourself.\r\n- Override `Equals` and do what the decompiled stuff does, replacing the `EqualityComparer<T>.Default` part of the collection `SequenceEquals`\r\n\r\nDon't use AutoMapper to try to work around the design of Records, though, that's super confusing to anyone using it. You'd have to \"UseDestinationValue\" then mutate the array contents, which I DON'T think you'd want to do, that's super weird. Say you want to use `ReadOnlyCollection<T>` instead? This would all break."
      },
      {
        "user": "jameswoodley",
        "created_at": "2021-01-08T17:41:42Z",
        "body": "Yup I'm with you, I was hoping for a silver bullet that isn't there. All good. I'll find a way.\r\n\r\nThanks again for the help and digging into the framework, really appreciate it"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2021-02-14T00:20:21Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3548,
    "title": "Mapping an object with IEnumerable property does not work",
    "created_at": "2020-12-21T03:59:52Z",
    "closed_at": "2020-12-21T05:41:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3548",
    "body": "Why this does not work?\r\n```\r\npublic class Container<T>\r\n{\r\n    public IEnumerable<T> Items { get; set; }\r\n}\r\n\r\nvar containerX = new Container<X> { Items = new List<X>(...) };\r\nvar containerY = _mapper.Map<Container<Y>>(containerX);\r\n```\r\nI have `CreateMap<X, Y>()`  and this `_mapper.Map<Y>(x)` works but somehow for collection it does not.\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3548/comments",
    "author": "hiredgunhouse",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-12-21T05:41:45Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "hiredgunhouse",
        "created_at": "2020-12-22T19:48:15Z",
        "body": "Nevermind, that was PEBKAC, it actually works fine."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2021-01-24T00:53:47Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3545,
    "title": "Mapping with a constructor doesn't work if a target property is mapped using MapFrom",
    "created_at": "2020-12-10T17:26:35Z",
    "closed_at": "2020-12-10T17:47:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3545",
    "body": "### Source/destination types\r\n\r\n```csharp\r\nrecord Foo(int Id, string Name, string Description);\r\n\r\nrecord FooDto(int Id, string Name, string Text);\r\n```\r\n\r\n(I'm using records here, but I don't think it matters)\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\n    var mapper = new MapperConfiguration(cfg =>\r\n    {\r\n        cfg.CreateMap<Foo, FooDto>()\r\n            .ForMember(dto => dto.Text, o => o.MapFrom(f => f.Description));\r\n    }).CreateMapper();\r\n```\r\n\r\n### Version: 10.1.1\r\n\r\n### Expected behavior\r\n\r\nShould map successfully\r\n\r\n### Actual behavior\r\n\r\n> **ArgumentException**: FooDto needs to have a constructor with 0 args or only optional args. (Parameter 'type')\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\n    var foo = new Foo(123, \"hello\", \"test\");\r\n    var dto = mapper.Map<FooDto>(foo);\r\n```\r\n\r\n### Additional remarks\r\n\r\nIt works fine if `FooDto.Text` is renamed to `Description` and I remove the `ForMember(... MapFrom(...))` configuration, so I'm pretty sure that's what causing the problem.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3545/comments",
    "author": "thomaslevesque",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-12-10T17:47:03Z",
        "body": "You need `ForCtorParam`."
      },
      {
        "user": "thomaslevesque",
        "created_at": "2020-12-10T20:30:07Z",
        "body": "Oh! I had never noticed that method before. Thanks!"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2021-01-17T00:52:53Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3541,
    "title": "Nested relationships",
    "created_at": "2020-11-28T22:46:36Z",
    "closed_at": "2020-11-29T05:38:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3541",
    "body": "\r\n\r\n### Version: 10.1.1\r\n<!-- \r\n    Include the major/minor version (4.2.1, 5.2.0, 6.0.2 etc) \r\n    If you're using ProjectTo, also specify the EF Core or EF6 version.\r\n--> \r\n.NET 5\r\nAutoMapper 10.1.1\r\nAutoMapper.Extensions.Microsoft.DependencyInjection 8.1.0\r\n\r\n### Expected behavior\r\n\r\n<!-- What did you expect to happen? Or what used to happen in an older version? -->\r\nWhen projecting, it should fetch only the columns refered in the DTO like in **.net core 3.1**\r\n### Actual behavior\r\nAll the columns are being fetched and then mapped\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3541/comments",
    "author": "Joellao",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-11-29T05:38:12Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2021-01-03T00:34:23Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3539,
    "title": "Automapper for .Net 5",
    "created_at": "2020-11-24T17:37:00Z",
    "closed_at": "2020-11-24T17:41:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3539",
    "body": "When will automapper support .Net 5.0?",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3539/comments",
    "author": "wiwichu",
    "comments": [
      {
        "user": "jbogard",
        "created_at": "2020-11-24T17:41:26Z",
        "body": "It already does, and has supported it ever since `netstandard2.0`. So technically, it has since the first alpha ðŸ˜† "
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-12-27T00:29:24Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3535,
    "title": "hiï¼ŒIs it time to support  .net5",
    "created_at": "2020-11-14T13:57:31Z",
    "closed_at": "2020-11-14T14:04:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3535",
    "body": "hiï¼ŒIs it time to support  .net5",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3535/comments",
    "author": "lijingpan",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-11-14T14:04:07Z",
        "body": "We support .Net Standard, that means .net 5 too."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-12-20T00:23:20Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3530,
    "title": "Method mapping instead of property mapping",
    "created_at": "2020-10-26T15:18:09Z",
    "closed_at": "2020-10-26T15:19:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3530",
    "body": "Hi,\r\nSince a recent release we get different behavior when mapping two types:\r\n\r\n### Source/destination types\r\n\r\n```csharp\r\npublic class WFDelegation //Source type (of external dll)\r\n{\r\n   //other properties\r\n   public string ProcDefIDS { get; set; }\r\n\r\n   public string[] GetProcDefIDs();//implementation invisible of this method\r\n}\r\n\r\npublic class DelegationDto //Destination type\r\n{\r\n   //other properties\r\n   public string ProcDefIDS { get; set; }\r\n}\r\n\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\nCreateMap<WFDelegation, DelegationDto>();\r\n```\r\n\r\n### Expected behavior\r\n\r\nThe source object has ProcDefIDS as an empty string.\r\nWe expect destination object ProcDefIDS to be also an empty string.\r\nI would assume the property -> property mapping has a higher priority than the GetProperty() -> property mapping.\r\n\r\n### Actual behavior\r\nUsing version 10.1.1\r\n\r\ndestinationDto.ProcDefIDS = \"System.String[]\"\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\nvar result = Mapper.Map(wfDelegation, delegationDto);\r\n```\r\n\r\nPS: please don't judge me on the naming in the source class, I am not the developer of that code ;)\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3530/comments",
    "author": "ArnaudB88",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-10-26T15:19:15Z",
        "body": "#3523"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-11-29T00:20:11Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3513,
    "title": "UseDestinationValue() not working in in List<T>",
    "created_at": "2020-10-06T09:46:43Z",
    "closed_at": "2020-10-06T10:16:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3513",
    "body": "I have in a mapper profile of\r\nCreateMap<A_DTO, A> with UseDestinationValue for specific members.\r\n\r\nWhen trying to Mapper.Map<List<A_DTO>, List<A>>(source, value), \r\nThe UseDestinationValue() does not work. It simply sets with default of the type.\r\n\r\nAfter adding a CreateMap<List<A_DTO>, List<A>> it returned to work as expected.\r\n\r\nI don't know if it's a feature, but it feels like a bug...\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3513/comments",
    "author": "tamirzamo",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-10-06T10:16:14Z",
        "body": "I think this is better suited for StackOverflow."
      }
    ]
  },
  {
    "number": 3508,
    "title": "Automapper 8.0 migration to Automapper 10.0 has breaking changes for Map method",
    "created_at": "2020-09-29T20:51:41Z",
    "closed_at": "2020-09-30T03:31:09Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3508",
    "body": "I am migrating a project to .Net Core 3.1, as part of the migration I needed to upgrade Automapper packages. I am passing parameters via Items property to some of my Mappers but now that option is no longer available.\r\n\r\n`Claims = mapper.Map<List<UserClaimModel>>(source.Claims, options => { options.Items[\"createdBy\"] = createdBy; options.Items[\"updatedBy\"] = updatedBy; })`\r\n\r\nBut now the method Map is not receiving 2 arguments: **No overload for method 'Map' takes 2 arguments**\r\n\r\nThis is part of my ITypeConverter implementation\r\n\r\n`public class UserForCreationDto22UserModel : ITypeConverter<UserForCreationDto2, UserModel>\r\n    {\r\n        IUserAppService _userAppService;\r\n        private IHashingService _hashingService;\r\n\r\n        public UserForCreationDto22UserModel(IUserAppService userAppService, IHashingService hashingService)\r\n        {\r\n            _userAppService = userAppService;\r\n            _hashingService = hashingService;\r\n        }\r\n\r\n        public UserModel Convert(UserForCreationDto2 source, UserModel destination, ResolutionContext context)\r\n        {\r\n            try\r\n            {\r\n                var mapper = context.Mapper;\r\n                var createdBy = context.Items[\"createdBy\"] as string;\r\n                var updatedBy = createdBy;\r\n                var time = DateTime.Today;\r\n\r\n                var username = source.Claims.First(x => x.ClaimType == AppClaimTypes.Username).ClaimValue;\r\n\r\n                destination = new UserModel\r\n                {\r\n                    CreatedBy = createdBy,\r\n                    UpdatedBy = updatedBy,\r\n                    CreatedOn = time,\r\n                    UpdatedOn = time,\r\n\r\n                    Username = username,\r\n                    Password = _hashingService.CreateHash(Guid.NewGuid().ToString()),\r\n                    \r\n                    Claims = mapper.Map<List<UserClaimModel>>(source.Claims, options => { options.Items[\"createdBy\"] = createdBy; options.Items[\"updatedBy\"] = updatedBy; })\r\n                };\r\n            }\r\n            catch\r\n            {\r\n                return null;\r\n            }\r\n\r\n            return destination;\r\n        }\r\n    }`\r\n\r\nAny advice on how can I accomplish the same thing with Automapper 10.0?",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3508/comments",
    "author": "zinov",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-09-30T03:31:09Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "zinov",
        "created_at": "2020-09-30T03:35:41Z",
        "body": "There is no clear documentation for each Automapper upgrades that points to the correct way"
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-09-30T03:36:21Z",
        "body": "A PR is welcome."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-11-01T00:18:35Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3493,
    "title": "Mapping silently fails between two instances of the same type without a map",
    "created_at": "2020-09-03T18:52:03Z",
    "closed_at": "2020-09-04T05:03:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3493",
    "body": "### Source/destination types\r\n\r\n```csharp\r\npublic class Foo\r\n{\r\n    public int Bar { get; set; }\r\n}\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\nvar mapper = new MapperConfiguration(c => c.AddProfile<EmptyProfile>()).CreateMapper();\r\n\r\npublic class EmptyProfile : Profile\r\n{\r\n    public EmptyProfile() { }\r\n} \r\n```\r\n\r\n### Version: 10.0.0\r\n\r\n### Expected behavior\r\n\r\nEither an `AutoMapperMappingException` (due to the lack of map) or a successful mapping.\r\n\r\n### Actual behavior\r\n\r\nSilent failure to map between two instances of the same type when a map isn't defined.\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\npublic class EmptyProfile : Profile\r\n{\r\n    public EmptyProfile() { }\r\n} \r\n\r\npublic class Foo\r\n{\r\n    public int Bar { get; set; }\r\n}\r\n\r\n[Test]\r\nvoid Main()\r\n{\r\n    var mapper = new MapperConfiguration(c => c.AddProfile<EmptyProfile>()).CreateMapper();\r\n    var foo = new Foo(){Bar = 1};\r\n    var baz = new Foo();\r\n    mapper.Map(foo, baz); // does not throw AutoMapperMappingException\r\n    Assert.AreEqual(foo.Bar, baz.Bar); // fails\r\n}\r\n```\r\nAdding `CreateMap<Foo, Foo>();` to `EmptyProfile` causes the test pass.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3493/comments",
    "author": "brainbolt",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-09-04T05:03:21Z",
        "body": "Duplicate of #3480."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-10-11T00:23:45Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3491,
    "title": "ITypeConverter does not seem to work with null",
    "created_at": "2020-09-02T13:12:30Z",
    "closed_at": "2020-09-03T06:06:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3491",
    "body": "The code is simplified to only leave the essential parts.\r\n\r\n### Source/destination types\r\n\r\n```csharp\r\nclass ChildDto { public int A {get; set;} }\r\nclass MainDto { public ChildDto Child {get;set;} }\r\nclass ChildEntity { public int A {get;set;} = -1; }\r\nclass MainEntity { public ChildEntity Child {get;set;} }\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\nCreateMap<ChildDto,ChildEntity>()\r\n    .ConvertUsing<ChildConverter>();\r\nCreateMap<ParentDto,ChildEntity>()\r\n    .ConvertUsing<ParentConverter>();\r\n```\r\n\r\n### Type converters\r\n\r\n```csharp\r\npublic class ChildConverter : ITypeConverter<ChildDto, ChildEntity>\r\n{\r\n    ChildEntity ITypeConverter<ChildDto, ChildEntity>.Convert(\r\n        ChildDto source, ChildEntity destination, ResolutionContext context)\r\n    {\r\n        var entity = new ChildEntity();\r\n\r\n        if (source != null)\r\n            entity.A = child.A; // Else defaults to -1\r\n\r\n        AddToDatabase(entity);\r\n        return entity;\r\n    }\r\n}\r\n\r\npublic class ParentConverter : ITypeConverter<ParentDto, ParentEntity>\r\n{\r\n    ParentEntity ITypeConverter<ParentDto, ParentEntity>.Convert(\r\n        ParentDto source, ParentEntity destination, ResolutionContext context)\r\n    {\r\n        var entity = new ParentEntity\r\n        {\r\n            Child = context.Mapper.Map<ChildEntity>(source.Child),\r\n        };\r\n\r\n        AddToDatabase(entity);\r\n        return entity;\r\n    }\r\n}\r\n```\r\n\r\n### Version: 9.0.0\r\n\r\n### Expected behavior\r\n\r\n`b.Child` is populated with the default instance.\r\n\r\n### Actual behavior\r\n\r\n`b.Child` is `null`.\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\nvar a = new ParentDto(); // Child is null\r\nvar b = mMapper.Map<ParentEntity>(a);\r\nAssert.IsNotNull(b.Child);\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3491/comments",
    "author": "mc0re",
    "comments": [
      {
        "user": "mc0re",
        "created_at": "2020-09-02T13:13:40Z",
        "body": "Forgot to mention, the `ChildConverter` is called, and returns a non-null object."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-09-03T06:06:05Z",
        "body": "I think this is better suited for StackOverflow."
      }
    ]
  },
  {
    "number": 3489,
    "title": "Allow using PreConditions with ProjectTo in specific cases (Localization)",
    "created_at": "2020-08-26T05:37:16Z",
    "closed_at": "2020-08-26T05:58:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3489",
    "body": "**Use case**\r\n\r\nWe have an Entity model with localized properties and use any ORM (NHibernate in this example):\r\n\r\n```csharp\r\npublic class Product {\r\n  public virtual long Id {get; set;}\r\n  public virtual long NameEn {get; set;}\r\n  public virtual long NameIt {get; set;}\r\n  public virtual long NameRu {get; set;}\r\n}\r\n```\r\n\r\nand DTO model:\r\n\r\n```csharp\r\npublic class ProductDto {\r\n  public virtual long Id {get; set;}\r\n  public virtual long Name {get; set;}\r\n}\r\n```\r\n\r\nAlso we use ProjectTo to make mapping from Entity to DTO.\r\nSo now we need to map localized properties (NameEn, NameIt, NameRu) to single DTO property (Name) according to current UI culture. But here we have a problem because Automapper Queryable extension ignored PreConditions.\r\n\r\n**Proposal**\r\n\r\nSomething like this would be very helpful for us:\r\n\r\n```csharp\r\nthis.CreateMap<Product, ProductDto>()\r\n  .ForMember(d=>d.Name, m=>{\r\n    m.PreCondition(()=>Thread.CurrentThread.CurrentUICulture.ThreeLetterISOLanguageName == \"en\");\r\n    m.MapFrom(s=>s.NameEn);\r\n  }\r\n  .ForMember(d=>d.Name, m=>{\r\n    m.PreCondition(()=>Thread.CurrentThread.CurrentUICulture.ThreeLetterISOLanguageName == \"it\");\r\n    m.MapFrom(s=>s.NameIt);\r\n  }\r\n  .ForMember(d=>d.Name, m=>{\r\n    m.PreCondition(()=>Thread.CurrentThread.CurrentUICulture.ThreeLetterISOLanguageName == \"ru\");\r\n    m.MapFrom(s=>s.NameRu);\r\n  };\r\n```\r\n\r\nIn our case conditions are not based on source object and only tell either to map source property to concrette destination property or not to map.\r\n\r\n**Alternatives**\r\n\r\nWe can use conditions right in the query, but it's not a nice solution which leads to many code duplications. \r\n\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3489/comments",
    "author": "oleg-varlamov",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-08-26T05:58:43Z",
        "body": "Duplicate of #3360. This was discussed many times before, here and on SO. sometimes specifically about localization. You'll just have to choose one of the solutions people used before."
      },
      {
        "user": "oleg-varlamov",
        "created_at": "2020-08-26T06:20:39Z",
        "body": "Yes, I saw the thread #3360. But my request is different. That question was need conditional mapping based on source object, which means transform PreCondition expression to LINQ. But in my case LINQ hadn't to contain conditional expression.\r\n\r\nRegarding that there are many solutions for Localization, i think neither of these solutions would be as elegant as solution with Automapper."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-08-26T06:59:11Z",
        "body": "A `PreCondition` is smth that gets executed at map time. Apparently you want smth else altogether. If you cannot find what you want, you should ask a new question on SO."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-27T00:22:02Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3477,
    "title": "[Rant] Deprecating functionality should allow for backwards-compatibility",
    "created_at": "2020-08-12T14:22:29Z",
    "closed_at": "2020-08-12T14:50:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3477",
    "body": "I'd like to just make a polite suggestion.\r\n\r\nI am new to AutoMapper.  It seems like just the right tool for the job.  However, I am having an issue with learning how to utilize it as a total n00b.\r\n\r\nIt seems to me like functionality that shows up in a Stack Overflow post or YouTube video is non-existent in the latest version of the library.  \r\n\r\nThis makes learning to utilize the library for the first time a bit of a challenge.\r\n\r\nMy suspicion is that the creators of AutoMapper, as I can also see by discussions on Stack Overflow posts, tend to \"deprecate\" functionality by straight-up deleting said code from the library.  \r\n\r\nI think that, if this is true, then it is a bad practice as it does not support backwards-compatibility.  There are a lot of obsolete YouTube videos and SO posts out there now, due to missing overrides, static methods etc. which they teach.  \r\n\r\nThe best-practice is to deprecate functionality by marking it with an attribute, but otherwise leaving the code there.\r\n\r\nIt it curious to me why this practice is not adhered to.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3477/comments",
    "author": "astrohart",
    "comments": [
      {
        "user": "jbogard",
        "created_at": "2020-08-12T14:47:17Z",
        "body": "Because that's not best practice. The Obsolete attribute causes compiler warnings, and many folks turn warnings into errors, so it might as well be removed. Instead we use the upgrade guide for deprecated and removed calls.\n\nI asked the .NET team about this and that's what they recommended.\n\nWhat we can do better about is not adding APIs we don't want to support and just having a much higher bar since deleting is so disruptive."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:26:40Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3472,
    "title": "InvalidCastException when using ConvertUsing",
    "created_at": "2020-07-21T13:20:51Z",
    "closed_at": "2020-07-21T13:28:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3472",
    "body": "Hello,\r\n\r\nI am quite new to C# so this bug might be my misunderstanding of how AutoMapper works. However, the example below fails an unit test, which I would expect to succeed.\r\n\r\n\r\n### Source/destination types\r\n\r\n```csharp\r\nvar source = \"2020-01-01T10:10:00Z\";\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\n            var configuration = new MapperConfiguration(cfg =>\r\n            {\r\n                cfg.CreateMap<string, DateTime>()\r\n                    .ConvertUsing(source => DateTime.Parse(source, null, System.Globalization.DateTimeStyles.RoundtripKind));\r\n            });\r\n            var mapper = new Mapper(configuration);\r\n```\r\n\r\n### Version: 10.0.0\r\n\r\n### Expected behavior\r\n\r\nI expected the mapping to succeed. I would not expect there to be different between these calls\r\n\r\n### Actual behavior\r\n\r\nSystem.InvalidCastException : Unable to cast object of type 'System.Func`4[System.Object,System.Object,AutoMapper.ResolutionContext,System.DateTime]' ...\r\n\r\nSystem.InvalidCastException : Unable to cast object of type 'System.Func`4[System.Object,System.Object,AutoMapper.ResolutionContext,System.DateTime]' to type 'System.Func`4[System.Object,System.Object,AutoMapper.ResolutionContext,System.Object]'.\r\n   at AutoMapper.MapperConfiguration.GetExecutionPlan[TSource,TDestination](MapRequest mapRequest)\r\n   at AutoMapper.Mapper.MapCore[TSource,TDestination](TSource source, TDestination destination, ResolutionContext context, Type sourceType, Type destinationType, IMemberMap memberMap)\r\n   at AutoMapper.Mapper.Map(Object source, Object destination, Type sourceType, Type destinationType)\r\n   at AutoMapper.Mapper.Map(Object source, Type sourceType, Type destinationType)\r\n   at Medsol.StandardApi.Tests.Tests.Mapping.DateTimeMappingTests.Test_Runtime_Mapping() in <redacted>\r\n\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\n        [Fact]\r\n        public void Test_Runtime_Mapping()\r\n        {\r\n            var configuration = new MapperConfiguration(cfg =>\r\n            {\r\n                cfg.CreateMap<string, DateTime>()\r\n                    .ConvertUsing(source => DateTime.Parse(source, null, System.Globalization.DateTimeStyles.RoundtripKind));\r\n            });\r\n            \r\n            var mapper = new Mapper(configuration);\r\n            \r\n            var value = \"2020-01-01T10:10:00Z\";\r\n\r\n            // fails\r\n            mapper.Map(\r\n                value,\r\n                value.GetType(),\r\n                DateTime.UtcNow.GetType()\r\n            );\r\n\r\n            // fails\r\n            mapper.Map(\r\n                value,\r\n                value.GetType(),\r\n                typeof(DateTime)\r\n            );\r\n\r\n           // succeeds\r\n          mapper.Map<DateTime>(value);\r\n            \r\n        }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3472/comments",
    "author": "mkoppanen",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-07-21T13:28:15Z",
        "body": "Duplicate of #3455. You already found the workaround."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:26:44Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3470,
    "title": "Call to Map clears list property with ConstructUsing.",
    "created_at": "2020-07-20T13:29:21Z",
    "closed_at": "2020-07-20T13:35:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3470",
    "body": "### Source/destination types\r\n\r\n```csharp\r\n// Source\r\nclass Model1\r\n{\r\n    public List<int> Ints { get; set; }\r\n}\r\n\r\n// Dest\r\nclass Model2\r\n{\r\n    public Model2(List<int> ints)\r\n    {\r\n        Ints = ints;\r\n    }\r\n\r\n    public List<int> Ints { get; }\r\n}\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\ncfg.CreateMap<Model1, Model2>().ConstructUsing(x => new Model2(x.Ints));\r\n```\r\n\r\n### Version: 10.0.0\r\n\r\n### Expected behavior\r\n\r\nIn 9.0.0 the `Model1` and `Model2` instances their 'Ints' property both had the value of a `List<int>` containing `1`,`2`,`3`.\r\n\r\n### Actual behavior\r\n\r\nIn 10.0.0 the `Model1` and `Model2` instances their 'Ints' property are both EMPTY `List<int>`'s.\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\nvar model1 = new Model1()\r\n{\r\n    Ints = new List<int> { 1, 2, 3 }\r\n};\r\nvar model2 = mapper.Map<Model2>(model);\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3470/comments",
    "author": "JoasE",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-07-20T13:35:10Z",
        "body": "Duplicate of #3468."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:26:48Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3469,
    "title": "Support for IAsyncEnumerable<T> .NET Core 30",
    "created_at": "2020-07-17T14:48:08Z",
    "closed_at": "2020-07-17T18:44:55Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3469",
    "body": "I am trying to map a `IAsyncEnumerable<T>` list of entities to a regular `List<T>` without any database or IQueryable. The source entities come from an async cache store which does not support `IQueryable`. But there are more use cases when one wants to map an `IAsyncEnumerable<T>` to a non async enumerable.\r\n\r\n# Source/destination types\r\n\r\n### Mapping setup\r\n```csharp\r\n\r\nclass Source\r\n{\r\n    public int MyProperty { get; set; }\r\n}\r\n\r\nclass Dest\r\n{\r\n    public int MyProperty { get; set; }\r\n}\r\n\r\nIAsyncEnumerable<Source> asyncEnumerable = GetAllItemsAsync(...);\r\n\r\n```\r\n\r\n### Desired behavior\r\n\r\n```csharp\r\nList<Dest> result = _mapper.Map<IAsyncEnumerable<Source>, List<Dest>>(asyncEnumerable);\r\n```\r\n\r\nHowever this is not possible.\r\n\r\n### Workaround 1\r\n```csharp\r\nList<Dest> result = new List<Dest>();\r\nawait foreach (var item in asyncEnumerable)\r\n{\r\n    result.Add(_mapper.Map<Dest>(item));\r\n}\r\n```\r\n\r\n### Workaround 2\r\n```csharp\r\nList<Source> result = new List<Source>();\r\nawait foreach (var item in asyncEnumerable)\r\n{\r\n    result.Add(item);\r\n}\r\nList<Dest> result_new = _mapper.Map<List<Dest>>(result);\r\n```\r\n\r\nNeither one is clean enough. This is a mapping one might want to do in a single line.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3469/comments",
    "author": "yorickdewid",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-07-17T15:03:00Z",
        "body": "`Map` is sync, so write your own extension method? :)"
      },
      {
        "user": "yorickdewid",
        "created_at": "2020-07-17T18:04:39Z",
        "body": "Yeah already did that. Should did not be part of AutoMapper?"
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-07-17T18:44:55Z",
        "body": "No, there is nothing async in AM."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:26:49Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3464,
    "title": "Standardise APIs between type converters, value resolvers, and value converters",
    "created_at": "2020-07-15T08:59:39Z",
    "closed_at": "2020-07-15T18:03:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3464",
    "body": "Type converters:\r\n\r\n* allow the conversion operation to be specified either via an instance of an implementation of `ITypeConverter`, or a type parameter referring to an implementation of `ITypeConverter`, or an inline delegate\r\n\r\nValue resolvers:\r\n\r\n* allow the resolution operation to be specified either via an instance of an implementation of `IValueResolver`, or a type parameter referring to an implementation of `IValueResolver`, or a type (that may or may not implement `IValueResolver`)\r\n\r\nValue converters:\r\n\r\n* allow the conversion operation to be specified either via an instance of an implementation of `IValueConverter`, or a type parameter referring to an implementation of `IValueConverter`\r\n* states that it can be instantiated by the services locator by specifying a type parameter - is this identical to how it works with type converters?\r\n\r\nAs you can see, while all of these mechanisms share similarities in the way they are applied, there are also differences that make switching between them more difficult than it has to be (unnecessarily, IMO). For example, while I can define an inline delegate for a type converter, I cannot do the same for a value resolver.\r\n\r\nI'd like to understand the reason(s) for the differences in these APIs - is it due to performance concerns, the fact that they evolved separately, or...?\r\n\r\nDepending on the reasoning, I'd like to propose that the API for all three of these be standardised so that they behave like type converters.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3464/comments",
    "author": "IanKemp",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-07-15T09:23:06Z",
        "body": "What's the specific problem you're having? If smth is missing, we'll take a PR to add it."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-07-15T18:30:30Z",
        "body": "About the existing API-s, we've just released a major version, so no change there anytime soon."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:26:51Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3463,
    "title": "Missing ConfigurationProvider in Automapper 10.0.0",
    "created_at": "2020-07-12T11:35:03Z",
    "closed_at": "2020-07-13T11:44:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3463",
    "body": "Hello.\r\n\r\nIn earlier versions of Automapper I can use `context.Mapper.ConfigurationProvider.GetAllTypeMaps();` \r\nNow `ResolutionContext` doesn't contain `ConfigurationProvider`. I can't get `TypeMap[]` array and skip mapping unmapped pairs. And also I can't use `GetService/GetRequiredService` in the `ConstructUsing/ConvertUsing` methods for, for example, `MapperConfiguration` resolving.\r\nCould you explain the way to get `TypeMap[]` array now?\r\n\r\nThank you.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3463/comments",
    "author": "GoNextGroup",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-07-12T12:06:22Z",
        "body": "If you don't want validation, you should say so when creating the map."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-07-13T11:44:30Z",
        "body": "Anyway, you can always inject `IConfigurationProvider`, although you probably shouldn't."
      },
      {
        "user": "jbogard",
        "created_at": "2020-07-13T16:19:27Z",
        "body": "What exactly are you trying to do here?"
      },
      {
        "user": "GoNextGroup",
        "created_at": "2020-07-13T16:26:09Z",
        "body": "> What exactly are you trying to do here?\r\n\r\nI had this code:\r\n\r\n```\r\n            CreateMap<ICollection<UserProfile>, ShortLegalEntityInformationResponse>()\r\n                     .IncludeAllDerived()\r\n                     .ConvertUsing  ((src, dest, context) =>\r\n                     {\r\n                         if (dest == null) { dest = new ShortLegalEntityInformationResponse(); }\r\n\r\n                         var mapTypes = context.Mapper.ConfigurationProvider.GetAllTypeMaps();\r\n\r\n                         src.ForEach(elem =>\r\n                         {\r\n                             if (mapTypes.Any(x => x.SourceType.Equals(elem.GetType()) && x.DestinationType.Equals(dest.GetType())))\r\n                             {\r\n                                 context.Mapper.Map(elem, dest, elem.GetType(), dest.GetType());\r\n                             }\r\n                         });\r\n\r\n                         return dest;\r\n                     });\r\n```\r\n\r\nIt works in Automapper 9.0.0 but not in 10.0.0\r\nI need this code because I have a partial mapping for `UserProfile` derived classes. For example, I have only one mapping like this: `CreateMap<LegalEntityProfile, ShortLegalEntityInformationResponse>()`, but not for, for example, `DriverProfile` which both are derived from `UserProfile`. An `ICollection<UserProfile>` may contains both of `DriverProfile` and `LegalEntityProfile` objects. If I won't use check like this, I will get mapping error for unmapped `DriverProfile` to `ShortLegalEntityInformationResponse`."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-07-13T17:55:59Z",
        "body": "Just create a map from `UserProfile` to `ShortLegalEntityInformationResponse`. It doesn't have to do much, but it will simplify things."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:26:54Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3454,
    "title": "Compatibility issues with IdentityServer4.",
    "created_at": "2020-07-03T10:03:10Z",
    "closed_at": "2020-07-03T10:15:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3454",
    "body": "Was using version 10 this morning and just wanted people to know it does not play well with IdentityServer4. Probably on MS side to update though, but now you know ðŸ™‚ ",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3454/comments",
    "author": "devantler",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-07-03T10:14:03Z",
        "body": "It's a major version in the sense that it breaks binary compatibility, but other than that, there are no big changes."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:27:07Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3450,
    "title": "Question: Automapper map to self to perform recursive flatterning, is it supported?",
    "created_at": "2020-07-01T05:33:38Z",
    "closed_at": "2020-07-01T06:05:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3450",
    "body": "Hi\r\n\r\nI have a tree of objects. I would like to update the objects with some default values and flattening some propertied also.\r\nHowever, I do not want to create a new object, just update the existing.\r\nSo I though. Well I can do it with a mass of logic and recursion. Or I could try it with automapper. Basically map to self. And automapper might update the destination with the source. and perform the flatterning:\r\n\r\n### Source/destination types\r\n\r\n```csharp\r\npublic class Foo\r\n    {\r\n        public bool SomeBool { get; set; }\r\n        public IEnumerable<Bar> Bars { get; set; }\r\n    }\r\n    \r\n    public class Bar\r\n    {\r\n        public bool SomeBoolWithDefalting { get; set; }\r\n    }\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\nvar config = new MapperConfiguration(cfg =>\r\n            {\r\n                cfg.CreateMap<Foo, Foo>();\r\n                cfg.CreateMap<Bar, Bar>()\r\n                    .ForMember(dest => dest.SomeBoolWithDefalting, opt=>opt.MapFrom(src=>true));\r\n            });\r\n            var mapper = config.CreateMapper();\r\n\r\nvar foo = new Foo\r\n            {\r\n                Bars = new List<Bar> { new Bar() }\r\n            };\r\n            mapper.Map<Foo, Foo>(foo, foo);\r\n```\r\n\r\n### Version: \r\n9.0.0\r\n\r\n### Expected behavior\r\n\r\nI expected that Bars get updated with the default value. And foo and bars is the same object as before\r\n\r\n### Actual behavior\r\n\r\nBut all I got back is empty bars.\r\n\r\nif I:\r\n```c#\r\nvar newFoo = mapper.Map<Foo, Foo>(foo);\r\n```\r\nThen I get a new foo, with the bars updated.\r\n\r\n\r\nI know auomapper should be used to make new objects. But isn't. use case valid? performing flatterning on a destination only?\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n\r\n            var config = new MapperConfiguration(cfg =>\r\n            {\r\n                cfg.CreateMap<Foo, Foo>();\r\n                cfg.CreateMap<Bar, Bar>()\r\n                    .ForMember(dest => dest.SomeBoolWithDefalting, opt => opt.MapFrom(src => true));\r\n            });\r\n            var mapper = config.CreateMapper();\r\n\r\n            var foo = new Foo\r\n            {\r\n                Bars = new List<Bar> { new Bar() } \r\n            };\r\n            var newFoo = mapper.Map<Foo, Foo>(foo); //good bars, but new objects\r\n\r\n            mapper.Map<Foo, Foo>(foo, foo); //same foo, but no bars\r\n            Console.WriteLine(foo.Bars.First().SomeBoolWithDefalting);\r\n\r\n        }\r\n    }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3450/comments",
    "author": "generik0",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-07-01T06:05:16Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:27:09Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3444,
    "title": "Only map changed data?",
    "created_at": "2020-06-14T13:01:09Z",
    "closed_at": "2020-06-14T13:55:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3444",
    "body": "Hi,\r\n\r\nIs it possible to only apply mappigs where data (Member Value) has actually changed?\r\n\r\nSorry if there is an obvious answer. Solutions on stackoverflow appear to only apply to <= v6. \r\n\r\nIf possible, a global flag for a map would be great as opposed to having to test every member with some sort of Condition.\r\n\r\nDoes this make sense?\r\n\r\nThanks for the great work!\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3444/comments",
    "author": "VisualMicro",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-06-14T13:55:10Z",
        "body": "There isn't anything built in. You'll have to choose from the things people did before."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:27:20Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3441,
    "title": "Mapper not consistent between Start with and without debug",
    "created_at": "2020-06-08T11:42:36Z",
    "closed_at": "2020-06-08T12:27:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3441",
    "body": "\r\n### Source/destination types\r\n\r\n```csharp\r\npublic abstract class UpdateUserBase\r\n{\r\n    [Required]\r\n    public bool EmailEnabled { get; set; }\r\n\r\n    [Required]\r\n    public bool SMSEnabled { get; set; }\r\n\r\n    [Required]\r\n    public bool PushEnabled { get; set; }\r\n}\r\n\r\npublic class AvTimeZone\r\n{\r\n    [ValidateTimeZone]\r\n    public string Id { get; set; }\r\n    public string DisplayName { get; set; }\r\n}\r\n\r\npublic class UpdateUser : UpdateUserBase\r\n{\r\n\t[Required]\r\n\t[ValidateEnum]\r\n\tpublic Language Language { get; set; }\r\n\r\n\t[Required]\r\n\t[ValidateObject]\r\n\tpublic AvTimeZone TimeZone { get; set; }\r\n\r\n\t[Required]\r\n\tpublic string FirstName { get; set; }\r\n\r\n\t[Required]\r\n\tpublic string LastName { get; set; }\r\n\r\n\t[RegularExpression(@\"^(\\(?\\+?[0-9]*\\)?)?[0-9_\\- \\(\\)]*$\")]\r\n\tpublic string PhoneNumber { get; set; }\r\n\r\n\t[RegularExpression(@\"^(\\(?\\+?[0-9]*\\)?)?[0-9_\\- \\(\\)]*$\")]\r\n\tpublic string MobilePhoneNumber { get; set; }\r\n}\r\n\r\npublic class UpdateCompleteUser : UpdateUser\r\n{\r\n    public UpdateCompleteUser()\r\n    {\r\n        TimeZone = new AvTimeZone();\r\n    }\r\n    \r\n\t[Required]\r\n\t[EmailAddress]\r\n\tpublic string Email { get; set; }\r\n\r\n\t[ValidateEnum]\r\n\tpublic UserRole Role { get; set; }\r\n\r\n\t[Required]\r\n\t[ValidateObject]\r\n\tpublic AvTimeZone TimeZone { get; set; }\r\n}\r\n\r\npublic class DataModelUser \r\n{\r\n\t[Required]\r\n\tpublic Guid Id { get; set; }\r\n\r\n\t[Required]\r\n\tpublic string Email { get; set; }\r\n\r\n\t[Required]\r\n\tpublic string TimeZone { get; set; }\r\n\r\n\t[Required]\r\n\tpublic string UserName { get; set; }\r\n\r\n\t[Required]\r\n\tpublic string FirstName { get; set; }\r\n\r\n\t[Required]\r\n\tpublic string LastName { get; set; }\r\n\r\n\t[RegularExpression(@\"^(\\(?\\+?[0-9]*\\)?)?[0-9_\\- \\(\\)]*$\")]\r\n\tpublic string PhoneNumber { get; set; }\r\n\r\n\t[RegularExpression(@\"^(\\(?\\+?[0-9]*\\)?)?[0-9_\\- \\(\\)]*$\")]\r\n\tpublic string MobilePhoneNumber { get; set; }\r\n\r\n\t[Required]\r\n\tpublic UserRole Role { get; set; }\r\n\r\n\t[Required]\r\n\tpublic Language Language { get; set; }\r\n}\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\nCreateMap<UpdateMobileUser, DataModelUser >()\r\n    .ForPath(x => x.TimeZone.Id, opt => opt.MapFrom(src => src.TimeZone))\r\n    .ReverseMap();\r\n\r\nCreateMap<DataModelUser , UpdateCompleteUser>()\r\n    .ForPath(x => x.TimeZone.Id, opt => opt.MapFrom(src => src.TimeZone))\r\n    .ReverseMap()\r\n    .ForMember(x => x.UserName, opt => opt.MapFrom(src => src.Email));\r\n```\r\n\r\n### Version: 9.0.0\r\n\r\n### Expected behavior\r\n\r\nExpected `user.Email` there to be equal to `userToPatch.Email` and `user.Role` to be equal to `userToPatch.Role`\r\n\r\n### Actual behavior\r\n\r\nWhen I run with **Start without debugging** it's failing, so `Email` and `Role` are not being saved as expected. But when I run it with **Start debugging** and put breakpoints in the beginning so I go through all method step by step, until the end, then `user.Email` and `user.Role` are being set as expected.\r\n\r\nSome other times, it passes on both **Start without debugging** and on **Start debugging*. And the other times is failing for both of them.\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\npublic async Task PartiallyUpdateUser(Guid userId, JsonPatchDocument<UpdateCompleteUser> patchDoc)\r\n{\r\n    if(!TryGetDataModelUser(userId, out var user)) //returns DataModelUser object from DB\r\n    {\r\n        throw new KeyNotFoundException($\"User not found with id: {userId}\");\r\n    }\r\n\r\n    var userToPatch = _mapper.Map<UpdateCompleteUser>(user);\r\n\r\n    patchDoc.ApplyTo(userToPatch);\r\n\r\n    _mapper.Map(userToPatch, user); \r\n    // also tried explicitly writing which mappers to use, but still the same output\r\n    // _mapper.Map<UpdateCompleteUser, DataModelUser >(userToPatch, user); \r\n\r\n    Console.WriteLine(user.Email) //this is not equal to userToPatch.Email\r\n    Console.WriteLine(user.Role) //this is not equal to userToPatch.Role\r\n\r\n    await SaveChanges();\r\n}\r\n```\r\n\r\n\r\n### My current fix to make it work\r\n\r\n```csharp\r\npublic class UpdateCompleteUser : UpdateUserBase\r\n{\r\n    public UpdateCompleteUser()\r\n    {\r\n        TimeZone = new AvTimeZone();\r\n    }\r\n\r\n\t[Required]\r\n\tpublic string FirstName { get; set; }\r\n\r\n\t[Required]\r\n\tpublic string LastName { get; set; }\r\n\r\n\t[Required]\r\n\t[EmailAddress]\r\n\tpublic string Email { get; set; }\r\n\r\n\t[ValidateEnum]\r\n    public UserRole Role { get; set; }\r\n\r\n\t[RegularExpression(@\"^(\\(?\\+?[0-9]*\\)?)?[0-9_\\- \\(\\)]*$\")]\r\n\tpublic string PhoneNumber { get; set; }\r\n\r\n\t[RegularExpression(@\"^(\\(?\\+?[0-9]*\\)?)?[0-9_\\- \\(\\)]*$\")]\r\n\tpublic string MobilePhoneNumber { get; set; }\r\n\r\n\t[Required]\r\n\t[ValidateEnum]\r\n\tpublic Language Language { get; set; }\r\n\r\n\t[Required]\r\n\t[ValidateObject]\r\n\tpublic AvTimeZone TimeZone { get; set; }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3441/comments",
    "author": "ertanhasani",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-06-08T12:27:13Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:27:24Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3436,
    "title": "Conditionally block reverse map unflattening of a member?",
    "created_at": "2020-06-04T19:08:28Z",
    "closed_at": "2020-09-09T04:15:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3436",
    "body": "I want to block the reverse map unflattening of a destination member based on the value of a source member.  I thought I'd be able to do it like this:\r\n\r\n```\r\n    class TestEntity {\r\n        public int Id { get; set; }\r\n        public TestSubEntity SubEntity { get; set; }\r\n    }\r\n    class TestSubEntity {\r\n        public int Id { get; set; }\r\n        public string Name { get; set; }\r\n    }\r\n    class TestDto {\r\n        public int Id { get; set; }\r\n        public int SubEntityId { get; set; }\r\n        public string SubEntityName { get; set; }\r\n    }\r\n\r\n    public void TestMap() {\r\n        IMapper mapper = new MapperConfiguration(cfg => {\r\n            cfg\r\n                .CreateMap<TestEntity, TestDto>()\r\n                .ReverseMap()\r\n                .ForMember(ent => ent.SubEntity, opt => opt.Condition(dto => false)); // marker\r\n        }).CreateMapper();\r\n        var result = mapper.Map<TestEntity>(new TestDto {\r\n            Id = 123,\r\n            SubEntityId = 987,\r\n            SubEntityName = \"I'm a SubEntity!\"\r\n        }); // result.SubEntity is non-null; wanted null\r\n    }\r\n```\r\n\r\n... but as you can see, `SubEntity` gets mapped to a non-null value even though the condition is false.  Replacing the 'marker' line with the following gets the same result:\r\n\r\n```\r\n    .ForMember(ent => ent.SubEntity, opt => opt.PreCondition((Func<TestDto, bool>)(dto => false)));\r\n```\r\n\r\n... however replacing it with this does indeed cause `SubEntity` to be null (though allows no condition to be provided):\r\n\r\n```\r\n    .ForMember(ent => ent.SubEntity, opt => opt.Ignore());\r\n```\r\n\r\nIs there a way I can get it to be null on a certain condition?",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3436/comments",
    "author": "jez9999",
    "comments": [
      {
        "user": "jalvarezca",
        "created_at": "2020-09-08T23:56:50Z",
        "body": "When this happens to me I had to remove the `.ReverseMap()` option and add another CreateMap() on the other direcction manually, otherwise I will get a new instance of the subentity."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-09-09T04:15:12Z",
        "body": "I think this is better suited for StackOverflow."
      }
    ]
  },
  {
    "number": 3434,
    "title": "Cannot auto map ImmutableArray to regular array",
    "created_at": "2020-06-02T13:43:31Z",
    "closed_at": "2020-06-02T13:53:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3434",
    "body": "### Source/destination types\r\n\r\n```csharp\r\nImmutableArray<string>\r\nstring[]\r\n```\r\n\r\n### Version: 9.0.0\r\n<!-- \r\n    Include the major/minor version (4.2.1, 5.2.0, 6.0.2 etc) \r\n    If you're using ProjectTo, also specify the EF Core or EF6 version.\r\n--> \r\n\r\n### Expected behavior\r\n\r\n`ImmutableArray` should be automatically mapped to a regular array.\r\n\r\n### Actual behavior\r\n\r\nAn exception is thrown: ``System.ArgumentException: Expression of type 'System.Collections.Immutable.ImmutableArray`1[System.String]' cannot be used for parameter of type 'System.Collections.Generic.IEnumerable`1[System.String]' of method 'Int32 Count[String](System.Collections.Generic.IEnumerable`1[System.String])' (Parameter 'arg0')``\r\n\r\n### Steps to reproduce\r\n\r\nAny mapping from an ImmutableArray property to a regular array property.\r\n\r\nWorkaround is to add a `ForMember` to the map and call `.ToArray()` on the source property, but I'd rather not have to do this.\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3434/comments",
    "author": "qrjo",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-06-02T13:53:29Z",
        "body": "AM doesn't consider `ImmutableArray`. You'll have to handle that yourself."
      },
      {
        "user": "qrjo",
        "created_at": "2020-06-02T13:56:11Z",
        "body": "I noticed that. If possible, it should consider `ImmutableArray`. It's a built-in type of .NET Core 3.1 and will be in .NET 5."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:27:29Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3433,
    "title": "ProjectTo does not work with enum types",
    "created_at": "2020-06-02T11:30:18Z",
    "closed_at": "2020-06-02T12:07:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3433",
    "body": "### Source/destination types\r\n\r\n```csharp\r\n\r\npublic class AbortReason : ExtendableDto\r\n{\r\n        public AbortReasonValue Reason { get; set; }\r\n}\r\n\r\npublic class AbortReasonDto : ExtendableDto\r\n{\r\n        [JsonProperty(PropertyName = \"value\")]\r\n        [JsonConverter(typeof(StringEnumConverter))]\r\n        public AbortReasonValueDto Reason { get; set; }\r\n}\r\n\r\npublic enum AbortReasonValueDto\r\n{\r\n        [EnumMember(Value = \"none\")]\r\n        None = 0,\r\n\r\n        [EnumMember(Value = \"otherReason\")]\r\n        OtherReason = 1,\r\n\r\n        [EnumMember(Value = \"abortedByApplicant\")]\r\n        AbortedByApplicant = 2,\r\n\r\n        [EnumMember(Value = \"applicantAbandoned\")]\r\n        ApplicantAbandoned = 3\r\n}\r\n\r\npublic enum AbortReasonValue\r\n{\r\n        None = 0,\r\n        OtherReason = 1,\r\n        AbortedByApplicant = 2,\r\n        ApplicantAbandoned = 3\r\n }\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\nCreateMap<AbortReasonValueDto, AbortReasonValue>();\r\nCreateMap<AbortReasonValue, AbortReasonValueDto>();\r\n\r\nCreateMap<AbortReasonDto, AbortReason>();\r\nCreateMap<AbortReason, AbortReasonDto>();\r\n```\r\n\r\n### Version: 9.1.0.0\r\n\r\n### Expected behavior\r\n\r\nMapping enums should work properly when using QueryableExtension's ProjectTo<>().\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3433/comments",
    "author": "subseqenz",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-06-02T11:35:55Z",
        "body": "Write an EF LINQ query that does what you want."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-06-02T12:07:27Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "jbogard",
        "created_at": "2020-06-02T14:56:17Z",
        "body": "When debugging LINQ expressions, you MUST first confirm that the query works WITHOUT AutoMapper involved whatsoever. LINQ query expressions are very complex to work with, and we often find bugs in the LINQ query provider themselves.\r\n\r\nTo understand if this is AutoMapper's generation of the LINQ expression, or the query providers *interpretation* of the expression, you MUST isolate the expression first against the query provider.\r\n\r\nHence, \"write an EF query to do what you want\". If that EF query works, it's AutoMapper's bug. If it does not work, it's with the query provider."
      },
      {
        "user": "jbogard",
        "created_at": "2020-06-02T15:40:00Z",
        "body": "Before we fix a bug in the LINQ expression creation stuff, we have to confirm that the expression we're targeting is able to be executed in the first place. Part of what we're trying to do is build LINQ expressions that query providers can actually interpret successfully.\r\n\r\nFor this example, we could fix the bug but it results in an expression not possible to execute, so that's why we're looking for viable LINQ expression that does work. Our main target is EF Core's query provider, also, repository pattern or not.\r\n\r\nSo if you can, post an example that uses the Cosmos DB query provider with a manual `.Select` projection to validate that Cosmos DB at least can handle the manual projection. We then reverse engineer a successful projection's expression tree into how AutoMapper builds out an expression."
      },
      {
        "user": "jbogard",
        "created_at": "2020-06-02T17:21:33Z",
        "body": "> Look, lets not overcomplicate things by searching for a hypothetical issue in a provider considered well tested.\r\n\r\nOh you sweet summer child :) AutoMapper finds TONS of bugs in LINQ query providers. LINQ query providers are very often, if not always, the most complex areas of code for database SDK providers.\r\n\r\nA \"manual projection\" is you calling into the Cosmos DB, removing AutoMapper COMPLETELY from the mix.\r\n\r\nReplace your code that calls `ProjectTo` with `Select`. Also, something looks quite wonky, you're calling `await Task.FromResult`, that looks very very odd. Your method there shouldn't return a `Task<IQueryable>`, it should only return `IQueryable` and then your calling code would materialize and await the query with `ToListAsync` etc.\r\n\r\nI'm familiar with the repository pattern, I use it with Mongo and Cosmos DB as well. Typically, my repo exposes the provider-specific queryable, and then I do my additional filtering/projection in application code.\r\n\r\nSo, replace your `ProjectTo` with `Select` and confirm that it works."
      }
    ]
  },
  {
    "number": 3432,
    "title": "ProjectTo InvalidOperationException",
    "created_at": "2020-05-27T11:58:21Z",
    "closed_at": "2020-05-27T13:21:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3432",
    "body": "### Source/destination types\r\n\r\n```csharp\r\n// EF Core entities\r\n\r\npublic class Foo\r\n{\r\n    public int Id { get; set; }\r\n    public ICollection<FooTranslation> Translations { get; set; } = new List<FooTranslation>();\r\n    // other properties, not relevant to this issue\r\n}\r\n\r\npublic class FooTranslation\r\n{\r\n    public int FooId { get; set; }\r\n    public string Language { get; set; }\r\n    public string Name { get; set; }\r\n    public string Description { get; set; }\r\n}\r\n\r\n// DTOs\r\npublic class FooDto\r\n{\r\n    public int Id { get; set; }\r\n    public LocalizedText Name { get; set; }\r\n    public LocalizedText Description { get; set; }\r\n    // other properties, not relevant to this issue\r\n}\r\n\r\n// The dictionary key is the language\r\npublic class LocalizedText : Dictionary<string, string> { }\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\nCreateMap<Foo, FooDto>()\r\n    .ForMember(dto => dto.Name, o => o.MapFrom(f => f.Translations.ToLocalizedText(t => t.Name)))\r\n    .ForMember(dto => dto.Description, o => o.MapFrom(f => f.Translations.ToLocalizedText(t => t.Description)))\r\n```\r\n\r\n`ToLocalizedText` is a method that converts a list of `FooTranslation` to a `LocalizedText` (I can post the code if requested, but it's probably not relevant)\r\n\r\n### Version\r\nAutoMapper 9.0.0\r\nEF Core 3.1.3\r\n\r\n### Expected behavior\r\n\r\n`dbContext.Foos.ProjectTo<FooDto>(configurationProvider)` should work\r\n\r\n### Actual behavior\r\n\r\nIt throws an exception:\r\n\r\n> System.InvalidOperationException: When called from 'VisitLambda', rewriting a node of type 'System.Linq.Expressions.ParameterExpression' must return a non-null value of the same type. Alternatively, override 'VisitLambda' and change it to not visit children of this type.\r\n\r\n### Steps to reproduce\r\n\r\nProject Foo to FooDto in a EF query:\r\n\r\n```csharp\r\nvar dtos = await _dbContext.Foos.Project<FooDto>(_mapper.ConfigurationProvider);\r\n```\r\n\r\n---\r\n\r\nI realize that it looks like an EF issue rather than an AutoMapper issue, but bear with me for a moment.\r\n\r\nThe problem is probably that EF Core can't translate `ToLocalizedText` to SQL, which makes sense. But I *have* to use `ToLocalizedText`, because if I just do `MapFrom(f => f.Translations)`, it doesn't return the right thing.\r\n\r\nBasically, what I need is a way to specify that `Name` is mapped from `Translations`, so that the query has the right `Include`s, and also specify that the value should be converted using `ToLocalizedText`. But I can't put `ToLocalizedText` in the expression, since it can't translate to SQL.\r\n\r\nIs there a way to do that? i.e., specify separately:\r\n- where the value comes from (`Translations`)\r\n- how to convert it to the destination type\r\n\r\nI also tried this:\r\n\r\n```csharp\r\n.ForMember(dto => dto.Name, o => o.ConvertUsing(\r\n    new TranslationValueConverter<FooTranslation>(t => t.Name),\r\n    f => f.Translations));\r\n```\r\nBut it returns a different error: \r\n\r\n> System.Exception: Can't resolve this to Queryable Expression\r\n\r\nAm I just missing something obvious?",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3432/comments",
    "author": "thomaslevesque",
    "comments": [
      {
        "user": "thomaslevesque",
        "created_at": "2020-05-27T12:14:41Z",
        "body": "Basically, what I'm looking for is a `MapFrom` overload which lets me specify a conversion separately from the source member, i.e. something like this:\r\n\r\n```\r\n.ForMember(dto => dto.Name, o => o.MapFrom(\r\n    f => f.Translations,\r\n    translations => translations.ToLocalizedText(t => t.Name)));\r\n```\r\nThe first argument would be used for the Linq projection, the second would be applied after the results have been fetched from the DB.\r\n\r\nIs there already something in AutoMapper that would let me achieve this? Or is it a feature you'd consider adding?"
      },
      {
        "user": "jbogard",
        "created_at": "2020-05-27T12:32:38Z",
        "body": "This is not a feature that's possible to add to AutoMapper. Once we give the projection to the query provider, execution of the LINQ query is completely in the LINQ provider's hands:\r\n\r\n```csharp\r\n   var foos = await _dbContext\r\n        .Where(foo => foo.Bar > 3) // System.Linq.QueryableExtensions\r\n        .ProjectTo<FooDto>() // returns IQueryable\r\n        .ToListAsync(); // executed by the IQueryable.Provider\r\n```\r\n\r\nOnce you go `IQueryable`, your choices for intercepting or extending the query execution are completely determined by the `IQueryable.Provider`. Once execution is *finished*, then you can do post-processing on the server-side if you like (after `ToListAsync`).\r\n\r\nIf AutoMapper were to support what you suggest, we'd have to wrap query providers, execute their result, then transform the result and assign values once it's finished. And because each query provider is different, for N query providers we'd have to have N specific packages to that query provider.\r\n\r\nWe can do `ProjectTo` because ALL that's doing is calling `Select` on the underlying query provider. \r\n\r\nIn your code, I'd suggest doing your own post-processing of the value after calling `ToList`."
      },
      {
        "user": "thomaslevesque",
        "created_at": "2020-05-27T13:21:46Z",
        "body": "Thanks for the reply, @jbogard. I see the problem now.\r\n\r\n> In your code, I'd suggest doing your own post-processing of the value after calling `ToList`.\r\n\r\nYes, that's what I ended up doing."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:27:32Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3423,
    "title": "Map To Immutable Object With Differently Named Constructor Args",
    "created_at": "2020-05-19T23:07:21Z",
    "closed_at": "2020-05-20T04:40:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3423",
    "body": "Currently, when mapping objects using a constructor, the constructor arguments must match the source property name.  I have found this unintuitive.  Intuitively, I would expect that AutoMapper would look at the source object and my configurations and find an appropriate constructor without having to do any additional configuration.\r\n\r\n### Source/destination types\r\n\r\n```csharp\r\nclass Source\r\n{\r\n    public Source(int one, string two)\r\n    {\r\n        One = one;\r\n        Two = two;\r\n    }\r\n\r\n    public int One { get; private set; }\r\n    public string Two { get; private set; }\r\n}\r\n\r\nclass Destination\r\n{\r\n    public Destination(int one, string two2)\r\n    {\r\n        One = one;\r\n        Two2 = two2;\r\n    }\r\n\r\n    public int One { get; private set; }\r\n    public string Two2 { get; private set; }\r\n}\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\nCreateMap<Source, Destination>()\r\n      .ForMember(dest => dest.Two2, opt => opt.MapFrom(src => src.Two))\r\n```\r\n\r\n### Version: 9.0.0\r\n\r\n### Expected behavior\r\n\r\n`Destination` object is created using the available `Destination` constructor.\r\n\r\n### Actual behavior\r\n\r\nI have to either:\r\n1. Create a default constructor (or constructor with all optional args).\r\n2. Change the name of `two2` in the Destination constructor to `two` so it matches `Source.Two`.  Or create another constructor just for AutoMapper.\r\n3. Add `ForCtorParam()` call in my configuration.\r\n\r\nI would rather not have to do any of these.  It seems like AutoMapper should be able to figure it out without this.  Maybe it's not as straight forward as it seems, but if it can be done, I think it would go a long way to improve usability and be more intuitive for those of us who like to use immutable types.\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\nmapper.Map<Destination>(new Source(1, \"two\"));\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3423/comments",
    "author": "danadesrosiers",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-05-20T04:05:18Z",
        "body": "If you have a private setter, you don't need the constructor anymore. AM will use the setter. Without a setter, you can write an extension method that calls both `ForMember` and `ForCtorParam`."
      },
      {
        "user": "danadesrosiers",
        "created_at": "2020-05-20T19:19:15Z",
        "body": "Thank you for the quick response!\r\n\r\n> If you have a private setter, you don't need the constructor anymore.\r\n\r\nThis is only an option if the object never needs to be instantiated manually.  Also, when using nullable reference types in C# 8.0, you get warnings that non-nullable reference types are not instantiated.  For both of these reasons, this solution doesn't work for me.\r\n\r\n> you can write an extension method that calls both ForMember and ForCtorParam.\r\n\r\nThat sounds like a reasonable work around.  I'm going to move forward with that.  \r\n\r\nI still suggest updating the library to make this easier.  I know it would have saved me a lot of time and confusion. "
      },
      {
        "user": "jbogard",
        "created_at": "2020-05-20T19:44:55Z",
        "body": "I'm not too concerned with nullable reference types, because you're far more likely to use C# 9.0 record types instead for those. We'll see what we need to do to support those :)"
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-06-24T18:11:08Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3419,
    "title": "AfterProjectionFrom<TSource>() extension method idea",
    "created_at": "2020-05-15T21:09:13Z",
    "closed_at": "2020-05-18T07:43:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3419",
    "body": "I know discussion around AfterMap and ProjectTo has come up a few times, and I think I understand most of the reasons why it's not possible, but I have an idea and I was wondering if you think it makes sense, if it's workable or something you would consider. I will walk through the specific angle I coming from.\r\n\r\nProblem:\r\nI have created a map between from TSource to TDestination. This mapping profile is used in a few places, both in memory with IMapper.Map and in SQL with the ProjectTo extension.\r\n\r\nOne member on TDestination is ignored as I want to populate it with a service after the mapping. I can use AfterMap and an IMappingAction to achieve this, but that won't work for ProjectTo. As a workaround, I can simply take the final TDestination or `List<TDestination>` after it's been materialised by EF and set the extra member(s) manually.\r\n\r\nHowever, I want to centralise the action performed after mapping in the map configuration/IMappingAction. However, I don't think there is a way to easily plug into that at the moment. How it might be used:\r\n\r\n```\r\ndbContext\r\n    .Products\r\n    .ProjectTo<ProductDto>\r\n    .ToList()\r\n    .AfterProjectionFrom<Product>()\r\n```\r\n\r\nAn AfterProjectionFrom extension would need to take the source type as that would be lost by the time we ToList(). The source type would allow it to look up the correct mapping configuration for the destination (which may be configured to be mapped from multiple source types). It would return the same type as it takes, e.g. in this case `List<ProductDto>()`\r\n\r\nThis could only support AfterMaps that only use the destination, as the source may never have been materialised in memory in such a query. Therefore a new mapping configuration method would be needed, e.g. AfterMapOrProjection, a more limited version of AfterMap which is compatible with both but which only lets you work against the destination object. Supporting that you'd need a new interface for implementing those actions where dependency injection is needed, e.g. IMappingOrProjectionAction, where again, the Process method doesn't have the source object as an argument.\r\n\r\nIt's still an extra step you have to take after using ProjectTo, but you don't need to know the specifics of the action at that point, just that you need to hook into AutoMapper again and let it handle it. This is particularly useful where you have a common generic method that lots of areas of your app use, and your query code actually looks more like:\r\n\r\n```\r\ndbContext\r\n    .Set<TSource>\r\n    .ProjectTo<TDestination>\r\n    .ToList();\r\n```\r\n\r\nSo being able to tag on an extra `AfterProjectionFrom<TSource>()` extension method in the shared generic query code means lots of areas that use it would no longer need to take those extra steps themselves. It centralises the actions taken in the mapping configuration, which are also performed when mapping is done in memory too.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3419/comments",
    "author": "stevendarby",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-05-16T04:22:48Z",
        "body": "You can write your own `ProjectTo` that calls AM and _then_ does what you need."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-06-24T18:18:23Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3417,
    "title": "How to use \"ConstructUsing\" with LambdaExpression in 9.0 Version",
    "created_at": "2020-05-14T05:07:51Z",
    "closed_at": "2020-05-14T05:55:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3417",
    "body": "Dear Friends,\r\n\r\nI lost some hours, so I want sharing with the community:\r\n\r\n```\r\nprivate IRegister ReturnConstruct(IRegisterViewModel registerViewModel)\r\n{\r\n    var type = (Type) Enum.Parse(typeof(Type), registerViewModel.GetType().ToString());\r\n    switch (type) {\r\n        case Type.AdditionalInclusion:\r\n            return new AdditionalInclusion();\r\n        case Type.DigitalRelationship:\r\n            return new DigitalRelationship();\r\n    }\r\n    return new Default();\r\n}\r\n\r\npublic MappingProfile() {\r\n    CreateMap<IRegisterViewModel, IRegister>()\r\n        .ConstructUsing(registerViewModel => ReturnConstruct(registerViewModel))\r\n        .ReverseMap();\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3417/comments",
    "author": "esdrasdemorais",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-05-14T05:55:32Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-06-24T18:50:20Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3416,
    "title": "One unusual mapping case",
    "created_at": "2020-05-13T16:40:13Z",
    "closed_at": "2020-05-13T16:50:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3416",
    "body": "Hi, all!\r\n\r\nWould you mind helping me to solve this quiz:\r\n\r\n### Source/destination types\r\n\r\n```csharp\r\n        public class SourceA\r\n        {\r\n            public int EntityId { get; set; }\r\n            public int Id { get; set; }\r\n            public int Other { get; set; }\r\n        }\r\n\r\n        public class DestinationA\r\n        {\r\n            public int Id { get; set; }\r\n            public int Other { get; set; }\r\n        }\r\n\r\n        public class SourceB { ... }\r\n        public class DestinationB { ... }\r\n        ...\r\n        public class SourceZ { ... }\r\n        public class DestinationZ { ... }\r\n```\r\nI have a dozen of Source and Destination classes, which follow the same property naming scheme: each Source has `Id` and `EntityId`, and each Destination has just `Id`.\r\nAll other properties (a lot) are named equally in Sources and Destinations.\r\n\r\nThe task is to completely omit `Id` value from `Source`, but use instead a value from `EntityId`! And, of course, all Other properties should be mapped as usual.\r\n\r\nI've been trying to configure AutoMapper Profile using out-of-box Conventions, custom `ISourceToDestinationNameMapper`, and so on, but neither of my approaches were success. \r\n\r\nIs there any way to ask AutoMapper to use some `SpecialEntityIdNameMapper` about that unusual `EntityId -> Id` mapping, which would have the highest priority among the all default mappers/conventions?\r\n\r\n### Version: 9.0.0\r\n\r\n### Expected behavior\r\n\r\nCustom convention tells AutoMapper how to map `EntityId` into `Id`, and all other properties are mapped using default conventions.\r\n\r\n### Actual behavior\r\n\r\nAll my attempts to write such convention (`ISourceToDestinationNameMapper`) ended with the same result: AutoMapper uses only its default conventions (`Id -> Id`), and my mapper event don't receive control. \r\n\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3416/comments",
    "author": "iamhere2",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-05-13T16:50:45Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-06-24T19:04:23Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3412,
    "title": "IgnoreAllPropertiesWithAnInaccessibleSetter interferes with ForCtorParam",
    "created_at": "2020-05-11T15:01:06Z",
    "closed_at": "2020-05-11T15:27:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3412",
    "body": "\r\n### Version: 9.0.0\r\n\r\n### Expected behavior\r\n\r\nMaybe I have misunderstood the intention of `IgnoreAllPropertiesWithAnInaccessibleSetter`, but my interpretation of it is to safeguard against AutoMapper constructing the destination object using the default constructor and then mapping to a private/protected setter. This is especially important to ensure encapsulation and valid invariants, i.e. that all validation in the destination object's constructor are run. So I would like to set `IgnoreAllPropertiesWithAnInaccessibleSetter` globally to ensure this never happens, but still be able to map to constructor parameters by name with `ForCtorParam`.\r\n\r\n### Actual behavior\r\n\r\nException is thrown, with message `Destination needs to have a constructor with 0 args or only optional args`.\r\n\r\n### Steps to reproduce\r\n\r\nYou can reproduce this with the existing unit test below. Just add `IgnoreAllPropertiesWithAnInaccessibleSetter` to it's config.\r\n\r\n```csharp\r\n    public class When_renaming_class_constructor_parameter : AutoMapperSpecBase\r\n    {\r\n        Destination _destination;\r\n\r\n        public class Source\r\n        {\r\n            public InnerSource InnerSource { get; set; }\r\n        }\r\n\r\n        public class InnerSource\r\n        {\r\n            public string Name { get; set; }\r\n        }\r\n\r\n        public class Destination\r\n        {\r\n            public Destination(InnerDestination inner)\r\n            {\r\n                InnerDestination = inner;\r\n            }\r\n\r\n            public InnerDestination InnerDestination { get; }\r\n        }\r\n\r\n        public class InnerDestination\r\n        {\r\n            public string Name { get; set; }\r\n        }\r\n\r\n        protected override MapperConfiguration Configuration => new MapperConfiguration(c =>\r\n        {\r\n            // Line below added\r\n            c.ForAllMaps((tm, me) => me.IgnoreAllPropertiesWithAnInaccessibleSetter());\r\n\r\n            c.CreateMap<Source, Destination>().ForCtorParam(\"inner\", o => o.MapFrom(s => s.InnerSource));\r\n            c.CreateMap<InnerSource, InnerDestination>();\r\n        });\r\n\r\n        protected override void Because_of()\r\n        {\r\n            _destination = Mapper.Map<Destination>(new Source { InnerSource = new InnerSource { Name = \"Core\" } });\r\n        }\r\n\r\n        [Fact]\r\n        public void Should_map_ok()\r\n        {\r\n            _destination.InnerDestination.Name.ShouldBe(\"Core\");\r\n        }\r\n    }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3412/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-05-11T15:13:35Z",
        "body": "If you don't want to use default constructors, don't have default constructors."
      },
      {
        "user": "ghost",
        "created_at": "2020-05-11T15:18:13Z",
        "body": "> If you don't want to use default constructors, don't have default constructors.\r\n\r\nI don't. But I was under the impression that AutoMapper can magically construct \"empty\" objects even when there is no default constructor? But if not, then it should be safe to assume that my single non-default constructor is always run, and no mappings occur to the properties of the class even when not setting `IgnoreAllPropertiesWithAnInaccessibleSetter`? What is the point then of having `IgnoreAllPropertiesWithAnInaccessibleSetter`? Is that some other use case?"
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-05-11T15:27:26Z",
        "body": "No, AM doesn't do such thing :) I have no insight on `IgnoreAllPropertiesWithAnInaccessibleSetter`. Perhaps find the initial PR."
      },
      {
        "user": "ghost",
        "created_at": "2020-05-11T15:29:15Z",
        "body": "Ok! Thanks for the quick reply! :)"
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-06-24T22:19:27Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3409,
    "title": "Ignore mapping of destination property not working",
    "created_at": "2020-05-08T20:01:11Z",
    "closed_at": "2020-05-09T04:25:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3409",
    "body": "### Source/destination types\r\n\r\n```csharp\r\npublic class RequestPutFeedbackDto {\r\n        public Guid Id { get; set; }\r\n        public Guid TrainingDetailId { get; set; }\r\n        public Guid ParameterId { get; set; }\r\n        public string ParameterName { get; set; }\r\n        [JsonIgnore]\r\n        public Guid ParticipantId { get; set; }\r\n        public int ParameterRating { get; set; }\r\n        public string ExtrasComments { get; set; }\r\n    }\r\n\r\npublic partial class ParticipantProgramFeedback\r\n    {\r\n        public Guid Id { get; set; }\r\n        public Guid TrainingDetailId { get; set; }\r\n        public Guid ParticipantId { get; set; }\r\n        public Guid ProgramParameterId { get; set; }\r\n        public int? ProgramParameterRating { get; set; }\r\n        public bool? HasRelevantContent { get; set; }\r\n        public bool? HasQualityContent { get; set; }\r\n        public DateTime? CreatedDate { get; set; }\r\n        public Guid? CreatedBy { get; set; }\r\n    }\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\nV1:\r\nCreateMap<RequestPutFeedbackDto, ParticipantProgramFeedback>()\r\n            .ForMember(x => x.TrainingDetailId, y => y.MapFrom(z => z.TrainingDetailId))\r\n            .ForMember(x => x.ProgramParameterId, y => y.MapFrom(z => z.ParameterId))\r\n            .ForMember(x => x.ParticipantId, opt=> opt.Ignore())\r\n            .ForMember(x => x.ProgramParameterRating, y => y.MapFrom(z => z.ParameterRating));\r\nV2:\r\nCreateMap<RequestPutFeedbackDto, ParticipantProgramFeedback>()\r\n            .ForMember(x => x.TrainingDetailId, y => y.MapFrom(z => z.TrainingDetailId))\r\n            .ForMember(x => x.ProgramParameterId, y => y.MapFrom(z => z.ParameterId))\r\n            .ForSourceMember(x => x.ParticipantId, opt=> opt.DoNotValidate())\r\n            .ForMember(x => x.ProgramParameterRating, y => y.MapFrom(z => z.ParameterRating));\r\n```\r\n\r\n### Version: 9.0.0\r\n\r\n### Expected behavior\r\n\r\nWhile Mapping it should ignore the already available value for property `ParticipantId` in destination object `ParticipantProgramFeedback`\r\n\r\n### Actual behavior\r\n\r\nEven after ignoring value from source in above code, it is considering value from Source object and mapping it to destination object. Sor\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\nActual Code : \r\n [HttpPut]\r\n        public async Task<IActionResult> PutAsync([FromBody]List<RequestPutFeedbackDto> requestPutFeedbackDto) {\r\n            if (ModelState.IsValid) {\r\n                Guid participantId = GetCurrentUserId();\r\n                Guid trainingDetailId = requestPutFeedbackDto.FirstOrDefault().TrainingDetailId;\r\n                IEnumerable<ParticipantProgramFeedback> existingProgramFeedback = await _feedbackService.GetProgramFeedbackParameter(trainingDetailId, participantId);\r\n                _mapper.Map(requestPutFeedbackDto, existingProgramFeedback);\r\n            }\r\n            return Ok();\r\n        }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3409/comments",
    "author": "shardulshende",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-05-09T04:25:07Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-06-24T22:34:44Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-06-24T22:35:31Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3407,
    "title": "DuplicateTypeMapConfigurationException due to MapperConfigurationExpression.AddMap(IEnumerable<Type>)",
    "created_at": "2020-05-06T17:12:04Z",
    "closed_at": "2020-05-06T18:56:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3407",
    "body": "I have multiple assemblies and each has multiple types derived from `AutoMapper.Profile` so that mappings are nicely organized.\r\n\r\nWhen creating the `MapperConfiguration` I used the `AddMaps(IEnumerable<Type>)` overload and passed all those derived types that are available in the current `AppDomain`.\r\n\r\nThen calling `AssertConfigurationIsValid()` throws `DuplicateTypeMapConfigurationException`.\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\npublic class DependencyModule : Module\r\n{\r\n    protected override void Load(ContainerBuilder builder)\r\n    {\r\n        // Here we collect all types that are\r\n        // - derived from AutoMapper.Profile and\r\n        // - loaded into the current AppDomain.\r\n        IEnumerable<Type> profileTypes = GetAutoMapperProfileTypes();\r\n\r\n        var mapperConfiguration =\r\n            new MapperConfiguration(\r\n                config =>\r\n                {\r\n                    config.AllowNullCollections = true;\r\n                    config.AddMaps(profileTypes);\r\n                }\r\n            );\r\n\r\n        // This throws DuplicateTypeMapConfigurationException.\r\n        mapperConfiguration.AssertConfigurationIsValid();\r\n\r\n        IMapper mapper = mapperConfiguration.CreateMapper();\r\n\r\n        builder.RegisterInstance(mapper);\r\n    }\r\n}\r\n```\r\n\r\n### Version: 8.1.1\r\n\r\n### Expected behavior\r\n\r\nThe expected behavior is `DuplicateTypeMapConfigurationException` not to be thrown.\r\n\r\n### Actual behavior\r\n\r\n`DuplicateTypeMapConfigurationException` was thrown and based on the exception message it seemed that the same assembly is loaded exactly `n` times where `n` is the number of types derived from `AutoMapper.Profile` in that specific assembly.\r\n\r\nIf skipping `mapperConfiguration.AssertConfigurationIsValid();` then no `Exception` is thrown.\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\n    private IEnumerable<Type> GetAutoMapperProfileTypes()\r\n    {\r\n        return new Type[]\r\n        {\r\n            typeof(CustomProfile1),\r\n            typeof(CustomProfile2)\r\n        };\r\n    }\r\n    \r\n    public class Entity1 { }\r\n    \r\n    public class Entity2 { }\r\n    \r\n    public class Model1 { }\r\n    \r\n    public class Model2 { }\r\n    \r\n    public class CustomProfile1 : AutoMapper.Profile\r\n    {\r\n        public CustomProfile1()\r\n        {\r\n            CreateMap<Entity1, Model1>();\r\n        }\r\n    }\r\n    \r\n    public class CustomProfile2 : AutoMapper.Profile\r\n    {\r\n        public CustomProfile2()\r\n        {\r\n            CreateMap<Entity2, Model2>();\r\n        }\r\n    }\r\n\r\n```\r\n\r\n### Suggested change\r\n\r\nChange `MapperConfigurationExpression.cs` as below:\r\n\r\nIn `AddMaps(IEnumerable<Type>)` method call `.Distinct()` after calling `.Select()`.\r\n\r\nSimilarly in `AddMapsCore(IEnumerable<Assembly>)` method call `.Distinct()` in between `.Where()` and `.SelectMany()`.\r\n\r\n### Remarks\r\n\r\nAs for `AddMaps(IEnumerable<Type>)` I might misused/misunderstood it but it might not be 100% obvious that to you should pass *only one type per assembly*. Otherwise, you risk `DuplicateTypeMapConfigurationException` to be thrown.\r\n\r\nAdding the above suggested `.Distinct()` calls help avoid `DuplicateTypeMapConfigurationException` that I think is worth thinking about.\r\n\r\nIf you like this idea then I would happily make this minor change.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3407/comments",
    "author": "gcsizmadia",
    "comments": [
      {
        "user": "jbogard",
        "created_at": "2020-05-06T17:16:26Z",
        "body": "Why are you adding the same assembly multiple times? It seems that you can call `Distinct` on your side before calling into AutoMapper.\r\n\r\nI don't like our code making those sorts of assumptions."
      },
      {
        "user": "gcsizmadia",
        "created_at": "2020-05-06T17:24:23Z",
        "body": "I don't add the same assembly multiple times. \r\n\r\nI add different types derived from `AutoMapper.Profile` that are in the same assembly hence your `AddMaps(IEnumerable<Type>)` overload selects the same assembly multiple times in the 74th line:\r\n`.Select(t => t.GetTypeInfo().Assembly)`"
      },
      {
        "user": "jbogard",
        "created_at": "2020-05-06T17:28:20Z",
        "body": "Oh, don't do that. Those types you pass in are types to match assemblies.\r\n\r\n@lbargaoanu I wonder if this is more confusing than helpful, should we only have methods that accept Assembly objects? It'll just force you to do `typeof(MyProfile).Assembly`."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-05-06T17:37:05Z",
        "body": "A lot of things can be confusing :) I vote to keep them. I'm sure I've seen this in some other library and I would guess it's pretty useful."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-05-06T17:42:07Z",
        "body": "The name of the parameter seems well chosen to me. But I guess we could rename it if there's a better idea."
      },
      {
        "user": "jbogard",
        "created_at": "2020-05-06T17:45:30Z",
        "body": "\"MarkerTypesForAssembliesButOnlyOneMarkerTypePerAssemblyPlease\""
      },
      {
        "user": "gcsizmadia",
        "created_at": "2020-05-06T17:46:28Z",
        "body": "I suspected I misunderstood the purpose of that method. :)\r\n\r\nAs for me I now use the `AddMaps(IEnumerable<Assembly>)` overload and it works well.\r\n\r\nRegarding the subject I'd suggest\r\n- either extending the XML comment for that method to make it clear(er) - should pass only one type per assembly!\r\n- or adding that `.Distinct()` call as a guard\r\n\r\nThe parameter name could remain as it is now."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-05-06T18:56:50Z",
        "body": "About the docs, a PR is welcome."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-06-24T23:16:30Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-06-24T23:16:48Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3404,
    "title": "AutoMapperMappingException when mapping EF Core lazy loaded proxy objects",
    "created_at": "2020-05-05T18:19:05Z",
    "closed_at": "2020-05-05T18:48:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3404",
    "body": "Hi,\r\n\r\nI'm using AutoMapper, Mediatr and EF Core in an .NET Core 3.1 API project.\r\nFor my EF Core DbContext, I configured lazy loading in Startup.cs:\r\n```csharp\r\nservices.AddDbContext<IMyDbContext, MyDbContext>(options =>\r\noptions\r\n  .UseLazyLoadingProxies()\r\n  .UseSqlServer(Configuration.GetConnectionString(\"MyConnStr\")));\r\n```\r\nIn a Mediatr command handler, I retrieve an entity from the db, alter it, save it to the db and map it to a DTO.\r\n```csharp\r\nawait context.SaveChangesAsync(cancellationToken);\r\nreturn mapper.Map<MyDto>(entity);\r\n```\r\nI'm getting a mapping error (AutoMapper.AutoMapperMappingException: Missing type map configuration or unsupported mapping) because the entity variable contains a proxy object in the form of an Castle.Proxies.MyEntityProxy object instead of a MyEntity object that I have a map for.\r\nI don't use projections here because I need to the entity object in order to change it.\r\n\r\nHow should I handle this optimally?\r\nI don't think I can add a map for the proxy object as it's created in runtime.\r\nI could retrieve the data again from the db, but that would mean an extra roundtrip.\r\n\r\nTia,\r\nNils",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3404/comments",
    "author": "ngruson",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-05-05T18:48:53Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-06-24T23:29:29Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-06-24T23:29:48Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3402,
    "title": "Conditional CreateMap",
    "created_at": "2020-05-04T11:33:29Z",
    "closed_at": "2020-05-04T18:05:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3402",
    "body": "\r\n### Feature description\r\n\r\nLet's suppose that we have to make an object mapping, this mapping has to be made based on a property of the source entity: type, for example. When the mapping is done through _mapper.Map<DestObj>(SrcObj) the condition should be evaluated and the mapping that fulfills this condition should be applied. In this way, the condition mapping of objects is facilitated.\r\n\r\nThis we can achive applying strategy pattern\r\n\r\n### Possible syntax\r\n\r\nWhen we are going to define the profiles:\r\n\r\n```csharp\r\nthis.CreateMap<SrcObj, DestObj>(src => src.Type == EnumType.Type1);\r\nthis.CreateMap<SrcObj, DestObj>(src => src.Type == EnumType.Type1);\r\n```\r\n\r\nWhen the Mapper.Map<DestObj>(srcObj) method is going to be executed it will check if there are mapping conditions available and will choose the one that fulfills that expression\r\n\r\n### Implementation\r\n\r\nI think the most appropriate way to implement it is to apply a strategic pattern.\r\n\r\n modifying the Profile.CreateMap method and the 'MappingExpression' class to allow adding an evaluation function:\r\n\r\n```csharp\r\nFunc<SrcObj, bool>\r\n```\r\n\r\nMultiple mappers are recorded that are the same but with different conditions will be added to a list of function expressions for when the IMapper method is executed.Map retrieve this list of functions and execute it: \r\n\r\n```csharp\r\nvar profile = conditions.FirstOrDefault(p => p.Invoke(srcObj))\r\n```\r\n\r\nThis is my opinion, I would like to know what you think about this functionality and the proposed implementation.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3402/comments",
    "author": "dlopezb93",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-05-04T18:05:09Z",
        "body": "This doesn't really fit. Maps depend only on the types, so they can be cached. But there's nothing stopping you from implementing that yourself, outside AM."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-06-24T23:54:04Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-06-24T23:55:49Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-06-24T23:56:04Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:27:14Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3398,
    "title": "Projects are not working for some reason",
    "created_at": "2020-04-30T13:18:11Z",
    "closed_at": "2020-04-30T13:32:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3398",
    "body": "I just Upgraded to .Net-Core 3.1, I'm using the latest Automapper.   My Projections are not working at all (sql and in memory).   This is my testing project and I'm connecting to a local MDF as a DB\r\n\r\nI'm trying to make a framework to abstract my Entity Layers,  However for this to work I need automapper projects to work so I can Query my DTO's instead of Querying the Entities\r\n\r\n    [TestMethod]\r\n    public async Task Verify_Mapping_Projection_Behavior()\r\n    {\r\n        var projectionModifier = \"Alabastar\";\r\n        var services = this.GetRegisteredRestEzServiceCollection();\r\n        var serviceProvider = services.BuildServiceProvider();\r\n        var context = (AstootContext)serviceProvider.GetService<DbContext>();\r\n\r\n        var config = new MapperConfiguration(cfg =>\r\n        {\r\n            cfg.CreateMap<User, UserDTO>().ForMember(x => x.FirstName, \r\n                o => o.MapFrom((entity, dto) => entity.FirstName + projectionModifier));\r\n        });\r\n\r\n        var mapper = config.CreateMapper();\r\n\r\n        // Hack: we'll verify exeuction happens in sql\r\n        // using the behavioral differene between in memory and sql (case insensitivity)\r\n        var sqlOnlyModifier = projectionModifier.ToUpper();\r\n        var userDTO = mapper.ProjectTo<UserDTO>(context.Users)\r\n            .Where(x => x.FirstName.Contains(sqlOnlyModifier))\r\n            .FirstOrDefault();\r\n\r\n        Assert.IsNotNull(userDTO);\r\n    }\r\n\r\nMy test failed, so I decided to materialize the projection directly. When I materialize I can see that my  `projectionModifier` is not being added to the firstName property.\r\n\r\nHow can I get the project to map my modifier, so that I can use my DTO's as Sql Queryables?",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3398/comments",
    "author": "granthoff1107",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-04-30T13:32:08Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "granthoff1107",
        "created_at": "2020-04-30T14:09:28Z",
        "body": "I didn't know you were part of the Automapper team, Thanks for the help on Stackoverflow  "
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:27:41Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3394,
    "title": "Option to disable ForAllOtherMembers",
    "created_at": "2020-04-24T05:18:40Z",
    "closed_at": "2020-04-24T05:57:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3394",
    "body": "Add the option to disable the ForAllOtherMembers extension, perhaps crash at runtime during startup.\r\n\r\nThis option has the potential to be abused, thus violating some AutoMapper best practices. I realize this is an odd request, but I'd rather leave a strict 'do not remove' comment around a single configuration line that disables this feature vs enforcing multiple mapping rules which get poorly mapped.\r\n\r\nYes this is a process problem on the team, but the reality is people forget and this keeps cropping up.\r\n\r\nAny other suggestions on how to enforce this dangerous usage?\r\n\r\n### Version: 9.x.x",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3394/comments",
    "author": "tomgruszowski",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-04-24T05:57:23Z",
        "body": " :) I would write a Roslyn analyzer."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-04-24T06:08:35Z",
        "body": "Perhaps you want to add smth useful in the documentation/xml docs."
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:27:47Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3386,
    "title": "MemberList.Source doesn't work with referenced objects",
    "created_at": "2020-04-22T00:41:08Z",
    "closed_at": "2020-04-22T03:38:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3386",
    "body": "### Source/destination types\r\n\r\n```csharp\r\npublic class A\r\n{\r\n    public string Text { get; set; }\r\n}\r\n\r\npublic class B\r\n{\r\n    public string Text { get; set; }\r\n\r\n    public string NotMapped { get; set; }\r\n}\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\nvar config = new MapperConfiguration(cfg =>\r\n{\r\n    cfg.CreateMap<A, B>(MemberList.Source)\r\n       .ForMember(b => b.Text, x => x.MapFrom(a => a.Text ?? string.Empty));\r\n});\r\n```\r\n\r\n### Version: 6.2.0+\r\n\r\n### Expected behavior\r\n\r\n`config.AssertConfigurationIsValid()` should not throw an exception.\r\n\r\n### Actual behavior\r\n\r\n`AutoMapperConfigurationException` was thrown with the following text:\r\n\r\n> Unmapped members were found. Review the types and members below. (...)\r\n=================================================\r\nA -> B (Source member list)\r\nUnmapped properties:\r\nText\r\n\r\n### Steps to reproduce\r\n\r\nIf I change `x.MapFrom(a => a.Text ?? string.Empty)` to `x.MapFrom(a => a.Text ?? \"\")`, it works without any problems.\r\n\r\nSo to reproduce the issue, a `MemberList.Source` must be used, then in a `ForMember` declaration an \"outside\" object should be used, even if it's a simple static member or a variable in the same scope.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3386/comments",
    "author": "btihanyi",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-04-22T03:38:48Z",
        "body": "I see your point, but that expression could be a lot more complicated, even involve more source members. I don't think we want to go there. If it's important to you, workaround it. Use a simple `MapFrom` and some other way to implement the logic you need. `AllowNullDestinationValues`, `NullSubstitute`, value transformers, type converters or anything else might fit :)"
      },
      {
        "user": "github-actions[bot]",
        "created_at": "2020-09-17T00:27:53Z",
        "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3377,
    "title": " Unmapped properties: Capacity",
    "created_at": "2020-04-16T10:26:55Z",
    "closed_at": "2020-04-16T10:51:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3377",
    "body": "hello\r\n\r\ni try to use AutoMapper for a project but whit this code\r\n\r\n`AutoMapper.Mapper.CreateMap<IDataReader, List<TResult>>();\r\n AutoMapper.Mapper.AssertConfigurationIsValid();\r\n`\r\n\r\ni have this error\r\n\r\n> AutoMapperConfigurationException: Unmapped members were found. Review the types and members below. Add a custom mapping expression, ignore, add a custom resolver, or modify the source/destination type ==================================================================================================================================================================================================================================================== IDataReader -> List`1 (Destination member list) System.Data.IDataReader -> System.Collections.Generic.List`1[[Databook.Services.DocumentiContabili.Controllers.WeatherForecastController+PivotResult, Databook.Services.DocumentiContabili, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]] (Destination member list) Unmapped properties: Capacity\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3377/comments",
    "author": "andry85mae",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-04-16T10:51:17Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-05-20T19:47:43Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3369,
    "title": "How can I map when I've property in my class which have default constructor to provide values ?",
    "created_at": "2020-04-01T20:47:33Z",
    "closed_at": "2020-04-02T04:29:34Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3369",
    "body": "My Entity class:\r\n\r\n```\r\npublic class User\r\n    {\r\n        public string Id { get; set; }\r\n\r\n        public string Name { get; set; }\r\n\r\n        public GeoLocation PurchaseLocationCoordinates { get; set; }\r\n    }\r\n```\r\n\r\nMy Dto class:\r\n\r\n```\r\npublic class UserDto\r\n    {\r\n        public string Id { get; set; } = Guid.NewGuid().ToString();\r\n\r\n        public string Name { get; set; }\r\n\r\n        public string PurchaseLocationLatitude { get; set; }\r\n\r\n        public string PurchaseLocationLongitude { get; set; }\r\n    }\r\n```\r\nGeoLocation class:\r\n\r\n```\r\npublic class GeoLocation\r\n    {\r\n        public GeoLocation(double lon, double lat)\r\n        {\r\n            Type = \"Point\";\r\n            if (lat > 90 || lat < -90) { throw new ArgumentException(\"A latitude coordinate must be a value between -90.0 and +90.0 degrees.\"); }\r\n            if (lon > 180 || lon < -180) { throw new ArgumentException(\"A longitude coordinate must be a value between -180.0 and +180.0 degrees.\"); }\r\n            Coordinates = new double[2] { lon, lat };\r\n        }\r\n\r\n        [JsonProperty(\"type\")]\r\n        public string Type { get; set; }\r\n        [JsonProperty(\"coordinates\")]\r\n        public double[] Coordinates { get; set; }\r\n\r\n        public double? Lat() => Coordinates?[1];\r\n        public double? Lon() => Coordinates?[0];\r\n    }\r\n```\r\n\r\nNow i want create a mapping from UserDto to User entity, please help me how can i achieve this. I've GeoLocation property in User entity how to map these properties. Can someone please give a solution with example?",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3369/comments",
    "author": "aliiqbalIntelligenes",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-04-02T04:29:34Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-05-05T21:52:36Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3367,
    "title": "How to reuse the existing mapping configuration when flatten an complex source to destination?",
    "created_at": "2020-03-29T16:17:02Z",
    "closed_at": "2020-03-29T16:30:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3367",
    "body": "I am trying to reuse the existing mapping configuration to flatten a complex source object, which is combined by two simple source objects, the configuration as below:\r\n```\r\n    public class Source1\r\n    {\r\n        public int Id { get; set; }\r\n        public string Source1Str { get; set; }\r\n    }\r\n    public class Source2\r\n    {\r\n        public int Id { get; set; }\r\n        public string Source2Str { get; set; }\r\n    }\r\n\r\n    public class ComplexSource\r\n    {\r\n        public Source1 Source1 { get; set; }\r\n        public Source2 Source2 { get; set; }\r\n    }\r\n\r\n    public class Dest\r\n    {\r\n        public string Source1Str { get; set; }\r\n        public string Source2Str { get; set; }\r\n    }\r\n\r\n    public class TestProfile : Profile\r\n    {\r\n        public TestProfile()\r\n        {\r\n            CreateMap<Source1, Dest>();\r\n            CreateMap<Source2, Dest>();\r\n            CreateMap<ComplexSource, Dest>();\r\n        }\r\n    }\r\n\r\n```\r\nwhen I am trying to project  `IQueryable<ComplextSouce>` To  `IQuerable<Dest>` , mapping did not happen:\r\n\r\n```\r\n     var dests =  (from s1 in _dbContext.Source1 \r\n        join s2 in _dbContext.Source2 on s1.Id equals s2.Id\r\n        select new ComplextObject\r\n        {\r\n            Source1 = s1,\r\n            Source2 = s2\r\n        }).ProjectTo<Dest>().ToList()\r\n\r\n```\r\nIt seems that  automapper unable figure out how to map ComplexSource to Dest, as a result I have to configure  each member of Dest to map from ComplexSourceï¼ŒIt is so tedious and unnecessary, how can I simplify this mapping configuration with as less code as possible",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3367/comments",
    "author": "LoremipsumSharp",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-03-29T16:30:57Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-05-05T22:00:21Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3350,
    "title": "Create configuration using expression tree",
    "created_at": "2020-03-19T13:51:29Z",
    "closed_at": "2020-03-19T14:44:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3350",
    "body": "### Source/destination types\r\n\r\n```csharp\r\nString -> Class.String  \r\nString -> Class.Class.String \r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\n// Mapper.Initialize or just the CreateMap snippet \r\n```\r\n\r\n### Version: 9.1.0\r\n<!-- \r\n    Include the major/minor version (4.2.1, 5.2.0, 6.0.2 etc) \r\n    If you're using ProjectTo, also specify the EF Core or EF6 version.\r\n--> \r\n\r\n### Expected behavior\r\nHello guys !\r\n\r\nI'm going through a little problem, i'm using automapper and creating maps from a Expression Tree or Reflection  but i'm not obtain success, i will explain the problem.\r\n\r\n### Actual behavior\r\n\r\nBasically in this code i'm trying pass a expression tree independent to type of property, but this exception occours in 'MapFrom': \r\nSystem.ArgumentOutOfRangeException: 'Only member accesses are allowed. dest => Convert(dest.Shipping.Method, Object) '\r\n\r\nExists a workarround for this ?\r\n### Steps to reproduce\r\n\r\n```csharp\r\n   var peDestination = Expression.Parameter(destination.GetType(), \"dest\");\r\n   var peSource = Expression.Parameter(source.GetType(), \"src\");\r\n\r\n    if (propertyMap.Destination.IndexOf('.') >= 0)\r\n    {\r\n         Expression destinationExpression = peDestination;\r\n         foreach (var navigatinoPropertieDestination in propertyMap.Destination.Split('.'))\r\n               destinationExpression = Expression.Property(destinationExpression,navigatinoPropertieDestination);\r\n\r\n          var sourceExpression = Expression.Property(peSource, propertyMap.Source);\r\n\r\nvar sourceMapFromExpression = Expression.Lambda<Func<TSource, object>>(                                \r\n  Expression.Convert(sourceExpression, typeof(object)), new ParameterExpression[] { peSource });\r\n\r\n     //// dest => dest.Property\r\n    var destinationMapFromExpression =\r\n                            Expression.Lambda<Func<TDestination, object>>\r\n                                (Expression.Convert(destinationExpression, typeof(object)), new ParameterExpression[] { peDestination });\r\n\r\nmap.ForPath(destinationMapFromExpression, a => a.MapFrom(sourceMapFromExpression));\r\n}\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3350/comments",
    "author": "gsgabrielsouza",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-03-19T14:44:39Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "gsgabrielsouza",
        "created_at": "2020-03-19T17:32:05Z",
        "body": "> I think this is better suited for StackOverflow.\r\n\r\nHello @lbargaoanu , I believe that this could be something incremental in the project, I opened the issue precisely for this discussion, because I attached and debugged it directly in the automapper project realizing that the problem is actually Cast, which is done in the 'GetMembers' method. The way I solved the problem was initially, validating if the node is an 'Expression.Convert' and if so, if there was a possibility to ignore it, and so it worked. I would like to know if this is in fact the best solution or if there is a possibility of opening a fork for this solution.\r\n\r\nA better way would be to check inside the node for some function call and ignore it."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-03-19T17:43:24Z",
        "body": "Let's continue on SO."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-03-20T18:48:33Z",
        "body": "@jbogard Perhaps this could be implemented with a string based `ForPath`. But I don't think we have much need for it and the complexity it entails."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-04-25T08:44:44Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3346,
    "title": "Automapper overwriting property with a setter.",
    "created_at": "2020-03-15T19:21:19Z",
    "closed_at": "2020-03-15T19:31:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3346",
    "body": "Automapper is overwriting a public property without a setter, from the documentation I believe this is not the expected behavior.  Is this a bug or am doing something wrong?\r\n\r\n`public Instant Created { get; }`\r\n\r\nJust to be clear, I want this property to be read by Automapper, but not written to.  It is in a BaseEntity class, so I would like to not have to Ignore() it explicitly in all the child class maps, and it seems like something that shouldn't require an extension method or something along those lines to accomplish.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3346/comments",
    "author": "tommymh",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-03-15T19:31:18Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "jbogard",
        "created_at": "2020-03-16T19:44:56Z",
        "body": "Are you mapping to an existing item? In that case we will not override the object, but we will override that object's properties. That's normal and expected behavior."
      },
      {
        "user": "tommymh",
        "created_at": "2020-03-16T19:45:42Z",
        "body": "No, to a new item where the property in question is set in the constructor.  Also thank you, I appreciate the quick response.\r\n"
      },
      {
        "user": "jbogard",
        "created_at": "2020-03-16T20:35:04Z",
        "body": "AutoMapper maps to constructors too - I think any further help, we'd need to see your source/destination types and usage."
      },
      {
        "user": "tommymh",
        "created_at": "2020-03-16T21:11:12Z",
        "body": "I will have to adjust my code a bit so I'm not exposing anything sensitive, I will update this issue with a code example shortly.  Would an example repo be the most helpful or should I just paste it directly in this thread?"
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-04-17T12:34:20Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3331,
    "title": "Properties of type T[][] work with Mapper.Map but not Mapper.ProjectTo",
    "created_at": "2020-02-24T15:27:47Z",
    "closed_at": "2020-02-24T15:49:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3331",
    "body": "### Source/destination types\r\n```csharp\r\npublic class Source\r\n{\r\n    public SrcValue[][] Value { get; set; }\r\n}\r\npublic class SrcValue\r\n{\r\n    public int Value { get; set; }\r\n}\r\n\r\npublic class Destination\r\n{\r\n    public DestValue[][] Value { get; set; }\r\n}\r\npublic class DestValue\r\n{\r\n    public int Value { get; set; }\r\n}\r\n```\r\n\r\n### Mapping configuration\r\n```csharp\r\ncfg.CreateMap<Source, Destination>();\r\ncfg.CreateMap<SrcValue, DestValue>();\r\n```\r\n\r\n### Version: 9.0.0\r\n\r\n### Expected behavior\r\n\r\nMapper.Map and Mapper.ProjectTo should behave the same way when mapping a source type to a destination type.\r\n\r\n### Actual behavior\r\nMapper.Map behaves as expected with the value property mapped correctly.\r\n\r\nAn Error is thrown when calling Mapper.ProjectTo\r\n_\"Missing map from SrcValue[] to DestValue[]. Create using CreateMap<SrcValue[], DestValue[]>\"_\r\n_\"at AutoMapper.QueryableExtensions.ExpressionBuilder.CreateMapExpressionCore(ExpressionRequest request, Expression instanceParameter, IDictionary`2 typePairCount, LetPropertyMaps letPropertyMaps, TypeMap& typeMap)\"_\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\n// setup\r\nvar source = new Source{ Value = new[] { new[] { new SrcValue{Value = 2} } }};\r\nvar queryableSource = new[] {source}.AsQueryable();\r\n\r\n// destination maps correctly\r\nvar destination = Mapper.Map<Destination>(source);\r\n\r\n// Error is thrown\r\ndestination = Mapper.ProjectTo<Destination>(queryableSource).First();\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3331/comments",
    "author": "NorfAlrin",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-02-24T15:49:45Z",
        "body": "For the most part `ProjectTo` only supports what EF6 supports, so that's expected."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-03-27T08:28:03Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3322,
    "title": "AutoMapper defaults to calling ToString() when converting DateTime",
    "created_at": "2020-02-17T16:34:43Z",
    "closed_at": "2020-03-10T06:36:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3322",
    "body": "\r\n### Source/destination types\r\n\r\n```csharp\r\n// Put your source/destination types here\r\nDateTime? source;\r\nstring destination = mapper.Map<string>(source);\r\n\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\n\r\n// No mapping\r\n\r\n```\r\n\r\n### Version: x.y.z\r\n\r\n6.1.1\r\n\r\n### Expected behavior\r\n\r\nAutomapper should emit a date in a round-trippable format like ISO-8601 Zulu time\r\n\r\n### Actual behavior\r\n\r\nAutomapper calls date.ToString(), which emits a date using current locale. This string is unusable outside UI code.\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\n// Your calls to Mapper.Map or ProjectTo here, with source/destination objects constructed\r\nDateTime? source = DateTime.Now;\r\nstring destination = mapper.Map<string>(source);\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3322/comments",
    "author": "vivainio",
    "comments": [
      {
        "user": "vivainio",
        "created_at": "2020-02-17T16:37:19Z",
        "body": "You can avoid this by creating an explicit mapping like:\r\n\r\n```csharp\r\ncfg.CreateMap<DateTime?, string>().ConvertUsing<DateTimeToPlainStringConverter>();\r\n```\r\n\r\n... but current behavior is potentially dangerous\r\n"
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-02-17T17:06:38Z",
        "body": "I see your point, but I'm not convinced. There's no contract here. cc @jbogard "
      },
      {
        "user": "jbogard",
        "created_at": "2020-02-18T14:04:09Z",
        "body": "Let's open a discussion on this one - I don't want to revisit every `ToString` but it's a warning that R# pops up to supply a culture.\r\n\r\nThis is potentially a breaking change to alter the default behavior, though.\r\n\r\nI don't know how one could decide the \"correct\" one, even round-trip versus one of the other standards is debatable"
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-02-18T14:12:12Z",
        "body": "Yes, and it's dead easy to change the default. You can even replace the default `StringMapper` with a custom version. The default seems reasonable to me. After all it's the default in the BCL too."
      },
      {
        "user": "vivainio",
        "created_at": "2020-02-18T15:07:55Z",
        "body": "\"Obviously\" correct format is the one used by JSON, I.e. ToString(\"o\"). Likewise, you would expect AutoMapper to use invariant culture in other places where formatting happens.\r\n\r\nI have no idea how format changes across versions can be done in AutoMapper though. Maybe some \"contrib\" package that opts in to most sensible defaults?"
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-02-18T15:26:18Z",
        "body": "Maybe for serialization, but certainly not for UI. What about all the people relying on this? It's not exactly a common complaint. After all, the main AM scenario is DB entity to UI."
      },
      {
        "user": "vivainio",
        "created_at": "2020-02-18T18:29:41Z",
        "body": "The behavior certainly seems more accidental than intentional.\r\n\r\nWe use AutoMapper to map between DB entities to DTOs. It's not up to DTOs to contain the \"final rendering\", this should happen based on end user locale (browser locale?), not the locale the server happens to be running in.\r\n\r\nIt may be that users rarely use string as target type, hence people haven't complained about this earlier. I stumbled on this while serializing between db entities and gRPC, taking the first stab by converting both dates and decimals to strings."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-02-18T19:29:17Z",
        "body": "It makes sense for the end user culture to be set on the thread serving the request. This seems a more reasonable default than what you're proposing. The breaking change makes it even clearer to me. But I guess AM cannot know what the right conversion is. Hence the extensibility."
      },
      {
        "user": "jbogard",
        "created_at": "2020-02-18T21:09:46Z",
        "body": "To me the only other \"reasonable\" default is `ToString(CultureInfo.InvariantCulture)`."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-02-19T05:51:11Z",
        "body": "I disagree :) I think the UI people should have priority. I would guess there are more of them too. The BCL made the same choice by having the no params overload use the current culture. Also, you can set the current culture to the invariant culture, but once you hard-code it in AM, they'll need type converters."
      },
      {
        "user": "vivainio",
        "created_at": "2020-02-19T06:28:48Z",
        "body": "For dates, InvariantCulture gives\r\n\r\n\"05/21/2014 22:09:28\" \r\n\r\ni.e. the US formatting which, among other things, is not sortable and doesn't preserve time zone information.\r\n\r\nWhen BCL made the choices it was a different time (.net was made for desktop applications), and those choices are probably not compatible with what people do nowadays.\r\n\r\nMaybe AutoMapper could bundle a \"formatter pack\" that would use invariant culture everywhere? This would make AutoMapper safer/eavier for server application developers, and you could opt into it by running a command."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-02-19T06:42:11Z",
        "body": "For web UI-s it's the same and .Net Core made the same choice."
      },
      {
        "user": "vivainio",
        "created_at": "2020-02-19T07:20:04Z",
        "body": "Web UI's often consume json and the format of DateTime in both system.text.json and newtonsoft (i.e. both old aspnet and aspnetcore) is ToString(\"o\"), i.e. conforming to ISO 8601 standard.\r\n\r\nNetcore couldn't break compatibility there for obvious reasons."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-02-19T08:06:33Z",
        "body": "It's not about json here, it's about .net types, any serializer can do its own stuff. And yes, backward compatibility :)"
      },
      {
        "user": "vivainio",
        "created_at": "2020-02-19T08:40:29Z",
        "body": "Serializer cannot behave sensibly if data is not in normalized format. Culture sensitive rendering  of data is essentially corrupt and only useful for showing to the end user. IMHO of course.\r\n\r\nThat being said, do you still see value for culture insensitive mappers as an add-on to default behavior? What would that API look like?\r\n"
      },
      {
        "user": "lbargaoanu",
        "created_at": "2020-02-19T09:02:37Z",
        "body": "You should let the serializer convert objects to string and use AM to map .net types. I think ad-hoc solutions are best here. AM is not a serialization library and it's general enough that it couldn't possibly cover all cases. @jbogard might see it differently :)"
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-04-15T07:43:17Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3316,
    "title": "Why is ForAllOtherMembers void?",
    "created_at": "2020-02-06T19:28:28Z",
    "closed_at": "2020-02-07T05:02:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3316",
    "body": "### Version: 9.0.0\r\n\r\n### Actual behavior\r\n\r\n`ForAllMembers` and `ForAllOtherMembers` are really helpful things, but they do not return an `IMappingExpression` like all the other methods do. Which makes it impossible to call `ReverseMap` after them. Is this behaviour intentional or an oversight?\r\n\r\nIf intentional - can I call `ReverseMap` on the expression passed on to `ForAllOtherMembers`?",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3316/comments",
    "author": "mc0re",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-02-06T19:48:21Z",
        "body": "It's intentional. They don't compose with most other configuration. You cannot call `ForMember` again. You can call `ReverseMap` as you've said. Or just create that map yourself, without `ReverseMap`."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-03-10T18:47:13Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3313,
    "title": "Mapping from interface to concrete class not working",
    "created_at": "2020-02-04T09:50:53Z",
    "closed_at": "2020-02-04T10:01:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3313",
    "body": "Hi,\r\n\r\nBelow are my sample code\r\n\r\npublic void Interface IPerson\r\n{\r\n DateTimeOffset DOB { get; set ;}\r\n}\r\n\r\npublic class Person : IPerson\r\n{\r\npublic string Name { get; set; }\r\n\r\npublic DateTimeOffset DOB { get; set; }\r\n}\r\n\r\nPublic class Man\r\n{\r\npublic string Name { get; set; }\r\n\r\npublic DateTime DOB { get; set; }\r\n}\r\n\r\nAbove are the example classes in my project. Now, I am trying to Map between IPerson to Man. Unfortunately DOB is not getting mapped.\r\nPlease check below mapping configuration.\r\n\r\npublic class PersonProfile : Profile\r\n    {\r\n        public PersonProfile()\r\n        {\r\n            this.CreateMap<IPerson, Man>()\r\n                .ForMember(dest => dest.DOB, opt => opt.MapFrom(src => src.DOB.UtcDateTime));\r\n        }\r\n    }\r\n\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3313/comments",
    "author": "viswateja499",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-02-04T10:01:10Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-03-10T18:47:37Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3301,
    "title": "How to preserve values in destination using auto mapper in .net core",
    "created_at": "2020-01-16T07:25:41Z",
    "closed_at": "2020-01-16T08:03:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3301",
    "body": "We are using AutoMapper (9.0.0) in .net core for mapping values between source and destination. Till time this is working fine. However, we need to keep some of the values in destination as it is after mapping.\r\n\r\nWe have tried to used UseDestinationValue() and Ignore() methods on member, but it is not preserving the existing values. Below is the code for the same.\r\n\r\nRequestModel\r\n\r\n```\r\npublic class RequestModel\r\n{\r\n    public int Id { get; set; }\r\n    public int SubmittedById { get; set; }\r\n    public string Description { get; set; }\r\n    public string Location { get; set; }\r\n}\r\n```\r\nRequestDto\r\n\r\n```\r\npublic class RequestDto\r\n{\r\n    public int Id { get; set; }\r\n    public int SubmittedById { get; set; }\r\n    public string Description { get; set; }\r\n    public string Location { get; set; }\r\n    public string SubmittedByName { get; set; }\r\n}\r\n```\r\nWe are accepting Dto in API as request parameter API\r\n\r\n```\r\n[HttpPost]\r\n        public IActionResult Save([FromBody] RequestDto requestDto)\r\n        {\r\n           // Some logic to save records\r\n        }\r\n```\r\nSo, before saving the records we are mapping RequestDto to RequestModel and passing that model to DAL layer to save the records like this\r\n\r\n`var requestModel = MapperManager.Mapper.Map<RequestDto, RequestModel>(RequestDto);`\r\n\r\nAnd call to data layer\r\n\r\n`var requestModel = DAL.Save(RequestModel)`\r\nSo, after receiving the updated request model we are again mapping it to requestDto, in this case we are loosing the value for SubmittedByName property.\r\n\r\n`return MapperManager.Mapper.Map<RequestModel, RequestDto>(requestModel);`\r\nMapper Class\r\n\r\n```\r\npublic class RequestProfile: Profile\r\n{\r\n     public RequestProfile()\r\n       {\r\n           CreateMap<RequestModel, RequestDto>()\r\n           CreateMap<RequestDto, RequestModel>()\r\n       }\r\n}\r\n```\r\nThis SubmittedByName column is not present in the Request table, but we want to utilize its value after saving the records.\r\n\r\nSo, how can we preserve the destination value after mapping.\r\n\r\nAny help on this appreciated !",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3301/comments",
    "author": "rpundlik",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-01-16T08:03:06Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-02-16T09:46:19Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3298,
    "title": "Ignore Attribute with AutoMap Reverse Attribute not working? ",
    "created_at": "2020-01-10T15:07:36Z",
    "closed_at": "2020-01-13T08:13:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3298",
    "body": "Dear fellows and @jbogard ,\r\n\r\nIÂ´m struggling to get a mapping works.\r\n\r\nI have a property that is Ignored with Ignore Attribute in a DTO with AutoMap Reverse.\r\n\r\nWhen I try to get from DTO to entity, seem like the ignored attribute is being copied to destiny Entity, wouldnÂ´t it be left on copy when source (dto) has the ignore map?\r\n\r\n[AutoMap(typeof(User))] \r\npublic class UserDto { \r\npublic string Name { get; set; }\r\n[Ignore]\r\npublic string Password { get; set; }\r\n}\r\n_mapper.Map(dto,user); <-- Password is being copy to user, should that happens?\r\n\r\nThanks in advance",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3298/comments",
    "author": "lixaotec",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2020-01-10T15:15:35Z",
        "body": "Make a test without attributes. That's the intended behavior."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-02-13T08:53:02Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3292,
    "title": "Support for AfterProject",
    "created_at": "2019-12-24T10:09:28Z",
    "closed_at": "2019-12-24T11:29:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3292",
    "body": "Hi,\r\n\r\nIs there any support for `AfterProject` coming soon, similar to `AfterMap`?\r\n\r\nI have some custom properties which are calculated based on some business rules after the data is fetched from database ðŸ˜„ ",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3292/comments",
    "author": "ajayak",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-12-24T11:29:15Z",
        "body": "No, ProjectTo only supports what the EF provider can do."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-01-24T12:29:39Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3289,
    "title": "Attribute Mapping strategy in a DDD Environment (question / best practices)",
    "created_at": "2019-12-20T13:24:00Z",
    "closed_at": "2019-12-20T15:26:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3289",
    "body": "Dear @jbogard and fellows,\r\n\r\nIÂ´m strugglin to adopt Attribute mapping strategy (latest versions feature).\r\n\r\nIn a DDD scenario I have all my entities in a domain 'layer', and my DTO were moved to a crosscutting layer (in order to share with appservices and repository), iÂ´ll picture it bellow.\r\n\r\nHowever to adopt mapping strategy I would have to reference my domain in the crosscutting layer, what leads me to a circular reference, once mt domain already references my crosscutting.\r\n\r\nSo what would should be done in this case? How to order my dependencies?\r\n\r\n```\r\n1-Api Controllers                                           --> 5 - CrossCutting\r\n                V\r\n2-App Services                                              --> 5 - CrossCutting\r\n                V             |        V\r\n3-Domain Services (entities)   4. Repository                --> 5 - CrossCutting (both 3 and 4 needs)\r\n\r\n```\r\n\r\nSo my DTO are moved to 5.Crosscutting in order to have their translation at app and projections at repository.\r\n\r\nMy entities are definied at 3.Domain Services.\r\n\r\nWhen I try to reference domain to crosscuttin so I can use attribute mapping I get stuck. \r\nShould I move my entities to CrossCutting?\r\n\r\n[AutoMap(typeof(Order))] <-- 3.Domain\r\npublic class OrderDto { <-- 5-Crosscutting\r\n   [SourceMember(\"OrderTotal\")]\r\n   public decimal Total { get; set; }\r\n\r\nThanks in advance.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3289/comments",
    "author": "lixaotec",
    "comments": [
      {
        "user": "lixaotec",
        "created_at": "2019-12-20T14:03:31Z",
        "body": "Totally non-sense what I have done, \r\n\r\nDTO should never be at CrossCutting, they must stay at appservices, where domain is known.\r\n\r\nHovewer how could repository know appservices?"
      },
      {
        "user": "jbogard",
        "created_at": "2019-12-20T15:15:34Z",
        "body": "This sounds like a lot of layers - I just use AutoMapper to project from domain model to DTO. More than that is overkill for a single application."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-01-24T11:21:59Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3285,
    "title": "Updating property on owned entity doesn't set it as Modified",
    "created_at": "2019-12-16T06:16:47Z",
    "closed_at": "2019-12-16T06:30:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3285",
    "body": "In EF Core 3.1, using AutoMapper to update an entity with an owned type does not trigger EF Core's change detection.\r\n\r\nThis issue was not present in EF Core 2.2.\r\n\r\n### Source/destination types\r\n\r\n```csharp\r\npublic class SomeOwnedType\r\n{\r\n    public string SomeString { get; set; }\r\n}\r\n\r\npublic class SomeEntity\r\n{\r\n    public SomeOwnedType Something { get; set; } = new SomeOwnedType();\r\n\r\n    public DateTime? UpdatedAt { get; set; }\r\n}\r\n\r\npublic class SomeEntityForm\r\n{\r\n    public SomeOwnedType Something { get; set; }\r\n\r\n    public DateTime? UpdatedAt { get; set; }\r\n}\r\n\r\npublic class MyContext : IdentityDbContext<...>\r\n{\r\n    public DbSet<SomeEntity> Entities { get; set; }\r\n\r\n    protected override void OnModelCreating(ModelBuilder builder) =>\r\n        builder.Entity<SomeEntity>().OwnsOne(e => e.Something);\r\n}\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\nCreateMap<SomeEntity, SomeEntityForm>()\r\n    .ReverseMap()\r\n    .ForMember(dest => dest.UpdatedAt, opt => opt.Ignore())\r\n    .ForMember(dest => dest.Something, opt => opt.UseDestinationValue());\r\n\r\nCreateMap<SomeOwnedType, SomeOwnedType>();\r\n```\r\n\r\n### Version: 9.0.0 on EF Core 3.1\r\nAutoMapper.Collection 5.0.0\r\nAutoMapper.Extensions.Microsoft.DependencyInjection 7.0.0\r\n\r\n### Expected behavior\r\n\r\n```csharp\r\nvar form = ...;\r\nvar entity = ...;\r\n\r\nmapper.Map(form, entity);\r\nentity.UpdatedAt = DateTime.Now;\r\n\r\ncontext.Entities.Update(entity);\r\n\r\nvar changes = context.ChangeTracker.Entries();\r\n// entity -> Modified\r\n// entity.Something -> Modified\r\n```\r\n\r\n### Actual behavior\r\n\r\n```csharp\r\nvar form = ...; // Something.SomeString = \"qwerty\"\r\nvar entity = ...; // Something.SomeString = \"abcde\"\r\n\r\nmapper.Map(form, entity);\r\n// entity.Something.SomeString = \"qwerty\"\r\n\r\ncontext.Entities.Update(entity);\r\n\r\nvar changes = context.ChangeTracker.Entries();\r\n// entity -> Modified\r\n// no entry for entity.Something\r\n```\r\n\r\n### Steps to reproduce\r\n\r\nAs above in `Expected behaviour`.\r\n\r\nIncidentally, manually modifying the field marks the expected entities as modified:\r\n```csharp\r\nvar entity = ...; // Something.SomeString = \"qwerty\"\r\n\r\nentity.Something.SomeString = \"abcde\";\r\n\r\ncontext.Entities.Update(entity);\r\n\r\nvar changes = context.ChangeTracker.Entries();\r\n// entity -> Modified\r\n// entity.Something -> Modified\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3285/comments",
    "author": "psyren89",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-12-16T06:30:28Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-01-16T08:09:25Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3277,
    "title": "Microsoft.AspNetCore.Mvc.Rendering.SelectList needs to have a constructor with 0 args or only optional args.",
    "created_at": "2019-12-02T02:11:20Z",
    "closed_at": "2019-12-02T05:34:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3277",
    "body": "I have two types as follows:\r\n\r\n    public class ScheduleALessonInfoDto\r\n    {\r\n        public SelectList LanguageSelectList { get; set; }\r\n        public SelectList LessonTypeSelectList { get; set; }\r\n        public SelectList LessonNameSelectList { get; set; }\r\n        public SelectList LessonOptionSelectList { get; set; }\r\n        public SelectList LessonToolSelectList { get; set; }\r\n    }\r\n\r\n    public class ScheduleALessonViewModel\r\n    {\r\n        public SelectList LanguageSelectList { get; set; }\r\n        public SelectList LessonTypeSelectList { get; set; }\r\n        public SelectList LessonNameSelectList { get; set; }\r\n        public SelectList LessonOptionSelectList { get; set; }\r\n        public SelectList LessonToolSelectList { get; set; }\r\n    }\r\n\r\nI am trying to map `ScheduleALessonInfoDto` to `ScheduleALessonViewModel`. But if any of the property, for say `LanguageSelectList`, is null in `ScheduleALessonInfoDto` then its not setting null value to the property (`LanguageSelectList`) in `ScheduleALessonViewModel` rather throwing the following exception:\r\n\r\n> An unhandled exception occurred while processing the request.\r\n> ArgumentException: Microsoft.AspNetCore.Mvc.Rendering.SelectList needs to have a constructor with 0 args or only optional args.\r\n> Parameter name: type\r\n> lambda_method(Closure , ScheduleALessonInfoDto , ScheduleALessonViewModel , ResolutionContext )\r\n\r\n> AutoMapperMappingException: Error mapping types.\r\n> \r\n> Mapping types:\r\n> ScheduleALessonInfoDto -> ScheduleALessonViewModel\r\n> GlotsALot.Application.DataTransferObjects.LessonScheduleDtos.ScheduleALessonInfoDto -> GlotsALot.Web.ViewModels.LessonScheduleViewModels.ScheduleALessonViewModel\r\n> \r\n> Type Map configuration:\r\n> ScheduleALessonInfoDto -> ScheduleALessonViewModel\r\n> GlotsALot.Application.DataTransferObjects.LessonScheduleDtos.ScheduleALessonInfoDto -> GlotsALot.Web.ViewModels.LessonScheduleViewModels.ScheduleALessonViewModel\r\n> \r\n> Destination Member:\r\n> LessonNameSelectList\r\n> lambda_method(Closure , ScheduleALessonInfoDto , ScheduleALessonViewModel , ResolutionContext )\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3277/comments",
    "author": "TanvirArjel",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-12-02T05:34:41Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2020-01-02T07:37:47Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3269,
    "title": ".Net Framework 4.0 support",
    "created_at": "2019-11-21T09:28:44Z",
    "closed_at": "2019-11-21T09:46:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3269",
    "body": "The latest version compatible with .Net Framework 4.0 is 6.2.2, but it's behaviour is differ then 9.0.0. Particularly, if constructor of target object has parameters, then for parameter new instanse of parameter will be created on mapping process, despite the fact that parameter object was mapped erlier in this mapping process. It leads to multiple mapped instacnces of original object after map. Such problems are solved in later versions of AutoMapper, but they are incomatible with .Net Framework 4.0. So, is it posible to add .Net Framework 4.0 support in latest version of AutoMapper?\r\n\r\nHeare example of configuration, which has different result in versions 6.2.2 and 9.0.0:\r\n# Source class\r\n```csharp\r\n    public sealed class Foo\r\n    {\r\n        public Foo(Foo related)\r\n        {\r\n            Related = related;\r\n        }\r\n\r\n        public Foo Related { get; }\r\n    }\r\n```\r\n# Target class\r\n```csharp\r\n    public sealed class Bar\r\n    {\r\n        public Bar(Bar related)\r\n        {\r\n            Related = related;\r\n        }\r\n\r\n        public Bar Related { get; }\r\n    }\r\n```\r\n# Test code\r\n```csharp\r\n            var mcfg = new MapperConfiguration(configuration =>\r\n            {\r\n                configuration\r\n                    .CreateMap<Foo, Bar>();\r\n            });\r\n\r\n            mcfg.AssertConfigurationIsValid();\r\n            var m = mcfg.CreateMapper();\r\n\r\n            var foo1 = new Foo(null);\r\n            var foo2 = new Foo(foo1);\r\n            var fooDto = m.Map<Bar[]>(new[] { foo1, foo2 });\r\n\r\n            Console.WriteLine(fooDto[1].Related == fooDto[0]);\r\n            // Writes \"False\" for version 6.2.2 and \"True\" for version 9.0.0\r\n```",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3269/comments",
    "author": "ds1709",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-11-21T09:46:32Z",
        "body": "No. Search the old issues about the back and forth on this."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-12-22T10:04:52Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3265,
    "title": ".Ignore() doesn't work in second level collection mapping",
    "created_at": "2019-11-19T15:04:51Z",
    "closed_at": "2019-11-19T15:10:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3265",
    "body": "    public class EmployeeEntity\r\n    {\r\n        public int Id { get; set; }\r\n        public string Name { get; set; }\r\n        public int Age { get; set; }\r\n        public List<TaskEntity> Tasks { get; set; }\r\n    }\r\n    public class EmployeeModel\r\n    {\r\n        public int Id { get; set; }\r\n        public string Name { get; set; }\r\n        public int Age { get; set; }\r\n        public List<int> Salary { get; set; }\r\n\r\n        public List<TaskModel> Tasks { get; set; }\r\n    }\r\n\r\n    public class TaskModel\r\n    {\r\n        public int TaskId { get; set; }\r\n        public string Name { get; set; }\r\n        public ICollection<TaskUserModel> Users { get; set; }\r\n    }\r\n    public class TaskUserModel\r\n    {\r\n        public int TaskId { get; set; }\r\n        public int UserId { get; set; }\r\n    }\r\n\r\n    public class TaskEntity\r\n    {\r\n        public int TaskId { get; set; }\r\n        public string Name { get; set; }\r\n        public ICollection<TaskUserEntity> Users { get; set; }\r\n    }\r\n\r\n    public class TaskUserEntity\r\n    {\r\n        public int TaskId { get; set; }\r\n        public int UserId { get; set; }\r\n    }\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var config = new MapperConfiguration(cfg =>\r\n            {\r\n\r\n                cfg.CreateMap<EmployeeEntity, EmployeeModel>();\r\n                cfg.CreateMap<EmployeeModel, EmployeeEntity>();\r\n\r\n                cfg.CreateMap<TaskEntity, TaskModel>();\r\n                cfg.CreateMap<TaskModel, TaskEntity>().ForMember(z => z.Users, opt => opt.Ignore());\r\n\r\n\r\n                cfg.CreateMap<TaskUserEntity, TaskUserModel>();\r\n                cfg.CreateMap<TaskUserModel, TaskUserEntity>();\r\n            });\r\n            var entity = new EmployeeEntity()\r\n            {\r\n                Id = 1,\r\n                Age = 5,\r\n                Name = \"Joseph\",\r\n                Tasks = new List<TaskEntity>() {\r\n                new TaskEntity()\r\n                {\r\n                    Name=\"X\",\r\n                    TaskId=1,\r\n                    Users=new List<TaskUserEntity>() { new TaskUserEntity() {TaskId=1,UserId=2 } }\r\n                }\r\n            }\r\n            };\r\n            var model = new EmployeeModel()\r\n            {\r\n                Id = 1,\r\n                Age = 5,\r\n                Name = null,\r\n                Tasks = new List<TaskModel>() {\r\n                new TaskModel()\r\n                {\r\n                    Name=\"X\",\r\n                    TaskId=1,\r\n                    Users=null // In model i am making it null, but it should brng me taskusers list anyhow.\r\n                } }\r\n\r\n            };\r\n\r\n            var mapper = config.CreateMapper();\r\n            var updatedEntity = mapper.Map(model, entity);\r\n\r\n        }\r\n    }\r\n\r\nI am having trouble with .Ignore().\r\ni have employee entity,inside Employee entity i have List_TaskEntity, and inside List_TaskEntity i have List_TaskUserEntity.\r\nand i have dto model of all entities.\r\nWhat i can't do is, i dont want to allow client to edit List_TaskUserEntity though EmployeeModel, \r\nso in mapping i want to Ignore 'List_TaskUser' like this;\r\n\r\ncfg.CreateMap<TaskModel, TaskEntity>().ForMember(z => z.Users, opt => opt.Ignore()); //doesnt work,\r\ncfg.CreateMap<TaskModel, TaskEntity>().ForMember(z => z.Users, opt => opt.UseDestinationValue()); //doesnt work\r\n\r\nDesired result;\r\nwhether i edit User collection in Employee model or not, always it should bring me unmodified user entity list after mapping.\r\n\r\nThanks a lot.\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3265/comments",
    "author": "SnrVnnd",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-11-19T15:10:48Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-12-20T16:41:43Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3258,
    "title": "How to conditionally ignore mapping for a member",
    "created_at": "2019-11-08T14:51:53Z",
    "closed_at": "2019-11-08T14:57:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3258",
    "body": "Dear Team, \r\n\r\nThanks for this wonderful project. I'm asking here this after doing lots of search. I'm still not able to achieve conditional ignore.\r\n\r\nI need to conditionally ignore mapping for two members if the user is not in a specific role. I'm not sure on how to handle this.  Please can you assist me on this? \r\n\r\n### Source/destination types\r\n\r\n```csharp\r\n\r\npublic class BranchViewModel\r\n{\r\n    public bool Lock { get; set; }\r\n    public DateTime ExpireOn { get; set; }\r\n}\r\n\r\npublic class Branch\r\n{\r\n    public string Lock { get; set; }\r\n    public string ExpireOn { get; set; }\r\n}\r\n\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\npublic class BranchProfile : Profile\r\n{\r\n    private readonly HttpContext _httpContext;\r\n\r\n    public BranchProfile(IHttpContextAccessor httpContextAccessor)\r\n    {\r\n        _httpContext = httpContextAccessor.HttpContext;\r\n\r\n        CreateMap<Branch, BranchViewModel>()\r\n            .ForMember(dest => dest.Lock, opt => opt.Condition(src => _httpContext.User.IsInRole(UserRoles.Master.ToString())))\r\n            .ForMember(dest => dest.ExpireOn, opt => opt.Condition(src => _httpContext.User.IsInRole(UserRoles.Master.ToString())));\r\n    }\r\n}\r\n```\r\n\r\n### Version: 7.0.0\r\n I'm using `AutoMapper.Extensions.Microsoft.DependencyInjection 7.0.0` in my `Asp.Net Core 3.0` project\r\n\r\n### Expected behavior\r\n\r\nI would like to ignore the mapping if the user is not in a master role.\r\n\r\n### Actual behavior\r\n\r\n>No parameterless constructor defined for type 'BranchProfile'\r\n\r\nIf I remove the deoendency injection in profile how can I get access to `HttpContext`? Do I need to write a separate class and have the logic's there? Please assist",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3258/comments",
    "author": "fingers10",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-11-08T14:57:37Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-12-11T08:04:51Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3252,
    "title": "ForAllMembers and ForAllOtherMembers does not return fluent API",
    "created_at": "2019-11-03T13:36:25Z",
    "closed_at": "2019-11-03T20:13:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3252",
    "body": "### Source/destination types\r\n```csharp\r\n    public class Order\r\n    {\r\n        public string orderId { get; set; }\r\n        public string paymentType { get; set; }\r\n        public string comment { get; set; }\r\n        public decimal price { get; set; }\r\n    }\r\n\r\n    public class OrderDTO\r\n    {\r\n        public int id { get; set; }\r\n        public string orderId { get; set; }\r\n        public string paymentType { get; set; }\r\n        public string comment { get; set; }\r\n    }\r\n```\r\n\r\n### Mapping configuration\r\n```csharp\r\nvar configuration = new MapperConfiguration(cfg =>\r\n        {\r\n            cfg.CreateMap<Order, OrderDTO>()\r\n                .ForMember(dst => dst.id, opt => opt.Ignore())\r\n                .ForAllOtherMembers(e => e.IgnoreSourceWhenDefault())\r\n                .ReverseMap()\r\n                .ForMember(dst => dst.price, opt => opt.Ignore())\r\n                .ForAllOtherMembers(e => e.IgnoreSourceWhenDefault());\r\n        });\r\n```\r\n\r\n### Version: x.y.z\r\n9.0.0\r\n\r\n### Expected behavior\r\nValid configuration of mapper.\r\n\r\n### Actual behavior\r\nAfter `ForAllOtherMembers().` VS write error:\r\n> Operator '.' cannot be applied to operand of type 'void'\r\n\r\n### Feature request\r\nIt would be nice when `ForAllMembers` and `ForAllOtherMembers` will provide fluent API as expected.\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3252/comments",
    "author": "evorios",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-11-03T20:13:49Z",
        "body": "That's by design. Because they don't compose with other configuration."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-12-04T21:04:53Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3251,
    "title": "Mocking the context mapper",
    "created_at": "2019-10-31T21:05:31Z",
    "closed_at": "2019-11-01T14:04:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3251",
    "body": "There was a change in AutoMapper 9 where the Mapper property from the ResolutionContext class returns the class itself as a IRuntimeMapper. With this change I'm unable to mock the return of Map on my tests. \r\n\r\nThis is how I was doing:\r\n```csharp\r\n_mappingOperationOptions = Substitute.For<IMappingOperationOptions>();\r\n_runtimeMapper = Substitute.For<IRuntimeMapper>();\r\n_resolutionContext = new ResolutionContext(_mappingOperationOptions, _runtimeMapper);\r\n\r\n_runtimeMapper.Map<List<Dto>>(Arg.Is(dto))\r\n                .Returns(listOfDtos);\r\n```\r\n\r\nBefore, the Mapper property was returning the instance I was injecting in the constructor, so I was able to unit tests my classes that implemented ITypeConverter. Is there any way to add a new method on ITypeConverter changing the ResolutionContext parameter to IRuntimeMapper? This way I'll be able to mock the context and unit test my converters.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3251/comments",
    "author": "joao29a",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-11-01T06:34:46Z",
        "body": "There is no need to mock `IMapper`. You should just use the real mapper instance."
      },
      {
        "user": "joao29a",
        "created_at": "2019-11-01T13:27:24Z",
        "body": "I get it what I have to do. I have to mock the IRuntimeMapper methods instead of IMapper, like this:\r\n\r\n```csharp\r\n_runtimeMapper.Map(\r\n                    Arg.Is(dto),\r\n                    Arg.Any<object>(),\r\n                    Arg.Any<Type>(),\r\n                    Arg.Any<Type>(),\r\n                    Arg.Is(_resolutionContext))\r\n                .Returns(listOfDto);\r\n```\r\n\r\nThis way when any Map happens on my converters, it will return what I specified. Thanks!"
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-12-02T14:57:49Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3246,
    "title": "EF Core Null Check Navigation Property",
    "created_at": "2019-10-21T20:19:59Z",
    "closed_at": "2019-10-22T15:01:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3246",
    "body": "Hi,\r\n\r\nFirst off, if this is not an Automapper and is an EF Core issue, if there is no way around this, this will mean EF Core is a no go. If there are alternative ways to solve this issue, insight would be truly appreciated.\r\n\r\nI am experiencing an issue when trying to map a nested database model into a (mostly) flattened DTO object and default all null navigation properties.  Unfortunately, there are situations where a database model might be 5 levels deep, this.that.something.whatever.ok that might have \"something\" as null.\r\n\r\nWhen using the same database model with EF6, this is handled perfectly fine, and resolves the whole map to null. But now, i am getting \"nullable object must have a value\" or if i enable \"EnableNullPropagationForQueryMapping\" I get \"Object reference not set to an instance of an object.\"\r\n\r\nI can post a gist if needed, and the expression tree. It appears with \"EnableNullPropagationForQueryMapping\" it does add the null checks which makes sense,  but from the warning that it provides, it seems like this may be a known issue... but i'm not finding much help via Google searches.\r\n\r\nThanks for the help!\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3246/comments",
    "author": "MattHartz",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-10-22T03:50:44Z",
        "body": "If it works with EF6, then most likely it's an EF Core issue and you should report it there."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-11-22T15:52:53Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3241,
    "title": "is support for .NET CORE 3.0",
    "created_at": "2019-10-14T09:26:00Z",
    "closed_at": "2019-10-14T09:26:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3241",
    "body": "how to setup automapper in .net core 3.0 application?\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3241/comments",
    "author": "MathavanN",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-10-14T09:26:41Z",
        "body": "The same. Check the docs."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-11-14T09:52:12Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3239,
    "title": "Support projection for IAsyncEnumerable<T>",
    "created_at": "2019-10-12T16:30:05Z",
    "closed_at": "2019-10-13T21:48:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3239",
    "body": "EF Core 3.0 supports the use of `IAsyncEnumerable<T>` for more efficient queries. Can you consider adding mapping support for it so it's possible to use AutoMapper in this use case without breaking the async streaming behaviour?\r\nOr have I missed something?",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3239/comments",
    "author": "MarcusWichelmann",
    "comments": [
      {
        "user": "MarcusWichelmann",
        "created_at": "2019-10-13T21:48:39Z",
        "body": "I'm using `Entities.ProjectTo<Destination>(...).AsAsyncEnumerable();` now, which is a much cleaner solution."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-11-13T21:52:15Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3238,
    "title": "Convert dynamic data into static types if exist",
    "created_at": "2019-10-08T15:55:06Z",
    "closed_at": "2019-10-08T19:27:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3238",
    "body": "I have a entity with translatable `Name` property and a dictionary to store translates as JSON. \r\n```C#\r\n    public class Entity \r\n    {\r\n        public string Id { get; set; }\r\n        public string Name { get; set; }\r\n        //key is culture's name\r\n        public IDictionary<string, Translation> Translations { get; set; }\r\n    }\r\n\r\n    public class Translation\r\n    {\r\n        public string Name { get; set; }\r\n        public string Culture { get; set; }\r\n    }\r\n\r\n    public class EntityDTO \r\n    {\r\n        public string Id { get; set; }\r\n        public string Name { get; set; }\r\n    }\r\n```\r\nHow can I config AutoMapper to map `Name` property from Translations dictionary if exist?\r\n```C#\r\n    public static class AutoMapExtensions\r\n    {\r\n        public static IMappingExpression<TTranslatableEntity, TDestination>\r\n            CreateTranslatableMap<TTranslatableEntity, TTranslation, TDestination>(\r\n                this IMapperConfigurationExpression configuration, MultiLingualMapContext multiLingualMapContext)\r\n            where TTranslation : class, ITranslation\r\n            where TTranslatableEntity : ITranslatable<TTranslation>\r\n        {\r\n           return configuration.CreateMap<TTranslatableEntity, TDestination>().AfterMap(\r\n                (source, destination, context) =>\r\n                {\r\n                    if (source.Translations == null)\r\n                    {\r\n                        return;\r\n                    }\r\n\r\n                    if (source.Translations.TryGetValue(CultureInfo.CurrentUICulture.Name,\r\n                        out TTranslation translation))\r\n                    {\r\n                        if (translation != null)\r\n                        {\r\n                            context.Mapper.Map(translation, destination);\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    var defaultLanguage = multiLingualMapContext.SettingManager\r\n                        .GetSettingValue(LocalizationSettingNames.DefaultLanguage);\r\n\r\n                    if (source.Translations.TryGetValue(defaultLanguage, out translation))\r\n                    {\r\n                        if (translation != null)\r\n                        {\r\n                            context.Mapper.Map(translation, destination);\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    translation = source.Translations.FirstOrDefault().Value;\r\n                    if (translation != null)\r\n                    {\r\n                        context.Mapper.Map(translation, destination);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n```\r\nWhen trying to run test my VS was crushing and fixed just with pc restart.\r\nWith commenting this code section test was passing as well.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3238/comments",
    "author": "hitaspdotnet",
    "comments": [
      {
        "user": "lock[bot]",
        "created_at": "2019-11-10T05:52:11Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3229,
    "title": "Can i add condition for ICollection<T>?",
    "created_at": "2019-09-28T23:57:13Z",
    "closed_at": "2019-09-29T05:51:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3229",
    "body": "**Master entity:**\r\n```\r\npublic class ClientInfo\r\n{\r\n    public Guid Id { get; set; }\r\n    public string FirstName { get; set; }\r\n    public string LastName { get; set; }\r\n    public DateTime BirthDate { get; set; }\r\n    public GenderType Gender { get; set; }\r\n    public string IdentityNumber { get; set; }\r\n    public string Phone { get; set; }\r\n    public string Mobile { get; set; }\r\n    public string Address { get; set; }\r\n    public string Email { get; set; } = null;\r\n    public string Country { get; set; }\r\n    public string Province { get; set; }\r\n    public string City { get; set; }\r\n    public bool IsActive { get; set; }\r\n\r\n    public ICollection<CompanionInfo> CompanionInfo { get; set; }\r\n\r\n}\r\n```\r\n**Detail entity:**\r\n```\r\npublic class CompanionInfo\r\n{\r\n    public Guid Id { get; set; }\r\n    public string FirstName { get; set; }\r\n    public string LastName { get; set; }\r\n    public DateTime BirthDate { get; set; }\r\n    public GenderType Gender { get; set; }\r\n    public string IdentityNumber { get; set; }\r\n    public string Phone { get; set; }\r\n    public string Mobile { get; set; }\r\n    public string Address { get; set; }\r\n    public CompanionTypes CompanionType { get; set; }\r\n    public Guid ClientInfoId { get; set; }\r\n    public ClientInfo ClientInfo { get; set; }\r\n}\r\n```\r\n**Mapper Profile:**\r\n```\r\npublic class ClientInfoApplicationAutoMapperProfile : Profile\r\n{\r\n    public ClientInfoApplicationAutoMapperProfile()\r\n    {\r\n        AllowNullCollections = true;\r\n\r\n        CreateMap<ClientInfo, ClientInfoDto>().ReverseMap()\r\n            .ForMember(d => d.CompanionInfo, m => m.MapFrom(s => s.CompanionInfo));\r\n\r\n        CreateMap<ClientInfo, CreateUpdateClientInfoDto>().ReverseMap()\r\n            .ForMember(d => d.CompanionInfo, m => m.MapFrom(s => s.CompanionInfo))\r\n            .ForAllMembers(opt => opt.Condition((s, d, m) => m != null));\r\n\r\n        CreateMap<CompanionInfo, CompanionInfoDto>().ReverseMap()\r\n            .ForAllMembers(opt => opt.Condition((s, d, m) => d != null & m != null));\r\n    }\r\n}\r\n```\r\nOn updating `CompanionInfo` by `CreateUpdateClientInfoDto`, `Condition` not working on `ICollection<CompanionInfoDto>`",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3229/comments",
    "author": "SaeedSpate",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-09-29T05:51:18Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-10-30T06:05:12Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3228,
    "title": "about Mapper.DynamicMap",
    "created_at": "2019-09-27T08:35:04Z",
    "closed_at": "2019-09-27T08:49:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3228",
    "body": "why Mapper.DynamicMap is not supported ? it's more easy  to use AutoMapper ",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3228/comments",
    "author": "winnyrain",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-09-27T08:49:05Z",
        "body": "Because it's too much work to support. This was discussed many times before, search the older issues."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-10-28T09:05:06Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3221,
    "title": "the encode of file \"Internationalization.cs\" is right?",
    "created_at": "2019-09-18T05:41:13Z",
    "closed_at": "2019-09-18T07:31:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3221",
    "body": " the codepage of the source file named \"Internationalization.cs\" in UnitTests directory is ISO-8859-2, is it right?",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3221/comments",
    "author": "frankbsd",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-09-18T07:23:24Z",
        "body": "Why would that be relevant?"
      },
      {
        "user": "frankbsd",
        "created_at": "2019-09-18T07:26:13Z",
        "body": "Visual studio 2019 complains, it can't work"
      },
      {
        "user": "lbargaoanu",
        "created_at": "2019-09-18T07:31:49Z",
        "body": "It works for us. Try StackOverflow or a VS forum."
      },
      {
        "user": "frankbsd",
        "created_at": "2019-09-18T07:33:19Z",
        "body": "OK!Thanks!"
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-10-19T08:21:30Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3206,
    "title": "Map overload without Action",
    "created_at": "2019-08-27T13:29:45Z",
    "closed_at": "2019-08-27T13:38:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3206",
    "body": "After migration to latest version of AutoMapper(from v8 to v9). I have issue with mapper.Map<T> method. When mapping an object to another one I get System.InvalidOperationException: 'You must use a Map overload that takes Action<IMappingOperationOptions>!'.\r\n\r\nSome code:\r\n\r\nTHEN:\r\n\r\n[...]\r\n    //This line throws exception\r\n    conversation.CreatedBy = mapper.Map<UserLight>(usr);\r\n[...]\r\n\r\nNOW (to fix the bug momentarily):\r\n\r\n[...]\r\n    //It's ok\r\n    conversation.CreatedBy = mapper.Map<UserLight>(usr, ctx => ctx.Items[\"UserId\"] = null);\r\n[...]\r\n\r\nI just wonder if this is expected behavior or bug. Do I have to pass items of context to the method every time from v9 on? Or there is any way to not do it?",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3206/comments",
    "author": "lucabellaviadev",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-08-27T13:38:02Z",
        "body": "Yes, you need to tell us that you need the context. That allows us to avoid creating it in all the other cases. You don't have to do anything in the Action parameter (`_=>{}` would do). It is a little clumsy. But to add a new method, just for this purpose, I don't know... You can easily write an `IMapper` extension method if you want."
      },
      {
        "user": "dstj",
        "created_at": "2019-09-04T22:59:20Z",
        "body": "@lbargaoanu Why is the `Map(src)` method still present then if it will always throw an error?\r\n\r\nHaving to write `_=>{}` everywhere seems extra work for no reason... I must be missing something, right?"
      },
      {
        "user": "dstj",
        "created_at": "2019-09-05T17:33:46Z",
        "body": "@lbargaoanu I thought about it some more.  I need to add the `_ => {}` dummy function in many many places because I'm using the `ResolutionContext.Items` to optionally put a `Dictionary` indicating if a field should be mapped or not (i.e. a sparse fieldset).\r\n\r\nIn my mapping function, I first check if the field should be mapped with the following extensions method. If the `Items` key is missing, that it means that everything should be mapped.\r\n\r\n\t\tpublic static bool ShouldMapField(this ResolutionContext ctx, string type, string fieldName)\r\n\t\t{\r\n\t\t\tif (!ctx.Items.TryGetValue(FieldsKey, out var fieldsPerTypeObj))\r\n\t\t\t\treturn true;\r\n\r\n\t\t\tvar fieldsPerType = (IDictionary<string, HashSet<string>>) fieldsPerTypeObj;\r\n\t\t\tif (!fieldsPerType.TryGetValue(type, out var fields))\r\n\t\t\t\treturn true;\r\n\r\n\t\t\treturn fields.Contains(fieldName);\r\n\t\t}\r\n\r\nThere should maybe be a way to say `if (ctx.NoContextProvided || !ctx.Items.TryGetValue(.....` to avoid having to specify a dummy context..."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2019-09-05T17:49:59Z",
        "body": "It seems to me like your own code is to blame because it doesn't initialize the values in the context. You use it without initializing it and without telling us you need it by using the right overload."
      },
      {
        "user": "dstj",
        "created_at": "2019-09-05T17:54:46Z",
        "body": "Yes, exactly, a non-initialized (i.e. no values in the context) is a valid scenario for me. It just means that nothing special was requested and to proceed with the default behavior...\r\n\r\nNow, with v9, I have to always specify \"use the default behavior\"... that is all."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2019-09-05T18:06:55Z",
        "body": "That seems fair to me. cc @jbogard"
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-10-06T18:31:49Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3196,
    "title": "Automapper in ARM iot core Windows",
    "created_at": "2019-08-17T20:06:17Z",
    "closed_at": "2019-08-18T04:05:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3196",
    "body": "Hi\r\nI am using Automapper in .net core app with netstandard projekt for model and Automapper, if I publish with this: dotnet publish -r ubuntu.16.04-arm I do not receive error but if I run this dotnet publish  -r win10-arm I receive downgrade error NU1605\r\n\r\nCan you help me ?",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3196/comments",
    "author": "M2xAy",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-08-18T04:05:49Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-09-18T04:31:48Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3195,
    "title": "Recursive ProjectTo",
    "created_at": "2019-08-16T21:32:55Z",
    "closed_at": "2019-08-17T05:40:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3195",
    "body": "## Source/destination types\r\n\r\n**Source:**\r\n\r\n```cs\r\n    public class Attribute\r\n    {\r\n        public int Id { get; set; }\r\n        public string Name { get; set; }\r\n\r\n        public int? RequiredAttributeId { get;set; } \r\n\r\n        public Attribute RequiredAttribute { get;set; }\r\n\r\n        public List<AttributeValue> Values { get; set; }\r\n    }\r\n```\r\n\r\n**Destination:**\r\n\r\n```cs\r\n    public class AttributeDto\r\n    {\r\n        public int Id { get; set; }\r\n        public string Name { get;set; }\r\n\r\n        public int? RequiredAttributeId { get;set; }\r\n\r\n        public AttributeDto RequiredAttribute { get; set; }\r\n\r\n        public List<AttributeValueDto> Values { get; set; }\r\n    }\r\n```\r\n\r\n### Mapping configuration\r\n\r\nNote: `MaxDepth()` has no effect on this issue.\r\n\r\n```csharp\r\n            config.CreateMap<Attribute, AttributeDto>();\r\n            config.CreateMap<AttributeValue, AttributeValueDto>()\r\n```\r\n\r\n### Version: 8.1.1, EF Core v2.2.6\r\n\r\n### Expected behavior\r\n\r\nThat the property `RequiredAttribute` would be mapped when using `ProjectTo<AttributeDto>`. Just like if I loaded the entity and did a `IMapper.Map<AttributeDto>()` call.\r\n\r\n### Actual behavior\r\n\r\n`RequiredAttribute` is always null when using projections. \r\n\r\n### Steps to reproduce\r\n\r\nNote: I did think maybe this is `MaxDepth()` related, but no matter what `MaxDepth()`  is set to, this still doesn't project. This is also not self-referencing as `RequiredAttribute` is a different entity.\r\n\r\n```cs\r\n            // Attribute Entity has RequiredAttribute filled in\r\n            Attribute attribute = _context.Attributes\r\n                .Where(x => x.Id == id)\r\n                .Include(x => x.Values)\r\n                    .ThenInclude(x => x.ChildValues)\r\n                .Include(x => x.RequiredAttribute)\r\n                .SingleOrDefault();\r\n\r\n            // Mapped AttributeDto has RequiredAttribute filled in\r\n            AttributeDto  attributeMapped = _defaultMapper.Map<AttributeDto>(attributetest);\r\n\r\n             // Projected AttributeDto has null RequiredAttribute \r\n            AttributeDto  attributeDto = _context.Attributes\r\n                .Where(x => x.Id == id)\r\n                .Include(x => x.Values)\r\n                    .ThenInclude(x => x.ChildValues)\r\n                .Include(x => x.RequiredAttribute)\r\n                .ProjectTo<AttributeDto>()\r\n                .SingleOrDefault();\r\n\r\n            // Projected AttributeDto with explicit projection has null RequiredAttribute \r\n            AttributeDto attributeDtoExplicit = _context.Attributes\r\n                .Where(x => x.Id == id)\r\n                .Include(x => x.Values)\r\n                    .ThenInclude(x => x.ChildValues)\r\n                .Include(x => x.RequiredAttribute)\r\n                .ProjectTo<AttributeDto>(x => x.RequiredAttribute)\r\n                .SingleOrDefault();\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3195/comments",
    "author": "douglasg14b",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-08-17T05:40:04Z",
        "body": "Duplicate of #2171."
      },
      {
        "user": "douglasg14b",
        "created_at": "2019-08-17T21:38:43Z",
        "body": "@lbargaoanu  Can you please, succinctly, explain what is wrong here if you believe this to be a question? How is this recursive? I specifically stated that the child entity is **NOT** self-referencing.\r\n\r\nWhy does this map, but not project?\r\n\r\nThe linked issue (that this is a duplicate of?) did not have a resolution, as the poster pointed out that ` I skipped using AutoMapper in this scenario and created a EF query that satisfied my needs in this.`."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2019-08-18T04:10:01Z",
        "body": "In one form or another, this question has been discussed many times before, here and on SO. We don't have another answer. If you need further assistance, please ask on SO."
      },
      {
        "user": "jbogard",
        "created_at": "2019-08-18T13:33:55Z",
        "body": "Your `Attribute` and corresponding DTO are self referencing through the `RequiredAttribute` property.\r\n\r\n\r\nTry writing this projection without AutoMapper using only Select with LINQ."
      },
      {
        "user": "douglasg14b",
        "created_at": "2019-08-19T18:06:25Z",
        "body": "@jbogard  Thanks, I'm just trying to understand the problem as the linked issue doesn't succinctly describe it, and that issue is locked and further discussion isn't possible there.\r\n\r\nIf I understand this correctly, a child entity of the same type, even if it's not the same entity (ie. by Id), is still self referencing? Is the MaxDepth config not for this then?"
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-09-19T18:31:49Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3190,
    "title": "Breaking change between v8.1.0 and v8.1.1 when mapping to a dictionary",
    "created_at": "2019-08-12T17:42:02Z",
    "closed_at": "2019-08-12T17:53:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3190",
    "body": "Hello,\r\n\r\nI meant to post this a while ago when 8.1.1 was released but I got caught up in things at work so I never got a chance. I'm not sure if this was an intentional breaking change or not, but there was a breaking change in 8.1.1 when mapping from a collection of Key/Values to a Dictionary (the Key/Value type is not `KeyValuePair` because it is an EF entity).\r\n\r\n### Expected behavior\r\nIn 8.1.0 of AutoMapper, this mapping worked without any issues. It would map the Key/Values into the Dictionary.\r\n\r\n### Actual behavior\r\nIn 8.1.1, the following error is thrown:\r\n\r\n```\r\nAutoMapperMappingException: Error mapping types.\r\n\r\nMapping types:\r\nOrder -> OrderModel\r\nUserQuery+Order -> UserQuery+OrderModel\r\n\r\nType Map configuration:\r\nOrder -> OrderModel\r\nUserQuery+Order -> UserQuery+OrderModel\r\n\r\nDestination Member:\r\nAttributes\r\n```\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\nvoid Main()\r\n{\r\n    var services = new ServiceCollection();\r\n    services.AddAutoMapper(this.GetType().Assembly);\r\n    \r\n    using var root = services.BuildServiceProvider();\r\n    var mapper = root.GetRequiredService<IMapper>();\r\n    \r\n    var model = mapper.Map<OrderModel>(new Order\r\n    {\r\n        OrderNumber = \"PO1001\",\r\n        Attributes =\r\n        {\r\n            new Order.Attribute { Key = \"Key1\", Value = \"Value1\" },\r\n            new Order.Attribute { Key = \"Key2\", Value = \"Value2\" },\r\n        }\r\n    });\r\n}\r\n\r\npublic class Order\r\n{\r\n    public String OrderNumber { get; set; }\r\n    public ICollection<Attribute> Attributes { get; set; } = new HashSet<Attribute>();\r\n\r\n    public class Attribute\r\n    {\r\n        public String Key { get; set; }\r\n        public String Value { get; set; }\r\n    }\r\n}\r\n\r\npublic class OrderModel\r\n{\r\n    public String OrderNumber { get; set; }\r\n    public IDictionary<String, String> Attributes { get; set; } = new Dictionary<String, String>();\r\n}\r\n\r\npublic class Profile : AutoMapper.Profile\r\n{\r\n    public Profile()\r\n    {\r\n        this.CreateMap<Order, OrderModel>();\r\n    }\r\n}\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3190/comments",
    "author": "ChristopherHaws",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-08-12T17:53:23Z",
        "body": "9.0 was just released. So use that or stick with the version you have."
      },
      {
        "user": "ChristopherHaws",
        "created_at": "2019-08-12T18:06:57Z",
        "body": "@lbargaoanu This issue still occurs in v9."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2019-08-12T18:10:41Z",
        "body": "You can either do what the message says, or keep the version you have."
      },
      {
        "user": "jbogard",
        "created_at": "2019-08-14T12:46:00Z",
        "body": "The `Order.Attribute` type is unknown to AutoMapper. Previously, we would create dynamic maps on the fly. We turned that off, then removed dynamic maps, since you could have misspelled or changed the `Order.Attribute` type and your mapping would silently skip those properties.\r\n\r\nYou need to create a map from your custom type to the KeyValuePair type:\r\n\r\n```c#\r\npublic class Profile : AutoMapper.Profile\r\n{\r\n    public Profile()\r\n    {\r\n        this.CreateMap<Order, OrderModel>();\r\n        this.CreateMap<Order.Attribute, KeyValuePair<string, string>>();\r\n    }\r\n}\r\n```"
      },
      {
        "user": "ChristopherHaws",
        "created_at": "2019-08-14T17:33:54Z",
        "body": "Ah, I didn't realize that it was being dynamically mapped. Thanks for the clarification!"
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-09-14T18:31:48Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3181,
    "title": "Map to IEnumerable<> doesn't work anymore after upgrading to 8.1.1",
    "created_at": "2019-08-06T10:28:10Z",
    "closed_at": "2019-08-06T11:12:34Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3181",
    "body": "### Source/destination types\r\n\r\n```csharp\r\n// Put your source/destination types here\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\nCreateMap<PriceFactorInitializeDto, PriceFactorModel>();\r\n```\r\n\r\n### Version: x.y.z\r\n8.1.1\r\n\r\n### Expected behavior\r\n\r\nIt worked before updating to 8.1.1.\r\n\r\n### Actual behavior\r\n\r\nNow it issues an error:\r\n```\r\n    AutoMapper.AutoMapperMappingException: Error mapping types.\r\n    \r\n    Mapping types:\r\n    WhereListIterator`1 -> IEnumerable`1\r\n    System.Linq.Enumerable+WhereListIterator`1[[db.ccr.dto.scenario.PriceFactorInitializeDto, DtoScenarioManagement, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]] -> System.Collections.Generic.IEnumerable`1[[db.ccr.scenario.models.PriceFactorModel, Models, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]] ---> AutoMapper.AutoMapperMappingException: Missing type map configuration or unsupported mapping.\r\n    \r\n    Mapping types:\r\n    PriceFactorInitializeDto -> PriceFactorModel\r\n    db.ccr.dto.scenario.PriceFactorInitializeDto -> db.ccr.scenario.models.PriceFactorModel\r\n  Stack Trace: \r\n    at lambda_method(Closure , PriceFactorInitializeDto , PriceFactorModel , ResolutionContext )\r\n    at lambda_method(Closure , WhereListIterator`1 , IEnumerable`1 , ResolutionContext )\r\n    at --- End of inner exception stack trace ---\r\n    at lambda_method(Closure , WhereListIterator`1 , IEnumerable`1 , ResolutionContext )\r\n    at lambda_method(Closure , Object , Object , ResolutionContext )\r\n    <location of Map() call>\r\n```\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\nvar pfs = TestSetup.TestMapper.Map<IEnumerable<PriceFactorModel>>(\r\n    from dto in dtos\r\n    where dto.IsRiskFactor\r\n    select dto);\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3181/comments",
    "author": "mc0re",
    "comments": [
      {
        "user": "mc0re",
        "created_at": "2019-08-06T11:12:34Z",
        "body": "Okay, my bad. The problem was in replacing `AddAutoMapper(config => config.AddProfile<...>())` with `AddAutoMapper(typeof(...))`. Some of the profiles were previously picked up automatically, which is why it worked before.\r\n\r\nBtw, I would like to specify the profile classes explicitly, but it's not an option anymore."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-09-06T12:31:48Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3179,
    "title": "Question: Is AutoMapper Compitable with .NET Core 2.2 ?",
    "created_at": "2019-08-05T09:50:42Z",
    "closed_at": "2019-08-05T09:52:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3179",
    "body": "Just a small question.\r\nI have new .NET Core project 2.2, And I want to add AutoMapper to it.\r\nI do not want to install `AutoMapper.Extensions.Microsoft.DependencyInjection` package.\r\nThe AutoMapper library is enough for my case.\r\n\r\nMy question is: Can I use the AutoMapper package safely with .NET Core 2.2, Is the library has been tested in .NET Core 2.2 so I can safely add it and start working with it\r\n\r\nThank you",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3179/comments",
    "author": "HakamFostok",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-08-05T09:52:15Z",
        "body": "Yes."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-09-05T10:31:48Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3177,
    "title": "Constructor parameters must not have default values",
    "created_at": "2019-07-31T07:46:55Z",
    "closed_at": "2019-07-31T08:40:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3177",
    "body": "\r\n### Source/destination types\r\n\r\n```csharp\r\npublic class Source {\r\n    public string A { get; set; }\r\n    public string B { get; set; }\r\n}\r\n\r\npublic class Destination {\r\n    public string A { get; }\r\n    public string B { get; }\r\n\r\n    public Destination(string a, string b = null) {\r\n        A = a ?? throw new ArgumentNullException(nameof(a));\r\n        B = b;\r\n    }\r\n}\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\nCreateMap<Source, Destination>();\r\n```\r\n\r\n### Version: 8.1.1\r\n\r\n### Expected behavior\r\n\r\nWhen both A and B in my `Source` object are **not** null, I'd expect, that they are both mapped to `Destination`.\r\n\r\n### Actual behavior\r\n\r\nBecause of `string b = null`, the default value is used to call the constructor instead of mapping `B` from `Source` to `Destination`. This results in `Destination.B` being always null.\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\n[Fact]\r\npublic void MapsAllProperties()\r\n{\r\n    var configuration = new MapperConfiguration(cfg =>\r\n    {\r\n        cfg.CreateMap<Source, Destination>();\r\n    });\r\n\r\n    configuration.AssertConfigurationIsValid();\r\n\r\n    IMapper mapper = configuration.CreateMapper();\r\n\r\n    var source = new Source {A = \"foo\", B = \"bar\"};\r\n    var dest = mapper.Map<Destination>(source);\r\n\r\n    Assert.Equal(source.A, dest.A); // succeeds\r\n    Assert.Equal(source.B, dest.B); // fails because dest.B is null\r\n}\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3177/comments",
    "author": "MarcusWichelmann",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-07-31T07:58:11Z",
        "body": "Yes, default values have priority."
      },
      {
        "user": "MarcusWichelmann",
        "created_at": "2019-07-31T08:00:00Z",
        "body": "@lbargaoanu Okay, why is that? Could you please point me to some use case where this behaviour is makes sense and is expected?\r\nIs there an option to change this behaviour?"
      },
      {
        "user": "lbargaoanu",
        "created_at": "2019-07-31T08:05:44Z",
        "body": "No. But if you change it, some tests will fail. I wasn't around when that was implemented. If you're interested in opening a PR, you must first convince @jbogard that your use case is more relevant than the existing tests. Otherwise, just work around it."
      },
      {
        "user": "MarcusWichelmann",
        "created_at": "2019-07-31T08:25:24Z",
        "body": "It would be a breaking change, yes, but because the current behaviour is IMO not obvious and completely unexpected, maybe this would be a good thing to change for the next major release?"
      },
      {
        "user": "spydacarnage",
        "created_at": "2019-07-31T08:33:43Z",
        "body": "You could add a configuration flag to `IMappingExpression` to override the default behaviour:\r\n```csharp\r\nvar configuration = new MapperConfiguration(cfg =>\r\n{\r\n    cfg.CreateMap<Source, Destination>()\r\n        .OverrideConstructorDefaults();\r\n});\r\n```\r\n\r\nWhen performing the mapping, this flag could be consulted to see which value has priority?"
      },
      {
        "user": "lbargaoanu",
        "created_at": "2019-07-31T08:39:24Z",
        "body": "No for the configuration option. About the change, a PR is welcome."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-08-31T09:31:44Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3176,
    "title": "Updated to latest version, no longer can map without a profile",
    "created_at": "2019-07-30T20:09:36Z",
    "closed_at": "2019-07-31T03:43:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3176",
    "body": "I tried updating to 8.1.1 today and after reading the upgrade guide, I'm still having issues.\r\n\r\nI have a call to mapper.Map<Dest>(source Obj) that I don't have defined in a Profile. This has been working fine as I assume it's just using auto mapping of properties. But once I moved to 8.1.1, it throws an error saying it can't find a mapping definition for it.  Is there some new way to do this in the latest version?",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3176/comments",
    "author": "gdodd1977",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-07-31T03:43:26Z",
        "body": "The sole purpose of this release is to start moving people away from dynamic maps and static. So if you don't want to do that, just stick with the version you have."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-08-31T08:31:44Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3171,
    "title": "Unflatten from View to DTO",
    "created_at": "2019-07-23T20:37:50Z",
    "closed_at": "2019-07-24T02:18:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3171",
    "body": "Given this entity that we get back from a database view:\r\n\r\n public class TestEntity\r\n    {\r\n        public string MyProp { get; set; }\r\n        public string MyProp2 { get; set; }\r\n        public string MyChildProp { get; set; }\r\n        public string MyChildProp2 { get; set; }\r\n    }\r\n\r\nWhich maps to these models:\r\n\r\n    public class TestModel\r\n    {\r\n        public string MyProp { get; set; }\r\n        public string MyProp2 { get; set; }\r\n        public List<TestChildModel> TestChildModels { get; set; }\r\n    }\r\n    public class TestChildModel\r\n    {\r\n        public string MyChildProp { get; set; }\r\n        public string MyChildProp2 { get; set; }\r\n    }\r\n\r\nGiven this result set:\r\n\r\n\r\n            var entities = new List<TestEntity>\r\n            {\r\n                new TestEntity\r\n                {\r\n                    MyProp = \"1\",\r\n                    MyProp2 = \"2\",\r\n                    MyChildProp = \"c-1\",\r\n                    MyChildProp2 = \"c-2\"\r\n                },\r\n                new TestEntity\r\n                {\r\n                    MyProp = \"1\",\r\n                    MyProp2 = \"2\",\r\n                    MyChildProp = \"c-1\",\r\n                    MyChildProp2 = \"c-2\"\r\n                }\r\n            };\r\n\r\nIs there any way to use automapper to map to the models where the result would be a single TestModel with two TestChildModels?",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3171/comments",
    "author": "szavoda",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-07-24T02:18:43Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-08-24T02:31:44Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3166,
    "title": "Mapping fails to recognize existing constructor parameters",
    "created_at": "2019-07-12T21:41:49Z",
    "closed_at": "2019-07-12T22:18:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3166",
    "body": "### Source/destination types\r\n\r\n```csharp\r\nSrc: \r\n public class UserClaim : AuditableEntity\r\n    {\r\n        [Key]\r\n        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]\r\n        public int UserClaimId { get; set; }\r\n\r\n        [Required]\r\n        public int UserId { get; set; }\r\n\r\n        [Required]\r\n        [ForeignKey(\"ClaimType\")]\r\n        public ClaimTypeEnum ClaimTypeId { get; set; }\r\n        \r\n        [Required]\r\n        public ClaimType ClaimType { get; set; }\r\n\r\n        [Required]\r\n        [MaxLength(50)]\r\n        public string ClaimValue { get; set; }\r\n    }\r\n}\r\npublic class ClaimType : AuditableEntity\r\n    {\r\n        [Key]\r\n        public ClaimTypeEnum ClaimTypeId { get; set; }\r\n        public string ClaimTypeName { get; set; }\r\n    }\r\nDest: System.Security.Claims.Claim\r\n\r\n\r\npublic class Claim\r\n    {\r\n        ...\r\n        //\r\n        // Summary:\r\n        //     Initializes a new instance of the System.Security.Claims.Claim class with the\r\n        //     specified claim type, and value.\r\n        //\r\n        // Parameters:\r\n        //   type:\r\n        //     The claim type.\r\n        //\r\n        //   value:\r\n        //     The claim value.\r\n        //\r\n        // Exceptions:\r\n        //   T:System.ArgumentNullException:\r\n        //     type or value is null.\r\n        public Claim(string type, string value);\r\n...\r\n\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\nAutoMapper.Mapper.Initialize(config =>\r\n            {\r\n                config.CreateMap<UserClaim, Claim>()\r\n                .ForCtorParam(\"value\", opt => opt.MapFrom(src => src.ClaimValue))\r\n                .ForCtorParam(\"type\", opt => opt.MapFrom(src => src.ClaimType.ClaimTypeName));\r\n            });\r\n```\r\n\r\n### Version: 8.0.0\r\n\r\n### Expected behavior\r\n\r\nsuccessfully map?\r\n\r\n### Actual behavior\r\n\r\n\r\nException has occurred: CLR/AutoMapper.AutoMapperConfigurationException\r\nAn exception of type 'AutoMapper.AutoMapperConfigurationException' occurred in AutoMapper.dll but was not handled in user code: 'Claim does not have a constructor with a parameter named 'value'.\r\nSystem.Security.Claims.Claim'\r\n   at AutoMapper.CtorParamConfigurationExpression`1.Configure(TypeMap typeMap)\r\n   at AutoMapper.Configuration.MappingExpression`2.Configure(TypeMap typeMap)\r\n   at AutoMapper.ProfileMap.BuildTypeMap(IConfigurationProvider configurationProvider, ITypeMapConfiguration config)\r\n   at AutoMapper.ProfileMap.Register(IConfigurationProvider configurationProvider)\r\n   at AutoMapper.MapperConfiguration.Seal()\r\n   at AutoMapper.MapperConfiguration..ctor(MapperConfigurationExpression configurationExpression)\r\n   at AutoMapper.MapperConfiguration..ctor(Action`1 configure)\r\n   at AutoMapper.Mapper.Initialize(Action`1 config)\r\n   at Wellspring.Eqp.Api.Startup.SetUpAutoMapper() in /home/brian/clients/walsh/eqp-api/src/Wellspring.Eqp.Api/Startup.cs:line 362\r\n   at Wellspring.Eqp.Api.Startup.Configure(IApplicationBuilder app, IWebHostEnvironment env, ILogger`1 logger) in /home/brian/clients/walsh/eqp-api/src/Wellspring.Eqp.Api/Startup.cs:line 241\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Object[] arguments, Signature sig, Boolean constructor, Boolean wrapExceptions)\r\n   at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n   at Microsoft.AspNetCore.Hosting.Internal.ConfigureBuilder.Invoke(Object instance, IApplicationBuilder builder)\r\n   at Microsoft.AspNetCore.Hosting.Internal.ConfigureBuilder.<>c__DisplayClass4_0.<Build>b__0(IApplicationBuilder builder)\r\n   at Microsoft.AspNetCore.Hosting.Internal.GenericWebHostBuilder.<>c__DisplayClass13_0.<UseStartup>b__2(IApplicationBuilder app)\r\n   at Microsoft.AspNetCore.Mvc.Filters.MiddlewareFilterBuilderStartupFilter.<>c__DisplayClass0_0.<Configure>g__MiddlewareFilterBuilder|0(IApplicationBuilder builder)\r\n   at Microsoft.AspNetCore.HostFilteringStartupFilter.<>c__DisplayClass0_0.<Configure>b__0(IApplicationBuilder app)\r\n   at Microsoft.AspNetCore.Hosting.Internal.GenericWebHostService.<StartAsync>d__31.MoveNext()\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3166/comments",
    "author": "WellspringCS",
    "comments": [
      {
        "user": "spydacarnage",
        "created_at": "2019-07-12T21:57:20Z",
        "body": "Due to the way that constructor mapping currently works, your source object must contain all the properties contained in the destination constructor.\r\n\r\nThere is currently an active PR (#3160) to resolve this issue, but in the meantime, you can create a dummy parameter (`public object Value => null;`) in `UserClaim` and it should work."
      },
      {
        "user": "WellspringCS",
        "created_at": "2019-07-12T22:18:11Z",
        "body": "Thank you for your quick reply! I tried this,\r\n\r\n```\r\n// for automapper to work\r\npublic object Value => null;\r\npublic object Type => null;\r\n```\r\nand indeed found that the problem went away. Needless to say, it does seem a hack and ugly. But it works, and I appreciate your solution. Here's hoping the next release will address this gap."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2019-07-13T06:35:42Z",
        "body": "There is no need for that. You can use `ConstructUsing` or optional parameters. Or just take advantage of the naming convention:\r\n\r\n  \tpublic Claim(string claimValue, string claimTypeClaimTypeName)\r\n"
      },
      {
        "user": "WellspringCS",
        "created_at": "2019-08-07T17:44:44Z",
        "body": "@lbargaoanu Thank you very much. I've been putting out other fires but kept your response and tried it out when I came up for air. Worked like a charm! I'm rather new to AutoMapper so wasn't aware of this feature.\r\n\r\n```\r\nAutoMapper.Mapper.Initialize(config => {\r\n  config.CreateMap<UserClaim, Claim>()\r\n     .ConstructUsing(userClaim => new Claim(\r\n              userClaim.ClaimType.ClaimTypeName\r\n            , userClaim.ClaimValue\r\n         )\r\n     );\r\n  ...\r\n```\r\n\r\nThank you once again!"
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-09-07T18:31:48Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3165,
    "title": "Multiple beforemaps.",
    "created_at": "2019-07-12T16:42:34Z",
    "closed_at": "2019-07-15T04:33:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3165",
    "body": "I've extended Automapper to explicitly load collections in EFCore.  This routine uses BeforeMap.\r\n\r\nI've also mapped objects using BeforeMap.  So, the mapping essentially includes two BeforeMaps.  The order of operations becomes important here.\r\n\r\nI've discovered that the last \"beforemap\" in the mapping definition ends up executing first.\r\n\r\nMy question is whether this behavior is something I can count on for future releases or there could be an OrderOfExecution parameter at some point to govern this behavior?\r\n\r\nFor example:\r\n```\r\n.BeforeMap((src, dest) =>\r\n{\r\n   //code here\r\n})\r\n.LoadDestinationCollections(ent => new { ent.<collection1>, ent.<collection2>});  //this ends up executing first.\r\n\r\n```\r\n\r\nThanks!\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3165/comments",
    "author": "foobarred1",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-07-13T06:24:23Z",
        "body": "Maybe you should use ProjectTo. Or a single BeforeMap."
      },
      {
        "user": "foobarred1",
        "created_at": "2019-07-17T13:01:37Z",
        "body": "So, to be clear, multiple BeforeMaps are not officially supported.  Correct?"
      },
      {
        "user": "lbargaoanu",
        "created_at": "2019-07-17T13:04:50Z",
        "body": "To be honest I was surprised that's even possible for the same map. But I believe the intent was for it to work as an event, no order implied."
      },
      {
        "user": "foobarred1",
        "created_at": "2019-07-17T16:21:56Z",
        "body": "Okay, thanks.  I suppose it would be great for me if this was supported, but if not, I think I can live with it, and figure out a workaround.  Maybe if others chime in and request the same you could consider it."
      },
      {
        "user": "foobarred1",
        "created_at": "2019-07-22T13:32:54Z",
        "body": "Just as an FYI, I solved this issue by modifying my extension to accept a second parameter so that:\r\n\r\n```\r\n.LoadDestinationCollections(ent => new { ent.<collection1>, ent.<collection2>}, (src,dest,context) => {\r\n  //beforemap code.\r\n});\r\n\r\n```\r\n\r\nThe extension will then Invoke the \"beforemap\" code guaranteeing the order of execution.\r\n\r\n\r\n"
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-08-22T14:31:44Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3163,
    "title": "Using AutoMapper for deep copy of object returns same instance",
    "created_at": "2019-07-10T12:19:33Z",
    "closed_at": "2019-07-10T12:29:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3163",
    "body": "### Source/destination types\r\n\r\n```csharp\r\n// Put your source/destination types here\r\n```\r\nclass TDao\r\n{\r\n  public Guid Id {get;set;}\r\n}\r\n### Mapping configuration\r\n\r\n```csharp\r\n// Mapper.Initialize or just the CreateMap snippet \r\n```\r\n\r\n### Version: 8.1.1\r\n\r\n### Expected behavior\r\n\r\nAccording to documentation this should create a new object.\r\n\r\n### Actual behavior\r\n\r\nIf the source and target type are the same then all Map methods seem to return the source object.\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\nTDao dao = _mapper.Map<TDao>(source);\r\n\r\nif (dao == source) {\r\n // this should not happen and new instance should be returned\r\n}\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3163/comments",
    "author": "voloda",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-07-10T12:29:35Z",
        "body": "I think this is better suited for StackOverflow. About the documentation, a PR is welcome."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-08-10T12:31:43Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3137,
    "title": "â€œMemberList.Sourceâ€ not throwing exception when it should",
    "created_at": "2019-06-20T06:15:58Z",
    "closed_at": "2019-06-20T06:51:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3137",
    "body": "I have the following models:\r\n\r\n    public class A\r\n    {\r\n        public int a1;\r\n        public int a2;\r\n        public int a3;\r\n        public int a4;\r\n        public B b;\r\n    }\r\n\r\n    public class B\r\n    {\r\n        public int b1;\r\n        public int b2;\r\n        public C c;\r\n    }\r\n\r\n    public class C\r\n    {\r\n        public int c1;\r\n        public int c2;\r\n    }\r\n\r\n    public class A_DTO\r\n    {\r\n        public int a1;\r\n        public int a2;\r\n        public int a3;\r\n        public B_DTO b;\r\n    }\r\n\r\n\r\n    public class B_DTO\r\n    {\r\n        public int b1x;\r\n        public int b2;\r\n        public C_DTO c;\r\n    }\r\n\r\n    public class C_DTO\r\n    {\r\n        public int c1;\r\n    }\r\n\r\nAnd here are my objectives:\r\n\r\n 1. Map each member in source to the member in destination with the same name (including inheritance)\r\n 2. Create custom map for A.b.b1 --> A_DTO.b.b1x\r\n 3. Explicitly say that there is no mapping for A.b.c.c2\r\n 4. If there is an unmapped property in source that is not explicitly mapped AND cannot be mapped based on same name, throw exception\r\n\r\nAnd here is the configuration I am using for that:\r\n\r\n            var config = new MapperConfiguration(\r\n                cfg => {\r\n                    cfg.CreateMap<A, A_DTO>(MemberList.Source);\r\n                    cfg.CreateMap<B, B_DTO>(MemberList.Source)\r\n                    .ForMember(dest => dest.b1x, opt => opt.MapFrom(src => src.b1));\r\n                    cfg.CreateMap<C, C_DTO>(MemberList.Source)\r\n                    .ForSourceMember(src => src.c2, opt => opt.DoNotValidate());\r\n                }\r\n            );\r\n\r\nAnd here is the test data I used:\r\n\r\n            var mapper = config.CreateMapper();\r\n            A a = new A()\r\n            {\r\n                a1 = 1,\r\n                a2 = 2,\r\n                a3 = 3,\r\n                a4 = 10,\r\n                b = new B\r\n                {\r\n                    b1 = 4,\r\n                    b2 = 5,\r\n                    c = new C\r\n                    {\r\n                        c1 = 6,\r\n                        c2 = 7\r\n                    }\r\n                }\r\n            };\r\n\r\n            A_DTO aDto = new A_DTO();\r\n\r\n            mapper.Map(a, aDto);\r\n\r\n\r\nThis meets all the conditions I listed above except the last one because `a4` does not exist on `A_DTO` and I still do not get an exception. (Whereas if I remove `.ForSourceMember(src => src.c2, opt => opt.DoNotValidate())`, it does throw exception for `c2`.)\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3137/comments",
    "author": "hakankurcenlivivense",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-06-20T06:51:12Z",
        "body": "Let's continue on SO."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-07-21T07:42:19Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3132,
    "title": "ProjectTo failing with self-relationship",
    "created_at": "2019-06-19T10:26:42Z",
    "closed_at": "2019-06-19T11:08:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3132",
    "body": "EF Core Mapping problem:\r\n\r\nI have a class Event that has a property Parent. Basically Events form a hierarchy. This is normally limited (2-3 levels deep), so loading them all is not a problem.\r\n\r\n    public class Event : IIdentityEntity\r\n    {\r\n\r\n        [Key]\r\n        public Guid Identity { get; set; }\r\n\r\n        public Int32 Id { get; set; }\r\n\r\n        public Event Parent { get; set; }\r\n\r\n    }\r\n\r\nThere obviously are a lot more data properties, but I leave them out as they are not relevant here. I load them with EF Core from tables with funny naming ;)\r\n\r\nThe 1:1 mapping from Event to the parent works, which is confirmed by a direct test:\r\n\r\n                var incidents = await repository.OBTIncident\r\n                    .Include(x => x.OBTIncident_FkParentID)\r\n                    .Where(x => x.OBTIncident_FkParentID != null)\r\n                    .ToArrayAsync();\r\n\r\nI have this in a unit test and this will get all events (in their OBTIncident table) that have a parent. Works like a charm.\r\n\r\nNow, I try to do the same with the events that are going through mapping.\r\n\r\nI pull them through my standard generic mapping code:\r\n\r\n                        var query = Repository.Set<T>()\r\n                            // No tracking. \r\n                            .AsNoTracking()\r\n                            .ProjectTo<P>(EmptyParams, includes)\r\n                        ;\r\n\r\nand the includes include the \"Parent\" property.\r\n\r\nIn my event mappings I ahve defined:\r\n\r\n            CreateMap<Data.Core.OBTIncident, Api.Odata.Event>()\r\n               .ForMember(d => d.Identity, o => o.MapFrom(s => s.GIdentity))\r\n               .ForMember(d => d.Id, o => o.MapFrom(s => s.PkIncidentID))\r\n               .ForMember(d => d.Parent, o => { o.MapFrom(s => s.OBTIncident_FkParentID);  o.ExplicitExpansion(); })                \r\n               .ForAllOtherMembers(o => o.Ignore())\r\n\r\nI look at the generated  SQL and there is no attempt to load the parent - and parents are not loaded in the output.\r\n\r\nI have a ton of other mappings in this project, which work perfectly. I ahve a TON of relationships, and they ALSO work perfect. This is the only one failing - and it is also the only self-reference (i.e. all other relationships go between different mapped classes, i.e. x -> a, x->b->a, not x->parentwhichisx)\r\n\r\nA look at the geneated expression:\r\n\r\n.Call System.Linq.Queryable.Select(\r\n    .Call Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AsNoTracking(.Constant<Microsoft.EntityFrameworkCore.Query.Internal.EntityQueryable`1[Data.Core.OBTIncident]>(Microsoft.EntityFrameworkCore.Query.Internal.EntityQueryable`1[Data.Core.OBTIncident]))\r\n    ,\r\n    '(.Lambda #Lambda1<System.Func`2[Data.Core.OBTIncident,Api.Odata.Event]>))\r\n\r\n.Lambda #Lambda1<System.Func`2[Data.Core.OBTIncident,Api.Odata.Event]>(Data.Core.OBTIncident $dtoOBTIncident) {\r\n    .New Api.Odata.Event(){\r\n        Id = $dtoOBTIncident.PkIncidentID,\r\n        Identity = $dtoOBTIncident.GIdentity,\r\n    }\r\n}\r\n\r\nshows (I removed all data properties except id and identity) that parent is simply not mapped at all to the output.\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3132/comments",
    "author": "NetTecture",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-06-19T10:38:42Z",
        "body": "Write a LINQ statement that does what you want."
      },
      {
        "user": "NetTecture",
        "created_at": "2019-06-19T10:46:25Z",
        "body": "You mean \"do not use automapper\"? Yeah, looks like an idea.\r\n\r\nSee, the whole problem is that we DO write linq statements in front of automapper, but they do not make it throug hthe project to.\r\n\r\n                var incidents = await repository.OBTIncident\r\n                    .ProjectTo<OdataApi.Event>(new Dictionary<String, Object>(), \"Parent\")\r\n                    .Where(x=>x.Parent != null)\r\n                    .ToArrayAsync();\r\n\r\nis the direct simple way and it results in this SQL:\r\n\r\nSELECT [dtoOBTIncident].[dCreateDate] AS [Created], [dtoOBTIncident].[pkIncidentID] AS [Id], [dtoOBTIncident].[gIdentity] AS [Identity]\r\nFROM [dbo].[OB_TIncident] AS [dtoOBTIncident]\r\n\r\nThe including parent and the filter are simply removed."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2019-06-19T11:03:41Z",
        "body": "No, I mean just that. Forget about AM and write a LINQ query that does what you want. Once you've done that and that query returns the correct data, we can see how you can write that with ProjectTo."
      },
      {
        "user": "NetTecture",
        "created_at": "2019-06-19T11:05:35Z",
        "body": "Already done that?\r\n\r\n            var incidents = await repository.OBTIncident\r\n                .Include(x => x.OBTIncident_FkParentID)\r\n                .Where(x => x.OBTIncident_FkParentID != null)\r\n                .ToArrayAsync();\r\n\r\nfrom the first code example in my original post."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2019-06-19T11:08:26Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "NetTecture",
        "created_at": "2019-06-19T11:09:10Z",
        "body": "Really? So, even with a fully repro you would say \"ok, just swallowing queries is not a bug because hey, it works in any other case, so there is no chance this is a bug\". See.\r\n\r\nAnd btw., this is not a question, it is a bug report."
      },
      {
        "user": "lbargaoanu",
        "created_at": "2019-06-19T11:12:20Z",
        "body": "It seems to me like you don't understand the problem you're trying to solve. And that's alright, but SO is the place for this kind of questions."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-07-20T11:42:16Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3131,
    "title": "Bug: unable to convert from IDataReader to List<POCO> in v8.1.1",
    "created_at": "2019-06-18T11:41:55Z",
    "closed_at": "2019-06-18T11:43:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3131",
    "body": "Previously we had a working implementation using AutoMapper v8.0.0 and AutoMapper.Data v3.0.0.  After upgrading AutoMapper to v8.1.1 our mappings from IDataReader to collections of C# objects stopped working.\r\n\r\n### Source/destination types\r\n\r\n```csharp\r\n  SqlDataReader\r\n```\r\n\r\n### Mapping configuration\r\n\r\n```csharp\r\n\t\t\tvar config = new MapperConfiguration(cfg =>\r\n\t\t\t{\r\n\t\t\t\tcfg.AddDataReaderMapping();\r\n\t\t\t});\r\n\r\n\t\t\tconfig.AssertConfigurationIsValid();\r\n\t\t\treturn config.CreateMapper();\r\n```\r\nNote: we do not add mappings for each POCO type, but rely on the default mechansim in AutoMapper.Data which maps columns to properties with the same name.\r\n\r\n### Version: 8.1.1\r\nAutoMapper.Data 3.0.0\r\n.Net Framework 4.6.1\r\n<!-- \r\n    Include the major/minor version (4.2.1, 5.2.0, 6.0.2 etc) \r\n    If you're using ProjectTo, also specify the EF Core or EF6 version.\r\n--> \r\n\r\n### Expected behavior\r\n\r\nWhen using AutoMapper.Data it should be possible to map from an IDataReader to a list of C# objects without any further mapping required.\r\n\r\nThis works in version 8.0.0 but throws an exception in v8.1.1\r\n\r\n### Actual behavior\r\n\r\nException thrown: \r\n\r\nAutoMapper.AutoMapperMappingException\r\n Message=Error mapping types.\r\n\r\nInner Exception:\r\nMissing type map configuration or unsupported mapping.\r\nMapping types: IDataRecord -> POCO\r\n\r\n<!-- What happened instead? -->\r\n\r\n### Steps to reproduce\r\n\r\n```csharp\r\nvar sqlReader = GetDatabaseObjects();\r\nvar pocos = mapper.map<List<POCO>>(sqlReader)\r\n\r\n// Your calls to Mapper.Map or ProjectTo here, with source/destination objects constructed\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3131/comments",
    "author": "roblugt",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-06-18T11:43:45Z",
        "body": "That's a different repo."
      },
      {
        "user": "roblugt",
        "created_at": "2019-06-18T11:50:45Z",
        "body": "> That's a different repo.\r\n\r\nWhat is? Do you mean the error is in AutoMapper.Data?  How can you be sure?  And are you also saying that a minor version change in AutoMapper can break other components?"
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-07-19T12:42:16Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3125,
    "title": "Problem with mapping if the maps are in separate classes",
    "created_at": "2019-06-17T12:01:03Z",
    "closed_at": "2019-06-17T12:55:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3125",
    "body": "AutoMapper versions: 8.1.1\r\nThe previous version worked!\r\n\r\nLet's look at the code below:\r\n\r\n```\r\n    public class A\r\n    {\r\n        public int P1 { get; set; }\r\n    }\r\n\r\n    public class B\r\n    {\r\n        public int P1 { get; set; }\r\n    }\r\n\r\n    public class C\r\n    {\r\n        public List<A> List { get; set; }\r\n    }\r\n\r\n    public class D\r\n    {\r\n        public List<B> List { get; set; }\r\n    }\r\n\r\n    public sealed class C_To_D : MapperConfigurationExpression\r\n    {\r\n        public C_To_D()\r\n        {\r\n             // â†“ it would work â†“\r\n            //CreateMap<A, B>()\r\n            //    .ForMember(_ => _.P1, _ => _.MapFrom(v => v.P1));\r\n\r\n            CreateMap<C, D>()\r\n                .ForMember(_ => _.List, _ => _.MapFrom(v => v.List));\r\n        }\r\n    }\r\n\r\n    public sealed class A_To_B : MapperConfigurationExpression\r\n    {\r\n        public A_To_B()\r\n        {\r\n             // â†“ it does not work â†“\r\n            CreateMap<A, B>()\r\n                .ForMember(_ => _.P1, _ => _.MapFrom(v => v.P1));\r\n        }\r\n    }\r\n```\r\nIf the map from A to B is in a separate class then:\r\n\r\n**Message: AutoMapper.AutoMapperConfigurationException : The following member on ...D cannot be mapped: \r\n\tList \r\nAdd a custom mapping expression, ignore, add a custom resolver, or modify the destination type ...D.\r\nContext:\r\n\tMapping to member List from ...C to ...D\r\nException of type 'AutoMapper.AutoMapperConfigurationException' was thrown.**\r\n\r\nThe project is so large that it is impossible to have maps in this way. Please help.",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3125/comments",
    "author": "Tomaszczubaszek",
    "comments": [
      {
        "user": "jbogard",
        "created_at": "2019-06-17T12:33:33Z",
        "body": "Why are your classes inheriting from `MapperConfigurationExpression`? That's the class that performs configuration once for the entire mapper.\r\n\r\nTypically you use `Profile` classes to segregate configuration."
      },
      {
        "user": "Tomaszczubaszek",
        "created_at": "2019-06-17T12:55:23Z",
        "body": "Thanks, correcting this solves the problem."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-07-18T19:42:16Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3104,
    "title": "byte to int error",
    "created_at": "2019-05-30T07:36:23Z",
    "closed_at": "2019-05-30T08:02:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3104",
    "body": "I use AutoMapper.Data 2.0  & AutoMapper 7.0.1ï¼Œand net framework 4.5\r\nI have a property in my dest class, but the field in sqlserver has the type \"tinyint\".\r\n``` \r\n  public int click{get;set;}\r\n```\r\n\r\nI try some code like below, it works. \r\nbut when I remove the \"ForMember \"ï¼ŒI got an error: cast type error. \r\nI use the automapper source to debug it,  I found I got a [byte] value from datarecord.when try to set value to dest class. cast type error occur!\r\nwhy [byte] cannot auto cast to [int]?\r\n```\r\n var config = new MapperConfiguration(cfg =>\r\n                {\r\n                    cfg.AddDataReaderMapping();\r\n                    cfg.CreateMissingTypeMaps = true;\r\n                    cfg.CreateMap<IDataRecord, ModelWithFoundingGroup>()\r\n                        .ForMember(dest => dest.click,\r\n                            options => options.MapFrom(src =>\r\n                                src.GetByte(src.GetOrdinal(nameof(ModelWithFoundingGroup.click)))))\r\n                   \r\n                });\r\n                var mapper = config.CreateMapper();\r\n                model = mapper.Map<IDataRecord, ModelWithFoundingGroup>(dataRecord);\r\n```",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3104/comments",
    "author": "xyfy",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-05-30T08:02:57Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "xyfy",
        "created_at": "2019-05-30T08:23:28Z",
        "body": "            int i = 1;\r\n            byte m = 1;\r\n            i = m;\r\n\r\nthe code above can work well.\r\n\r\nwhy in automapper , it got a  cast type error?"
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-06-30T12:15:21Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3099,
    "title": "Conditional inheritance with AutoMapper",
    "created_at": "2019-05-28T07:03:30Z",
    "closed_at": "2019-05-28T07:10:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3099",
    "body": "Hello,\r\n\r\nI have a small problem regarding the use conditional inheritance with AutoMapper in the DTO to Entity direction.\r\n\r\nI have inheritance (TPH) between my entities, namely an abstract mother class \"**ConnectorBaseEntity**\".\r\n\r\nAnd two children classes:\r\n\"**ConnectorOracleEntity**\" and \"**ConnectorMySQLEntity**\"\r\n\r\nTo add a new connector, I go through a end point POST type that takes as parameter a \"**ConnectorCreateDTO**\" which contains all the properties of children.\r\n\r\nI defined my mapping between my DTO and my classes like this:\r\n\r\n```csharp\r\nCreateMap<ConnectorCreateDTO, ConnectorBaseEntity>().As<ConnectorOracleEntity>();\r\nCreateMap<ConnectorCreateDTO, ConnectorOracleEntity>();\r\n\r\nCreateMap<ConnectorCreateDTO, ConnectorBaseEntity>().As<ConnectorMySQLEntity>();\r\nCreateMap<ConnectorCreateDTO, ConnectorMySQLEntity>();\r\n ```\r\n\r\nI use the \"**As**\" because my mother entity is abstract, I can not use it, so I use the derived type as a base.       \r\n\r\nThen in my controller I map:\r\n\r\n```csharp\r\n_mapper.Map <ConnectorBaseEntity> (connectorCreateDTO)\r\n ```\r\n\r\nThe problem is that I do not know how to tell AutoMapper to use the right child based on the \"**type**\" property in my \"ConnectorCreateDTO\".\r\n\r\nI have to make a big \"if\" or a \"switch\" to handle all the mapping cases in my controller?\r\n```csharp\r\nif(connectorCreateDTO.Type == ProviderTypeEnum.ORACLE){\r\n       _mapper.Map<ConnectorOracleEntity>(connectorCreateDTO)\r\n}\r\nif(connectorCreateDTO.Type == ProviderTypeEnum.MYSQL){\r\n       _mapper.Map<ConnectorMySQLEntity>(connectorCreateDTO)\r\n}\r\n ```\r\n\r\nIs there not a cleaner way to handle inheritance conditions directly in the map?\r\n\r\nWhat do you recommend ?\r\n\r\nThank you.\r\n\r\n### Version: \r\nAutoMapper 8.1.0\r\nPomelo.EntityFrameworkCore.MySql 2.2.0",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3099/comments",
    "author": "aborderon",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-05-28T07:10:42Z",
        "body": "There is nothing built in to help you with that. This has been discussed many times before, here and on SO. You'll have to choose one of the solutions people used before. If all you need is to create the destination object, `ConstructUsing` can help."
      },
      {
        "user": "aborderon",
        "created_at": "2019-05-29T06:48:34Z",
        "body": "Thank you for this orientation, I solved my problem with ConstrucUsing and a Factory."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-06-29T07:50:41Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3092,
    "title": "Ignore a property of nested object list",
    "created_at": "2019-05-22T13:46:20Z",
    "closed_at": "2019-05-22T13:46:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3092",
    "body": "Hi,\r\nIs it possible to ignore a property of  child object list?\r\nI want to ignore UserPostComment  of UserPostCommentAttachments of below example.\r\nEx: \r\nSource Class\r\n    public class UserPostComment : IEntity, IModifyStamp\r\n    {\r\n        public UserPostComment()\r\n        {\r\n            this.UserPostCommentAttachments = new List<UserPostCommentAttachment>();\r\n        }\r\n      \r\n        public int Id{get;set;}\r\n        public virtual UserPost UserPost { get; set; }\r\n        public virtual ICollection<UserPostCommentAttachment> UserPostCommentAttachments { get; set; }\r\n    }\r\n\r\nDestination Class\r\n public UserPostComment()\r\n        {\r\n            this.UserPostCommentAttachments = new List<UserPostCommentAttachment>();\r\n        }\r\n\r\n        public int Id { get; set; }\r\n        public int? UserId { get; set; }\r\n        public ICollection<UserPostCommentAttachment> UserPostCommentAttachments { get; set; }\r\n\r\nNested Object Class\r\npublic class UserPostCommentAttachment\r\n{\r\n public int? UserPostCommentId { get; set; }\r\n  public UserPostComment UserPostComment { get; set; }\r\n}\r\n\r\nThanks\r\nChaminda\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3092/comments",
    "author": "kodithuwa",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-05-22T13:46:59Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-06-25T15:42:13Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3089,
    "title": "Has anyone hit this bug in .Net Core 2.x?",
    "created_at": "2019-05-21T19:07:36Z",
    "closed_at": "2019-05-28T14:26:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3089",
    "body": "dotnet/coreclr#24676 describes a jit bug in .Net Core 2.1 and 2.2 that impacts Automapper when used in conjunction with a profiler. The bug happens only on Linux x64, and involves struct types that need more than 8 bytes of storage (eg `Nullable<long>`). \r\n\r\nIf anyone has hit this bug can you add information to the issue linked above?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3089/comments",
    "author": "AndyAyersMS",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-05-21T19:29:49Z",
        "body": "I didn't see anything similar here or on SO."
      },
      {
        "user": "iskiselev",
        "created_at": "2019-05-22T17:13:47Z",
        "body": "Sample stack trace for this errors:\r\n```\r\nUnhandled Exception: System.EntryPointNotFoundException: Entry point was not found.\r\n   at AutoMapper.IMemberMap.get_UseDestinationValue()\r\n   at AutoMapper.Execution.ExpressionBuilder.NullCheckSource(ProfileMap profileMap, Expression sourceParameter, Expression destinationParameter, Expression objectMapperExpression, IMemberMap memberMap)\r\n   at AutoMapper.Execution.ExpressionBuilder.MapExpression(IConfigurationProvider configurationProvider, ProfileMap profileMap, TypePair typePair, Expression sourceParameter, Expression contextParameter, IMemberMap propertyMap, Expression destinationParameter)\r\n   at AutoMapper.Mappers.NullableDestinationMapper.MapExpression(IConfigurationProvider configurationProvider, ProfileMap profileMap, IMemberMap memberMap, Expression sourceExpression, Expression destExpression, Expression contextExpression)\r\n   at AutoMapper.Execution.ExpressionBuilder.MapExpression(IConfigurationProvider configurationProvider, ProfileMap profileMap, TypePair typePair, Expression sourceParameter, Expression contextParameter, IMemberMap propertyMap, Expression destinationParameter)\r\n   at AutoMapper.Mappers.NullableSourceMapper.MapExpression(IConfigurationProvider configurationProvider, ProfileMap profileMap, IMemberMap memberMap, Expression sourceExpression, Expression destExpression, Expression contextExpression)\r\n   at AutoMapper.Execution.ExpressionBuilder.MapExpression(IConfigurationProvider configurationProvider, ProfileMap profileMap, TypePair typePair, Expression sourceParameter, Expression contextParameter, IMemberMap propertyMap, Expression destinationParameter)\r\n   at AutoMapper.Execution.TypeMapPlanBuilder.CreatePropertyMapFunc(IMemberMap memberMap, Expression destination, MemberInfo destinationMember)\r\n   at AutoMapper.Execution.TypeMapPlanBuilder.TryPropertyMap(PropertyMap propertyMap)\r\n   at AutoMapper.Execution.TypeMapPlanBuilder.CreateAssignmentFunc(Expression destinationFunc)\r\n   at AutoMapper.Execution.TypeMapPlanBuilder.CreateMapperLambda(HashSet`1 typeMapsPath)\r\n   at AutoMapper.TypeMap.Seal(IConfigurationProvider configurationProvider)\r\n   at AutoMapper.MapperConfiguration.Seal()\r\n   at AutoMapper.MapperConfiguration..ctor(MapperConfigurationExpression configurationExpression)\r\n   at AutoMapper.Mapper.Initialize(Action`1 config)\r\n```\r\n```\r\nSystem.EntryPointNotFoundException: Entry point was not found.\r\n  at AutoMapper.IMemberMap.get_UseDestinationValue()\r\n  at AutoMapper.Mappers.Internal.CollectionMapperExpressionFactory.<MapCollectionExpression>g__UseDestinationValue|1_0(<>c__DisplayClass1_0& )\r\n  at AutoMapper.Mappers.Internal.CollectionMapperExpressionFactory.MapCollectionExpression(IConfigurationProvider configurationProvider, ProfileMap profileMap, IMemberMap memberMap, Expression sourceExpression, Expression destExpression, Expression contextExpression, Type ifInterfaceType, MapItem mapItem)\r\n  at AutoMapper.Mappers.CollectionMapper.MapExpression(IConfigurationProvider configurationProvider, ProfileMap profileMap, IMemberMap memberMap, Expression sourceExpression, Expression destExpression, Expression contextExpression)\r\n  at AutoMapper.Execution.ExpressionBuilder.MapExpression(IConfigurationProvider configurationProvider, ProfileMap profileMap, TypePair typePair, Expression sourceParameter, Expression contextParameter, IMemberMap propertyMap, Expression destinationParameter)\r\n  at AutoMapper.Execution.TypeMapPlanBuilder.CreatePropertyMapFunc(IMemberMap memberMap, Expression destination, MemberInfo destinationMember)\r\n  at AutoMapper.Execution.TypeMapPlanBuilder.TryPropertyMap(PropertyMap propertyMap)\r\n  at AutoMapper.Execution.TypeMapPlanBuilder.CreateAssignmentFunc(Expression destinationFunc)\r\n  at AutoMapper.Execution.TypeMapPlanBuilder.CreateMapperLambda(HashSet`1 typeMapsPath)\r\n  at AutoMapper.TypeMap.Seal(IConfigurationProvider configurationProvider)\r\n  at AutoMapper.MapperConfiguration.Seal()\r\n  at AutoMapper.MapperConfiguration..ctor(MapperConfigurationExpression configurationExpression)\r\n```\r\n\r\nIn both cases object that is used to call `AutoMapper.IMemberMap.get_UseDestinationValue()` do not implement `IMemberMap` interface, as due too mentioned CLR issue incorrect argument was from function (in first case `ExpressionBuilder.ObjectMapperExpression` is responsble for it, but not visible in stack trace as tail call was used to call `NullableSourceMapper.MapExpression`)."
      },
      {
        "user": "iskiselev",
        "created_at": "2019-05-23T04:43:16Z",
        "body": "Another profiler hited by same issue: DataDog/dd-trace-dotnet#302"
      },
      {
        "user": "lucaspimentel",
        "created_at": "2019-05-28T19:27:45Z",
        "body": "Thanks for calling this github issue to our attention, @iskiselev. Here's a minimal repro using AutoMapper:\r\n\r\n```csharp\r\n   public class Program\r\n    {\r\n        public static void Main()\r\n        {\r\n            Mapper.Initialize(\r\n                configuration =>\r\n                {\r\n                    configuration.CreateMap<Model1, Model2>();\r\n                });\r\n        }\r\n    }\r\n\r\n    public class Model1\r\n    {\r\n        public List<string> Items { get; set; }\r\n    }\r\n\r\n    public class Model2\r\n    {\r\n        // changing this to string[] avoids the problem\r\n        public List<string> Items { get; set; }\r\n    }\r\n```\r\n\r\nCan repro on Linux with .NET Core 2.1 and 2.2, not on Windows."
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-06-29T14:03:39Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3078,
    "title": "ConstructUsing not working",
    "created_at": "2019-05-14T12:09:35Z",
    "closed_at": "2019-05-14T12:21:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3078",
    "body": "Hi there, I'm having trouble with ConstructUsing method. The field 'Thumbnail' is not changing even after resolving the context. Any suggesstion please?\r\n\r\n`\r\n var command = Mapper.Map<CreateDeviceApp.Command>(model, opt =>\r\n            {\r\n                opt.Items[\"Thumbnail\"] = uploadImageResponse.Uri;\r\n            });\r\n`\r\n\r\n\r\n`\r\nCreateMap<CreateDeviceAppViewModel, CreateDeviceApp.Command>().ConstructUsing((src, ctxt) => new CreateDeviceApp.Command() { Thumbnail = ctxt.Options.Items[\"Thumbnail\"].ToString() });\r\n`",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3078/comments",
    "author": "BetimShala",
    "comments": [
      {
        "user": "lbargaoanu",
        "created_at": "2019-05-14T12:21:52Z",
        "body": "I think this is better suited for StackOverflow."
      },
      {
        "user": "BetimShala",
        "created_at": "2019-05-14T12:35:31Z",
        "body": "> I think this is better suited for StackOverflow.\r\n\r\nI have posted also in StackOverflow, but I think that I have found where's the problem, the Thumbnail property is part of CreateDeviceApp.Command and also part of CreateDeviceAppViewModel so what's going on here is that the AutoMapper is ignoring the ConstructUsing method because it just mapped all the properties (including 'Thumbnail' property). \r\n@lbargaoanu What's your comment on this, do you think this is happening or it may be something else?\r\n\r\nThank you. "
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-07-03T04:50:20Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  },
  {
    "number": 3070,
    "title": "LockBot has spammed aver 1200 message in the last 3 days!",
    "created_at": "2019-05-06T23:13:01Z",
    "closed_at": "2019-05-07T02:03:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/AutoMapper/AutoMapper/issues/3070",
    "body": "Not an issue with the repository code.  Is there any way to mute LockBot?  I don't need the messages in my inbox.\r\n\r\nTIA",
    "comments_url": "https://api.github.com/repos/AutoMapper/AutoMapper/issues/3070/comments",
    "author": "KeithBarrows",
    "comments": [
      {
        "user": "jbogard",
        "created_at": "2019-05-07T02:00:29Z",
        "body": "Unsubscribe from notifications"
      },
      {
        "user": "lock[bot]",
        "created_at": "2019-07-03T04:50:09Z",
        "body": "This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
      }
    ]
  }
]