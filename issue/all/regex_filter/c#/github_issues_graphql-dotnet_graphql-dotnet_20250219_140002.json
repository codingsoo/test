[
  {
    "number": 3586,
    "title": "Nullable reference types best practice for nullable field",
    "created_at": "2023-04-12T16:53:28Z",
    "closed_at": "2023-04-23T14:24:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3586",
    "body": "I use the GraphQL package 7.2.2.\r\nI have recently enable nullable refernce types in my GraphQL project and I was wondering how I could handle this snippet:\r\n\r\n```csharp\r\nField<Project, ProjectViewModel?>(\"Project\")\r\n    .ResolveAsync(ctx =>\r\n    {\r\n        if (ctx.Source.ProjectId > 0)\r\n        {\r\n            var loader = accessor.Context!.GetOrAddBatchLoader<int, ProjectViewModel>\r\n            (\"projectDataStore\", x => projectDataStore.GetItem(x, ctx));\r\n            return loader.LoadAsync((int)ctx.Source.ProjectId);\r\n        }\r\n        return null;\r\n    });\r\n```\r\nSo, here my type has a field \"Project\" that can be null. The type \"Project\" doesn't have the \"nonnull\" tags around it and the viewModel has the \"?\" at the end. The issue is that I get the warning on the first line:\r\n```\r\nWarning CS8620: Argument of type 'FieldBuilder<ActivityViewModel, ProjectViewModel?>' cannot be used for parameter 'builder' of\r\ntype 'FieldBuilder<ActivityViewModel, ProjectViewModel>' in 'FieldBuilder<ActivityViewModel, ProjectViewModel>\r\nDataLoaderExtensions.ResolveAsync<ActivityViewModel, ProjectViewModel>(FieldBuilder<ActivityViewModel, ProjectViewModel>\r\nbuilder, Func<IResolveFieldContext<ActivityViewModel>, IDataLoaderResult<ProjectViewModel>> resolve)' due to\r\ndifferences in the nullability of reference types.\r\n```\r\nand this warning on the `return null;` line:\r\n`Possible null reference return`\r\nI don't understand why, the ViewModel has a \"?\" at the end. It looks like ot only looks at what the dataloader returns.\r\n\r\nHonestly, this all works fine, the dataloader is skipped if the projectId is null, and when it's not, the ProjectViewModel is returned. \r\n\r\nThe datastore GetItem in case this helps (it creates a new scope for parallel execution):\r\n```\r\npublic async Task<IDictionary<int, TViewModel>> GetItem(IEnumerable<int> ids, IResolveFieldContext ctx)\r\n{\r\n    using var scope = ctx.RequestServices!.CreateRequestScope();\r\n    var resource = scope.ServiceProvider.GetRequiredService<TResource>();\r\n\r\n    var result = await _mapper.Value.ProjectTo<TViewModel>(resource.GetQueryable()\r\n        .Where(x => ids.Contains(x.Id)))\r\n        .ToListAsync();\r\n\r\n    return result.ToDictionary(x => x.Id);\r\n}\r\n```\r\n\r\nI already tried changing the whole datastore to simply return `TViewModel?`, but then it creates warnings for when the viewModel is not nullable. If I go that route I should make two methods: one \"GetIOtem\" and one \"GetNullableItem\". Before i go there I'd like to know what you guys think. ",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3586/comments",
    "author": "julienFlexsoft",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2023-04-12T17:20:52Z",
        "body": "I'm guessing it's because you're returning `IDataLoaderResult<ProjectViewModel>` or `null`, so the definition is `IDataLoaderResult<ProjectViewModel>?` not `IDataLoaderResult<ProjectViewModel?>`.\r\n\r\nThis is fine for GraphQL.NET, as you can see.  However, the extension method we have for data loaders probably is not typed the way you are using it.\r\n\r\nYou can probably patch it with this:\r\n\r\n```cs\r\nField<Project, ProjectViewModel>(\"Project\")\r\n    .ResolveAsync(ctx =>\r\n    {\r\n        if (ctx.Source.ProjectId > 0)\r\n        {\r\n            var loader = accessor.Context!.GetOrAddBatchLoader<int, ProjectViewModel>\r\n            (\"projectDataStore\", x => projectDataStore.GetItem(x, ctx));\r\n            return loader.LoadAsync((int)ctx.Source.ProjectId);\r\n        }\r\n        return null!;\r\n    });\r\n```\r\n\r\nOr maybe this:\r\n\r\n```cs\r\nField<Project, ProjectViewModel?>(\"Project\")\r\n    .ResolveAsync(ctx =>\r\n    {\r\n        if (ctx.Source.ProjectId > 0)\r\n        {\r\n            var loader = accessor.Context!.GetOrAddBatchLoader<int, ProjectViewModel?>\r\n            (\"projectDataStore\", x => (ProjectViewModel?)projectDataStore.GetItem(x, ctx));\r\n            return loader.LoadAsync((int)ctx.Source.ProjectId);\r\n        }\r\n        return null!;\r\n    });\r\n```\r\n\r\nOr maybe this:\r\n\r\n```cs\r\n// define a static null response\r\nvar nullResponse = new DataLoaderResult<ProjectViewModel?>(Task.FromResult((ProjectViewModel?)null));\r\n\r\nField<Project, ProjectViewModel?>(\"Project\")\r\n    .ResolveAsync(ctx =>\r\n    {\r\n        if (ctx.Source.ProjectId > 0)\r\n        {\r\n            var loader = accessor.Context!.GetOrAddBatchLoader<int, ProjectViewModel?>\r\n            (\"projectDataStore\", x => (ProjectViewModel?)projectDataStore.GetItem(x, ctx)); // is cast necessary here?\r\n            return loader.LoadAsync((int)ctx.Source.ProjectId);\r\n        }\r\n        return nullResponse;\r\n    });\r\n```\r\n\r\nOr maybe write a new `ResolveAsync` extension method for your needs.\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2023-04-12T17:23:54Z",
        "body": "Unfortunately `Task<T>` is not `Task<out T>` (it is not covariant, as only interfaces can be variant) which means that `IDataLoaderResult` isn't covariant either.  Not much we can do about that.  So I think that means that widening conversions will not automatically take place when returning values."
      },
      {
        "user": "Shane32",
        "created_at": "2023-04-23T14:24:50Z",
        "body": "Closing as answered"
      }
    ]
  },
  {
    "number": 3557,
    "title": "InputObjectGraphType doesn't resolve fieldName correctly",
    "created_at": "2023-03-01T03:44:33Z",
    "closed_at": "2023-03-01T05:09:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3557",
    "body": "## Description\r\n\r\nWhen I define an InputObjectGraphType with a field\r\n\r\n```\r\nField<GuidGraphType>(\"id\")\r\n    .Description(\"Some description.\")\r\n    .Resolve(context => context.Source.SomeGuid)\r\n    .NonNull();\r\n```\r\nThe Id is set to it's default value, even though the value is set.  If I change the field name to match the actually property name it works just fine, ie\r\n\r\n```\r\nField<GuidGraphType>(\"someGuid\")\r\n    .Description(\"Some description.\")\r\n    .Resolve(context => context.Source.SomeGuid)\r\n    .NonNull();\r\n```\r\n\r\n### Steps to reproduce\r\n\r\nIn the mutation ObjectGraphType, I setup a field like so:\r\n\r\n```\r\nField<MyGraphType, MyObject>(\"setAccessGroup\")\r\n    .Description(\"Some description.\")\r\n    .Argument<NonNullGraphType<MyInputGraphType>>(\"input\")\r\n    .ResolveAsync(async context =>\r\n    {\r\n        // This next line is where it fails\r\n        var input = context.GetArgument<MyInputGraphType>(\"input\");\r\n        // database call\r\n        return result;\r\n    });\r\n\r\n### Expected result\r\n\r\nIt should map \"id\" to SomeGuid\r\n\r\n### Actual result\r\n\r\nIt only maps \"someGuid\" to SomeGuid\r\n\r\n### Environment\r\n\r\n.NET Framework 4.8\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3557/comments",
    "author": "andrewboyd-envirosuite",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2023-03-01T04:46:15Z",
        "body": "By design, field resolvers are ignored for input objects.  Use this syntax instead:\r\n\r\n```cs\r\nField(\"id\", x => x.SomeGuid, false)\r\n    .Description(\"test\");\r\n```\r\n\r\nSupplying an expression will allow GraphQL.NET to tie the field to the proper member.\r\n\r\nYou may also use the optional `type` parameter to manually specify a graph type such as `type: typeof(NonNullGraphType<GuidGraphType>)`.\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2023-03-01T04:50:29Z",
        "body": "In a future version of GraphQL.NET, we hope to split input objects off to a separate base class which will not include methods that do not apply to input objects.  But presently the `Field` methods are defined on `ComplexGraphType` which is the base class for both `InputObjectGraphType` and `ObjectGraphType`."
      },
      {
        "user": "andrewboyd-envirosuite",
        "created_at": "2023-03-01T05:03:13Z",
        "body": "Thanks, @Shane32 for the quick response!  So I tried this and I get the error `Cannot implicitly convert type 'System.Guid' to 'GraphQL.Types.GuidGraphType'`"
      },
      {
        "user": "Shane32",
        "created_at": "2023-03-01T05:04:32Z",
        "body": "You cannot use `Field<GuidGraphType>(\"id\", x => x.SomeGuid)` syntax.  You must use the syntax I stated above."
      },
      {
        "user": "Shane32",
        "created_at": "2023-03-01T05:05:13Z",
        "body": "```cs\r\n//non-null, explicit type\r\nField(\"id\", x => x.SomeGuid, false, typeof(NonNullGraphType<GuidGraphType>))\r\n    .Description(\"test\");\r\n\r\n//nullable, explicit type\r\nField(\"id\", x => x.SomeGuid, true, typeof(GuidGraphType))\r\n    .Description(\"test\");\r\n\r\n//non-null, implicit type\r\nField(\"id\", x => x.SomeGuid)\r\n    .Description(\"test\");\r\n\r\n//nullable, implicit type\r\nField(\"id\", x => x.SomeGuid, true)\r\n    .Description(\"test\");\r\n```"
      },
      {
        "user": "andrewboyd-envirosuite",
        "created_at": "2023-03-01T05:09:28Z",
        "body": "Yep, that got it! thanks mate!"
      },
      {
        "user": "sungam3r",
        "created_at": "2023-03-01T21:31:15Z",
        "body": "Rel: #1176"
      }
    ]
  },
  {
    "number": 3464,
    "title": "Is it possible to give a resolver for the underlying value of an UnionGraphType?",
    "created_at": "2022-12-24T22:27:28Z",
    "closed_at": "2023-04-24T07:18:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3464",
    "body": "I have a `UnionGraphType` where the underlying type is a container that may have an _A_ or a _B_. I want to be able to resolve the underlying value in a similar way to how I resolve the type. \r\n\r\nUnderlying union class:\r\n\r\n```csharp\r\npublic class BookOrMovie\r\n{\r\n    private readonly bool isBook; \r\n    private readonly Book book;\r\n    private readonly Movie movie;\r\n\r\n    public bool IsBook { get { return isBook; } }\r\n\r\n    public Book Book { get { return book; } }\r\n\r\n    public Movie Movie { get { return movie; } }\r\n\r\n    public BookOrMovie(Book book)\r\n    {\r\n        this.isBook = true;\r\n        this.book = book;\r\n        this.movie = null;\r\n    }\r\n\r\n    public BookOrMovie(Movie movie)\r\n    {\r\n        this.isBook = false;\r\n        this.book = null;\r\n        this.movie = movie;\r\n    }\r\n}\r\n```\r\n\r\nResolve type logic:\r\n\r\n```csharp\r\n      (x : obj) => {\r\n        var bom = x as BookOrMovie;\r\n\r\n        if (bom.IsBook) {\r\n          return new GraphQLTypeReference(\"Book\");\r\n        } else {\r\n          return new GraphQLTypeReference(\"Movie\");\r\n        }\r\n      }\r\n```\r\n\r\nThe issue is that my `Book` and `Movie` types do not understand `BookOrMovie`. \r\n\r\nIs there a way to resolve the value of a `UnionGraphType`?\r\n\r\n```csharp\r\n      (x : obj) => {\r\n        var bom = x as BookOrMovie;\r\n\r\n        if (bom.IsBook) {\r\n          return bom.Book as obj;\r\n        } else {\r\n          return bom.Movie as obj;\r\n        }\r\n      }\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3464/comments",
    "author": "njlr",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-12-24T23:42:15Z",
        "body": "No but just return the underlying type directly. Then if you’re using `ObjectGraphType<Book>` and `ObjectGraphType<Movie>` then IsTypeOf will automatically be set to detect the proper object type. \r\n\r\nSo to summarize, whatever field resolver currently returns a BookOrMovie should instead return either Book or Movie"
      },
      {
        "user": "Shane32",
        "created_at": "2022-12-24T23:45:51Z",
        "body": "So you shouldn’t need to write the “resolve type logic” (although you can with the ResolveType delegate), and the “resolve value logic” should be embedded in the field resolver that returns the value for the union. In fact you may not need the BookOrMovie class at all"
      },
      {
        "user": "njlr",
        "created_at": "2022-12-25T15:29:44Z",
        "body": "The problem is that this commits the underlying data-model to having an \"is-a\" relationship between the union type and the object type. Is this unavoidable? "
      },
      {
        "user": "Shane32",
        "created_at": "2022-12-25T15:40:35Z",
        "body": "I guess I'm not exactly sure what you're asking."
      },
      {
        "user": "Shane32",
        "created_at": "2022-12-25T15:43:51Z",
        "body": "There is no place to set a resolver on a Union type AFTER its object type has been determined, but PRIOR to resolvers on the object type, as posed in your original question.\r\n"
      },
      {
        "user": "njlr",
        "created_at": "2022-12-25T15:56:08Z",
        "body": "> I guess I'm not exactly sure what you're asking.\r\n\r\nSure, let me try again 🙂 \r\n\r\nSuppose my domain is:\r\n\r\n - Books\r\n - Movies\r\n - Media (union of books and movies)\r\n\r\nIn C#, I can model this using an interface: \r\n\r\n - `class Book : IMedia`\r\n - `class Movie : IMedia` \r\n\r\n`graphql-dotnet` works well for this arrangement. \r\n\r\n - `Book` corresponds to an `ObjectGraphType`\r\n - `Movie` corresponds to an `ObjectGraphType`\r\n - `IMedia` corresponds to a `UnionGraphType`\r\n\r\nI can implement `ResolveType` like this: \r\n\r\n```csharp\r\n(x) => {\r\n  if (x is Book) {\r\n    return GraphQLTypeReference(\"Book\");\r\n  }\r\n\r\n  if (x is Movie) {\r\n    return GraphQLTypeReference(\"Movie\");\r\n  }\r\n\r\n  throw new Exception(\"Unsupported type for Media union\")\r\n}\r\n```\r\n\r\nHowever, for other reasons unrelated to using GraphQL, I don't want to model my domain in this way. \r\n\r\nInstead, I have three sealed classes like this:\r\n\r\n - `class Book`\r\n - `class Movie`\r\n - `class BookOrMovie`\r\n\r\nAnd\r\n\r\n - `Book` corresponds to an `ObjectGraphType`\r\n - `Movie` corresponds to an `ObjectGraphType`\r\n - `BookOrMovie` corresponds to a `UnionGraphType` (`Media`)\r\n\r\nI can convert an `BookOrMovie` into either a `Book` or a `Movie` using the properties it provides. \r\n\r\n```csharp\r\nvar bookOrMovie = // ...\r\n\r\nif (bookOrMovie.IsBook) {\r\n  var book = bookOrMovie.Book;\r\n\r\n  Console.WriteLine(\"The book is \" + book.ToString());\r\n}\r\n\r\nif (bookOrMovie.IsMovie) {\r\n  var movie = bookOrMovie.Movie;\r\n\r\n  Console.WriteLine(\"The movie is \" + movie.ToString());\r\n}\r\n```\r\n\r\nHowever, how can I make this work with `graphql-dotnet`? \r\n\r\nWhen I resolve a field of type `Media`, I return a `BookOrMovie`. But this doesn't work because `BookOrMovie` cannot be cast to `Book` or `Movie`. \r\n\r\nIt seems that I am forced to use inheritance when implementing a GraphQL union. \r\n\r\nBasically, I want to be able to configure a `UnionGraphType` with a method for unpacking a union into the appropriate case. "
      },
      {
        "user": "Shane32",
        "created_at": "2022-12-25T16:00:02Z",
        "body": "Can you post a sample field definition that returns `BookOrMovie`?  This might be an example:\r\n\r\n```cs\r\nField<BookOrMovieType>(\"getById\")\r\n    .Argument<int>(\"id\")\r\n    .Resolve(context => {\r\n        var id = context.GetArgument<int>(\"id\");\r\n        var bookOrMovie = context.RequestServices.GetRequiredService<ObjectService>().GetById(id);\r\n        return bookOrMovie;\r\n    });\r\n```\r\n\r\n"
      },
      {
        "user": "njlr",
        "created_at": "2022-12-25T16:14:15Z",
        "body": "Something like this:\r\n\r\n```csharp\r\nField<List<BookOrMovieType>>(\"allMedia\")\r\n    .Resolve(context => {\r\n        var results = new List<BookOrMovie>();\r\n\r\n        results.Add(new BookOrMovie(new Movie(\"Top Gun\")));\r\n        results.Add(new BookOrMovie(new Book(\"Superforecasting\")));\r\n\r\n        return results;\r\n    });\r\n```\r\n\r\n(Sorry if it does not compile, I am mentally converting from F#)"
      },
      {
        "user": "Shane32",
        "created_at": "2022-12-25T16:16:00Z",
        "body": "```cs\r\nField<List<BookOrMovieType>>(\"allMedia\")\r\n    .Resolve(context => {\r\n        var results = new List<object>();\r\n\r\n        results.Add(Convert(new BookOrMovie(new Movie(\"Top Gun\"))));\r\n        results.Add(Convert(new BookOrMovie(new Book(\"Superforecasting\"))));\r\n\r\n        return results;\r\n    });\r\n\r\nobject Convert(BookOrMovie obj)\r\n{\r\n    return obj.IsBook ? obj.Book : obj.IsMovie ? obj.Movie : throw new InvalidOperationException();\r\n}\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2022-12-25T16:20:55Z",
        "body": "You shouldn't need to write a `ResolveType` method.  But you'd need to use this conversion method for any fields that return a BookOrMovie."
      },
      {
        "user": "sungam3r",
        "created_at": "2023-01-01T21:30:58Z",
        "body": "> Book corresponds to an ObjectGraphType\r\n    Movie corresponds to an ObjectGraphType\r\n    BookOrMovie corresponds to a UnionGraphType (Media)\r\n\r\nor BookOrMovie corresponds to a InterfaceGraphType (Media). Maybe interface is more suitable to you here.\r\n"
      }
    ]
  },
  {
    "number": 3462,
    "title": "Question: How to create static Connection field",
    "created_at": "2022-12-23T07:07:04Z",
    "closed_at": "2023-04-24T07:15:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3462",
    "body": "I  create connection like below code \r\n\r\n`  public static Connection<News> Data1()\r\n    {\r\n        return new Connection<News>();\r\n    }\r\n`\r\n`\r\n    public static Connection<ArticlePicture> Data2()\r\n    {\r\n        return new Connection<ArticlePicture>();\r\n    }`\r\n\r\nbut get error\r\n\r\n`[Error] \"Unable to register GraphType 'AutoRegisteringObjectGraphType<Connection<ArticlePicture>>' with the name 'Connection'. The name 'Connection' is already registered to 'AutoRegisteringObjectGraphType<Connection<News>>'. Check your schema configuration.\"`\r\n\r\nif only Data1 field remove Data2 field, no error.\r\n\r\n I use GraphQL Server version is GraphQL.Server.All 7.2.0 \r\n\r\nHow to create static connection correctly?\r\n\r\nCan anybody help? many thanks!\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3462/comments",
    "author": "need",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-12-23T20:34:56Z",
        "body": "The easiest way is to create a derived class of `Connection<News>` such as `class NewsConnection : Connection<News> { }`.\r\n\r\nThe second easiest answer is mark a custom type for this field with the `[OutputType]` attribute such as `[OutputType(typeof(ConnectionType<AutoRegisteringObjectGraphType<News>>))]`\r\n\r\nSince the auto-registering handler doesn't create unique names for generic types, and doesn't have any special code to recognize `Connection<T>` types, it is creating conflicting names for your schema."
      },
      {
        "user": "need",
        "created_at": "2022-12-26T03:44:41Z",
        "body": "Thanks for your reply.\r\n\r\nI try way 1 get below error\r\n`[Error] Unable to register GraphType 'AutoRegisteringObjectGraphType<Edge<ArticlePicture>>' with the name 'Edge'. The name 'Edge' is already registered to 'AutoRegisteringObjectGraphType<Edge<News>>`\r\n\r\nway 2 get below error\r\n`[Error] \"Unable to register GraphType 'ConnectionType<AutoRegisteringObjectGraphType<ArticlePicture>>' with the name 'AutoRegisteringObjectConnection'. The name 'AutoRegisteringObjectConnection' is already registered to 'ConnectionType<AutoRegisteringObjectGraphType<News>>'`\r\n\r\n\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2022-12-26T05:26:05Z",
        "body": "Hmm... you're right\r\n\r\nWell, unfortunately i'd probably just create the edge type and connection type and name each of the types.  Perhaps in the next version of GraphQL.NET we can change the automatic naming algorithm for connection types.\r\n\r\n```cs\r\npublic class NewsConnectionType : ConnectionType<AutoRegisteringObjectGraphType<News>, NewsEdgeType>\r\n{\r\n    public NewsConnectionType()\r\n    {\r\n        Name = \"NewsConnection\";\r\n    }\r\n}\r\n\r\npublic class NewsEdgeType : EdgeType<AutoRegisteringObjectGraphType<News>>\r\n{\r\n    public NewsEdgeType()\r\n    {\r\n        Name = \"NewsEdge\";\r\n    }\r\n}\r\n\r\n// [OutputType(typeof(NewsConnectionType))]\r\n// or\r\n// [OutputType(typeof(NonNullGraphType<NewsConnectionType>))]\r\n```\r\n\r\nAn alternate method is to create a concrete type for `News`:\r\n\r\n```cs\r\n// note: be sure to end this name in \"GraphType\"\r\npublic class NewsGraphType : AutoRegisteringObjectGraphType<News>\r\n{\r\n}\r\n\r\n// [OutputType(typeof(ConnectionType<NewsGraphType>))]\r\n// or\r\n// [OutputType(typeof(NonNullGraphType<ConnectionType<NewsGraphType>>))]\r\n\r\n// but will need to be sure the CLR type mapping is registered properly so other references to `News`\r\n// map to the same NewsGraphType\r\n// e.g. .AddClrTypeMappings() during DI configuration\r\n// or this.RegisterTypeMapping<News, NewsGraphType>() during schema configuration\r\n```\r\n\r\nYou can also register the type mapping for `Connection<News>` so you don't need to use `[OutputType]`\r\n\r\n```cs\r\n// in schema constructor, or within ConfigureSchema:\r\nschema.RegisterTypeMapping<Connection<News>, NewsConnectionType>();\r\n// or ConnectionType<News> depending on the solution picked above\r\n```\r\n\r\nIn this way nullability is automatically determined.\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2022-12-26T05:26:18Z",
        "body": "There's just so many different ways to perform the same task...."
      },
      {
        "user": "need",
        "created_at": "2022-12-26T06:01:58Z",
        "body": "OK, I'd got it.\r\n\r\nThank you very much."
      }
    ]
  },
  {
    "number": 3449,
    "title": "Exception when I iterate through the types of a schema before defining any resolvers etc",
    "created_at": "2022-12-09T20:22:42Z",
    "closed_at": "2022-12-09T21:17:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3449",
    "body": "I am trying to read a string as a `Schema` and then print out all of the type names in that schema. \r\n\r\nHere is my script:\r\n\r\n```fsharp\r\n#r \"nuget: GraphQL, 7.2.1\"\r\n#r \"nuget: GraphQL.SystemTextJson\"\r\n\r\nopen GraphQL\r\nopen GraphQL.Types\r\nopen GraphQL.SystemTextJson\r\n\r\nlet definition =\r\n  \"\"\"type User {\r\n  id : ID!\r\n  handle : String!\r\n  bio : String\r\n  karma : Int!\r\n}\r\n\r\nunion CommentParent = Post | Comment\r\n\r\ntype Post {\r\n  id : ID!\r\n  created : String!\r\n  title : String!\r\n  url : String!\r\n  posterId : ID!\r\n  poster : User\r\n  karma : Int!\r\n}\r\n\r\ntype Comment {\r\n  id : ID!\r\n  created : String!\r\n  commenterId : ID!\r\n  commenter : User\r\n  parent : CommentParent\r\n  content : String!\r\n  karma : Int!\r\n}\r\n\r\ntype Query {\r\n  posts(page : Int! = 0) : [Post!]!\r\n  profile(id : ID!) : User\r\n}\r\n\"\"\"\r\n\r\nlet schema = Schema.For(definition)\r\n\r\nprintfn \"Found these GraphQL types: \"\r\n\r\nfor graphQLType in schema.AllTypes do\r\n  match graphQLType with\r\n  | :? GraphQL.Types.INamedType as namedType ->\r\n    printfn $\" - {namedType.Name}\"\r\n  | _ -> ()\r\n\r\nprintfn \"Done. \"\r\n```\r\n\r\nIt throws an error:\r\n\r\n```\r\nSystem.InvalidOperationException: Union type 'CommentParent' does not provide a 'resolveType' function and possible Type 'CommentParent' does not provide a 'isTypeOf' function. There is no way to resolve this possible type during execution.\r\n   at GraphQL.Types.SchemaTypes.ApplyTypeReference(IGraphType type) in /_/src/GraphQL/Types/Collections/SchemaTypes.cs:line 842\r\n   at GraphQL.Types.SchemaTypes.ApplyTypeReferences() in /_/src/GraphQL/Types/Collections/SchemaTypes.cs:line 790\r\n   at GraphQL.Types.SchemaTypes.Initialize(ISchema schema, IServiceProvider serviceProvider, IEnumerable`1 graphTypeMappings) in /_/src/GraphQL/Types/Collections/SchemaTypes.cs:line 225\r\n   at GraphQL.Types.SchemaTypes..ctor(ISchema schema, IServiceProvider serviceProvider, IEnumerable`1 graphTypeMappings) in /_/src/GraphQL/Types/Collections/SchemaTypes.cs:line 133\r\n   at GraphQL.Types.SchemaTypes..ctor(ISchema schema, IServiceProvider serviceProvider) in /_/src/GraphQL/Types/Collections/SchemaTypes.cs:line 118\r\n   at GraphQL.Types.Schema.CreateSchemaTypes() in /_/src/GraphQL/Types/Schema.cs:line 471\r\n   at GraphQL.Types.Schema.CreateAndInitializeSchemaTypes() in /_/src/GraphQL/Types/Schema.cs:line 442\r\n   at GraphQL.Types.Schema.Initialize() in /_/src/GraphQL/Types/Schema.cs:line 210\r\n   at <StartupCode$FSI_0002>.$FSI_0002.main@() in /home/njlr/Repro.fsx:line 8\r\nStopped due to error\r\n```\r\n\r\nIs there a way to examine the types of a schema parsed from a string?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3449/comments",
    "author": "njlr",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-12-09T20:39:29Z",
        "body": "You can parse the SDL using the GraphQLParser project and iterate through the type definitions there.  Call `GraphQLParser.Parser.Parse(definitions)`\r\n"
      },
      {
        "user": "njlr",
        "created_at": "2022-12-09T21:17:19Z",
        "body": "> You can parse the SDL using the GraphQLParser project and iterate through the type definitions there. Call `GraphQLParser.Parser.Parse(definitions)`\r\n\r\nWorks a treat!\r\n\r\n```fsharp\r\n#r \"nuget: GraphQL, 7.2.1\"\r\n#r \"nuget: GraphQL.SystemTextJson\"\r\n\r\nopen GraphQLParser\r\nopen GraphQLParser.AST\r\n\r\nlet definition =\r\n  \"\"\"type User {\r\n  id : ID!\r\n  handle : String!\r\n  bio : String\r\n  karma : Int!\r\n}\r\n\r\nunion CommentParent = Post | Comment\r\n\r\ntype Post {\r\n  id : ID!\r\n  created : String!\r\n  title : String!\r\n  url : String!\r\n  posterId : ID!\r\n  poster : User\r\n  karma : Int!\r\n}\r\n\r\ntype Comment {\r\n  id : ID!\r\n  created : String!\r\n  commenterId : ID!\r\n  commenter : User\r\n  parent : CommentParent\r\n  content : String!\r\n  karma : Int!\r\n}\r\n\r\ntype Query {\r\n  posts(page : Int! = 0) : [Post!]!\r\n  profile(id : ID!) : User\r\n}\r\n\"\"\"\r\n\r\nlet doc = Parser.Parse(definition)\r\n\r\nprintfn \"Found these GraphQL types: \"\r\n\r\nfor node in doc.Definitions do\r\n  match node with\r\n  | :? GraphQLTypeDefinition as typeDefinition ->\r\n    printfn $\" - {typeDefinition.Name}\"\r\n  | _ -> ()\r\n\r\n```\r\n\r\n```\r\nFound these GraphQL types: \r\n - User\r\n - CommentParent\r\n - Post\r\n - Comment\r\n - Query\r\n\r\n```"
      }
    ]
  },
  {
    "number": 3435,
    "title": "Can DataLoader discover what fields are required to be loaded?",
    "created_at": "2022-12-04T21:32:02Z",
    "closed_at": "2023-04-24T07:04:08Z",
    "labels": [
      "question",
      "data loader"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3435",
    "body": "My DataLoader calls an existing API that was not designed with GraphQL in mind. The API loads objects, and optionally loads various fields associated with those objects. Loading the additional fields is optional because they can be expensive in terms of execution time.\r\n\r\nI would like my DataLoader to be able to only request fields from the underlying API that are actually required to service the GraphQL request. Is it possible for DataLoader to find out the union of all the fields that the resolver needs? I understand that different parts of the GraphQL query may request different fields, so I'm only looking to exclude fields that are not required by any nodes in the query.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3435/comments",
    "author": "bartecargo",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-12-04T21:56:00Z",
        "body": "Yes....more or less.  I do this in one of my projects, and I do it as follows:\r\n\r\n- create a data loader where the key is a valuetuple of (1) the `IResolveFieldContext`, and (2) the id to be loaded\r\n- within the fetch delegate of the data loader, group by `context.GraphQLField`; loop over each group and independently retrieve results\r\n- within each group, take the first context, and pull the SubFields property (note: any of the contexts in this group will return the same set of subfields)\r\n- match the subfields to the data fields to be retrieved from the data source\r\n- retrieve the data and supply the values to the data loader nodes\r\n- go to the next group and repeat\r\n\r\nThe grouping is grouping by node in the query, because they will always have exactly the same fields.  This means that it may cause this effect for a GraphQL query:\r\n\r\n```gql\r\n{\r\n  hotProducts {   # list of hot products which are data loaded together\r\n    id\r\n    name\r\n    popularity\r\n  }\r\n  recentProducts {   # list of recent products which are data loaded together\r\n    id\r\n    name\r\n    lastPurchaseDate\r\n  }\r\n  # note that the two above groups normally would data load\r\n  # together, but now with grouping are not (on purpose)\r\n}\r\n```\r\n\r\nNote that GraphQL fields may be aliased in the query, and even be requested twice.  It may also use fragments...  so you should test that queries like this still performs correctly:\r\n\r\n```gql\r\n{\r\n  products {\r\n    id\r\n    currentPrice: price\r\n    lastPrice: price\r\n    ...example\r\n  }\r\n}\r\n\r\nfragment example on Product {\r\n  name\r\n  description\r\n}\r\n```\r\n\r\nWith a few tweaks to the design above, you can likely make it so that it takes the union of all the subfields across all contexts.  Pulling the SubFields property for each context isn't ideal for performance reasons, but something like this could probably work:  (untested; just a concept)\r\n\r\n```cs\r\nvar subFields = keys.GroupBy(x => x.Context).Select(x => x.First().Context.SubFields).SelectMany(x => x);\r\n```\r\n\r\nThen you need to do something like `Distinct()`, but I'm guessing `Distinct()` wouldn't exactly work.  You get the picture..."
      }
    ]
  },
  {
    "number": 3365,
    "title": "Intercepting Resolver in a FieldBuilder extension",
    "created_at": "2022-10-19T19:49:15Z",
    "closed_at": "2022-10-19T22:48:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3365",
    "body": "Hi, \r\nI want to create a FieldBuilder extension that will be applied after Resolve and conditionally can override Resolve behavior. \r\nIn the example below, the extension is called WithComment. \r\nit:\r\n- Adds an argument called comment if not already provided.\r\n- In the resolver, it checks if comment is needed (here the logic is only for demo)\r\n- If comment is needed and not provided, it returns response with error.\r\n- if comment is need and also provided, it should fall back to the original resolver execution.\r\n\r\nI came up with the following approach and wondering if you can advise if it is correct ot there is any better way.\r\n(Only look at the implementation of WithComment extension)\r\n\r\n```csharp\r\nasync Task Main()\r\n{\r\n\tvar schema = new Schema { Query = new TestQuery() };\r\n\tvar result1 = await schema.ExecuteAsync(_ =>\r\n\t\t\t{\r\n\t\t\t\t_.Query = \"{ test1 { status, id, errorMessage } }\";\r\n\t\t\t}\r\n\t);\r\n\r\n\tvar result2 = await schema.ExecuteAsync(_ =>\r\n\t\t\t{\r\n\t\t\t\t_.Query = \"{ test2 { status, id, errorMessage } }\";\r\n\t\t\t}\r\n\t);\r\n\r\n\r\n\tresult1.Dump();\r\n\tresult2.Dump();\r\n}\r\n\r\npublic class TestQuery : ObjectGraphType\r\n{\r\n\tpublic TestQuery()\r\n\t{\r\n\t\tField<TestResponseType, TestResponse>(\"test1\")\r\n\t\t\t.Resolve(context =>\r\n\t\t\t{\r\n\t\t\t\treturn new TestResponse();\r\n\t\t\t})\r\n\t\t\t.WithComment(1);\r\n\r\n\t\tField<TestResponseType, TestResponse>(\"test2\")\r\n\t\t\t.Resolve(context =>\r\n\t\t\t{\r\n\t\t\t\treturn new TestResponse();\r\n\t\t\t})\r\n\t\t\t.WithComment(2);\r\n\r\n\t}\r\n}\r\n\r\npublic static class FieldBuilderExtensions\r\n{\r\n\tpublic static readonly string COMMENT_ARGUMENT = \"comment\";\r\n\r\n\tpublic static FieldBuilder<TSourceType, TReturnType> WithComment<TSourceType, TReturnType>(\r\n\t\t\tthis FieldBuilder<TSourceType, TReturnType> builder, int value) where TReturnType : BaseResponse, new()\r\n\t{\r\n\t\tif (builder.FieldType.Resolver == null) {\r\n\t\t\tthrow new Exception(\"Resolve must be used before WithComment\");\r\n\t\t}\r\n\t\t\r\n\t\tif (builder.FieldType.Arguments == null)\r\n\t\t{\r\n\t\t\tbuilder.FieldType.Arguments = new QueryArguments();\r\n\t\t}\r\n\r\n\t\tif (!builder.FieldType.Arguments.Any(f => f.Name == COMMENT_ARGUMENT))\r\n\t\t{\r\n\t\t\tbuilder.FieldType.Arguments.Add(new QueryArgument<StringGraphType>\r\n\t\t\t{\r\n\t\t\t\tName = COMMENT_ARGUMENT\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tvar currentResolver = builder.FieldType.Resolver;\r\n\r\n\t\tbuilder.FieldType.Resolver = new FuncFieldResolver<TSourceType, TReturnType>((IResolveFieldContext<TSourceType> context) =>\r\n\t\t{\r\n\t\t\tvar needsComment = value % 2 == 0;\t//Dummy logic here for demo\r\n\t\t\tvar comment = context.GetArgument<string>(COMMENT_ARGUMENT);\r\n\r\n\t\t\tif (needsComment && comment == null)\r\n\t\t\t{\r\n\t\t\t\treturn new TReturnType() {\r\n\t\t\t\t\tStatus = \"Fail\",\r\n\t\t\t\t\tErrorMessage = \"Comment must be provided\"\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn (TReturnType)currentResolver.ResolveAsync(context).Result;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn builder;\r\n\t}\r\n}\r\n\r\npublic class TestResponseType : BaseResponseType<TestResponse>\r\n{\r\n\tpublic TestResponseType()\r\n\t{\r\n\t\tField<StringGraphType>(\"Id\");\r\n\t}\r\n}\r\n\r\npublic class BaseResponseType<T> : ObjectGraphType<T>\r\n{\r\n\tpublic BaseResponseType()\r\n\t{\r\n\t\tField<StringGraphType>(\"status\");\r\n\t\tField<StringGraphType>(\"errorMessage\");\r\n\t}\r\n}\r\n\r\npublic class TestResponse : BaseResponse\r\n{\r\n\tpublic string Id { get; set; }\r\n\tpublic TestResponse()\r\n\t{\r\n\t\tId = \"0\";\r\n\t}\r\n}\r\n\r\npublic class BaseResponse\r\n{\r\n\tpublic string Status { get; set; } = \"success\";\r\n\tpublic string ErrorMessage { get; set; } = \"\";\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3365/comments",
    "author": "rmeshksar",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-10-19T22:35:22Z",
        "body": "I think it looks good.  Here's a couple other ideas also, just FYI:\r\n\r\n1. If the comment argument was a non-null argument, validation would fail if the comment was not provided, so you might not need to overwrite the field resolver.  Validation has a benefit that the query does not execute if validation fails.  In your example above, you indicated that the comment was only conditionally required based on runtime logic, so this might not work for you.\r\n\r\nAlso, it seems that you are returning error messages within the GraphQL response.  I would personally recommend using GraphQL errors instead, and unify error responses with validation errors.\r\n\r\n2. If the comment is not used in the resolver but is simply there for logging, you could likely provide it \"out of bounds\" as a directive or comment, and write a validation rule that ensures that the directive or comment exists.  So for example it is possible to validate this within a validation rule:\r\n\r\n```gql\r\n{\r\n  something {\r\n    # a comment here <-- validation code ensures there is a comment here prior to execution of 'child' below\r\n    child { id }\r\n  }\r\n}\r\n```\r\n\r\nHowever, the example above probably violates spec as comments should be treated as whitespace during execution."
      },
      {
        "user": "rmeshksar",
        "created_at": "2022-10-19T22:48:45Z",
        "body": "Thanks for the fast reply as usual."
      },
      {
        "user": "sungam3r",
        "created_at": "2022-11-12T20:03:13Z",
        "body": "> you could likely provide it \"out of bounds\" as a directive or comment\r\n\r\nOf course directive  can help here\r\n\r\n```graphql\r\n{\r\n  something {\r\n    child @comment(\"Hello world!\") { id }\r\n  }\r\n}\r\n```\r\nDirective looks more promising, structured (unlike comments). You **may** go this way but prepare to fight with some difficulties - exposing directives via introspection, using GraphQL clients that aware of directives, write validation rule checking directive. The official specification has not yet been able to fully reveal all the possibilities of directives."
      }
    ]
  },
  {
    "number": 3355,
    "title": "Inject a query if a directive is present.",
    "created_at": "2022-10-11T13:17:41Z",
    "closed_at": "2022-10-12T14:04:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3355",
    "body": "I have created a custom directive, placed on a mutation field that would instruct the mutation as follows:\r\n\r\nThe mutation's resolver is capable of forming, based on the mutation, a \"smart query\" that would retrieve the items affected by the mutation.  The directive would tell the mutation to \"append/inject\" this smart query into the mutation's response as if the client had been knowledgeable enough to send the query in the first place.  The client would specify, using the custom field directive, that it would like the server to execute in this manner.\r\n\r\nI have injected into the DI system an object where this \"smart query\" could be get/set.\r\n\r\nI have a few questions:\r\n1. If this behavior occurs only when the directive is present, does this violate the GraphQL protocol?\r\n2. Is using FieldMiddleware the best way to do this...I could not get a DirectiveVisitor to work?\r\n3. I saw in issue #2649 how to create the \"smart query\" document, but I don't know how to modify the executing document to add the smart query AST elements.  Would you offer any suggestions?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3355/comments",
    "author": "keithcarter5",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-10-11T20:59:37Z",
        "body": "Can you provide a sample GraphQL request and response that you are attempting to implement?"
      },
      {
        "user": "keithcarter5",
        "created_at": "2022-10-11T21:23:33Z",
        "body": "Mutation:\r\n```graphql\r\nmutation {\r\n  module {\r\n    setUserName(name: \"KeithsModule\") @performQuery {\r\n      result {\r\n        code\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\nImagining this mutation affected \"userName\", \"userDescription\", and \"catalogNumber\", the mutation would (using a DI suggestQuery service) specify \"{ module { userName userDescription } module { catalogNumber } }\" as the \"suggestedQuery\". \r\n The @performQuery directive would signal the server to retrieve the suggestedQuery (via the serviceProvider) insert the query into the executing document.\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-11T21:38:16Z",
        "body": "Ok so just for clarification can you post the combined query that you’d like it to execute?\r\n\r\nnote that you can have GitHub format the code by typing something like this:\r\n\r\n````\r\n```gql\r\nquery {\r\n  sample\r\n}\r\n```\r\n````\r\n\r\nwhich will look like this:\r\n\r\n```gql\r\nquery {\r\n  sample\r\n}\r\n```"
      },
      {
        "user": "keithcarter5",
        "created_at": "2022-10-11T23:33:58Z",
        "body": "the client enters the following mutation:\r\n```gql\r\nmutation {\r\n    module {\r\n        setUserName(name: \"KeithsModule\") @performSuggestedQuery {\r\n            result {\r\n                code\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nin addition to resolving the mutation and returning the mutation's response result code, the resolver inserts into the mutation's response the suggested query:\r\n```gql\r\n{\r\n    module {\r\n        userName userDescription\r\n    }\r\n    module {\r\n        catalogNumber\r\n    }\r\n}\r\n```\r\nthe graphql response to the mutation would be:\r\n```json\r\n{\r\n  \"data\": {\r\n    \"module\": {\r\n      \"setUserName\": {\r\n        \"result\": {\r\n          \"code\": 0\r\n        },\r\n        \"suggestedQuery\": {\r\n          \"module\": {\r\n            \"userName\": \"KeithsModule\",\r\n            \"userDescription\": \"Keiths Module Description\",\r\n            \"catalogNumber\": \"2198-EW\"\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-12T00:48:45Z",
        "body": "Rather than a directive, have you considered this instead:\r\n\r\n```gql\r\nmutation {\r\n    module {\r\n        setUserName(name: \"KeithsModule\") {\r\n            result {\r\n                code\r\n            }\r\n            suggestedQuery\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThen `suggestedQuery` is a `JsonScalarType` or similar (a custom scalar graph type), which is a legal GraphQL scalar which returns structured data in the format you described:\r\n\r\n```json\r\n{\r\n  \"data\": {\r\n    \"module\": {\r\n      \"setUserName\": {\r\n        \"result\": {\r\n          \"code\": 0\r\n        },\r\n        \"suggestedQuery\": {\r\n          \"module\": {\r\n            \"userName\": \"KeithsModule\",\r\n            \"userDescription\": \"Keiths Module Description\",\r\n            \"catalogNumber\": \"2198-EW\"\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThe above could be implemented by having the `suggestedQuery` field call another GraphQL call internally to execute whatever suggested query was dictated by your DI-injected service.  You can use `.ToValue()` or similar to convert the internal GraphQL response back into a dictionary to return from the `suggestedQuery` resolver.  You will need to consider what happens if the internal execution returns an error, of course -- perhaps just returning null is sufficient.\r\n\r\nNow, all of this assumes that the caller will know what the format of the suggested query would be.  Which begs the question: if the caller knows what the suggested query is, why doesn't the schema know what it is and assign the correct GraphQL type to the field?  I'll assume you have a good answer for this question, and offer a suggestion as a solution: include the suggested query text in the response, as shown below:\r\n\r\n```gql\r\nmutation {\r\n    module {\r\n        setUserName(name: \"KeithsModule\") {\r\n            result {\r\n                code\r\n            }\r\n            suggestedQuery\r\n            suggestedQueryResponse\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nwhich returns:\r\n\r\n```json\r\n{\r\n  \"data\": {\r\n    \"module\": {\r\n      \"setUserName\": {\r\n        \"result\": {\r\n          \"code\": 0\r\n        },\r\n        \"suggestedQuery\": \"{ module { userName userDescription } module { catalogNumber } }\",\r\n        \"suggestedQueryResponse\": {\r\n          \"module\": {\r\n            \"userName\": \"KeithsModule\",\r\n            \"userDescription\": \"Keiths Module Description\",\r\n            \"catalogNumber\": \"2198-EW\"\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nNow I wouldn't want callers to have to parse the `suggestedQuery` field to decipher the `suggestedQueryResponse` field, but I guess it is possible to do so."
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-12T00:59:04Z",
        "body": "Here are some other things I've done in the past which you may be able to pull ideas from:\r\n\r\n1. The GraphQL type of the `setUserName` mutation is the `ModuleType` so that any property from the updated module can be returned\r\n\r\n```gql\r\nmutation {\r\n    module {\r\n        setUserName(name: \"KeithsModule\") {\r\n            userName\r\n            userDescription\r\n            catalogNumber\r\n            # any other fields of the updated module can be selected here\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n2. Add a `query` field to the root of the `MutationType` which points to `QueryType` so that any query can be run in conjunction with the mutation.  These queries could execute within the same SQL transaction as the mutation, for example.  And since according to GraphQL spec, mutations execute serially, the caller can define if the query can run before or after the mutation:\r\n\r\n```gql\r\nmutation {\r\n    module {\r\n        setUserName(name: \"KeithsModule\") {\r\n            result { code }\r\n        }\r\n    }\r\n    query {\r\n        module(name: \"KeithsModule\") {\r\n            userName\r\n            userDescription\r\n            catalogNumber\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nSince GraphQL spec allows querying the same field multiple times via aliases, it is even possible to return any arbitrary data from both before and after the mutation, like this:\r\n\r\n```gql\r\nmutation {\r\n    queryBefore: query {\r\n        module(name: \"KeithsModule\") {\r\n            userName\r\n            userDescription\r\n            catalogNumber\r\n        }\r\n    }\r\n    module {\r\n        setUserName(name: \"KeithsModule\") {\r\n            result { code }\r\n        }\r\n    }\r\n    queryAfter: query {\r\n        module(name: \"KeithsModule\") {\r\n            userName\r\n            userDescription\r\n            catalogNumber\r\n        }\r\n    }\r\n}\r\n```\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-12T01:04:45Z",
        "body": "Back to your original question regarding using a directive to inject query results into the mutation results, within GraphQL.NET this would be difficult to implement in the exact manner you described.  Basically, I'm not sure how or if you could inject into the results.  Best bet would be to injecting a field into the request (i.e. the `suggestedQuery` field that I first suggested above), and letting it process exactly as if the `suggestedQuery` field was requested directly from the caller.  At that point it seems a little pointless to use a directive at all.  However, if it was a requirement, you could implement a schema filter to hide `suggestedQuery` from introspection queries and simply inject the hidden field when the directive was used.  I don't really have a better answer there."
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-12T01:33:42Z",
        "body": "Oh, as to your other questions:\r\n\r\n> If this behavior only occurs when the directive is present, does this violate the GraphQL protocol?\r\n\r\nWell, maybe, but I don't know that it matters.  Directives are meant to alter server behavior.  You can think of this directive as enabling an experimental feature, for example.  Not really a big deal, even if technically it does not meet spec.  It just means you may not be able to use typical clients with this directive as they may ignore the extra data.\r\n\r\n> Is using FieldMiddleware the best way to do this...I could not get a DirectiveVisitor to work? \r\n\r\nNot sure exactly; I do not use directives.  @sungam3r would be the one to ask for questions on directives."
      },
      {
        "user": "keithcarter5",
        "created_at": "2022-10-12T13:34:07Z",
        "body": "I think your idea about the form of the mutation is better than the directive idea I had...certainly more straightforward.  As in:\r\n```gql\r\nmutation {\r\n    module {\r\n        setUserName(name: \"KeithsModule\") {\r\n            result {\r\n                code\r\n            }\r\n            suggestedQuery\r\n            suggestedQueryResponse\r\n        }\r\n    }\r\n}\r\n```\r\nIn one of your responses, you stated \r\n>The above could be implemented by having the suggestedQuery field call another GraphQL call internally to execute whatever suggested query was dictated...\r\n\r\nWould you mind providing an example on how to do that?\r\n\r\nAlso, you mentioned that in this case, the `suggestedQueryResponse` could be a `JsonScalarType` which allows structured json like that returned by the server.  I looked up #474 and saw references to a `AnyScalarGraphType`, but I could not find anything in the repo on `JsonScalarType`.  Would you elaborate a little more on this?\r\n\r\nOne other thing, you asked if the caller would understand the format of the `suggestedQueryResponse` json.  I'm thinking that since this field contains a response to a valid GraphQL query, which conforms to an existing schema, then the caller would be able to process that field with the same code with which it would process the actual query response (had the caller actually sent the query).\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-12T13:55:06Z",
        "body": "> JsonScalarType\r\n\r\n#474 relates to what I was talking about.  I wrote `ComplexScalarGraphType` in #3257 to serve that purpose, but honestly `AnyGraphType` is all you need here.  Although designed for GraphQL federation, it will serve your purpose nicely.  `ComplexScalarGraphType` has `ToAST` implemented where `AnyGraphType` does not, but this does not matter for your needs.\r\n\r\nIf you look through the open PRs you will also see #3246 -- this represents stringified JSON and is not what I was talking about."
      },
      {
        "user": "keithcarter5",
        "created_at": "2022-10-12T14:04:52Z",
        "body": "I just realized the sillyness of my question on how to internally execute my own graphql query...thanks for ignoring that.  I think I have everything I needed to move forward.  Thanks very much for your help!"
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-12T14:06:12Z",
        "body": "Well since I already am half done answering it...something like this:\r\n\r\n```cs\r\npublic async Task<object?> ExecuteSubquery(IResolveFieldContext context, string suggestedQuery)\r\n{\r\n    try {\r\n        var executer = context.RequestServices.GetRequiredService<IDocumentExecuter<ISchema>>();\r\n        var result = await executer.ExecuteAsync(new ExecutionOptions {\r\n            Query = suggestedQuery,\r\n            RequestedServices = context.RequestServices,\r\n            User = context.User,\r\n            CancellationToken = context.CancellationToken,\r\n            //Root = root,\r\n        });\r\n        if (!result.Executed || result.Data == null || result.Errors != null)\r\n            return null;\r\n        return ((ExecutionNode)result.Data).ToValue();\r\n    } catch {\r\n        return null;\r\n    }\r\n}\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-12T14:06:43Z",
        "body": "Feel free to ask if there's anything else."
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-12T14:07:34Z",
        "body": "You might or might not want to create a service scope for the subquery execution.  Probably not I'm guessing."
      },
      {
        "user": "keithcarter5",
        "created_at": "2022-10-12T14:56:18Z",
        "body": "Now I feel like I had a good question after all, since your above example hits some items I would have missed.  Thanks again."
      }
    ]
  },
  {
    "number": 3333,
    "title": "Arguments cannot be retrieved with registration case",
    "created_at": "2022-09-17T21:34:57Z",
    "closed_at": "2022-09-17T21:42:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3333",
    "body": "## Description\r\n\r\nWhen an argument is registered with \"PascalCase\", the (default) naming converter changes it to \"camelCase\". However, when retrieving the argument with this code, it will not return anything.\r\n\r\n```\r\nif (context.Arguments.TryGetValue(\"Take\", out var take) &&\r\n    take.Value is int intCount &&\r\n    intCount > 0)\r\n{\r\n    pageableQuery.Take = intCount;\r\n}\r\n``` \r\n\r\n### Steps to reproduce\r\n\r\nRegister argument:\r\n\r\n``` \r\n// Take\r\ngraphType.AddField(new FieldType\r\n{\r\n    Name = \"Take\",\r\n    ResolvedType = new IntGraphType(),\r\n});\r\n```\r\n\r\nTry retrieving the argument value:\r\n\r\n``` \r\nif (context.Arguments.TryGetValue(\"Take\", out var take) &&\r\n    take.Value is int intCount &&\r\n    intCount > 0)\r\n{\r\n    pageableQuery.Take = intCount;\r\n}\r\n```\r\n\r\nWill not work. The dictionary has \"take\", not \"Take\".\r\n\r\n### Expected result\r\n\r\nI would expect to be able to retrieve the argument via the name I registered it with (e.g. if we change naming convention, we have to manually go through all the argument retrieval functions).\r\n\r\n### Actual result\r\n\r\nDictionary keys use the post-naming-convention style.\r\n\r\n### Environment\r\n\r\nGraphQL 7.0.2\r\n\r\n### Possible solutions\r\n\r\n**Simple**\r\n\r\nMake the dictionary holding the arguments case insensitive.\r\n\r\n**Complex but more reliable**\r\n\r\nKeep an internal dictionary of mappings (e.g. registration name and naming convention name). As long as there are no duplicates (this could easily be checked), the actual \"camelCase\" argument could be resolved via the \"PascalCase\" registration name.\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3333/comments",
    "author": "GeertvanHorrik",
    "comments": [
      {
        "user": "GeertvanHorrik",
        "created_at": "2022-09-17T21:42:05Z",
        "body": "I did some extra research and noticed that one can use the GetArgument extension method:\r\n\r\n```\r\nvar take = context.GetArgument<int>(\"Take\");\r\nif (take > 0)\r\n{\r\n    pageableQuery.Take = take;\r\n}\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2022-09-17T23:16:22Z",
        "body": "Correct; this is as designed — the dictionary contains the exact names within the request while GetArgument runs the supplied name through the name converter. "
      }
    ]
  },
  {
    "number": 3266,
    "title": "Unable to debug my controller code",
    "created_at": "2022-08-04T03:27:16Z",
    "closed_at": "2022-11-10T16:09:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3266",
    "body": "Hello ,\r\n\r\nI have created a graphql api sometime back using the ASP .NET MVC Web Api (.net core 3.1 )  . The code always worked really well . Now after a long time I plan to update it with some new code for which I started testing it again .\r\n\r\nTo my surprise I am unable to debug the code . The break point in the controller does not get hit at all.  I remember the Post method working and then moving to the Query class . Looks like the code in the controller is not even getting executed.\r\n\r\nStartup.cs\r\nConfigure Services Method\r\n```\r\n            //names changed\r\n\t      services.AddSingleton<ISchema, Schema1>();\r\n\t       services.AddSingleton<Query>();\r\n               services.AddSingleton<Type1>();\r\n               services.AddSingleton<Type2>();\r\n\r\n \r\n\r\n                    services.AddGraphQL(options => { options.EnableMetrics = false; })\r\n                    .AddSystemTextJson()\r\n                    .AddErrorInfoProvider(opt => opt.ExposeExceptionStackTrace = true)\r\n                    .AddDataLoader();           \r\n\r\n\r\n            services.AddMvc(options => options.EnableEndpointRouting = false);\r\n\r\n```\r\n\r\n\r\nController\r\n ```\r\npublic async Task<IActionResult> Post([FromBody] GraphQLQuery query)\r\n        {\r\n            \r\n            Inputs inputs = query.Variables;\r\n\r\n            var result = await new DocumentExecuter().ExecuteAsync( _options=>\r\n            {\r\n                _options.Schema = schema; \r\n                _options.Query = query.Query;\r\n                _options.OperationName = query.OperationName;\r\n                _optionsInputs = inputs;\r\n                \r\n            });\r\n\r\n\r\n            if (result.Errors?.Count > 0)\r\n            {\r\n                return BadRequest(result.Errors);\r\n            }\r\n\r\n            \r\n            return Ok(result);\r\n```\r\n\r\nQuery Class Constructor\r\n\r\n```\r\n\t\r\n public Query()\r\n        {\r\n            Field<ListGraphType<Type1>>(\r\n            \"type1s\",\r\n             \r\n             resolve: context =>\r\n                                {\r\n\r\n                                     \r\n                                    using var serviceScope = context.RequestServices.CreateScope();\r\n                                    var provider = serviceScope.ServiceProvider;\r\n                                    var DbContext = provider.GetRequiredService<DbContext>();\r\n\r\n                                    var type1data = DbContext.....//db logic\r\n                                    return type1data;\r\n\r\n\r\n\r\n                                });\r\n\r\n\r\n        \r\n\r\n        }\r\n\r\n```\r\n\r\n\r\n\r\n        \r\n\r\nplease help.\r\n\r\nThanks\r\nKishore",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3266/comments",
    "author": "kikshore",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2022-08-04T04:28:19Z",
        "body": "> Looks like the code in the controller is not even getting executed.\r\n\r\nIf so most likely this is the problem before any code from this project. Turn on switch in your IDE to show all exceptions. Maybe this helps to understand what is going wrong."
      },
      {
        "user": "Shane32",
        "created_at": "2022-08-04T07:04:50Z",
        "body": "Typically I find this problem to be due to DI issues; very possibly the schema is throwing an exception while being initialized.\r\n\r\nOne thing I often try is to add something like this to the Startup.cs file:\r\n\r\n```cs\r\napp.ApplicationServices.GetRequiredService<ISchema>().Initialize();\r\n```\r\n\r\nIf there's an issue it will throw an exception on that line of code and the application will fail to start."
      },
      {
        "user": "kikshore",
        "created_at": "2022-08-04T23:22:00Z",
        "body": "Thank you for the quick response .But the query is returning the desired results . If there were an exception it shouldn't right !?\r\n\r\nAnd this may sound silly , but do we need a controller and a post method . I am able to run the code by excluding the controller itself from the project . "
      },
      {
        "user": "kikshore",
        "created_at": "2022-08-04T23:36:10Z",
        "body": "> Typically I find this problem to be due to DI issues; very possibly the schema is throwing an exception while being initialized.\r\n> \r\n> One thing I often try is to add something like this to the Startup.cs file:\r\n> \r\n> ```cs\r\n> app.ApplicationServices.GetRequiredService<ISchema>().Initialize();\r\n> ```\r\n> \r\n> If there's an issue it will throw an exception on that line of code and the application will fail to start.\r\n\r\nI added the line to the Configure Method in StartUp and it worked without any issues."
      },
      {
        "user": "Shane32",
        "created_at": "2022-08-05T03:13:50Z",
        "body": "I guess I don’t understand your issue if everything is working correctly …."
      },
      {
        "user": "kikshore",
        "created_at": "2022-08-05T03:28:27Z",
        "body": "Hi Shane ,\r\nThe issue is that if I put a breakpoint in my [POST] action method , it is never hit . Any changes I make to my controller , I am not able to debug.\r\n\r\nThanks."
      },
      {
        "user": "Shane32",
        "created_at": "2022-08-05T04:22:05Z",
        "body": "Do you have anything in your startup like app.UseGraphQL or MapGraphQL ?   (Besides AddGraphQL)"
      },
      {
        "user": "sungam3r",
        "created_at": "2022-08-09T10:31:10Z",
        "body": "The idea is that you configure GraphQL execution engine **twice** - within controller mentioned above and somehow else so control flow does not fall into your controller but in general everything just works."
      },
      {
        "user": "sungam3r",
        "created_at": "2022-11-10T16:09:53Z",
        "body": "Closed due to inactivity."
      }
    ]
  },
  {
    "number": 3251,
    "title": "Where has Subscriber gone when defining a Subscription?",
    "created_at": "2022-07-22T17:47:14Z",
    "closed_at": "2022-07-30T22:18:09Z",
    "labels": [
      "question",
      "documentation"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3251",
    "body": "The documentation for the upgrade from 4 to 5 says in section 34\r\n\r\n\"Please use FieldType instead. The Subscriber property has been moved to the FieldType class so no other changes should be required. The AsyncSubscriber property has been removed as described above.\"\r\n\r\nFieldType does not have a \"Subscriber\" property.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3251/comments",
    "author": "AndyEdmonds",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-07-22T18:24:48Z",
        "body": "It’s called StreamResolver now. We need to fix the migration document on that. "
      }
    ]
  },
  {
    "number": 3193,
    "title": "AutoSchema, is it possible to combine (merge) queries or mutations from several classes?",
    "created_at": "2022-06-23T04:36:20Z",
    "closed_at": "2022-06-23T23:27:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3193",
    "body": "Hello, \r\n\r\nI found that `AddAutoSchema` was very useful for the code-first approach, but I found it not so clean to make a class contains all of the queries (and also for mutations). When number of queries and mutations grows it's a little bit hard to manage the code. \r\n\r\nIs it possible to group them for something like this?\r\n\r\n```c#\r\npublic class UserQuery \r\n{\r\n    IList<User> Users(int limit, int offset) {}\r\n    IList<User> User(int id) {}\r\n}\r\n\r\npublic class UserMutation \r\n{\r\n    User CreateUser(User user) {}\r\n    User UpdateUser(int id, User user) {}\r\n    bool DeleteUser(int id) {}\r\n}\r\n\r\npublic class PostQuery \r\n{\r\n    IList<Post> Posts(int limit, int offset) {}\r\n    IList<Post> Post(int id) {}\r\n}\r\n\r\npublic class PostMutation \r\n{\r\n    Post CreatePost(Post post) {}\r\n    Post UpdatePost(int id, Post post) {}\r\n    bool DeletePost(int id) {}\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3193/comments",
    "author": "ktutnik",
    "comments": [
      {
        "user": "Revazashvili",
        "created_at": "2022-06-23T12:59:16Z",
        "body": "you can do something like that\r\n```c#\r\npublic interface IQuery{}\r\n\r\npublic class Query : ObjectGraphType<object>\r\n{\r\n    private static readonly Lazy<List<Type>> GraphTypes = new(() =>\r\n        Assembly.GetExecutingAssembly().GetTypes()\r\n            .Where(type => typeof(IQuery).IsAssignableFrom(type) && type.IsClass).OrderBy(type => type.Name)\r\n            .ToList());\r\n    public Query()\r\n    {\r\n        Name = nameof(Query);\r\n        foreach (var type in GraphTypes.Value)\r\n            Field(type, type.Name, resolve: context => new object());\r\n    }\r\n}\r\n\r\npublic class UserQuery : ObjectGraphType<User>,IQuery\r\n{\r\n    IList<User> Users(int limit, int offset) {}\r\n    IList<User> User(int id) {}\r\n}\r\n\r\npublic class PostQuery : ObjectGraphType<Post>,IQuery\r\n{\r\n    IList<Post> Posts(int limit, int offset) {}\r\n    IList<Post> Post(int id) {}\r\n}\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2022-06-23T13:17:38Z",
        "body": "If you're looking for a schema like this:\r\n\r\n```gql\r\ntype Query {\r\n  users: UserQuery!\r\n  posts: PostQuery!\r\n}\r\n\r\ntype Mutation {\r\n  users: UserMutation!\r\n  posts: PostMutation!\r\n}\r\n```\r\n\r\nYou can do this:\r\n\r\n```cs\r\npublic class Query\r\n{\r\n    public static UserQuery Users => new UserQuery();\r\n    public static PostQuery Posts => new PostQuery();\r\n}\r\n\r\npublic class Mutation\r\n{\r\n    public static UserMutation Users => new UserMutation();\r\n    public static PostMutation Posts => new PostMutation();\r\n}\r\n\r\n// .AddAutoSchema<Query>(o => o.WithMutation<Mutation>())\r\n```\r\n\r\nAlong with your other classes listed above, of course."
      },
      {
        "user": "Shane32",
        "created_at": "2022-06-23T13:36:15Z",
        "body": "If you want to merge different auto-generated classes together, for a schema like this:\r\n\r\n```gql\r\ntype Query {\r\n  user(id: Int!): [User!]!\r\n  users(limit: Int!, offset: Int!): [User!]!\r\n  post(id: Int!): [Post!]!\r\n  posts(limit: Int!, offset: Int!): [Post!]!\r\n}\r\n\r\n# and similar for mutation\r\n```\r\n\r\nThen I would do something similar to @Revazashvili 's sample, like this probably:\r\n\r\n```cs\r\npublic interface IQuery { }\r\n\r\n// use code-first to generate the query type\r\npublic class Query : ObjectGraphType\r\n{\r\n    public Query()\r\n    {\r\n        var types = Assembly.GetExecutingAssembly().GetTypes()\r\n            .Where(type => typeof(IQuery).IsAssignableFrom(type) && type.IsClass).OrderBy(type => type.Name)\r\n            .ToList();\r\n\r\n        // with the list of types that need to be combined,\r\n        foreach (var type in types)\r\n        {\r\n            // construct an \"auto-registering\" (aka type-first) graph type for each type\r\n            var constructedType = typeof(AutoRegisteringObjectGraphType<>).MakeGenericType(type);\r\n            var graphType = (IComplexGraphType)Activator.CreateInstance(constructedType);\r\n            // and add all the fields it generates into this graph type\r\n            foreach (var field in graphTypes.Fields)\r\n                AddField(field);\r\n        }\r\n    }\r\n}\r\n\r\npublic class UserQuery : IQuery\r\n{\r\n    IList<User> Users(int limit, int offset) {}\r\n    IList<User> User(int id) {}\r\n}\r\n\r\npublic class PostQuery : IQuery\r\n{\r\n    IList<Post> Posts(int limit, int offset) {}\r\n    IList<Post> Post(int id) {}\r\n}\r\n\r\n// and similar for mutation, using IMutation\r\n\r\n// use code-first to create the schema\r\npublic class MySchema : Schema\r\n{\r\n    public MySchema(IServiceProvider provider) : base(provider)\r\n    {\r\n        Query = new Query();\r\n        Mutation = new Mutation();\r\n    }\r\n}\r\n\r\n// .AddSchema<MySchema>()\r\n// .AddAutoClrMappings()\r\n```\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2022-06-23T13:45:49Z",
        "body": "You can also do without the `IQuery` and etc a bit more simply:\r\n\r\n```cs\r\npublic class Query : ObjectGraphType\r\n{\r\n    public Query()\r\n    {\r\n        AddFields<UserQuery>();\r\n        AddFields<PostQuery>();\r\n\r\n        void AddFields<T>()\r\n        {\r\n            var graphType = new AutoRegisteringObjectGraphType<T>();\r\n            foreach (var field in graphType.Fields)\r\n                AddField(field);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nI didn't test all this code, but I think it will work."
      },
      {
        "user": "Shane32",
        "created_at": "2022-06-23T13:55:12Z",
        "body": "And finally, the easiest answer is to just use partial classes:\r\n\r\n```cs\r\n// Query.Users.cs\r\npublic partial class Query\r\n{\r\n    IList<User> Users(int limit, int offset) {}\r\n    IList<User> User(int id) {}\r\n}\r\n\r\n// Query.Posts.cs\r\npublic partial class Query\r\n{\r\n    IList<Post> Posts(int limit, int offset) {}\r\n    IList<Post> Post(int id) {}\r\n}\r\n\r\n// .AddAutoSchema<Query>()\r\n```"
      },
      {
        "user": "Revazashvili",
        "created_at": "2022-06-23T14:39:41Z",
        "body": "if i'am not wrong, my example's sdl will be:\r\n```\r\nschema {\r\n  query: Query\r\n}\r\n\r\ntype Query {\r\n  UserQuery: UserQuery\r\n  PostQuery: PostQuery\r\n}\r\n\r\ntype UserQuery{\r\n  user(id: Int!): [User!]!\r\n  users(limit: Int!, offset: Int!): [User!]!\r\n}\r\n\r\n```\r\nand query will be like that \r\n```\r\nquery {\r\n  UserQuery{\r\n    user(id:1)\r\n  }\r\n}\r\n```"
      },
      {
        "user": "ktutnik",
        "created_at": "2022-06-23T23:27:45Z",
        "body": "Ah, I think I understand the idea.\r\nThank you guys for the variety of answers.\r\n"
      }
    ]
  },
  {
    "number": 3151,
    "title": "How to implement file upload graph?",
    "created_at": "2022-05-28T07:44:14Z",
    "closed_at": "2024-01-07T05:12:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3151",
    "body": "Hey guys.\r\nI've upgraded my GraphQl version to 5.2.0 and I want to know how I can receive a file from QueryArgument?\r\nI've searched a lot, but I haven't found any solution yet. Is there any idea?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3151/comments",
    "author": "PouryaMontakhab",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2022-05-28T08:36:14Z",
        "body": "File upload issues: #682, #419, #213."
      },
      {
        "user": "Shane32",
        "created_at": "2022-05-28T15:41:02Z",
        "body": "I’ve implemented file download in some of my schemas as base64 encoded strings. File upload could be done the same way. Another common download technique would be to return a url pointing to the file data. Similarly you could have the caller PUT the file to a temporary storage url and post the url as a string within a variable to the GraphQL endpoint. "
      }
    ]
  },
  {
    "number": 3111,
    "title": "Block schema introspection based on a HTTP request header",
    "created_at": "2022-04-29T12:43:14Z",
    "closed_at": "2022-05-06T14:07:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3111",
    "body": "## Summary\r\n\r\nBlock schema introspection based on a HTTP request header value without running the IFieldMiddleware for every single field.\r\n\r\n## Relevant information\r\n\r\nHello there! It's me again. I'd like to block schema introspection based on a HTTP request header value (we only want to allow introspection to IP's from certain IP ranges). At the moment we have built a middleware class which implements the `IFieldMiddleware` interface and which checks the header value for matching values. The 'problem' we have with this approach though is that it does the check for every single field in the request. We're worried that this might hurt the performance of our API and before deploying this I would like to check with you guys if there possibly is a better approach to implement logic like this?\r\n\r\n### Environment (if relevant)\r\n\r\nversion 4.8.0\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3111/comments",
    "author": "Heuts",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-04-29T18:16:00Z",
        "body": "call `app.UseWhen` probably like this:\r\n\r\n```cs\r\napp.UseWhen(context => ValidateIpAddress(context), app2 => {\r\n    app2.UseGraphQL(...);\r\n});\r\n\r\nbool ValidateIpAddress(HttpContext context)\r\n{\r\n    // examine ip and return true if allowed\r\n}\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2022-04-29T18:19:12Z",
        "body": "If you want it to ** only ** block introspection requests, and not all requests, then you have to leave it as a validation rule.  You can enhance performance by checking the IP address once during the validation rule setup, and then either returning null if allowed or a rule if not:\r\n\r\n```cs\r\n    public class IntrospectionValidationRule : IValidationRule\r\n    {\r\n        public ValueTask<INodeVisitor> ValidateAsync(ValidationContext context)\r\n        {\r\n            if (ValidateIpAddress(context))\r\n                return null; // no need for validation rule at all if it's a valid ip\r\n\r\n            // otherwise need a validation rule to ensure no introspection requests\r\n            return new ValueTask<INodeVisitor>(new MatchingNodeVisitor<GraphQLField>(\r\n                (field, context2) =>\r\n                {\r\n                    if (field.Name.Value == \"__schema\" || field.Name.Value == \"__type\")\r\n                        context2.ReportError(new ValidationError(\"Cannot request introspection query.\"))\r\n                }));\r\n        }\r\n    }\r\n```"
      },
      {
        "user": "Heuts",
        "created_at": "2022-05-02T07:53:07Z",
        "body": "Cool, thanks! I'll give this a try"
      },
      {
        "user": "Heuts",
        "created_at": "2022-05-03T14:36:20Z",
        "body": "Do you maybe have an example for GraphQL 4? I'm having a tough time finding one.\r\n\r\nAnd can I access the headers by using the `ValidationContext` object?"
      },
      {
        "user": "Shane32",
        "created_at": "2022-05-03T16:03:02Z",
        "body": "Inject IHttpContextAccessor via DI and use that to pull the http context and from that the headers (or client IP address). \r\n\r\nLook at the source code of the repo, and go to the tag (under branches) for a 4.x version. Then look under src GraphQL Validation Rules to see a whole bunch of validation rule examples for 4.x"
      },
      {
        "user": "Heuts",
        "created_at": "2022-05-06T14:07:54Z",
        "body": "It took some figuring out but I managed to make it work for our use-case. Once again thanks for your assistance 🚀 "
      }
    ]
  },
  {
    "number": 3109,
    "title": "Operation is not valid due to the current state of the object error",
    "created_at": "2022-04-28T23:31:21Z",
    "closed_at": "2023-04-03T19:55:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3109",
    "body": "Hello, yesterday I had a question related to variables and ended up making this change,\r\n\r\nI changed Variables to,\r\n```\r\npublic JsonElement Variables\r\n{\r\n    get; set;\r\n}\r\n```\r\nand changed,\r\n```\r\nopts.Variables = serializer.ReadNode<Inputs>(request?.Variables);\r\n```\r\n\r\nHowever, today just the build with this change seems to be giving me an \r\n`Operation is not valid due to the current state of the object error` in the GraphQLMiddleware. I was wondering if I've missed something else during the variable upgrade ? Thank you",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3109/comments",
    "author": "giy",
    "comments": [
      {
        "user": "giy",
        "created_at": "2022-04-28T23:46:39Z",
        "body": "So, I am going back to the other way,\r\n```\r\n[JsonConverter(typeof(ObjectDictionaryConverter))]\r\n        public Dictionary<string, object> Variables\r\n        {\r\n            get; set;\r\n```\r\n\r\nI tried replacing `ObjectDictionaryConverter` with \r\n```\r\n[JsonConverter(typeof(InputsJsonConverter))]\r\n        public Dictionary<string, object> Variables\r\n```\r\n\r\nBut that gives me an error too,\r\n```\r\n The converter specified on ...Api.Kestrel.GraphQLRequest.Variables' is not compatible with the type 'System.Collections.Generic.Dictionary`2[System.String,System.Object]'\r\n```\r\n\r\nWhat is the right way for me to replace `ObjectDictionaryConverter` ?"
      },
      {
        "user": "giy",
        "created_at": "2022-04-29T01:32:39Z",
        "body": "Added,\r\n```\r\nif (request?.Variables != null && request.Variables.ValueKind != JsonValueKind.Undefined)\r\n{\r\n    variables = serializer.ReadNode<Inputs>(request.Variables);\r\n}\r\n``` but just want to make sure this looks right for all cases"
      },
      {
        "user": "Shane32",
        "created_at": "2022-04-29T02:02:10Z",
        "body": "```cs\r\n[JsonConverter(typeof(InputsJsonConverter))]\r\npublic Inputs Variables { get; set; }\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2022-04-29T02:02:47Z",
        "body": "Then `opts.Variables = request.Variables;`"
      },
      {
        "user": "giy",
        "created_at": "2022-04-29T03:16:15Z",
        "body": "Oh, I see.. thank you!! "
      }
    ]
  },
  {
    "number": 3050,
    "title": "Handling exceptions of child field resolvers in parent resolver",
    "created_at": "2022-03-31T16:43:16Z",
    "closed_at": "2022-03-31T19:15:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3050",
    "body": "Hi,\r\nIn the following code the query returns a complex object of Person. \r\nPerson has list of addresses and addresses field has its own resolver.\r\nI want to handle any exceptions that happen while resolving addresses, in the hi level person resolver.\r\n\r\nIs that possible?\r\n\r\n```csharp\r\nvoid Main()\r\n{\r\n\tvar schema = new Schema { Query = new PersonGraphType() };\r\n\tvar exec = new DocumentExecuter();\r\n\r\n\tvar result = exec.ExecuteAsync(options =>\r\n\t\t{\r\n\t\t\toptions.Schema = schema;\r\n\t\t\toptions.Query = \"{ person { name, addresses { street } } }\";\r\n\t\t}\r\n\t).Result;\r\n\r\n\tJsonConvert.SerializeObject(result.Data).Dump();\r\n}\r\n\r\npublic class PersonGraphType : ObjectGraphType\r\n{\r\n\tpublic PersonGraphType()\r\n\t{\r\n\t\tField<PersonResponseType>(\r\n\t\t\tname: \"person\",\r\n\t\t\tresolve: context =>\r\n\t\t\t{\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tvar repo = new PersonRepository();\r\n\t\t\t\t\treturn repo.GetPerson();\r\n\t\t\t\t}\r\n\t\t\t\tcatch(Exception ex) {\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n}\r\n\r\npublic class PersonResponseType : ObjectGraphType<Person>\r\n{\r\n\tpublic PersonResponseType()\r\n\t{\r\n\t\tName = \"PersonReponse\";\r\n\t\tField<StringGraphType>(\"name\");\r\n\t\t\r\n\t\tField<ListGraphType<AddressResponseType>>()\r\n\t\t\t.Name(\"addresses\")\r\n\t\t\t.Resolve(ctx => \r\n\t\t\t{\r\n\t\t\t\t// <--------- If any exception happens here, I want to handle it in Person Response type\r\n\t\t\t\treturn new PersonRepository().GetAddresses();\r\n\t\t\t});\r\n\t\t\t\r\n\t}\r\n}\r\n\r\npublic class AddressResponseType : ObjectGraphType<Address>\r\n{\r\n\tpublic AddressResponseType()\r\n\t{\r\n\t\tName = \"AddressReponse\";\r\n\t\tField<StringGraphType>(\"street\");\r\n\t}\r\n}\r\n\r\npublic class Person\r\n{\r\n\tpublic string Name { get; set; }\r\n\tpublic List<Address> Addresses { get; set; }\r\n\r\n\tpublic Person()\r\n\t{\r\n\t\tAddresses = new List<Address>();\r\n\t}\r\n}\r\n\r\npublic class Address\r\n{\r\n\tpublic string Street { get; set; }\r\n\r\n\tpublic Address(string street) {\r\n\t\tStreet = street;\r\n\t}\r\n}\r\n\r\npublic class PersonRepository\r\n{\r\n\tpublic Person GetPerson()\r\n\t{\r\n\t\treturn new Person()\r\n\t\t{\r\n\t\t\tName = \"John\"\r\n\t\t};\r\n\t}\r\n\t\r\n\tpublic List<Address> GetAddresses() {\r\n\t\treturn new List<Address>() {\r\n\t\t\tnew Address(\"Address 1\"),\r\n\t\t\tnew Address(\"Address 2\"),\r\n\t\t\tnew Address(\"Address 3\")\r\n\t\t};\r\n\t}\r\n}\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3050/comments",
    "author": "rmeshksar",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-03-31T18:08:35Z",
        "body": "No it is not possible to do that.\r\n\r\nThings you can do:\r\n- define `addresses` as a non-nullable field, so that if an error that occurs, `null` will be returned for the entire `person` node due to 'null bubbling'.  the exception will still be returned in the list of errors.\r\n- define a global 'unhandled exception handler' to change the error before it is returned\r\n- both\r\n"
      }
    ]
  },
  {
    "number": 3020,
    "title": "Generic sanitize html string input",
    "created_at": "2022-03-22T15:50:53Z",
    "closed_at": "2023-04-03T19:57:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3020",
    "body": "Hi,\r\n\r\nI'm looking for the best way to generalize the html sanitize input concept without having to do it inside each mutation once I cast my input into my input object. What would be the best way? Tried adding a validation rule that sanitized the input and then trying to compare it with the input but my sanitizer is to hard and make it fail all the time since it's very sensible. What would be the best approch to do something like that? Is it possible to modify my field value inside the validation rules?\r\n\r\nThank you very much,\r\nDan",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3020/comments",
    "author": "danmac03",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-03-22T17:25:38Z",
        "body": "If you are trying to sanitize HTML fields, I would write a custom scalar - e.g. `HtmlGraphType` - which would perform sanitization to remove javascript or whatever before it hits the resolvers.  Errors should be thrown in the validation stage, although generally sanitization will occur twice - once when it is validated and once when it is deserialized - depending on how you write the scalar.  If they are not thrown in the validation stage, perhaps so that sanitization does not occur twice, then certainly it will occur during the call to GetArgument, throwing an exception at that time.\r\n\r\nIf you are trying to sanitize string fields to be sure there is no HTML in them, I would write a custom scalar to replace StringGraphType, which will take effect for all uses of StringGraphType in your codebase."
      },
      {
        "user": "sungam3r",
        "created_at": "2023-04-03T19:57:31Z",
        "body": "Closed as answered. "
      }
    ]
  },
  {
    "number": 3013,
    "title": "Working with timezones by taking in ID's",
    "created_at": "2022-03-15T01:13:13Z",
    "closed_at": "2023-04-03T20:00:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3013",
    "body": "## Summary\r\nI believe I am simply having a lapse in my knowledge of how to use graphql/this library. I am fairly new and I can't imagine there isnt a solution for this, but I am really struggling. I wish to expose an API that takes in a datetime with a timezone attached to it. Some googling has led me to believe that getting a list of these availible timezones is not possible, so I wish to expose the timezone input as a string.\r\n\r\nMy current input looks like this (please tell me to reformat if its not in a standard way)\r\n\r\n```\r\ninput: DaysBetweenInputType {\r\n    start: TimeZonedDateTimeType {\r\n        timeZoneId: StringGraphType\r\n        dateTime: DateTimeGraphType\r\n    }\r\n}\r\n```\r\n\r\nThe actual problem is how I get that timeZoneId, call `TimeZoneInfo.FindSystemTimeById(timeZoneId)` to validate and convert to a proper timezone object. My current method is to have a model `TimeZonedDateTime`\r\n\r\n```\r\npublic struct TimeZonedDateTime\r\n{\r\n    public TimeZonedDateTime(DateTime dateTime, string timeZoneId)\r\n    {\r\n        DateTime = dateTime;\r\n        TimeZoneId = timeZoneId;\r\n    }\r\n\r\n    public DateTime DateTime { get; }\r\n    public TimeZoneInfo TimeZone\r\n    {\r\n        get\r\n        {\r\n            return TimeZoneInfo.FindSystemTimeZoneById(TimeZoneId);\r\n        }\r\n    }\r\n\r\n    public String TimeZoneId { get; }\r\n}\r\n```\r\n\r\nand a type to expose it\r\n\r\n```\r\npublic class TimeZonedDateTimeType : InputObjectGraphType<TimeZonedDateTime>\r\n{\r\n    public TimeZonedDateTimeType()\r\n    {\r\n        Field(tz => tz.TimeZoneId);\r\n        Field(tz => tz.DateTime);\r\n    }\r\n}\r\n```\r\n\r\nbut having a TimeZoneId inside that object feels odd to me. \r\n\r\nI think I fundamentally, at some level misunderstand types and models but I am not sure where the misunderstanding is.\r\n\r\nA much quicker question that I feel I should know but have somehow missed while reading the docs: Someone has called my API, I have now received a TimebetweenDateTimeType object with a nested TimeZonedDateTimeType object. How do I actually convert these into my model types so that I can call my query handlers\r\n\r\n### Environment (if relevant)\r\n\r\nLatest version of dotnet graphql.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3013/comments",
    "author": "prchristie",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-03-15T03:02:16Z",
        "body": "Typically one would use a DateTimeOffset which gets formatted in a RFC format with the time offset included.  However, I think the current version of GraphQL.NET converts the time stamp to UTC and then drops the offset.  (It might be fixed in the upcoming v5; can't remember.)  Similarly, responses would also be a DateTimeOffset value (or UTC time stored in a DateTime), and the client would convert the UTC timestamp to their own time zone.  Nevertheless, this still doesn't tell you exactly what time zone the client is in.\r\n\r\nIf you need to store a time zone alongside a timestamp, creating a class like you demonstrated above is a viable option.  But you must be aware that the list of time zone identifiers used by `FindSystemTimeZoneById` is different on Linux versus Windows, and if you are communicating to Javascript clients, I'm not sure which time zone identifiers they use.  If I had such a need, I would likely store a list of time zones in a database on the server, and then allow clients to select from the predetermined list in their user preferences page, or something like that."
      },
      {
        "user": "sungam3r",
        "created_at": "2023-04-03T20:00:34Z",
        "body": "Closed as answered and due to inactivity. "
      }
    ]
  },
  {
    "number": 2947,
    "title": "Lifetime of validation rule in AddValidationRule",
    "created_at": "2022-02-15T17:24:54Z",
    "closed_at": "2024-01-02T13:27:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2947",
    "body": "@Shane32  I see that rule is added as singleton and user cannot configure this. Why?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2947/comments",
    "author": "sungam3r",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-02-15T18:29:14Z",
        "body": "The design of the GraphQL builder is not to provide every single method of configuration of services, but to provide options for those configurations that are common, with encouragement of the recommended pattern.  Although not recommended, registering a schema as scoped is also supported, due to its wide use.\r\n\r\nThe following services always register as singletons:\r\n- `DocumentExecuter`\r\n- `ComplexityAnalyzer`\r\n- `ErrorInfoProvider`\r\n- `DocumentCache`\r\n- `GraphQLSerializer`\r\n- `ValidationRule`\r\n\r\nGraphQL types are registered as transients, so they match the lifetime of the schema.\r\n\r\nThese allow configuration of lifetime:\r\n- `DocumentListener`\r\n- `IFieldMiddleware`\r\n- `Schema`\r\n\r\nHowever, `IFieldMiddleware` can cause major problems if it does not match the schema lifetime.  We probably should only have allowed middleware to be registered as transients by default (so the lifetime matches that of the schema).\r\n\r\nAny other use would be considered an 'advanced use case' and require manual registration.  (I have no problem saying that for advanced scenarios, users must configure DI themselves.)\r\n\r\nAs for particulars, I was imagining that validation rules are primarily for validating an abstract schema.  However, if validation rules need to contact a database to verify authentication information, or something of the sort, I could see that a scoped validation rule would make sense.  Also, since validation rules are configured at execution time, there is no ill effect of having a lifetime that does not match the schema lifetime.  So I would support changing the validation rule extension methods to allow configuration of the registration lifetime, if you agree that it is appropriate.  I would not do so for the other extension methods at this time."
      },
      {
        "user": "sungam3r",
        "created_at": "2022-02-15T19:03:27Z",
        "body": "My use case:\r\n`System.InvalidOperationException : Cannot consume scoped service 'Microsoft.AspNetCore.Authorization.IAuthorizationHandler' from singleton 'Opn.Lib.Dotnet.Security.Grants.GrantAuthorization.GrantAuthorizationValidationRule'.`"
      },
      {
        "user": "sungam3r",
        "created_at": "2022-02-15T19:20:58Z",
        "body": "I can use a workaround like `Defer<T>` though."
      },
      {
        "user": "Shane32",
        "created_at": "2022-02-15T19:23:32Z",
        "body": "I think it makes sense to allow scoped validation rules if you think so also."
      },
      {
        "user": "sungam3r",
        "created_at": "2022-02-15T19:32:22Z",
        "body": "This is not urgently, now we will switch to the use of `Defer<>` from SteroidsDI."
      },
      {
        "user": "Shane32",
        "created_at": "2023-04-24T06:56:15Z",
        "body": "@sungam3r Should we add scoped validation rule support for v8?  I'd leave it as-is, encouraging singleton use.  Users can always register it as a scoped service if they need to in order to override the default lifetime -- for instance:\r\n\r\n```cs\r\nservices.AddGraphQL(b => b\r\n    /* more */\r\n    .AddValidationRule<MyValidationRule>()\r\n);\r\nservices.AddScoped<MyValidationRule>();\r\n```\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2023-04-24T08:33:13Z",
        "body": "Looking through `GraphQLBuilderExtensions.AddValidationRule` overloads I see that we can easily add support for scoped validation rules - just add `ServiceLifetime` parameter with default singleton value and pass it into `RegisterAsBoth`. So I would do it for v8 or even for v7 but I do not want to bother with additional overloads and jumping around `useForCachedDocuments` default parameter."
      },
      {
        "user": "Shane32",
        "created_at": "2024-01-01T23:49:49Z",
        "body": "Transient validation rules would also make sense - every request execution would automatically create a new instance of the validation rule, simplifying local storage of validation rule data during execution."
      }
    ]
  },
  {
    "number": 2896,
    "title": "[Question] Inspect given properties while working with complex variables for a mutation",
    "created_at": "2022-02-01T12:12:11Z",
    "closed_at": "2023-04-24T01:41:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2896",
    "body": "I'm currently struggling while working with variabels for mutations, when arguments are a complex type. My problem is, that I get a deserialized type of Note in the example below but not a list of properties which are defined in the argument value (**example call 1**). I really think this is possible in any way and I have just a \"simple\" missunderstanding. \r\n\r\nWhen not using a variable and passing the struct directly into the argument, it is very easy for me to read which properties are given (**example call 2**), just by inspecting `context.Arguments`.\r\n\r\nI created this simple example to demonstrate my problem.\r\n\r\nClasses\r\n```\r\n    public class Note\r\n    {\r\n        public string Id { get; set; }\r\n        public string Title { get; set; }\r\n        public string Body { get; set; }\r\n    }\r\n\r\n    public class NoteGraphType: ObjectGraphType<Note>\r\n    {\r\n        public NoteGraphType()\r\n        {\r\n            Name = $\"Note\";\r\n            Field(typeof(StringGraphType), \"Id\");\r\n            Field(typeof(StringGraphType), \"Title\");\r\n            Field(typeof(StringGraphType), \"Body\");\r\n        }\r\n    }\r\n\r\n    public class InputNoteGraphType : InputObjectGraphType<Note>\r\n    {\r\n        public InputNoteGraphType()\r\n        {\r\n            Name = $\"InputNote\";\r\n            Field(typeof(StringGraphType), \"Id\");\r\n            Field(typeof(StringGraphType), \"Title\");\r\n            Field(typeof(StringGraphType), \"Body\");\r\n        }\r\n    }\r\n```\r\n\r\nMutation\r\n```\r\n    Field<NoteGraphType>(\"upsertNote\",\r\n        arguments: new QueryArguments(\r\n            new QueryArgument<NonNullGraphType<InputNoteGraphType>> { Name = \"input\" }\r\n\r\n        ),\r\n        resolve: context => {\r\n            var argumentVar = context.Variables.FirstOrDefault(x => x.Name == \"input\").Value;\r\n            // How to resolve which properties of the variable are given? Here: [\"title\", \"body\"]\r\n            // store.UpsertNote(argumentVar, propertyList);\r\n            return argumentVar;\r\n        });\r\n\r\n    // example call 1\r\n   mutation upsertNote($input: InputNote!) {\r\n      upsertNote(input: $input) {\r\n        id\r\n      }\r\n    }\r\n```\r\n\r\nExample call 1\r\n```\r\nmutation upsertNote($input: InputNote!) {\r\n  upsertNote(input: $input) {\r\n    id\r\n  }\r\n}\r\n\r\n# Variables\r\n#  {\r\n#    \"input\": { \r\n#      \"title\": \"Test note\",\r\n#      \"body\": \"Hello World\"\r\n#    }\r\n#  }\r\n```\r\n\r\nExample call 2\r\n```\r\nmutation upsertNote {\r\n  upsertNote(input: { title: \"Test note\", body: \"Hello World\" })  {\r\n    id\r\n  }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2896/comments",
    "author": "Sascha-Lindtner",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2022-02-01T12:53:00Z",
        "body": "Try look into `context.Arguments` dictionary first."
      },
      {
        "user": "Sascha-Lindtner",
        "created_at": "2022-02-01T13:07:55Z",
        "body": "In `context.Arguments` is also \"just\" the deserialized Note instance"
      },
      {
        "user": "sungam3r",
        "created_at": "2022-02-01T13:12:37Z",
        "body": "Then `context.Inputs`."
      },
      {
        "user": "Sascha-Lindtner",
        "created_at": "2022-02-01T13:21:17Z",
        "body": "> Then `context.Inputs`.\r\n\r\ncontext is `IResolveFieldContext` and has no property `Inputs`"
      },
      {
        "user": "sungam3r",
        "created_at": "2022-02-01T13:34:06Z",
        "body": "What version do you use?"
      },
      {
        "user": "Sascha-Lindtner",
        "created_at": "2022-02-01T13:39:16Z",
        "body": "> What version do you use?\r\n\r\n5.2.0"
      },
      {
        "user": "sungam3r",
        "created_at": "2022-02-01T14:25:16Z",
        "body": "@Shane32 We have `ExecutionOptions.Inputs` and use it in `ValidationContext` to fill variables (parse/map discrete inputs into variables) but then no initial inputs available from resolver."
      },
      {
        "user": "Shane32",
        "created_at": "2022-02-01T14:59:59Z",
        "body": "Trying to read the \"initial inputs\" would be a pain anyway.  The input might be a literal and not contained within the variables, or it might be nested within another object.  Then answer is easy with `ParseDictionary`, as this is exactly what the method was designed for:\r\n\r\n### Option 1\r\n\r\nAdd this code to your input graph type:\r\n\r\n```cs\r\npublic override object ParseDictionary(IDictionary<string, object?> value)\r\n    => value;\r\n```\r\n\r\nThen within your resolver, pull the raw dictionary like this:\r\n\r\n```cs\r\nvar args = context.GetArgument<IDictionary<string, object>>(\"argument\");\r\n```\r\n\r\n### Option 2\r\n\r\n```cs\r\n    public class Note\r\n    {\r\n        public string Id { get; set; }\r\n        public bool HasId { get; set; }\r\n        public string Title { get; set; }\r\n        public bool HasTitle { get; set; }\r\n        public string Body { get; set; }\r\n        public bool HasBody { get; set; }\r\n    }\r\n\r\n//within input graph type\r\npublic override object ParseDictionary(IDictionary<string, object?> value)\r\n{\r\n    var note = new Note();\r\n    note.HasId = value.TryGetValue(\"id\", out var obj);\r\n    if (note.HasId) note.Id = (string)obj;\r\n    //repeat for title and body\r\n    return note;\r\n}\r\n\r\n//within resolver\r\nvar arg = context.GetArgument<Note>(\"arg\");\r\nif (arg.HasId) ...\r\n```\r\n\r\n### Note\r\n\r\nIf you nest complex types, you might need to use the second option.  Well, not necessarily.  I guess it would depend on your needs."
      },
      {
        "user": "Shane32",
        "created_at": "2022-02-03T05:21:01Z",
        "body": "@Sascha-Lindtner Were you able to solve your issue?"
      },
      {
        "user": "Sascha-Lindtner",
        "created_at": "2022-03-31T11:14:59Z",
        "body": "Sorry for my late answer. I created a fix. But all the other solutions did not work. As long as I created my InputTypes via InputObjectGraphType, I'm not able to see which fields are given. Now all my InputTypes a inherited by InputObjectGraphType instead and its fine."
      }
    ]
  },
  {
    "number": 2885,
    "title": "accessor.Context is null when using DataLoader with a custom document executor",
    "created_at": "2022-01-27T12:31:58Z",
    "closed_at": "2022-01-27T14:06:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2885",
    "body": "## Summary\r\n\r\nIn my Startup file I have the following configuration:\r\n```cs\r\n        public class CustomDocumentExecuter : DocumentExecuter { }\r\n\r\n        public void ConfigureServices(IServiceCollection services)\r\n        {\r\n            GraphQL.MicrosoftDI.GraphQLBuilderExtensions\r\n                .AddGraphQL(services)\r\n                .AddServer(true)\r\n                .AddSystemTextJson()\r\n                .AddErrorInfoProvider(opt => opt.ExposeExceptionStackTrace = Environment.IsDevelopment())\r\n                .AddDocumentExecuter<CustomDocumentExecuter>()\r\n                .AddSchema<StarWarsSchema>()\r\n                .AddGraphTypes(typeof(StarWarsSchema).Assembly)\r\n                .AddDataLoader();\r\n        }\r\n```\r\n\r\nThe StarWarsSchema contains a field that uses the DataLoader in the usual way:\r\n```\r\n            Field<StringGraphType>(\r\n                \"batchedName\",\r\n                resolve: context => accessor.Context.GetOrAddBatchLoader<string, string>(\r\n                    \"LoadName\", data.NameById).LoadAsync(context.Source.Id)\r\n                );\r\n```\r\n\r\nEverything works as expected if I leave out the `AddDocumentExecuter` call in the configuration, or if I add the standard `DocumentExecuter`. However, when I add the `CustomDocumentExecuter` above, even though it does not override anything, the dataloader accessor does not work any more - the `accessor.Context` then always gives `null`. The rest seems to work, only the fields using DataLoader show the problem.\r\n\r\nAm I doing anything wrong or is this a bug? How can I use a custom DocumentExecuter together with the DataLoader?\r\n\r\n### Environment\r\n\r\n```\r\n    <TargetFramework>net6.0</TargetFramework>\r\n```\r\n```\r\n    <PackageReference Include=\"GraphQL\" Version=\"4.7.1\" />\r\n    <PackageReference Include=\"GraphQL.DataLoader\" Version=\"4.7.1\" />\r\n    <PackageReference Include=\"GraphQL.MicrosoftDI\" Version=\"4.7.1\" />\r\n    <PackageReference Include=\"GraphQL.Server.Core\" Version=\"5.2.0\" />\r\n    <PackageReference Include=\"GraphQL.Server.Transports.AspNetCore\" Version=\"5.2.0\" />\r\n    <PackageReference Include=\"GraphQL.Server.Transports.AspNetCore.SystemTextJson\" Version=\"5.2.0\" />\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2885/comments",
    "author": "Cito",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-01-27T13:14:00Z",
        "body": "Just guessing but your custom document executor probably doesn’t have the proper constructor that allows dependency injection to inject all the necessary classes. You need the most complex one available for proper operation. "
      },
      {
        "user": "Cito",
        "created_at": "2022-01-27T14:01:16Z",
        "body": "Thanks for reminding me that in C# the constructors are not inherited. After adding the most complex one, as you suggested, it works now.\r\n\r\nActually all I want to do is change the ExecutionStrategy for Queries from Parallel to Serial. So I'm using the following class now as DocumentExecuter. Is there a simpler way to achieve this?\r\n\r\n```cs\r\n    public class SerialDocumentExecuter : DocumentExecuter\r\n    {\r\n        public SerialDocumentExecuter(\r\n            IDocumentBuilder documentBuilder, IDocumentValidator documentValidator,\r\n            IComplexityAnalyzer complexityAnalyzer, IDocumentCache documentCache,\r\n            IEnumerable<IConfigureExecution>? configurations)\r\n            : base(documentBuilder, documentValidator, complexityAnalyzer, documentCache, configurations) { }\r\n\r\n        protected override IExecutionStrategy SelectExecutionStrategy(ExecutionContext context)\r\n        {\r\n            return context.Operation.OperationType switch\r\n            {\r\n                OperationType.Query => SerialExecutionStrategy.Instance,\r\n                OperationType.Mutation => SerialExecutionStrategy.Instance,\r\n                OperationType.Subscription => throw new NotSupportedException(\r\n                    \"DocumentExecuter does not support executing subscriptions.\"),\r\n                _ => throw new InvalidOperationException(\r\n                    $\"Unexpected OperationType {context.Operation.OperationType}\")\r\n            };\r\n        }\r\n    }\r\n```\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2022-01-27T14:02:39Z",
        "body": "No, that is the recommended pattern."
      },
      {
        "user": "Cito",
        "created_at": "2022-01-27T14:06:29Z",
        "body": "Thanks a lot, @Shane32, you saved my day."
      }
    ]
  },
  {
    "number": 2869,
    "title": "Dynamic subscription handler",
    "created_at": "2022-01-20T01:49:01Z",
    "closed_at": "2022-01-20T23:30:34Z",
    "labels": [
      "question",
      "subscriptions"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2869",
    "body": "Hi everyone,\r\n\r\nIs it possible to define a universal subscription handler that would process every subscription and every field? I'm looking for something like this:\r\n```\r\n    public class DynamicSubscription : ObjectGraphType\r\n    {\r\n        public DynamicSubscription()\r\n        {\r\n            AddField(\"*\", ...);\r\n        }\r\n        ...\r\n    }\r\n\r\n   var executor = new SubscriptionDocumentExecuter();\r\n   schema.Subscription = new DynamicSubscription();\r\n```\r\n\r\nThe structure of the schema and incoming queries are not known in advance.\r\n\r\nAny help greatly appreciated.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2869/comments",
    "author": "azaslonov",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-01-20T03:58:00Z",
        "body": "With a truly dynamic schema, there’s no way to fully parse the query into execution nodes or even to validate it. I would suggest using the parser project to parse the query into an AST and write your own execution code, as there isn’t much useful that GraphQL.NET can do without a schema. You can of course use the classes and execution result class and serializers and so on which will greatly facilitate such an endeavor. "
      },
      {
        "user": "azaslonov",
        "created_at": "2022-01-20T22:07:45Z",
        "body": "@Shane32, thanks for quick response. Sorry for confusion: we don't know the schema in advance (when we build the code), but we do know schema at the moment of request (from our DB), and we do run some validations of the request against the schema. What I meant is that we can't code anything like that AddField method, because in build-time we don't know what fields will be there."
      },
      {
        "user": "Shane32",
        "created_at": "2022-01-20T22:10:06Z",
        "body": "Is it known prior to the time of request, for example after the database boots up with daily refresh, or only at the moment of the request?"
      },
      {
        "user": "azaslonov",
        "created_at": "2022-01-20T22:13:10Z",
        "body": "Yeah, our users can update the schema in DB (prior to making the request). This is when we re-parse it and keep in memory for quicker request processing."
      },
      {
        "user": "Shane32",
        "created_at": "2022-01-20T22:48:33Z",
        "body": "Why can't you build the schema from the database then (and cache it)?  I have plenty of code that builds dynamic schemas... shouldn't be too hard.  You can certainly use the same field resolver for each field if you like."
      },
      {
        "user": "azaslonov",
        "created_at": "2022-01-20T23:24:32Z",
        "body": "Yep, that's the problem, I don't know how to make that AddField operation dynamic, it requires specific field name to attach to, like in this example:\r\n```\r\n    AddField(new EventStreamFieldType\r\n    {\r\n      Name = \"messageAdded\",\r\n      Type = typeof(MessageType),\r\n      Resolver = new FuncFieldResolver<Message>(ResolveMessage),\r\n      Subscriber = new EventStreamResolver<Message>(Subscribe)\r\n    });\r\n```\r\nHow can I attach the same (universal) resolver to all of the types/fields?"
      },
      {
        "user": "Shane32",
        "created_at": "2022-01-20T23:25:31Z",
        "body": "Just run AddField for each field with the same resolver for each."
      },
      {
        "user": "azaslonov",
        "created_at": "2022-01-20T23:26:56Z",
        "body": "I was afraid you say that :). Are there any other options by chance?"
      },
      {
        "user": "Shane32",
        "created_at": "2022-01-20T23:27:19Z",
        "body": "Pseudocode:\r\n\r\n1. If user's db schema has changed\r\n  a. Rebuild GraphQL `Schema` from db schema\r\n  b. Cache schema\r\n2. Pull GraphQL schema from cache\r\n3. Execute query"
      },
      {
        "user": "Shane32",
        "created_at": "2022-01-20T23:29:08Z",
        "body": "Again, if you do not initialize the GraphQL `Schema` class with each field and type, `GraphQL` cannot validate the query or know how to execute any nodes.  There's just nothing for GraphQL.NET to do.  You can parse the query via the parser project, and then write your own code to examine the nodes and so on."
      },
      {
        "user": "azaslonov",
        "created_at": "2022-01-20T23:30:12Z",
        "body": "Yeah, got it. Thanks a lot for your answers, really appreciate your help."
      }
    ]
  },
  {
    "number": 2850,
    "title": "Using DataLoader with MicrosoftDI",
    "created_at": "2022-01-10T10:30:03Z",
    "closed_at": "2023-04-03T21:44:21Z",
    "labels": [
      "question",
      "data loader"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2850",
    "body": "## Summary\r\n\r\nDataLoader code fails to compile when using scoped resolvers\r\n\r\n## Relevant information\r\n\r\nBefore, compiles fine, but needs to be scoped:\r\n\r\n```csharp\r\nField<UserType, User>()\r\n     .Name(\"User\")\r\n     .ResolveAsync(context =>\r\n     {\r\n         var db = context.RequestServices.GetRequiredService<MyDbContext>()\r\n         var loader = accessor.Context.GetOrAddBatchLoader<int, User>(\"GetUsersById\", db.GetUsersByIdAsync);\r\n         return loader.LoadAsync(context.Source.UserId);\r\n     });\r\n```\r\n\r\nAfter:\r\n\r\n```csharp\r\nField<UserType, User>()\r\n     .Name(\"User\")\r\n     .ResolveScopedAsync(context =>\r\n     {\r\n         var db = context.RequestServices.GetRequiredService<MyDbContext>()\r\n         var loader = accessor.Context.GetOrAddBatchLoader<int, User>(\"GetUsersById\", db.GetUsersByIdAsync);\r\n         return loader.LoadAsync(context.Source.UserId);\r\n     });\r\n```\r\n\r\nGives an error on the return like:\r\n\r\n```\r\nCannot implicitly convert type 'GraphQL.DataLoader.IDataLoaderResult<User>' to 'System.Threading.Tasks.Task<User>'. An explicit conversion exists (are you missing a cast?)\r\n```\r\n\r\nI'm not sure how to resolve this!\r\n\r\n### Environment (if relevant)\r\n\r\nVersion 4.7.1\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2850/comments",
    "author": "jeffw-wherethebitsroam",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-01-10T12:24:58Z",
        "body": "`.Returns<IDataLoaderResult<User>>().ResolveScoped(…`\r\n\r\nbut it probably won’t work because the scope will be discarded at the end of this method, before the data loader executes"
      },
      {
        "user": "jeffw-wherethebitsroam",
        "created_at": "2022-01-10T14:41:42Z",
        "body": "Ok, I have previously been doing something like:\r\n\r\n```csharp\r\nField<UserType, User>()\r\n     .Name(\"User\")\r\n     .ResolveAsync(context =>\r\n     {\r\n         var loader = accessor.Context.GetOrAddBatchLoader<int, User>(\"GetUsersById\",\r\n             async (ids, cancellationToken) =>\r\n             {\r\n                 using var scope = context.RequestServices.CreateScope();\r\n                 var db = scope.ServiceProvider.GetRequiredService<MyDbContext>();\r\n                 return db.GetUsersByIdAsync(ids, cancellationToken);\r\n             }\r\n         );\r\n         return loader.LoadAsync(context.Source.UserId);\r\n     });\r\n```\r\n\r\nIs this ok? Is there an easier way to do this?\r\n\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2022-01-10T17:14:54Z",
        "body": "Context.RequestServices intended to be scoped already."
      },
      {
        "user": "Shane32",
        "created_at": "2022-01-10T17:32:18Z",
        "body": "Not if you want to use a parallel execution strategy. Of course with a serial execution strategy you shouldn’t need to create a scope at all."
      },
      {
        "user": "jeffw-wherethebitsroam",
        "created_at": "2022-01-13T12:09:48Z",
        "body": "Yes, we run in parallel with an EF core context. So without scopes, we run into the error:\r\n\r\n> A second operation started on this context before a previous operation completed. This is usually caused by different threads using the same instance of DbContext, however instance members are not guaranteed to be thread safe.\r\n\r\nSo I was wondering how best to handle this situation when using DataLoader"
      },
      {
        "user": "Shane32",
        "created_at": "2022-01-13T12:46:12Z",
        "body": "There is no easier way provided than you’ve already been doing. \r\n\r\nI would create new extension methods for IDataLoaderContext that simplifies creating a scope and pulling the database from it or whatever you need. \r\n\r\nIn my code I simplify that kind of stuff down to one line of code, where I can. So to have a data loader pull a list of orders for a customer I might just write:\r\n\r\n```cs\r\nthis.AddDataLoadedCollectionField(“orders”, source => source.Id, db => db.Orders.Where(x => !x.Deleted), orders => orders.CustomerId);\r\n```\r\n\r\nSo it works throughout my codebase - but that is specific to my needs. "
      },
      {
        "user": "sungam3r",
        "created_at": "2023-04-03T21:30:06Z",
        "body": "@Shane32 close? "
      },
      {
        "user": "Shane32",
        "created_at": "2023-04-03T21:44:21Z",
        "body": "Please ask if there are any further questions."
      }
    ]
  },
  {
    "number": 2727,
    "title": "Incorrect resolver return type when using batch loader and GraphQL.MicrosoftDI",
    "created_at": "2021-12-06T09:08:11Z",
    "closed_at": "2021-12-06T17:22:08Z",
    "labels": [
      "question",
      "data loader"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2727",
    "body": "## Summary\r\nWithout GraphQL.MicrosoftDI it works:\r\n\r\n```csharp\r\nField<NonNullGraphType<OrgType>, OrgProto>()\r\n    .Name(\"org\")\r\n    .Description(\"Organization details\")\r\n    .ResolveAsync(context => accessor.Context\r\n        .GetOrAddBatchLoader<long, OrgProto>(\r\n            loaderKey: context.Path + context.FieldAst.Name,\r\n            fetchFunc: batchLoaders.Orgs(context))\r\n        .LoadAsync(context.Source.OrgId)); // LoadAsync returns IDataLoaderResult<Org>\r\n```\r\n\r\nHowever when using GraphQL.MicrosoftDI and .WithService() I get compile error:\r\n\r\n```csharp\r\nField<NonNullGraphType<OrgType>, OrgProto>()\r\n    .Name(\"org\")\r\n    .Description(\"Organization details\")\r\n    .Resolve() // <=== Resolve\r\n    .WithService<BatchLoaders>() // <=== WithService\r\n    .ResolveAsync((context, batchLoaders) => accessor.Context\r\n        .GetOrAddBatchLoader<long, OrgProto>(\r\n            loaderKey: context.Path + context.FieldAst.Name,\r\n            fetchFunc: batchLoaders.Orgs(context))\r\n        .LoadAsync(context.Source.OrgId));\r\n```\r\n\r\nI get following compile error:\r\n```\r\nCannot convert expression type 'GraphQL.DataLoader.IDataLoaderResult<Flymachine.Proto.Orgs.Org>' \r\nto return type 'System.Threading.Tasks.Task<Flymachine.Proto.Orgs.Org>'\r\n```\r\n\r\nWhy I get this error? It seems I can fix this by using `.LoadAsync(...).GetResultAsync()` but I am not sure if it won't break batch loader functionality?:\r\n\r\n```csharp\r\nField<NonNullGraphType<OrgType>, OrgProto>()\r\n    .Name(\"org\")\r\n    .Description(\"Organization details\")\r\n    .Resolve() // <=== Resolve\r\n    .WithService<BatchLoaders>() // <=== WithService\r\n    .ResolveAsync((context, batchLoaders) => accessor.Context\r\n        .GetOrAddBatchLoader<long, OrgProto>(\r\n            loaderKey: context.Path + context.FieldAst.Name,\r\n            fetchFunc: batchLoaders.Orgs(context))\r\n        .LoadAsync(context.Source.OrgId).GetResultAsync()); // <=== .GetResultAsync(), no compile error\r\n```\r\n\r\n~~Is it okay to return `IDataLoaderResult.GetResultAsync()` here? I had no chance yet to test it properly as I am rewriting pretty big schema which fails to compile for now...~~ - finally managed to compile and run the schema and for sure `GetResultAsync()` can't be used because it causes batch-loaders to execute separately and not in batch. So the problem is with types when using `Resolve().WithService<Service>().ResolveAsync(...)`.\r\n\r\n### Environment (if relevant)\r\n\r\nGraphQL.net 4.5.0\r\n.net 5.0\r\nC# 9\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2727/comments",
    "author": "alekbarszczewski",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-12-06T15:11:15Z",
        "body": "Technically the data loader's LoadAsync method is a synchronous method, not asynchronous.  So properly it should not have been called `LoadAsync` at all, which is what makes this confusing.\r\n\r\nJust change your code like this and all will be fine:\r\n\r\n```cs\r\nField<NonNullGraphType<OrgType>, IDataLoaderResult<OrgProto>>()\r\n    .Name(\"org\")\r\n    .Description(\"Organization details\")\r\n    .Resolve() // <=== Resolve\r\n    .WithService<BatchLoaders>() // <=== WithService\r\n    .Resolve((context, batchLoaders) => accessor.Context\r\n        .GetOrAddBatchLoader<long, OrgProto>(\r\n            loaderKey: context.Path + context.FieldAst.Name,\r\n            fetchFunc: batchLoaders.Orgs(context))\r\n        .LoadAsync(context.Source.OrgId));\r\n```\r\n\r\nI don't see a real easy to write an extension method to 'fix' this.  FYI, the reason the other syntax works is because there are a number of extension methods in `DataLoaderExtensions.cs` defined to allow that and similar syntax."
      },
      {
        "user": "alekbarszczewski",
        "created_at": "2021-12-06T17:22:07Z",
        "body": "Perfect, thanks! It works now."
      }
    ]
  },
  {
    "number": 2701,
    "title": "Get the input values in the order they were supplied",
    "created_at": "2021-11-19T09:12:04Z",
    "closed_at": "2021-11-19T19:43:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2701",
    "body": "I have a schema where fields have several parameters, and one of them is a sort order. A query may look like this:\r\n\r\n```\r\n{\r\n   users(sortOrder : {name : DESC, id : ASC}) {\r\n      totalCount\r\n      items {\r\n         id\r\n         name         \r\n      }\r\n   }\r\n}\r\n```\r\n\r\nThe problem is, the `Argument.Value` is a `Dictionary<string, object>`. So I get the data as:\r\n\r\n```\r\n{\r\n   \"id\" : ASC,\r\n   \"name\" : DESC\r\n}\r\n```\r\n\r\nThis does not allow me to know what order the values were supplied by the user. \r\n\r\nIs there any possibility to parse them in the given order? Or do I have to build something like an array of values:\r\n\r\n```\r\n{\r\n   users(sortOrder : [{name : DESC}, {id : ASC}]) {\r\n      totalCount\r\n      items {\r\n         id\r\n         name         \r\n      }\r\n   }\r\n}\r\n```\r\nThis is the best I could come up with as an alternative.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2701/comments",
    "author": "mariusbancila",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-11-19T17:30:22Z",
        "body": "Enumerating `context.FieldAst.Arguments` should allow you to determine the order in which the arguments were supplied.  Note that `context.FieldAst.Arguments` may be `null` if no arguments were supplied.\r\n\r\nI suggest using `context.GetArgument` to retrieve the actual values of those arguments, so the values can be parsed by the proper scalar type, converted if necessary, default argument values applied, and/or read from variables."
      },
      {
        "user": "Shane32",
        "created_at": "2021-11-19T17:56:08Z",
        "body": "Unfortunately I see you're trying to determine the order of the fields inside the argument's value.  This can be done also in a similar fashion -- but only if the `sortOrder` argument is passed as a literal.  Otherwise ... well, it is possible to write your own dictionary implementation which retains the order of elements added to it, then rewrite `GraphQL.SystemTextJson.InputsConverter` to use that custom dictionary type you created.  Perhaps implement similar changes in GraphQL for literals.  Then you might write a custom scalar for the sortorder object, with ParseDictionary overridden to interpret the object as passed in.  But I don't know that all this effort is worth it.\r\n\r\nWhile your original concept is pretty cool, I would probably just do this:\r\n\r\n```gql\r\n{\r\n  users (sortOrder: [{ by: NAME }, { by: ID, descending: true }] {\r\n    totalCount\r\n    items {\r\n      id\r\n      name\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis way, the fields names are an enumeration type, and the `descending` field has a default value of false.  Then it is really easy to build a IEnumerable or IQuerablye as necessary like this:\r\n\r\n```cs\r\npublic class Widget\r\n{\r\n    public string Name { get; set; }\r\n    public string Value { get; set; }\r\n}\r\n\r\nclass SortBy\r\n{\r\n    public WidgetFields By { get; set; }\r\n    public bool Descending { get; set; }\r\n}\r\n\r\nenum WidgetFields\r\n{\r\n    Name,\r\n    Value\r\n}\r\n\r\n//IEnumerable or IQueryable should work here\r\nIEnumerable<Widget> Sort(this IEnumerable<Widget> data, IEnumerable<SortBy> sortBy)\r\n{\r\n    if (sortBy == null)\r\n        return data;\r\n\r\n    bool first = true;\r\n    IOrderedEnumerable<Widget> ordered = null;\r\n    foreach (var sortOrder in sortBy)\r\n    {\r\n        if (first)\r\n        {\r\n            switch (sortOrder.By)\r\n            {\r\n                case WidgetFields.Name when !sortOrder.Descending:\r\n                    ordered = data.OrderBy(x => x.Name);\r\n                    break;\r\n                case WidgetFields.Name when sortOrder.Descending:\r\n                    ordered = data.OrderByDescending(x => x.Name);\r\n                    break;\r\n                case WidgetFields.Value when !sortOrder.Descending:\r\n                    ordered = data.OrderBy(x => x.Value);\r\n                    break;\r\n                case WidgetFields.Value when sortOrder.Descending:\r\n                    ordered = data.OrderByDescending(x => x.Value);\r\n                    break;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            switch (sortOrder.By)\r\n            {\r\n                case WidgetFields.Name when !sortOrder.Descending:\r\n                    ordered = ordered.ThenBy(x => x.Name);\r\n                    break;\r\n                case WidgetFields.Name when sortOrder.Descending:\r\n                    ordered = ordered.ThenByDescending(x => x.Name);\r\n                    break;\r\n                case WidgetFields.Value when !sortOrder.Descending:\r\n                    ordered = ordered.ThenBy(x => x.Value);\r\n                    break;\r\n                case WidgetFields.Value when sortOrder.Descending:\r\n                    ordered = ordered.ThenByDescending(x => x.Value);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return first ? data : ordered;\r\n}\r\n```\r\n\r\nThis probably makes it easier to build the object in javascript anyway, as you can just push entries to an array to get the desired sort order.\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2021-11-19T17:58:46Z",
        "body": "But your alternate idea would work well too -- `users(sortOrder : [{name : DESC}, {id : ASC}])`"
      },
      {
        "user": "mariusbancila",
        "created_at": "2021-11-19T18:37:37Z",
        "body": "The idea of implementing my own dictionary and rewriting the `InputsConverter` seems interesting but might be too much work for something I can achieve differently.\r\n\r\nThe idea is that this schema is already in production and this is a bug we discovered which I am working to fix. I need to maintain backward compatibility as much as possible. So, currently, I think my best option would be to:\r\n\r\n- keep `sortOrder` as it is now but limit it to a single value, which would work fine\r\n- provide an additional `sortOrders` which is an array of values as I showed in my example\r\n\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2021-11-19T18:41:08Z",
        "body": "Makes sense to me."
      },
      {
        "user": "mariusbancila",
        "created_at": "2021-11-19T20:11:40Z",
        "body": "I actually managed to find an easy fix. \r\n\r\nI replaced this code:\r\n```\r\nvar sortOrderArgDef = ctx.FieldDefinition.Arguments?.FirstOrDefault(arg => arg.Name == \"sortOrder\");\r\nvar sortInputType = sortOrderArgDef.ResolvedType as InputObjectGraphType;\r\n\r\nif (sortOrderArgDef is object && ctx.Arguments is object && ctx.Arguments.TryGetValue(\"sortOrder\", out ArgumentValue sortOrder))\r\n{\r\n   if (sortOrder.Value is Dictionary<string, object> sortMemberDictionary)\r\n   {\r\n      foreach (var sortFieldName in sortMemberDictionary.Keys)\r\n      {\r\n         // handle it here\r\n      }\r\n   }            \r\n}\r\n```\r\n\r\nwith this code:\r\n```\r\nvar sortOrderArgDef = ctx.FieldDefinition.Arguments?.FirstOrDefault(arg => arg.Name == \"sortOrder\");\r\nvar sortInputType = sortOrderArgDef?.ResolvedType as InputObjectGraphType;\r\n\r\nvar arg = ctx.FieldAst.Arguments.FirstOrDefault(a => a.Name == \"sortOrder\");\r\nif (arg is object && sortInputType is object)\r\n{ \r\n   foreach(ObjectValue child in arg.Children)\r\n   {\r\n      foreach(ObjectField field in child.ObjectFields)\r\n      {\r\n         // handle it here\r\n      }\r\n   }\r\n}\r\n```\r\nThis is exactly what I was looking for. Works like a charm."
      },
      {
        "user": "Shane32",
        "created_at": "2021-11-19T20:39:41Z",
        "body": "But that won’t work if the sort order is passed in a variable - correct?"
      },
      {
        "user": "mariusbancila",
        "created_at": "2021-11-19T21:02:28Z",
        "body": "> But that won’t work if the sort order is passed in a variable - correct?\r\n\r\nThat's correct. I didn't think of that, but I checked it and you're right. Thanks for pointing it out."
      },
      {
        "user": "mariusbancila",
        "created_at": "2021-11-26T16:29:31Z",
        "body": "For the sake of reference, since others might read this looking for a similar solution, I decided to go with the following solution to be both backward compatible and support multiple sort order fields at the same time.\r\n\r\n```\r\n{\r\n   users(sortOrder : {\r\n         name : DESC\r\n         _thenBy : {\r\n            registrationDate : ASC\r\n            _thenBy : {\r\n               id : DESC\r\n            }\r\n         }})\r\n   {\r\n      totalCount\r\n      items {\r\n         id\r\n         name         \r\n      }\r\n   }\r\n}\r\n```\r\n\r\nThe resolved type of the `_thenBy` field is the type of the `sortOrder` field, so this goes recursively as much as needed. And it's pretty easy to parse it, It also works with variables:\r\n\r\n```\r\n{\r\n  \"order\" :{\r\n      \"name\" : \"DESC\",\r\n      \"_thenBy\" : {\r\n        \"registrationDate\" :\"ASC\",\r\n        \"_thenBy\" : {\r\n          \"id\" :\"DESC\"\r\n        }}}\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 2653,
    "title": "Access UserContext inside data fetch function when using Dataloader ",
    "created_at": "2021-09-17T10:07:57Z",
    "closed_at": "2021-09-17T10:45:05Z",
    "labels": [
      "question",
      "data loader"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2653",
    "body": "I am starting to integrate DataLoader into our project and I'm not sure how to best implement what I need. We're making use of \r\nthe `UserContext` object provided by GraphQL to pass request-spanning information down to all resolvers. The resolvers can use this `UserContext` to do their actual work and fetch data from the database, for example. That worked great so far.\r\n\r\nOur old code looks like this:\r\n```\r\nFieldAsync<StringGraphType>(\"CIName\",\r\n    resolve: async (context) =>\r\n    {\r\n        var ciid = context.Source!.CIID;\r\n        var userContext = (context.UserContext as OmnikeeperUserContext)!;\r\n        var names = await attributeModel.GetMergedCINames(SpecificCIIDsSelection.Build(ciid), userContext.LayerSet, userContext.TimeThreshold);\r\n});\r\n```\r\n\r\nNote the use of the `userContext` and how its inner data is used for getting data from the Model layer (`attributeModel`).\r\n\r\nWith the introduction of the dataloader, it doesn't seem as straight forward anymore. Essentially, the function that now does the actual fetch does not have access to the `UserContext`... but we need this for data fetching. I've come up with a really cumbersome workaround of passing the UserContext as part of the key and inside a Tuple... but it makes all kinds of things much harder: we need a tuple, a custom equalityComparator, and the actual fetch function is much more complex too. Here's the workaround:\r\n\r\n```\r\nField<StringGraphType>(\"CIName\",\r\n    resolve: (context) =>\r\n    {\r\n        var ciid = context.Source!.CIID;\r\n        var userContext = (context.UserContext as OmnikeeperUserContext)!;\r\n\r\n        var loader = dataLoaderContextAccessor.Context.GetOrAddBatchLoader(\"GetMergedCINames\", Fetch, new EQ());\r\n        return loader.LoadAsync((SpecificCIIDsSelection.Build(ciid), userContext));\r\n    }\r\n);\r\n\r\nprivate class EQ : EqualityComparer<(SpecificCIIDsSelection ciidSelection, OmnikeeperUserContext context)>\r\n{\r\n    public override bool Equals([AllowNull] (SpecificCIIDsSelection ciidSelection, OmnikeeperUserContext context) x, [AllowNull] (SpecificCIIDsSelection ciidSelection, OmnikeeperUserContext context) y)\r\n    {\r\n        return x.ciidSelection.Equals(y.ciidSelection); // ignore context, its fixed per-request\r\n    }\r\n\r\n    public override int GetHashCode([DisallowNull] (SpecificCIIDsSelection ciidSelection, OmnikeeperUserContext context) t)\r\n    {\r\n        return t.ciidSelection.GetHashCode(); // ignore context, its fixed per-request\r\n    }\r\n}\r\n\r\nprivate async Task<IDictionary<(SpecificCIIDsSelection ciidSelection, OmnikeeperUserContext context), string?>> Fetch(IEnumerable<(SpecificCIIDsSelection ciidSelection, OmnikeeperUserContext context)> ciidSelections)\r\n{\r\n    // HACK: treat as if we only have a single usercontext\r\n    var userContext = ciidSelections.First().context;\r\n\r\n    var ret = new Dictionary<(SpecificCIIDsSelection ciidSelection, OmnikeeperUserContext context), string?>() { };\r\n\r\n    // ... snip: actual fetch code that uses userContext and batches all requests into a single one\r\n    // then splits them again and returns the required, properly structured dictionary\r\n\r\n    return ret;\r\n}\r\n```\r\n\r\nIs there a better way to access the `UserContext` inside the fetch function?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2653/comments",
    "author": "maximiliancsuk",
    "comments": [
      {
        "user": "maximiliancsuk",
        "created_at": "2021-09-17T10:45:05Z",
        "body": "I'm dumb... I just realized that I can use a JS-style closure like the following to pass the `UserContext`:\r\n```\r\nField<StringGraphType>(\"CIName\",\r\n  resolve: (context) =>\r\n  {\r\n      var ciid = context.Source!.CIID;\r\n      var userContext = (context.UserContext as OmnikeeperUserContext)!;\r\n\r\n      var loader = dataLoaderContextAccessor.Context.GetOrAddBatchLoader(\"GetMergedCINames\", (IEnumerable<SpecificCIIDsSelection> ciidSelections) => Fetch(userContext, ciidSelections));\r\n      return loader.LoadAsync((SpecificCIIDsSelection)SpecificCIIDsSelection.Build(ciid));\r\n  });\r\n```\r\n\r\nThat fixes my issue and makes everything simple again! :)\r\n\r\nI'll close my question, but leave this up should anybody have the same brain-fart is I did ;)"
      },
      {
        "user": "Shane32",
        "created_at": "2021-09-17T11:01:44Z",
        "body": "Keep in mind that only the first call to `GetOrAddBatchLoader` will capture the lambda (per request); the rest will use the lambda already specified.  Very similar to your \"hack\" comment in your previous sample.  This should be fine for the usercontext, since it will be the same for every data loader call for the same request.  So I think you're good.  You just wouldn't want to include the `context.Source` property in the lambda or anything like that, and you're relying on the data loader to keep concurrent requests separated by request (which it does within the `DataLoaderContextAccessor` via an `AsyncLocal`)."
      },
      {
        "user": "maximiliancsuk",
        "created_at": "2021-09-17T11:12:16Z",
        "body": "Yes, you're right. I wouldn't want to use this approach for anything that would need to be \"up-to-date\" with every field resolving. So I also think it's ok to use for the UserContext.\r\n\r\nI didn't actually think about concurrent requests at all, but just assumed that there would be safeguards that keep things separated here. Thanks for thinking it through! :)\r\n\r\nI'll re-open should I run into problems down the road with this approach."
      }
    ]
  },
  {
    "number": 2644,
    "title": "Type extend with GraphType first and Apollo federation",
    "created_at": "2021-09-08T09:32:58Z",
    "closed_at": "2021-09-08T14:03:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2644",
    "body": "Went through documentation and examples and can not find solution for my use case. I would like to use GraphType first approach (managed to make it kind of work with schema first) with Apollo federation where type is defined in different GraphQL server (NodeJS) and I need to extend it inside dotnet GraphQL and define resolver. Is something like that possible or should I stick with Schema first approach? \r\n\r\n**Example:**\r\nLets say we have employee that manages multiple types of property in company. So schema would look something like this\r\n\r\nUser\r\n__Organization\r\n_____ManagedProperty\r\n_______Vehicles\r\n_______Computers\r\n\r\nAll of this is defined in different GraphQL schema with resolvers. Now I want to extend ManagedProperty with MobilePhones type with resolvers and filters. So basically I need GraphTypes approach to generate something like: \r\n\r\nextend type ManagedProperty {\r\n__mobilePhone(id: ID!): MobilePhone\r\n__mobilePhones: [MobilePhone]\r\n}\r\n\r\ntype MobilePhone  @key(fields: \"\"id\"\") {\r\n__id: ID!\r\n__name....\r\n}",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2644/comments",
    "author": "martin-krivosudsky",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-09-08T11:54:55Z",
        "body": "I’ve not done Apollo federation with GraphQL.NET but I’m pretty sure it’s not supported in code-first. See #2564 "
      }
    ]
  },
  {
    "number": 2610,
    "title": "how does the defaultValue of GetArgument work?",
    "created_at": "2021-07-15T12:41:41Z",
    "closed_at": "2021-07-19T10:22:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2610",
    "body": "Hey guys,\r\n\r\nI'm a bit confused about the defaultValue of the GetArgument function.\r\n\r\n`var myArgument = resolveFieldContext.GetArgument(\"myArgument\", string.Empty);`\r\n\r\nI would expect that `myArgument` has an empty string (`\"\"`) as value when no argument is passed. instead the result is `null`. \r\nWhat do I miss here?\r\n\r\n`var myArgument = resolveFieldContext.GetArgument(\"myArgument\") ?? \"\";` works as expected.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2610/comments",
    "author": "thezeronine",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-07-15T15:32:54Z",
        "body": "I'd need to see the exact query.  If the field argument was passed null, then null will be returned.  If the field argument is set to a variable, and the variable was set to null, then null will be returned.  If the field argument was set to a variable, and variable default's value is null, and the variable was not specified, then null will be returned.  If the field argument was completely unspecified, then the field argument's default value will be examined and returned if it is not null.  Only if the field argument was completely unspecified and there is no default value set for the field argument will the default value be taken from GetArgument.  If you simply want null values to be replaced with empty strings, then you want to use the syntax you already mentioned (`?? \"\"`) rather than specifying a default value to GetArgument.\r\n\r\nNote that there is no way to set a field argument's default value to a specific value of null -- in that case null by definition is unspecified within GraphQL.NET."
      },
      {
        "user": "thezeronine",
        "created_at": "2021-07-19T10:22:19Z",
        "body": "Thanks for clarification!"
      }
    ]
  },
  {
    "number": 2609,
    "title": "How to fix error: FuncFieldResolver<Message>?",
    "created_at": "2021-07-14T10:48:33Z",
    "closed_at": "2021-08-15T04:50:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2609",
    "body": "I have a small ASP.NET Core 3.1. server + GraphQL NuGet.\r\nWhen I used GraphQL NuGet v3 - it worked, but after update to the latest v4.5 I cannot compile it\r\n```\r\n        public AuthorSubscription(IAuthor authordetails)\r\n        {\r\n            _author = authordetails;\r\n\r\n            AddField(new EventStreamFieldType\r\n            {\r\n                Name = \"authorAdded\",\r\n                Type = typeof(MessageType),\r\n                Resolver = new FuncFieldResolver<Message>(ResolveAuthor),//<----\r\n                Subscriber = new EventStreamResolver<Message>(Subscribe)//<----\r\n            });\r\n        }\r\n\r\n```\r\n\r\nThere are errors:\r\n error CS1503: Argument 1: cannot convert from 'method group' to 'Func<IResolveFieldContext, Message>'\r\n\r\nHow to fix it?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2609/comments",
    "author": "ZedZipDev",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-07-14T13:31:04Z",
        "body": "Can you post the signature of the `ResolveAuthor` and `Subscribe` methods in your class?  Offhand I do not know why a change would be needed."
      },
      {
        "user": "Shane32",
        "created_at": "2021-08-15T04:50:17Z",
        "body": "Closed due to lack of information.  Please re-open if you can provide additional details."
      }
    ]
  },
  {
    "number": 2594,
    "title": "AutoRegisteringObjectGraphType<> doesnt create default expression resolvers for the auto generated fields?",
    "created_at": "2021-07-08T15:07:17Z",
    "closed_at": "2021-07-14T13:38:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2594",
    "body": "Does AutoRegisteringObjectGraphType<> not create the default expression resolvers for the auto generated fields?\r\nIf not ,then how do we update these fields? \r\n\r\nMy scenario is that I'm creating the corresponding graphtypes at runtime using classes that are dynamically created at run time. I'm having these runtime created graphtypes inherit from AutoRegisteringObjectGraphType<>. I guess that since the resolvers for these fields are missing,graphql is not able to filter these fields from the output. \r\n\r\nIs there a way by which I can programmatically update the expression resolvers for these autogenerated fields after the graphtype has been generated at runtime?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2594/comments",
    "author": "truptivishe-gep",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-07-08T15:30:28Z",
        "body": "You'd probably want to exclude fields that you were going to define manually from the auto-generation process.  You can do so by passing a `params` list of expressions to the `AutoRegisteringObjectGraphType` constructor (the base constructor).  Does that answer your question?"
      },
      {
        "user": "truptivishe-gep",
        "created_at": "2021-07-09T07:01:58Z",
        "body": "Is there no way to have AutoRegisteringObjectGraphType generate the default resolvers?"
      },
      {
        "user": "Shane32",
        "created_at": "2021-07-09T07:19:44Z",
        "body": "I’m not sure what your question is. For the fields it auto creates, yes it creates resolvers for them. "
      },
      {
        "user": "truptivishe-gep",
        "created_at": "2021-07-09T09:20:47Z",
        "body": "The resolvers are not getting created for me when I'm generating the class in the below manner :\r\n\r\nMy main method -\r\n`\r\nType dataModelType = dataModelTypes.GetValueOrDefault(dataModelTypeClassName);\r\nTypeBuilder typeBuilder = CreateClassBuilder(dataModelTypeClassName, dataModelType);\r\nCreateConstructor(typeBuilder);\r\nType type = typeBuilder.CreateType();\r\n`\r\n\r\nOther methods to generate the graphQL type class - \r\n\r\n`\r\n        private TypeBuilder CreateClassBuilder(string className, Type classType)\r\n        {\r\n            TypeBuilder typeBuilder = moduleBuilder.DefineType(className + \"GraphType\"\r\n                                , TypeAttributes.Public |\r\n                                TypeAttributes.Class |\r\n                                TypeAttributes.AutoClass |\r\n                                TypeAttributes.AnsiClass |\r\n                                TypeAttributes.BeforeFieldInit |\r\n                                TypeAttributes.AutoLayout\r\n                                , null);\r\n            typeBuilder.SetParent(typeof(AutoRegisteringObjectGraphType<>).MakeGenericType(classType));\r\n            //typeBuilder.SetParent(typeof(ObjectGraphType<>).MakeGenericType(classType));\r\n            return typeBuilder;\r\n        }\r\n\r\n        private void CreateConstructor(TypeBuilder typeBuilder)\r\n        {\r\n            typeBuilder.DefineDefaultConstructor(MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName);\r\n        }\r\n`\r\n\r\nAfter registering the mapping for these classes in the Schema, when I check the Schma->AllTypes->the fieldtypes generated for these do not contain the resolvers\r\n\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2021-07-09T12:58:59Z",
        "body": "Are you saying that the Resolver property for the field is null? That’s normal. During execution, fields with a null resolver property will resolve the field by matching the field name to a property of the context.Source - which is what the AutoRegisteringObjectGraphType used to create the field to begin with. So it will resolve properly even though the resolver property is null. "
      },
      {
        "user": "truptivishe-gep",
        "created_at": "2021-07-09T13:15:42Z",
        "body": "Ohkay...thanks for explaining! I'm new to graphql so am in the initial stages of exploring things.\r\nMy graphql api isn't filtering the subfields stated in the query and is instead returning all properties of the mapped graph type. Therefore I thought that the issue might be due to the Resolver property for the fields being null.\r\n\r\nThanks again! I might be missing something else then."
      },
      {
        "user": "Shane32",
        "created_at": "2021-07-14T13:38:03Z",
        "body": "Closing this issue.  Please re-open if you have further questions along this line."
      }
    ]
  },
  {
    "number": 2585,
    "title": "Is it possible to monitor Graphql.NET performance via .Net Runtime Metrics in Datadog?",
    "created_at": "2021-07-02T08:16:04Z",
    "closed_at": "2022-02-04T23:37:47Z",
    "labels": [
      "question",
      "performance"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2585",
    "body": "We've successfully tracing Graphql.NET via dd-trace but we want to trace it thru .Net Runtime Metrics. is it possible? ",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2585/comments",
    "author": "jbarbacena",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2021-12-07T23:50:15Z",
        "body": "What is \".Net Runtime Metrics\" ? PerformanceCounters ? EventCounters ?"
      },
      {
        "user": "sungam3r",
        "created_at": "2022-02-04T23:37:47Z",
        "body": "GraphQL.NET support Apollo Tracing, also see `InstrumentFieldsMiddleware`. I closed this issue due to lack of feedback."
      }
    ]
  },
  {
    "number": 2582,
    "title": "Why IDataLoaderResult instead of Task from DataLoader?",
    "created_at": "2021-06-30T09:56:31Z",
    "closed_at": "2021-08-27T12:28:28Z",
    "labels": [
      "question",
      "data loader"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2582",
    "body": "In previous versions (I'm coming from 2.x) the dataloader method 'LoadSync' returned a task. This was nice because that if I needed to make multiple calls the the same dataloader in one field I could just run something like:\r\n\r\n```\r\nawait Task.WhenAll(dataLoadersTasks);\r\n```\r\n\r\nNow with the new IDataLoaderResult I have to chain them with `.Then(...)`. If I want to make many calls to dataloaders that chain would be long. In node/javascript we have moved away from this type of syntax chaining in favor for the async/await stuff.\r\n\r\nIn one of my fields in the gql api I get a list of articleids for which I want to fetch prices for. The batch loaders `LoadAsync` method takes one id as input but now I have a list of ids. Before I just ran `await Task.WhenAll(dataLoadersTasks)` for all these calls to the dataloader. How can I do the same with a list of IDataLoaderResult?\r\n\r\nI also have another problem. I have a interface like:\r\n\r\n```\r\npublic interface IPricingService : ICommerceService\r\n    {\r\n        IDataLoaderResult<Price> GetPrice(string articleId); //Now\r\n        Task<Price> GetPrice(string articleId); //Previously\r\n    }\r\n```\r\n\r\nI have multiple implementations (multiple ecom systems for different markets) of this service. One of them is using a datalaoder and another is not. It depends on the ecom system if there is any need for the dataloader.\r\n\r\nSo now the interface of this service has to return a IDataLoaderResult since the graphql field needs to have the dataloader returned for it to work.\r\n\r\nIs there any way to convert the dataloader to a task so I can batch them and still have the exection strategy trigger the loading at the end of the graphql request so that batch loaders are actually batched.\r\n\r\nI tried the `GetResultAsync` method that returns a task but it also triggers the underlying fetch function so stuff are no longer batched.\r\n\r\nDoes my questions/inputs make any since? :)\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2582/comments",
    "author": "magnusottosson",
    "comments": [
      {
        "user": "magnusottosson",
        "created_at": "2021-06-30T10:05:40Z",
        "body": "I just found this extension. That would solve the \"load many\" instead of chaining issue I guess.\r\n\r\n```\r\n/// <summary>\r\n        /// Asynchronously load data for the provided given keys\r\n        /// </summary>\r\n        /// <param name=\"dataLoader\">The dataloader to use</param>\r\n        /// <param name=\"keys\">Keys to use for loading data</param>\r\n        /// <returns>\r\n        /// A task that will complete when the DataLoader has been dispatched,\r\n        /// or a completed task if the result is already cached.\r\n        /// </returns>\r\n        public static IDataLoaderResult<T[]> LoadAsync<TKey, T>(this IDataLoader<TKey, T> dataLoader, IEnumerable<TKey> keys)\r\n        {\r\n            var results = new List<IDataLoaderResult<T>>();\r\n\r\n            foreach (var key in keys)\r\n            {\r\n                results.Add(dataLoader.LoadAsync(key));\r\n            }\r\n\r\n            return new DataLoaderResultWhenAll<T>(results);\r\n        }\r\n\r\n        private class DataLoaderResultWhenAll<T> : IDataLoaderResult<T[]>\r\n        {\r\n            private readonly IEnumerable<IDataLoaderResult<T>> _dataLoaderResults;\r\n\r\n            public DataLoaderResultWhenAll(IEnumerable<IDataLoaderResult<T>> dataLoaderResults)\r\n            {\r\n                _dataLoaderResults = dataLoaderResults ?? throw new ArgumentNullException(nameof(dataLoaderResults));\r\n            }\r\n\r\n            public Task<T[]> GetResultAsync(CancellationToken cancellationToken = default)\r\n                => Task.WhenAll(_dataLoaderResults.Select(x => x.GetResultAsync(cancellationToken)));\r\n\r\n            async Task<object> IDataLoaderResult.GetResultAsync(CancellationToken cancellationToken)\r\n                => await GetResultAsync(cancellationToken).ConfigureAwait(false);\r\n        }\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2021-06-30T14:40:08Z",
        "body": "I wrote the new data loaders and can explain why the new data loaders are designed the way they are, and provide some possible solutions.\r\n\r\nIn short, the task-based data loaders were insufficient because the execution was immediately awaited upon within the execution strategy.  To prevent the data loader from executing right away, the data loader would be paused until triggered by a document execution listener.  But this meant that a deadlock would always occur in either of these two scenarios:\r\n\r\n1. A field resolver awaits a data loader to retrieve information and then awaits another data loader.\r\n2. Within the field resolver, an asynchronous task is awaited prior to awaiting the data loader.\r\n\r\nThe prior design also meant:\r\n\r\n- It was incompatible with serial execution strategies, as the execution strategy knew nothing of data loaders and would execute each field resolver sequentially.  Support for the serial execution strategy is very important to anyone using Entity Framework as the underlying ORM (although there are workarounds).\r\n- It did not work within mutations (since mutations run with a serial execution strategy by default)\r\n- It was very slow (seen when loading 100s of data loaders in one execution).\r\n- It had an issue with federation.\r\n- A canceled GraphQL request could cause a pending data loader node to hang.\r\n\r\nAll of these issues have been solved with the new design, even though it may not be as elegant to use.  (See PR #1511)\r\n\r\nWith the new design, `IDataLoaderResult<>` is simply a thin wrapper around a delegate that returns a `Task<>` so that the execution strategy can identify that the result should not be executed immediately, and instead run and await the data loader after all other code has been executed.\r\n\r\nYou can easily \"convert\" a data loader result to a `Task<>` by calling `IDataLoaderResult.GetResultAsync<>`.  It will execute immediately of course, as you already have seen.  You can also turn any async delegate \"into a dataloader\" (so it will run at the appropriate time during the execution strategy) by calling `new SimpleDataLoader(asyncDelegate)`.  Then the delegate will be called at the correct time.  You cannot \"turn a Task into a data loader\".  The Task has already begun; it cannot be queued to run later.\r\n\r\nI think the idea to grasp here is that .NET always intended a `Task` to represent an execution that has already started and is either completed or pending completion.  Not one that has been 'paused' or 'not started'.  And delegates were designed to represent an execution that has not occurred yet.  The new design matches the .NET philosophy (with a thin wrapper around the delegate), rather than trying to get Tasks to do something they were never designed for.  I do grant you that the old design was easier to use -- but only in the specific scenarios supported by the framework.\r\n\r\nYou can certainly write your own code within v3/v4 to 'pause' a Task until triggered by a `DocumentExecutionListener`'s `OnBeforeExecutionStepAwaitedAsync` step, just as occurred in v2, or even copy the entire previous DataLoader v2 implementation in to v3/v4 -- but `OnBeforeExecutionStepAwaitedAsync` is deprecated and is planned to be removed in v5.\r\n\r\nLet me know if you have a specific scenario for which you would like a suggestion or have a question."
      },
      {
        "user": "Shane32",
        "created_at": "2021-06-30T14:52:50Z",
        "body": "We have also moved all the data loader code to its own library; you can write your own if you have specific needs.  The only data-loader specific functionality within the main library is to look for `IDataLoaderResult` objects returned from field resolvers, and execute `GetResultAsync` after all other nodes have executed.  And the interface is only this:\r\n\r\n```cs\r\n    public interface IDataLoaderResult\r\n    {\r\n        Task<object> GetResultAsync(CancellationToken cancellationToken = default);\r\n    }\r\n```\r\nEverything else is built on top of that.  And, until v5, the old v2 data loaders would work (to the extent they ever worked) within v3/v4 if you copy the code over."
      },
      {
        "user": "Shane32",
        "created_at": "2021-07-07T12:49:37Z",
        "body": "@magnusottosson Do you have any further questions?"
      },
      {
        "user": "Shane32",
        "created_at": "2021-07-14T13:44:23Z",
        "body": "Please re-open this issue if you have further questions."
      },
      {
        "user": "magnusottosson",
        "created_at": "2021-08-18T08:59:07Z",
        "body": "Hi, thanks for the very detailed explanation. I think that my problem is that I have the dataloader code a bit seperated from the graphl code.\r\n\r\nSo its like:\r\n\r\nthe graphql filed `price` tries to fetch prices, further down in a ´PriceService` it looks as some config code and depending on the settings the code goes into a price service implementation that wants to batch load prices from another system. After the price if fetched the logic contiues and it performs some formatting etc... so I guess I will have to put all of this code within the batch loader right?\r\n\r\nSo the field resolver doesnt actually know that it needs to use a dataloader. If I create a `SimpleDataLoader` instance I need to return that in the field resolver otherwise it will never be triggered right?"
      },
      {
        "user": "Shane32",
        "created_at": "2021-08-18T15:58:14Z",
        "body": "> so I guess I will have to put all of this code within the batch loader right?\r\n\r\nI think so.\r\n\r\n> If I create a SimpleDataLoader instance I need to return that in the field resolver otherwise it will never be triggered right?\r\n\r\nRight\r\n\r\nThe obvious suggestion is to change the signature of the method in `PriceService` to return a `IDataLoaderResult<>` (or `Task<IDataLoaderResult<>>`).  Any code that executes after a data loader call needs to be chained with `Then` or similar.  I understand this is probably a pain if you have multiple layers of business logic, but I don't have a better suggestion.  At that point, you have two choices for your `PriceService` implementation:\r\n\r\n1. If the data is immediately available, such as if it's in a cache, return a `DataLoaderResult<>` containing the data.  If not, return an actual data loader that will retrieve the data.  Keep in mind that the remainder of the method call will not run immediately, but will execute after any pending calls have completed, in parallel with any other data loader executions.  (Or in series for a serial execution strategy.)\r\n2. Move all the logic into the data loader.  Within the data loader you can return results for data that is immediately available (such as cached data), and make your DB call or similar for the remaining keys.  All results will need to wait for the data loader to complete, even if the data was immediately available.  (Of course, if all data is immediately available, no DB call would exist and there would be no additional wait.)\r\n\r\nYou do have another option.  You can return type `object` from your service, which can be an immediate value (such as 23.44) or a data loader like `IDataLoaderResult<float>`.  This would be a real pain to chain with other calls, however; I wouldn't recommend it.\r\n\r\nFinally, you can always import the GraphQL.NET 2.x data loader code and use it with very few changes.  Even if the `OnBeforeExecutionStepAwaitedAsync` method is removed in GraphQL.NET 5.x, you could copy the applicable execution strategy class and add the necessary code without much effort to keep the old data loader design operating.  It may sound like a lot of hacking, but going forward you'd really only need to maintain the duplicate `ParallelExecutionStrategy` (or `SerialExecutionStrategy`) from the main project, which is only about 100 lines of code; the rest would then be your own data loader implementation.  But as of 4.x you would not need to modify the execution strategy."
      },
      {
        "user": "magnusottosson",
        "created_at": "2021-08-27T12:28:28Z",
        "body": "Thanks, we will change our interface so that we are returnin a IDataLoaderResult instead of a Task. A bit less generic but it will work. Thank you so much for you help!"
      }
    ]
  },
  {
    "number": 2570,
    "title": "How to set default object in each request pair in certain conditions?",
    "created_at": "2021-06-07T23:58:30Z",
    "closed_at": "2021-06-08T01:48:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2570",
    "body": "I am using batch data loader to group up a number of requests and return them to each of the field resolvers.\r\n\r\nBelow is what I have and it works fine -\r\n\r\n    protected override async Task FetchAsync(IEnumerable<DataLoaderPair<IRequest, object>> list, CancellationToken cancellationToken)\r\n    {\r\n         //1. find the different types of requests\r\n         var contentRequestPair = list.SingleOrDefault(x => x.Key is ContentRequest);\r\n         var contentRequest = (ContentRequest)contentRequestPair?.Key;\r\n\r\n         var findRequestPair = list.SingleOrDefault(x => x.Key is FindRequest);\r\n         var findRequest = (FindRequest)findRequestPair?.Key;\r\n\r\n         //2. initialize request\r\n         var processRequest = new ProcessRequest {\r\n             ....\r\n         };\r\n\r\n         // 3. execute request\r\n         var processResponse = await ExecuteProcessRequestAsync(processRequest, cancellationToken);\r\n         int statusCode = processResponse.ResponseCode;\r\n\r\n         // 4. set the results\r\n         if (contentRequest != null)\r\n         {\r\n             // create the data model for the graph\r\n             var contentResponse = processResponse.GetContentResponse;\r\n             if(contentResponse != null) {\r\n                contentRequestPair.SetResult(contentResponse);\r\n             }\r\n             else {\r\n             // this doesn't work\r\n              contentRequestPair.SetResult(new ContentResponse());\r\n             }\r\n         }\r\n         if (findRequest != null)\r\n         {\r\n             // create the data model for the graph\r\n             var findResponse = processResponse.GetFindResponse;\r\n             if(findResponse != null) {\r\n                findRequestPair.SetResult(findResponse);\r\n             }\r\n             else {\r\n              // but this works fine\r\n              findRequestPair.SetResult(new new List<FindResponse>()());\r\n             }\r\n         }\r\n    }\r\n\r\nIf the status code is 204, then I want to set default object in each of the requestpair back instead of using the corresponding objects from `processResponse` variable. For some weird reason when I set like this then my graph type throws exception as - `Error trying to resolve field 'clientId'.\\n ---> System.NullReferenceException: Object reference not set to an instance of an object`\r\n\r\n    contentRequestPair.SetResult(new ContentResponse());\r\n\r\n**ContentResponseType class**\r\n\r\n    public class ContentResponseType : ObjectGraphType<ContentResponse>\r\n    {\r\n          public ContentResponseType()\r\n          {\r\n              Name = \"ContentResponse\";\r\n              Field(\"clientId\", x.Holder.Data.ClientId.ToString());\r\n              ....\r\n          }\r\n    }\r\n\r\nBut this works fine for `findRequestPair` object.\r\n\r\n    public class FindResponseType : ObjectGraphType<FindResponse>\r\n    {\r\n        public FindResponseType()\r\n        {\r\n            Name = \"FindingResponse\";\r\n            Field(\"title\", x => x.Group.Label);\r\n            Field(\"type\", x => x.Group.Type);\r\n        }\r\n    }",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2570/comments",
    "author": "TechGeeky",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-06-08T00:39:57Z",
        "body": "By executing `contentRequestPair.SetResult(new ContentResponse());`, now when `clientId` attempts to resolve, it looks at a new `ContentResponse` object and tries to evaluate `x.Holder.Data.ClientId.ToString()`.  Most likely, `Holder` is the default value of `null`, so evaluating `x.Holder.Data` results in a null reference exception.  I suggest one of two approaches:\r\n\r\n1. Use `contentRequestPair.SetResult(null);`.  This will cause a `null` for the entire object graph to be returned and is probably the correct approach.  Then `clientId` will not attempt to be resolved at all.  If the graph type for the object is a non-null graph type then you may get an error due to a null being returned where it is not allowed.  Easiest to just try and see if the results are what you expect.\r\n\r\n2. Use `Field(\"clientId\", x => x.Holder?.Data?.ClientId?.ToString());`.  This will cause a null to be returned for `clientId` in your scenario.\r\n"
      },
      {
        "user": "TechGeeky",
        "created_at": "2021-06-08T00:49:26Z",
        "body": "I wasn't aware of this `contentRequestPair.SetResult(null);`. Thanks for letting me know. And for second point I may need to make it nullable true then right?"
      },
      {
        "user": "Shane32",
        "created_at": "2021-06-08T00:51:20Z",
        "body": "yes, but not in the Field(\"clientId\"...) definition -- rather in the Field(...) that queues up the dataloader."
      },
      {
        "user": "TechGeeky",
        "created_at": "2021-06-08T00:59:01Z",
        "body": "You sure on your point 2 I don't need to make this? If clientId can be null then I need to make this right?\r\n\r\n    Field(\"clientId\", x => x.Holder?.Data?.ClientId?.ToString(), true)\r\n\r\nOr something I need to do here?\r\n\r\n```\r\nFieldAsync<ListGraphType<ContentResponseType>>(\r\n            \"contentRequest\",\r\n            arguments: new QueryArguments(\r\n                    new QueryArgument<NonNullGraphType<IntGraphType>>\r\n                    {\r\n                        Name = \"clientId\",\r\n                        Description = \"Client Id of the request\"\r\n\r\n                    },\r\n                    new QueryArgument<ListGraphType<FilterType>>\r\n                    {\r\n                        Name = \"filters\",\r\n                        Description = \"Filters\"\r\n                    },\r\n                    new QueryArgument<StringGraphType>\r\n                    {\r\n                        Name = \"clientKey\",\r\n                        DefaultValue = \"abc\",\r\n                        Description = \"some stuff\"\r\n                    }\r\n                ),\r\n\r\n            resolve: async context =>\r\n            {\r\n                var dataLoader = context.RequestServices.GetRequiredService<MyDataRequestor>();\r\n                var request = new ContentRequest {\r\n                    ClientId = context.GetArgument<int>(\"clientId\"),\r\n                    Filters = context.GetArgument<List<Filter>>(\"filters\"),\r\n                    ClientKey = context.GetArgument<string>(\"clientKey\"),\r\n                };\r\n\r\n                // after being processed by the dataloader, will return a List<ContentResponse>\r\n                return dataLoader.LoadAsync(request);\r\n            }\r\n        );\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2021-06-08T01:00:49Z",
        "body": "You should not need to make a change in either area.  The second area is already defined as a nullable list of nullable objects. See this line of code:\r\n\r\n```\r\nFieldAsync<ListGraphType<ContentResponseType>>(\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2021-06-08T01:02:48Z",
        "body": "Unless of course you expect this to run and contain a null clientId string:\r\n\r\n```\r\n         var contentResponse = processResponse.GetContentResponse;\r\n         if(contentResponse != null) {\r\n            contentRequestPair.SetResult(contentResponse);\r\n            // ----- if contentResponse.Holder.Data.ClientId still might be null here, then yes you need the change -----\r\n         }\r\n```"
      }
    ]
  },
  {
    "number": 2506,
    "title": "In FieldMiddleware how to access FileldDefinitions (and metadata) of all fields in a query?",
    "created_at": "2021-04-16T05:43:09Z",
    "closed_at": "2021-04-17T15:08:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2506",
    "body": "## Summary\r\n\r\nMy use case is that on root query/mutation level I need to traverse all selected field types and access their metadata before initial/root resolver is called. For example for query `query { a { b { c, d } } }` before executing resolver of `a` I need to gather metadata from `a`, `b`, `c` and `d` fields.\r\n\r\n## Relevant information\r\n\r\n```c#\r\nusing System;\r\nusing System.Linq;\r\nusing System.Threading.Tasks;\r\nusing GraphQL;\r\nusing GraphQL.Instrumentation;\r\nusing GraphQL.Language.AST;\r\n\r\nnamespace MyProject\r\n{\r\n    public class MyMiddleware : IFieldMiddleware\r\n    {\r\n        public async Task<object> Resolve(IResolveFieldContext context, FieldMiddlewareDelegate next)\r\n        {\r\n            if (context.Parent == null)\r\n            {\r\n                // context.FieldDefinition.Metadata; // <- here I can access root field metadata (\"a\" in example)\r\n                var b = context.SubFields[\"b\"];\r\n                \r\n                Console.WriteLine(b.Name); // prints \"b\"\r\n                \r\n                // but how to access FieldDefinition / metadata of \"b\"?\r\n            }\r\n            return await next(context);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2506/comments",
    "author": "alekbarszczewski",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2021-04-16T10:34:28Z",
        "body": "Maybe to use `context.Schema` to get all requested fields and their metadata ?"
      },
      {
        "user": "alekbarszczewski",
        "created_at": "2021-04-17T15:08:09Z",
        "body": "Thanks, using `context.Schema` I was able to get all fields metadata:\r\n\r\n```c#\r\npublic class AuthContextResolver : IFieldMiddleware\r\n    {\r\n        public async Task<object> Resolve(IResolveFieldContext context, FieldMiddlewareDelegate next)\r\n        {\r\n            if (context.Parent == null)\r\n            {\r\n                VisitFields(context.ParentType, context.FieldAst, (fieldType, field) =>\r\n                {\r\n                    // you can access fieldType.Metadata here\r\n                    return true;\r\n                });\r\n            }\r\n            return await next(context);\r\n        }\r\n\r\n        private void VisitFields(IObjectGraphType objectType, Field field, Func<FieldType, Field, bool> visitor)\r\n        {\r\n            var fieldType = objectType.Fields.First(type => type.Name == field.Name);\r\n            if (!visitor(fieldType, field))\r\n            {\r\n                return;\r\n            }\r\n            foreach (var selection in field.SelectionSet.Selections)\r\n            {\r\n                if (selection is Field && fieldType.ResolvedType is IObjectGraphType)\r\n                {\r\n                    VisitFields((IObjectGraphType) fieldType.ResolvedType, (Field) selection, visitor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n```"
      }
    ]
  },
  {
    "number": 2503,
    "title": "Using output type in the response of mutations",
    "created_at": "2021-04-15T06:06:26Z",
    "closed_at": "2021-04-15T07:28:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2503",
    "body": "## Summary\r\nI want to send a field of `ObjectGraph` type in the response of a mutation. I am using apollo GraphQL on the client-side. Returning this way helps with the caching.\r\nI tried to add a field for `ItemGraph` inside `ItemInputGraph`.  But, it will throw an exception since `ItemInputGraph` is of `IInputObjectGraphType` type. Is it possible to add this only at the response of a mutation?\r\n\r\n`mutation MarkAsCompleted($item:ItemInputGraph!){\r\n    markAsCompleted(item: $item){\r\n        success\r\n        item { # this should be the same output type used for querying item\r\n            id\r\n            name\r\n            type\r\n            isCompleted\r\n            completedOn\r\n            completedBy\r\n        }\r\n    }\r\n}`\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2503/comments",
    "author": "athomasec",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-04-15T06:22:19Z",
        "body": "Input types and output types are distinct according to the GraphQL specification. An input type cannot be used for returning data and an output type cannot be used for a field argument. GraphQL.NET enforces this rule.\r\n\r\nYou can however create matching input and output types that map to the same fields of the same type of object. \r\n\r\nThere is also no issue having the item field of the mutation result match the same type as a query for the item. You might simply be adding the field to the wrong graph - rather than adding it to the input graph, you want to add it to the return type of the mutation graph. "
      },
      {
        "user": "athomasec",
        "created_at": "2021-04-15T07:28:48Z",
        "body": "> There is also no issue having the item field of the mutation result match the same type as a query for the item. You might simply be adding the field to the wrong graph - rather than adding it to the input graph, you want to add it to the return type of the mutation graph.\r\n\r\nThis makes sense. Changing the return type did it for me."
      }
    ]
  },
  {
    "number": 2499,
    "title": "Test Graphql types to ViewModels mapping",
    "created_at": "2021-04-12T08:19:55Z",
    "closed_at": "2021-04-20T04:53:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2499",
    "body": "## Summary\r\nWould you mind suggesting ways I can unit test view graph types to view models mapping? Maybe it's overkill, and I don't need to? I really like how easy it is to unit test auto mapper models.\r\n\r\n## Relevant information\r\n\r\nThe way I validate AutoMapper:\r\n```c#\r\npublic MappingTests() {\r\n            _configuration = new MapperConfiguration(cfg => { cfg.AddProfile<MappingProfile>(); });\r\n\r\n            _mapper = _configuration.CreateMapper();\r\n        }\r\n\r\n        [Test]\r\n        public void ShouldHaveValidConfiguration() {\r\n            _configuration.AssertConfigurationIsValid();\r\n        }\r\n\r\n        /// <summary>\r\n        /// Tests all implementations of <seealso cref=\"IMapFrom{TSource}\"/>\r\n        /// </summary>\r\n        [Test]\r\n        public void ShouldSupportMappingFromSourceToDestination() {\r\n            var mapFromTypes = typeof(DependencyInjection).Assembly.GetExportedTypes()\r\n                .Where(t => t.HasParentOfType(typeof(IMapFrom<>), true));\r\n\r\n            foreach (var destinationType in mapFromTypes) {\r\n                var sourceType = destinationType.GetParentOfType(typeof(IMapFrom<>), true)\r\n                    !.GetGenericArguments()[0];\r\n                var instance = GetInstanceOf(sourceType);\r\n                _mapper.Map(instance, sourceType, destinationType);\r\n            }\r\n        }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2499/comments",
    "author": "Vidzhel",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2021-04-14T12:26:13Z",
        "body": "What do you want to test? GraphType does not have to accurately have the same fields/properties as ViewModel, if you mean Source object, passed in resolver."
      },
      {
        "user": "Vidzhel",
        "created_at": "2021-04-18T15:02:21Z",
        "body": "Heah, I understand, but if we exclude fields that use resolver, we end up with these that just convert values from GraphType DTOs to other classes' fields and in the case when you have to manually specify a field type (not to mention a field name), it becomes error-prone. \r\n\r\nProbably one possible solution to my problem is just integration testing, which I'm rewriting right now to use GraphQl queries instead of constructing commands passing GraphQl layer (I use MediatR).\r\n\r\nAnyway, I haven't seen any material regarding the subject, so maybe the thread will help others"
      },
      {
        "user": "sungam3r",
        "created_at": "2021-04-19T10:47:16Z",
        "body": "I think that it's more important to test public GraphQL API than some internal mappings. GraphQL has introspection capability so your test client could verify actual results. "
      }
    ]
  },
  {
    "number": 2496,
    "title": "How to create single request object from multiple queries input arguments?",
    "created_at": "2021-04-10T18:22:46Z",
    "closed_at": "2022-02-04T23:33:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2496",
    "body": "I am working on migrating legacy use cases to our new `GraphQL` service. \r\n\r\n- Internally all our requests gets mapped to single `ProcessRequest` object which holds all input arguments being passed from Schema. \r\n- Then we pass this `ProcessRequest` object to underlying methods which in turn returns back `ProcessResponse` object which has response for that request.\r\n\r\nBelow is `ProcessRequest` class:\r\n\r\n    public interface IProcess\r\n    {\r\n        int ClientId { get; set; }\r\n        int LanguageId { get; set; }\r\n        int CustomerId { get; set; }\r\n    }\r\n\r\n    public interface IData\r\n    {\r\n        IList<Filter> Filters { get; set; }\r\n        KeywordsTemplate KeywordsTemplate { get; set; }\r\n    }\r\n\r\n    public class Filter\r\n    {\r\n        public string Key { get; set; }\r\n        public int Value { get; set; }\r\n    }\r\n\r\n    public class KeywordsTemplate\r\n    {\r\n        public string Query { get; set; }\r\n        public string UserQuery { get; set; }\r\n    }\r\n\r\n    public class ClientType\r\n    {\r\n        public string ClientKey { get; set; }\r\n    }\r\n\r\n    public class Shop\r\n    {\r\n        public double CartAmount { get; set; }\r\n        public double PromoAmount { get; set; }\r\n        public IList<int> ClientIds { get; set; }\r\n    }\r\n\r\n    public class ListingRequest\r\n    {\r\n        public IList<Filter> Filters { get; set; }\r\n        public int ClientNumber { get; set; }\r\n        public string PotType { get; set; }\r\n        public IList<int> ClientIds { get; set; }\r\n    }\r\n\r\n    public class ListingsRequest\r\n    {\r\n        public IList<ListingRequest> Listings { get; set; }\r\n    }\r\n\r\n    public class ProcessRequest : IData, IProcess\r\n    {\r\n        public DetailsRequest DetailsRequest { get; set; }\r\n        public ClientType ClientType { get; set; }\r\n        public ListingsRequest ListingsRequest { get; set; }\r\n        public ProtoRequest ProtoRequest { get; set; }\r\n\r\n        public IList<Filter> Filters { get; set; }\r\n        public KeywordsTemplate KeywordsTemplate { get; set; }\r\n        public int ClientId { get; set; }\r\n    }\r\n\r\nFor my below `GraphQL` query - I map input arguments to my `ProcessRequest` class and then call corresponding methods to get `ProcessResponse` object. Then I created a corresponding model `LandingGroup` from `ProcessResponse` class which exactly matches with what I need in `GraphQL` response for my below `contentRequest` query and then I use that in my `ContentResponseType` class to get what I need.\r\n\r\n    {\r\n      contentRequest(clientId: 123, filters: [{key: \"abc\", value: \"98\"}], clientKey: \"process\") {\r\n        title\r\n        id\r\n        name\r\n      }\r\n    }\r\n\r\nBelow is how I am using my Query -\r\n\r\n    public class TitanQuery : ObjectGraphType<object>\r\n    {\r\n        public TitanQuery(....)\r\n        {\r\n            Name = \"Query\";\r\n\r\n            FieldAsync<ListGraphType<ContentResponseType>>(\r\n                \"contentRequest\",\r\n                arguments: new QueryArguments(\r\n                        new QueryArgument<NonNullGraphType<IntGraphType>>\r\n                        {\r\n                            Name = \"clientId\",\r\n                            Description = \"Client Id of the request\"\r\n\r\n                        },\r\n                        new QueryArgument<ListGraphType<FilterType>>\r\n                        {\r\n                            Name = \"filters\",\r\n                            Description = \"Filters\"\r\n                        },\r\n                        new QueryArgument<StringGraphType>\r\n                        {\r\n                            Name = \"clientKey\",\r\n                            DefaultValue = \"abc\",\r\n                            Description = \"some stuff\"\r\n                        }\r\n                    ),\r\n\r\n                resolve: async context =>\r\n                {\r\n                    var clientId = context.GetArgument<int>(\"clientId\");\r\n                    var filters = context.GetArgument<List<Filter>>(\"filters\");\r\n                    var clientKey = context.GetArgument<string>(\"clientKey\");\r\n\r\n                    // mapping all the arguments to ProcessRequest class\r\n                    ProcessRequest processRequest = new ProcessRequest()\r\n                    {\r\n                        ClientId = clientId,\r\n                        Filters = filters,\r\n                        ClientType = new ClientType()\r\n                        {\r\n                            ClientKey = clientKey\r\n                        },\r\n                        ProtoRequest = new ProtoRequest()\r\n                    };\r\n\r\n                    // below line returns 'ProcessResponse' object by using 'processRequest' object\r\n                    var processResponse = await metadataService.ProcessData(processRequest);\r\n\r\n                    var dataGroups = processResponse.LandingResponse.DataGroups.Select(dataGroup => new LandingGroup\r\n                    {\r\n                        DataGroup = dataGroup,\r\n                        TileContext = processResponse.TileContext\r\n                    });\r\n\r\n                    return dataGroups;\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n**Problem Statement**\r\n\r\nEverything works fine for my above single schema use case. Now I have a very different use case with multiple schemas as shown below. I am not able to figure out on how to do it or whether it is even possible to do it? As you can see below I have three different schemas. \r\n\r\n- All the input arguments from below queries maps to single `ProcessRequest` object. \r\n- And then I get single `ProcessResponse` object back from `ProcessRequest` object like the same old way as shown above in the `TitanQuery` class.\r\n- All the GraphQL response fields for each schema is already there in `ProcessResponse` object so I need to find a way to return all those fields back to `GraphQL` response for each query.\r\n- `clientId`, `filters` will be there in all the schemas with same values. They will map to corresponding field in `ProcessRequest` class.\r\n\r\nBelow is my query with multiple schemas:\r\n\r\n    {\r\n      contentRequest(clientId: 123, filters: [{key: \"hello\", value: \"98\"}], clientKey: \"process\") {\r\n        title\r\n        id\r\n        name\r\n      }\r\n      find(queryString: \"\", filters: [{key: \"hello\", value: \"98\"}], clientId: 1234) {\r\n        metricx {\r\n          name\r\n          key\r\n        }\r\n        prodCount\r\n      }\r\n      itemListings(pots: [{potType: \"KITE_1\", filters: [{key: \"c\", value: \"1341\"}]}, {potType: \"KITE_2\", filters: [{key: \"c\", value: \"9812\"}]}], filters: [{key: \"hello\", value: \"98\"}], clientId: 1234, clientKey: \"process\") {\r\n        potType\r\n        productAlgo\r\n        count\r\n        listingEndpoint\r\n      }\r\n    }\r\n\r\nNow my question is how can I make single `ProcessRequest` object by extracting input arguments from all my above queries? And then from single `ProcessResponse` object I need to extract all those fields which each of my query needs in `GraphQL` response. Also I am not sure if we can have different models from `ProcessResponse` object for different combinations of schemas and use them?\r\n\r\n**Note:**\r\n\r\n- I have simplified my response fields for each query to make it easier for understanding but in general they are complicated with lot of fields but all of those fields for each query are part of `ProcessResponse` object only.\r\n- Also this is our legacy use case which we are migrating to our new `GraphQL` service and that legacy service passes queries in that format as of now so we are trying to follow the same format if we can.\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2496/comments",
    "author": "TechGeeky",
    "comments": [
      {
        "user": "TechGeeky",
        "created_at": "2021-04-11T04:53:04Z",
        "body": "@Shane32 Interested in hearing your thoughts to see if this is possible to achieve it?"
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-11T16:07:00Z",
        "body": "Sure it is possible.  I have something similar in my own implementation.\r\n\r\nFor the sake of discussion, and since it will be easier to implement, let's add a layer to the query:\r\n\r\n```gql\r\n{\r\n  multipleQueryRequest {\r\n    contentRequest(clientId: 123, filters: [{key: \"hello\", value: \"98\"}], clientKey: \"process\") {\r\n      title\r\n      id\r\n      name\r\n    }\r\n    find(queryString: \"\", filters: [{key: \"hello\", value: \"98\"}], clientId: 1234) {\r\n      metricx {\r\n        name\r\n        key\r\n      }\r\n      prodCount\r\n    }\r\n    itemListings(pots: [{potType: \"KITE_1\", filters: [{key: \"c\", value: \"1341\"}]}, {potType: \"KITE_2\", filters: [{key: \"c\", value: \"9812\"}]}], filters: [{key: \"hello\", value: \"98\"}], clientId: 1234, clientKey: \"process\") {\r\n      potType\r\n      productAlgo\r\n      count\r\n      listingEndpoint\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThen you need to write code in the resolver method of `multipleQueryRequest` to examine all of the requested child fields and formulate a response.  The child graph objects then just pull from their source objects, ignoring the arguments passed to them. \r\n It ain't pretty, but it's possible.  I've written a sample to demonstrate:\r\n\r\n```cs\r\n    public class Test123Child\r\n    {\r\n        public int Child1a { get; set; }\r\n    }\r\n\r\n    public class Test123ChildGraphType : ObjectGraphType<Test123Child>\r\n    {\r\n        public Test123ChildGraphType()\r\n        {\r\n            Field(x => x.Child1a);\r\n        }\r\n    }\r\n    public class Test123\r\n    {\r\n        public Test123Child Child1 { get; set; }\r\n        public Test123Child Child2 { get; set; }\r\n    }\r\n    public class Test123GraphType : ObjectGraphType<Test123>\r\n    {\r\n        public Test123GraphType()\r\n        {\r\n            Field<Test123ChildGraphType, Test123Child>(\"Child1\")\r\n                .Argument<IntGraphType>(\"arg\");\r\n            Field<Test123ChildGraphType, Test123Child>(\"Child2\")\r\n                .Argument<IntGraphType>(\"arg\");\r\n        }\r\n    }\r\n    public class MyQuery : ObjectGraphType\r\n    {\r\n        public MyQuery()\r\n        {\r\n            Field<Test123GraphType>(\r\n                \"test123\",\r\n                resolve: ctx =>\r\n                {\r\n                    var thisGraphType = (Test123GraphType)ctx.FieldDefinition.ResolvedType.GetNamedType();\r\n\r\n                    var test123 = new Test123();\r\n                    var children = ctx.SubFields;\r\n                    if (children.ContainsKey(\"child1\"))\r\n                    {\r\n                        var child = children[\"child1\"];\r\n                        var args = thisGraphType.GetField(\"child1\").Arguments;\r\n                        var arguments = GraphQL.Execution.ExecutionHelper.GetArgumentValues(args, child.Arguments, ctx.Variables);\r\n                        var val = arguments.TryGetValue(\"arg\", out var argumentValue) ? (int)(argumentValue.Value ?? 0) : 0;\r\n                        test123.Child1 = new Test123Child { Child1a = val };\r\n                    }\r\n                    if (children.ContainsKey(\"child2\"))\r\n                    {\r\n                        var child = children[\"child2\"];\r\n                        var args = thisGraphType.GetField(\"child2\").Arguments;\r\n                        var arguments = GraphQL.Execution.ExecutionHelper.GetArgumentValues(args, child.Arguments, ctx.Variables);\r\n                        var val = arguments.TryGetValue(\"arg\", out var argumentValue) ? (int)(argumentValue.Value ?? 0) : 0;\r\n                        test123.Child2 = new Test123Child { Child1a = val };\r\n                    }\r\n                    return test123;\r\n                });\r\n        }\r\n    }\r\n\r\n        [Fact]\r\n        public void RunTest()\r\n        {\r\n            var queryString = \"query($arg: Int! = 2, $arg2: Int! = 3) { test123 { child1(arg: $arg) { child1a } child2(arg: $arg2) { child1a } } }\";\r\n            var expectedAnswer = @\"{ \"\"test123\"\": { \"\"child1\"\": { \"\"child1a\"\": 2 }, \"\"child2\"\": { \"\"child1a\"\": 3 } } }\";\r\n            AssertQuerySuccess(queryString, expectedAnswer, null);\r\n        }\r\n```\r\n\r\nAs you can see, most of the helper methods are unavailable to you because there is no `IResolveFieldContext` instance for the child fields.  Moreover, trying to examine the children of those children is still harder, because `SubFields` is not available.  And this implementation does not handle requests with aliases properly.  For instance, this request is entirely valid:\r\n\r\n```gql\r\n{\r\n  multipleQueryRequest {\r\n    hello: contentRequest(clientId: 123, filters: [{key: \"hello\", value: \"98\"}], clientKey: \"process\") {\r\n      title\r\n      id\r\n      name\r\n    }\r\n    widget: contentRequest(clientId: 123, filters: [{key: \"widget\", value: \"98\"}], clientKey: \"process\") {\r\n      title\r\n      id\r\n      name\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nBut my sample code does not properly handle this request.  To properly handle this request also, you'd need to change the `Test123` class into a dictionary and store values into it based on the alias.  Then in the resolver of the child, it would need to pull the child object from the source (a dictionary), using the field alias as the dictionary key.  Finally, I didn't check to see if my sample works properly for fragments."
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-11T16:12:35Z",
        "body": "Is this issue related to or a duplicate of #2464 or #2465 @TechGeeky ?"
      },
      {
        "user": "TechGeeky",
        "created_at": "2021-04-11T16:17:09Z",
        "body": "I think it will be duplicate of #2464 but we can close both of those for now. This is the main thread where I am working as of now.\r\n\r\nReading your answer trying to understand on how this will fit with my example in the question."
      },
      {
        "user": "TechGeeky",
        "created_at": "2021-04-12T01:15:11Z",
        "body": "@Shane32 Do we really need to add layer to the request like `multipleQueryRequest` you added? In my scenario I can have single query or multiple queries in the request depending on the use case as it's not fixed. \r\n\r\nOur customers can call us by passing single query in the request for some use case or multiple queries in the request for some other use case and I need to build `ProcessRequest` object accordingly so is there any way to do this without using any root layer like `multipleQueryRequest`? "
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-12T01:25:14Z",
        "body": "Well sure you can write your own document executer implementation and examine the document before it calls the execution strategy. Then set the root object on the execution context before calling the execution strategy, so the source object is set in the context of the root query object. \r\n\r\nOf course if you keep the extra layer that doesn’t mean it wouldn’t work for a single request."
      },
      {
        "user": "TechGeeky",
        "created_at": "2021-04-12T01:39:22Z",
        "body": "Yeah it will work for a single request for sure. The reason I was asking is because as of now our customers call our **old service** like this for single query request - \r\n\r\n    {\r\n      contentRequest(clientId: 123, filters: [{key: \"hello\", value: \"98\"}], clientKey: \"process\") {\r\n        title\r\n        id\r\n        name\r\n      }\r\n    }\r\n\r\nor like this for multiple query request -\r\n\r\n    {\r\n      contentRequest(clientId: 123, filters: [{key: \"hello\", value: \"98\"}], clientKey: \"process\") {\r\n        title\r\n        id\r\n        name\r\n      }\r\n      find(queryString: \"\", filters: [{key: \"hello\", value: \"98\"}], clientId: 1234) {\r\n        metricx {\r\n          name\r\n          key\r\n        }\r\n        prodCount\r\n      }\r\n      itemListings(pots: [{potType: \"KITE_1\", filters: [{key: \"c\", value: \"1341\"}]}, {potType: \"KITE_2\", filters: [{key: \"c\", value: \"9812\"}]}], filters: [{key: \"hello\", value: \"98\"}], clientId: 1234, clientKey: \"process\") {\r\n        potType\r\n        productAlgo\r\n        count\r\n        listingEndpoint\r\n      }\r\n    }\r\n\r\nAnd for both the above cases, I need to map the arguments from each query to `ProcessRequest` class. Since we migrating them from **old service (uses javascript)** to **new service (uses dotnet)** so was trying to make sure they don't have to the change their request at all. This way they can just call new GraphQL endpoint with same requests and everything will work as it is.\r\n\r\nNow if we have to change the query request then I need to ask them to wrap their query with another static layer which I will use to extract child objects I guess. I can do that too but just trying to figure out if there is a way to do that without asking them to change anything?\r\n\r\nAlso **old service** is written in `Javascript` and uses `GraphQL` as well so does `Javascript` allows that to extract child objects without using any extra layer like we are adding here? This is just for my knowledge. @Shane32 "
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-12T04:02:33Z",
        "body": "Certainly if you have an existing graphql schema then you would not want to change it.\r\n\r\nThere's another way you can implement your schema that would probably work much better: use a batch data loader to group up a number of requests and return them to each of the field resolvers.  Here's how I would set it up:\r\n\r\n1. Create a dummy interface and classes containing the request parameters each type of query.\r\n\r\n```cs\r\npublic interface IRequest\r\n{\r\n}\r\n\r\npublic class ContentRequest : IRequest\r\n{\r\n    public int ClientId { get; set; }\r\n    public List<Filter> Filters { get; set; }\r\n    public string ClientKey { get; set; }\r\n}\r\n\r\npublic class FindRequest : IRequest\r\n{\r\n    public string QueryString { get; set; }\r\n    // other query parameters\r\n}\r\n\r\npublic class ItemListingsRequest : IRequest\r\n{\r\n    // see above\r\n}\r\n```\r\n\r\n2. Create a custom data loader where the key is the dummy interface, and it returns an object.  The \"data loader\" can group all of the requests together server-side and respond with data for each of them.  Be sure caching is turned off.\r\n\r\n```cs\r\npublic class MyDataRequestor : DataLoaderBase<IRequest, object>\r\n{\r\n    private readonly IDataService _dataService; // <-- example service\r\n\r\n    public MyDataRequestor(IDataService dataService) : base(false)  // no caching\r\n    {\r\n        // pull DI services as necessary here\r\n        _dataService = dataService;\r\n    }\r\n\r\n    protected override async Task FetchAsync(IEnumerable<DataLoaderPair<IRequest, object>> list, CancellationToken cancellationToken)\r\n    {\r\n        // process all of the requests, calling SetResult on each of the pairs\r\n        // below is a simplified example that executes the requests sequentially, but you can change this as desired\r\n        foreach (var pair in list)\r\n        {\r\n            pair.SetResult(pair.Key switch\r\n                {\r\n                    // if the request is a ContentRequest, return a List<ContentResponse>\r\n                    ContentRequest contentRequest => await _dataService.ProcessContentRequestAsync(contentRequest, cancellationToken),\r\n\r\n                    FindRequest findRequest => await _dataService.ProcessFindRequestAsync(findRequest, cancellationToken),\r\n\r\n                    ItemListingsRequest itemListingsRequest => await _dataService.ProcessItemListingsRequestAsync(itemListingsRequest, cancellationToken),\r\n\r\n                    _ => throw new NotSupportedException()\r\n                });\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n3. Register the data loader in your DI container as a singleton or scoped, depending on your needs.  If you are going to register it as a singleton, be sure that data loader caching is turned off, or else it will eventually use all of the memory on your server as there is no technique to clear the cache.  Caching won't be useful anyway because without `Equals` being implemented on the class, none of the `IRequest` objects will equal each other.  (It is something that could be implemented, however.)\r\n\r\n4. Call the data loader from the `contentRequest`, `find`, and `itemListings` field resolvers.  If the data loader is registered as a singleton, you can include a reference in the graph type constructor.  If not, you will need to obtain a reference from `context.RequestServices`.  I am going to assume it is scoped in the below example.\r\n\r\n```cs\r\npublic class TitanQuery : ObjectGraphType<object>\r\n{\r\n    public TitanQuery(....)\r\n    {\r\n        Name = \"Query\";\r\n\r\n        FieldAsync<ListGraphType<ContentResponseType>>(\r\n            \"contentRequest\",\r\n            arguments: new QueryArguments(\r\n                    new QueryArgument<NonNullGraphType<IntGraphType>>\r\n                    {\r\n                        Name = \"clientId\",\r\n                        Description = \"Client Id of the request\"\r\n\r\n                    },\r\n                    new QueryArgument<ListGraphType<FilterType>>\r\n                    {\r\n                        Name = \"filters\",\r\n                        Description = \"Filters\"\r\n                    },\r\n                    new QueryArgument<StringGraphType>\r\n                    {\r\n                        Name = \"clientKey\",\r\n                        DefaultValue = \"abc\",\r\n                        Description = \"some stuff\"\r\n                    }\r\n                ),\r\n\r\n            resolve: async context =>\r\n            {\r\n                var dataLoader = context.RequestServices.GetRequiredService<MyDataRequestor>();\r\n                var request = new ContentRequest {\r\n                    ClientId = context.GetArgument<int>(\"clientId\"),\r\n                    Filters = context.GetArgument<List<Filter>>(\"filters\"),\r\n                    ClientKey = context.GetArgument<string>(\"clientKey\"),\r\n                };\r\n\r\n                // after being processed by the dataloader, will return a List<ContentResponse>\r\n                return dataLoader.LoadAsync(request);\r\n            }\r\n        );\r\n    }\r\n}\r\n```\r\n\r\nFYI, how data loaders work is that they will execute all nodes possible until none remain that can be executed.  Then it will execute/trigger all pending data loader nodes at once.  See `SerialExecutionStrategy` and `ParallelExecutionStrategy` source code for specifics.\r\n\r\nAlso, I'd be real careful about registering the data loader as a singleton.  Specifically, let's say two request come in at the same time like this:\r\n\r\n```gql\r\n# request A\r\n\r\nquery {\r\n  contentRequest { ... }\r\n}\r\n\r\n# request B\r\n\r\nquery {\r\n  contentRequest { ... }\r\n  find { ... }\r\n}\r\n```\r\n\r\nThen what can happen is that the two `contentRequest` queries can get grouped into the same dataloader call, while the second half of request B (the `find` query) gets put into a separate call.  Worse yet, the first group of requests gets called from the context of request A, so if there is any code that relies on `IHttpContextAccessor`, it will return the wrong http context for the second content request. Similar issues can occur with any async-local data.  I had these problems in one of my live environments; it was very hard to track down since the probability of it happening is rare.  Now if that is perfectly fine (no issues with authentication or anything else), then sure, I guess...  But also if the `FetchAsync` code in the data loader depends on any scoped services, you'll need the data loader to be a scoped service.\r\n\r\nI think this solution should work well for you.  It also can fully handle any valid graphql query, whether it uses aliases, fragments, etc."
      },
      {
        "user": "TechGeeky",
        "created_at": "2021-04-12T21:48:16Z",
        "body": "Interesting solution. Let me go through this and try to understand. I will get back to you in sometime."
      },
      {
        "user": "TechGeeky",
        "created_at": "2021-04-13T00:20:27Z",
        "body": "You meant `FetchAsync` right in your return line in `TitanQuery` class? I cross checked `DataLoaderBase` abstract class so I believe it should be `FetchAsync` but just making sure.\r\n\r\n> return dataLoader.LoadAsync(request);\r\n\r\nAlso as of now it gives me an error on that line - \r\n\r\n`'MyDataRequestor.FetchAsync(IEnumerable<DataLoaderPair<IRequest, object>>, CancellationToken)' is inaccessible due to its protection level`\r\n\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-13T00:33:16Z",
        "body": "No, `LoadAsync` is correct."
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-13T00:45:22Z",
        "body": "Here's the gory details:\r\n\r\n`LoadAsync` queues the key (the `IRequest` in your case) as a new `DataLoaderPair<IRequest, object>` within a `DataLoaderList` and returns the `DataLoaderPair` an `IDataLoaderResult<object>` interface.  Once the execution strategy determines that only data loader nodes are remaining to be processed, it will call `await IDataLoaderResult.GetResultAsync(cancellationToken)`.  The `DataLoaderPair` in turn holds a reference of the queued requests in the form of a `DataLoaderList` instance and calls the `DispatchAsync` method.  The `DataLoaderList.DispatchAsync` method holds a reference to the `DataLoaderBase` and calls the abstract `FetchAsync` method to load the results into the list for all of the pending nodes.  The `FetchAsync` method contains only your own code and calls the `DataLoaderPair.SetResult` methods once the information requested has been retrieved.  Once the `DispatchAsync` method finishes, the `DataLoaderPair.GetResultAsync` method returns the data back to the execution strategy.\r\n\r\nFor the other pending data loader nodes, one of two things happen:\r\n1.  If the `DispatchAsync` method has already completed, then the `IsResultSet` property of the pair is already `true`, and so the `GetResultAsync` method can immediately return the correct data.\r\n2. If not, it calls `DispatchAsync`, which returns a reference to the same `Task` that represents the completion of the `FetchAsync` method on the other thread.  Once that task is complete, the `IsResultSet` property will be `true` and the data can be returned from the pair."
      },
      {
        "user": "TechGeeky",
        "created_at": "2021-04-13T01:18:01Z",
        "body": "Yeah my bad. I missed `LoadAsync` in `DataLoaderBase` class. Went through the doc and got some clarity. \r\n\r\nI am kinda confuse on your second solution and not sure how it will fit to what I need unless I am understanding it wrong. This is what I am trying to do and let me know if your second solution helps me with that -\r\n\r\nWhen customer passes query like this - \r\n\r\n    {\r\n      contentRequest(clientId: 123, filters: [{key: \"hello\", value: \"98\"}], clientKey: \"process\") {\r\n        title\r\n        id\r\n        name\r\n      }\r\n    }\r\n\r\nthen I want to create `ProcessRequest` object like below.\r\n\r\n    var processRequest = new ProcessRequest {\r\n        ClientId = context.GetArgument<int>(\"clientId\"),\r\n        Filters = context.GetArgument<List<Filter>>(\"filters\"),\r\n        ClientKey = context.GetArgument<string>(\"clientKey\"),\r\n    };\r\n\r\nBut if customer passes multiple queries in single request like this - \r\n\r\n    {\r\n      contentRequest(clientId: 123, filters: [{key: \"hello\", value: \"98\"}], clientKey: \"process\") {\r\n        title\r\n        id\r\n        name\r\n      }\r\n      find(queryString: \"\", filters: [{key: \"hello\", value: \"98\"}], clientId: 1234) {\r\n        metricx {\r\n          name\r\n          key\r\n        }\r\n        prodCount\r\n      }\r\n      itemListings(pots: [{potType: \"KITE_1\", filters: [{key: \"c\", value: \"1341\"}]}, {potType: \"KITE_2\", filters: [{key: \"c\", value: \"9812\"}]}], filters: [{key: \"hello\", value: \"98\"}], clientId: 1234, clientKey: \"process\") {\r\n        potType\r\n        productAlgo\r\n        count\r\n        listingEndpoint\r\n      }\r\n    }\r\n\r\nthen I want to create request object like this by extracting arguments from all those queries. `clientId`, `filters`, `clientKey` will be there in all the schemas with same values mostly.\r\n\r\n    var processRequest = new ProcessRequest {\r\n        ClientId =    'clientId from any query arguments',\r\n        Filters =     'filters from any query arguments',\r\n        ClientKey =   'clientKey from any query arguments',\r\n        QueryString = 'queryString from \"find\" query arguments',\r\n        Pots =        'pots from \"itemListings\" query arguments'\r\n    };\r\n\r\nBasically arguments from each query is mapped to some object or variables in `ProcessRequest` class. Single query or multiple query makes one `ProcessRequest` object. Once I make `processRequest` object either from single query or multiple query then I pass this object to underlying methods of services to get `ProcessResponse` object just like I have in my original question - \r\n\r\n> var processResponse = await metadataService.ProcessData(processRequest);\r\n\r\nOnce I have `ProcessResponse` object which has all the data either from single query or multiple queries then I need to get corresponding fields for each query type from it. Basically we make one call to underlying services by passing single `processRequest` object to get data out of it.\r\n\r\nNow in our code base, we already have `ProcessRequest` and `ProcessResponse` defined. We just need to create `ProcessRequest` from either single query or multiple query arguments and then from that get `ProcessResponse`  object which will be use to return data for corresponding query fields depending on what they need.\r\n\r\nNow if I see your example of `FetchAsync` method then it looks like we are creating different input request object for each query arguments but in my case I need single `ProcessRequest` object from all those query arguments and use that to get `ProcessResponse` object. \r\n\r\nDo you think `DataLoader` can still be used here? Maybe `FetchAsync` method can be modified to make one `ProcessRequest` object from all input arguments in multiple queries and then call `await metadataService.ProcessData(processRequest)` to get data and then return multiple response type for each resolvers? Is that possible to do by any chance?\r\n\r\nAs of now when I was testing the code, I am seeing NPE from this line. \r\n\r\n```\r\nvar dataLoader = context.RequestServices.GetRequiredService<MyDataRequestor>();\r\n...\r\n```\r\n\r\nStacktrace:\r\n\r\n```\r\nSystem.ArgumentNullException: Value cannot be null. (Parameter 'provider')\r\n   at GraphQL.Utilities.ServiceProviderExtensions.GetRequiredService(IServiceProvider provider, Type serviceType) in /_/src/GraphQL/Utilities/ServiceProviderExtensions.cs:line 33\r\n   at GraphQL.Utilities.ServiceProviderExtensions.GetRequiredService[T](IServiceProvider provider) in /_/src/GraphQL/Utilities/ServiceProviderExtensions.cs:line 18\r\n```\r\n\r\nI have added it as scoped:\r\n\r\n`services.AddScoped<MyDataRequestor>();`\r\n\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-13T07:41:30Z",
        "body": "The NPE is because `ExecutionOptions.RequestServices` isn't set when calling the `DocumentExecutor`."
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-13T07:59:39Z",
        "body": "> Now if I see your example of FetchAsync method then it looks like we are creating different input request object for each query arguments but in my case I need single ProcessRequest object from all those query arguments and use that to get ProcessResponse object.\r\n\r\nYes, but you can change the code in FetchAsync however you want. For example:\r\n\r\n```cs\r\n    protected override async Task FetchAsync(IEnumerable<DataLoaderPair<IRequest, object>> list, CancellationToken cancellationToken)\r\n    {\r\n        //1. find the different types of requests, and ensure that only max of one is requested for each type\r\n        //  (because according to graphql spec there could be multiple of a single one)\r\n        var contentRequestPair = list.SingleOrDefault(x => x.Key is ContentRequest);\r\n        var contentRequest = (ContentRequest)contentRequestPair?.Key;\r\n        //ditto for findRequest and itemListingsRequest\r\n\r\n        //2. pull the common variables\r\n        var clientId = contentRequest?.ClientId ?? findRequest?.ClientId ?? itemListingsRequest?.ClientId;\r\n        //ditto for filters and clientkey\r\n\r\n        //optional: throw an exception if clientId is different for contentRequest vs findRequest vs itemListingsRequest, or similar logic\r\n\r\n        //3. initialize the process request\r\n        var request = new ProcessRequest {\r\n            //common properties\r\n            ClientId = clientId,\r\n            ClientKey = clientKey,\r\n            Filters = filters,\r\n            //properties specific to the type of request\r\n            QueryString = findRequest?.Find,\r\n            ...\r\n        };\r\n\r\n        // 4. todo: execute your request (async or sync)\r\n        var processResponse = await ExecuteProcessRequestAsync(processRequest, cancellationToken);\r\n\r\n        // 5. set the results\r\n        if (contentRequestPair != null)\r\n        {\r\n            // create the data model for the graph\r\n            var contentResponse = processResponse.whatever;\r\n            // set the answer\r\n            contentRequestPair.SetResult(contentResponse);\r\n        }\r\n        listRequestPair?.SetResult(processResponse.answer2);\r\n        // ditto for the other objects\r\n    }\r\n```\r\n\r\nSome more idea: group the `list` variable by the common properties, so e.g. if there are different clientIds specified it will execute separate requests rather than execute one of the two with the wrong clientid.  Apply similar logic if there are multiple `contentRequest`s queried, so it will execute separate requests rather than throwing an error during `SingleOrDefault`.\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-13T08:01:44Z",
        "body": "> Do you think DataLoader can still be used here? Maybe FetchAsync method can be modified to make one ProcessRequest object from all input arguments in multiple queries and then call await metadataService.ProcessData(processRequest) to get data and then return multiple response type for each resolvers? Is that possible to do by any chance?\r\n\r\nYes exactly.  This is your responsibility now to implement `FetchAsync` any way you want.  Group the queries together into one call, or issue separate calls, whatever."
      },
      {
        "user": "TechGeeky",
        "created_at": "2021-04-13T20:52:20Z",
        "body": "@Shane32 I think it makes sense now. I got more clarity after your last few comments. Working on making those changes. Also I fixed the error by adding this line - `options.RequestServices = context.RequestServices;`. Working on your above suggestion.\r\n\r\n```\r\n        private async Task ExecuteAsync(HttpContext context, ISchema schema)\r\n        {\r\n            var request = Deserialize<GraphQLRequest>(context.Request.Body);\r\n            var result = await _executer.ExecuteAsync(_ =>\r\n            {\r\n                _.Schema = schema;\r\n                _.Query = request?.Query;\r\n                _.OperationName = request?.OperationName;\r\n                _.Inputs = request?.Variables.ToInputs();\r\n                _.RequestServices = context.RequestServices;\r\n                _.UserContext = _settings.BuildUserContext?.Invoke(context);\r\n                _.ValidationRules = DocumentValidator.CoreRules.Concat(new[] { new InputValidationRule() });\r\n                _.EnableMetrics = _settings.EnableMetrics;\r\n                if (_settings.EnableMetrics)\r\n                {\r\n                    _.FieldMiddleware.Use<InstrumentFieldsMiddleware>();\r\n                }\r\n                _.UnhandledExceptionDelegate = ctx => logger.Error(\"GraphQL\", \"{Error} occurred\", ctx.OriginalException.Message, \"GraphQL error\", ctx.OriginalException.Message);\r\n            });\r\n            await WriteResponseAsync(context, result);\r\n        }\r\n```"
      },
      {
        "user": "sungam3r",
        "created_at": "2022-02-04T23:33:35Z",
        "body": "Since it seems issue is answered I close it."
      }
    ]
  },
  {
    "number": 2313,
    "title": "Inconsistent casting of input arguments for arrays",
    "created_at": "2021-02-23T23:46:21Z",
    "closed_at": "2021-02-24T23:28:10Z",
    "labels": [
      "question",
      "wontfix"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2313",
    "body": "In the following code (In LinqPad), there is an input object with two properties and both are List of string.\r\n\r\nIn the query, for list1 one single value is passed (without []) and list 2 is passed with one value as array:\r\n(Before this, I even did not know when parameter is defined as list, one single value could be passed without [] )\r\n\r\n```\r\nlist1: \"item1\",\r\nlist2: [\"item2\"]\r\n```\r\n\r\nWhen the input parameter is getting cast to Dictionary<string, object>, the type of **list1** is **System.Object[]** and the type of **list2** is **System.Collections.Generic.List`1[System.Object]**\r\n\r\n```csharp\r\nvoid Main()\r\n{\r\n\tvar schema = new Schema { Query = new TestQuery() };\r\n\r\n\tvar exec = new DocumentExecuter();\r\n\r\n\tvar result = exec.ExecuteAsync(options =>\r\n\t\t\t{\r\n\t\t\t\toptions.Schema = schema;\r\n\t\t\t\toptions.Root = null;\r\n\t\t\t\toptions.Query = \"{ test(input: {list1: \\\"item1\\\", list2: [\\\"item2\\\"]}) { prop1  } }\";\r\n\t\t\t\toptions.OperationName = \"\";\r\n\t\t\t}\r\n\t).Result;\r\n}\r\n\r\npublic class TestQuery : ObjectGraphType\r\n{\r\n\tpublic TestQuery()\r\n\t{\r\n\r\n\t\tField<TestResponseType>(\r\n\t\t\tname: \"test\",\r\n\t\t\targuments: new QueryArguments(\r\n\t\t\t\tnew QueryArgument<InputType> { Name = \"input\" }\r\n\t\t\t),\r\n\t\t\tresolve: context =>\r\n\t\t\t{\r\n\t\t\t\tvar input = context.GetArgument<Dictionary<string, object>>(\"input\");\r\n\t\t\t\tinput[\"list1\"].GetType().Dump();  \t//<--- System.Object[]\r\n\t\t\t\tinput[\"list2\"].GetType().Dump();\t//<--- System.Collections.Generic.List`1[System.Object]\r\n\t\t\t\treturn new TestResponse();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n}\r\n\r\npublic class TestResponseType : ObjectGraphType<TestResponse>\r\n{\r\n\tpublic TestResponseType()\r\n\t{\r\n\t\tField(h => h.Prop1);\r\n\t}\r\n}\r\n\r\npublic class TestResponse\r\n{\r\n\tpublic string Prop1 { get; set; } = \"Prop1\";\r\n}\r\n\r\npublic class InputType : InputObjectGraphType\r\n{\r\n\tpublic InputType()\r\n\t{\r\n\t\tField<ListGraphType<StringGraphType>>(\"list1\");\r\n\t\tField<ListGraphType<StringGraphType>>(\"list2\");\r\n\t}\r\n}\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2313/comments",
    "author": "rmeshksar",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-02-23T23:59:37Z",
        "body": "This is designed this way for performance reasons.  Both can be cast to `IList<object>` for a consistent view of the data, regardless of whether there is a single item (`list1: \"item1\"`) or multiple (`list2: [\"item2\"]`)."
      },
      {
        "user": "Shane32",
        "created_at": "2021-02-24T00:06:01Z",
        "body": "Note that within v4, you should almost always be returned an `object[]` instance, rather than a `List<object>` instance.  However, it is still possible to be returned a `List<object>` if the argument is passed within a variable, and the variable value instance is an `IEnumerable` that does not implement `IList`."
      },
      {
        "user": "Shane32",
        "created_at": "2021-02-24T00:07:11Z",
        "body": "> when parameter is defined as list, one single value could be passed without [] \r\n\r\nThis is pursuant to the GraphQL specification."
      },
      {
        "user": "rmeshksar",
        "created_at": "2021-02-24T14:11:24Z",
        "body": "We recently migrated from very old GraphQL .NET 0.14 to 3.2 and I noticed in old version it is always object[] .\r\n\r\nSo, I thought it might be a bug in 3.2."
      },
      {
        "user": "Shane32",
        "created_at": "2021-02-24T23:28:10Z",
        "body": "Please let me know if you have further questions."
      }
    ]
  },
  {
    "number": 2290,
    "title": "How to represent response object type for complex json objects?",
    "created_at": "2021-02-16T06:18:08Z",
    "closed_at": "2021-02-16T20:07:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2290",
    "body": "`ContainerResponse` is the class which contains response for my request -\r\n\r\n**ContainerResponse.cs**\r\n\r\n    public class ContainerResponse\r\n    {\r\n        public int ResponseCode { get; set; }\r\n        public ClientResponse ClientResponse { get; set; }\r\n    }\r\n\r\n**ClientResponse.cs**\r\n\r\n    public class ClientResponse\r\n    {\r\n        public int ClientGroupCount { get; set; }\r\n        public IList<ClientGroup> ClientGroups { get; set; }\r\n    }\r\n\r\n**ClientGroup.cs**\r\n\r\n    public class ClientGroup\r\n    {\r\n        public string ClientLabel { get; set; }\r\n        public string ClientType { get; set; }\r\n        public string ClientGroupName { get; set; }\r\n        public int ClientCount { get; set; }\r\n        public IList<Client> Clients { get; set; }\r\n        public int OrderNumber { get; set; }\r\n    }\r\n\r\n**Client.cs**\r\n\r\n    public class Client\r\n    {\r\n        public string ClientId { get; set; }\r\n        public int ClientValuesCount { get; set; }\r\n        public IList<ClientValue> ClientValues { get; set; }\r\n    }\r\n\r\n**ClientValue.cs**\r\n\r\n    public class ClientValue\r\n    {\r\n        public string DisplayValue { get; set; }\r\n        public int ValueId { get; set; }\r\n        public int totalCount { get; set; }\r\n        public ClientUrl ClientUrl { get; set; }\r\n        public double? OrderNumber { get; set; }\r\n    }\r\n\r\n**ClientUrl.cs**\r\n\r\n    public class ClientUrl\r\n    {\r\n        public string Alias { get; set; }\r\n        public string Resource { get; set; }\r\n        public string BaseResource { get; set; }\r\n        public string QueryString { get; set; }\r\n        public string Url { get; set; }\r\n    }\r\n\r\n**ClientSnippet.cs**\r\n\r\n    public class ClientSnippet\r\n    {\r\n        public string ImagePath { get; set; }\r\n    }\r\n\r\nBelow is the sample JSON response for my above POCO -\r\n\r\n    {\r\n        \"responseCode\": 200,\r\n        \"clientResponse\": {\r\n            \"clientGroupCount\": 1,\r\n            \"clientGroups\": [{\r\n                \"clientLabel\": \"Hello World\",\r\n                \"clientType\": \"states\",\r\n                \"clientGroupName\": \"states\",\r\n                \"clientCount\": 1,\r\n                \"clients\": [{\r\n                    \"clientId\": \"t\",\r\n                    \"clientValuesCount\": 98,\r\n                    \"clientValues\": [{\r\n                        \"displayValue\": \"Texas Sports\",\r\n                        \"valueId\": 1118,\r\n                        \"totalCount\": 9876,\r\n                        \"clientUrl\": {\r\n                            \"alias\": \"poy/texas\",\r\n                            \"resource\": \"abc12345poqert\",\r\n                            \"baseResource\": \"a-b-ce-kj-123\",\r\n                            \"url\": \"poy/texas/abc12345poqert\"\r\n                        },\r\n                        \"orderNumber\": 12311\r\n                    }]\r\n                }],\r\n                \"orderNumber\": 0\r\n            }]\r\n        }\r\n    }\r\n\r\nNow I am trying to represent my graphql output in this below format using `GraphQL` -\r\n\r\n    {\r\n      \"data\": {\r\n        \"output\": [\r\n          {\r\n            \"title\": \"Hello World\",\r\n            \"type\": \"states\",\r\n            \"links\": [\r\n              {\r\n                \"clientId\": \"abc12345poqert\",\r\n                \"totalCount\": 9876,\r\n                \"resource\": \"a-b-ce-kj-123\",\r\n                \"text\": \"Texas Sports\",\r\n                \"href\": \"poy/texas/abc12345poqert\"\r\n              }\r\n            ]\r\n          }\r\n        ]\r\n      },\r\n      \"extensions\": {\r\n        \"runTime\": 29\r\n      }\r\n    }\r\n\r\nBelow is my Query - \r\n\r\n    Field<ResponseType>(\r\n        \"output\",\r\n        arguments: new QueryArguments(\r\n            new QueryArgument<NonNullGraphType<StringGraphType>> { Name = \"id\"}\r\n        ),\r\n        resolve: context =>\r\n        {\r\n            var input = context.GetArgument<string>(\"id\");\r\n            var containerResponse = data.GetResponse(input);\r\n            return containerResponse;\r\n        }\r\n    );\r\n\r\nBelow is my `ResponseType` class which I started with but I got confuse on how to proceed further for other classes. Since my json is little bit complex so kinda confuse on how my other class will look like?\r\n\r\n    public class ResponseType : ObjectGraphType<ContainerResponse>\r\n    {\r\n        public ResponseType()\r\n        {\r\n            Name = \"Output\";\r\n            Field(h => h.ResponseCode).Description(\"Response Code of the request.\");\r\n            // is this right?\r\n            Field<ObjectGraphType<ClientResponseType>>(\"clientResponse\", \"some stuff\");\r\n        }\r\n    }\r\n\r\n    public class ClientResponseType : ObjectGraphType<ClientResponseType>\r\n    {\r\n        public ClientResponseType()\r\n        {\r\n            Name = \"ClientResponse\";\r\n            Field(h => h.ClientGroupCount).Description(\"some stuff\");\r\n            .....\r\n        }\r\n    }\r\n\r\nAny example will be greatly appreciated.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2290/comments",
    "author": "davidport21",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2021-02-16T13:41:01Z",
        "body": "`public class ClientResponseType : ObjectGraphType<ClientResponseType>`\r\n->\r\n`public class ClientResponseType : ObjectGraphType<ClientResponse>`"
      },
      {
        "user": "davidport21",
        "created_at": "2021-02-16T16:29:06Z",
        "body": "yeah I already fixed that but I am seeing an error as -\r\n\r\n```\r\nSystem.InvalidOperationException: Required service for type GraphQL.Types.ObjectGraphType`1[Golden.Contracts.Types. ClientResponseType] not found\r\n```\r\n\r\nI have already added service as well - \r\n\r\n```\r\nservices.AddSingleton<ClientResponseType>();\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2021-02-16T18:10:32Z",
        "body": "Fix:\r\n```cs\r\n//Field<ObjectGraphType<ClientResponseType>>(\"clientResponse\", \"some stuff\");\r\nField<ClientResponseType>(\"clientResponse\", \"some stuff\");\r\n```"
      }
    ]
  },
  {
    "number": 2288,
    "title": "How to enable Compression ...",
    "created_at": "2021-02-16T01:47:11Z",
    "closed_at": "2021-02-16T09:07:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2288",
    "body": "Hello ,\r\n\r\nI was trying to enable response compression in my application ...\r\n\r\n On the server side ...I  was able to successfully configure it on the GraphQL Server using ASP .Net Core Response Compression Middleware\r\n```\r\n            services.AddResponseCompression(options =>\r\n            {\r\n                options.Providers.Add<BrotliCompressionProvider>();\r\n                options.Providers.Add<GzipCompressionProvider>();\r\n                options.MimeTypes =\r\n                    ResponseCompressionDefaults.MimeTypes.Concat(\r\n                        new[] { \"application/json\" });\r\n            });\r\n```\r\nAnd on the client side , using a GraphQLHttpClient I am passing the required headers using the underlying HttpClient Instance..\r\n\r\n```\r\n            using var graphQLClient = new GraphQLHttpClient(graphQLEndpoint, new NewtonsoftJsonSerializer());\r\n            graphQLClient.HttpClient.DefaultRequestHeaders.Clear();\r\n            graphQLClient.HttpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\r\n            graphQLClient.HttpClient.DefaultRequestHeaders.AcceptEncoding.Add(new StringWithQualityHeaderValue(\"gzip\"));\r\n            var httpClientHandler = new HttpClientHandler\r\n            {\r\n                AutomaticDecompression = System.Net.DecompressionMethods.GZip\r\n            };\r\n            graphQLClient.Options.HttpMessageHandler = httpClientHandler;\r\n```\r\n\r\nHowever , when I run it , the client is uanble to parse the response and throws an error \r\n\r\n> {\"Unexpected character encountered while parsing value: \\u001f. Path '', line 0, position 0.\"}\r\n\r\nI inspected the request using Fiddler and found that the client was sending the desired headers and the server is able to compress the data seamlessly ... the problem seems to be at the receiving end . \r\n\r\nIs there anything that I am doing wrong . \r\n\r\nThanks\r\nSK",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2288/comments",
    "author": "KreeziOS",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-02-16T03:01:28Z",
        "body": "Have you tried using the defaults for the client side? I would expect HttpClient should decompress automatically without extra code but I could be wrong. "
      },
      {
        "user": "Shane32",
        "created_at": "2021-02-16T03:03:38Z",
        "body": "Have you tried GraphiQL or similar? ( If GraphiQL works you can be sure that it’s a client side problem.)"
      },
      {
        "user": "KreeziOS",
        "created_at": "2021-02-16T03:15:05Z",
        "body": "Hello Shane32 ,\r\nThanks for the quick response.\r\n1.Defaults did not work as it was not setting the required gzip header.\r\n2.I just tried GraphiQL and it works neatly (the compressed size is actually very good too)... \r\nand it sends these in the request headers ; so technically it means compression should work without any issues , right !?\r\n`Accept-Encoding: gzip, deflate, br`\r\n\r\nThanks \r\nSK"
      },
      {
        "user": "Shane32",
        "created_at": "2021-02-16T03:18:34Z",
        "body": "Yes, if GraphiQL works then you should be good. Offhand I’m not sure how to configure the client to request and process compressed responses. "
      },
      {
        "user": "KreeziOS",
        "created_at": "2021-02-16T03:23:29Z",
        "body": "Okay Shane  ... no problem but Thanks for the GraphiQL idea ; i'll try to set a few more headers and see if it works . "
      },
      {
        "user": "KreeziOS",
        "created_at": "2021-02-16T08:40:53Z",
        "body": "Finally !!  Should have done this first I believe   ... \r\nneed to create an HttpClient instance manually and pass it to the GraphQLHttpClient ... \r\n\r\n```\r\n            HttpClient httpClient = new HttpClient(new HttpClientHandler\r\n            {\r\n                AutomaticDecompression = System.Net.DecompressionMethods.GZip | System.Net.DecompressionMethods.Deflate\r\n            });\r\n            httpClient.DefaultRequestHeaders.AcceptEncoding.Add(new StringWithQualityHeaderValue(\"gzip\"));\r\n\r\n            GraphQLHttpClientOptions options = new GraphQLHttpClientOptions();\r\n            options.EndPoint = new Uri(graphQLEndpoint);\r\n\r\n            using var graphQLClient = new GraphQLHttpClient(options, new NewtonsoftJsonSerializer(), httpClient);\r\n```\r\n\r\nHope someone finds it useful too ...\r\n\r\nAnother interesting fact => the response for a GraphiQL request was 200KB smaller .. weird ... may be a challenge for some other day ..\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
      }
    ]
  },
  {
    "number": 2286,
    "title": "How to use FieldAsync here bcoz my methods signatures are \"async Task<...>\"",
    "created_at": "2021-02-15T01:48:46Z",
    "closed_at": "2021-02-22T15:09:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2286",
    "body": "I have a resolve method like this in which I need to use `await` two times because `BuildRequest` and `ProcessData` method signatures are `async Task<....>` -\r\n\r\n    Field<HumanType>(\r\n        \"human\",\r\n        arguments: new QueryArguments(\r\n            new QueryArgument<NonNullGraphType<StringGraphType>> { Name = \"id\", Description = \"id of the human\" }\r\n        ),\r\n        resolve: context =>\r\n        {\r\n            var human = context.GetArgument<string>(\"id\");\r\n            var requestContext = await clientService.BuildRequest(.....);\r\n            var response = await metadataService.ProcessData(....);\r\n\r\n            return response;\r\n        }\r\n    );\r\n\r\nIs this the right way to use resolve like this? Or is there any async implementations which I can use here?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2286/comments",
    "author": "TechGeeky",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2021-02-15T17:20:58Z",
        "body": "Use `FieldAsync`:\r\n```graphql\r\n FieldAsync<__Type>(\r\n                \"mutationType\",\r\n                \"If this server supports mutation, the type that mutation operations will be rooted at.\",\r\n                resolve: async context =>\r\n                {\r\n                    return await context.Schema.Filter.AllowType(context.Schema.Mutation).ConfigureAwait(false)\r\n                        ? context.Schema.Mutation\r\n                        : null;\r\n                });\r\n```"
      },
      {
        "user": "TechGeeky",
        "created_at": "2021-02-15T18:02:28Z",
        "body": "You mean something like this?\r\n\r\n```\r\nFieldAsync<HumanType>(\r\n    \"human\",\r\n    arguments: new QueryArguments(\r\n        new QueryArgument<NonNullGraphType<StringGraphType>> { Name = \"id\", Description = \"id of the human\" }\r\n    ),\r\n    resolve: async context =>\r\n    {\r\n        var human = context.GetArgument<string>(\"id\");\r\n        var requestContext = await clientService.BuildRequest(.....);\r\n        var response = await metadataService.ProcessData(....);\r\n\r\n        return response;\r\n    }\r\n);\r\n```\r\n\r\nOr I need something else here?"
      },
      {
        "user": "sungam3r",
        "created_at": "2021-02-15T19:24:49Z",
        "body": "> You mean something like this?\r\n\r\nYes. `FieldAsync` overloads."
      },
      {
        "user": "sungam3r",
        "created_at": "2021-02-22T15:09:11Z",
        "body": "Closed as answered."
      }
    ]
  },
  {
    "number": 2282,
    "title": "Siblings dependencies",
    "created_at": "2021-02-14T15:23:17Z",
    "closed_at": "2023-04-03T21:43:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2282",
    "body": "Hi,\r\n\r\n**Use case** \r\nIn an ObjectGraphType, i have a Field that resolve with a required Async sibling dependency, ie :\r\nA patient wants to calculate his last weight measurement. So, in my model Patient, i have a property \r\n```c#\r\npublic Measurement LastMeasurement => Measurements?.OrderByDescending(m => m.Date).FirstOrDefault();\r\n```\r\nBut it doesn´t work, because in the same time, i'm requesting the necessary Measurements with a dataloader.\r\nIs there a way to tell to some siblings fields to wait for their resolution until all their dependencies are ready to be used ?\r\n\r\nIs this solution is an anti pattern compared to graphql spec ?\r\nIf yes, what is the good way to handle such a use case ?\r\n\r\nThanks.\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2282/comments",
    "author": "grean",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-02-14T15:55:38Z",
        "body": "The graphql spec has no bearing on this issue; your problem is determining the best way to load data from your database.\r\n\r\nYou have a couple options:\r\n\r\n1. When the parent is being resolved, examine which child fields are being requested, and load the necessary data at that time.\r\n2. Issue another call to the database for this field\r\n\r\nA data loader can force a sibling node to execute after its siblings.  However, this would mean making the Measurements not load via a dataloader, and having the LastMeasurements field load via a data loader.  Probably not what you want to do if there are multiple parent objects returned in one call.\r\n\r\nBesides that, you cannot control the order in which sibling fields are resolved.  With a serial execution strategy, fields are resolved in the order listed, but LastMeasurement might come listed before the Measurements nodes in the query."
      },
      {
        "user": "Shane32",
        "created_at": "2021-02-14T17:28:37Z",
        "body": "Another option is to put both the siblings in an object which has two fields: “items” and “last”. So the object resolves via data loader together, and then it is easy to return the items or the last item from the resolved list. \r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2021-02-14T20:22:02Z",
        "body": "Consider changing your data model and pull down `last` property in data structure:\r\n```graphql\r\n{\r\n  user {\r\n    measurements {\r\n      items\r\n      last\r\n    }\r\n  }\r\n}\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2021-02-15T00:50:39Z",
        "body": "Thanks for the example. That’s exactly what I meant. "
      },
      {
        "user": "sungam3r",
        "created_at": "2021-02-15T00:58:45Z",
        "body": "😄 I haven't even seen your comment."
      },
      {
        "user": "grean",
        "created_at": "2021-02-16T16:52:46Z",
        "body": "Ok, i see what you mean but, my case is a bit more complicated since i've some calculus that needs lastMeasurement but not only :(\r\nThe others dependencies are siblings too.. I could put all the calculus in your new object but it feels weird.\r\nSo i've decided to load the dependencies alltogether with the parent object and it works. But i've a question on how to load the depedencies. I've found two ways of doing that.\r\nFirst one with AsSplitQuery macanism\r\n```c#\r\n\r\n        public async Task<Patient> GetPatientByIdAsync(Guid id, CancellationToken cancellationToken)\r\n        {\r\n            using (var scope = _serviceProvider.CreateScope())\r\n            {\r\n                var dbContext = scope.ServiceProvider.GetRequiredService<DietContext>();\r\n                return await dbContext.Patients.AsSplitQuery()\r\n                    .Include(i => i.Regimes)\r\n                    .Include(i => i.Measurements)\r\n                    .Include(i => i.Folders)\r\n                    .Include(i => i.Nap)\r\n                        .FirstAsync(i => i.Id == id, cancellationToken);\r\n            }\r\n        }\r\n```\r\nIt loads correctly but the split SQL querys are run sequentially, plus, it duplicates my 1 to 1 Nap relation property on each of them (why this behavior with 1 to 1 relation ?)\r\n\r\nSecond one using multiple dbContext with Tasks, then i rebuild my patient object with dependencies like the dbContext would do it.\r\n```c#\r\n        public Patient GetPatientByIdAsync2(Guid id, CancellationToken cancellationToken)\r\n        {\r\n            var patientTask = _dbContextHelper.GetPatient(id, cancellationToken);\r\n            var measurementTask = _dbContextHelper.GetMeasurements(id, cancellationToken);\r\n            var folderTask = _dbContextHelper.GetFolders(id, cancellationToken);\r\n            var regimeTask = _dbContextHelper.GetRegimes(id, cancellationToken);\r\n\r\n            Task.WaitAll(new Task[] { patientTask, measurementTask, folderTask, regimeTask }, cancellationToken);\r\n            var patient = patientTask.Result;\r\n\r\n            patient.Measurements = measurementTask.Result;\r\n            patient.Regimes = regimeTask.Result;\r\n            patient.Folders = folderTask.Result;\r\n\r\n            return patient;\r\n        }\r\n```\r\nClass helper that allow to launch in parallel all the SQL queries\r\n```c#\r\npublic async Task<Patient> GetPatient(Guid id, CancellationToken cancellationToken)\r\n        {\r\n            using (var scope = _serviceProvider.CreateScope())\r\n            {\r\n                var dbContext = scope.ServiceProvider.GetRequiredService<DietContext>();\r\n                return await dbContext.Patients.Include(i => i.Nap).FirstAsync(i => i.Id == id, cancellationToken);\r\n            }\r\n        }\r\n\r\n        public async Task<List<Regime>> GetRegimes(Guid id, CancellationToken cancellationToken)\r\n        {\r\n            using (var scope = _serviceProvider.CreateScope())\r\n            {\r\n                var dbContext = scope.ServiceProvider.GetRequiredService<DietContext>();\r\n                return await dbContext.Regimes.Where(i => i.PatientId == id).ToListAsync(cancellationToken);\r\n            }\r\n        }\r\n//remove others for brevity\r\n```\r\nBut now my Root Query Field as change from FieldAsync to Field because my repository doesn't return a task anymore.\r\nDoes that change on Root Query Field type is a problem ?\r\n\r\nWhat strategy do you prefer ?\r\n\r\nSide question :\r\nHow do you do to make my helpers function being Templated ? like this \r\n```c#\r\n        public async Task<T> GetResult<T>(Guid id, CancellationToken cancellationToken)\r\n        {\r\n            using (var scope = _serviceProvider.CreateScope())\r\n            {\r\n                var dbContext = scope.ServiceProvider.GetRequiredService<DietContext>();\r\n                return await dbContext.Set<T>().Include(i => i.Nap).FirstAsync(i => i.Id == id, cancellationToken);\r\n            }\r\n        }\r\n```\r\nUsing like this \r\n```c#\r\n_dbContextHelper.GetResult<Patient>(id, cancellationToken);\r\n```\r\nBut, i have an error like this \r\n> CS0452: Le type 'T' doit être un type référence afin d'être utilisé comme paramètre 'TEntity' dans le type ou la méthode générique 'DbContext.Set<TEntity>()'\r\n\r\nPlus, my 1 to 1 relation is not reconize anymore due to templating, i should test for Type of Entity but i don't know the good way to do it :(\r\nThanks."
      },
      {
        "user": "Nobusuma",
        "created_at": "2022-12-26T00:54:36Z",
        "body": "> A data loader can force a sibling node to execute after its siblings. However, this would mean making the Measurements not load via a dataloader, and having the LastMeasurements field load via a data loader. Probably not what you want to do if there are multiple parent objects returned in one call.\r\n\r\nI am having a problem were I have a field called stadistics and takes the data from a sibling, I think what you mentioned here can solve my issue.\r\n\r\nCan you provide an example of forcing a dataloader to execute after it siblings? \r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2022-12-26T01:53:33Z",
        "body": "Going mostly from memory here so lmk if it’s not correct.\r\n\r\n```cs\r\nreturn new SimpleDataLoader<IDataLoaderResult<Class1>>(\r\n    async cancellationToken => {\r\n        // old resolver code which returns a data loader\r\n    });\r\n// note: returns IDataLoaderResult<IDataLoaderResult<Class1>>\r\n```"
      },
      {
        "user": "sungam3r",
        "created_at": "2023-04-03T21:43:36Z",
        "body": "@grean I hope you solved this issue. Closing due to inactivity. "
      }
    ]
  },
  {
    "number": 2278,
    "title": "Field scalar value and extension method",
    "created_at": "2021-02-11T18:19:20Z",
    "closed_at": "2021-02-13T13:02:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2278",
    "body": "I have an extension method on a decimal type like this \r\n```c#\r\n    public static class Conversion\r\n    {\r\n        public static decimal MegaJouleToKcal(this decimal value) => value * Constantes.MegaJouleToKcal;\r\n\r\n    }\r\n``` \r\nBut when i want to use it in an objectType constructor, the second line throw a error\r\n```c#\r\nField(i => i.DEJGoal);\r\nField(i => i.DEJGoal.MegaJouleToKcal(), nullable: true, type: typeof(DecimalGraphType)).Name(\"dejGoalKcal\");\r\n```\r\nlike this \r\n>Cannot infer a Field name from the expression: 'i.DEJGoal.MegaJouleToKcal()' on parent GraphQL type: 'PatientType'.\r\n\r\nIf i don´t use the extention method it works.\r\nHow can i achieve this ? I simply want to have the same value 'dejGoal' with a different unit.\r\nThanks.\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2278/comments",
    "author": "grean",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-02-11T20:53:03Z",
        "body": "Try:\r\n```cs\r\nField(\"dejGoalKcal\", i => i.DEJGoal.MegaJouleToKcal(), nullable: true, type: typeof(DecimalGraphType));\r\n```"
      },
      {
        "user": "grean",
        "created_at": "2021-02-13T10:59:23Z",
        "body": "It works, thanks @Shane32 :)"
      }
    ]
  },
  {
    "number": 2256,
    "title": "DataLoaderContext Is Null",
    "created_at": "2021-02-05T13:32:26Z",
    "closed_at": "2021-02-05T14:10:41Z",
    "labels": [
      "question",
      "data loader"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2256",
    "body": "I'm using GraphQL v 3.3.2 and I'm trying to make work the DataLoader but everytime I try to access the `Context` property inside the injected `IDataLoaderContextAccessor` instance, it is null. I've went through the documentation but didn't find anything useful so unstuck me. I'm not using directly in my code `DocumentExecuter` so the advice in the documentation doesn't seem to apply to my case\r\n\r\n## Startup\r\n\r\nThere is nothing fancy here\r\n\r\n```\r\nservices\r\n                .AddGraphQL(o => { o.EnableMetrics = true; })\r\n                .AddNewtonsoftJson()\r\n                .AddErrorInfoProvider(opt => opt.ExposeExceptionStackTrace = _environment.IsDevelopment())\r\n                .AddDataLoader() \r\n                .AddGraphTypes(ServiceLifetime.Scoped);\r\n```\r\n\r\nMy type\r\n\r\n```\r\npublic class FondsCatalogType : ObjectGraphType<CatalogFondsRepresentation>\r\n    {\r\n        public FondsCatalogType(IDataLoaderContextAccessor dataLoaderContextAccessor)\r\n        {\r\n            Field(t => t.Id, type: typeof(IdGraphType));\r\n\r\n            // more irrelevant field declarations...                    \r\n  \r\n        }\r\n    }\r\n```\r\n\r\nSo I'm getting correctly the instance of `IDataLoaderContextAccessor` but the context is `null`\r\n\r\nIs there something else to configure? \r\n\r\nIf I understand correctly internally the  `DataLoaderDocumentListener` is added to the execution context.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2256/comments",
    "author": "tjaskula",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-02-05T13:50:28Z",
        "body": "The context will only hold a value within a field resolver, not in the type constructor, Can you supply a sample of the field declaration whose results should come from the data loader?"
      },
      {
        "user": "tjaskula",
        "created_at": "2021-02-05T14:10:41Z",
        "body": "My bad. I didn't understood that from the documentation\r\n\r\nChecking this, it works. The Context is not null anymore inside the resolve operation\r\n\r\n```\r\nFieldAsync<StringGraphType>(\"testDataLoader\", resolve: async context =>\r\n            {\r\n                var loader = dataLoaderContextAccessor.Context;\r\n                return \"OK\";\r\n            });\r\n```"
      }
    ]
  },
  {
    "number": 2161,
    "title": "Slowness while fetching the data, post upgrade to GraphQl 3.2 from 2.2",
    "created_at": "2021-01-11T09:05:50Z",
    "closed_at": "2021-02-17T01:02:30Z",
    "labels": [
      "question",
      "performance"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2161",
    "body": "Summary\r\nWe recently migrated from 2.4 to 3.2 GraphQL Dotnet, with few issues in the beginning the upgrade was successful. \r\nAfter some tests, we found that the older version 2.2 was giving us the desired performance( ~ under 3 secs) in terms of data retrieval on a complex query but 3.3 was taking more than 5 minutes to execute. \r\nWe tried to search for the fixes but could not get any information thus adding a question here.\r\n## Relevant information\r\n```c#\r\npublic class ReceiptType : ObjectGraphType<Receipt>\r\n    {\r\n        public ReceiptType(ContextServiceLocator contextServiceLocator)\r\n        {\r\n            \r\n            Field(x => x.Tag, true);\r\n            Field(x => x.SlipNumber, true);\r\n            Field(x => x.Status, true);\r\n            Field(x => x.CarrierName, true);\r\n            Field(x => x.ClientName, true);\r\n            Field(x => x.ClientCode, true);\r\n            \r\n            Field<ListGraphType<ItemsType>>(\"parts\",\r\n             resolve: context => contextServiceLocator.receivingRepository.GetPartList(context.Source.IdReceiving, context.Source.Discrepancy));\r\n            Field<ListGraphType<DiscrepancyType>>(\"discrepancies\",\r\n                arguments: new QueryArguments(new QueryArgument<BooleanGraphType> { Name = \"isDeleted\" }),\r\n            resolve: context => contextServiceLocator.receivingRepository.GetDiscrepancyList(context.Source.IdReceiving, context.GetArgument<Boolean>(\"isDeleted\")));\r\n            Field<AttachmentType>(\"attachments\",\r\n                arguments: new QueryArguments(new QueryArgument<BooleanGraphType> { Name = \"isDeleted\" }),\r\n            resolve: context => contextServiceLocator.receivingRepository.GetAttachmentList(context.Source.IdReceiving, context.GetArgument<Boolean>(\"isDeleted\")));\r\n        }\r\n    }\r\n```\r\nStartup.cs \r\n```c#\r\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\r\n        {\r\n            if (env.IsDevelopment())\r\n            {\r\n                app.UseDeveloperExceptionPage();\r\n            }\r\n            app.UseGraphiQl();\r\n            app.UseRouting();\r\n            app.UseAuthorization();\r\n            app.UseEndpoints(endpoints =>\r\n            {\r\n                endpoints.MapControllers();\r\n            });\r\n        }\r\n\r\n public void ConfigureServices(IServiceCollection services)\r\n        {\r\n            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_3_0);\r\n\r\n            \r\n\t\t\tservices.AddSingleton<ISchema, UserTypeSchema>();\r\n            services.Configure<IISServerOptions>(options =>\r\n            {\r\n                options.AllowSynchronousIO = true;\r\n            });\r\n            services.AddLogging(builder => builder.AddConsole());\r\n            services.AddHttpContextAccessor();\r\n            services.AddAuthorization(options =>\r\n            {\r\n                options.AddPolicy(\"AuthenticatedUser\", p => p.RequireAuthenticatedUser());\r\n            });\r\n }\r\n```\r\n\r\nAny inputs, please..",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2161/comments",
    "author": "vikassharma5981",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2021-01-11T12:44:33Z",
        "body": "1. Please show the code where you use `DocumentExecuter/DocumentWriter`.\r\n2. Avoid using `AllowSynchronousIO`.\r\n3. What is `ContextServiceLocator` and how do you configure DI with it?"
      },
      {
        "user": "vikassharma5981",
        "created_at": "2021-01-11T14:22:06Z",
        "body": "```\r\n [HttpPost]\r\n        public async Task<IActionResult> Post([FromBody] GraphQLQuery query)\r\n        {\r\n            if (query == null) { throw new ArgumentNullException(nameof(query)); }\r\n            var inputs = query.Variables.ToInputs();\r\n            var executionOptions = new ExecutionOptions\r\n            {\r\n                Schema = _schema,\r\n                Query = query.Query,\r\n                Inputs = inputs,\r\n            };\r\n            var result = await _documentExecuter.ExecuteAsync(executionOptions);\r\n            return CreateWebResponse(result);\r\n        }\r\n```\r\nQuery class \r\n ```\r\npublic class GraphQLQuery\r\n    {\r\n        public string OperationName { get; set; }\r\n\r\n        public string Query { get; set; }\r\n\r\n        [JsonConverter(typeof(GraphQL.SystemTextJson.ObjectDictionaryConverter))]\r\n        public Dictionary<string, object> Variables { get; set; }\r\n    }\r\n```\r\n services.AddSingleton<ContextServiceLocator>();\r\n\r\n```\r\npublic class ContextServiceLocator\r\n    {\r\n        public ISalesOrderRepository SalesOrderRepository => _httpContextAccessor.HttpContext.RequestServices.GetRequiredService<ISalesOrderRepository>();\r\n\r\n        private readonly IHttpContextAccessor _httpContextAccessor;\r\n        public ContextServiceLocator(IHttpContextAccessor httpContextAccessor)\r\n        {\r\n            _httpContextAccessor = httpContextAccessor;\r\n        }\r\n    }\r\n\r\n```"
      },
      {
        "user": "sungam3r",
        "created_at": "2021-01-11T14:28:21Z",
        "body": "So I see that you use `System.Text.Json` which does not require `AllowSynchronousIO`. \r\n\r\n`_documentExecuter` is from `GraphQL.SystemTextJson` package. Right? \r\n\r\nAnd what is `CreateWebResponse` ?\r\n"
      },
      {
        "user": "vikassharma5981",
        "created_at": "2021-01-11T14:39:15Z",
        "body": "CreateWebResponse is just a wrapper which wraps the response in a  format \r\n\r\n```\r\n Response response = new Response();\r\n            if (result.Errors?.Count > 0)\r\n            {\r\n                response.Status = (int)HttpStatusCode.BadRequest;\r\n                response.Message = \"Error while fetching data\";\r\n                List<string> errors = new List<string>();\r\n                foreach (var item in result.Errors)\r\n                {\r\n                    errors.Add(item.Message);\r\n                }\r\n                response.Errors = errors;\r\n                return BadRequest(response);\r\n            }\r\n            else\r\n            {\r\n                response.Data = result.Data;\r\n                response.Status = (int)HttpStatusCode.OK;\r\n                return Ok(response);\r\n            }\r\n\r\n\r\n```\r\nIDocumentExecuter is derived out of GraphQL\r\nThis is from my controller \r\n```\r\nusing Extron.Graph.Models;\r\nusing GraphQL;\r\nusing GraphQL.Types;\r\nusing Microsoft.AspNetCore.Mvc;\r\nusing Microsoft.Extensions.Logging;\r\n\r\n```\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2021-01-11T15:09:08Z",
        "body": "Most likely the problem is that you are not using `IDocumentWriter` : `GraphQL.SystemTextJson.DocumentWriter` . Measure the executions time of your response object serialization. `System.Text.Json` can run for a very long time if configured incorrectly."
      },
      {
        "user": "vikassharma5981",
        "created_at": "2021-01-11T15:44:23Z",
        "body": "We are using the Graph only for the data retieval process as of now, not sure if I got your response correctly. \r\nYou want us to use IDocumentWriter to write the response serialization?\r\n\r\nIf yes then, can you guide us through sample?\r\n\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2021-01-11T16:46:46Z",
        "body": "> but 3.3 was taking more than 5 minutes to _execute_\r\n\r\nWhat does _execute_ mean? Pure execution time in `DocumentExecuter`? End-to-end round-trip client-server time?\r\nLet's first localize the problem. Measure the running time of the main units of your app. Maybe the problem is in a completely different place. Start with measuring this line ` var result = await _documentExecuter.ExecuteAsync(executionOptions);` "
      },
      {
        "user": "sungam3r",
        "created_at": "2021-02-17T01:02:30Z",
        "body": "Closed due to inactivity."
      }
    ]
  },
  {
    "number": 2132,
    "title": "Dynamic GraphObjectTypes",
    "created_at": "2021-01-05T11:11:26Z",
    "closed_at": "2021-02-17T01:03:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2132",
    "body": "I know that GraphQL is strongly-typed, so this is maybe impossible. I would still like to hear your feedback on how to handle our current use case.\r\n\r\nWe are wrapping a REST interface in our .NET Middleware and forward most of the data through GraphQL.NET to the frontend. The backend has some objects that look like this:\r\n\r\n```\r\n{ \r\n  \"type\": \"hello-world\",\r\n  \"value\": \"myValue\"\r\n}\r\n```\r\n\r\nThose can be inputs or outputs actually. Now the problem that we have is that the REST API used the value field to accept boolean, string or integer, meaning the way it is handled actually changes dynamically. It sometimes is used like this:\r\n\r\n```\r\n{ \r\n  \"type\": \"hello-number\",\r\n  \"value\": 1000\r\n}\r\n```\r\n\r\nOur current implementation always uses string for inputs/outputs on the value parameter, and we cast in the backend. It would be nicer though if we could accept inputs as either boolean, string or integer on the same field (meaning dynamic type). Is this possible in GraphQL at all? If yes, how would this be done?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2132/comments",
    "author": "ninomllr",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2021-01-05T13:36:22Z",
        "body": "I think that you just have to provide the desired conversion (adapter) in your REST API if it wraps GraphQL.NET specific bits."
      },
      {
        "user": "sungam3r",
        "created_at": "2021-02-17T01:03:48Z",
        "body": "Closed due to inactivity."
      }
    ]
  },
  {
    "number": 2082,
    "title": "Subscription with Entity Framework and repository pattern",
    "created_at": "2021-01-01T12:34:59Z",
    "closed_at": "2023-04-23T18:12:12Z",
    "labels": [
      "question",
      "subscriptions"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2082",
    "body": "Is possible to get any example? How is possible to use subscription with entity framework and repository pattern.\r\n\r\nMy schema is registered like singleton\r\n\r\nI have mutation for post likes, with adding notification. I want to subscribe notifications to get information about likes. \r\n\r\nCode for mutation is below:\r\n\r\n```\r\n  public class Mutation\r\n    {\r\n        private void Mutation()\r\n        {\r\n            Field<NonNullGraphType<BooleanGraphType>, bool>(\"SetPostLike\")\r\n                .Argument<NonNullGraphType<StringGraphType>>(\"postId\")\r\n                .Argument<NonNullGraphType<BooleanGraphType>>(\"status\")\r\n                .ResolveScopedAsync(SetPostLike);\r\n        }\r\n\r\n        private async Task<bool> SetPostLike<T>(IResolveFieldContext<T> context, IServiceProvider serviceProvider)\r\n        {\r\n            var uow = serviceProvider.GetRequiredService<IUnitOfWork>();\r\n            var postId = context.GetArgument<string>(\"postId\");\r\n            var status = context.GetArgument<bool>(\"status\");\r\n            var user = context.GetUserContext().User;\r\n            using (IDbContextTransaction transaction = uow.BeginTransaction())\r\n            {\r\n                try\r\n                {\r\n                    if (status)\r\n                    {\r\n                        await uow.PostRepository.AddPostLikeAsync(user.Id, postId);\r\n                        await uow.NotificationRepository.AddNotificationAsync(user.Id, postId, NotifiType.AddPostLike);\r\n                    }\r\n                    else\r\n                    {\r\n                        await uow.PostRepository.RemovePostLikeAsync(user.Id, postId);\r\n                    }\r\n                    transaction.Commit();\r\n                    return true;\r\n                }\r\n                catch (Exception)\r\n                {\r\n                    transaction.Rollback();\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n```\r\nMy repository code is below:\r\n\r\n```\r\n    public class UnitOfWork : IUnitOfWork, IDisposable\r\n    {\r\n        private bool _disposed;\r\n        private readonly InseritasDbContext _context;\r\n        public UnitOfWork(\r\n            InseritasDbContext context,\r\n            INotificationRepository notificationRepo,\r\n            IPostRepository postRepo\r\n            )\r\n        {\r\n            _context = context;\r\n           \r\n            NotificationRepository = notificationRepo;\r\n            PostRepository = postRepo;\r\n        }\r\n\r\n        public INotificationRepository NotificationRepository { get; }\r\n        public IPostRepository PostRepository { get; }\r\n\r\n        public int SaveChanges()\r\n        {\r\n            return _context.SaveChanges();\r\n        }\r\n\r\n        public IDbContextTransaction BeginTransaction()\r\n        {\r\n            return _context.Database.BeginTransaction();\r\n        }\r\n    }\r\n\r\n    public class PostRepository : BaseRepository, IPostRepository\r\n    {\r\n        public async Task AddPostLikeAsync(string userId, string postId)\r\n        {\r\n            Likes.Add(new Like()\r\n            {\r\n                PostId = postId,\r\n                UserId = userId,\r\n                CreateDate = DateTime.UtcNow\r\n            });\r\n            await SaveAsync();\r\n        }\r\n    }\r\n\r\n    public class NotificationRepository : BaseRepository, INotificationRepository\r\n    {\r\n        public async Task AddNotificationAsync(string senderId, string sourceId, NotifiType type)\r\n        {\r\n            //logic for add notification to DB\r\n        }\r\n    }\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2082/comments",
    "author": "Risbot",
    "comments": [
      {
        "user": "Jonatthu",
        "created_at": "2021-01-03T02:50:45Z",
        "body": "Try observables, I did an observable service that basically fires every single time that my Generic repository detect changes, with Entity Change Tracker! Then on subscription method you can subscribe to the observable."
      },
      {
        "user": "Shane32",
        "created_at": "2023-04-23T18:12:12Z",
        "body": "> Try observables, I did an observable service that basically fires every single time that my Generic repository detect changes, with Entity Change Tracker! Then on subscription method you can subscribe to the observable.\r\n\r\nI did the same.  Sorry I can't share the code, but ask if you have questions.  Closing for now."
      }
    ]
  },
  {
    "number": 2040,
    "title": "Is there a way to be warned that a subscription was closed ?",
    "created_at": "2020-12-09T14:24:20Z",
    "closed_at": "2020-12-14T08:43:31Z",
    "labels": [
      "question",
      "subscriptions"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2040",
    "body": "## Summary\r\nI am trying to use the subscription, and it works wonderfully so far.\r\nHowever, I need to know when the client closed the subscription (for whatever reason), so I can cleanup on the server side.\r\nIs there a way to do that ?\r\nI am not very familiar with the Reactive namespace...\r\nI used SignalR in the past, which uses `ChannelWriter<T>` and `ChannelReader<T>` to model subscriptions, which does provide some signaling (including support for CancellationTokens) to handle that.\r\n\r\nI found the HasObservers property on the ReplaySubject and managed to cobble something together, but it needs to account for publishing before the Observer has subscribed, which leads to ugly code...\r\n\r\nIs there anything in GraphQL or Reactive for that problem ?\r\n\r\n### Environment (if relevant)\r\n.Net 5, GraphQL 3.1.6",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2040/comments",
    "author": "denis-troller",
    "comments": [
      {
        "user": "denis-troller",
        "created_at": "2020-12-14T08:43:31Z",
        "body": "Nevermind, \r\n\r\nI just realised I just need to implement my own `IObservable` / `IDisposable` object and all will be well.\r\nUpon closing of the webSocket connection, GraphQL-Dotnet will dispose() the IObservable.\r\n\r\nI will open a suggestion to add that to the docs though.\r\n "
      },
      {
        "user": "Smiloh",
        "created_at": "2021-08-21T14:45:47Z",
        "body": "> Nevermind,\r\n> \r\n> I just realised I just need to implement my own `IObservable` / `IDisposable` object and all will be well.\r\n> Upon closing of the webSocket connection, GraphQL-Dotnet will dispose() the IObservable.\r\n> \r\n> I will open a suggestion to add that to the docs though.\r\n\r\nHello,\r\n\r\nDo you have any example?\r\n\r\nThank you"
      },
      {
        "user": "flieks",
        "created_at": "2021-11-28T14:45:42Z",
        "body": "@denis-troller An example would be appreciated.. Tried implementing it but it is not an easy subject :)"
      }
    ]
  },
  {
    "number": 2026,
    "title": "NonNullable Connections",
    "created_at": "2020-11-24T11:07:43Z",
    "closed_at": "2020-12-02T08:34:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2026",
    "body": "Hey.\r\nI'm working on a project, where we need to make non optional connections, and I can't really find anything on the subject.\r\nI made the fields work with the NonNullableGraphType as shown beneath, but I have no luck getting the connections to be non nullable.\r\nI've searched far and wide, and can't find anything about the issue, so I hope someone can help me here, as I'm completely lost.\r\nThe fields that are non nullable are written as such:\r\n\r\n            Field<NonNullGraphType<OrderPresetGraphType>>(\r\n                \"preset\",\r\n                resolve: context => {\r\n                    var loader = dataLoader.Context.GetOrAddBatchLoader<int, Base.Entities.Orders.OrderPreset>(\r\n                        \"OrderPresetById\", orderPresetController.GetOrderPresetsByIdAsync\r\n                    );\r\n\r\n                    return loader.LoadAsync(context.Source.PresetId);\r\n                }\r\n            );\r\nSadly, the same method doesn't work with lists. \r\nAny help is much appreciated! ",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2026/comments",
    "author": "oliverlowbob",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2020-11-24T16:03:42Z",
        "body": "What code are you using now for nullable connections?"
      },
      {
        "user": "oliverlowbob",
        "created_at": "2020-11-24T16:05:46Z",
        "body": "> What code are you using now for nullable connections?\r\n\r\nI've tried in the same way, as I got the Fields to work:\r\n\r\n            Connection<NonNullGraphType<AssetFilterPresetFieldGraphType>>()\r\n                .Name(\"fields\")\r\n                .Unidirectional()\r\n                .Description(\"Returns a list of AssetFilterPresetFieldGraphType connected to this AsetFilterPresetGraphType\")\r\n                .ResolveAsync(async context =>\r\n                {\r\n                    var result = await assetFilterPresetController.GetFilterPresetFieldsByIdAsync(context.Source.Id)\r\n                        .ConfigureAwait(false);\r\n\r\n                    return ConnectionResolver.ToConnection(result.Data, context);\r\n                });"
      },
      {
        "user": "Shane32",
        "created_at": "2020-11-24T16:35:51Z",
        "body": "Looks good so far.  What problem are you seeing?"
      },
      {
        "user": "oliverlowbob",
        "created_at": "2020-11-24T16:57:02Z",
        "body": "> Looks good so far. What problem are you seeing?\r\n\r\nMy front-end is not recieving the connection as non nullable, and I'm recieving errors, that the fields in the connection, that are set to non nullable, is returning null. Also, it's worth to mention that I'm working in .NET 4.7.2"
      },
      {
        "user": "Shane32",
        "created_at": "2020-11-24T17:30:49Z",
        "body": "can you copy and paste the error message and stack trace?"
      },
      {
        "user": "oliverlowbob",
        "created_at": "2020-11-25T08:54:44Z",
        "body": "Actually, there's no direct errors, but my front-end needs to know, if its nullable or not, and with fields it gets the right information like this:\r\nname: String! \r\n\r\nBut with the connections, it doesn't, and it looks like this:\r\nstages(after: String, first: Int): OrderPresetWorkflowStageConnection\r\n\r\nAnd with the nonnullablegraphtype, it's only the items that becomes non-nullable, not the connection itself.\r\n\r\nThis is how it looks now:\r\n\r\n```\r\ntype OrderPresetWorkflowGraphType {\r\n  ...\r\n  name: String!\r\n  stages(after: String, first: Int): OrderPresetWorkflowStageConnection\r\n}\r\ntype OrderPresetWorkflowStageActionConnection {\r\n  totalCount: Int\r\n  pageInfo: PageInfo!\r\n  edges: [OrderPresetWorkflowStageActionEdge]\r\n  items: [OrderPresetWorkflowStageActionGraphType]\r\n}\r\ntype OrderPresetWorkflowStageActionEdge {\r\n  cursor: String!\r\n  node: OrderPresetWorkflowStageActionGraphType\r\n}\r\n\r\n```\r\nAnd this is how I would want it to look:\r\n\r\n```\r\ntype OrderPresetWorkflowGraphType {\r\n  ...\r\n  stages(after: String, first: Int): OrderPresetWorkflowStageConnection!\r\n}\r\ntype OrderPresetWorkflowStageActionConnection {\r\n  totalCount: Int!\r\n  pageInfo: PageInfo!\r\n  edges: [OrderPresetWorkflowStageActionEdge!]!\r\n  items: [OrderPresetWorkflowStageActionGraphType!]!\r\n}\r\ntype OrderPresetWorkflowStageActionEdge {\r\n  cursor: String!\r\n  node: OrderPresetWorkflowStageActionGraphType!\r\n}\r\n\r\n```\r\n\r\nI hope it makes sense.\r\n\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2020-11-25T14:35:58Z",
        "body": "You probably need to define your own connection types and logic. You can probably finesse the “stages” field to be non nullable, but I don’t think there’s a way to make “edges” and “items” and “totalCount” return the non nullable types you are looking for without rewriting the connection types. "
      },
      {
        "user": "Shane32",
        "created_at": "2020-11-25T14:40:28Z",
        "body": "“node” should return the correct non nullable type....."
      },
      {
        "user": "oliverlowbob",
        "created_at": "2020-11-26T11:07:39Z",
        "body": "Ahh okay, thanks for the help! I'll look into it "
      },
      {
        "user": "oliverlowbob",
        "created_at": "2020-11-26T14:57:49Z",
        "body": "I've tried to make my own connection type, and inject it, like I did with the one provided by GraphQL, through a ContainerBuilder, but I'm getting a ComponentNotRegisteredException. Do you have any idea how to solve this issue?"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-11-26T15:07:58Z",
        "body": "Register your GraphType in DI. "
      },
      {
        "user": "oliverlowbob",
        "created_at": "2020-11-26T15:48:02Z",
        "body": "> Register your GraphType in DI.\r\n\r\nIf I understand what you're saying, then I've already done that, like this:\r\n\r\n```\r\npublic class GraphQLEntityModule : Autofac.Module\r\n        {\r\n            protected override void Load(ContainerBuilder builder)\r\n            {\r\n                var assembly = Assembly.GetExecutingAssembly();\r\n\r\n                builder.RegisterAssemblyTypes(assembly)\r\n                   .Where(t => t.IsInNamespace(\"MediaCloud.API.GraphQL.Types\"))\r\n                   .SingleInstance();\r\n            }\r\n        }\r\n\r\n```\r\n\r\nAnd I did it like this for the ConnectionType(McConnectionType) and EdgeType(McEdgeType), which works fine:\r\n\r\n         builder.RegisterGeneric(typeof(ConnectionType<>));\r\n\r\n         builder.RegisterGeneric(typeof(EdgeType<>));\r\n\r\nBut when I do the same for the new ConnectionType and EdgeType, I'm getting this:\r\n\r\n_The requested service 'MediaCloud.API.GraphQL.Relay.McConnectionType`2[[MediaCloud.API.GraphQL.Types.Orders.OrderTerritoryGraphType, MediaCloudAPI, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null],[MediaCloud.API.GraphQL.Relay.McEdgeType`1[[MediaCloud.API.GraphQL.Types.Orders.OrderTerritoryGraphType, MediaCloudAPI, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], MediaCloudAPI, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]' has not been registered. To avoid this exception, either register a component to provide the service, check for service registration using IsRegistered(), or use the ResolveOptional() method to resolve an optional dependency._"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-11-26T17:22:09Z",
        "body": "Apparently there is some problem with registration in your container."
      },
      {
        "user": "oliverlowbob",
        "created_at": "2020-12-01T08:33:08Z",
        "body": "I figured it out.\r\nI needed to add a , to the autofac registration like this:\r\n```\r\nbuilder.RegisterGeneric(typeof(McConnectionType<>)).SingleInstance();\r\nbuilder.RegisterGeneric(typeof(McConnectionType<,>)).SingleInstance();\r\n```\r\n\r\nThanks for the help!"
      }
    ]
  },
  {
    "number": 1939,
    "title": "JSONProperty not used in GetArgument",
    "created_at": "2020-10-23T11:23:13Z",
    "closed_at": "2020-10-31T19:19:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1939",
    "body": "I have an issue with Deserializing of Graphl.NET because the [JsonProperty(\"name\")] that we put into our models are not recognized by GraphQL.NET in the function GetArgument. As we are using Newtonsoft to Serialize/Deserialize I assumed that we can just install the GraphQL.Client.Serializer.Newtonsoft NuGet package, but I didn't see a change. Is this a bug? Or do I somewhere need to configure which JSON Library is used?\r\n\r\nQuoteInputType.cs\r\n```\r\nusing GraphQL.Types;\r\nusing app.backend.business.Models;\r\n\r\nnamespace app.backend.GraphQLModels.InputTypes\r\n{\r\n    public class QuoteInputType : InputObjectGraphType<QuoteInput>\r\n    {\r\n        public QuoteInputType()\r\n            {  \r\n                Name = nameof(QuoteInputType);\r\n                \r\n                Field(x => x.ProductId, nullable:false).Name(\"product_id\");\r\n                Field(x => x.PaymentFrequency, nullable:true).Name(\"payment_frequency\");\r\n            }\r\n        \r\n        }\r\n}\r\n```\r\n\r\nQuoteInput.cs\r\n```\r\nusing System.Collections.Generic;\r\nusing Newtonsoft.Json;\r\nnamespace app.backend.business.Models {\r\n\r\n    public class QuoteInput\r\n    {\r\n        [JsonProperty(\"product_id\")]\r\n        public string ProductId { get; set; }\r\n\r\n        [JsonProperty(\"payment_frequency\")]\r\n        public string PaymentFrequency { get; set; }\r\n    }\r\n}\r\n```\r\n\r\nGraphQLQuery.cs (just a snippet)\r\n```\r\n             Field<QuoteType>(\r\n                name: \"quote\",\r\n                arguments: new QueryArguments(\r\n                    new QueryArgument<QuoteInputType>() { Name = \"data\" }\r\n                ),\r\n                resolve: context =>\r\n                {\r\n                    var data = context.GetArgument<QuoteInput>(\"data\");\r\n                    Quote result = myService.GetQuotes(data);\r\n                    return result;\r\n                }\r\n            );\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1939/comments",
    "author": "ninomllr",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-10-23T13:24:53Z",
        "body": "`GetArgument` has nothing to do with Newtonsoft.Json or any other attributes. What version of GraphQL.NET do you use?"
      },
      {
        "user": "ninomllr",
        "created_at": "2020-10-23T13:59:53Z",
        "body": "It looks like it was a version issue. I upgraded now and I came one step furher. In my app.backend.api Project i have the following package references.\r\n\r\n```\r\n    <PackageReference Include=\"GraphQL.Authorization\" Version=\"3.0.43\" />\r\n    <PackageReference Include=\"GraphQL.Server.Transports.AspNetCore\" Version=\"4.0.1\" />\r\n    <PackageReference Include=\"GraphQL.Server.Transports.WebSockets\" Version=\"4.0.1\" />\r\n    <PackageReference Include=\"GraphQL.Server.Transports.AspNetCore.NewtonsoftJson\" Version=\"4.0.1\" />\r\n    <PackageReference Include=\"GraphQL.Server.Ui.GraphiQL\" Version=\"4.0.1\" />\r\n    <PackageReference Include=\"GraphQL.Server.Ui.Playground\" Version=\"4.0.1\" />\r\n    <PackageReference Include=\"GraphQL.Server.Ui.Voyager\" Version=\"4.0.1\" />\r\n```\r\n\r\nIn the startup.cs I have the following parts of code\r\n\r\n```\r\n  services.AddSingleton<IDocumentExecuter, DocumentExecuter>();\r\n  services.AddSingleton<IDocumentWriter, GraphQL.NewtonsoftJson.DocumentWriter>();\r\n  services.AddGraphQL(options =>\r\n            {\r\n                options.EnableMetrics = true;\r\n                // options.ExposeExceptions = false; // false prints message only, true will ToString\r\n                options.UnhandledExceptionDelegate = context =>\r\n                {\r\n                    Console.WriteLine(\"Error: \" + context.OriginalException.Message);\r\n                };\r\n            })\r\n            .AddNewtonsoftJson(configureDeserializerSettings => {}, configureSerializerSettings => {})\r\n```\r\nI have another project where I define GraphQL Types, InputTypes, Mutations and Queries and so on which is called app.backend.GraphQL. I add the following package references there. \r\n\r\n```\r\n  <ItemGroup>\r\n    <PackageReference Include=\"GraphQL\" Version=\"3.1.0\" />\r\n    <PackageReference Include=\"GraphQL.Authorization\" Version=\"3.0.43\" />\r\n    <PackageReference Include=\"GraphQL.NewtonsoftJson\" Version=\"3.0.0.2026\" />\r\n    <PackageReference Include=\"Microsoft.AspNetCore.Http.Abstractions\" Version=\"2.2.0\" />\r\n    <PackageReference Include=\"Microsoft.AspNetCore.Http\" Version=\"2.2.2\" />\r\n    <PackageReference Include=\"Newtonsoft.Json\" Version=\"12.0.3\" />\r\n\r\n  </ItemGroup>\r\n```\r\n\r\nWhen I have a simple input type I can use JsonProperty to map my GraphQL Field to a Property, like in product_id and it works. But when I use a ListGraphType and have to use a custom resolver then it doesn't map it anymore and the property stays null, i.e. in payment_frequency.\r\n\r\n\r\nQuoteInputType.cs\r\n```\r\n\r\nusing GraphQL.Types;\r\nusing app.backend.business.Models;\r\n\r\nnamespace app.backend.GraphQLModels.InputTypes\r\n{\r\n    public class QuoteInputType : InputObjectGraphType<QuoteInput>\r\n    {\r\n        public QuoteInputType()\r\n            {  \r\n                Name = nameof(QuoteInputType);\r\n                \r\n                Field(x => x.ProductId, nullable:false).Name(\"product_id\"); // works!\r\n                Field<ListGraphType<PaymentFrequencyInputType>>(\"payment_frequency\", resolve: context => context.Source.PaymentFrequency); // doesn't work, PaymentFrequency always stays null\r\n            }\r\n        \r\n        }\r\n}\r\n```\r\nQuoteInput.cs\r\n```\r\n\r\nusing System.Collections.Generic;\r\nusing Newtonsoft.Json;\r\nnamespace app.backend.business.Models {\r\n\r\n    public class QuoteInput\r\n    {\r\n        [JsonProperty(\"product_id\")]\r\n        public string ProductId { get; set; }\r\n\r\n        [JsonProperty(\"payment_frequency\")]\r\n        public List<PaymentFrequencyInput> PaymentFrequency { get; set; }\r\n    }\r\n}\r\n```\r\nGraphQLQuery.cs (just a snippet)\r\n```\r\n\r\n             Field<QuoteType>(\r\n                name: \"quote\",\r\n                arguments: new QueryArguments(\r\n                    new QueryArgument<QuoteInputType>() { Name = \"data\" }\r\n                ),\r\n                resolve: context =>\r\n                {\r\n                    var data = context.GetArgument<QuoteInput>(\"data\");\r\n                    Quote result = myService.GetQuotes(data);\r\n                    return result;\r\n                }\r\n            );\r\n\r\n```\r\nCan someone explain to me what I am doing wrong?"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-10-23T14:12:16Z",
        "body": "We can start by looking at what request text (with variables) comes from the client."
      },
      {
        "user": "ninomllr",
        "created_at": "2020-10-23T14:25:13Z",
        "body": "Query (sent through Playground and Postman, same behaviour)\r\n\r\n```\r\nquery {\r\n  quote(\r\n    data: { product_id: \"my_id\", payment_frequency: { value: \"frequency\" } }\r\n  ) {\r\n    product_id\r\n  }\r\n}\r\n\r\n```\r\nNow I use the debugger on the \"quote\" query and have the following inputs: \r\ncontext.Arguments\r\n```\r\nCount = 1\r\n[0] [KeyValuePair]:{[data, System.Collections.Generic.Dictionary`2[System.String,System.Object]]}\r\nKey [string]:\"data\"\r\nValue [object]:Count = 2\r\n[0] [KeyValuePair]:{[product_id, my_id]}\r\nKey [string]:\"product_id\"\r\nValue [object]:\"my_id\"\r\nNon-Public members\r\n[1] [KeyValuePair]:{[payment_frequency, System.Object[]]}\r\nKey [string]:\"payment_frequency\"\r\nValue [object]:{object[1]}\r\n[0] [object]:Count = 1\r\nNon-Public members\r\n[0] [KeyValuePair]:{[value, frequency]}\r\nKey [string]:\"value\"\r\nValue [object]:\"frequency\"\r\nNon-Public members\r\nRaw View\r\nRaw View\r\nNon-Public members\r\n```\r\n\r\nWhat I have after the GetVariable in var data:\r\n```\r\nPaymentFrequency [List]:null\r\nProductId [string]:\"my_id\"\r\n```\r\n\r\nSo the mapping did work for the product_id --> ProductId but not for payment_frequency --> PaymentFrequency.\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-10-23T15:09:44Z",
        "body": "Try this:\r\n```graphql\r\nquery {\r\n  quote(\r\n    data: { product_id: \"my_id\", payment_frequency: [{ value: \"frequency\" }] }\r\n  ) {\r\n    product_id\r\n  }\r\n}\r\n\r\n```"
      },
      {
        "user": "ninomllr",
        "created_at": "2020-10-23T15:34:22Z",
        "body": "Interesting that I didn't get an exception with the other one...\r\n\r\nAnyway, the behaviour is the same, the payment_frequency is still null.\r\n\r\ncontext.Arguments\r\n```\r\nCount = 1\r\n[0] [KeyValuePair]:{[data, System.Collections.Generic.Dictionary`2[System.String,System.Object]]}\r\nKey [string]:\"data\"\r\nValue [object]:Count = 2\r\n[0] [KeyValuePair]:{[product_id, my_id]}\r\n[1] [KeyValuePair]:{[payment_frequency, System.Collections.Generic.List`1[System.Object]]}\r\nKey [string]:\"payment_frequency\"\r\nValue [object]:Count = 1\r\n[0] [object]:Count = 1\r\n[0] [KeyValuePair]:{[value, frequency]}\r\nRaw View\r\nRaw View\r\nNon-Public members\r\nRaw View\r\nNon-Public members\r\n```\r\n\r\nI realized that my problem exists even if i don't have list, but it is somehow connected to me using the custom resolve function.\r\n`\r\n Field<ListGraphType<PaymentFrequencyInputType>>(\"payment_frequency\", resolve: context => context.Source.PaymentFrequency);`"
      },
      {
        "user": "ninomllr",
        "created_at": "2020-10-23T16:06:52Z",
        "body": "Another thing that I tested right now. When I add a Property with the exact name as the GraphQL input, it can map it to that field. \r\n\r\n```\r\nusing System.Collections.Generic;\r\nusing Newtonsoft.Json;\r\nnamespace app.backend.business.Models {\r\n\r\n    public class QuoteInput\r\n    {\r\n        [JsonProperty(\"product_id\")]\r\n        public string ProductId { get; set; } // this field gets the data\r\n\r\n        [JsonProperty(\"payment_frequency\")]\r\n        public List<PaymentFrequencyInput> PaymentFrequency { get; set; } // this field doesn't get the data and stays null\r\n\r\n        public PaymentFrequencyType payment_frequency { get; set; } // this field gets the data\r\n    }\r\n```"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-10-23T17:46:50Z",
        "body": "> I realized that my problem exists even if i don't have list, but it is somehow connected to me using the custom resolve function.\r\n\r\nSorry, I completely forgot that resolvers for inputs are not supported. See #1176 and related issues."
      },
      {
        "user": "ninomllr",
        "created_at": "2020-10-23T21:04:18Z",
        "body": "Ah okay, thanks for clearing this up.\r\n\r\nFor all the people struggling with this as well, I found a working solution for my case:\r\n\r\n`Field(x => x.PaymentFrequency, nullable: true, typeof(List<PaymentFrequencyInput>)).Name(\"payment_frequency\");`\r\n\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-10-23T22:07:45Z",
        "body": "Do you have other questions? Can this issue be closed?"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-10-31T19:19:07Z",
        "body": "Closed as resolved."
      }
    ]
  },
  {
    "number": 1934,
    "title": "ReadonlyResolveFieldContext  in 3.0.0.2026",
    "created_at": "2020-10-22T22:13:13Z",
    "closed_at": "2020-10-23T13:30:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1934",
    "body": "In earlier versions I was able to modify the global ResolveFieldContext as follows:\r\n```\r\n public object Resolve(IResolveFieldContext rfc)\r\n....\r\nrfc.Arguments = new Dictionary<string, object>(rfc.Arguments,StringComparer.InvariantCultureIgnoreCase);\r\n.....\r\n```\r\n\r\nThe goal being to allow for arguments to be case-insensitive.\r\nThe current version, because it is read-only, I'm not able to make this modification anymore.\r\n\r\nIs there any way around this problem - ideally this would just be like a configuration setting or something.\r\n\r\nLet me know - thanks for your time!\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1934/comments",
    "author": "OpenSpacesAndPlaces",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-10-22T22:27:43Z",
        "body": "By the way we still have `ResolveFieldContext` with setters.\r\nI see one way to quickly resolve your issue on your side - just get `_arguments` field from `ReadonlyResolveFieldContext` with Reflection and set the new value. @Shane32 do we want to provide a case-insensitive option for getting arguments? I doubt."
      },
      {
        "user": "Shane32",
        "created_at": "2020-10-22T22:57:03Z",
        "body": "@OpenSpacesAndPlaces Be aware that calls to `GetArgument` will run the provided argument name through the schema's `NameConverter`, which in its default configuration converts names to camel case.  So, calling `GetArgument<string>(\"Test\")` will match on an argument with the name of `test`.\r\n\r\nThere had been a bug where `HasArgument(\"Test\")` would not match, but this was fixed in #1549 \r\n\r\nAs it relates to your needs, you can of course use reflection to patch your old code as @sungam3r described.  You can also use middleware to wrap the `IResolveFieldContext` with a custom implementation that returns a case-insensitive version of the dictionary when requested.\r\n\r\nIf you were writing new code, I would suggest using `GetArgument` and `HasArgument`, or writing your own extension methods as necessary.  Since `ResolveFieldContext` is now an interface, extension methods will apply to any derived class, which is very nice.  `Arguments` is really only designed for access to the raw list of arguments provided to the field.\r\n\r\n@sungam3r I would consider making `Arguments` return a case-insensitive dictionary **if** the graphql spec requires argument names to be unique by more than just case.  We still need to pass names through the name converter in case more has changed than case.  Similarly, people should use the `GetArgument` and `HasArgument` methods so that it runs through the name converter regardless of whether only the case has changed.  Looking at the other side of the argument, returning a case-insensitive dictionary would probably be a nice feature for certain uses.  For example, I have code that passes the entire dictionary of arguments through to the `Source` property of a child graph.  `GetArgument` and `HasArgument` are not accessible in that scenario.  A case-insensitive match would be convenient, although not necessary.\r\n\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-10-23T11:51:16Z",
        "body": "I am inclined to believe that we should not do support for this particular case. We already have name converters. If someone need special processing for args, then he can take the `Arguments` dictionary directly from resolve context and do whatever. In fact `ResolveFieldContextExtensions` is just extensions."
      },
      {
        "user": "OpenSpacesAndPlaces",
        "created_at": "2020-10-23T13:30:54Z",
        "body": "Thanks for all the time and thought on this.\r\nThat gives me a few options for adjusting.\r\n\r\n\r\n"
      },
      {
        "user": "OpenSpacesAndPlaces",
        "created_at": "2020-10-23T18:56:08Z",
        "body": "I wanted to a tiny bit more background in-case this comes again.\r\nThe remembered reason was because - often people declare classes in Pascal, but then they are auto-converted Camel.\r\n\r\nThen coming back in it's now camel vs. pascal (unless you convert or the other).\r\n\r\nBut as you mentioned - it sounds like 1549 covers the base case - the only residual problem is any customization/existence checking."
      }
    ]
  },
  {
    "number": 1880,
    "title": "Scoped resolution with the new data loader",
    "created_at": "2020-09-28T08:47:38Z",
    "closed_at": "2021-02-17T01:00:15Z",
    "labels": [
      "question",
      "data loader"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1880",
    "body": "So I'm getting an object disposed exception when I tried to use the scoped extension method with the new data loader. It says the DbContext is disposed. Also tried to use `GetResultAsync()` directly to no avail. \r\n```c#\r\n            Field<NonNullGraphType<CategoryType>, Category>()\r\n                .Name(\"category\")\r\n                .ResolveScopedAsync(async (ctx, serviceProvider) =>\r\n                {\r\n                    var sparesContext = serviceProvider\r\n                        .GetRequiredService<SparesContext>();\r\n\r\n                    var loader = dataLoaderContextAccessor.Context\r\n                        .GetOrAddBatchLoader<int, Category>(\r\n                            DataLoaderConstants.GetCategoryById,\r\n                            async ids => await sparesContext\r\n                                .Categories\r\n                                .Where(c => ids.Contains(c.Id))\r\n                                .ToDictionaryAsync(c => c.Id)\r\n                        );\r\n\r\n                    var category = loader.LoadAsync(ctx.Source.CategoryId);\r\n\r\n                    return category;\r\n                });\r\n\r\nalso tried,\r\n\r\n                    var category = await loader.LoadAsync(ctx.Source.CategoryId).GetResultAsync();\r\n                    return category;\r\n```\r\n(`ResolveScopedAsync` is implemented as shown in the docs.)\r\n\r\n@Shane32 any thoughts on this?\r\n\r\nEdit: Only way I could get it work again was by injecting the service provider into the objectgraphtype in the constructor (having changed the registration back to scoped). Looks to me like the scope in `ResolveScopedAsync` gets disposed before the query executes.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1880/comments",
    "author": "avin-kavish",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2020-09-28T12:33:59Z",
        "body": "You’re creating the scope during the field resolution, but data loaders by design don’t execute then but rather later after all the fields that might need the data loader have executed. You need to create a scope within the data loader fetch delegate and obtain the dbcontext from DI there. "
      },
      {
        "user": "Shane32",
        "created_at": "2020-09-28T14:29:59Z",
        "body": "I didn't check this code, but this is generally what you're looking for.\r\n\r\n```csharp\r\n            Field<NonNullGraphType<CategoryType>, Category>()\r\n                .Name(\"category\")\r\n                .Resolve(ctx =>\r\n                {\r\n\r\n                    var loader = dataLoaderContextAccessor.Context\r\n                        .GetOrAddBatchLoader<int, Category>(\r\n                            DataLoaderConstants.GetCategoryById,\r\n                            async ids => {\r\n                                //create the scope inside the data loader (need a reference to any IServiceProvider to use CreateScope)\r\n                                using var scope = ctx.RequestServices.CreateScope();\r\n                                //grab the service provider from the scope\r\n                                var serviceProvider = scope.ServiceProvider;\r\n                                //grab the data context from the scope\r\n                                var sparesContext = serviceProvider\r\n                                    .GetRequiredService<SparesContext>();\r\n                                //execute the database call\r\n                                return await sparesContext\r\n                                    .Categories\r\n                                    .Where(c => ids.Contains(c.Id))\r\n                                    .ToDictionaryAsync(c => c.Id);\r\n                                };\r\n                        );\r\n\r\n                    var category = loader.LoadAsync(ctx.Source.CategoryId);\r\n\r\n                    return category;\r\n                });\r\n```"
      },
      {
        "user": "sungam3r",
        "created_at": "2021-02-17T01:00:15Z",
        "body": "Closed as answered. No activity here."
      }
    ]
  },
  {
    "number": 1839,
    "title": "Detailed performance data with Azure Application Insights",
    "created_at": "2020-09-04T08:25:28Z",
    "closed_at": "2021-02-14T20:31:47Z",
    "labels": [
      "question",
      "nice-to-document"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1839",
    "body": "##  Summary\r\nAzure Application Insights automatically shows the performance of REST API's per endpoint (ex. /users, /settings/general, etc...) but with graphQL we only get one endpoint (/graphql) which makes sense, but has anyone found an easy way to track performance per GraphQL query?\r\n\r\nFor now my plan is to manually make custom telemetry measurements for each query type that I have. Which will be quite long to make. Do you know of any existing library or do you have a more efficient way?\r\n\r\nThanks!\r\nIf I find a better way I'll add it here below.\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1839/comments",
    "author": "julienFlexsoft",
    "comments": [
      {
        "user": "BenjaBobs",
        "created_at": "2020-09-04T08:31:09Z",
        "body": "You could create a listener that hooks in after the execution and uses the apollo tracing data to synthesize the application insights data. You could do it as traces or dependencies or whatever you like."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-09-04T19:32:17Z",
        "body": "@Shane32 I made a special label to better track such questions."
      }
    ]
  },
  {
    "number": 1817,
    "title": "Add minimum 1 field requirement to query argument of InputObjectGraphType",
    "created_at": "2020-08-27T16:00:01Z",
    "closed_at": "2020-10-31T18:35:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1817",
    "body": "Hello ,\r\n\r\nI have a complex input object graph type  as a query argument field. For example :\r\n```\r\n    myEntity(\r\n      first:10000 \r\n      filter:  { \r\n        year: {_gt:2000}\r\n      }\r\n    ){\r\n```\r\nIf you add the filter argument , then you should add at least 1 entry/column  in the filter. So it can be caught at developer's qraphiQl.\r\n\r\nCan this error be raised at graphiQL user typing like nullable types ? (I am guessing it cannot be done )\r\nCan this be done at runtime? If it is done at runtime should I use validation rules or throw Argument exceptions whenever I see a missing expected value?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1817/comments",
    "author": "ovidiubuligan",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-08-27T16:37:54Z",
        "body": "> Can this be done at runtime?\r\n\r\nYes.\r\n\r\n> should I use validation rules or throw Argument exceptions whenever I see a missing expected value?\r\n\r\nYou can use both.\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-08-28T23:51:55Z",
        "body": "@ovidiubuligan if you were able to solve the problem then please close this issue."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-10-31T18:35:53Z",
        "body": "Closed due to lack of feedback."
      }
    ]
  },
  {
    "number": 1815,
    "title": "Is it possible to not wrap response int a 'data' field?",
    "created_at": "2020-08-26T13:33:07Z",
    "closed_at": "2020-08-26T13:40:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1815",
    "body": "Hi,\r\n\r\nWhenever I execute a query like this:\r\n```graphql\r\n{\r\n  users {\r\n    id\r\n    username\r\n  }\r\n}\r\n```\r\nThe response is formatted like this:\r\n```json\r\n{\r\n  \"data\": {\r\n    \"users\": [\r\n      {\r\n        \"id\": 1,\r\n        \"username\": \"test\"\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nIs it possible to receive the response without the \"data\" property like this?\r\n(I am using a library that uses graphql but doesn't process the endpoint's response and I'm guessing that this might be the cause)\r\n```json\r\n{\r\n  \"users\": [\r\n    {\r\n      \"id\": 1,\r\n      \"username\": \"test\"\r\n    }\r\n  ]\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1815/comments",
    "author": "koppa96",
    "comments": [
      {
        "user": "BenjaBobs",
        "created_at": "2020-08-26T13:39:01Z",
        "body": "It wouldn't follow the graphql spec then. I would suggest tackling this issue at the client library instead."
      },
      {
        "user": "koppa96",
        "created_at": "2020-08-26T13:40:18Z",
        "body": "Thank you, I'll try to do that."
      }
    ]
  },
  {
    "number": 1804,
    "title": "Different schema per client credential?",
    "created_at": "2020-08-22T15:46:56Z",
    "closed_at": "2020-11-11T21:21:35Z",
    "labels": [
      "duplicate",
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1804",
    "body": "Is there a way to easily swap the schema definition per calling client?  I want to identify who is calling the api by client credentials and change the schema depending on who is calling or who is authenticated.  The idea being that one client may be able to see a field by policy, while another client may not be authorized to see the same field.  Basically a way to add the equivalent of column based authorization.  Different clients could have different authorization to fields on the same objects.  The objects would not be structurally different in code only what is transmitted over the wire as defined by the graph schema.\r\n\r\nI could inspect headers in the resolve method of the graph queries to determine the client and then use reflection to dynamically set the fields, but I would prefer to populate the objects and have the graph schema do the stripping of the data that is not authorized.\r\n\r\nIdeally the schema would be accurately reflected in playground as well, as the schema would be determined by the headers when the playground page loads.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1804/comments",
    "author": "dorlandode",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-08-22T18:07:29Z",
        "body": "See #1212 "
      },
      {
        "user": "sungam3r",
        "created_at": "2020-11-11T21:21:35Z",
        "body": "Closed due to lack of feedback."
      }
    ]
  },
  {
    "number": 1750,
    "title": "How to access Field-level arguments in .Net code",
    "created_at": "2020-07-29T21:52:24Z",
    "closed_at": "2020-07-31T16:09:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1750",
    "body": "In the documentation, I see how to access arguments and am doing that successfully.  However, I can't seem to find any guidance on how to access the field-level arguments in code.  For instance, I have the following:\r\n\r\n```\r\npublic HoldType ()\r\n        {\r\n            Name = \"Hold\";\r\n\r\n            Field(h => h.HoldId, type: typeof(LongGraphType)).Description(\"Id of the Hold\");            \r\n            Field(h => h.Status)\r\n                .Argument<ListGraphType<IntGraphType>>(\"exclude\", \"List of status codes to exclude from the result\")\r\n                .Description(\"Current status of the Hold\");\r\n        }\r\n```\r\n\r\nThen in my Query definition, I have:\r\n```\r\nField<ListGraphType<HoldType>>(\r\n  \"holds\",\r\n  arguments: new QueryArguments(\r\n    new QueryArgument<ListGraphType<IntGraphType>> { Name = \"exclude\", DefaultValue = new int[] { 999 }, Description = \"Status codes to exclude from the results\" }\r\n  ),\r\n  resolve: context =>\r\n  {\r\n    var exclude = context.GetArgument<int[]>(\"exclude\");  // this works for a parent-level argument - holds(exclude:999)\r\n  });\r\n```\r\n\r\nI want to be able to pass in a list of values to exclude from the query on the status field.    So something like...\r\n\r\n```\r\nquery {\r\n  holds {\r\n    holdId\r\n    status(exclude:999,998,100)\r\n  }\r\n}\r\n```\r\n\r\nAm I going about this the right way?  If so, how do I access the values during resolution?  If I need to pass it at parent level, that's fine, but I know GQL supports field-level arguments so I'm wondering if that's possible.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1750/comments",
    "author": "dochoss",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-07-30T16:29:18Z",
        "body": "> Am I going about this the right way?\r\n\r\nYes.\r\n\r\n> If so, how do I access the values during resolution?\r\n\r\nUse different field overload with custom resolver. Your current solution uses overload with expression which just returns property as is."
      },
      {
        "user": "dochoss",
        "created_at": "2020-07-30T17:08:06Z",
        "body": "Thanks for following up. I'm not sure I really understand what the field-level resolver is doing.  Is it applying the lambda to each record on retrieval?  If so, should I use something like this? \r\n\r\n```\r\nField(h => h.Status)\r\n  .Resolve(resolver =>\r\n  {\r\n    var exclude = resolver.GetArgument<int[]>(\"exclude\");\r\n    var status = resolver.Source.Status;\r\n                    \r\n    return !exclude.Contains(status) \r\n      ? resolver.Source.Status \r\n      : -1;\r\n    })\r\n    .Argument<ListGraphType<IntGraphType>>(\"exclude\", \"List of status codes to exclude from the result\")\r\n    .Description(\"Current status of the Hold\");\r\n```\r\n\r\nIf not, how should I accomplish what I'm trying to do?  I'm trying to get a record to not appear in the output if the value of Status is included in the \"exclude\" argument."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-07-30T17:36:53Z",
        "body": "Resolver returns object used for subsequent resolution of inner fields in case of non-leaf parent (current) field. Does `Status` property have `List<int>` type?"
      },
      {
        "user": "dochoss",
        "created_at": "2020-07-30T18:11:37Z",
        "body": "Status is an int, basically a code for the current status of an item.  `Exclude` will be a list of status codes to exclude from the result set.  \r\n\r\nFor clarity, here's an example...\r\n\r\nData set:\r\n```\r\n{ \"holdId\": 1, \"status\": 1 },  \r\n{ \"holdId\": 2, \"status\": 5 }, \r\n{ \"holdId\": 3, \"status\": 999 } \r\n```\r\n\r\nGQL query (desired state):\r\n```\r\nquery {\r\n  holds {\r\n    holdId\r\n    status(exclude:5,999)\r\n  }\r\n}\r\n```\r\n\r\nThe query should only return the hold with holdId = 1"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-07-30T18:18:36Z",
        "body": "OK. So did you come up with a working solution?"
      },
      {
        "user": "dochoss",
        "created_at": "2020-07-30T18:36:04Z",
        "body": "Sorry, computer had a little meltdown and ate part of my comment.  \r\n\r\nI'm still not quite clear on how to use the data I get from the field resolver.  When I get the data into my query resolver, will the updated value from the field resolver be used in place of the raw data?\r\n\r\n```\r\nquery {\r\n  holds {\r\n    holdId\r\n    status(exclude:5,999)\r\n  }\r\n}\r\n```\r\n\r\n```\r\n// query resolver\r\nresolve: context => {\r\n  var holds = database.Holds;\r\n  foreach (var hold in holds) \r\n  {\r\n    // what is the value of hold.Status here if Status == 999?\r\n    // database value or -1? (does the field resolver execute first?)\r\n  }\r\n}\r\n```\r\n"
      },
      {
        "user": "dochoss",
        "created_at": "2020-07-30T18:40:52Z",
        "body": "I just tested with a breakpoint in the query resolver and in the field resolver.  The field resolver hits after the query, so it's not obvious how I can get an item to be excluded.  I can change the value of `Status` but that doesn't help me since the record is still sent in the output."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-07-31T15:42:04Z",
        "body": "GraphQL yields data level by level from top to bottom. First top, then bottom. Your resolver return some object (or array/list/enumerable) which then will be passed to the next level of resolution process until the process comes to primitive values - scalars. If you want to filter some holds you should do it where you have access to them - in resolver for `holds`, not in resolver for `status` so move `exclude` argument to `holds` field."
      },
      {
        "user": "dochoss",
        "created_at": "2020-07-31T16:01:07Z",
        "body": "Got it.  Thanks for all your assistance.  \r\n\r\nI decided to filter just based on my \"deleted\" status (which is 999), but I could still do an array of numbers to exclude (included code for this in the example below).  \r\n\r\nMy working solution for anyone who comes later:\r\n\r\n```\r\nField<ListGraphType<HoldType>>(\r\n    \"holds\",\r\n    arguments: new QueryArguments(\r\n        new QueryArgument<BooleanGraphType> { Name = \"includeDeleted\", DefaultValue = false, Description = \"Include holds marked for deletion\" }\r\n/*\r\n OR\r\n      new QueryArgument<ListGraphType<IntGraphType>> { Name = \"statusesToExclude\", DefaultValue = 999, Description = \"Exclude all these status codes\"\r\n*/\r\n    ),\r\n    resolve: context =>\r\n    {\r\n        var includeDeleted = context.GetArgument<bool>(\"includeDeleted\");\r\n\r\n        var holds = db.Holds\r\n        .AsNoTracking()\r\n        .Where(h => h.Status != (includeDeleted ? -999 : 999))\r\n        .Select(h => new ExtHold().FromHold(h))\r\n        .ToList();\r\n\r\n        AddHoldItemCounts(db, holds);\r\n\r\n        return holds;\r\n    });\r\n```"
      }
    ]
  },
  {
    "number": 1743,
    "title": "document execution result writing",
    "created_at": "2020-07-25T01:00:25Z",
    "closed_at": "2020-08-16T14:18:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1743",
    "body": "i've been scouring the source code for the framework, and i can't seem to find a way/interface that i can supply that allows me to essentially hook the result of a field as its resolved. what i would like to achieve is, instead of taking the result Dictionary returned by DocumentExecutor.ExecuteAsync and manually serializing it to the format i want, i would like to begin my own custom writing as the query is being executed and fields are being resolved. possibly even avoiding the Dictionary<string, object> alltogether. if even possible. If i manually serialize the result now, the following happens(at least from what i see), result is returned, which is however many allocations it takes to build the result Dictionary, which is one step over the result set of data, then i step over all of the data again, and serialize it into the buffer/memory stream of my choice. which is a second allocation for the same data. is there a way i can supply some kind of execution interface, so that i can avoid an extra allocation/unnecessary step over the same data? essentially, the goal is to build the result myself. into the format i want it in. thank you!",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1743/comments",
    "author": "emceelovin",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2020-08-14T04:38:32Z",
        "body": "It's probably possible, but for multiple reasons you'd need to write your own ExecutionStrategy in order to accomplish that.  In order to meet the graphql spec with your custom implementation, you will probably run into 3 main issues:\r\n1. The document will need to be executed in the order it is serialized (e.g. serial execution strategy), or else you'll need to write special code to serialize data once it is available in the correct order for serialization\r\n2. Graphs need to render all their non-null children before writing any children back to the output, since if a non-null child throws an error, a null needs to bubble up from that node to the parent (since it is a non-null node)\r\n3. Any errors need to be queued to be returned after the rest of the data is serialized\r\n\r\nNeat idea, though."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-08-16T14:18:33Z",
        "body": "I agree with the answer from @Shane32. In theory, such a possibility exists, but it is fraught with a number of difficulties. Maybe sometime in the future we will work on it, but there are no such plans now."
      }
    ]
  },
  {
    "number": 1728,
    "title": "Github example for schema first approach",
    "created_at": "2020-07-15T19:32:58Z",
    "closed_at": "2021-03-11T22:24:41Z",
    "labels": [
      "duplicate",
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1728",
    "body": "Is there a decent example of using schema first approach? There are so many questions floating about, and all answers in issue, but no sample code (and I dont mean the docs). I am looking for a runnable example of schema first approach. ",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1728/comments",
    "author": "sukruthakittur",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2021-03-11T22:24:41Z",
        "body": "Closed as a duplicate of #1025 "
      }
    ]
  },
  {
    "number": 1724,
    "title": "How to list field errors?",
    "created_at": "2020-07-14T05:44:04Z",
    "closed_at": "2020-11-11T21:17:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1724",
    "body": "##  Summary\r\nWhen I handle mutation like `registerUser`, I have to perform server-side validation on email and \"not a robot\" fields. Both of them can be invalid (email can already be taken, not a robot can be invalid). \r\nFrontend has to handle error messages and add label to inputs. In regular REST I used to return 422 response with JSON object like this:\r\n```\r\n{\r\n \"email\": [\"This email is already taken.\"],\r\n \"not_a_robot\": [\"Wrong captcha, try again.\"]\r\n}\r\n```\r\nFrontend can easy define what was wrong and display UI errors. How can I list fields with errors for mutation in GraphQL? Or what is the concept about listing errors?\r\n\r\n## Relevant information\r\n\r\nI tried `ExecutionException`, but it provides errors without defining what property failed. Building large list of `HResult` enum doesn't look like good option because this enum is not listed in schema and I have to document it somewhere else.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1724/comments",
    "author": "undestroyer",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-07-14T16:16:15Z",
        "body": "GraphQL response contains errors. Each error has path property and message. You can expose your message.\r\n\r\n> How can I list fields with errors for mutation in GraphQL?\r\n\r\nNothing special for mutations. Queries have the same errors."
      },
      {
        "user": "Shane32",
        "created_at": "2020-08-14T04:55:48Z",
        "body": "Might relate to #1740 \r\n\r\nValidation rules inspect the input object to be sure it is of the correct type.  Assuming that your front-end validates that parameters are of the correct type, then it would be your mutation field resolver that is examining the inputs to be sure they are valid (e.g. email in correct format).  You can only throw a single `ExecutionError` from a single field resolver, but you have two options to return additional data:\r\n\r\n1. You can add data to the `ExecutionError.Data` dictionary to return data along with the error message.  For example, you could execute something like:\r\n```csharp\r\nvar error = new ExecutionError(\"Error adding account\");\r\nerror.Data[\"email\"] = new[] { \"This email is already taken\" };\r\nerror.Data[\"not_a_robot\"] = new[] { \"Wrong captcha, try again.\" };\r\nthrow error;\r\n```\r\n2. You can attach arbitrary information back with the execution result via the `IResolveFieldContext.Extensions` dictionary.  This is not specific to the particular field that caused the error, so it's both harder to use and not as preferred."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-08-30T14:47:04Z",
        "body": "@undestroyer Did you manage to solve your issue?"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-11-11T21:17:34Z",
        "body": "Closed due to lack of feedback."
      }
    ]
  },
  {
    "number": 1721,
    "title": "graphql .Net Framework 3.5 support",
    "created_at": "2020-07-09T04:18:49Z",
    "closed_at": "2020-07-24T21:03:41Z",
    "labels": [
      "question",
      "wontfix"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1721",
    "body": "Hello\r\n\r\nCan I have GraphQl to support .Net Framework 3.5 . As we need to support Windows XP also\r\n\r\nThanks And With Regards\r\nPartha",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1721/comments",
    "author": "kbpartha17",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-07-09T22:27:34Z",
        "body": "Generally speaking, Windows XP has not been supported for a long time. GraphQL.NET targets netstandard2.0 since 2017 - #441 and support only netstandard2.0 since 2019 - #969 . AFAIK GraphQL.NET never supported .Net Framework 3.5. I can see only net45 TFM in initial commit. .Net Framework 3.5 lacks a lot of APIs used in GraphQL.NET. I’m not at all sure that there will be at least one project in graphql-dotnet org  that supports .Net Framework 3.5. @joemcbride  ?"
      },
      {
        "user": "avin-kavish",
        "created_at": "2020-07-12T18:15:57Z",
        "body": "@kbpartha17 Can't you put it in the cloud and have the XP client access it through a web browser? Why do you want to run a graphql server on a local machine?"
      }
    ]
  },
  {
    "number": 1706,
    "title": "Question: Ordering Resolution of ResolverFieldContexts in a custom ObjectGraphType",
    "created_at": "2020-06-09T18:02:26Z",
    "closed_at": "2020-08-17T23:42:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1706",
    "body": "## Summary\r\nWe are attempting to use multiple Fields within an ObjectGraphType to dictate the contents for another field within the Type.  Some example code would look like this:\r\n\r\nSomeModel that we use for our ObjectGraphType\r\n```\r\npublic class SomeModel\r\n{\r\n    public int Num1{get;set;}\r\n    public int Num2 {get;set;}\r\n    public int Sum{get;set;}\r\n}\r\n```` \r\n\r\nAnd our ObjectGraphType\r\n```\r\npublic class SomeModelType : ObjectGraphType<SomeModel>\r\n{\r\n    public SomeModelType(IDataLoaderContextAccessor accessor)\r\n    {\r\n        Field<IntType>()\r\n          .Name(\"Num1\")\r\n          .Description(\"First Number in our sum\")\r\n          .ResolveAsync(context => {\r\n              /*  \r\n                   Here, we asynchronously load up the contents\r\n                   of our Num1.  For arguments sake, we use the \r\n                   IDataLoadContextAccessor to instrument an API call\r\n                   that will finish at some point in the future.\r\n                   As such, this must be ResolveAsync\r\n              */\r\n              Task<int> intResult = dataLoaderResult;\r\n              return intResult;\r\n           });\r\n\r\n        Field<IntType>()\r\n          .Name(\"Num2\")\r\n          .Description(\"Second Number in our sum\")\r\n          .ResolveAsync(context => {\r\n              /*  \r\n                  Same code as above essentially.\r\n              */\r\n           });\r\n\r\n        Field<IntType>()\r\n          .Name(\"Sum\")\r\n          .Description(\"Sum of our first and second number\")\r\n          .ResolveAsync(context => {\r\n              /*  \r\n                  ?\r\n              */\r\n           });\r\n    }\r\n}\r\n```\r\n\r\nWe have quasi solved this issue via Tasks and various `awaiting` concepts (such as Loops checking for statuses to be updated in the body of ResolveAsync() for Num1 or Num2), but they seem to have caused other issues.\r\n\r\nMy Question: Is there a simpler solution that lay within the GraphQL code that allows us to orchestrate the `ResolveAsync()` of our Sum field to only execute after the other Fields have finished, or do we have to utilize things outside of the GraphQL code to achieve this (Continuations, Task analysis, good old fashioned flags, etc)?\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1706/comments",
    "author": "amoore-incomm",
    "comments": [
      {
        "user": "kevklam",
        "created_at": "2020-06-28T06:17:03Z",
        "body": "Probably writing a custom ExecutionStrategy, i.e. a fork of ParallelExecutionStrategy. You could make your resolver implement some interface like \"IDependencyAwareResolver\" that just exposes a list of dependencies (could be as simple as string identifiers), and then have your execution strategy check for nodes with resolvers implementing this interface and block execution of the node (stick it in some separate queue) until all its dependencies have been resolved. I'm doing something similar with \"exclusion groups\" where certain resolvers can't run in parallel with each other.\r\n\r\nThe way I see it, you're probably going to run into issues if you try to solve it at the resolver level, because the execution strategy has a configurable max parallel execution limit and you could presumably deadlock if you end up with too many resolvers blocked waiting for dependencies and run out of threads to run the resolvers that actually satisfy the dependencies. Solving it at the ExecutionStrategy level will avoid this by just not executing the resolver until all its dependencies have been satisfied, hence eliminating the risk of running out of threads."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-07-10T15:38:22Z",
        "body": "Yes. Custom `ExecutionStrategy` may be the best way to do what you want @amoore-incomm . You can place some custom meta-information on your fields about dependencies and then use it in custom strategy to orchestrate execution process."
      }
    ]
  },
  {
    "number": 1705,
    "title": "Aggregation types in schema",
    "created_at": "2020-06-09T14:02:13Z",
    "closed_at": "2020-07-13T23:17:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1705",
    "body": "Hi guys,\r\n\r\nIm working on aggregation functions feature and stuck with one issue (probably) \r\nIn my project, I have two simple entities - customers and orders\r\nI defined for each graphql type separate aggregation type which is including aggregation function type (with appropriate fields - \"total\" and \"price\") \r\nBy some reason, GraphQL \"detect\" latest defined type - so, I got the same field in \"sum\" aggregation type.\r\n\r\nSo, Im trying to implement something like this:\r\n> \r\n      customers {\r\n           aggregation {\r\n            sum {\r\n               price --> should be \"total\" field, but instead of it - field from type defined for another entity - orders\r\n             }\r\n          }\r\n       }\r\n     orders{\r\n       customerId\r\n       aggregation {\r\n          sum {\r\n            price\r\n           }\r\n        }\r\n      }\r\n\r\nMaybe I did something wrong? might be because name of graphql type should be unique? Or it's known issue and somewhere exists workaround?\r\n\r\nVersion of GraphQL lib 2.4\r\n\r\n\r\nThanks, Dmytro.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1705/comments",
    "author": "MakaBuka",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-06-09T15:18:53Z",
        "body": "> might be because name of graphql type should be unique?\r\n\r\nExactly. Try the latest 3.0.0-preview."
      },
      {
        "user": "MakaBuka",
        "created_at": "2020-06-09T15:59:27Z",
        "body": "@sungam3r thanks for your reply. As far as I understood, release of v3 is going to be soon? \r\nAnyways, thanks one more time - you save me one more night, cuz, I thought that i missed sth. will try to find temporary solution before v3 release"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-06-09T18:45:52Z",
        "body": "> As far as I understood, release of v3 is going to be soon?\r\n\r\nWell, just read #1321 ."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-07-13T23:17:46Z",
        "body": "Closed as answered."
      }
    ]
  },
  {
    "number": 1703,
    "title": "Question: ParallelExecutionStrategy and Task.WhenAll",
    "created_at": "2020-06-08T01:20:26Z",
    "closed_at": "2021-02-17T00:55:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1703",
    "body": "Hi,\r\nI was wondering about the reasoning for using Task.WhenAll to await node execution in ParallelExecutionStrategy. At first brush it looks like Task.WhenAny would make more sense to ensure full usage of the configured max parallelization, but I was wondering if that has some bad interactions with DataLoader or some other such issues.\r\n\r\nWould appreciate any insight here!",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1703/comments",
    "author": "kevklam",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2020-07-19T16:24:41Z",
        "body": "It is a problem with the current DataLoader implementation.  It would not be a problem if #1511 were pulled.\r\n\r\nAlso see #976 "
      },
      {
        "user": "sungam3r",
        "created_at": "2021-02-17T00:55:15Z",
        "body": "Closing as fixed. Ping @Shane32 . Right?"
      },
      {
        "user": "Shane32",
        "created_at": "2021-02-18T04:09:11Z",
        "body": "Not exactly “fixed”. The new data loader could work with WhenAny but currently we still use WhenAll in the ParallelExecutionStrategy. "
      }
    ]
  },
  {
    "number": 1687,
    "title": "Can stop ToInputs auto converts IOS8601 string to datetime type",
    "created_at": "2020-05-21T09:10:14Z",
    "closed_at": "2020-05-21T09:33:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1687",
    "body": "Hello there. I had passed a IOS8601 format date into a service inside variables. \r\nBut after converting the variables to jobject using ToInputs() it became a datatime type instead of string. Can I stop it?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1687/comments",
    "author": "ooo2003003v2",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-05-21T11:02:11Z",
        "body": "So nothing to fix there? Did you solve this issue?"
      }
    ]
  },
  {
    "number": 1676,
    "title": "2.4 to Preview 1648 - AddField() Error",
    "created_at": "2020-05-13T01:06:50Z",
    "closed_at": "2020-05-20T01:55:10Z",
    "labels": [
      "question",
      "wontfix"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1676",
    "body": "System.ArgumentOutOfRangeException: 'Output type 'Query' can have fields only of output types: ScalarGraphType, ObjectGraphType, InterfaceGraphType, UnionGraphType or EnumerationGraphType. (Parameter 'fieldType')'\r\n\r\nPreviously this was working:\r\n```\r\nvar listType = new ListGraphType(tableType);\r\nAddField(new FieldType\r\n {\r\n   Name = $\"{friendlyTableName}_list\", \r\n   Type = listType.GetType(), //CLR Type of Graph Type\r\n   ResolvedType = listType, //Graph Type\r\n   Resolver = dyQueryFieldResolver\r\n });\r\n```\r\n\r\nWhat should I be doing differently?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1676/comments",
    "author": "OpenSpacesAndPlaces",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-05-13T06:11:39Z",
        "body": "Everything is correct, additional checks were added in 3.0.0 to match the GraphQL specifications and  avoid unpredictable behavior in runtime."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-05-13T06:13:33Z",
        "body": "See #1678"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-05-13T06:14:14Z",
        "body": "> What should I be doing differently?\r\n\r\nBecause previous behavior was wrong."
      },
      {
        "user": "OpenSpacesAndPlaces",
        "created_at": "2020-05-20T01:55:10Z",
        "body": "I'm not sure if/when I'll get a chance to circle back to testing the preview version.\r\nClosing this thread so it doesn't become a zombie."
      }
    ]
  },
  {
    "number": 1671,
    "title": "Nested input graphtypes",
    "created_at": "2020-05-07T21:38:01Z",
    "closed_at": "2020-07-13T23:06:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1671",
    "body": "Hello,\r\nIs there any documentation about create a mutation based a nested input graph types ?\r\n{\r\n     data {\r\n        name,\r\n        child {\r\n        }\r\n     }\r\n}",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1671/comments",
    "author": "Oliver2301",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-05-08T11:35:53Z",
        "body": "Nesting for inputs no different from nesting for outputs. I see more information in your initial post which I received on my email:\r\n```c#\r\npublic class EventDateTimeType : ObjectGraphType<EventDateTime>\r\n{\r\n    public EventDateTimeType()\r\n    {\r\n        this.Name = \"EventDateTime\";\r\n\r\n        this.Field(e => e.StartingDateTime).Description(\"The start of the Event\");\r\n        this.Field(e => e.EndingDateTime).Description(\"The end of the Event\");\r\n    }\r\n```\r\n\r\n`EventDateTimeType` **must** be input graph type too. Also I think that you use version 2.4.0. In one of the latest previews we added some checks to warn user about input/output inconsistency in nested types. Please read README.md and try the latest preview."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-07-13T23:06:29Z",
        "body": "Closed due to the lack of feedback."
      }
    ]
  },
  {
    "number": 1668,
    "title": "Inheritance of graph types",
    "created_at": "2020-05-05T19:50:33Z",
    "closed_at": "2020-06-06T22:27:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1668",
    "body": "I have a question about inheritance of graph types that I have been unable to solve. Imagine the following scenario:\r\n```csharp\r\npublic class Foo\r\n{ \r\n    public int FooProp { get; set; }\r\n}\r\n\r\npublic class Bar : Foo\r\n{ \r\n    public int BarProp { get; set; }\r\n}\r\n\r\npublic class FooGraphType : ObjectGraphType<Foo>\r\n{\r\n    public FooGraphType()\r\n    {\r\n        Field(p => p.FooProp);\r\n     }\r\n}\r\n\r\npublic class BarGraphType : ObjectGraphType<Bar>\r\n{\r\n    public BarGraphType()\r\n    {\r\n        Field(p => p.FooProp);\r\n        Field(p => p.BarProp);\r\n     }\r\n}\r\n```\r\n\r\nMy issue is that I have to redeclare the FooProp field in BarGraphType, which is just a minor annoyance in this example but when Foo has a lot of fields with resolver code etc it gets very attractive to have them in Foo only and not duplicate them in Bar.\r\n\r\nSo my question is, is there some way for BarGraphType to inherit from FooGraphType, get all the fields defined there, and still be able to use it's own model for additional fields?\r\n\r\nI've been looking through the docs and examples but unable to find anything, so I thought I would ask here.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1668/comments",
    "author": "kenewbie",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-05-05T20:32:10Z",
        "body": "If you want to inherit from two different generic types the answer is NO. This is a limitation of the .NET type system, not GraphQL.NET. But you can always move field declarations inside some method and use this method in your type hierarchy. Also you can inherit from `AutoRegisteringObjectGraphType`."
      },
      {
        "user": "kenewbie",
        "created_at": "2020-05-06T06:08:38Z",
        "body": "Yes I am aware of the limitations on multiple inheritance. I was hoping that there might be some variation of `ObjectGraphType<T>` that looks at the base of T, and if a GraphType is found that uses the base as a model then the fields from that are applied to the GraphType of T as well. \r\n\r\nI'll take a look at the AutoRegistering version and see if that helps me."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-05-06T06:37:37Z",
        "body": "Given `TDerived : TBase`\r\n\r\n`ObjectGraphType<TDerived>` and `ObjectGraphType<TBase>` are not connected in any way. Generic parameter is only needed to provide expression configuration capabilities and typed resolvers."
      },
      {
        "user": "KreativJos",
        "created_at": "2020-05-06T11:55:28Z",
        "body": "Wouldn't your problem be solved if you'd make a generic base class, like this (note: written in free-hand, not tested):\r\n\r\n```\r\npublic class Foo\r\n{ \r\n    public int FooProp { get; set; }\r\n}\r\n\r\npublic class Bar : Foo\r\n{ \r\n    public int BarProp { get; set; }\r\n}\r\n\r\npublic abstract class BaseFooGraphType<T> : ObjectGraphType<T>\r\n    where T : Foo\r\n{\r\n    protected BaseFooGraphType()\r\n    {\r\n        Field(p => p.FooProp);\r\n    }\r\n}\r\n\r\npublic class FooGraphType : BaseFooGraphType<Foo>\r\n{\r\n    public FooGraphType()\r\n        : base()\r\n    { }    \r\n}\r\n\r\npublic class BarGraphType : BaseFooGraphType<Bar>\r\n{\r\n    public BarGraphType()\r\n        : base()\r\n    {\r\n        Field(p => p.BarProp);\r\n    }\r\n}\r\n```"
      },
      {
        "user": "kenewbie",
        "created_at": "2020-05-06T13:24:48Z",
        "body": "Nice, I did not think of that. \r\nThanks for the feedback, I'll try that approach."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-06-06T22:27:57Z",
        "body": "Closed as answered."
      },
      {
        "user": "aguirmrc",
        "created_at": "2023-02-03T14:27:58Z",
        "body": "Tanks! Very helpfull, its works to me!!!!\r\n"
      }
    ]
  },
  {
    "number": 1644,
    "title": "Resolving InputObject Field with Different Name",
    "created_at": "2020-04-15T22:08:40Z",
    "closed_at": "2020-04-16T19:17:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1644",
    "body": "##Summary\r\nQuick note: I did my best to search the issues list, and the docs. The \"Aliases\" section of the docs seems to indicate this is possible, but I may be missing something.\r\n\r\nI am trying to provide a complex input object that contains a field with an aliased name from what the POCO property is named; however, it seems to only map correctly if the name is the same as the property.\r\n\r\n## Relevant information\r\n\r\nThis is a stripped-down example of the setup I have:\r\n\r\n```\r\npublic class Stereo()\r\n{\r\n  public Guid StereoKey { get; set; }\r\n}\r\n\r\npublic class StereoInput : InputObjectType<Stereo>\r\n{\r\n  Field(f => f.StereoKey, type: typeof(GuidGraphType)).Name(\"key\");\r\n}\r\n\r\npublic class Items()\r\n{\r\n  public Stereo Stereo { get; set; }\r\n}\r\n\r\npublic class ItemsInput : InputObjectType<Items>\r\n{\r\n  Field<StereoInput>(\"Stereo\");\r\n}\r\n```\r\n\r\nWhat I would expect is that I could provide the user with a field called \"key\" that would map to `StereoKey`; however, this doesn't seem to be the case. Is there additional info that I am missing when creating this relationship?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1644/comments",
    "author": "Teletraan1",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-04-16T04:48:28Z",
        "body": "Try the latest preview from myget feed. This issue has been fixed."
      },
      {
        "user": "Teletraan1",
        "created_at": "2020-04-16T19:17:22Z",
        "body": "This did the trick. Thanks for the quick reply!"
      }
    ]
  },
  {
    "number": 1630,
    "title": "How do I register a generic base interface without name collisions?",
    "created_at": "2020-03-31T17:49:24Z",
    "closed_at": "2020-04-01T09:56:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1630",
    "body": "## Summary\r\n\r\nI want to do the following:\r\n\r\n- Register an ``InterfaceGraphType<T> where T: IBaseEntity`` where ``IBaseEntity`` contains some very generic fields (Id, Created and Updated)\r\n- Create an abstract generic base object to inherit from so that my object types does not have to implement the same fields over and over again\r\n- Inherit this base object class from different types \r\n- I want the interface be the same for all objects implementing it. That is, i want them all to implement ``BaseEntityInterface`` and not ``BaseEntityInterface<TypeName>``.\r\n    - I want to be able to click on the ``BaseEntityInterface`` in a documentation explorer and list all the types implementing this interface. That will not happen if a generic typename is generated for each implementation. Then there will be only one per interface.\r\n  \r\nRight now, if I use this approach I get a name collision telling me that the name is already registered (if I don´t generate unique names). So I guess I'm going about this in the wrong way...any hints? \r\n\r\nAnd I do, of course want to use the benefits of having generics so things get typechecked by the compiler.\r\n\r\nI think the actions in #510, and #1284 prevents my use case (which I think is legit)?\r\n\r\n## Relevant information\r\n\r\n```csharp\r\n public class BaseEntityInterface<T> : InterfaceGraphType<T> where T: IBaseEntity\r\n    {\r\n        public BaseEntityInterface()\r\n        {\r\n            this.Description = \"An entity with a id and created/updated timestamps\";\r\n\r\n            this.Field(x => x.Id)\r\n                .Description(\"The unique identifier of the entitity.\");\r\n            this.Field(x => x.Created)\r\n                .Description(\"Timestamp when the entity was first created.\");\r\n            this.Field(x => x.Updated)\r\n                .Description(\"Timestamp when the entity was last updated.\");\r\n        }\r\n    }\r\n\r\n public abstract class BaseEntityObject<T> : ObjectGraphType<T> where T: IBaseEntity\r\n    {\r\n        public BaseEntityObject()\r\n        {\r\n            this.Description = \"An entity with a id and created/updated timestamps\";\r\n\r\n\r\n            this.Field(x => x.Id)\r\n                .Description(\"The unique identifier of the entity.\");\r\n            this.Field(x => x.Created)\r\n                .Description(\"Timestamp when the entity was first created.\");\r\n            this.Field(x => x.Updated)\r\n                .Description(\"Timestamp when the entity was last updated.\");\r\n\r\n            this.Interface<BaseEntityInterface<T>>();\r\n            this.IsTypeOf = obj => obj is IBaseEntity;\r\n        }\r\n    }\r\n\r\n// Sample implementation type\r\npublic class InvoiceArticleObject: BaseEntityObject<InvoiceArticle>\r\n    {\r\n        public InvoiceArticleObject()\r\n        {\r\n            this.Description = \"Invoice article.\";\r\n\r\n           // ...\r\n\r\n            this.Interface<BaseEntityInterface<InvoiceArticle>>();\r\n            this.IsTypeOf = obj => obj is InvoiceArticle;\r\n        }\r\n    }\r\n   \r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1630/comments",
    "author": "andrejohansson",
    "comments": [
      {
        "user": "BenjaBobs",
        "created_at": "2020-03-31T18:24:14Z",
        "body": "With the current code the interface is being registered multiple times due to the generics. What you could do is interface with the base type instead:\r\n`this.Interface<BaseEntityInterface<IBaseEntity>>()`\r\n\r\nThat way, the type being registered will be the same, so it will only be registered once, and that should solve your name collision problem while still allowing you to access the needed fields, provided that they are present on `IBaseEntity`."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-31T18:50:20Z",
        "body": "All types in GraphQL **must have unique names**. Which ones? You choose yourself. I see that you do not specify them, so the names are inferred by default from the type are used. You can set type name with just `Name = \"blablabla\";` to avoid any conflicts. For a better understanding of what schemа you have (names), you can open it with GraphQL Playgroud, GraphiQL, Altair or any other UI tool."
      },
      {
        "user": "andrejohansson",
        "created_at": "2020-04-01T09:56:14Z",
        "body": "@BenjaBobs tips was the right for me, setting the BaseInterface solved my issue. Thank you both for your response!"
      }
    ]
  },
  {
    "number": 1608,
    "title": "Does graphql-dotnet support apollo federation for .NET Framework 4.6.1/4.6.2/4.7.1 ?",
    "created_at": "2020-03-12T21:14:42Z",
    "closed_at": "2021-02-17T00:53:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1608",
    "body": "Hi,\r\nWe already have an existing graph that uses apollo federation principle and we would like to know if we can use graphql-dotnet for developing federated graphql service using  .NET framework so that we can integrate this federated graph.\r\n\r\n**We have a limitation to stick with .NET framework and not to use .NET Core 3.X**\r\n\r\nSo wondering if we can achieve the aforementioned requirement using .NET Framework and dotnet-graphql.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1608/comments",
    "author": "rtdt99",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-03-12T22:15:00Z",
        "body": "I know that subscriptions are a limiting factor (.NET Core only), everything else should work."
      },
      {
        "user": "sungam3r",
        "created_at": "2021-02-17T00:53:46Z",
        "body": "Closed as answered."
      }
    ]
  },
  {
    "number": 1596,
    "title": "Is it possible to includes more than one query or mutation class in Schema?",
    "created_at": "2020-03-06T02:01:45Z",
    "closed_at": "2021-02-16T21:21:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1596",
    "body": "Hello there I have encounter a problem when i need include more than one query file. Is it possible to include more than one in schema?\r\n\r\n```c#\r\nthis._schema = GraphQL.Types.Schema.For(\r\n                @\"type Query {\r\n         hello:String\r\n}      \", _ =>\r\n            {\r\n              \r\n                _.Types.Include<Query>();\r\n                _.Types.Include<GeneralQuery>();\r\n            });\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1596/comments",
    "author": "ooo2003003v2",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-03-06T04:48:51Z",
        "body": "What behavior do you expect to get?"
      },
      {
        "user": "ooo2003003v2",
        "created_at": "2020-03-09T07:35:26Z",
        "body": "I am not sure I am doing the right thing because I've split each topic having it's own controllers(eq: push msg, device etc ) instead of one controllers for everything. I have a general response object which can be access by each topic query. So i split it into a general query file but it's not working."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-09T10:44:31Z",
        "body": "Query is one of the root GraphQL types. I see you use schema first way where methods from .NET type are mapped to GraphQL **fields**, 1 method of .NET type - 1 field of corresponding GraphQL type. Do you want to combine methods from many .NET types into one GraphQL root Query type?"
      },
      {
        "user": "ooo2003003v2",
        "created_at": "2020-03-10T07:06:12Z",
        "body": "Yes. I would love to do that. The result I want is that localhost/topic and localhost/device can share the response type.\r\n\r\nlocalhost/topic\r\nquery getTopics{\r\ntopic\r\nresponse\r\n}\r\n\r\nlocalhost/device\r\nquery getDevices{\r\ndevice\r\nresponse\r\n}\r\n`\r\nDevice Query file\r\n`\r\n\r\n        [GraphQLMetadata(\"topic\")]\r\n        public Response GetTopics(){\r\n\r\n            List<GetTopic> res = new List<GetTopic>();\r\n           ...\r\n            return res;\r\n\r\n        }\r\n`\r\nDevice Query file\r\n`\r\n\r\n        [GraphQLMetadata(\"devices\")]\r\n        public Response GetDevices(){\r\n\r\n            List<Device> res = new List<Device>();\r\n          ...\r\n            return res;\r\n\r\n        }\r\n`\r\nResponse Query file\r\n`\r\n\r\n        [GraphQLMetadata(\"response\")]\r\n        public Response GetResponse(){\r\n\r\n            Response res = new Response();\r\n          ...\r\n            return res;\r\n\r\n        }\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-10T11:03:19Z",
        "body": "Now this feature is not supported."
      },
      {
        "user": "sungam3r",
        "created_at": "2021-02-16T21:21:46Z",
        "body": "I don't think it's worth doing support for this feature, because it will complicate the implementation. Now in the schema first approach, 1 CLR type corresponds to one GraphType. See `TypeConfig.Type` property and its usages. If we allow the aggregation of GraphTypes from several CLR types, then this convention system will need to be completely changed. I am not saying that this is not possible. This is possible, but the benefits are out of proportion to the complexity involved. Closing."
      }
    ]
  },
  {
    "number": 1591,
    "title": "How can I gain access to the HttpRequest object in n ObjectGraphType Field Resolve Function",
    "created_at": "2020-03-05T08:35:06Z",
    "closed_at": "2020-03-06T08:24:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1591",
    "body": "This is the code for my GraphQL controller;\r\n\r\n    [Route(\"[controller]\")]\r\n    public class GraphQLController : Controller\r\n    {\r\n        private readonly IDocumentExecuter _documentExecuter;\r\n        private readonly ISchema _schema;\r\n\r\n        public GraphQLController(ISchema schema, IDocumentExecuter documentExecuter)\r\n        {\r\n            _schema = schema;\r\n            _documentExecuter = documentExecuter;\r\n        }\r\n\r\n        [HttpPost]\r\n        public async Task<IActionResult> Post([FromBody] GraphQLQuery query)\r\n        {\r\n            if (query == null) { throw new ArgumentNullException(nameof(query)); }\r\n            var inputs = query.Variables.ToInputs();\r\n            //I can get the Request Object here\r\n            var executionOptions = new ExecutionOptions\r\n            {\r\n                Schema = _schema,\r\n                Query = query.Query,\r\n                Inputs = inputs\r\n            };\r\n\r\n            var result = await _documentExecuter.ExecuteAsync(executionOptions).ConfigureAwait(false);\r\n\r\n            if (result.Errors?.Count > 0)\r\n            {       \r\n                return BadRequest(result);\r\n            }\r\n\r\n            return Ok(result);\r\n        }\r\n    }\r\n\r\nI would like to be able to access the HttpRequest object (obtained in the controller action) in a resolve function of am ObjectGraphType field;\r\n\r\n            Field<FooGraphType>(\r\n                \"baz\",\r\n                resolve: context =>\r\n                {\r\n                    //Get the Request here\r\n                });\r\n\r\nMore generally, is there a method for including additional information in the \"context\" or by some other means, so that it can be accessed in the resolve function?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1591/comments",
    "author": "monkeyTrainer",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-03-05T13:35:47Z",
        "body": "1. Inject `IHttpContextAccessor`\r\nor\r\n2. Store something into `UserContext` property, it's dictionary of user defined additional information."
      },
      {
        "user": "monkeyTrainer",
        "created_at": "2020-03-06T08:24:20Z",
        "body": "Thanks @sungam3r that'll do nicely."
      }
    ]
  },
  {
    "number": 1585,
    "title": "How to get the parent argument",
    "created_at": "2020-03-03T07:20:49Z",
    "closed_at": "2020-03-09T07:59:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1585",
    "body": "Hi!\r\n\r\nI have a query like this:\r\n`{\r\n  rules(provider:\"TST\"){\r\n    ruleA(client:\"A\"){\r\n      value\r\n    }\r\n    ruleB(client:\"B\"){\r\n      value\r\n    }\r\n  }\r\n}`\r\n\r\nSomeone requested 2 rules of a provider, for different clients.\r\nHow can I access to the parent argument (provider) in the ruleA resolver?\r\n\r\nIn my code i have something like:\r\n\r\n```\r\npublic class BaseQuery : ObjectGraphType<object>\r\n{\r\n\tpublic BaseQuery()\r\n\t{            \r\n\t\tName = \"Query\";\r\n\r\n\t\tField<Rules>(\"rules\",\r\n\t\t\targuments: new QueryArguments(new QueryArgument<NonNullGraphType<StringGraphType>> { Name = \"provider\", Description = \"Provider\" }),\r\n\t\t\tresolve: context => new Rules());\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n```\r\npublic class Rules : ObjectGraphType<object>\r\n{\r\n\tpublic Rules()\r\n\t{\r\n\t\tName = \"Rules\";\r\n\r\n\t\t//---- Rule A ----------------------------------\r\n\t\tField<BoolValueInterface>(\"ruleA\",\r\n\t\t\targuments: new QueryArguments(new QueryArgument<NonNullGraphType<StringGraphType>> { Name = \"client\" , Description = \"Client\" }),\r\n\t\t\t\r\n\t\t\tresolve: context => {          \r\n\t\t\t\t//Here I need to get the Provider from Parent query\r\n\t\t\t\treturn RulesService.GetRuleDummy(/*Send Provider*/);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n}\r\n```\r\n\r\n\r\nThe only way I achieved this, was using query variables to send the provider.\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1585/comments",
    "author": "Mcaldentey",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-03-03T11:38:43Z",
        "body": "You can use `context.Document` to obtain entire AST of incoming request. Now there is no reference to parent field from `GraphQL.Language.AST.Field` (see `IResolveFieldContext.FieldAst`). I myself miss this feature for some projects, while I have to manually parse the document."
      },
      {
        "user": "Mcaldentey",
        "created_at": "2020-03-09T07:59:01Z",
        "body": "Thank you! "
      }
    ]
  },
  {
    "number": 1562,
    "title": "Current recommendation for implementing GraphQL.Net with Entity Framework",
    "created_at": "2020-02-23T21:56:52Z",
    "closed_at": "2020-03-02T06:20:28Z",
    "labels": [
      "duplicate",
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1562",
    "body": "## Summary\r\nSo there's a lot of discussion about how to deal with the dependency injection scoping of GraphQL.Net and Entity Framework with many different suggestions of various age. \r\n\r\nIn the project that I'm currently working on, I have been running with a service locator for using the EF dbContext in resolvers and it works, but there's so much documentation out there suggesting that this pattern should be avoided I'm trying to find an ideal alternative.\r\n\r\n## Questions\r\nWhat is the current recommendation for using a \"scoped\" Entity Framework dbContext with a \"singleton\" GraphQL setup? \r\n\r\nShould I feel bad about the service locator implementation? \r\n\r\nWould an injectable dbContext factory with singleton scope be a better solution?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1562/comments",
    "author": "ztrobinson777",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-02-23T22:19:12Z",
        "body": "For all three questions you will get different answers from different people, there is no single ideal solution. Relates to #1310 "
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-02T06:20:28Z",
        "body": "Closed in favor of #1310 "
      }
    ]
  },
  {
    "number": 1560,
    "title": "Get requested fields",
    "created_at": "2020-02-23T08:37:54Z",
    "closed_at": "2020-03-29T09:47:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1560",
    "body": "Hi.\r\nIn node version you can access to \"info\" field of GraphQLResolveInfo, to get what fields are requested in query.\r\n\r\nHow can you do in graphql .net core?\r\nIt can be usefull to decide what sql queries I need to do to resolve all requested fields.\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1560/comments",
    "author": "fenomeno83",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-02-23T08:40:46Z",
        "body": "`IResolveFieldContext.SubFields`, `IResolveFieldContext.Path`"
      },
      {
        "user": "fenomeno83",
        "created_at": "2020-02-23T08:45:39Z",
        "body": "Can you give me example?\r\n\r\nThis is a my test query\r\n\r\n    public class TestGroupQueries : ObjectGraphType\r\n    {\r\n        public TestGroupQueries(ITestOperations testOperations)\r\n        {\r\n            Name = \"testQueries\";\r\n\r\n            FieldAsync<StringGraphType>(\r\n            \"test\",\r\n                resolve: async context => await testOperations.Test<object>());\r\n\r\n        }\r\n      }\r\n\r\nHow can I get query requested fields"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-23T08:47:47Z",
        "body": "`context.SubFields`"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-23T08:48:34Z",
        "body": "or `context.Document` in case of the whole query text"
      },
      {
        "user": "fenomeno83",
        "created_at": "2020-02-24T09:19:06Z",
        "body": "thanks!"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-02T06:19:35Z",
        "body": "@fenomeno83 Is this issue still actual for you?"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-29T09:47:50Z",
        "body": "Closed due to lack of feedback."
      }
    ]
  },
  {
    "number": 1545,
    "title": "DefaultFieldNameConverter question",
    "created_at": "2020-02-17T23:33:20Z",
    "closed_at": "2020-02-23T14:48:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1545",
    "body": "@sungam3r I'm trying to understand the `DefaultFieldNameConverter` and `PascalCaseFieldNameConverter`.  It appears to only apply camel case to \"instrospection types\".  However, this is searching a private fixed array, always containing a single static type `SchemaIntrospection`.  As a private array, it can't be changed.  And static types can't be created.  Am I missing something or does this make no sense at all?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1545/comments",
    "author": "Shane32",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-02-18T06:34:49Z",
        "body": "You have the same question that I once had. In fact, everything is simple - the **parent** type is checked. And the converter is applied to **child** fields. Also look into `GraphTypesLookup`:\r\n```c#\r\n var introspectionType = typeof(SchemaIntrospection);\r\n\r\n            lookup.HandleField(introspectionType, SchemaIntrospection.SchemaMeta, ctx);\r\n            lookup.HandleField(introspectionType, SchemaIntrospection.TypeMeta, ctx);\r\n            lookup.HandleField(introspectionType, SchemaIntrospection.TypeNameMeta, ctx);\r\n```\r\n\r\n```c#\r\n private void HandleField(Type parentType, FieldType field, TypeCollectionContext context)\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2020-02-18T12:56:37Z",
        "body": "Thanks. I felt it must have made sense somehow but couldn’t figure it out!"
      },
      {
        "user": "Shane32",
        "created_at": "2020-02-18T13:48:56Z",
        "body": "But ... the introspection types start with `__` -- so this code still actually does nothing, right???  "
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-18T15:14:08Z",
        "body": "Why nothing?"
      },
      {
        "user": "Shane32",
        "created_at": "2020-02-18T15:57:05Z",
        "body": "The `Name` property of `SchemaMetaFieldType` is set to `\"__schema\"`.  `HandleField` passes the parent type and the `Name` property of the field to the `IFieldConverter`.  If this then ran this through `StringExtensions.ToPascalCase` (it doesn't currently), it would grab the first character and try to capitalize it.  The first character is `'_'`.  So it would return the original string `\"__schema\"`.  Same with `TypeMetaFieldType` and `TypeNameMetaFieldType`, the only three types this code applies to.  Right?  So it would seem that you could run any field name through `ToPascalCase` without the name of those introspection type names being affected.  And they certainly don't need to run through `ToCamelCase` as they are predefined with the correct case."
      },
      {
        "user": "Shane32",
        "created_at": "2020-02-18T16:32:27Z",
        "body": "Maybe there's more I'm not seeing.  I'll run some tests."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-18T16:53:55Z",
        "body": "I think I understood your question.\r\n\r\n>  it would grab the first character and try to capitalize it. The first character is '_'\r\n\r\nFirst, you confuse the parent field and the child field. The converter converts the names of child fields, for example `types`, `args`. However, the current code indeed can be simplified because all introspection fields are lowercase:\r\n```c#\r\npublic class PascalCaseFieldNameConverter : IFieldNameConverter\r\n    {\r\n        private static readonly Type[] IntrospectionTypes = { typeof(SchemaIntrospection) };\r\n\r\n        public static readonly PascalCaseFieldNameConverter Instance = new PascalCaseFieldNameConverter();\r\n\r\n        public string NameFor(string field, Type parentType) => isIntrospectionType(parentType) ? field : field.ToPascalCase();\r\n\r\n        private bool isIntrospectionType(Type type) => IntrospectionTypes.Contains(type);\r\n    }\r\n```\r\n\r\nand\r\n\r\n```c#\r\n public class DefaultFieldNameConverter : IFieldNameConverter\r\n    {\r\n        public static readonly DefaultFieldNameConverter Instance = new DefaultFieldNameConverter();\r\n\r\n        public string NameFor(string field, Type parentType) => field;\r\n    }\r\n```"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-18T16:56:49Z",
        "body": "The basic idea is not to affect the name of the introspection fields so I think you are right that code into `DefaultFieldNameConverter` does nothing although it seemed to me your explanation was not entirely true."
      },
      {
        "user": "Shane32",
        "created_at": "2020-02-18T16:57:05Z",
        "body": "Making more sense now.  I tried switching to the PascalNameConverter but the default json writer in DocumentWriter is forcing the result to camelcase.  Is this an error?"
      },
      {
        "user": "Shane32",
        "created_at": "2020-02-18T16:57:19Z",
        "body": "Or is that expected behavior?"
      },
      {
        "user": "Shane32",
        "created_at": "2020-02-18T17:13:56Z",
        "body": "I'm still researching; I'll figure it out."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-18T17:44:38Z",
        "body": "`DocumentWriter` is \"external\" component with additional \"formatter\" function. You **can** configure it as you want. Yes, by default we forced the result to camelCase."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-18T17:46:16Z",
        "body": "So in other words if you want to have PascalCase you should enable it on two levels - schema and document writer."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-18T17:55:21Z",
        "body": "By the way, I think that it was wrong to convert introspection field names to lowercase (even with no effect). The point is that the names of these fields should not change and no matter what their original name is. So I think that `CamelCaseFieldNameConverter` should be changed too to follow this pattern. And of course (as you might have already guessed) all these discussions should be noted in the comments."
      },
      {
        "user": "Shane32",
        "created_at": "2020-02-18T18:07:10Z",
        "body": "I think I found my answer.  The `GraphTypesLookup` constructor runs before the `GraphTypesLookup.FieldNameConverter` property is set, so all the introspection fields always get configured with the `CamelCaseNameConverter` (the default value of `GraphTypesLookup.FieldNameConverter`), no matter how `Schema.FieldNameConverter` or `ExecutionOptions.FieldNameConverter` is set.\r\n\r\nI've proven this by three steps:\r\n1. Change CamelCaseFieldNameConverter.cs to the following:\r\n``` C#\r\nusing System;\r\nusing System.Linq;\r\nusing GraphQL.Introspection;\r\n\r\nnamespace GraphQL.Conversion\r\n{\r\n    public class CamelCaseFieldNameConverterOld : IFieldNameConverter\r\n    {\r\n        public static readonly CamelCaseFieldNameConverterOld Instance = new CamelCaseFieldNameConverterOld();\r\n\r\n        public string NameFor(string field, Type parentType) => field.ToCamelCase();\r\n    }\r\n    public class CamelCaseFieldNameConverter : IFieldNameConverter\r\n    {\r\n        private static readonly Type[] IntrospectionTypes = { typeof(SchemaIntrospection) };\r\n\r\n        public static readonly CamelCaseFieldNameConverter Instance = new CamelCaseFieldNameConverter();\r\n\r\n        public string NameFor(string field, Type parentType)\r\n        {\r\n            if (isIntrospectionType(parentType) && field != \"__schema\" && field != \"__type\" && field != \"__typename\")\r\n                throw new Exception();\r\n            return field.ToCamelCase();\r\n        }\r\n\r\n        private bool isIntrospectionType(Type type) => IntrospectionTypes.Contains(type);\r\n    }\r\n}\r\n```\r\n2. Change the GraphTypesLookup constructor to set `FieldNameConverter` to `CamelCaseFieldNameConverterOld.Instance` at the start of the function, and back to the default of `CamelCaseFieldNameConverter.Instance` at the end of the function\r\n3. Run all tests -- which all pass showing that no exception is thrown\r\n            "
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-18T19:05:32Z",
        "body": "Well, OK, this does not change the essence of the matter - `CamelCaseFieldNameConverter` does nothing with introspection fields."
      },
      {
        "user": "Shane32",
        "created_at": "2020-02-18T19:53:45Z",
        "body": "Found one bug: `GetArgument`, used within some introspection types, does not work with pascal case due to it transforming the argument name to pascal case, which is incorrect for the introspection types.  Posting a PR for it."
      }
    ]
  },
  {
    "number": 1532,
    "title": "Subscriptions in .NET Framework",
    "created_at": "2020-02-12T14:58:33Z",
    "closed_at": "2020-02-12T21:48:56Z",
    "labels": [
      "wrong project",
      "question",
      "subscriptions"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1532",
    "body": "## Summary\r\nAre there any examples or efforts available to enable subscriptions on .NET Framework? All of the GraphQL middleware for WebSockets and subscriptions is written with ASPNET Core in mind and is not transferrable to .NET Framework. This unfortunately means that it looks like it's not possible to use subscriptions with GraphQL.net in NFX.\r\n\r\nAny info would be great, thanks.\r\n\r\n## Relevant information\r\nN/a\r\n\r\n### Environment (if relevant)\r\nFYI I am using OWIN Self-Host on .NET Framework 4.7.2\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1532/comments",
    "author": "dillanmann",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-02-12T19:30:10Z",
        "body": "This is transport agnostic package. It is worth posting that issue to the server project."
      },
      {
        "user": "dillanmann",
        "created_at": "2020-02-12T21:48:56Z",
        "body": "> This is transport agnostic package. It is worth posting that issue to the server project.\r\n\r\nWill do, thank you!"
      }
    ]
  },
  {
    "number": 1521,
    "title": "How to implement mutation provider classes",
    "created_at": "2020-02-06T16:20:38Z",
    "closed_at": "2020-02-07T08:32:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1521",
    "body": "\r\nI would like to create the mutation fields outside the mutation class, so that I can use DI to get all classes which implements e.g. IMutationFieldsProvider and then call a method to create the fields.\r\n\r\n\r\nHere is my mutation class\r\n```\r\npublic class MyMutation : ObjectGraphType\r\n{\r\n    public MyMutation(IEnumerable<IMutationFieldsProvider> mutationFieldsProviders)\r\n    {\r\n        Name = \"MyMutation\";\r\n        foreach (var mutationFieldsProvider in mutationFieldsProviders)\r\n        {\r\n            mutationFieldsProvider.CreateMutationFields(this);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAnd this is one of my mutation providers\r\n```\r\npublic class MyMutationsProvider : IMutationFieldsProvider\r\n{\r\n    public void CreateMutationFields(ObjectGraphType myMutationObject)\r\n    {\r\n        myMutationObject.Field<MyPayloadType, MyPayload>()\r\n                .Name(\"addSomthing\")\r\n                .ResolveAsync(async context =>\r\n                {\r\n                   // do something\r\n                });\r\n    }\r\n}\r\n```\r\nWhen I thy this, I get the following error:\r\n`MyMutation fields must be an object with field names as keys or a function which returns such an object.`\r\n\r\nIt is working when I call the Field method directly in the constructor of the MyMutation.\r\n\r\nIs there a possibility to split up the mutations so that there are not all implemented in the constructor of the mutation class?\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1521/comments",
    "author": "taimo42",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-02-06T17:10:17Z",
        "body": "Did you try the latest preview version?"
      },
      {
        "user": "taimo42",
        "created_at": "2020-02-07T08:32:24Z",
        "body": "Thank you for the fast reaction.\r\n\r\nI was checking my code again and tried several things.\r\nAt the end it turned out, that there was an issue with the DI. I was not registering `MyMutationsProvider` in the right way. I managed to fix this. Now it is working as expected.\r\n\r\n**So this was not an issue with GraphQl. Sorry for the inconvenience.**\r\n\r\nI'm in general very happy with this library. But I'm also looking forward to the new features, because I'm still working with the latest stable release.  "
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-07T08:54:16Z",
        "body": "You may find that in fact the latest preview versions are even more \"stable\" than 2.4.0, also a bunch of useful features were implemented since 2.4.0 release. I myself use the latest previews in production for a long time."
      }
    ]
  },
  {
    "number": 1520,
    "title": "Get GraphQL Schema when using GraphType First",
    "created_at": "2020-02-04T14:31:33Z",
    "closed_at": "2020-02-04T14:52:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1520",
    "body": "We are building our api using a GraphType first approach, however it would be useful to be able to export this to a GraphQL schema as this is easier to discuss with others. I cannot find any documentation or obvious methods that seem to allow me to do this. Am I missing it or is this not possible currently?\r\n\r\nFor example, I was hoping to be able to do something like:\r\n```\r\nusing System;\r\nusing System.Threading.Tasks;\r\nusing GraphQL;\r\nusing GraphQL.Types;\r\n\r\npublic class Droid\r\n{\r\n  public string Id { get; set; }\r\n  public string Name { get; set; }\r\n}\r\n\r\npublic class DroidType : ObjectGraphType<Droid>\r\n{\r\n  public DroidType()\r\n  {\r\n    Field(x => x.Id).Description(\"The Id of the Droid.\");\r\n    Field(x => x.Name).Description(\"The name of the Droid.\");\r\n  }\r\n}\r\n\r\npublic class StarWarsQuery : ObjectGraphType\r\n{\r\n  public StarWarsQuery()\r\n  {\r\n    Field<DroidType>(\r\n      \"hero\",\r\n      resolve: context => new Droid { Id = \"1\", Name = \"R2-D2\" }\r\n    );\r\n  }\r\n}\r\n\r\npublic class Program\r\n{\r\n  public static async Task Main(string[] args)\r\n  {\r\n    var schema = new Schema { Query = new StarWarsQuery() };\r\n\r\n    var gqlSchema = await schema.ToGraphQLSchema();\r\n\r\n    Console.WriteLine(gqlSchema);\r\n  }\r\n}\r\n```\r\n\r\nWhich would give:\r\n```\r\ntype Droid {\r\n    id: String!\r\n    name: String!\r\n  }\r\n\r\n  type Query {\r\n    hero: Droid\r\n  }\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1520/comments",
    "author": "simonbu11",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-02-04T14:37:07Z",
        "body": "`new SchemaPrinter(yourSchema).Print();`"
      },
      {
        "user": "simonbu11",
        "created_at": "2020-02-04T14:52:23Z",
        "body": "Perfect; that is exactly what I wanted. Thank you for such a quick reply too"
      }
    ]
  },
  {
    "number": 1513,
    "title": "Is complex nestedInputType supported in mutation and if so how do I use it?",
    "created_at": "2020-01-21T16:23:22Z",
    "closed_at": "2020-01-22T06:34:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1513",
    "body": "Is complex nested InputObjectGraphType supported in mutation and if so how do I use it?\r\nI have this code:\r\n\r\n```\r\npublic class GqlCustomerSiteUserRelationshipInputType : InputObjectGraphType\r\n    {\r\n        public GqlCustomerSiteUserRelationshipInputType()\r\n        {\r\n            Name = \"GqlCustomerSiteUserRelationshipInputType\";\r\n            Field<NonNullGraphType<LongGraphType>>(\"id\"); \r\n            Field<NonNullGraphType<LongGraphType>>(\"version\");\r\n            Field<GqlCustomerSiteInputType>(\"customerSite\"); //this does not work, GqlCustomerSiteInputType inherits from InputObjectGraphType\r\n            Field<GqlUserInputType>(\"user\"); //this does not work, GqlUserInputType inherits from InputObjectGraphType\r\n            Field<NonNullGraphType<LongGraphType>>(\"userId\");\r\n            Field<NonNullGraphType<LongGraphType>>(\"customerSiteId\");\r\n        }\r\n    }\r\n```\r\n\r\nIf I remove 2 lines with comments then the schema works\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1513/comments",
    "author": "risogolo",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-01-21T17:21:53Z",
        "body": "What version do you use?"
      },
      {
        "user": "risogolo",
        "created_at": "2020-01-22T06:14:49Z",
        "body": "Nevermind, the issue seem to be that I have unintentionally used the same name for multiple InputObjectGraphTypes, you can close it if you want, or you can adde a feature that will inform develoepr that he has multiple InputObjectGraphTypes with the same name."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-01-22T06:34:41Z",
        "body": "This feature (and other checks for the correctness of the schema) is already in the preview version."
      }
    ]
  },
  {
    "number": 1445,
    "title": "Classes derived from InputObjectGraphType *sometimes* return error when given a name and a field is given a description.",
    "created_at": "2019-12-02T15:25:07Z",
    "closed_at": "2019-12-03T05:49:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1445",
    "body": "After a ton of testing to figure out exactly why my mutations were sometimes working and sometimes not I've finally isolated the problem down to whether or not the InputObjectGraphType class has been given a name and a field in that class has a description but this only seems to matter _sometimes_ as bizarre as that is.\r\n\r\nFor example, this\r\n```\r\n    public class WololoInputType : InputObjectGraphType\r\n    {\r\n        public WololoInputType()\r\n        {\r\n            Name = \"Enemies are red, allies are blue, WOLOLO, now you're blue too.\";\r\n            /// Attribute Fields\r\n            FieldAsync<NonNullGraphType<EntityReferenceInputType>, EntityReferenceType>(\"customerid\").Description == \"PepperoniPizza\";\r\n        }\r\n    }\r\n```\r\n\r\nGives me this error:\r\n\r\n```\r\n{\r\n    \"errors\": [\r\n        {\r\n            \"message\": \"GraphQL.Validation.ValidationError: Variable \\\"salesorder\\\" cannot be non-input type \\\"SalesOrderCreateInput\\\".\",\r\n            \"locations\": [\r\n                {\r\n                    \"line\": 1,\r\n                    \"column\": 10\r\n                }\r\n            ],\r\n            \"extensions\": {\r\n                \"code\": \"5.7.3\"\r\n            }\r\n        },\r\n        {\r\n            \"message\": \"GraphQL.Validation.ValidationError: Unknown type SalesOrderCreateInput.\",\r\n            \"locations\": [\r\n                {\r\n                    \"line\": 1,\r\n                    \"column\": 23\r\n                }\r\n            ],\r\n            \"extensions\": {\r\n                \"code\": \"5.4.1.2\"\r\n            }\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nHowever this:\r\n\r\n```\r\n    public class WololoInputType : InputObjectGraphType\r\n    {\r\n        public WololoInputType()\r\n        {\r\n            /// Attribute Fields\r\n            FieldAsync<NonNullGraphType<EntityReferenceInputType>, EntityReferenceType>(\"customerid\");\r\n        }\r\n    }\r\n```\r\n\r\nWill perform the mutation as expected.\r\n\r\nThe _strangest_ part about this error is that if I delete just the field description, rebuild the solution and run it, I still get the above error. However, if I delete both of them, rebuild it and then _add name back to class_ it runs fine, only failing yet again if I add Description back to any field.\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1445/comments",
    "author": "bigbizze",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2019-12-02T18:09:32Z",
        "body": "Name is a GraphType's name, not description. Name must have only alphanumeric symbols. Try the latest preview version and you will see runtime error about that when schema is built."
      },
      {
        "user": "bigbizze",
        "created_at": "2019-12-03T05:49:28Z",
        "body": "Ah, this makes sense then why it would often confuse one input type for another. Good to know, not sure how I mixed up the name and description properties so thoroughly, thank you!"
      }
    ]
  },
  {
    "number": 1395,
    "title": "Return custom model from mutation",
    "created_at": "2019-11-07T10:59:52Z",
    "closed_at": "2020-01-06T06:38:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1395",
    "body": "## Summary\r\nHello, I'd like to know how the fields are mapped with a given model because I've got this error when i'm trying to do a mutation :\r\n`\"GraphQL.ExecutionError: Expected value of type \\\"BearerType\\\" for \\\"BearerType\\\" but got: Bearer.\\r\\n`\r\nIs there any problem with my mutation or my objects ?\r\n\r\n## Relevant information\r\n**Mutation.cs**\r\n``` \r\nthis.FieldAsync<BearerType>(\r\n                \"login\",\r\n                arguments: new QueryArguments(\r\n                    new QueryArgument<NonNullGraphType<MyInputType>> { Name = \"credentials\" }\r\n                ),\r\n                resolve: async context => {\r\n                    return new Bearer { ... };\r\n                });\r\n```\r\n**BearerType.cs**\r\n``` \r\n    public class BearerType : ObjectGraphType<Bearer>\r\n    {\r\n        public BearerType()\r\n        {\r\n            this.Field(b => b.Token).Name(\"accessToken\");\r\n            this.Field(b => b.TokenType).Name(\"tokenType\");\r\n            this.Field(b => b.TokenLifetime).Name(\"expiresIn\");\r\n            this.Field(b => b.UserId, type: typeof(IdGraphType)).Name(\"userId\");\r\n        }\r\n    }\r\n```\r\n**Bearer.cs**\r\n``` \r\n    public class Bearer\r\n    {\r\n        public string Token { get; set; }\r\n        public string TokenType { get; set; }\r\n        public int TokenLifetime { get; set; }\r\n        public int UserId{ get; set; }\r\n    }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1395/comments",
    "author": "jsp-up",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2019-11-07T11:23:38Z",
        "body": "First of all please try to use the latest preview version of graphql-dotnet. Not so long ago I corrected the text of the error message that you see."
      },
      {
        "user": "SimonCropp",
        "created_at": "2020-01-06T00:33:34Z",
        "body": "@sungam3r propose we close this given the lack of response?"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-01-06T06:38:02Z",
        "body": "@jsp-up I hope you have solved this problem. In any case, I am always happy to answer your questions."
      }
    ]
  },
  {
    "number": 1363,
    "title": "Required service for type not found",
    "created_at": "2019-10-23T09:38:31Z",
    "closed_at": "2019-10-23T12:01:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1363",
    "body": "```\r\npublic void ConfigureServices(IServiceCollection services)\r\n{\r\n    services.AddDbContext<Context>();\r\n\r\n    services.AddScoped<Query>();\r\n    services.AddScoped<Schema>();\r\n\r\n    services.AddGraphQL();\r\n}\r\n\r\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\r\n{\r\n    app.UseGraphQL<Schema>();\r\n}\r\n```\r\n```\r\npublic class Schema : GraphQL.Types.Schema\r\n{\r\n    public Schema(Query query, IServiceProvider provider): base(provider)\r\n    {\r\n        Query = query;\r\n    }\r\n}\r\n```\r\n```\r\npublic class Query : ObjectGraphType\r\n{\r\n    public Query(Context db)\r\n    {\r\n        Name = \"query\";\r\n        Field<ListGraphType<Types.Note>>(\"notes\", resolve: _ => db.Notes.AsAsyncEnumerable());\r\n    }\r\n}\r\n```\r\n```\r\npublic class Note : ObjectGraphType<Database.Note>\r\n{\r\n    public Note(Context db)\r\n    {\r\n        Field(n => n.Id);\r\n        Field(n => n.Title);\r\n        Field(n => n.Content);\r\n        Field<Book>(\"book\", resolve: context => db.Books.First(book => Equals(book.Id, context.Source.BookId)));\r\n    }\r\n}\r\n```\r\n**GraphiQL shows**\r\n```\r\n  \"errors\": [\r\n    {\r\n      \"message\": \"Required service for type Models.Schema.Types.Note not found\",\r\n      \"extensions\": {\r\n        \"code\": \"INVALID_OPERATION\"\r\n      }\r\n    }\r\n  ]\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1363/comments",
    "author": "fangswet",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2019-10-23T10:13:17Z",
        "body": "Well...\r\n```c#\r\n  services.AddScoped<Note>();\r\n```\r\n"
      },
      {
        "user": "fangswet",
        "created_at": "2019-10-23T10:25:10Z",
        "body": "Already tried that. I'd say the missing service is `Context` for `Note`. `Context` does inject into `Query` though"
      },
      {
        "user": "fangswet",
        "created_at": "2019-10-23T12:01:16Z",
        "body": "my bad. you can remove this"
      }
    ]
  },
  {
    "number": 1359,
    "title": "How to use DataLoader with composite primary keys?",
    "created_at": "2019-10-21T17:22:12Z",
    "closed_at": "2023-04-23T15:37:17Z",
    "labels": [
      "question",
      "data loader"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1359",
    "body": "I can't figure how to use DataLoader with entities with composite primary key, can someone please provide a complete example of how to use DataLoader with entities with a composite primary key?\r\n\r\ni use this code for entities with a single primary key and it is working correctly\r\n\r\n```\r\nField<ListGraphType<BodySystemTranslationType>>(\r\n                \"BodySystemTranslations\",\r\n                resolve: context =>\r\n                {\r\n                    var loader =\r\n                        dataLoaderAccessor.Context.GetOrAddCollectionBatchLoader<short, BodySystemTranslation>(\r\n                            \"GetBodySystemTranslationByBodySystem\", GetBodySystemTranslationByBodySystemId);\r\n                    return loader.LoadAsync(context.Source.Id);\r\n                });\r\n\r\n        public async Task<ILookup<short, BodySystemTranslation>> GetBodySystemTranslationByBodySystemId(IEnumerable<short> bodySystemIds)\r\n        {\r\n            var bodySystemTranslations = await _bodySystemContext.BodySystemTranslation.Where(a => bodySystemIds.Contains(a.BodySystemId)).ToListAsync();\r\n            return bodySystemTranslations.ToLookup(x => x.BodySystemId);\r\n        }\r\n```\r\n\r\nand i'm trying this for composite keys but it is not working\r\n\r\n```\r\nField<BodySystemTranslationType>(\r\n                \"BodySystemTranslation\",\r\n                arguments: new QueryArguments(new QueryArgument<NonNullGraphType<IdGraphType>> { Name = \"LanguageLCID\" }),\r\n                resolve: context =>\r\n                {\r\n                    int languageLCID;\r\n\r\n                    if (!int.TryParse(context.GetArgument<string>(\"LanguageLCID\"), out languageLCID))\r\n                    {\r\n                        context.Errors.Add(new ExecutionError(\"Wrong value for LanguageLCID\"));\r\n                        return null;\r\n                    }\r\n\r\n                    var loader =\r\n                        dataLoaderAccessor.Context.GetOrAddCollectionBatchLoader<Tuple<short, int>, BodySystemTranslation>(\r\n                            \"GetBodySystemTranslationByBodySystemIdAndLanguageLCID\", GetBodySystemTranslationByBodySystemIdAndLanguageLCID);\r\n\r\n                    return loader.LoadAsync(Tuple.Create(context.Source.Id, languageLCID));\r\n                });\r\n\r\n        public async Task<ILookup<Tuple<short, int>, BodySystemTranslation>> GetBodySystemTranslationByBodySystemIdAndLanguageLCID(IEnumerable<Tuple<short, int>> keys)\r\n        {\r\n            var bodySystemTranslations = await _bodySystemContext.BodySystemTranslation.Where(CompositeKeyPredicate<BodySystemTranslation>.Generate(_bodySystemContext, keys)).ToListAsync();\r\n            return bodySystemTranslations.ToLookup(x => Tuple.Create(x.BodySystemId, x.LanguageLCID)); ;\r\n        }\r\n```\r\n\r\nwhen i issue a query that looks like this \r\n```\r\nbodySystemBaseQueries{\r\n    bodySystemQueries{\r\n      bodySystems{\r\n        id\r\n        name\r\n        bodySystemTranslation(languageLCID: \"1\"){\r\n          name\r\n        }\r\n      }\r\n```\r\n\r\nit queries the database allright and returns the correct results during debugging, but something wrong happens during the .ToLookup call and it just throws and exception in graphiql saying\r\n\r\n`\"message\": \"GraphQL.ExecutionError: Expected value of type \\\"BodySystemTranslationType\\\" for \\\"BodySystemTranslationType\\\" but got: System.Linq.Grouping`2[System.Tuple`2[System.Int16,System.Int32],Healox.Backend.Data.BodySystemBase.BodySystemTranslation].\\r\\n   at GraphQL.Execution.ExecutionStrategy.ValidateNodeResult(ExecutionContext context, ExecutionNode node)\\r\\n   at GraphQL.Execution.ExecutionStrategy.ExecuteNodeAsync(ExecutionContext context, ExecutionNode node)\",`\r\n\r\nCan someone please explain what am i doing wrong and how to do it correctly?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1359/comments",
    "author": "Walid-Abdulrazik",
    "comments": [
      {
        "user": "Walid-Abdulrazik",
        "created_at": "2019-10-26T17:39:28Z",
        "body": "After a lot of tinkering and failures, i managed to use the Dataloader with composite primary keys and here is how ...\r\n\r\n```\r\n            Field<ListGraphType<BodySystemTranslationType>>(\r\n                \"BodySystemTranslation\",\r\n                arguments: new QueryArguments(new QueryArgument<NonNullGraphType<IdGraphType>> { Name = \"LanguageLCID\" }),\r\n                resolve: context =>\r\n                {\r\n                    int languageLCID;\r\n\r\n                    if (!int.TryParse(context.GetArgument<string>(\"LanguageLCID\"), out languageLCID))\r\n                    {\r\n                        context.Errors.Add(new ExecutionError(\"Wrong value for LanguageLCID\"));\r\n                        return null;\r\n                    }\r\n\r\n                    var loader =\r\n                        dataLoaderAccessor.Context.GetOrAddCollectionBatchLoader<(short, int), BodySystemTranslation>(\r\n                            \"GetBodySystemTranslation\", GetBodySystemTranslation);\r\n                    return loader.LoadAsync((context.Source.Id, languageLCID));\r\n                });\r\n\r\n        public async Task<ILookup<(short, int), BodySystemTranslation>> GetBodySystemTranslation(IEnumerable<(short, int)> keys)\r\n        {\r\n            var bodySystemTranslations = await _bodySystemContext.BodySystemTranslation.Where(CompositeKeyPredicate<BodySystemTranslation>.Generate(_bodySystemContext, keys)).ToListAsync();\r\n            return bodySystemTranslations.ToLookup(p => (p.BodySystemId, p.LanguageLCID));\r\n        }\r\n\r\n```\r\n\r\n@joemcbride , @sungam3r Hope this is useful to someone out there ... and i suggest you add it to the documentation if that is possible, would save some of us a lot of time and frustrations ..."
      },
      {
        "user": "sungam3r",
        "created_at": "2019-10-26T18:27:36Z",
        "body": "Perhaps this is due to the fact that you changed class `Tuple` to a struct `ValueTuple`. This issue should be left open until the reasons are clarified."
      },
      {
        "user": "Walid-Abdulrazik",
        "created_at": "2019-10-26T19:05:01Z",
        "body": "@sungam3r  this is quite embarrassing, actually both solutions work , the problem with the first solution was the field definition ...\r\n\r\n`Field<BodySystemTranslationType> `\r\nvs\r\n`Field<ListGraphType<BodySystemTranslationType>>`\r\n\r\nso actually both Tuple and ValueTuple work ..."
      },
      {
        "user": "sungam3r",
        "created_at": "2019-10-26T20:34:23Z",
        "body": "Oh sure! I overlooked it. Indeed, in the second case, the list is lost, so the code does not work. Let's leave this issue open, maybe we should add some kind of check that will tell the developer what is wrong, and not leave it alone with the problem."
      },
      {
        "user": "Shane32",
        "created_at": "2023-04-23T15:37:10Z",
        "body": "I commonly use a ValueTuple for composite keys, and it works well."
      }
    ]
  },
  {
    "number": 1353,
    "title": "Auto Registering graph type for input types",
    "created_at": "2019-10-19T22:08:29Z",
    "closed_at": "2019-10-20T00:12:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1353",
    "body": "Hi, I was wondering how I can have an auto-registering graph type for input types?  I see there's a type for AutoRegisteringObjectGraphType<> but nothing for the input side.  Thanks",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1353/comments",
    "author": "jonathan82",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2019-10-20T00:12:46Z",
        "body": "You can look at the code of `AutoRegisteringObjectGraphType<>` as an example and write your own class that does the same thing for input types."
      },
      {
        "user": "jonathan82",
        "created_at": "2019-10-20T00:27:36Z",
        "body": "That's what I ended up doing. Thanks! "
      }
    ]
  },
  {
    "number": 1334,
    "title": "Graphql runtime schema with relationships",
    "created_at": "2019-10-08T13:17:51Z",
    "closed_at": "2021-02-15T00:11:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1334",
    "body": "Hey there, I have previously on gitter searched for a dynamich schema solution, the thing is that I don't really want a dynamic schema instead I want a schema generated on runtime, which is in a generic fashion, 1 GraphqlType, 1 or more case resolvers and thats it. Essentially I have made it so far that I have a graphql schema running but the problems are navigational properties from my models, I can't get them to work properly whatever I do. \r\n\r\nI tried to isolate the problem and I found I am having type conversion mismatches when I spin up the schema. Essentially the schema is made out of metadata: \r\n\r\nHere I have the column metadata,\r\n`\r\n  //public class ColumnMetadata\r\n\r\n    {\r\n        public string ColumnName { get; set; }\r\n        public string DataType { get; set; }\r\n        public FieldBaseType BaseType { get; set; }\r\n        public object Relation { get; set; }\r\n    }\r\n`\r\nQ: should I perhaps change the DataType to a object? Is the Relation object actually wrong implemented?\r\nThe TableType constructor is looking like this, I am using some TableMetadata and essentially looping through fields to initalise the fields from the GraphType, later on in a method I create graphqType fields, i.e. :\r\n\r\n` \r\n     \r\n\r\n            if (field.Relation != null)\r\n            {\r\n\r\n                var relatedObject = Tabledict[field.DataType];\r\n                var relatedTable = new TableType(relatedObject, Tabledict);\r\n                var listType = new ListGraphType(relatedTable);\r\n                graphqlType = relatedTable.GetType();\r\n\r\n                FieldType columnField = Field(\r\n                    graphqlType,\r\n                    relatedObject.TableName\r\n                    );\r\n\r\n                columnField.Resolver = new NameFieldResolver();\r\n\r\n            }\r\n            else\r\n            {\r\n                var graphQLType = (ResolveColumnMetaType(field.BaseType)).GetGraphTypeFromType(true);\r\n                var columnField = Field(\r\n                    graphQLType,\r\n                    field.ColumnName\r\n                );\r\n\r\n                columnField.Resolver = new NameFieldResolver();\r\n                FillArgs(field.ColumnName);\r\n            }\r\n            \r\n        } `\r\nin this method the magic happens, the else block works like a charm, but the if part is a little bit mystery to me, I can access it but when I get to making a new tableType I just get a null returned, and I don't know why, I only speculate it's a bad type conversion somwhere and thats why it's not working. Note I don't work with any popular orm so any also any pure reader writer advices are welcome(for type conversion that is)\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1334/comments",
    "author": "igorvuleta",
    "comments": [
      {
        "user": "isaksky",
        "created_at": "2019-11-05T19:38:37Z",
        "body": "I'm also constructing a schema at runtime, and was able to get it to work. I did it in 3 phases:\r\n\r\n- Phase 1 - just register the type containers without members (because they may point to things that have not been initialized yet)\r\n- Phase 2 - add members (e.g., fields) to the types\r\n- Phase 3 - add all top level fields. (All types are now initialized.)\r\n\r\nYou also need to add \"Query\" and \"Mutation\" fields to the schema at the beginning, (and register them), or it will not work (bug).\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2019-11-05T20:31:32Z",
        "body": "> You also need to add \"Query\" and \"Mutation\" fields to the schema at the beginning, (and register them), or it will not work (bug).\r\n\r\nCan you show in more detail what you call a bug?"
      },
      {
        "user": "isaksky",
        "created_at": "2019-11-05T20:43:23Z",
        "body": "@sungam3r I hade code like this:\r\n\r\n```fsharp\r\n  let schema = new GraphQL.Types.Schema()\r\n\r\n  // 1 -  Create ObjectTypes, Enums, etc\r\n  // ...\r\n  \r\n  // 2 - Set up the root fields\r\n  let query = GraphQL.Types.ObjectGraphType(Name = \"Query\")\r\n  schema.RegisterType(query)\r\n  schema.Query <- query\r\n  let mutation = GraphQL.Types.ObjectGraphType(Name = \"Mutation\")\r\n  schema.RegisterType(mutation)\r\n  schema.Mutation <- mutation\r\n\r\n  for f in fields do\r\n    let f = createField f schema\r\n    query.AddField(f) |> ignore\r\n      \r\n  for f in mut_fields do\r\n    let f = createField f schema\r\n    mutation.AddField(f) |> ignore\r\n```\r\n\r\nThat kind of code led to this error upon starting GraphiQL:\r\n\r\n```\r\nError: Invalid or incomplete schema, unknown type: Query. Ensure that a full introspection query is used in order to build a client schema.\r\n```\r\n\r\nMoving 2 before 1 fixed that problem."
      },
      {
        "user": "sungam3r",
        "created_at": "2019-11-05T21:31:01Z",
        "body": "Roughly understandable. It is better to make a separate issue to keep this issue focused on relationships. To use introspection, one can write a unit test and try to reproduce the error without GraphiQL."
      },
      {
        "user": "sungam3r",
        "created_at": "2021-02-15T00:11:36Z",
        "body": "Closed due to inactivity. I hope v4 release will fix some bugs mentioned here."
      }
    ]
  },
  {
    "number": 1331,
    "title": "ObjectGraphType meaning",
    "created_at": "2019-10-07T13:56:21Z",
    "closed_at": "2019-10-20T07:40:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1331",
    "body": "I wonder about the need for an `ObjectGraphType` type:\r\n```c#\r\npublic class ObjectGraphType : ObjectGraphType<object>\r\n{\r\n}\r\n```\r\nIt is a degenerate type that does not carry any logic, the so-called type-alias. In general, such types are not recommended. Is there any reason to have this type explicitly given? I see that the vast majority of its use is in the test project. Is it possible to move it there, and in the main project use `ObjectGraphType<object>` instead?\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1331/comments",
    "author": "sungam3r",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2019-10-13T22:39:30Z",
        "body": "@joemcbride Any thoughts?"
      },
      {
        "user": "sungam3r",
        "created_at": "2019-10-20T06:14:03Z",
        "body": "Also the same thoughts about `InputObjectGraphType`."
      },
      {
        "user": "joemcbride",
        "created_at": "2019-10-20T07:40:11Z",
        "body": "Those types were the original ones provided by this project.  The generic type came later.  There are a lot of cases where you don’t care about the type, as proved by all those tests that don’t use one.  Removing those types is not a breaking change I want to make at this time."
      },
      {
        "user": "sungam3r",
        "created_at": "2019-10-20T11:59:35Z",
        "body": "> Those types were the original ones provided by this project. The generic type came later. \r\n\r\nAh, now I get the point. Yes, in this case, of course, they must be preserved."
      }
    ]
  },
  {
    "number": 1314,
    "title": "Why won't dependency injection work in my Type classes? trying to inject IDataLoaderContextAccessor",
    "created_at": "2019-09-25T15:57:06Z",
    "closed_at": "2019-09-25T17:05:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1314",
    "body": "I am using GraphQL.NET 3.5.0-alpha0027 in a asp.net core 2.2 api project\r\n\r\nmy ConfigureServices is as follows\r\n\r\n        public void ConfigureServices(IServiceCollection services)\r\n        {\r\n            services.AddMvc();\r\n            services.AddDbContext<BodySystemContext>();\r\n            services.AddSingleton<IServiceProvider>(c => new FuncServiceProvider(type => c.GetRequiredService(type)));\r\n            services.AddScoped<GraphQLSchema>();\r\n            services.AddGraphQL(o => { o.ExposeExceptions = true; o.EnableMetrics = true; })\r\n                .AddGraphTypes(ServiceLifetime.Scoped)\r\n                .AddDataLoader();\r\n        }\r\n\r\nmy Configure is as follows\r\n\r\n        public void Configure(IApplicationBuilder app, IHostingEnvironment env)\r\n        {\r\n            app.UseGraphQL<GraphQLSchema>();\r\n            app.UseGraphQLPlayground(new GraphQLPlaygroundOptions());\r\n        }\r\n\r\nmy type class is as follows\r\n\r\n    public class BodySystemType : ObjectGraphType<BodySystem>\r\n    {\r\n        public BodySystemType(IDataLoaderContextAccessor dataLoaderAccessor)\r\n        {\r\n            Field(f => f.Id, type: typeof(IdGraphType));\r\n            Field(f => f.Name);\r\n            Field(f => f.Description, nullable: true);\r\n            Field(f => f.RowVersion, type: typeof(ListGraphType<ByteGraphType>));\r\n            Field<ListGraphType<BodySystemTranslationType>>(\r\n                \"BodySystemTranslations\",\r\n                resolve: context =>\r\n                {\r\n                    var loader =\r\n                        dataLoaderAccessor.Context.GetOrAddCollectionBatchLoader<short, BodySystemTranslation>(\r\n                            \"GetBodySystemTranslationByBodySystem\", GetBodySystemTranslationByBodySystemId);\r\n                    return loader.LoadAsync(context.Source.Id);\r\n                });\r\n        }\r\n\r\n        public async Task<ILookup<short, BodySystemTranslation>> GetBodySystemTranslationByBodySystemId(IEnumerable<short> bodySystemIds)\r\n        {\r\n            var bodySystemTranslations = await (new BodySystemContext()).BodySystemTranslation.Where(a => bodySystemIds.Contains(a.BodySystemId)).ToListAsync();\r\n            return bodySystemTranslations.ToLookup(x => x.BodySystemId);\r\n        }\r\n    }\r\n\r\nmy project compiles and runs playground alright but it won't show a schema and when i try to query it fails with error about needing a type with a parameterless constructor\r\n\r\n\"errors\": [\r\n    {\r\n      \"message\": \"GraphQL.ExecutionError: Failed to call Activator.CreateInstance. Type: Api.GraphQL.Types.BodySystemType ---> System.Exception: Failed to call Activator.CreateInstance. Type: Api.GraphQL.Types.BodySystemType ---> System.MissingMethodException: No parameterless constructor defined for this object.\\r\\n   at System.RuntimeTypeHandle.CreateInstance(RuntimeType type, Boolean publicOnly, Boolean wrapExceptions, Boolean& canBeCached, RuntimeMethodHandleInternal& ctor)\\r\\n   at System.RuntimeType.CreateInstanceSlow(Boolean publicOnly, Boolean wrapExceptions, Boolean skipCheckThis, Boolean fillCache)\\r\\n   at System.Activator.CreateInstance(Type type, Boolean nonPublic, Boolean wrapExceptions)\\r\\n   at GraphQL.DefaultServiceProvider.GetService(Type serviceType)\\r\\n   --- End of inner exception stack trace ---\\r\\n   at GraphQL.DefaultServiceProvider.GetService(Type serviceType)\\r\\n   at GraphQL.Utilities.ServiceProviderExtensions.GetRequiredService(IServiceProvider provider, Type serviceType)\\r\\n   at GraphQL.Types.Schema.<CreateTypesLookup>b__59_1(Type type)\\r\\n   at GraphQL.Types.GraphTypesLookup.AddTypeIfNotRegistered(Type type, TypeCollectionContext context)\\r\\n   at GraphQL.Types.GraphTypesLookup.HandleField(Type parentType, FieldType field, TypeCollectionContext context)\\r\\n   at GraphQL.Types.GraphTypesLookup.AddType(IGraphType type, TypeCollectionContext context)\\r\\n   at GraphQL.Types.GraphTypesLookup.Create(IEnumerable`1 types, IEnumerable`1 directives, Func`2 resolveType, IFieldNameConverter fieldNameConverter, Boolean seal)\\r\\n   at GraphQL.Types.Schema.CreateTypesLookup()\\r\\n   at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)\\r\\n   at System.Lazy`1.ExecutionAndPublication(LazyHelper executionAndPublication, Boolean useDefaultConstructor)\\r\\n   at System.Lazy`1.CreateValue()\\r\\n   at GraphQL.Types.Schema.get_AllTypes()\\r\\n   at GraphQL.Instrumentation.FieldMiddlewareBuilder.ApplyTo(ISchema schema)\\r\\n   at GraphQL.DocumentExecuter.ExecuteAsync(ExecutionOptions options)\\r\\n   --- End of inner exception stack trace ---\",\r\n      \"extensions\": {\r\n        \"code\": \"MISSING_METHOD\"\r\n      }\r\n    }\r\n\r\nafter some searching i figured that it cannot resolve the IDataLoaderContextAccessor ... is that right ? and if yes how can i solve this ? and how can i use the dataloader IDataLoaderContextAccessor  without injection !!!",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1314/comments",
    "author": "Walid-Abdulrazik",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2019-09-25T16:14:21Z",
        "body": "How is your Schema defined?  Is it setup to inject the `IServiceProvider`?\r\n\r\n```csharp\r\npublic MySchema(IServiceProvider provider)\r\n    : base(provider)\r\n{}\r\n```"
      },
      {
        "user": "Walid-Abdulrazik",
        "created_at": "2019-09-25T17:05:29Z",
        "body": "> How is your Schema defined? Is it setup to inject the `IServiceProvider`?\r\n> \r\n> ```cs\r\n> public MySchema(IServiceProvider provider)\r\n>     : base(provider)\r\n> {}\r\n> ```\r\n\r\n@joemcbride , Actually yes, it was injecting the IServiceProvider but unfortunately it was not passing it to base class, like follows\r\n\r\n```\r\npublic MySchema(IServiceProvider provider)\r\n{\r\n}\r\n```\r\n\r\nbut after i modified it to pass the IServiceProvider to the base class like you suggested, it now works like a champ ...\r\n\r\nThank you very much, i appreciate the help \r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2019-09-25T18:02:59Z",
        "body": "@Walid-Abdulrazik You can remove this line\r\n```c#\r\nservices.AddSingleton<IServiceProvider>(c => new FuncServiceProvider(type => c.GetRequiredService(type)));\r\n```\r\n\r\nMS DI has builtin support for `IServiceProvider`"
      }
    ]
  },
  {
    "number": 1306,
    "title": "Errors don't bubble up",
    "created_at": "2019-09-18T08:30:50Z",
    "closed_at": "2020-01-06T02:00:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1306",
    "body": "Hi,\r\n\r\nI am building an GraphQL API which uses as NonNullGraphType field. When the field resolver throws an ExecutionError (or adding an error to context.Errors) the field is null in the response. As far as I understand it, it should not allowed to be null, but the null should bubble up to the nearest nullable field. Am I doing something wrong, or is this just not implemented in the library?\r\n\r\nThank you for your help!",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1306/comments",
    "author": "acoder999",
    "comments": [
      {
        "user": "patrik-j-nilsson",
        "created_at": "2019-09-30T15:12:28Z",
        "body": "We are having this issue as well, seem to be fixed in 3.0!"
      },
      {
        "user": "sungam3r",
        "created_at": "2019-09-30T17:44:36Z",
        "body": "@acoder999 , @sommarlov Can you please provide an example or (which is better) write a unit test to expose the problem?"
      },
      {
        "user": "SimonCropp",
        "created_at": "2020-01-06T02:00:40Z",
        "body": "closing due to no response."
      }
    ]
  },
  {
    "number": 1298,
    "title": "ResolveFieldContext",
    "created_at": "2019-09-12T16:14:04Z",
    "closed_at": "2020-03-29T09:50:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1298",
    "body": "Hi,\r\n\r\nIs there any reason why we can't resolve service from the ResolveFieldContext.\r\nIm trying to add dynamic type (CMS) for my project and dont like the fact i must resolve all my services in advance before event knowing what will be the query, maybe i dont get it at all.\r\n\r\nAlso, IFieldResolver could be async?\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1298/comments",
    "author": "eddyjl077",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-03-02T00:03:38Z",
        "body": "Actually you can. See #1160 and related discussions. \r\n\r\nAlso now `Schema` explicitly implements `IServiceProvider` so you can do comething like \r\n```\r\n((IServiceProvider)context.Schema).GetRequiredService<ISomething>()\r\n```\r\n\r\n> Also, IFieldResolver could be async?\r\n\r\nI do not understand."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-29T09:50:38Z",
        "body": "Closed due to lack of feedback."
      }
    ]
  },
  {
    "number": 1293,
    "title": "Pass value from parent to subtree",
    "created_at": "2019-09-05T23:16:31Z",
    "closed_at": "2021-02-21T00:22:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1293",
    "body": "Is it somehow possible to pass an argument to a child value resolver?\r\n\r\nAs far as I understand the source code, variables are always the same instance for all resolvers, but I need to pass it for the whole subtree only. For another object, this object will be changed.\r\n\r\nI try to achieve a nested UnitOfWork structure, so each subtree will get a new UnitOfWork.\r\nFor mutations, I want to commit all changes only after all mutations executed correctly.\r\n\r\nTo mutate arguments or variables would be a good way to achieve this, but because the engine executes everything in parallel, there is no guarantee another node wouldn't override the value in between.\r\n\r\nSo basically I need a way to provide/inject values in child nodes.\r\n\r\nThx in advance.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1293/comments",
    "author": "dotlogix",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2019-09-06T07:00:04Z",
        "body": "As an option you can try to achive this by `UserContext` property to store arguments in your special tree structure."
      },
      {
        "user": "dotlogix",
        "created_at": "2019-09-06T14:31:17Z",
        "body": "Interesting idea, but it does not provide any way to ensure access to parent context, to get proper nesting working.\r\n\r\nI also thought about an AsyncLocal variable to apply the value to the logical async execution path, but because of the internal implementation this will not work\r\n\r\nPseudo Code:\r\nForEach Executor In Queue\r\n-- Execute Field As Result\r\n-- IF Result Is Object\r\n-- Queue.Add(Result.Children)\r\n\r\nSo the hierarchy and the execution path is completely flat and not recursive so no chance to achieve sth like this.\r\n\r\nAlso, UserContext is unique and the same instance for the whole schema, so I can pass arguments in, but if I mutate them it will change for all executors and not only for children.\r\n\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2019-09-06T14:42:57Z",
        "body": "It is just a shared state, usage of which is up to you."
      },
      {
        "user": "dotlogix",
        "created_at": "2019-09-06T15:22:12Z",
        "body": "I understand, but even if I would add a custom context logic to get the correct context I still need a way to relate a child node to its parent, what is not possible right?\r\n\r\nHer is an example:\r\nRoot\r\n - Field 1 (int)\r\n - Field 2 (string)\r\n - Field 3 (Object)\r\n   - Sub Field 3.1\r\n - Field 4 (Object)\r\n   - Sub Field 4.1\r\n\r\nIf you Imagine you have a context class UserContext and NestedUserContext\r\nHow could I ensure Field 1-4 get an instance of UserContext,\r\nbut SubField 3.1 gets a nested Context based on the parent\r\nand SubField 4.1 gets a nested Context based on parent\r\n\r\nBut the Context provided for 3.1 and 4.1 is not the same instance\r\n\r\nIt gets far more complicated if you imagine there is another nested layer. Then I would expect\r\nRoot gets a Context\r\nSubField 3.1 Gets a nested Context based on Root\r\nSubField 3.1.1 Gets a nested Context based on 3.1\r\n\r\nBecause the Api executes everything in one layer and not in a recursive way this is just impossible\r\n\r\n\r\n\r\n\r\n\r\n"
      },
      {
        "user": "barryhagan",
        "created_at": "2019-09-10T00:58:10Z",
        "body": "Take a look at using the `Path` property on `ResolveFieldContext`.   This is an array of names to get you from root to the current leaf.\r\n\r\nYou could use this to build keys for a concurrent dictionary to load whatever context/parent object you need based on where you are.   I would probably make a locator object that takes a `Path` and gives you back an appropriate object scoped from the parent knowing that parent's `Path` will be the current `Path` except the last item.   If that is an empty array, you are at the root.\r\n\r\nEven though the nested mutations will run in parallel at a given depth, you should always have the parent loaded before the children fire.\r\n\r\n"
      },
      {
        "user": "JoeEager",
        "created_at": "2020-02-17T21:32:27Z",
        "body": "Is there an example of this?  I'm looking to use the parent value to retrieve a subvalue\r\n\r\nParentA {\r\n   ParentId\r\n   ChildB {\r\n      Value1 //Changes based on ParentId\r\n   }\r\n}\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2021-02-17T23:26:51Z",
        "body": "I think that this issue is a duplicate of #899 . May be fixed by #2295. Instead of passing values from parent to subtree you can climb up the tree from child node to its parent , grandparent and so on to get arguments or some state that you need."
      },
      {
        "user": "sungam3r",
        "created_at": "2021-02-21T00:22:17Z",
        "body": "@dotlogix #2295 was merged and will be published in the v4 release."
      }
    ]
  },
  {
    "number": 1288,
    "title": "Provide dynamically Input type and query type",
    "created_at": "2019-09-03T14:11:48Z",
    "closed_at": "2020-03-29T09:52:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1288",
    "body": "I need your help with solving my problem. I have simple object, like \"Car\" with only two fields \"Id, Name\". But in query and in mutation I need to provide dynamically fields which not in class.\r\n```\r\n   public class Car\r\n   {\r\n        public int Id { get; set; }\r\n        public string Name { get; set; }\r\n   }\r\n\r\n   public class CarInputType : InputObjectGraphType<Car>\r\n   {\r\n        public CarInputType()\r\n        {\r\n            Name = \"CarInput\";\r\n            Field(x => x.Id).Description(\"\");\r\n            Field(x => x.Name).Description(\"\");\r\n        }\r\n   }\r\n    public class CarType : ObjectGraphType<Car>\r\n    {\r\n        public CarType()\r\n        {\r\n            Name = nameof(Car);\r\n\r\n            Field(x => x.Id, nullable: true).Description(\"\");\r\n            Field(x => x.Name, nullable: true).Description(\"\");\r\n        }\r\n    }\r\n```\r\nmutation and query like this\r\n```\r\nmutation {\r\n  CarPost(\r\n    CarInput: {\r\n      Name: \"Vehicle\"\r\n      Wheels: 4\r\n      Manufacture: \"BMW\"\r\n        }\r\n     )\r\n  {\r\n      Id\r\n  }\r\n}\r\n```\r\n```\r\nquery {\r\n    CarInput: {\r\n      Name: \"Vehicle\"\r\n      Wheels: 4\r\n      Manufacture: \"BMW\"\r\n  }\r\n}\r\n```\r\nNow I can't do it because I have validation error\r\n```\r\n{\r\n  \"error\": {\r\n    \"errors\": [\r\n      {\r\n        \"message\": \"GraphQL.Validation.ValidationError: Argument \"Car\" has invalid value { \r\n         Name: \"Vehicle\", Wheels: \"4\", Manufacture: \"BMW\"}. In field \"Wheels\" and \r\n          \"Manufacture\": Unknown fields.\"\r\n       }\r\n      ]\r\n   }\r\n}\r\n```\r\nI need to put this fields by graphQl, resolve it and write to document-like DB.\r\nFor now I haven't found any solutions except turning off ArgumentsOfCorrectType() rule.\r\nBut this solution doesn't look fot me like a good one. Could you please provide me any advice how to reach my goal. Thanks for any help!",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1288/comments",
    "author": "temofeychik",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-03-01T23:58:41Z",
        "body": "GraphQL API has no _dynamic fields_. You fully describe API. However, you can always use a field/argument of type `String` to pass any data structure in it, usually JSON."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-29T09:52:31Z",
        "body": "Closed due to lack of feedback."
      }
    ]
  },
  {
    "number": 1287,
    "title": "Mutations: How to map alternative name of a Field back to its original property",
    "created_at": "2019-09-03T06:57:17Z",
    "closed_at": "2020-02-25T11:42:45Z",
    "labels": [
      "bug",
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1287",
    "body": "Scenario: a property on a node was renamed from \"FirstName\" to \"FName\". To not break the interface I want to keep the old name for a certain time of periode. Because of that I apply an alternative name \"FirstName\" on the InputType, see sample below:\r\n\r\n```\r\npublic class HumanInputType : InputObjectGraphType<Human>\r\n{\r\n        public HumanInputType()\r\n        {\r\n            Name = \"HumanInput\";\r\n            Field(x => x.Name);\r\n            Field(x => x.FName).Name(\"FirstName\");\r\n        }\r\n}\r\n```\r\n\r\nFrom the client perspective it is working as expected. For above sample I get \"Name\" and \"FirstName\" as parameter.\r\n\r\nFrom the resolver perspective I would have expected that \"FirstName\" gets mapped to \"FName\" on type \"Human\". But it is not. Further in the context.Arguments of \"human\" I see keys for \"Name\" and \"FirstName\" (same here). \r\n\r\n```\r\nresolve: context =>\r\n{\r\n            var human = context.GetArgument<Human>(\"human\");\r\n            return data.AddHuman(human);\r\n});\r\n```\r\n\r\nHow can I map from \"FirstName\" to \"FName\" in a generic way? I thought this is done by the field configuration on the HumandInputType automatically. ",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1287/comments",
    "author": "pulla2908",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2019-09-03T09:23:38Z",
        "body": "Relates to #1107 ?"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-25T11:44:46Z",
        "body": "@pulla2908 merged!"
      }
    ]
  },
  {
    "number": 1264,
    "title": "Use Total records count under Extensions",
    "created_at": "2019-08-21T09:36:12Z",
    "closed_at": "2020-03-29T09:49:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1264",
    "body": "Query implementation look like this:\r\n```csharp\r\n   public class ContactQuery : ObjectGraphType\r\n    {\r\n        public ContactQuery(ContactContext contactContext)\r\n        {\r\n            FieldAsync<ListGraphType<ContactType>>(\"contacts\",\r\n                arguments: new QueryArguments(new List<QueryArgument>\r\n                {\r\n                     //other arguments\r\n  \r\n                    new QueryArgument<IntGraphType> { Name = \"limit\", DefaultValue = 10 },\r\n                    new QueryArgument<IntGraphType> { Name = \"offset\", DefaultValue = 0 }\r\n                }),\r\n                resolve: async context =>\r\n                {\r\n                    var query = contactContext.Contacts\r\n                        .Include(x => x.ContactAddresses)\r\n                        .Include(x => x.PhoneNumbers)\r\n                        .AsQueryable();\r\n\r\n                  // other query logic using passed arguments\r\n\r\n                    var totalRecordsCount = query.AsQueryable().Count();\r\n                    var offset = context.GetArgument<int>(\"offset\");\r\n                    var limit = context.GetArgument<int>(\"limit\");\r\n\r\n                  return await query\r\n                        .Skip(offset)\r\n                        .Take(limit)\r\n                        .ToListAsync();\r\n                });\r\n     }\r\n}\r\n```\r\nAt the end of query logic i am using ```var totalRecordsCount = query.AsQueryable().Count();```\r\nfor getting total records count. How to save this count number and use it outside this context?\r\nI want to put this number under Extensions.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1264/comments",
    "author": "petrdicp",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2019-08-21T12:37:52Z",
        "body": "You can use `ResolveFieldContext.UserContext` to store any value. Then you can get this value in `DocumentExecuter.ExecuteAsync` (you may want to copy ExecuteAsync method into your own `CustomDocumentExecuter`) and write it into `ExecutionResult.Extensions`. I see that now there is only one application of extensions - `EnrichWithApolloTracing`. Extensions in general are an external entity with respect to GraphQL, and they will have to be recorded in the middleware layer."
      },
      {
        "user": "barryhagan",
        "created_at": "2019-08-23T21:53:37Z",
        "body": "What is the purpose of adding it to Extensions?  If that is for the client to consume, it would probably be better to return an object graph that includes count information in addition to the results (look at the Relay Connection concept, or make your own return type that has both count and results in it).\r\n\r\nIt is perfectly valid to have more than one query in a request using aliasing, so you will have problems if it is just thrown into an extension field:\r\n```\r\n{\r\n  firstTen: contacts(limit: 10) {\r\n    name\r\n  }\r\n  firstTwenty: contacts(limit: 20) {\r\n    name\r\n  }\r\n}\r\n```\r\n\r\nvs.\r\n\r\n```\r\n{\r\n  firstTen: contacts(limit: 10) {\r\n    totalCount\r\n    items { name }\r\n  }\r\n  firstTwenty: contacts(limit: 20) {\r\n    totalCount\r\n    items { name }\r\n  }\r\n}\r\n```\r\n\r\nI'd rather have `totalCount` as a property in the graph, and then I can use the `items` instead of trying to figure it out in the extensions.\r\n\r\n\r\n\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2019-08-24T05:45:01Z",
        "body": "@barryhagan completely agree with you"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-02T05:10:28Z",
        "body": "@petrdicp Is this issue still actual for you?"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-29T09:49:18Z",
        "body": "Closed due to lack of feedback."
      }
    ]
  },
  {
    "number": 1254,
    "title": "Mark objects not to cause impact during complexity analysis",
    "created_at": "2019-08-19T20:15:47Z",
    "closed_at": "2022-06-07T17:35:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1254",
    "body": "Is there a way to mark custom types and/or fields to be ignored in complexity analysis?\r\n\r\nWe have a complex structure like this:\r\n```\r\nprice {\r\n  value\r\n  currency {\r\n      identifier\r\n  }\r\n  units {\r\n      identifier\r\n      category {\r\n          identifier\r\n      }\r\n  }\r\n}\r\n```\r\nThe problem we are facing is the fact that currency and units (plus their category) are cached and we just pick up and ID from the DB alongside value and then just get those from the cache.\r\nHowever, all this nesting is calculated in both depth and complexity of the query. Is there a way to avoid this without implementing our analyzer?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1254/comments",
    "author": "SDLionas",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-08-18T23:49:10Z",
        "body": "Now default complexity analyzer is very limited in its capabilities.\r\n\r\n> Is there a way to avoid this without implementing our analyzer?\r\n\r\nNot yet."
      },
      {
        "user": "sungam3r",
        "created_at": "2022-06-07T17:35:35Z",
        "body": "@SDLionas You can configure individual field impact now:\r\n```cs\r\n   Field<IntGraphType>(\"id\", resolve: context => ...).WithComplexityImpact(0);\r\n```"
      }
    ]
  },
  {
    "number": 1225,
    "title": "How do I deserialize paginated arrays?",
    "created_at": "2019-07-31T16:36:39Z",
    "closed_at": "2023-04-23T17:16:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1225",
    "body": "## Summary\r\n\r\nA problem I've been running into recently is dealing with pagination of Json I receive from the server. I can work around some instances but would like a better approach. So this sample query here illustrates a problem I can run into:\r\n\r\nModules\r\n    {\r\n        ID\r\n        Title\r\n        Description\r\n        Lessons\r\n        {\r\n            edges\r\n            {\r\n                node\r\n                {\r\n                    ID\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\nSo for the lessons array, the server inserts the edges and node elements because of the use of pagination. With pagination turned off, the structure of the request is much more as I expect:\r\n\r\nModules\r\n{\r\n    ID\r\n    Title\r\n    Description\r\n    Lessons\r\n    {\r\n        ID\r\n    }\r\n}\r\n\r\nI'm using JSON.Net with the C# library provided by GraphQL. \r\n\r\nI suppose two questions here, firstly is this difference expected in terms of the json I receive? And if that's the case, does anyone have workarounds they use?\r\n\r\nThanks!\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1225/comments",
    "author": "LukasRoper",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2023-04-23T17:16:08Z",
        "body": "This question seems to be more of a client question as it relates to a specific API, rather than a question as to how to implement a specific design in GraphQL.NET.  Moreover as the question has not been answered in 4 years, I'm closing.  @LukasRoper if you have a question regarding the GraphQL.NET API, please ask - thanks!"
      }
    ]
  },
  {
    "number": 1218,
    "title": "Additional information in the error response",
    "created_at": "2019-07-12T06:34:15Z",
    "closed_at": "2020-02-25T06:44:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1218",
    "body": "\r\n## Summary\r\n\r\nAdditional information in the error response\r\n\r\n## Relevant information\r\n\r\nWhile executing a query, if an error occurs, is there a way to provide additional information in the error message returned from the GraphQL Query execution?\r\n\r\nFor example, when a non-null field is resolved with a null value, is there a way to specify an identifier of root node in the error response?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1218/comments",
    "author": "raphaelvp",
    "comments": [
      {
        "user": "sgwozdz",
        "created_at": "2019-07-12T13:21:58Z",
        "body": "I had to provide some additional information in error responses. What I did to support it, is just response parser after `_documentExecuter.ExecuteAsync`. \r\nInside the parser I check what kind of `Exception` were thrown. Correct handler takes the custom exception data I need and put them to `ExtendedExecutionError`, which is just a simple class with `ExecutionError` as base class. On the end I replace original `ExecutionError`.\r\n\r\n```\r\npublic class ExtendedExecutionError : ExecutionError\r\n    {\r\n        public ExtendedExecutionError(string code, string message)\r\n            : base(message)\r\n        {\r\n            Code = code;\r\n        }\r\n    }\r\n```"
      },
      {
        "user": "sungam3r",
        "created_at": "2019-07-18T20:12:01Z",
        "body": "@raphaelvp I think that in this case, in a completely natural and simple way, you can use the `Exception.Data` property. GraphQL uses `ExecutionResultJsonConverter` to serialize response. Among other things this converter also writes extended error information that it extracts from exception type and `Data` property.\r\n\r\nHaving such a code\r\n```c#\r\n Field<StringGraphType>(\r\n                \"myField\",\r\n                resolve: ctx =>\r\n                {\r\n                    var ex = new ApplicationException(\"oops!\");\r\n                    ex.Data[\"b\"] = 42;\r\n                    ex.Data[\"h\"] = \"dddd\";\r\n                    throw ex;\r\n                    return \"blablabla\";\r\n                });\r\n```\r\nyou will get that response\r\n```json\r\n{\r\n  \"data\": {\r\n    \"myField\": null\r\n  },\r\n  \"errors\": [\r\n    {\r\n      \"message\": \"Error trying to resolve myField.\",\r\n      \"locations\": [\r\n        {\r\n          \"line\": 3,\r\n          \"column\": 3\r\n        }\r\n      ],\r\n      \"path\": [\r\n        \"myField\"\r\n      ],\r\n      \"extensions\": {\r\n        \"code\": \"APPLICATION\",          <------ derived from `exception.GetType()`\r\n        \"data\": {                       <------ and here is our extended information\r\n          \"b\": 42,\r\n          \"h\": \"dddd\"\r\n        }\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nAlso note that there is no error message _oops!_ in the response. This is done by design. If you want to see the source exception message than use `ExecutionOptions.ExposeExceptions = true` which is `false` by default.\r\n\r\nGraphQL client can interpret that information in extensions response section in any way.\r\n\r\nAlso see #1164 . This change will allow to augment (or even change exception type) any exception. "
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-25T06:44:16Z",
        "body": "Closed as resolved."
      }
    ]
  },
  {
    "number": 1184,
    "title": "Resolve related object from dbcontext in Field conflicted with scope lifetime dependency injection",
    "created_at": "2019-06-13T01:21:27Z",
    "closed_at": "2020-03-01T23:50:18Z",
    "labels": [
      "duplicate",
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1184",
    "body": "## Description\r\n\r\nHere is an example of article graph type I created in the system\r\n``` csharp\r\npublic ArticleGraphType(UserRepository users)\r\n{\r\n    Name = \"Article\";\r\n\r\n    Id(p => p.ArticleId);\r\n    Field(p => p.Title);\r\n    Field<UserGraphType>()\r\n        .Name(\"User\")\r\n        .ResolveAsync(async ctx => await users.Get(ctx.Source.UserId));\r\n}\r\n```\r\nBut I get exception when I query it, and it says the DbContext has been disposed, I did a quick debug, I can see it is true. All the scope dependencies are get disposed as soon as finish the resolve in the QueryGraphType, so it can't use continue to use them to resolve object in the other ObjectGraphType.\r\n\r\nCould someone help me check if it is an issue in the library or some mistake I made?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1184/comments",
    "author": "diouxis",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2019-06-13T17:02:36Z",
        "body": "See #1151 and #1160 "
      },
      {
        "user": "furier",
        "created_at": "2019-08-08T10:34:10Z",
        "body": "If the GraphType has the same lifetime as the Service, it should be fine.\r\n\r\nWe used to have all GraphTypes as Scoped per request and the same with all Services, then constructor injection was fine. However that means the entire graph is created on every request so we moved to GraphTypes as Singletons, only injecting Singletons in the constructor and Scoped services are resolved per resolver method, with IServiceProvider RequestServices."
      },
      {
        "user": "sungam3r",
        "created_at": "2019-08-08T17:47:39Z",
        "body": "Using RequestServices for resolving dependencies is ServiceLocator antipattern."
      },
      {
        "user": "furier",
        "created_at": "2019-08-08T17:58:39Z",
        "body": "> Using RequestServices for resolving dependencies is ServiceLocator antipattern.\r\n\r\nI agree but it's the only way we have found that makes it possible to keep the `GraphQLSchema` as a singleton, and it vastly improved performance."
      },
      {
        "user": "sungam3r",
        "created_at": "2019-08-08T23:13:32Z",
        "body": "It is not the only way. See #1160 "
      },
      {
        "user": "furier",
        "created_at": "2019-08-10T21:28:32Z",
        "body": "the implementation uses the RequestServices provider from the HttpContext, so what is the big difference? why is the other way an antipattern over this one?"
      },
      {
        "user": "sungam3r",
        "created_at": "2019-08-12T10:13:48Z",
        "body": "Because this is **implementation** and not user code. No need to burden the user code with the responsibility of manually resolving dependencies. Also `HttpContext` is just one of the possible existing providers that is hidden from user code. User code (resolvers) should not be tied to ASP.NET infrastructure at all."
      },
      {
        "user": "furier",
        "created_at": "2019-08-12T16:35:51Z",
        "body": "Firstly, I am not here to argue with you @sungam3r, this is an educational discussion for me.\r\n\r\n> User code (resolvers) should not be tied to ASP.NET infrastructure at all.\r\n\r\nFully agree on this one, but can be solved by having my own `IDependencyResolver` interface where I have an implementation resolving dependencies with an `IServiceProvider` which in this case happens to be RequestServices. Thus my user code is not tied to ASP.NET's infrastructure.\r\n\r\nHowever the `GraphTypes` I define are very much user code? I defined those types, I define what constructor arguments (services) are needed to resolve fields, the only difference to me is that manually resolving the dependencies in the resolvers may lead to more lines of code if the dependencies are used in multiple fields."
      },
      {
        "user": "sungam3r",
        "created_at": "2019-08-12T17:35:33Z",
        "body": "Ok.\r\n\r\n>  the only difference to me is that manually resolving the dependencies in the resolvers may lead to more lines of code if the dependencies are used in multiple fields.\r\n\r\nNot only more lines but **hidden** dependencies. Think about how configure/test/mock it (not only by you as author who know/remember all the code). "
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-01T23:50:18Z",
        "body": "Closed as duplicate in favor of #648 and related issues."
      }
    ]
  },
  {
    "number": 1159,
    "title": "Passing session / context data along from query to response",
    "created_at": "2019-05-25T21:44:50Z",
    "closed_at": "2021-02-23T23:01:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1159",
    "body": "In my `PossumLabQuery : ObjectGraphType` I  have the following code to grab some session stuff for each call. \r\n\r\n```\r\n            Func<ResolveFieldContext<object>, PossumLab.DomainObjects.Session> sessionResolver = \r\n                (context) => {\r\n                    var s =\r\n                        sessionManager.Rehydrate(\r\n                        context.GetArgument<PossumLab.DomainObjects.Session>(\"session\", defaultValue: null));\r\n\r\n                    return s; };\r\n```\r\nI'd like to capture this session somewhere that allows me to access it at the other end, right now it travels along with the objects and that does not feel right.\r\n\r\n```\r\n  public class DomainObjectType : ObjectGraphType<DomainObject>\r\n    {\r\n        public DomainObjectType(\r\n            IRepositoriesManager repositoriesManager)\r\n        {\r\n            Name = \"DomainObject\";\r\n            Field(x => x.Id);\r\n            Field<FolderType>(\"parrentFolder\", resolve: x => repositoriesManager.Get<Folder>(x.Source.Session, new ValueObjects.SearchArg { Id = x.Source.FolderId }));\r\n        }\r\n    }\r\n```\r\n\r\nI found the following properties on ResolveFieldContext<object> \r\n```\r\n            SubFields;\r\n            Variables;\r\n            UserContext;\r\n```\r\nI wonder if one of those could be used for that. I did not find any documentation so I'd like to make sure :)",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1159/comments",
    "author": "BasHamer",
    "comments": [
      {
        "user": "BasHamer",
        "created_at": "2019-05-25T23:52:54Z",
        "body": "well, userContext did not work out, it got nulled out after setting it;\r\n\r\nThe first idea was to just use the GetArgument again, but that only works at the entry point and not after that.\r\n\r\nVariables kind had the data I needed, so I grabbed it out of there (the format was, a dictionary of dictionaries so that took some tweaks. \r\n\r\nso I ended up with this recursive reflection abomination \r\n\r\n```\r\n  public PossumLab.DomainObjects.Session SessionOf<T>(ResolveFieldContext<T> context) =>\r\n                Rehydrate(context.GetArgument<PossumLab.DomainObjects.Session>(\"session\", defaultValue: null) ??\r\n                    SetProperties<Session>(context.Variables.ValueFor(\"session\")));\r\n\r\n        T SetProperties<T>(object source)\r\n            => (T)SetProperties(source, typeof(T));\r\n\r\n        object SetProperties(object source, Type t)\r\n        {\r\n            if (source == null)\r\n                return null;\r\n\r\n            if (t.IsAssignableFrom(source.GetType()))\r\n                return source;\r\n\r\n            var target = Activator.CreateInstance(t);\r\n            var properties =  t.GetProperties();\r\n\r\n            Func<string, PropertyInfo> findProp = (key) =>\r\n                properties.First(p=>p.Name.Equals(key, StringComparison.InvariantCultureIgnoreCase));\r\n\r\n            if (source is IDictionary)\r\n            {\r\n                var d = source as IDictionary;\r\n                foreach (var k in d.Keys)\r\n                {\r\n                    if (!(k is string))\r\n                        throw new NotImplementedException($\"the key type of {k.GetType()} is not known.\");\r\n\r\n                    var v = d[k];\r\n                    if (v == null)\r\n                        continue;\r\n\r\n                    var p = findProp(k as string);\r\n                    if (p.PropertyType.IsAssignableFrom(v.GetType()))\r\n                    {\r\n                        p.SetMethod.Invoke(target, new[] { v });\r\n                        continue;\r\n                    }\r\n                    p.SetMethod.Invoke(target, new[] { SetProperties(v, p.PropertyType) });\r\n                }\r\n            }\r\n            else\r\n            {\r\n                foreach (var prop in source.GetType().GetProperties())\r\n                {\r\n                    var propGetter = prop.GetGetMethod();\r\n                    var propSetter = findProp(prop.Name).GetSetMethod();\r\n                    var valueToSet = propGetter.Invoke(source, null);\r\n                    propSetter.Invoke(target, new[] { valueToSet });\r\n                }\r\n            }\r\n            return target;\r\n        }\r\n```\r\n\r\nWorks but I'd love to know how to actually do this correctly. "
      },
      {
        "user": "BasHamer",
        "created_at": "2019-05-26T23:00:16Z",
        "body": "<eddited the wrong tiket>"
      },
      {
        "user": "sungam3r",
        "created_at": "2021-02-23T23:01:17Z",
        "body": "> well, userContext did not work out, it got nulled out after setting it;\r\n\r\n😕  `UserContext` is a `IDictionary<string, object>` and now is passed from `ExecutionContext.UserContext`/`ExecutionOptions.UserContext` down the whole execution tree. Since a lot of time has passed since your question, I am sure that you have already solved this problem. I will close this issue. If you still have questions, please reopen it."
      }
    ]
  },
  {
    "number": 1098,
    "title": "Passing complex types in as variables",
    "created_at": "2019-04-04T19:59:11Z",
    "closed_at": "2019-04-05T16:03:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1098",
    "body": "I can't get this working for some reason. I tested it first with a single Int! variable defined and it worked just as expected. But then I tried adding a complex type to the mix so my query looks like:\r\n\r\n```\r\n{\r\n  \"query\": query fooQuery($id:Int!,$foo:FooInput!) {\r\n\tfooQuery (id:$id,foo:$foo){\r\n\t\tfooId\r\n\t\tfooName\r\n   }\r\n},\r\n  \"variables\": {\r\n\t\"id\":\"2\",\r\n\t\"foo\":{\"prop1\":\"val1\",\"prop2\":\"val2\"}\r\n  }              \r\n}\r\n\r\n\r\n```\r\nFooInput is declared simply as:\r\n\r\n\r\n```\r\npublic FooInput() {\r\n    Name = \"FooInput\";\r\n    Field<StringGraphType>(\"Prop1\");\r\n    Field<StringGraphType>(\"Prop2\");\r\n}\r\n```\r\n\r\nAnd the query declared as:\r\n\r\n ```\r\nField<FooType>(\r\n\"fooQuery\",\r\narguments: new QueryArguments(new QueryArgument<IntGraphType> { Name = \"id\" }, \r\nnew QueryArgument<NonNullGraphType<FooInput>> { Name = \"foo\" }),\r\nresolve: context => {\r\n    return repo.Get(context.GetArgument<int>(\"id\"), context.GetArgument<Foo>(\"foo\"));\r\n});\r\n\r\n```\r\n\r\nIt fails with \"Expected non-null value, resolve delegate return null for FooInput\"\r\n\r\nIt looks like the call to ToInputs() call is to blame but I'm not sure why, what am I doing wrong here?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1098/comments",
    "author": "scott-mac",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2019-04-04T22:15:10Z",
        "body": "Yes you will need to use `ToInputs` to pass the variables to the execution engine.  Does `FooInput` inherit from `InputGraphType`?"
      },
      {
        "user": "scott-mac",
        "created_at": "2019-04-05T12:30:31Z",
        "body": "Yes FooInput inherits from InputGraphType so that wasn't it. But your question did lead me to the problem. \r\n\r\nSince all my types are in the same namepace, in my Startup, I register them all in a  loop using reflection on that namespace. But this FooInput class I had added to a different namespace just for quick testing so it was never getting injected properly.\r\n\r\nThanks for the quick reply and helping me get pointed in the correct direction."
      }
    ]
  },
  {
    "number": 1084,
    "title": "How use stored procedure or dataset in graphql",
    "created_at": "2019-03-22T03:27:03Z",
    "closed_at": "2019-09-04T10:37:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1084",
    "body": "Is it possible to use stored procedure which return multiple datatable in single sp and display(resolve) result from them in graphql dotnet.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1084/comments",
    "author": "anomepani",
    "comments": [
      {
        "user": "SimonCropp",
        "created_at": "2019-03-22T06:02:21Z",
        "body": "yes"
      },
      {
        "user": "anomepani",
        "created_at": "2019-03-22T08:28:08Z",
        "body": "Do you have or anyone have demo project how we can do it? It would be great if some demo will be there. \r\nThanks  "
      },
      {
        "user": "denisedelbando",
        "created_at": "2019-04-15T16:00:30Z",
        "body": "hello @anomepani. its the same as any regular table. Your return type should be the model of your stored procedure. This answer is based on if you are using EF.\r\n\r\nWe have been using stored procedures and views with graphql. saves us resolve issues with on demand properties like created by info\r\n\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2019-09-04T10:37:15Z",
        "body": "Graphql does not tied to any data source technology. You can do everything you want in your resolvers to fetch data from. Feel free to post a new issue if you have any questions."
      }
    ]
  },
  {
    "number": 1057,
    "title": "GraphQL as API gateway?",
    "created_at": "2019-03-12T12:55:22Z",
    "closed_at": "2020-08-18T23:35:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1057",
    "body": "Can I use graphql-dotnet to set up a gateway for multiple web services?\r\nIf yes, is there any example available?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1057/comments",
    "author": "ildoc",
    "comments": [
      {
        "user": "SimonCropp",
        "created_at": "2019-03-13T00:23:46Z",
        "body": "> Can I use graphql-dotnet to set up a gateway for multiple web services\r\n\r\ncan u clarify what you mean by that?"
      },
      {
        "user": "A360JMaxxgamer",
        "created_at": "2019-03-17T12:09:41Z",
        "body": "Of course you can do that. Basically it is done by schema stitching or remote schemas. This repo does not support it yet I guess #955. \r\n\r\nAs a temporary solution your api service could use the hotchocolate package. It supports schema stitching. But it it lacks a support for supscriptions on a stitched schema.\r\n\r\nOr you do the stitching by yourself. ;) "
      },
      {
        "user": "michaelstaib",
        "created_at": "2019-10-18T14:06:45Z",
        "body": "@A360JMaxxgamer we will have subscription stitching with the upcoming version of HotChocolate."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-08-18T23:35:25Z",
        "body": "Closed as answered."
      }
    ]
  },
  {
    "number": 1045,
    "title": "Resolving GraphQL Types to Data types for Input Objects",
    "created_at": "2019-03-07T14:32:38Z",
    "closed_at": "2020-03-02T22:39:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1045",
    "body": "Hi,\r\n\r\nFor most operations in GraphQL, we are taking data objects and turning them into object graph types. If any transformation needs to happen on a field, we can use resolve to do that.\r\n\r\nHowever, for Input objects we are receiving object graph types and converting them to data objects. Is there a method similar to resolve that can be used for doing transformations in this direction?\r\n\r\nFor a specific example, I encode int Id's to be opaque global string ids. This is easy via resolve when converting from data type to graph type.\r\n\r\nFor the input object, I would like to decode the id from the InputObjectGraphType into an int id in the underlying data object. I can't work out where to do this.\r\n\r\nCode example:\r\n\r\n```c#\r\npublic class Person\r\n{\r\n  public int Id { get; set; }\r\n  public string Name { get; set; }\r\n  public int PartnerId { get; set; }\r\n}\r\n\r\npublic class PersonType : ObjectGraphType<Person>\r\n{\r\n  public PersonType()\r\n  {\r\n    Field<NonNullGraphType<IdGraphType>>(\"id\", resolve: x => ToGloablID(x.Source.Id));\r\n    Field(x => x.Name);\r\n    Field<NonNullGraphType<IdGraphType>>(\"partnerId\", resolve: x => ToGloablID(x.Source.PartnerId));\r\n  }\r\n}\r\n\r\npublic class PersonInput\r\n{\r\n  public string Name { get; set; }\r\n  public int PartnerId { get; set; }\r\n}\r\n\r\npublic class PersonInputType : InputObjectGraphType<PersonInput>\r\n{\r\n  public PersonInputType()\r\n  {\r\n    Field(x => x.Name);\r\n    // Should be able to use FromGlobalId(string id) somewhere here\r\n    Field<NonNullGraphType<IdGraphType>>(\"partnerId\", ???);\r\n  }\r\n}\r\n```\r\n\r\nJeff",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1045/comments",
    "author": "jeffw-wherethebitsroam",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-03-02T22:39:56Z",
        "body": "Do not use resolver for inputs, this just not work. See linked issues. Call `context.GetArgument<YourDataObject>(\"argname\")` inside field resolver to get argument. If you want custom deserialization for `YourDataObject` you may registed custom converter, for example `ValueConverter.Register<YourDataObject>(values => YourDataObject.Build(values))`"
      }
    ]
  },
  {
    "number": 1027,
    "title": "How to hide fields",
    "created_at": "2019-03-01T08:31:01Z",
    "closed_at": "2020-03-01T23:31:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1027",
    "body": "I have a `field` inside of a `mutation` which should not be used by any customer. Is it possible to hide it? Or must I protect it by authentication?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1027/comments",
    "author": "djonasdev",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2019-03-02T00:59:12Z",
        "body": "There is currently no way to hide fields, so yes it would have to be authentication today."
      },
      {
        "user": "sungam3r",
        "created_at": "2019-04-09T20:30:24Z",
        "body": "If this field should not be used by anyone, then why is it declared? You can also use the deprecated directive."
      },
      {
        "user": "djonasdev",
        "created_at": "2019-04-11T09:02:31Z",
        "body": "> \r\n> \r\n> If this field should not be used by anyone, then why is it declared?\r\n\r\nI have a `field` ... which should not be used by any customer..."
      },
      {
        "user": "sungam3r",
        "created_at": "2019-04-11T09:18:58Z",
        "body": "Ok. How and by whom then should it be used?"
      },
      {
        "user": "djonasdev",
        "created_at": "2019-04-11T09:21:42Z",
        "body": "Software developer and internal process communication between `client` and `server` application."
      },
      {
        "user": "sungam3r",
        "created_at": "2019-04-11T20:46:07Z",
        "body": "That is, you actually have two api - external and internal? Maybe then separate them and provide explicitly relevant api to different types of customers?"
      },
      {
        "user": "sungam3r",
        "created_at": "2019-10-12T10:52:49Z",
        "body": "@dojo90 I think #1179 is what you need. "
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-01T23:31:28Z",
        "body": "Closed as answered. @dojo90 Now you can use schema filter to solve this issue."
      }
    ]
  },
  {
    "number": 1016,
    "title": "Nullable types ObjectGraphType",
    "created_at": "2019-02-18T20:46:17Z",
    "closed_at": "2020-02-09T15:13:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1016",
    "body": "Can I force a field to return null with a model non-null like this?\r\n\r\n```\r\npublic class Model\r\n{\r\n    public int fieldInt{get; set;}\r\n}\r\n\r\nField(a => a.fieldInt, nullable: true)\r\n   .Resolve(context =>\r\n  {\r\n     return null;\r\n  });\r\n```\r\n\r\nThis is throwing to me an error:\r\n`Cannot convert lambda expression to intended delegate type because some of the return types in the block are not implicity convertible to the delegate return type.`\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1016/comments",
    "author": "LuizHenriqueCezar",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2019-02-21T00:10:30Z",
        "body": "This may or may not be a bug, in that I can see that being a bit confusing.  I'm not sure if that would be possible though with the generics in use.  You can define your field like such in the meantime:\r\n\r\nNullable example:\r\n\r\n\r\n```csharp\r\n// these are equivalent\r\n\r\nField<IntGraphType>(\"fieldInt\", context =>\r\n{\r\n  var model = context.Source as MyModel;\r\n  return model?.fieldInt;\r\n});\r\n\r\nField<IntGraphType>(\"fieldInt\");\r\n```\r\n\r\nNon-null example:\r\n\r\n```csharp\r\nField<NonNullGraphType<IntGraphType>>(\"fieldInt\", context => null);\r\n```"
      },
      {
        "user": "SimonCropp",
        "created_at": "2020-01-06T01:16:14Z",
        "body": "@LuizHenriqueCezar is this still an issue for you?"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-01-06T10:40:05Z",
        "body": "@LuizHenriqueCezar Could you change your model like that?\r\n```c#\r\npublic class Model\r\n{\r\n    public int? fieldInt{get; set;}\r\n}\r\n```"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-09T15:13:45Z",
        "body": "Closed due to inactivity."
      }
    ]
  },
  {
    "number": 996,
    "title": "For graph types using Field( c => c.something) always makes string types required. Is that intended?",
    "created_at": "2019-01-24T19:36:39Z",
    "closed_at": "2019-01-26T05:54:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/996",
    "body": "I recently switched our  graph types from a format for fields like\r\n`Field<StringGraphType>().Name(\"name\").Description(\"Description\")`\r\n\r\nto\r\n\r\n`Field(p => p.name).Description(\"Description\");`\r\n\r\nNow all string types are declared as non-null and will return execution errors.  Even though it returns results.  Is this working as intended?  Is there any advantage in using the expression way vs the extension method way?  I know with the extension method it starts everything off as an object.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/996/comments",
    "author": "nportelli",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2019-01-26T05:52:27Z",
        "body": "The expression helps when you have that data model and you rename fields.  There is a parameter to the expression method to make it nullable (`nullable = true`).  Behind the scenes they both do the exact same thing."
      }
    ]
  },
  {
    "number": 988,
    "title": "Can I add a QueryArgument than can accept either string or List<string> for incoming values?",
    "created_at": "2019-01-23T01:52:44Z",
    "closed_at": "2019-01-23T05:11:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/988",
    "body": "Can I add a QueryArgument than can accept either string or List<string> for incoming values?\r\n\r\nnew QueryArgument< StringGraphType   > { Name = \"fType\"},\r\nnew QueryArgument<  ListGraphType  <  StringGraphType  >> { Name = \"fType\"},\r\n\r\nAn input data type which is more as IEnumerable\r\n\r\nUse case: To make something backward compatible during data type change for an incoming QueryArgument\r\nquery UseCaseExample {\r\n QueryField(fType:\"ValueA\" fType__AsList:[\"Value1\" \"Value2\"] ) {\r\n\r\ncan be handled as either\r\nquery UseCaseExample {\r\n QueryField(fType:\"ValueA\") {\r\n\r\nOR\r\nquery UseCaseExample {\r\n QueryField(fType:[\"Value1\" \"Value2\"] ) {\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/988/comments",
    "author": "pravinhabbu4u",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2019-01-23T05:11:36Z",
        "body": "No, that is not possible due to the strong type safety that is defined in the GraphQL specification.  You will need to deprecate the old argument and provide a new one."
      },
      {
        "user": "pravinhabbu4u",
        "created_at": "2019-01-23T05:32:39Z",
        "body": "Thanks for the clarification. I have instead provided 2 separate arguments (with a pre-defined naming standards to handle this scenario)\r\n\r\nnew QueryArgument< StringGraphType > { Name = \"fType\"},\r\nnew QueryArgument< ListGraphType < StringGraphType >> { Name = \"fType__AsList\"},"
      }
    ]
  },
  {
    "number": 986,
    "title": "Is it possible to change graphql schema once it is initialized",
    "created_at": "2019-01-22T13:17:50Z",
    "closed_at": "2019-01-23T05:16:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/986",
    "body": "I am using graphql-dotnet with asp.net core and populated schema based on different assembly types. Now I would like to add new types to an existing schema without restarting the application server. Is that possible? \r\n\r\nExpecting your help.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/986/comments",
    "author": "hasibul2363",
    "comments": [
      {
        "user": "Tarig0",
        "created_at": "2019-01-22T18:34:04Z",
        "body": "All you need to do is instead of creating a singleton service for your scheme use the addscoped function"
      },
      {
        "user": "joemcbride",
        "created_at": "2019-01-23T05:16:38Z",
        "body": "As @Tarig0 mentioned, you can dynamically build the schema on request instead of making it a singleton.  However, once it has been initialized adding types can be dangerous.  It is technically possible to do so by getting the specific GraphType and adding a field, though you would need to ensure all of the models of the GraphType you are adding are properly populated.  That is not a typical scenario that I would suggest someone to do as there are a ton of issues you could run into.\r\n\r\nSummary:  its technically possible, though not supported."
      }
    ]
  },
  {
    "number": 958,
    "title": "Deserialize arguments to a type with private constructor",
    "created_at": "2018-12-30T19:34:08Z",
    "closed_at": "2019-01-01T04:08:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/958",
    "body": "In the following example, my `Test` model has a parameterless private constructor. That's why it throws an exception saying, `System.MissingMethodException: 'No parameterless constructor defined for this object.'` while deserializing the arguments to the specified type.\r\n\r\n```\r\nField<TestType>(\"test\", \"create test\",\r\n                arguments: new QueryArguments(\r\n                    new QueryArgument<NonNullGraphType<TestInputType>> {Name = \"test\", Description = \"test input\"}\r\n                ),\r\n                resolve: context =>\r\n                {\r\n                    var test = context.GetArgument<Test>(\"test\");\r\n                    return repository.AddAsync(test);\r\n                });\r\n```\r\n\r\nQuestion: Is there any way to make it work while keeping the parameterless constructor private?\r\n\r\nN.B: Json.Net can handle non public default constructor for deserialization i.e.  \r\n```\r\nJsonSerializerSettings settings = new JsonSerializerSettings \r\n{ \r\n    ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor \r\n};\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/958/comments",
    "author": "fiyazhasan",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-12-31T00:41:04Z",
        "body": "Not at this time, no.  You can use JSON.NET yourself to accomplish that today, something like this:\r\n\r\n```csharp\r\nresolve: context =>\r\n{\r\n    var jObject = JObject.FromObject(context.Arguments[\"test\"]);\r\n    var serializer = new JsonSerializer\r\n    {\r\n      ConstructorHandling =  ConstructorHandling.AllowNonPublicDefaultConstructor\r\n    };\r\n    var test = jObject.ToObject<Test>(serializer);\r\n    return repository.AddAsync(test);\r\n}\r\n```"
      },
      {
        "user": "fiyazbinhasan",
        "created_at": "2018-12-31T17:40:31Z",
        "body": "got it. thanks 👍 "
      }
    ]
  },
  {
    "number": 943,
    "title": "Option to be less strict with NonNullGraphType returning null?",
    "created_at": "2018-12-05T09:38:49Z",
    "closed_at": "2018-12-05T19:10:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/943",
    "body": "In our case, a property is set as a NonNullGraphType because it should be filled, and that's what we want to communicate to the consumers of our API.\r\n\r\nSometimes there is a problem in the source data and the data is missing. This causes `new ExecutionError($\"Cannot return null for non-null type. Field: {node.Name}, Type: {type.Name}!.\");` to be thrown and it is included in the list of errors.\r\n\r\nIn our API controller, we set status 500 if any errors exist. This serves us well mostly, but in this case it is far too strict. I suppose we can check for this specific text and ignore it, which is probably what I'll do.\r\n\r\nAm I thinking about this the right way, and/or do you think it'd be better to have the option to be less strict with NonNullGraphType returning null?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/943/comments",
    "author": "steviemcg",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-12-05T18:37:17Z",
        "body": "Unfortunately no - that is part of the GraphQL spec so I don't see that being budged on.  If that is an actual problem with your data I would suggest to instead do that check yourself and throw your own custom error vs. letting that bubble up to the null check."
      },
      {
        "user": "steviemcg",
        "created_at": "2018-12-05T19:10:25Z",
        "body": "OK, thanks. It's a gigantic number of properties so I'm not sure how to do that in a workable way. I'll stick with my hack of ignoring this text when choosing the status code. 😄 As the error text is definitely useful, but it's not necessarily big enough of a problem for the entire request to fail. Feel free to close and thanks for your time."
      }
    ]
  },
  {
    "number": 906,
    "title": "Cannot see which field in GraphiQL that is failing (Introspection)",
    "created_at": "2018-11-13T07:32:55Z",
    "closed_at": "2020-02-25T07:52:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/906",
    "body": "Hey!\r\nIs it possible to find out which field is failing?\r\nIn Graphiql it says \"Error: Introspection must provide input type for arguments\". But I wonder which one?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/906/comments",
    "author": "joelmandell",
    "comments": [
      {
        "user": "joelmandell",
        "created_at": "2018-11-14T08:54:38Z",
        "body": "I found out which field that was failing by inspecting the network tab in Graphiql and the types object on recieved data from introspection query. \r\n\r\nSo I did som dirty stuff with the mutation resolver... I had it to expect a `List<ObjectGraphType>` as InputType\r\n🤦‍♂️ \r\n\r\nBut I wonder, is it some API that can make it possible to errormessage this?"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-25T07:52:09Z",
        "body": "Fixed. Now all input and output types are checked when the schema is built."
      }
    ]
  },
  {
    "number": 904,
    "title": "Only one argument is available in ResolveFieldContext when doing multiple mutations.",
    "created_at": "2018-11-12T13:46:47Z",
    "closed_at": "2020-03-01T23:15:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/904",
    "body": "## Description\r\nI have mutations from apollo-client like this:\r\n```json\r\n{\r\n   \"operationName\":null,\r\n   \"variables\":{\r\n      \"smk\":{\r\n         \"id\":1,\r\n         \"ar\":2017,\r\n         \"period\":1,\r\n         \"mdelt\":3,\r\n         \"hdelt\":30,\r\n         \"arregel\":0,\r\n         \"frarman\":7,\r\n         \"tiarman\":25,\r\n         \"frarkvin\":7,\r\n         \"tiarkvin\":25\r\n      },\r\n      \"reg\":{\r\n         \"id\":1,\r\n         \"ar\":2017,\r\n         \"period\":1,\r\n         \"mlen\":60,\r\n         \"ledmial\":13,\r\n         \"lednaral\":0,\r\n         \"ledbid\":0\r\n      },\r\n      \"smkh\":{\r\n         \"id\":1,\r\n         \"ar\":2017,\r\n         \"period\":1,\r\n         \"mdelt\":3,\r\n         \"hdelt\":30,\r\n         \"arregel\":0,\r\n         \"frarman\":7,\r\n         \"tiarman\":25,\r\n         \"frarkvin\":7,\r\n         \"tiarkvin\":25\r\n      }\r\n   },\r\n   \"query\":\"mutation ($reg: kfgenreginputtype, $smk: kfsmkinputtype, $smkh: kfsmkinputtype) {\r\n a: updateKommunfilGenerellaRegler(kfgenreg: $reg) {\\n    year\\n    __typename\\n  }\\n  \r\nb: updateKommunfilSammankomstStandardRegler(kfsmk: $smk) {\\n    year\\n    __typename\\n  }\\n  \r\nc: updateKommunfilSammankomstHandikappRegler(kfsmk: $smkh) {\\n    year\\n    __typename\\n  }\\n}\\n\"\r\n}\r\n```\r\n\r\nThe problem is that in the ResolveFieldContext there is only one of the arguments available in the Arguments-dictionary (always the first one). The other variables that is specified as kfsmk in the aliased mutations \"b\" and \"c\" is not available.\r\n\r\n### Steps to reproduce\r\nMake a mutation with aliased mutations, and with multiple variables for each of them. Only one argument is available in ResolveFieldContext.Arguments\r\n\r\n### Expected result\r\n\r\nExpect to see arguments to the mutations \"updateKommunfilSammankomstStandardRegler\" and \"updateKommunfilSammankomstHandikappRegler\" in the ResolveFieldContext.\r\n\r\n### Actual result\r\nThere is only one of the arguments available in the Arguments-dictionary (always the first one).\r\n\r\n### Environment\r\n\r\nGraphql-dotnet v2.3.0, .NET 4.5.2 Windows 10.\r\nI am using latest of apollo-stack with the vue-apollo plugin.\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/904/comments",
    "author": "joelmandell",
    "comments": [
      {
        "user": "joelmandell",
        "created_at": "2018-11-12T14:13:45Z",
        "body": "I am not sure if I describe it well... But I can see 3 variables in ResolveFieldContext.Variables, but not in ResolveFieldContext.Arguments."
      },
      {
        "user": "joemcbride",
        "created_at": "2018-11-12T15:25:55Z",
        "body": "This is working as intended.  You will only get the arguments that are defined in the field.  If that is only one, you will only get one.  The variable that is defined should get passed in as the argument."
      },
      {
        "user": "joelmandell",
        "created_at": "2018-11-12T15:27:19Z",
        "body": "Oh. I see. Well I imagine I can iterate trough FieldAst to find out the variable name from the argument and the match that name to the name in Variables."
      },
      {
        "user": "joemcbride",
        "created_at": "2018-11-12T15:39:39Z",
        "body": "If you need both, why not pass both to the field?"
      },
      {
        "user": "joelmandell",
        "created_at": "2018-11-12T15:40:57Z",
        "body": "Excuse me but I don't follow "
      },
      {
        "user": "joemcbride",
        "created_at": "2018-11-12T15:44:54Z",
        "body": "Create two arguments in the field so you can pass in two variables as inputs."
      },
      {
        "user": "joelmandell",
        "created_at": "2018-11-12T16:36:25Z",
        "body": "Okay. I don't know if I ever will have the possibility to explain why I am hitting this problem. But I solved it by grabbing the Variable name from FieldAst. And then do an LINQ on the Variables object for the variable with that name. That gives me everything I need :)"
      }
    ]
  },
  {
    "number": 876,
    "title": "Schema first mutation",
    "created_at": "2018-10-24T12:51:09Z",
    "closed_at": "2018-12-13T15:03:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/876",
    "body": "Hi,\r\nCan you please tell me how to implement schema-first mutation? I have the schema as follows:\r\n\r\n```\r\n              type Mutation {\r\n                sendInvite(campaignId: ID! propertyId: ID! email: String!): Boolean!\r\n              }\r\n\r\n              schema {\r\n                query: Query\r\n                mutation: Mutation\r\n              }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/876/comments",
    "author": "baig316-adfenix",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-11-08T18:48:52Z",
        "body": "Syntax for a mutation is the exact same syntax for a query.  The only difference is having the `Mutation` name vs. `Query`."
      },
      {
        "user": "baig316-adfenix",
        "created_at": "2018-12-13T09:06:47Z",
        "body": "And how would we cater for custom input types as arguments to the mutation when those custom input types also include nested custom types."
      },
      {
        "user": "baig316-adfenix",
        "created_at": "2018-12-13T15:03:05Z",
        "body": "Got it working."
      },
      {
        "user": "bgoerdt",
        "created_at": "2020-02-19T20:30:23Z",
        "body": "@baig316-adfenix can you post an example of how to do custom input types with schema-first?"
      }
    ]
  },
  {
    "number": 864,
    "title": "How to map input object to complex object",
    "created_at": "2018-10-16T19:29:24Z",
    "closed_at": "2020-03-01T22:21:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/864",
    "body": "## Summary\r\nI would like to know how to map the following mutation (PersonInput) to the models Person having an Account, using GraphQL.NET 2.0\r\n\r\n```\r\nmutation createPerson ($person: PersonInput!){\r\n  createPerson(person: $person)\r\n  {\r\n\tid\r\n  }\r\n}\r\n```\r\n\r\n```\r\n{\r\n \"person\": {\r\n\t\"firstName\": \"Sjaak\",\r\n\t\"lastName\": \"Trekhaak\",\r\n\t\"email\": \"jan@test.com\",\r\n\t\"password\": \"sjanie\"\r\n  }\r\n}\r\n```\r\n\r\n```\r\npublic class PersonInputObject : InputObjectGraphType\r\n{\r\n\tpublic RentePersonInputObject InputObject()\r\n\t{\r\n\t\tthis.Name = \"PersonInput\";\r\n\t\t\r\n\t\tthis.Field(typeof(StringGraphType), \"firstName\");\r\n\t\t\r\n\t\tthis.Field(typeof(StringGraphType), \"lastName\");\r\n\t\t\r\n\t\tthis.Field(typeof(StringGraphType), \"password\");\r\n\t\t\r\n\t\tthis.Field(typeof(StringGraphType), \"email\");\r\n\t}\r\n}\r\n\r\npublic class Person\r\n{\r\n\tpublic int Id { get; set; }\r\n\tpublic string FirstName { get; set; }\r\n\tpublic string LastName { get; set; }\r\n\r\n\tpublic Account Account { get; set; }\r\n}\r\n\r\npublic class Account\r\n{\r\n\tpublic string Email { get; set; }\r\n\tpublic string Password { get; set; }\r\n}\r\n```\r\n\r\nThis is my mutation object.\r\n\r\n```\r\npublic MutationObject()\r\n{\r\n\tthis.Name = \"Mutation\";\r\n\tthis.Description = \"The mutation type, represents all updates we can make to our data.\";\r\n\r\n        \r\n\r\n\tthis.FieldAsync<PersonObject, Person>(\r\n\t\t\"createPerson\",\r\n\t\t\"Create a person.\",\r\n\t\targuments: new QueryArguments(\r\n\t\t\tnew QueryArgument<NonNullGraphType<PersonInputObject>>()\r\n\t\t\t{\r\n\t\t\t\tName = \"person\",\r\n\t\t\t\tDescription = \"The person you want to create.\",\r\n\t\t\t}),\r\n\t\tresolve: context =>\r\n\t\t{\r\n\t\t\tvar person= context.GetArgument<Person>(\"person\");\r\n// dostuff\r\n\t\t\t\r\n\t\t\treturn person;\r\n\t\t}\r\n\t);\r\n}\r\n```\r\n\r\nOr should I resolve everything by hand in the mutation's resolver?\r\n\r\nAny examples available?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/864/comments",
    "author": "zjean",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-10-17T08:16:33Z",
        "body": "There is currently nothing built-in to transform the input in this way.  This would need to be a manual transform that you do yourself from the `Arguments` dictionary."
      },
      {
        "user": "rose-a",
        "created_at": "2018-10-24T13:45:55Z",
        "body": "You can let `Newtonsoft.Json` do the conversion like so:\r\n\r\n```c#\r\nvar personArg = ctx.GetArgument<object>(\"person\");\r\nvar person = personArg != null\r\n    ? JToken.FromObject(personArg).ToObject<Person>()\r\n    : null;\r\n```\r\n\r\nWorks pretty well by default in most situations, you can even leverage a potentially already written custom JsonConverter for complexer objects."
      },
      {
        "user": "joemcbride",
        "created_at": "2018-10-25T16:28:46Z",
        "body": "Perhaps a slightly better version (with a little less processing):\r\n\r\n```csharp\r\nvar personArg = ctx.Arguments[\"person\"];\r\nvar person = personArg != null\r\n    ? JToken.FromObject(personArg).ToObject<Person>()\r\n    : null;\r\n```"
      },
      {
        "user": "zjean",
        "created_at": "2018-10-25T19:55:05Z",
        "body": "Thanks for your suggestions!"
      },
      {
        "user": "rose-a",
        "created_at": "2018-10-26T10:55:42Z",
        "body": "Just to be thorough, here are some ready to use extension methods:\r\n\r\n```c#\r\npublic static class ResolveFieldContextExtensions\r\n{\r\n    public static TObject ConvertArgumentToObject<TObject>(this ResolveFieldContext ctx, string argumentName)\r\n        => _convertArgument<TObject>(ctx.Arguments, argumentName);\r\n\r\n    public static TObject ConvertArgumentToObject<TObject>(this ResolveFieldContext<object> ctx, string argumentName)\r\n        => _convertArgument<TObject>(ctx.Arguments, argumentName);\r\n\r\n    public static TObject ConvertArgumentToObject<TObject, TSource>(this ResolveFieldContext<TSource> ctx, string argumentName)\r\n        => _convertArgument<TObject>(ctx.Arguments, argumentName);\r\n\r\n    private static TObject _convertArgument<TObject>(IReadOnlyDictionary<string, object> arguments, string argumentName)\r\n    {\r\n        return arguments[argumentName] != null\r\n            ? JToken.FromObject(arguments[argumentName]).ToObject<TObject>()\r\n            : default;\r\n    }\r\n}\r\n```\r\n\r\nto be used like this:\r\n\r\n```c#\r\nvar person = ctx.ConvertArgumentToObject<Person>(\"person\");\r\n```\r\n\r\n@joemcbride \r\nMaybe this could be delivered with the library? \r\n\r\nIs there a reason the generic `ResolveFieldContext<TSource>` does not inherit from `ResolveFieldContext`? This would eliminate the need of creating separate extension methods for them (not just in this case)..."
      },
      {
        "user": "joemcbride",
        "created_at": "2018-11-13T23:19:12Z",
        "body": "@rose-a I don't want to have multiple ways to transform the data.  This is an often requested feature though so I think we should provide some way to do it.  I'm not sure what that looks like yet, but I'm stewing on it."
      },
      {
        "user": "BenjaBobs",
        "created_at": "2018-11-14T07:41:45Z",
        "body": "I second @rose-a question about the inheritance chain.\r\n\r\n```c#\r\npublic class ResolveFieldContext\r\n{\r\n\t//...\r\n\tpublic object Source { get; set; }\r\n}\r\n\r\npublic class ResolveFieldContext<TSource> : ResolveFieldContext\r\n{\r\n\tpublic new TSource Source \r\n\t{ \r\n\t\tget => (TSource)base.Source; \r\n\t\tset => base.Source = value;\r\n\t}\r\n}\r\n```\r\n\r\nIf we design it like this, we can make generic (in the Source-type agnostic sense) solutions by creating solutions for the `ResolveFieldContext`.\r\nI think it would simplify the code."
      },
      {
        "user": "benmccallum",
        "created_at": "2019-08-12T06:10:21Z",
        "body": "Hey @SimonCropp, I've got a situation like above where I wanna use an input type with an inner complex input type. Solution above seems nice enough for me utilising `Newtonsoft.Json` to deserialize input into an object. I was thinking of extending @rose-a's example by adding a line to fire the fluent validation like so:\r\n`ArgumentValidation.Validate(context.GetCache(), typeof(TArgument), argument, context.UserContext);`, but `ArgumentValidation` is private. Can you make it public? "
      },
      {
        "user": "SimonCropp",
        "created_at": "2019-08-12T10:47:57Z",
        "body": "@benmccallum is that question meant to be in a diff repo?"
      },
      {
        "user": "benmccallum",
        "created_at": "2019-08-13T01:37:10Z",
        "body": "@SimonCropp Thought I'd tag on here, but will create an issue in your repo where the change is required."
      },
      {
        "user": "indeavr",
        "created_at": "2019-09-10T05:00:02Z",
        "body": "And what about using AutoMapper for this purpose ?\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2019-09-10T06:32:31Z",
        "body": "I would not want to drag it into the project. This is an extra dependency, dragging along a bunch of unnecessary functionality. I have been working with the AutoMapper for a long time and cannot say that I am delighted with it."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-27T22:34:04Z",
        "body": "Relates to #684 "
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-27T22:35:22Z",
        "body": "> Is there a reason the generic ResolveFieldContext<TSource> does not inherit from ResolveFieldContext? This would eliminate the need of creating separate extension methods for them (not just in this case)...\r\n\r\nDone in other PRs."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-29T17:44:05Z",
        "body": ">  I don't want to have multiple ways to transform the data. This is an often requested feature though so I think we should provide some way to do it. I'm not sure what that looks like yet, but I'm stewing on it.\r\n\r\n@joemcbride it's done in #1582 \r\n\r\n> This would eliminate the need of creating separate extension methods for them \r\n\r\n@rose-a you're right, with changes from #1582 you can continue to use `GetArgument` API through your codebase.\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-01T22:25:02Z",
        "body": "@zjean Done in #1582 . You can try the latest preview."
      }
    ]
  },
  {
    "number": 862,
    "title": "Distributed request resolve",
    "created_at": "2018-10-16T09:38:47Z",
    "closed_at": "2020-08-18T23:32:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/862",
    "body": "Hi!\r\n\r\nI've plugin like distributed system. Every plugin holds some data.\r\nI want to make API that will allow me to work with all system like a solid.\r\nCan you show checkpoints to make that scenario:\r\n\r\n2 Backend services:\r\n- <Service A> holds \"Humans\" dataset.\r\n- <Service B> holds \"Orks\" dataset.\r\n\r\nAll services use GQL. \r\nAny service **after autoupdate can starts use different scheme**.\r\n\r\nWant to create single <Facade> service which provide merged API.\r\n\r\nDataflow Sample 1:\r\n`{humans {id name} }` -> **Facade** service -> **Service A**\r\n\r\nDataflow Sample 2:\r\n`{orks {id name} }` -> **Facade** service -> **Service B**\r\n\r\nDataflow Sample 3:\r\n`{humans {id name} orks {id name} }` -> **Facade** service -> **Service A**,**Service B**\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/862/comments",
    "author": "mcdis",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-08-18T23:32:22Z",
        "body": "@mcdis I hope you found a solution. Feel free to reopen with additional details. Closed."
      }
    ]
  },
  {
    "number": 847,
    "title": "Generic Creation of ObjectGraphType",
    "created_at": "2018-10-07T17:59:20Z",
    "closed_at": "2018-10-11T02:13:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/847",
    "body": "Hi,\r\n\r\nI'm trying to use a generic response using ObjectGraphType like this:\r\n\r\npublic class ResponseRegister<TEntityType,TEntity> : ObjectGraphType<ResponseMutationModel<TEntity>>\r\n    {\r\n        public ResponseRegister(){\r\n             Field(x => x.Error, nullable:true).Description(\"Hay error\");\r\n             Field<ListGraphType<ValidationErrorType>,IEnumerable <ValidationErrorModel>>()\r\n                .Description(\"Lista de errores\")\r\n                .Name(\"ErrorList\");\r\n             Field<TEntityType,TEntity>()\r\n                .Name(\"Entity\")\r\n                .Description(\"Entity\");\r\n        }\r\n    }\r\n\r\nWhen I register each mutations like this:\r\n\r\nField<ResponseRegister<SchoolSiteType,SchoolSites>>\r\n            (\r\n                \"CreateSchoolSite\",\r\n                arguments:new QueryArguments(new QueryArgument<NonNullGraphType<InputSchoolSiteType>>{Name = \"schoolSite\"}),\r\n                resolve: context => \r\n                {\r\n                    var entity = context.GetArgument<SchoolSites>(\"schoolSite\");\r\n                    return _repository.AddSchoolSiteAsync(entity);\r\n                }\r\n            );\r\n\r\nField<ResponseRegister<TeacherType,Teachers>>\r\n            (\r\n                \"CreateTeacher\",\r\n                arguments:new QueryArguments(new QueryArgument<NonNullGraphType<InputStudentType>>{Name = \"teacher\"}),\r\n                resolve: context => \r\n                {\r\n                    var entity = context.GetArgument<Teachers>(\"teacher\");\r\n                    return _repository.AddTeacherAsync(entity);\r\n                }\r\n            );\r\n\r\n\r\nIt alwasy takes the last field register to autocomplete on graphiQL, I'd like to know if that's a problem with something that I'm doing, with the component or maybe with GraphiQL. For example in this case, if I try to call the mutation CreateSchoolSite, it takes the values of CreateTeacher to autocomplete the response.\r\n\r\nThanks for your help\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/847/comments",
    "author": "dimortizp",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-10-08T03:55:58Z",
        "body": "Are you providing a unique type name on your ResponseRegister types?"
      },
      {
        "user": "dimortizp",
        "created_at": "2018-10-09T01:14:01Z",
        "body": "Hi @joemcbride \r\n\r\nWhat do you mean on \"unique type name\"?\r\n\r\nMy ResponseRegister is like this: \r\n\r\npublic class ResponseRegister<TEntityType,TEntity> : ObjectGraphType<ResponseMutationModel<TEntity>>\r\n    {\r\n        public ResponseRegister(){\r\n             Field(x => x.Error, nullable:true).Description(\"Hay error\");\r\n             Field<ListGraphType<ValidationErrorType>,IEnumerable <ValidationErrorModel>>()\r\n                .Description(\"Lista de errores\")\r\n                .Name(\"ErrorList\");\r\n             Field<TEntityType,TEntity>()\r\n                .Name(\"Entity\")\r\n                .Description(\"Entity\");\r\n        }\r\n    }\r\n\r\nAnd in the implementations, I'm trying to do it in this way\r\n\r\nField<ResponseRegister<StudentType,Students>> with the name CreateStudent\r\nField<ResponseRegister<TeacherType,Teachers>> with the name CreateTeacher\r\n\r\nIf I try to call the mutation the autocomplete always shows me \r\nthe option of the TeacherType for the response of the migration, in this way\r\n\r\nmutation{\r\n  createSchool\r\n  (\r\n    school:\r\n    {\r\n      name:\"test school same ID\"\r\n      internalIdentification:\"800236529\"\r\n    }\r\n  ) {\r\n    entity{\r\n      **userId**\r\n    }\r\n  }\r\n}\r\n\r\nBut the parameter **userId** doesn't belongs to StudentType, it belongs to TeacherType."
      },
      {
        "user": "dimortizp",
        "created_at": "2018-10-11T02:13:29Z",
        "body": "Hi @joemcbride \r\n\r\nNow I got what you meant. The issue was caused because I didn't add a unique name for the generic ObjectGraphType. It was solved just by doing this:\r\n\r\npublic class ResponseRegister<TEntityType,TEntity> : ObjectGraphType<ResponseMutationModel<TEntity>>\r\n    {\r\n        public ResponseRegister(){\r\n            Name=typeof(TEntity).Name;\r\n            Field(x => x.Error, nullable:true).Description(\"Hay error\");\r\n            Field<ListGraphType<ValidationErrorType>,IEnumerable <ValidationErrorModel>>()\r\n            .Description(\"Lista de errores\")\r\n            .Name(\"ErrorList\");\r\n            Field<TEntityType,TEntity>()\r\n            .Name(\"Entity\")\r\n            .Description(\"Entity\");\r\n        }\r\n    }\r\n\r\nThanks"
      }
    ]
  },
  {
    "number": 826,
    "title": "Custom `GraphType` for dictionary",
    "created_at": "2018-09-18T16:34:20Z",
    "closed_at": "2018-09-18T20:14:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/826",
    "body": "Our project is trying to migrate to GraphQL from regular REST approach and currently we faced a problem with serialization of `Dictionary<string, T>`-like properties.\r\n\r\nBy default JSON.NET serializes them as regular JSON objects and that's what UI is expecting. So the idea is to use GraphQL query language to filter fields of `T` generic parameter (same as for `ListGraphType`) while providing JSON objects in response.\r\n\r\n## Example:\r\n__Classes:__\r\n```csharp\r\npublic class Employee\r\n{\r\n  public string Name { get; set; }\r\n  // ...\r\n}\r\n\r\npublic class Job\r\n{\r\n  public string Id { get; set; }\r\n  public Dictionary<string, Employee> Employees { get; set; }\r\n  // ...\r\n}\r\n```\r\n\r\n__Query:__\r\n```\r\n{\r\n  job(id: \"...\"){\r\n    employees{\r\n      name\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n__Response:__\r\n```\r\n{\r\n  employees: {\r\n    \"John\": {\r\n      name: \"John\"\r\n    },\r\n    \"Bob\": {\r\n      name: \"Bob\"\r\n    }\r\n  }\r\n}\r\n```\r\n_Employees_ property here has dynamic set of fields (schema), determined by the data.\r\n\r\nAs such I'm trying to define shema or custom `GraphType` to describe such properties but can't find anything similar in examples or documentation.  \r\nIs it possible with GraphQL.NET?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/826/comments",
    "author": "alexb5dh",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-09-18T17:49:46Z",
        "body": "That unfortunately does not follow the GraphQL Spec so it would not be supported.  You could create a Dictionary GraphQL scalar type, though since it is a scalar the engine would not be able to support querying sub fields."
      },
      {
        "user": "alexb5dh",
        "created_at": "2018-09-18T18:25:09Z",
        "body": "Can it be created in similar fashion to `ListGraphType`?  It does support subfields queries. "
      },
      {
        "user": "joemcbride",
        "created_at": "2018-09-18T19:05:58Z",
        "body": "That _could_ be done, though that would not conform to the GraphQL spec and it would need special handling in the engine.  Since that is far outside of the spec, unfortunately that is not a feature that I would want to add."
      }
    ]
  },
  {
    "number": 766,
    "title": "Disable Introspection Query",
    "created_at": "2018-08-02T21:24:04Z",
    "closed_at": "2018-08-03T19:00:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/766",
    "body": "Is there any way to disable the introspection query in an specific environment (production, in my case)?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/766/comments",
    "author": "wendelnascimento",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-08-02T21:49:32Z",
        "body": "There is nothing build-in, but you could inspect the request to determine it is introspection and not allow it.  Either by using a validation rule (probably the easiest) or you can build the `Document` yourself and inspect it.\r\n\r\n```csharp\r\nvar documentBuilder = new GraphQLDocumentBuilder();\r\nvar document = documentBuilder.Build(options.Query);\r\n\r\n// loop through operations + fields and see if it is introspection\r\n\r\n// pass Document to executor so it doesn't have to build it again\r\nschema.Execute(_ =>\r\n{\r\n    _.Query = options.Query;\r\n    _.Document = document;\r\n});\r\n```\r\n\r\nValidation rules already loop through operations + fields for you.\r\n\r\n```csharp\r\npublic class IntrospectionNotAllowed : IValidationRule\r\n{\r\n    public INodeVisitor Validate(ValidationContext context)\r\n    {\r\n        return new EnterLeaveListener(_ =>\r\n        {\r\n            var myContext = context.UserContext as MyGraphQLContext;\r\n\r\n            if(!myContext.IsProduction()) return;\r\n\r\n            _.Match<Field>(\r\n                enter: field =>\r\n                {\r\n                    // don't recall the exact properties off-hand\r\n                    if (field...)\r\n                    {\r\n                        var error = new ValidationError(\r\n                            context.OriginalQuery,\r\n                            \"code1\",\r\n                            \"Not allowed\",\r\n                            field);\r\n                        context.ReportError(error);\r\n                    }\r\n                });\r\n        });\r\n    }\r\n}\r\n```"
      },
      {
        "user": "wendelnascimento",
        "created_at": "2018-08-03T19:00:14Z",
        "body": "Great! We've implemented the validation rule and it worked!"
      },
      {
        "user": "rasmusskovdk",
        "created_at": "2019-08-12T11:46:14Z",
        "body": "@wendelnascimento: care to disclose how you tested for introspection?"
      },
      {
        "user": "joemcbride",
        "created_at": "2021-07-28T20:22:41Z",
        "body": "Code updated for latest validation rules structure.\r\n\r\nThis fails on any query that uses GraphQL types that starts with `__`. If you want to allow some introspection queries, such as `__type` but disallow others, such as `__schema`, update the `IsIntrospectionType` function in this example.\r\n\r\n```csharp\r\n    /// <summary>\r\n    /// Introspection is not allowed in production.\r\n    /// </summary>\r\n    public class IntrospectionNotAllowed : IValidationRule\r\n    {\r\n        /// <summary>\r\n        /// Returns a static instance of this validation rule.\r\n        /// </summary>\r\n        public static readonly IntrospectionNotAllowed Instance = new IntrospectionNotAllowed();\r\n\r\n        /// <inheritdoc/>\r\n        /// <exception cref=\"ScalarLeafsError\"/>\r\n        public Task<INodeVisitor> ValidateAsync(ValidationContext context) => _nodeVisitor;\r\n\r\n        private static readonly Task<INodeVisitor> _nodeVisitor =\r\n            new MatchingNodeVisitor<Field>((f, context) => Field(context.TypeInfo.GetLastType(), f, context))\r\n                .ToTask();\r\n\r\n        private static void Field(IGraphType? type, Field field, ValidationContext context)\r\n        {\r\n            if (type == null)\r\n            {\r\n                return;\r\n            }\r\n\r\n            var myContext = context.UserContext as MyGraphQLContext;\r\n            if(!myContext.IsProduction()) return;\r\n\r\n            if (type?.IsIntrospectionType())\r\n                context.ReportError(new IntrospectionNotAllowedError(context, field, type));\r\n        }\r\n    }\r\n\r\n    [Serializable]\r\n    public class IntrospectionNotAllowedError : ValidationError\r\n    {\r\n        internal const string NUMBER = \"0\";\r\n\r\n        /// <summary>\r\n        /// Initializes a new instance with the specified properties.\r\n        /// </summary>\r\n        public IntrospectionNotAllowedError(ValidationContext context, Field node, IGraphType type)\r\n            : base(context.Document.OriginalQuery!, NUMBER, \"Introspection is not allowed.\", node)\r\n        {\r\n        }\r\n    }\r\n\r\n    // <summary>\r\n    /// Provides extension methods for working with graph types.\r\n    /// </summary>\r\n    public static class Extensions\r\n    {\r\n        /// <summary>\r\n        /// Determines if this graph type is an introspection type.\r\n        /// </summary>\r\n        public static bool IsIntrospectionType(this IGraphType type) => type?.Name?.StartsWith(\"__\", StringComparison.InvariantCulture) ?? false;\r\n    }\r\n```"
      }
    ]
  },
  {
    "number": 759,
    "title": "Why does the generic EnumerationGraphType<TEnum> use the name of TEnum as the graphql type name? - inconsistent with ObjectGraphType",
    "created_at": "2018-08-01T16:45:34Z",
    "closed_at": "2018-08-11T18:12:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/759",
    "body": "This is regarding a line in `graphql-dotnet/src/GraphQL/Types/EnumerationGraphType.cs`  that sets the name to the name of the underlying TEnum\r\n```\r\npublic EnumerationGraphType()\r\n{\r\n    var type = typeof(TEnum);\r\n\r\n    Name = Name ?? StringUtils.ToPascalCase(type.Name);\r\n...\r\n```\r\n\r\nI'm not sure why that name is being set there. Here is an example of it causing a problem:\r\n```\r\npublic class Organisation\r\n{\r\n    public enum AccessLevel { Admin, Member }\r\n}\r\n\r\npublic class Project\r\n{\r\n    public enum AccessLevel { Admin, Member, ReadOnly }\r\n}\r\n\r\npublic class OrganisationAccessLevelEnum : EnumerationGraphType<Organisation.AccessLevel>\r\n{\r\n    public AccessLevelEnum()\r\n    {\r\n        AddValue(\"ADMIN\", \"\", Organisation.AccessLevel.Admin);\r\n        AddValue(\"MEMBER\", \"\", Organisation.AccessLevel.Member);\r\n    }\r\n}\r\n\r\npublic class ProjectAccessLevelEnum : EnumerationGraphType<Project.AccessLevel>\r\n{\r\n    public AccessLevelEnum()\r\n    {\r\n        AddValue(\"ADMIN\", \"\", Organisation.AccessLevel.Admin);\r\n        AddValue(\"MEMBER\", \"\", Organisation.AccessLevel.Member);\r\n        AddValue(\"READ_ONLY\", \"\", Organisation.AccessLevel.ReadOnly);\r\n    }\r\n}\r\n```\r\nBoth of those enums will get named \"AccessLevel\".\r\n\r\nI'm able to avoid it by removing the generic like this:\r\n```\r\npublic class ProjectAccessLevelEnum : EnumerationGraphType\r\n{\r\n    public AccessLevelEnum()\r\n    {\r\n        AddValue(\"ADMIN\", \"\", Organisation.AccessLevel.Admin);\r\n        AddValue(\"MEMBER\", \"\", Organisation.AccessLevel.Member);\r\n        AddValue(\"READ_ONLY\", \"\", Organisation.AccessLevel.ReadOnly);\r\n    }\r\n}\r\n```\r\nwhich will use the name \"ProjectAccessLevelEnum\"\r\n\r\nMy question is: Why does the generic version of EnumerationGraphType work this way? -  the generic version of ObjectGraphType does not do this. ",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/759/comments",
    "author": "saborrie",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-08-01T18:35:33Z",
        "body": "The generic version of `EnumerationGraphType` tries to add all the enum values for you so you don't have to duplicate them.  This is helpful in most cases.\r\n\r\nYou should be able to just override the `Name` and it will still set all the enum values for you?\r\n\r\n```\r\npublic class OrganisationAccessLevelEnum : EnumerationGraphType<Organisation.AccessLevel>\r\n{\r\n    public AccessLevelEnum()\r\n    {\r\n        Name = \"OrganizationAccessLevelEnum\";\r\n    }\r\n}\r\n```\r\n\r\nNote that with using the non-generic version you will still be required to set the `Name`."
      },
      {
        "user": "saborrie",
        "created_at": "2018-08-01T19:24:09Z",
        "body": "Thank you for the quick reply.\r\n\r\n> The generic version of EnumerationGraphType tries to add all the enum values for you so you don't have to duplicate them. This is helpful in most cases.\r\n\r\nCool, that's really useful!\r\n\r\n> You should be able to just override the Name and it will still set all the enum values for you?\r\n\r\nOk, yeah I didn't realise I could just set the name.\r\n\r\nHowever:\r\n> Note that with using the non-generic version you will still be required to set the Name.\r\n\r\nThis didn't seem the case for me, the non generic one worked as expected\r\n"
      }
    ]
  },
  {
    "number": 737,
    "title": "How can i use DataTables with ObjectGraphType?",
    "created_at": "2018-07-15T20:49:14Z",
    "closed_at": "2018-07-19T11:46:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/737",
    "body": "My issue is that i have legacy functions returning .net DataTables and writing POCOs for each datatable is a tedious task. How can i integrate Datatables and Datasets into the root query.\r\nI'm thinking something like this.\r\n```\r\n//Example field\r\nField<DataTable>(\r\n                \"Employees\",\r\n                resolve: context => GetAllEmployees();\r\n\r\n//And the Legacy Data access layer\r\npublic Datatable GetAllEmployees( ){ \r\n// Legacy code executing sql queries \r\n}\r\n```\r\nPlease help me , i'm stuck in this issue.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/737/comments",
    "author": "HHK01",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-07-16T05:18:33Z",
        "body": "It's been a very long time since I had to deal with a `DataTable`, though I think you should be able to create a `IFieldResolver` that knows how to work with a `DataRow`.\r\n\r\n```csharp\r\npublic class QueryGraphType : ObjectGraphType\r\n{\r\n    public QueryGraphType()\r\n    {\r\n        Name = \"Query\";\r\n        Field<ListGraphType<EmployeeGraphType>>(\r\n            \"employees\",\r\n            // notice that the 'DataTable.Rows' are being returned\r\n            // the GraphQL library should loop over those rows (hopefully)\r\n            resolve: context => GetAllEmployees().Rows\r\n        );\r\n    }\r\n\r\n    public DataTable GetAllEmployees()\r\n    {\r\n        return ...;\r\n    }\r\n}\r\n\r\npublic class EmployeeGraphType : ObjectGraphType\r\n{\r\n    public EmployeeGraphType()\r\n    {\r\n        Name = \"Employee\";\r\n        // new extension method for your custom field type\r\n        this.DataRowField<IdGraphType>(\"Id\");\r\n        this.DataRowField<StringGraphType>(\"Name\");\r\n    }\r\n}\r\n\r\npublic static class ObjectGraphTypeExtensions\r\n{\r\n    public static void DataRowField<TGraphType>(\r\n        this ObjectGraphType type,\r\n        string name,\r\n        string description = null,\r\n        QueryArguments arguments = null,\r\n        string deprecationReason = null)\r\n        where TGraphType : IGraphType\r\n    {\r\n        // create a new FieldType with your custom DataRowResolver\r\n        type.AddField(new FieldType\r\n        {\r\n            Name = name,\r\n            Description = description,\r\n            Type = typeof(TGraphType),\r\n            Arguments = arguments,\r\n            DeprecationReason = deprecationReason,\r\n            Resolver = new DataRowResolver()\r\n        });\r\n    }\r\n}\r\n\r\npublic class DataRowResolver : IFieldResolver\r\n{\r\n    public object Resolve(ResolveFieldContext context)\r\n    {\r\n        var row = context.Source as DataRow;\r\n        // context.Name is the name of the field\r\n        // registered on FieldType\r\n        return row[context.Name];\r\n    }\r\n}\r\n```"
      },
      {
        "user": "HHK01",
        "created_at": "2018-07-16T05:31:08Z",
        "body": "Thank you soo much, I'll try this. Keep up the good work 👍"
      },
      {
        "user": "SimonCropp",
        "created_at": "2018-07-19T00:16:58Z",
        "body": "@HilalHakla did u meant to re-open this?"
      },
      {
        "user": "HHK01",
        "created_at": "2018-07-19T11:47:45Z",
        "body": "By mistake. I'll reopen this if anyone needs help with this."
      }
    ]
  },
  {
    "number": 735,
    "title": "How to passs HttpRequest object to resolver ?",
    "created_at": "2018-07-13T12:59:25Z",
    "closed_at": "2018-07-19T01:47:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/735",
    "body": "",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/735/comments",
    "author": "kamleshdelat",
    "comments": [
      {
        "user": "SimonCropp",
        "created_at": "2018-07-19T00:11:44Z",
        "body": "@kamleshdelat u can add it to the `UserContext` at execute time\r\n\r\neg\r\n\r\n```\r\n    [HttpPost]\r\n    public async Task<IActionResult> Post([FromBody] GraphQlQuery query)\r\n    {\r\n        var inputs = query.Variables.ToInputs();\r\n        var executionOptions = new ExecutionOptions\r\n        {\r\n            Schema = schema,\r\n            Query = query.Query,\r\n            Inputs = inputs,\r\n            UserContext = new MyUserContext\r\n            {\r\n                HttpContext = this.HttpContext,\r\n            }\r\n        };\r\n\r\n        var result = await documentExecuter.ExecuteAsync(executionOptions).ConfigureAwait(false);\r\n\r\n        if (result.Errors?.Count > 0)\r\n        {\r\n            return BadRequest(result);\r\n        }\r\n\r\n        return Ok(result);\r\n    }\r\n```\r\nu can then use that instance in the resolve\r\n```\r\nresolve: context =>\r\n{\r\n    var userContext = (MyUserContext)context.UserContext;\r\n    var httpContext= userContext.HttpContext;\r\n\r\n    return ....;\r\n}\r\n```"
      },
      {
        "user": "joemcbride",
        "created_at": "2018-07-19T01:47:29Z",
        "body": "@SimonCropp thanks!"
      }
    ]
  },
  {
    "number": 695,
    "title": "Using FieldAsync to resolve an async mutation ",
    "created_at": "2018-06-14T12:17:15Z",
    "closed_at": "2018-06-14T16:07:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/695",
    "body": "Is this the correct way to make a mutation resolver async?\r\nUsing GraphQL Version 0.17.3\r\n\r\n```csharp\r\n// in startup\r\n    var result = await _documentExecuter.ExecuteAsync(_ =>\r\n    {\r\n        _.Schema = new Schema \r\n            {\r\n                Query = new Query();\r\n                Mutation = new Mutation();\r\n            }\r\n        // ...\r\n    });\r\n\r\n// mutation using FieldAsync\r\npublic class Mutation : ObjectGraphType\r\n{\r\n    public Mutation()\r\n    {\r\n        Name = \"Mutation\";\r\n\r\n        // note that createTransaction is async\r\n        FieldAsync<TransactionNode>(\"createTransaction\",\r\n            // arguments: new QueryArguments {...}\r\n            resolve: async ctx => await TransactionInput.CreateTransaction();\r\n        // ...\r\n    }\r\n}\r\n\r\n// async mutation resolver\r\npublic class TransactionInput : InputObjectGraphType\r\n{\r\n    // ...\r\n    public static async Task<TransactionNode> CreateTransaction()\r\n    { \r\n        // ...\r\n        await _httpClient.SendAsync()\r\n        // ...\r\n    }\r\n    // ...\r\n}\r\n```\r\nThanks",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/695/comments",
    "author": "masduo",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-06-14T14:53:55Z",
        "body": "You only need to use FieldAsync if you need/want to use the async keyword.  You can return a Task and it will be awaited for you with the other overloads."
      },
      {
        "user": "masduo",
        "created_at": "2018-06-14T15:55:06Z",
        "body": "Thanks @joemcbride \r\nBut is my sample above the recommended way to use the library if i need need/want async? Otherwise do you have an example of how to use it? \r\n\r\nAlso is this what you mean by\r\n> ... return a Task and it will be awaited for you with the other overloads.\r\n\r\n```csharp\r\n// mutation\r\nField<TransactionNode>(\"createTransaction\",\r\n    // arguments: new QueryArguments {...}\r\n    resolve: ctx => TransactionInput.CreateTransaction();\r\n\r\n// resolver's still async and returns a Task\r\n public static async Task<TransactionNode> CreateTransaction() \r\n{ \r\n    await _httpClient.SendAsync(...);\r\n}\r\n```\r\n"
      },
      {
        "user": "joemcbride",
        "created_at": "2018-06-14T16:00:14Z",
        "body": "> is this what you mean\r\n\r\nYes. These are functionally equivalent.  One just allows you to use the `async` keyword in the `resolve:` declaration.\r\n\r\n```csharp\r\nField<TransactionNode>(\"createTransaction\",\r\n    resolve: ctx => TransactionInput.CreateTransaction();\r\n\r\nFieldAsync<TransactionNode>(\"createTransaction\",\r\n    resolve: async ctx => await TransactionInput.CreateTransaction();\r\n```"
      },
      {
        "user": "masduo",
        "created_at": "2018-06-14T16:07:08Z",
        "body": "Alright great, thanks for your speedy response :)"
      },
      {
        "user": "vinhbachkhoa",
        "created_at": "2019-01-08T15:27:37Z",
        "body": "how to use veraiable in mutation "
      }
    ]
  },
  {
    "number": 684,
    "title": "Map input fields.",
    "created_at": "2018-06-05T21:36:19Z",
    "closed_at": "2020-03-01T22:21:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/684",
    "body": "Hi, \r\n\r\nI have the following use case:\r\n\r\nMy objects are nested dictionaries (JObjects). But the keys are not always valid for GraphQL,e g. the contain dashes or underscores.\r\n\r\nBut of course I can easily map them:\r\n\r\n\tstring key; // From internal schema definition.\r\n\t\r\n\tvar resolver = new FuncFieldResolver<object>(c =>\r\n\t{\r\n\t\tif (((JObject)c.Source).TryGetValue(key, out var value))\r\n\t\t{\r\n\t\t\treturn fieldInfo.Resolver(value, c);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn fieldInfo;\r\n\t\t}\r\n\t});\r\n\r\n\tAddField(new FieldType\r\n\t{\r\n\t\tName = key.ToCamelCase(),\r\n\t\tResolver = resolver,\r\n\t\tResolvedType = fieldInfo.ResolveType,\r\n\t});\r\n\r\nBut I cannot do something similar for the input types, because I just get a nested IDictionary<string, object>. Is there a solution I don't see, except than converting the final dictionary? It would be great to have something like a reverse resolver so that I can also skip the generation of the IDictionary and create the objects manually or set the properties.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/684/comments",
    "author": "SebastianStehle",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-06-06T00:37:30Z",
        "body": "I'm not sure I'm fully understanding what you're trying to do.  You are trying to dynamically build a Schema based on JObjects?  Or are you fetching data, returned as JObjects, and you're trying to return those values in the resolver?  Can you provide an example of what you're expecting the input arguments to look like in GraphQL Schema syntax?\r\n\r\nEx:\r\n\r\n```\r\ninput CreateInput {\r\n  name: String\r\n  age: Int\r\n}\r\n\r\ntype Query {\r\n  person(id: String): Person\r\n  createPerson(input:CreateInput): Person\r\n}\r\n```\r\n\r\nIn this case `id` and `input` are the arguments."
      },
      {
        "user": "SebastianStehle",
        "created_at": "2018-06-06T05:06:49Z",
        "body": "I have a custom schema for my  JObjects. The schema could say that there is a field with name `benutzer-straße`. The field name is in German and contains the dash and the letter `ß` which should be replaced with `ss`. So to stay in your example it would become this schema.\r\n\r\n\tinput CreateInput {\r\n\t  benutzerStrasse: String\r\n\t}\r\n\r\n\ttype Query {\r\n\t  person(id: String): Person\r\n\t  createPerson(input:CreateInput): Person\r\n\t}\r\n\r\nIn my queries this mapping is easy to do with the resolvers, I can just change the field name with `key.ToCamelCase().Replace(...)` and it works fine. But for mutation I can not make this (reverse) mapping very easily. Because graphql-dotnet always uses the field Name to add the values to the dictionary. Of course I can process the input object in the mutation but I think it should be the responsibility of the input scheme to make this mapping."
      },
      {
        "user": "joemcbride",
        "created_at": "2018-06-06T05:27:18Z",
        "body": "So are you trying to go from the `benutzerStrasse` input field back to `benutzer-straße` in a mutation?"
      },
      {
        "user": "SebastianStehle",
        "created_at": "2018-06-06T05:31:43Z",
        "body": "Yes"
      },
      {
        "user": "joemcbride",
        "created_at": "2018-06-06T05:57:32Z",
        "body": "👍 My first recommendation would be to write a small object model around that `JObject`.  Then it could handle that mapping fairly easily for you.\r\n\r\n```csharp\r\npublic class Benutzer\r\n{\r\n    public Benutzer(JObject json)\r\n    {\r\n        Json = json;\r\n    }\r\n\r\n    public string BenutzerStrasse\r\n    {\r\n        get => Json.TryGetString(\"benutzer-straße\");\r\n        set => Json.SetString(\"benutzer-straße\", value);\r\n    }\r\n\r\n    public JObject Json { get; }\r\n}\r\n\r\npublic static class JObjectExtensions\r\n{\r\n    public static JToken TryGetValue(this JObject json, string name)\r\n    {\r\n        if (json != null && json.TryGetValue(name, StringComparison.OrdinalIgnoreCase, out JToken value))\r\n        {\r\n            return value;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    public static string TryGetString(this JObject json, string name)\r\n    {\r\n        JToken value = json.TryGetValue(name);\r\n        return value?.ToString();\r\n    }\r\n\r\n    public static void SetString(this JObject json, string name, string value)\r\n    {\r\n        json[name] = value;\r\n    }\r\n}\r\n```\r\n\r\nIf it needs to be more dynamic than that, you could perhaps add the mapping as `Metadata` on the `GraphType` or the `FieldType`.\r\n\r\n```csharp\r\nvar field = new FieldType\r\n{\r\n    Name = key.ToCamelCase(),\r\n    Resolver = resolver,\r\n    ResolvedType = fieldInfo.ResolveType,\r\n};\r\nfield.Metadata[\"mappedName\"] = key;\r\n```\r\n\r\nThe `FieldType` can be accessed in the resolver.\r\n\r\n```csharp\r\ncontext => context.FieldDefinition.Metadata[\"mappedName\"]\r\ncontext => context.FieldDefinition.GetMetadata<string>(\"mappedName\");\r\n```"
      },
      {
        "user": "SebastianStehle",
        "created_at": "2018-06-06T06:06:29Z",
        "body": "The schema is not known at build time. Therefore I use the JObject for my data. The metadata approach is probably the same idea like my approach: To process the input Dictionary in my mutation-resolver.  You can use the metadata for that but I also have my custom schema, which I can use. But I think there should be something like a reverse-resolver for input types."
      },
      {
        "user": "saborrie",
        "created_at": "2018-08-15T22:01:14Z",
        "body": "+1 for the reverse resolver"
      },
      {
        "user": "joemcbride",
        "created_at": "2018-08-15T22:56:33Z",
        "body": "> skip the generation of the IDictionary and create the objects manually or set the properties\r\n\r\nThere are several things that happen related to the Arguments + Variables to conform to the GraphQL spec and get those specific values to the specified resolver.\r\n\r\nI'm not sure I want to try to deal with this with this framework.\r\n\r\nThat said, if this is really wanted can you provide a proposal on what you would expect that API to look like and how it would behave?"
      },
      {
        "user": "saborrie",
        "created_at": "2018-08-16T13:00:26Z",
        "body": "Maybe there's already a way to do this nicely, but essentially it would be good to define how input types deserialise into the models that they are for. For example, it would be nice to have a way of replacing this:\r\n\r\n```\r\n    public class MyInputType: InputObjectGraphType<MyInputModel>\r\n    {\r\n        public MyInputType()\r\n        {\r\n            Field(_ => _.Payload);\r\n        }\r\n    }\r\n\r\n    public class MyInputModel\r\n    {\r\n        public string Payload { get; set; } // actually just a JSON serialised payload\r\n    }\r\n```\r\n\r\nWith this:\r\n```\r\n    public class MyInputType: InputObjectGraphType<MyInputModel>\r\n    {\r\n        public MyInputType()\r\n        {\r\n            // something along these lines:\r\n            Field<StringGraphType>().Name(\"payload\").Deserialize(_ => JsonConvert.DeserializeObject<dynamic>(_));\r\n        }\r\n    }\r\n\r\n    public class MyInputModel\r\n    {\r\n        public dynamic Payload { get; set; } // the deserialised payload object\r\n    }\r\n```\r\n\r\nSince I'd never actually want to \"resolve\" a field on an input type, I'm not sure why it has Resolve methods"
      },
      {
        "user": "AmbroiseCouissin",
        "created_at": "2018-10-23T04:00:34Z",
        "body": "Would love this as well. This would clean a lot of our DTOs."
      },
      {
        "user": "Tarig0",
        "created_at": "2019-01-14T15:30:17Z",
        "body": "This would be nice to handle differences in naming conventions since snake case => pascal case does not work with the current input mapping."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-27T16:25:12Z",
        "body": "> Since I'd never actually want to \"resolve\" a field on an input type, I'm not sure why it has Resolve methods\r\n\r\nIt is a design flaw.\r\n\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-27T16:29:27Z",
        "body": "Relates to #1107 "
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-27T16:34:41Z",
        "body": "@saborrie I understand your idea. API will look different, but the functional purpose will be just that."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-27T20:09:04Z",
        "body": "Well, I think this issue will be resolved after merging #1577 . You can register any conversion delegate through `ValueConverter.Register` and it will be called from `context.GetArgument<YourDTO>`. Note that this applies to any nesting level of properties in the input argument, not root only."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-27T20:11:37Z",
        "body": "I was wrong, changes are required for the complex type."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-29T17:38:54Z",
        "body": "Duplicate of #669"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-01T22:24:29Z",
        "body": "@SebastianStehle Done in #1582 . You can try the latest preview."
      }
    ]
  },
  {
    "number": 676,
    "title": "Passing StringGraphType as QueryArgument",
    "created_at": "2018-05-28T15:34:07Z",
    "closed_at": "2018-06-04T14:51:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/676",
    "body": "I know this isn't so much a graphql-dotnet issue as a NewtonSoft issue but may help someone (or I likely am missing something).\r\n\r\nI'm trying to deserialize where the queryargument is a string:\r\n\r\n`var body = \"{\\\"query\\\":\\\"{transactions(term:\\\"hello\\\") {transactionId}}\\\"}\"`   \r\n`var request = JsonConvert.DeserializeObject<GraphQLQuery>(body);`\r\n\r\nBut NewtonSoft baulks at the 'h' in 'hello':\r\n\r\n`\"After parsing a value an unexpected character was encountered: h. Path 'query', line 1, position 30.\"`\r\n\r\nHow do you get around this?\r\n\r\nPassing IntGraphType as below works fine.\r\n\r\n`var body = \"{\\\"query\\\":\\\"{documents(typeId:1) {documentId, documentName, description, revision}}\\\"}`\r\n\r\nThanks for any/all responses. \r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/676/comments",
    "author": "mike-niemand",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-05-29T16:57:20Z",
        "body": "```csharp\r\nvar body = \"{\\\"query\\\":\\\"{transactions(term:\\\"hello\\\") {transactionId}}\\\"}\"\r\n```\r\n\r\nThat is invalid JSON (which is why you get the parse error).  To properly escape the `\"` around `hello` you have to include the escaped `\\`.\r\n\r\n```csharp\r\nvar body = \"{\\\"query\\\":\\\"{transactions(term:\\\\\\\"hello\\\\\\\") {transactionId}}\\\"}\"\r\n```\r\n\r\nYou can see the required JSON format by reversing the process:\r\n\r\n```csharp\r\nvar data = new GraphQLQuery\r\n{\r\n    Query = \"{transactions(term:\\\"hello\\\") {transactionId}}\"\r\n};\r\nvar body2 = JsonConvert.SerializeObject(data);\r\n```"
      }
    ]
  },
  {
    "number": 672,
    "title": "Resolver is not be utilized for sub-entity lookup",
    "created_at": "2018-05-25T19:53:27Z",
    "closed_at": "2020-03-29T10:11:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/672",
    "body": "Back again with another one.  I have an associated entity that is not being resolved.\r\n\r\nEmployeeTypeData\r\n```csharp\r\npublic Func<ResolveFieldContext<object>, object> GetResolver()\r\n{\r\n    return context => {\r\n        Guid id = Guid.Empty;\r\n\r\n        Object source = context.Source;\r\n        if (source is Employee)\r\n        {\r\n            id = (source as Employee).EmployeeTypeId;\r\n        }\r\n        else\r\n        {\r\n            id = context.GetArgument<Guid>(\"id\");\r\n        }\r\n\r\n        if (id != Guid.Empty)\r\n        {\r\n            return _sourceTypeRepository.GetAsync(id);\r\n        }\r\n        else\r\n        {\r\n            return _sourceTypeRepository.ListAllAsync();\r\n        }\r\n    };\r\n}\r\n```\r\n\r\nEmployeeTypeInterface\r\n```csharp\r\npublic class EmployeeTypeInterface : InterfaceGraphType<EmployeeType>\r\n{\r\n    public EmployeeTypeInterface()\r\n    {\r\n        Name = \"employeeType\";\r\n\r\n        Field(x => x.Id).Name(\"id\").Description(\"The database id of the employee type.\");\r\n        Field(x => x.Name).Name(\"name\").Description(\"The name of the employee type.\");\r\n    }\r\n}\r\n```\r\n\r\nEmployeeTypeType\r\n```csharp\r\npublic class EmployeeTypeType : ObjectGraphType<EmployeeType>\r\n{\r\n    public EmployeeTypeType()\r\n    {\r\n        Name = \"EmployeeType\";\r\n\r\n        Field(x => x.Id).Name(\"id\").Description(\"The database id of the employee type.\");\r\n        Field(x => x.Name).Name(\"name\").Description(\"The name of the employee type.\");\r\n\r\n        Interface<EmployeeTypeInterface>();\r\n    }\r\n}\r\n```\r\n\r\n```csharp\r\npublic class EmployeeType : ObjectGraphType<Employee>\r\n{\r\n    public EmployeeType()\r\n    {\r\n        Name = \"Employee\";\r\n\r\n        Field(x => x.Id, type: typeof(IdGraphType)).Name(\"id\").Description(\"The database id of the employee.\");\r\n        Field(x => x.FirstName).Name(\"firstName\").Description(\"The first name of the employee.\");\r\n        Field(x => x.LastName).Name(\"lastName\").Description(\"The last name of the employee.\");\r\n        Field(x => x.EmployeeTypeId).Name(\"employeeTypeId\").Description(\"The database id of the employee's employee type.\");\r\n\r\n        Field<EmployeeTypeInterface>(\"employeeType\");\r\n\r\n        Interface<EmployeeInterface>();\r\n    }\r\n}\r\n```\r\n\r\n```\r\nquery {\r\n  employee {\r\n    id\r\n    name\r\n    employeeTypeId\r\n    employeeType\r\n  }\r\n}\r\n```\r\n\r\nThe `employeeTypeId` has data on the return JSON, but there is no data in the `employeeType` field.  I put a break point in the `EmployeeTypeData` resolver and it never gets hit.\r\n\r\n```\r\nquery {\r\n  employeeTypes {\r\n    id\r\n    name\r\n  }\r\n}\r\n```\r\n\r\nThis query hits the break point, so I know that my resolver is correctly implemented.  Why would this one particular case have issues with resolving on another entity?  My schema's Query has the following fields defined.\r\n\r\n```csharp\r\nField<EmployeeTypeInterface>(\r\n    \"employeeType\",\r\n    resolve: new EmployeeTypeData(employeeTypeRepository).GetResolver()\r\n);\r\n\r\nField<ListGraphType<EmployeeTypeInterface>>(\r\n    \"employeeTypes\",\r\n    resolve: new EmployeeTypeData(employeeTypeRepository).GetResolver()\r\n);\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/672/comments",
    "author": "bdparrish",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-05-27T16:16:17Z",
        "body": "I highly suggest to not have a \"one resolver for everything\" pattern.\r\n\r\n```csharp\r\nField<EmployeeTypeInterface>(\"employeeType\");\r\n```\r\nThis declaration has no resolver defined, so it will use the default resolver.  The default resolver just looks for a property on the `Source` object with the given name.  In this case, it expects the `Employee` object to look like such:\r\n\r\n```csharp\r\npublic class Employee\r\n{\r\n    public EmployeeType EmployeeType { get; set; }\r\n}\r\n```\r\nIf you need to call a function to get that information you need to provide a resolver for it.\r\n\r\n```csharp\r\nField<EmployeeTypeInterface>(\"employeeType\",\r\n  context => _employeeTypeRespository.TypeForEmployee(context.Source));\r\n```"
      },
      {
        "user": "bdparrish",
        "created_at": "2018-05-27T16:24:53Z",
        "body": "If I am using the repository pattern, then the library throws a error saying that a `EmployeeType` cannot be returned for an expected `EmployeeTypeInterface`.  Is there a way to do something else where I am handling it with its own specific resolver?  Can you also verify that utilizing async methods is handled properly by a `Field` when resolving?\r\n\r\n```csharp\r\nField<EmployeeTypeInterface>(\"employeeType\", resolve: new EmployeeTypeData(employeeTypeRepository).GetEmployeeResolver());\r\n```"
      },
      {
        "user": "joemcbride",
        "created_at": "2018-05-27T16:42:08Z",
        "body": "> library throws a error saying that a EmployeeType cannot be returned for an expected EmployeeTypeInterface.\r\n\r\nDid you register `EmployeeTypeType` with the schema?  If you print the schema is `EmployeeType` graph type listed as well as the `employeeType` interface?\r\n\r\n```csharp\r\nnew SchemaPrinter(schema).Print();\r\n```\r\n\r\nI should look something like:\r\n\r\n```\r\ninterface employeeType {\r\n  id: ID!\r\n  name: String!\r\n}\r\n\r\ntype EmployeeType implements employeeType {\r\n  id: ID!\r\n  name: String!\r\n}\r\n```\r\n\r\n> Can you also verify that utilizing async methods is handled properly by a Field when resolving?\r\n\r\nYes you can use methods that return a `Task`.  If you want to use the `async` keyword then you would need to use an overload, `FieldAsync`."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-01T22:58:24Z",
        "body": "@bdparrish Is this issue still actual for you?"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-29T10:11:07Z",
        "body": "Closed due to lack of feedback."
      }
    ]
  },
  {
    "number": 667,
    "title": "[Question] - nested mutations or multiple files",
    "created_at": "2018-05-24T11:19:54Z",
    "closed_at": "2018-06-12T07:15:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/667",
    "body": "Hi guys,\r\n\r\nI'm trying to figure out how to do nested mutations if it's even possible? \r\n\r\nI want to have better, logical spearation.\r\n**Schema.Mutation** is type **IObjectGraphType**. \r\nSo I created corresponding file. Everything is fine when I have all mutations in one file, but it's stupid for anything bigger than example project. I want to split mutations logical into separate file, but how to wrap it and make it work ? ",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/667/comments",
    "author": "sgwozdz",
    "comments": [
      {
        "user": "chwarwick",
        "created_at": "2018-05-24T20:01:47Z",
        "body": "@sgwozdz A simple option that you can use is to put a marker Interface on all your individual Mutation classes and then inject them into the main Mutation.  Then you just just loop through and add all it's fields\r\n```\r\npublic Mutation(IEnumerable<IMutation> mutationClasses)\r\n{\r\n    foreach (var mutationClass in mutationClasses)\r\n    {\r\n         foreach (var field in mutationClass.Fields)\r\n         {\r\n             AddField(field);\r\n         }\r\n    }\r\n}\r\n```\r\n"
      },
      {
        "user": "sgwozdz",
        "created_at": "2018-05-25T08:33:53Z",
        "body": "In fact few minutes after I wrote this question I found out this solution. I'm not happy with this but it works."
      },
      {
        "user": "joemcbride",
        "created_at": "2018-05-25T18:22:25Z",
        "body": "Here is one \"trick\" you can do - you can \"group\" them under a subfield.  Something like this:\r\n\r\n```\r\nField<PersonMutation>(\"people\", resolve: ctx => new {});\r\n\r\nmutation CreatePersonMutation {\r\n  people {\r\n    createPerson(name: \"Joe\") {\r\n      id\r\n      name\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nNot the best perhaps, but an option."
      }
    ]
  },
  {
    "number": 663,
    "title": "Avoiding having to reregister Fields on all implementors of an interface?",
    "created_at": "2018-05-21T21:48:05Z",
    "closed_at": "2018-06-04T14:53:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/663",
    "body": "This code works:\r\n```csharp\r\n  public class NotificationSubscriptionUnion : UnionGraphType\r\n    {\r\n        public NotificationSubscriptionUnion()\r\n        {            \r\n            Type<SimulationNotificationSubscription>();\r\n            Type<BillingNotificationSubscription>();\r\n        }\r\n    }\r\n    \r\n    public class NotificationSubscriptionInterface : InterfaceGraphType<NotificationSubscription> {\r\n        public NotificationSubscriptionInterface()\r\n        {\r\n            Name = \"NotificationSubscription\";\r\n            Field<StringGraphType>().Name(\"_id\").Description(\"Unique ID\");\r\n            Field(x => x.endpoints);\r\n            Field(x => x.trigger);\r\n            Field(x => x.target).Description(\"The triggering event for the subscription.\");                      \r\n        }\r\n    }\r\n\r\n    public class SimulationNotificationSubscription : ObjectGraphType<NotificationSubscription> {\r\n        public SimulationNotificationSubscription() \r\n        {      \r\n            Interface<NotificationSubscriptionInterface>();\r\n\r\n            IsTypeOf = s => !string.IsNullOrEmpty((s as NotificationSubscription).simulationPhase); \r\n            Field<StringGraphType>().Name(\"_id\").Description(\"Unique ID\");\r\n            Field(x => x.endpoints);\r\n            Field(x => x.trigger);\r\n            Field(x => x.target).Description(\"The triggering event for the subscription.\");                \r\n            Field(x => x.simulationPhase);                                  \r\n        }        \r\n    }\r\n    \r\n    public class BillingNotificationSubscription : ObjectGraphType<NotificationSubscription> {\r\n        public BillingNotificationSubscription() \r\n        {      \r\n            Interface<NotificationSubscriptionInterface>();\r\n          \r\n            IsTypeOf = s => (s as NotificationSubscription).threshold != null; \r\n            \r\n            Field<StringGraphType>().Name(\"_id\").Description(\"Unique ID\");\r\n            Field(x => x.endpoints);\r\n            Field(x => x.trigger);\r\n            Field(x => x.target).Description(\"The triggering event for the subscription.\");                \r\n            Field(x => x.threshold, nullable:true);                                  \r\n        }        \r\n    }\r\n    \r\n    public class NotificationEndpointGraphType : ObjectGraphType<NotificationEndpoint>\r\n    {\r\n        public NotificationEndpointGraphType()\r\n        {\r\n            Field(x => x.type);\r\n            Field(x => x.value);\r\n        }\r\n    }\r\n```\r\n\r\nIf I remove the duplicated Field calls and instead only declare the unique fields in each of the unioned types, GraphQL Playground complains with:\r\n\r\n```invariant.js:19 Uncaught (in promise) Error: \"NotificationSubscription\" expects field \"_id\" but \"SimulationNotificationSubscription\" does not provide it.\r\n    at n (invariant.js:19)\r\n    at schema.js:244\r\n    at Array.forEach (<anonymous>)\r\n    at a (schema.js:239)\r\n    at schema.js:121\r\n    at Array.forEach (<anonymous>)\r\n    at schema.js:120\r\n    at Array.forEach (<anonymous>)\r\n    at new e (schema.js:117)\r\n    at Object.i (buildClientSchema.js:290)```\r\n\r\n\r\nHow do I avoid needing to duplicate a ton of shared code every time?  I would have thought this would be handled by Interface<T>()",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/663/comments",
    "author": "acronoah",
    "comments": [
      {
        "user": "acronoah",
        "created_at": "2018-05-21T21:48:54Z",
        "body": "To be clear, here's my goal code:\r\n\r\n```csharp\r\n public class NotificationSubscriptionUnion : UnionGraphType\r\n    {\r\n        public NotificationSubscriptionUnion()\r\n        {            \r\n            Type<SimulationNotificationSubscription>();\r\n            Type<BillingNotificationSubscription>();\r\n        }\r\n    }\r\n    \r\n    public class NotificationSubscriptionInterface : InterfaceGraphType<NotificationSubscription> {\r\n        public NotificationSubscriptionInterface()\r\n        {\r\n            Name = \"NotificationSubscription\";\r\n            Field<StringGraphType>().Name(\"_id\").Description(\"Unique ID\");\r\n            Field(x => x.endpoints);\r\n            Field(x => x.trigger);\r\n            Field(x => x.target).Description(\"The triggering event for the subscription.\");                      \r\n        }\r\n    }\r\n\r\n    public class SimulationNotificationSubscription : ObjectGraphType<NotificationSubscription> {\r\n        public SimulationNotificationSubscription() \r\n        {      \r\n            Interface<NotificationSubscriptionInterface>();\r\n\r\n            IsTypeOf = s => !string.IsNullOrEmpty((s as NotificationSubscription).simulationPhase); \r\n            Field(x => x.simulationPhase);                                  \r\n        }        \r\n    }\r\n    \r\n    public class BillingNotificationSubscription : ObjectGraphType<NotificationSubscription> {\r\n        public BillingNotificationSubscription() \r\n        {      \r\n            Interface<NotificationSubscriptionInterface>();\r\n          \r\n            IsTypeOf = s => (s as NotificationSubscription).threshold != null; \r\n            \r\n            Field(x => x.threshold, nullable:true);                                  \r\n        }        \r\n    }\r\n```"
      },
      {
        "user": "joemcbride",
        "created_at": "2018-05-21T23:02:57Z",
        "body": "An interface in GraphQL works just like in .NET.  It provides no default implementation.   If you want to provide a default implementation, you should be able to use inheritance.\r\n\r\n\r\n```csharp\r\n    public abstract class NotificationSubscriptionBase : ObjectGraphType<NotificationSubscription> {\r\n        protected NotificationSubscriptionBase() \r\n        {      \r\n            Interface<NotificationSubscriptionInterface>();\r\n\r\n            Field<StringGraphType>().Name(\"_id\").Description(\"Unique ID\");\r\n            Field(x => x.endpoints);\r\n            Field(x => x.trigger);\r\n            Field(x => x.target).Description(\"The triggering event for the subscription.\");                \r\n        }        \r\n    }\r\n\r\n   public class BillingNotificationSubscription : NotificationSubscriptionBase {\r\n        public BillingNotificationSubscription() \r\n        {      \r\n            IsTypeOf = s => (s as NotificationSubscription).threshold != null; \r\n\r\n            Field(x => x.threshold, nullable:true);                                  \r\n        }        \r\n    }\r\n```"
      }
    ]
  },
  {
    "number": 659,
    "title": "Get type requested fields names as an array of strings",
    "created_at": "2018-05-11T15:22:05Z",
    "closed_at": "2018-06-04T14:56:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/659",
    "body": "I would like to know how to get all the names of fields from a query so I can build dynamic selects at the query level.\r\n\r\nExample: \"{ hero { name, firstname } }\"\r\n\r\nMy List array would content [\"name\", \"firstname\"]\r\n\r\n```\r\n    public class StarWarsQuery : ObjectGraphType\r\n    {\r\n      public StarWarsQuery()\r\n      {\r\n        Field<DroidType>(\r\n          \"hero\",\r\n          resolve: context => {\r\n                    context.RequestedFields // [name, firstname ]\r\nreturn new Droid { Id = \"1\", Name = \"R2-D2\" }}\r\n        );\r\n      }\r\n    }\r\n```\r\n\r\nthanks!",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/659/comments",
    "author": "Jonatthu",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-05-11T15:56:49Z",
        "body": "Try `context.SubFields`"
      },
      {
        "user": "Jonatthu",
        "created_at": "2018-06-15T22:04:00Z",
        "body": "Graphql 0.17.3 does not have SubFields on context when I am debugging  @joemcbride "
      },
      {
        "user": "joemcbride",
        "created_at": "2018-06-15T22:39:31Z",
        "body": "@Jonatthu Was added in 2.0."
      }
    ]
  },
  {
    "number": 656,
    "title": "Q: Is there a version that is targeting .net core?",
    "created_at": "2018-05-10T18:03:12Z",
    "closed_at": "2018-05-10T18:10:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/656",
    "body": "I need to run a service in a Linux container.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/656/comments",
    "author": "kckst8",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-05-10T18:10:02Z",
        "body": "Version 0.13+ support NetStandard.  I would suggest to use the latest 2.0 prerelease."
      }
    ]
  },
  {
    "number": 655,
    "title": "Resolving objects inside other objects",
    "created_at": "2018-05-09T02:33:22Z",
    "closed_at": "2018-05-09T03:16:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/655",
    "body": "I'm attempting to build a schema with two objects: Assets and Actors.\r\n\r\n```cs\r\n    public class Asset\r\n    {\r\n        public string Id { get; set; }\r\n        public Actor Owner { get; set; }\r\n        public string Location { get; set; }\r\n        public string Variety { get; set; }\r\n        public string Quantity { get; set; }\r\n    }\r\n```\r\n\r\n```cs\r\n    public class Actor\r\n    {\r\n        public string Id { get; set; }\r\n        public string Name { get; set; }\r\n        public string Address { get; set; }\r\n    }\r\n```\r\n\r\nBut I run into an issue running queries to select Assets. For example, this query gives the error \"Field owner of type Actor must have a sub selection\".\r\n\r\n```json\r\nquery {\r\n    asset(id: \"1\")\r\n    {\r\n        id,\r\n        owner,\r\n        location\r\n}\r\n```\r\n\r\nI really have no idea how to deal with this 😨 \r\n\r\nMy asset type:\r\n\r\n```cs\r\n        public AssetType(GeoraData data)\r\n        {\r\n            Name = \"Asset\";\r\n\r\n            Field(a => a.Id).Description(\"The ID of the asset\");\r\n            Field(a => a.Owner).Description(\"The owner of the asset\");\r\n            Field(a => a.Location).Description(\"The location where the asset is stored\");\r\n            Field(a => a.Variety).Description(\"The variety of the asset\");\r\n            Field(a => a.Quantity).Description(\"The quantity of the asset in mt\");\r\n        }\r\n```\r\n\r\nMy query:\r\n```cs\r\n        public Query(Data data)\r\n        {\r\n            Name = \"Query\";\r\n\r\n            Field<AssetType>(\r\n                \"asset\",\r\n                arguments: new QueryArguments(\r\n                    new QueryArgument<NonNullGraphType<StringGraphType>>\r\n                    {\r\n                        Name = \"id\",\r\n                        Description = \"ID of the asset\"\r\n                    }),\r\n                resolve: context => data.GetAssetByIdAsync(context.GetArgument<string>(\"id\")));\r\n\r\n            Field<ActorType>(\r\n                \"actor\",\r\n                arguments: new QueryArguments(\r\n                    new QueryArgument<NonNullGraphType<StringGraphType>>\r\n                    {\r\n                        Name = \"id\",\r\n                        Description = \"ID of the actor\"\r\n                    }),\r\n                resolve: context => data.GetActorByIdAsync(context.GetArgument<string>(\"id\")));\r\n        }\r\n```\r\n\r\nAny help fixing the issue would be very appreciated, as I have no idea where to start!\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/655/comments",
    "author": "kdelwat",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-05-09T02:49:12Z",
        "body": "Because `owner` on `Asset` is a complex type, you have to provide what fields on that `GraphType` you want to query.\r\n\r\n```\r\nquery {\r\n    asset(id: \"1\")\r\n    {\r\n        id\r\n        owner {\r\n            id\r\n            name\r\n        }\r\n        location\r\n}\r\n```\r\n\r\nAlso because it is a complex type you will need to configure what `GraphType` it is.\r\n\r\n```diff\r\n-Field(a => a.Owner).Description(\"The owner of the asset\");\r\n\r\n+Field(a => a.Owner, type: typeof(ActorType)).Description(\"The owner of the asset\");\r\n```\r\n\r\nor\r\n\r\n```diff\r\n-Field(a => a.Owner).Description(\"The owner of the asset\");\r\n\r\n+Field<ActorType>(\"owner\", resolve: ctx => ctx.Source.Owner);\r\n```\r\n\r\nor\r\n\r\n```diff\r\nField(a => a.Owner).Description(\"The owner of the asset\");\r\n\r\n+GraphTypeRegistry.Register(typeof(Actor), typeof(ActorType));\r\n```"
      },
      {
        "user": "kdelwat",
        "created_at": "2018-05-09T03:16:22Z",
        "body": "Thanks so much, that fixed it! "
      }
    ]
  },
  {
    "number": 653,
    "title": "Issue Resolving Dependencies in context.GetArgument<T>",
    "created_at": "2018-05-07T15:53:48Z",
    "closed_at": "2018-05-07T15:58:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/653",
    "body": "I am running into an error when trying to get an argument from a mutation\r\n\r\n```namespace Performance.GraphQl\r\n{\r\n    public class PerformanceMutation :ObjectGraphType<object>\r\n    {\r\n        public PerformanceMutation(PerformanceService service, Core core)\r\n        {\r\n            Field<SessionType>(\r\n                \"createSession\",\r\n                arguments: new QueryArguments(\r\n                    new QueryArgument<NonNullGraphType<SessionInputType>> { Name = \"session\" }\r\n                ),              \r\n                resolve: context =>\r\n                {\r\n                    var session = context.GetArgument<PerformanceSession>(\"session\"); //System.MissingMethodException: 'No parameterless constructor defined for this object.'\r\n                    var test = new PerformanceSession(core);//this works fine\r\n                    return service.AddSession(test); //As does this.\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n }\r\n```\r\n\r\nThe PerformanceSession Object by my company's design needs a constructor that takes a Core object\r\n```\r\nnamespace Performance.Data\r\n{\r\n    public class PerformanceSession : ModelBase\r\n    {\r\n        public PerformanceSession(Core core) : base(core)\r\n        {\r\n        }\r\n\r\n        public override IModelPersistenceBase GetPersistence()\r\n        {\r\n            return new PerformanceSessionPersistence(UlineCore);\r\n        }\r\n///OTHER LOGIC///\r\n    }\r\n```\r\n\r\nIs having a DI dependent class in the context.GetArguments<T> method not supported?  \r\n\r\nHere is my Schmea in case that is needed to help, but I pretty much copied from the StarWars example.\r\n```\r\nnamespace Performance.GraphQl\r\n{\r\n    public class PerformanceSchema : Schema\r\n    {\r\n        public PerformanceSchema(IDependencyResolver resolver): base(resolver)\r\n        {\r\n            Query = resolver.Resolve<PerformanceQuery>();\r\n            Mutation = resolver.Resolve<PerformanceMutation>();\r\n            \r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAnd the Resolver\r\n```namespace Performance\r\n{\r\n    public class UnityResolver : IDependencyResolver\r\n    {\r\n        protected IUnityContainer container;\r\n\r\n        public UnityResolver(IUnityContainer container)\r\n        {\r\n            if (container == null)\r\n            {\r\n                throw new ArgumentNullException(\"container\");\r\n            }\r\n            this.container = container;\r\n        }\r\n\r\n        public object GetService(Type serviceType)\r\n        {\r\n            try\r\n            {\r\n                return container.Resolve(serviceType);\r\n            }\r\n            catch (ResolutionFailedException)\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        public IEnumerable<object> GetServices(Type serviceType)\r\n        {\r\n            try\r\n            {\r\n                return container.ResolveAll(serviceType);\r\n            }\r\n            catch (ResolutionFailedException)\r\n            {\r\n                return new List<object>();\r\n            }\r\n        }\r\n\r\n        public IDependencyScope BeginScope()\r\n        {\r\n            var child = container.CreateChildContainer();\r\n            return new UnityResolver(child);\r\n        }\r\n\r\n        public void Dispose()\r\n        {\r\n            Dispose(true);\r\n        }\r\n\r\n        protected virtual void Dispose(bool disposing)\r\n        {\r\n            container.Dispose();\r\n        }\r\n    }\r\n}```\r\n\r\nThanks for any help you can provide\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/653/comments",
    "author": "Historyman",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-05-07T15:56:43Z",
        "body": "Arguments are not setup to support DI.  They are designed to use basic DTOs.  So you would need to create a DTO with a parameterless constructor that represents your arguments."
      },
      {
        "user": "Historyman",
        "created_at": "2018-05-07T15:58:53Z",
        "body": "Thats what I suspected, but thanks for the confirmation."
      },
      {
        "user": "joemcbride",
        "created_at": "2018-05-07T16:01:04Z",
        "body": "Argument are just a `Dictionary<string, object>`, so you could write your own mapper if you really like, though having a DTO is a bit easier."
      }
    ]
  },
  {
    "number": 636,
    "title": "[Question] about value objects",
    "created_at": "2018-04-20T20:49:35Z",
    "closed_at": "2018-04-23T21:59:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/636",
    "body": "i have an object with a value object email and i need query the email as string. ¿How can i do this whitout use a DTO class?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/636/comments",
    "author": "miguelcaravantes",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-04-20T21:02:17Z",
        "body": "`ResolveFieldContext.Arguments` is a dictionary with arguments.   Should be able to pull values from there.  If it is multiple levels deep then you would have to do some additional casting to/from `Dictionary<string,object>()`."
      },
      {
        "user": "miguelcaravantes",
        "created_at": "2018-04-20T21:34:50Z",
        "body": "the problem is not pull arguments, the problem is sending values to the client, my email value object is not sended as string"
      },
      {
        "user": "joemcbride",
        "created_at": "2018-04-20T21:37:22Z",
        "body": "Ah - you could create your own scalar type to do that.  To convert it from your value object to a string."
      },
      {
        "user": "joemcbride",
        "created_at": "2018-04-20T21:45:13Z",
        "body": "Something like this:\r\n\r\n```\r\nField<EmailGraphType>(\"email\", resolve: context =>\r\n{\r\n    return new Email{ Value = \"me@me.com\"};\r\n});\r\n\r\n    public class Email\r\n    {\r\n        public string Value { get; set; }\r\n    }\r\n\r\n    public class EmailGraphType : ScalarGraphType\r\n    {\r\n        public override object ParseLiteral(IValue value)\r\n        {\r\n            if(value is StringValue)\r\n            {\r\n                return ParseValue(((StringValue)value).Value);\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        public override object ParseValue(object value)\r\n        {\r\n            if(value is string)\r\n            {\r\n                return new Email { Value = value.ToString() };\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        public override object Serialize(object value)\r\n        {\r\n            return ((Email)value).Value;\r\n        }\r\n    }\r\n```"
      },
      {
        "user": "miguelcaravantes",
        "created_at": "2018-04-23T21:59:37Z",
        "body": "thank you so much!!!"
      }
    ]
  },
  {
    "number": 616,
    "title": "IDependencyResolver obsolete, how do I properly setup schema using .net core 2.0 DI and GraphQL ?",
    "created_at": "2018-04-05T16:10:50Z",
    "closed_at": "2018-06-15T15:57:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/616",
    "body": "I am setting up my  .net core environment to use .net core DI with GraphQL . The sample code (starwars) does this: \r\n\r\nservices.AddSingleton<ISchema>(  s => new StarWarsSchema(new FuncDependencyResolver(type => (IGraphType)s.GetRequiredService(type))));\r\n\r\nHowever, the IDependencyResolver interface is not available in the GraphQL version I am using (latest at this time: 0.17.3) so I can't use that code. Is there any example of how to do this with this latest version of graphQL or should I revert to some previous version instead?. ",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/616/comments",
    "author": "peyoquintero",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-04-05T17:13:45Z",
        "body": "That example is using the 2.0 pre-release which is newer than 0.17.3.  So you can upgrade to the pre-release or use the setup that is required in 0.17.3, which is just removing the `FuncDependencyResolver` type.\r\n\r\n2.x\r\n```\r\nservices.AddSingleton(\r\n  s => new StarWarsSchema(new FuncDependencyResolver(type => (IGraphType)s.GetRequiredService(type))));\r\n```\r\n\r\n0.x\r\n```\r\nservices.AddSingleton( \r\n  s => new StarWarsSchema((type) => (IGraphType)s.GetRequiredService(type)));"
      },
      {
        "user": "peyoquintero",
        "created_at": "2018-04-06T20:54:51Z",
        "body": "Thanks Joe. Is 2.0 pre-release the TypeResolve branch?"
      },
      {
        "user": "joemcbride",
        "created_at": "2018-04-06T21:09:42Z",
        "body": "2.0 is currently the master branch"
      },
      {
        "user": "fiyazbinhasan",
        "created_at": "2018-04-09T13:41:16Z",
        "body": "Hi @joemcbride , what if I configure the default container the following way,\r\n\r\n    services.AddSingleton<StartWarsQuery>();\r\n    services.AddSingleton<ISchema, StarWarsSchema();\r\n\r\nAnd apply constructor injection to pass in the query or mutation,\r\n\r\n    public class StarWarsSchema : Schema \r\n    {\r\n        public StarWarsSchema(StartWarsQuery query)\r\n        {\r\n            Query = query;\r\n        }\r\n    }\r\n\r\nWill it be any different from,\r\n\r\n    services.AddSingleton(s => new StarWarsSchema(new FuncDependencyResolver(type => (IGraphType)s.GetRequiredService(type))));"
      },
      {
        "user": "joemcbride",
        "created_at": "2018-04-09T17:54:40Z",
        "body": "@fiyazbinhasan Yes, if you do not provide a dependency resolver to your Schema then if you attempt to do constructor injection in any other GraphTypes in the graph then it will fail.  By default, if no dependency resolver is provided, it attempts to use `Activator.CreateInstance` to create the graph types."
      },
      {
        "user": "joemcbride",
        "created_at": "2018-08-13T21:56:26Z",
        "body": "Updates related to this in #780."
      }
    ]
  },
  {
    "number": 600,
    "title": "Spliting GraphQL schema into multiple files for better manageability",
    "created_at": "2018-03-15T00:25:41Z",
    "closed_at": "2018-08-11T17:41:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/600",
    "body": "I'm trying to build my graphql server using Handler/Endpoints approach and one problem I'm facing is that my graphql schema is pretty big and maintaining such a big file is becoming an overhead.\r\n\r\nIs there any way I can split it into multiple file and use it in my graphql server?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/600/comments",
    "author": "ravgupms",
    "comments": [
      {
        "user": "KreativJos",
        "created_at": "2018-03-15T09:10:19Z",
        "body": "It is quite easy to split up your root query into multiple sub-queries, like this:\r\n```\r\nquery {\r\n  subRootQuery {\r\n    hero: Droid!\r\n  }\r\n}\r\n```"
      },
      {
        "user": "miguelcaravantes",
        "created_at": "2018-03-20T22:48:22Z",
        "body": " Schema.For supports a string array for definitions string[] typeDefinitions, split your definition in multiple files and read all files on your path and create this string array.\r\n\r\nSomething like this:\r\n\r\n\r\n```\r\nstring[] typeDefinitions =Directory.EnumerateFiles(Path.Combine(_env.ContentRootPath, _options.SchemaDirectory))\r\n                .Select(path => File.ReadAllText(path))\r\n                .ToArray()\r\n\r\nvar schema = Schema.For(typeDefinitions );\r\n```\r\n\r\n\r\n"
      }
    ]
  },
  {
    "number": 546,
    "title": "Question about Dependency Injection",
    "created_at": "2018-02-05T19:43:46Z",
    "closed_at": "2018-08-15T13:59:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/546",
    "body": "I may not be understanding how the dependency injection works in this library.  I've implemented a derived schema that takes in the FuncDependencyResolver.  Does that mean DI will work all the way down the graph?  For example if I have dependencies in the ObjectGraphType constructor, will it inject the needed dependency?  ",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/546/comments",
    "author": "nportelli",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-02-05T20:03:55Z",
        "body": "Yes that is the case.  One note though - at present once a `GraphType` is created it is cached in the Schema.  So those types will \"live\" for the lifetime of the Schema."
      },
      {
        "user": "SimonCropp",
        "created_at": "2018-08-15T12:00:08Z",
        "body": "@nportelli is this answered to your satisfaction? ok if we close?"
      }
    ]
  },
  {
    "number": 494,
    "title": "Best practices for configurable GraphQL.NET implementation with multiple sources of data",
    "created_at": "2017-12-09T20:47:16Z",
    "closed_at": "2020-08-18T23:28:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/494",
    "body": "We are dealing with almost 100 different data types with associated queries, mutations, interfaces, unions, and schemas.  These are organized into different projects that then need to be consolidated into our .NET Core 2.0 GraphQL.NET based data server. Our configurations are based on AutoFac modules and IoC/DI.\r\n\r\nI am wondering if any guidelines or best practices, ideally with examples, have been worked out for larger implementations of GraphQL.NET. Specifically ways of organizing and combining multiple schemas into the final schema at the server level.\r\n\r\nThe examples are very simplistic, which makes sense for learning the basics but leaves a lot of questions as the needs get more complex. Does anyone have a system for taking it further and could you share code examples of how you do it? \r\n\r\nCurrently, our approach involves a lot of hand wiring the schemas together for a final product. This is a lot of work, fragile and doesn't lend itself to easy configuration management. Guidance would be very helpful.\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/494/comments",
    "author": "drobertson123",
    "comments": [
      {
        "user": "jquense",
        "created_at": "2017-12-09T22:03:08Z",
        "body": "Honestly there really isn't a great way to stitch multiple schemas together, it's still a thing people are trying to solve in the GQL community.\r\n\r\nThat said I've done a few large gql schemas and I've found that having a single project for the schema has worked fine even with many types. You can still leverage application structure patterns like having isolated service layers split accross multiple places and handling sticking it all together with DI. In terms of structuring the schema itself I've found the class based approach  with ctor DI better (for my use cases) than the instance based approach for splitting stuff up and handling organization via the filesystem"
      },
      {
        "user": "drobertson123",
        "created_at": "2017-12-10T03:04:07Z",
        "body": "@jquense That is similar to the approach we are using now. We have a GraphQL project that is entirely focused on bringing all the pieces together.\r\n\r\nWe define the Types, Queries, Mutations, etc local to the project that is working with that data and then weave them together into a master Schema in the GraphQL project. ctor DI is our general approach also but I am hoping for some flexibility to use a configuration file to say what goes in and what doesn't. These aren't exclusive of each other but we haven't hit the sweet spot on these issues yet.\r\n\r\nOur outside data sources are less than reliable. We have built in a lot of data redundancy but switching back and forth is still a bit of a challenge. Flexibility is a key issue for us.\r\n\r\nI am hoping that other people who have dealt with larger GraphQL systems could share some ideas and experiences. Even better would be some code examples for ways they have dealt with problems. "
      },
      {
        "user": "alexandercarls",
        "created_at": "2018-10-06T10:23:10Z",
        "body": "Just to provide an alternative solution, although I think that the approach is very similiar.\r\n\r\nI created two marker attributes `QueryAggregate` and `MutationAggregate`. Each \"Sub\"-Schema would need to have this set at the class level.\r\n\r\nFor the container, I have a method like ` .AddGraphQLAggregates<RootQueryAggregate, RootMutationAggregate>();` which takes the Root Schemas (mostly empty classes), looks up in the specified assemblies and finds classes which are annotated with the above-mentioned attributes and stitches them together via reflection.\r\n\r\n@drobertson123 \r\n> I am hoping for some flexibility to use a configuration file to say what goes in and what doesn't. \r\n\r\nCan you give an example of what would be unwanted? Or where the flexibility would lie?\r\n"
      },
      {
        "user": "PayteR",
        "created_at": "2019-05-07T18:50:09Z",
        "body": "@alexandercarls Hi, I'm still a noob in .net, could you explain your solution better?  thx"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-08-18T23:28:20Z",
        "body": "Closing due to lack of activity."
      }
    ]
  },
  {
    "number": 450,
    "title": "Query always returning null?",
    "created_at": "2017-10-06T05:33:11Z",
    "closed_at": "2017-10-07T04:18:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/450",
    "body": "So I've been testing my query out on Postman but I keep getting back null characters.\r\n\r\nWhen I run this query I get back a null character:\r\n```\r\n{\r\n\t\"query\": \"query { character(id: 7) {id name} }\"\r\n}\r\n```\r\n\r\nWhen I run this query I get back a huge list of null characters:\r\n```\r\n{\r\n\t\"query\": \"query { characters {id name} }\"\r\n}\r\n```\r\n\r\nWhen I step through the code I see that the character is there in the resolve function but what I get back is null.\r\nWhat am I doing wrong here?\r\n\r\n```\r\npublic class CharacterType : ObjectGraphType<Character>\r\n{\r\n    public CharacterType()\r\n    {\r\n        Name = \"Character\";\r\n        Field(x => x.Id).Description(\"ID of the Character.\");\r\n        Field(x => x.Name).Description(\"Name of the character.\");\r\n    }\r\n}\r\n```\r\n\r\n```\r\npublic class CharactersQuery : ObjectGraphType\r\n{\r\n\r\n    public CharactersQuery(DbContextOptions dbOptions)\r\n    {\r\n        Name = \"CharactersQuery\";\r\n\r\n        Field<CharacterType>(\r\n            name: \"character\",\r\n            arguments: new QueryArguments(\r\n                new QueryArgument<IdGraphType>\r\n                {\r\n                    Name = \"id\"\r\n                }\r\n            ),\r\n            resolve: ctx =>\r\n            {\r\n                using (var db = new CharactersContext(dbOptions))\r\n                {\r\n                    var character = db.Character.FirstOrDefault(c => c.Id == (int)ctx.Arguments[\"id\"]);\r\n                    return character;\r\n                }\r\n            });\r\n\r\n        Field<ListGraphType<CharacterType>>(\r\n            name: \"characters\",\r\n            resolve: ctx =>\r\n            {\r\n                using (var db = new CharactersContext(dbOptions))\r\n                {\r\n                    return db.Character.ToList();\r\n                }\r\n            });\r\n    }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/450/comments",
    "author": "calvinxli",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2017-10-06T05:45:42Z",
        "body": "Are you getting any errors?  Check the `Errors` property on the `ExecutionResult`.  You can also set `ExposeExceptions` on the `ExecutionOptions` to get a more detailed error in the returned json."
      },
      {
        "user": "calvinxli",
        "created_at": "2017-10-06T06:20:08Z",
        "body": "Errors is set to null. Setting ExposeExceptions to true didn't seem to change anything."
      },
      {
        "user": "joemcbride",
        "created_at": "2017-10-06T06:21:58Z",
        "body": "Can you show the code of how you are using the `DocumentExecutor`/`DocumentWriter`?"
      },
      {
        "user": "pekkah",
        "created_at": "2017-10-06T08:34:55Z",
        "body": "Is the problem in query query?"
      },
      {
        "user": "joemcbride",
        "created_at": "2017-10-06T14:46:05Z",
        "body": "Query looks okay I think, as long as the Schema looks like\r\n\r\n```csharp\r\nvar schema = new Schema { Query = new CharactersQuery() };\r\n```"
      },
      {
        "user": "calvinxli",
        "created_at": "2017-10-07T03:14:20Z",
        "body": "I'm basically just using GraphQLMiddleware.cs:\r\n\r\n```\r\n        private async Task ExecuteAsync(HttpContext context, ISchema schema)\r\n        {\r\n            string body;\r\n            using (var streamReader = new StreamReader(context.Request.Body))\r\n            {\r\n                body = await streamReader.ReadToEndAsync().ConfigureAwait(true);\r\n            }\r\n\r\n            var request = JsonConvert.DeserializeObject<GraphQLRequest>(body);\r\n\r\n            var result = await _executer.ExecuteAsync(_ =>\r\n            {\r\n                _.Schema = schema;\r\n                _.Query = request.Query;\r\n                _.OperationName = request.OperationName;\r\n                _.Inputs = request.Variables.ToInputs();\r\n                _.UserContext = _settings.BuildUserContext?.Invoke(context);\r\n            });\r\n\r\n            await WriteResponseAsync(context.Response, result);\r\n        }\r\n\r\n        private async Task WriteResponseAsync(HttpResponse response, ExecutionResult result)\r\n        {\r\n            var json = _writer.Write(result);\r\n\r\n            response.ContentType = \"application/json\";\r\n            response.StatusCode = result.Errors?.Any() == true ? (int)HttpStatusCode.BadRequest : (int)HttpStatusCode.OK;\r\n\r\n            await response.WriteAsync(json);\r\n        }\r\n```\r\nAnd in my Startup.cs:\r\n```\r\n          services.AddSingleton<IDocumentExecuter, DocumentExecuter>();\r\n            services.AddSingleton<IDocumentWriter, DocumentWriter>();\r\n            services.AddTransient<CharactersQuery>();\r\n            services.AddSingleton<CharactersMutation>();\r\n            services.AddSingleton<ISchema>(\r\n                s => new CharactersSchema(new FuncDependencyResolver(type =>\r\n                    (GraphType)s.GetService(type))));\r\n```"
      },
      {
        "user": "calvinxli",
        "created_at": "2017-10-07T03:15:29Z",
        "body": "Oops I didn't mean to close the issue."
      },
      {
        "user": "calvinxli",
        "created_at": "2017-10-07T04:18:20Z",
        "body": "Not quite sure how but I've got it working again."
      },
      {
        "user": "Willovent",
        "created_at": "2017-10-18T13:08:14Z",
        "body": "I've got this exact issue (returning a list full of null element).  Do you remember any step you've done that can help ?"
      },
      {
        "user": "joemcbride",
        "created_at": "2017-10-18T13:53:33Z",
        "body": "@Willovent if you’re using DI, make sure every type is registered with the container."
      },
      {
        "user": "calvinxli",
        "created_at": "2017-10-18T15:50:15Z",
        "body": "It might've been a DI issue. I think instead of registering my query and schema I registered my query only and constructed the schema manually. I'm not sure if that was the fix though."
      },
      {
        "user": "Willovent",
        "created_at": "2017-10-19T08:12:42Z",
        "body": "@joemcbride You were right about my DI, it missed the registration of my types. It work just fine now, thanks"
      }
    ]
  },
  {
    "number": 449,
    "title": "Using a field in the resolve of another field?",
    "created_at": "2017-10-05T05:08:58Z",
    "closed_at": "2017-10-06T05:47:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/449",
    "body": "Hi,\r\nI would like to know if it's possible to use a field while resolving another field within a given type?\r\nIn the example below, I'd like to resolve for Gender by querying the Gender table for GenderId (which exists in Character), how would I do this?\r\n\r\n```csharp\r\npublic class CharacterType : ObjectGraphType<Character>\r\n{\r\n    public CharacterType(AnimeCharactersContext db)\r\n    {\r\n        Field(x => x.Id).Description(\"Id of the Character.\");\r\n        Field(x => x.GenderId);\r\n        Field(\r\n            type: typeof(ObjectGraphType<Gender>),\r\n            name: \"Gender\",\r\n            description: \"Gender of the character.\",\r\n            resolve: ctx =>\r\n            {\r\n                //return db.Gender.Find(GenderId);\r\n            });\r\n    }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/449/comments",
    "author": "calvinxli",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2017-10-05T05:36:36Z",
        "body": "The `Source` property on the `ResolveFieldContext` has the full object, which in your case should be `Character`.\r\n\r\n```csharp\r\nresolve: ctx =>\r\n{\r\n  return db.Gender.Find(ctx.Source.GenderId);\r\n});\r\n```\r\n\r\n"
      }
    ]
  },
  {
    "number": 328,
    "title": "how to query a relation ",
    "created_at": "2017-05-01T03:37:31Z",
    "closed_at": "2017-05-11T07:46:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/328",
    "body": "Hi,\r\n\r\nassuming I have a query like this\r\n\r\n```javascript\r\nquery {\r\n    typeA {id: 1)\r\n    {\r\n      field1\r\n      field2\r\n      typeB\r\n       {\r\n          idoftypeA\r\n         field3\r\n         field4\r\n        }\r\n    }\r\n```\r\n\r\nTypeB is suptype of TypeA with a field reference _idoftypeA_.\r\n\r\nI define a query like this:\r\n\r\n``` csharp\r\npublic class TypeAQuery : ObjectGraphType\r\n{\r\n   public TypeAQuery()\r\n   {\r\n      Field<ListGraphType<TypeA>>(\"typeA\", arguments:..., resolve: ResolveTypeA);\r\n      Field<ListGraphType<TypeB>>(\"typeB\", resolve: ResolveTypeB); // no arguments here for typeB ?\r\n   }\r\n\r\n   public IEnumerable<TypeA> ResolveTypeA(....)\r\n   {\r\n   }\r\n\r\n   public IEnumerable<TypeB> ResolveTypeB(...)\r\n   {\r\n   }\r\n}\r\n```\r\nAs long as I query only TypeA or TypeA with parameters it works fine. I can access the query arguments and return valid data. But I can't resolve TypeB. How do I know from which TypeA instance it comes for selecting valid data of TypeB with relation to a datarow of TypeA?\r\n\r\nBest regards,\r\nTorsten\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/328/comments",
    "author": "zimmybln",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2017-05-02T18:40:49Z",
        "body": "I'm pretty sure you should be able to check the `Source` property in your resolve method.  `TypeA` should get resolved and passed down to the `TypeB` resolver."
      },
      {
        "user": "zimmybln",
        "created_at": "2017-05-11T07:46:02Z",
        "body": "Hi Joe,\r\n\r\nthanks for your reply. Meanwhile I found it, I should have use the resolver for TypeB in TypeA instead of the resolver within the query type. Everything is fine.\r\n\r\nBest regards,\r\nTorsten"
      }
    ]
  },
  {
    "number": 324,
    "title": "How to split schemas into separate files?",
    "created_at": "2017-04-24T05:19:44Z",
    "closed_at": "2017-04-27T20:05:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/324",
    "body": "How can I separate different fields by topic like soccer, basketball, volleyball into separate files and include them in to the root?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/324/comments",
    "author": "Jonatthu",
    "comments": [
      {
        "user": "Jonatthu",
        "created_at": "2017-04-24T06:08:31Z",
        "body": "Temporal workaround\r\n\r\n```\r\n    public class TyFittQuery : ObjectGraphType\r\n    {\r\n        public TyFittQuery()\r\n        {\r\n\r\n            Name = \"TyFittRoot\";\r\n            Description = \"Welcome to TyFitt API\";\r\n\r\n            new UserQuery(this);\r\n            \r\n        }\r\n    }\r\n```\r\n\r\nAnd\r\n```\r\n\r\n    public class UserQuery\r\n    {\r\n        private TyFittQuery b;\r\n\r\n        public UserQuery(TyFittQuery tyFittQuery)\r\n        {\r\n            this.b = tyFittQuery;\r\n            b.Field<ListGraphType<UserType>>(\r\n                name: \"Users\",\r\n                description: \"A user inside TyFitt\",\r\n                arguments: new QueryArguments(\r\n                    new QueryArgument<IntGraphType> { Name = \"id\", Description = \"id of the user\" }\r\n                ),\r\n                resolve: context =>\r\n                {\r\n                    var list = new List<User>\r\n                    {\r\n                                    new User { Id = 4 }\r\n                    };\r\n                    return list;\r\n                }\r\n            );\r\n        }\r\n    }\r\n```"
      },
      {
        "user": "joemcbride",
        "created_at": "2017-04-24T13:22:52Z",
        "body": "I'm not sure what your scenario is exactly, though I would suggest using an extension method vs. creating that dependency.  I would further suggest to use either traditional inheritance and/or the Union or Interface features of GraphQL."
      },
      {
        "user": "joemcbride",
        "created_at": "2017-04-27T19:43:35Z",
        "body": "Any more on this or can it be closed?"
      },
      {
        "user": "Jonatthu",
        "created_at": "2017-04-27T20:05:09Z",
        "body": "@joemcbride Thanks it is ok 👍 "
      }
    ]
  },
  {
    "number": 322,
    "title": "Subscriptions Example",
    "created_at": "2017-04-21T16:50:28Z",
    "closed_at": "2017-04-27T19:44:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/322",
    "body": "How I can implement subscriptions with this library on the back-end?\r\nIs this going to tell the client when some event happens?\r\nOr this is not ready yet?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/322/comments",
    "author": "Jonatthu",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2017-04-21T16:52:23Z",
        "body": "Please see #186 "
      },
      {
        "user": "Jonatthu",
        "created_at": "2017-04-21T16:55:36Z",
        "body": "@joemcbride Well it seems no example is available yet, but is this in theory working? "
      },
      {
        "user": "joemcbride",
        "created_at": "2017-04-21T16:57:04Z",
        "body": "Yes this should in theory be working."
      },
      {
        "user": "joemcbride",
        "created_at": "2017-04-27T19:44:54Z",
        "body": "Going to go ahead and close this one."
      }
    ]
  },
  {
    "number": 319,
    "title": "Can I auto add certain fields in response even when those ar not requested in query",
    "created_at": "2017-04-12T16:58:29Z",
    "closed_at": "2017-07-07T22:32:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/319",
    "body": "Our API's has Data and Error blocks hence I am looking for a way to auto add Error field in response even when it is not requested by caller. Or even better would be to add it only in case it has data (just like standard errors block in Orchestration response)",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/319/comments",
    "author": "pravinhabbu4u",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2017-04-12T17:35:23Z",
        "body": "No, that is not currently a feature of GraphQL."
      },
      {
        "user": "joemcbride",
        "created_at": "2017-04-12T17:37:43Z",
        "body": "I think perhaps your best bet is to have a \"result\" class that you can add that data to."
      },
      {
        "user": "joemcbride",
        "created_at": "2017-07-07T22:32:39Z",
        "body": "Going to close this, re-open if needed.  Thanks!"
      },
      {
        "user": "minawalphonce",
        "created_at": "2018-11-22T10:11:12Z",
        "body": "I this this is needed\r\nin facebook, they always add Id for example, \r\ni need to add something like totalCount even if it is not requested but paging is requested "
      }
    ]
  },
  {
    "number": 318,
    "title": "Is there a DictionaryGraphType<TKey, TValue>?",
    "created_at": "2017-04-09T21:33:20Z",
    "closed_at": "2017-04-11T23:18:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/318",
    "body": "Awesome library! Works so good for my use cases. Thanks.\r\n\r\nI already have `QueryArgument<ListGraphType<StringGraphType>>` and works great, I wonder if I can pass an argument like the below.\r\n\r\n```\r\nquery FetchData {\r\n  data(dictionaryFieldValues: { address: [ \"address1\", \"address2\" ], state: [ \"states1\", \"states2\" ] }) {\r\n    id,\r\n    name,\r\n    region\r\n  }\r\n}\r\n```\r\n\r\nI believe you can tell that I have a `QueryArgument` of type `Dictionary<string, IEnumerable<string>>`. I understand that I could break them down but I want to use it as generic keys that will change at runtime so I would like to keep it in a `Dictionary` form.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/318/comments",
    "author": "xplatsolutions",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2017-04-10T06:04:01Z",
        "body": "There is not a built-in DictionaryGraphType.  You can create your own input types though.  In general, GraphQL is a very Type specific system.  You can create an input type that matches that signature.  While it may be possible to create a \"Dictionary Graph Type\" I wouldn't really recommend it as that kind of defeats the purpose of GraphQL.\r\n\r\n```csharp\r\n\r\npublic class SearchOptions\r\n{\r\n    public List<string> Address { get; set; }\r\n    public List<string> State { get; set; }\r\n}\r\n\r\npublic class SearchOptionsType : InputObjectGraphType\r\n{\r\n    public SearchOptionsType()\r\n    {\r\n        Description = \"Search criteria\";\r\n        Field<ListGraphType<StringGraphType>>(\"address\");\r\n        Field<ListGraphType<StringGraphType>>(\"state\");\r\n    }\r\n}\r\n\r\npublic class SearchDataType : ObjectGraphType\r\n{\r\n    public SearchDataType()\r\n    {\r\n      Field<ListGraphType<SearchResultType>(\r\n        \"data\",\r\n        arguments: new QueryArguments(new QueryArgument<SearchOptionsType>(\"options\")),\r\n        resolve: context =>\r\n        {\r\n            // this is now your strongly-typed DTO (not a GraphQL type)\r\n            var options = context.GetArgument<SearchOptions>(\"options\");\r\n            return Database.Search(options);\r\n        }\r\n      );\r\n    }\r\n}\r\n```"
      },
      {
        "user": "jquense",
        "created_at": "2017-04-10T12:27:04Z",
        "body": "I do wish there was gql support for typed maps. someone should submit an RFC :P"
      },
      {
        "user": "xplatsolutions",
        "created_at": "2017-04-10T17:20:03Z",
        "body": "Hmmm, I get what you mean and thank you for the example. \n\nI need this to be agnostic so at the moment I will just work it out using a different endpoint and just pass the results through GraphQL to filter response."
      }
    ]
  },
  {
    "number": 297,
    "title": "Exceptions for many fragments",
    "created_at": "2017-03-14T03:00:55Z",
    "closed_at": "2017-03-21T01:02:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/297",
    "body": "Does graphql support to show the errors per fragement? Can we provide some extension or injection on error handling?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/297/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2017-03-16T07:17:19Z",
        "body": "* the line/column should be provided in the error for the fragment so you can trace it back to a resolver\r\n* you can add your own try/catch in your field resolve functions\r\n* you can log or debug and check the inner exceptions for specific exceptions\r\n\r\nPossibly related?  #279 "
      },
      {
        "user": "ghost",
        "created_at": "2017-03-21T01:02:14Z",
        "body": "Thanks for your feedback. It's very helpful for us."
      }
    ]
  },
  {
    "number": 293,
    "title": "Arguments need implementation using lync?",
    "created_at": "2017-03-09T04:04:52Z",
    "closed_at": "2017-03-30T04:32:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/293",
    "body": "Arguments like human(id: \"1000\") need implementation using lync to fetch human by id? I was under the impression GraphQL gets the correct result without need for backend implementation similar to fields selection which uses NewtonSoft inside.\r\n\r\nPlease clarify.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/293/comments",
    "author": "psavanur",
    "comments": [
      {
        "user": "jquense",
        "created_at": "2017-03-09T18:05:35Z",
        "body": "nit sure what this means... \r\n\r\nGraphql is a way to query data but you still need a backend to provide that data. your arguments can be whatever you want/need"
      },
      {
        "user": "psavanur",
        "created_at": "2017-03-13T10:34:27Z",
        "body": "Yes I want to know if filtered data need to be supplied by us or GraphQL gets it by applying its own query mechanism."
      },
      {
        "user": "joemcbride",
        "created_at": "2017-03-16T07:20:55Z",
        "body": "Filtered data (as in the list of objects that GraphQL will extract fields from) needs to be supplied by you the developer.  For instance, if you have a list of people and you want to only return those who are older than 65 of age, then you the developer needs to do that filtering."
      },
      {
        "user": "jquense",
        "created_at": "2017-03-16T14:26:01Z",
        "body": "yeah GQL doesn't provide any sort of pagination, sorting, or filtering built-in. Instead lets you add arguments you can use to do those things, very similarly (and annoyingly) like REST. Things like Relay.js help a bit, because they add some conventions on top of your graphql schema so that the client (most of relay) can do smart paging."
      }
    ]
  },
  {
    "number": 288,
    "title": "Using a schema from another server",
    "created_at": "2017-03-01T22:09:27Z",
    "closed_at": "2017-03-01T22:15:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/288",
    "body": "Sorry for the question...\r\n\r\nWe're thinking of using DocumentValidator to check/validate queries against a schema in another server. The idea is to query the 3rd party server for their schema, populate an ISchema object, and then use it to validate queries using DocumentValidator.\r\n\r\nDo you already have something to load/convert a __schema response into an ISchema which can be used to validate queries?\r\nDo you know of another way to validate a query against the schema of another graphql server? (like what Graphi does, but in C#)\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/288/comments",
    "author": "ManuelDeLeon",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2017-03-01T22:13:46Z",
        "body": ">Do you already have something to load/convert a __schema response into an ISchema which can be used to validate queries?\r\n\r\nNot currently, no.\r\n\r\n>Do you know of another way to validate a query against the schema of another graphql server? (like what Graphi does, but in C#)\r\n\r\nWhat you propose is the only way I can think of at this moment."
      },
      {
        "user": "ManuelDeLeon",
        "created_at": "2017-03-01T22:15:20Z",
        "body": "Oh well. Thanks anyway =)"
      },
      {
        "user": "joemcbride",
        "created_at": "2017-03-01T22:15:40Z",
        "body": "One thing of note.  A separate GraphQL server may have its own custom validation rules.  So you could run the _default_ rules, but the only way to know if its truly valid would be to send it to the other server."
      }
    ]
  },
  {
    "number": 287,
    "title": "Need Advice - Passing Headers received on request to resolver method",
    "created_at": "2017-03-01T19:50:09Z",
    "closed_at": "2017-03-01T20:10:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/287",
    "body": "@joemcbride I am trying to capture the headers received on /graphql request and then make them available in resolve methods so that this information can be used for passing to next API calls made by graphql server for resolving fields.\r\n\r\nBased on my understanding I am planning capture headers in Middleware and then pass it to the request using _.UserContext method:\r\n```\r\n            return await new DocumentExecuter().ExecuteAsync(_ =>\r\n            {\r\n                _.Schema = schema;\r\n                _.Query = graphqlRequest.Query;\r\n                _.Inputs = inputs;\r\n                _.OperationName = graphqlRequest.OperationName;\r\n                _.UserContext = request.Headers;\r\n                _.FieldNameConverter = new DefaultFieldNameConverter();\r\n                \r\n            }).ConfigureAwait(false);\r\n```\r\n\r\nThis becomes available in query / root field. However, how can I access these in resolver method built by me. Do I need to pass a reference or context is supposed to be auto available there:\r\n\r\n```\r\n\tField<TestAPIReturnType>( \"TestAPI\",\r\n\t\targuments: new  QueryArguments(new QueryArgument<NonNullGraphType<StringGraphType>> { Name = \"id\"}),\r\n\t\t\t\tresolve: context => {\r\n                                      var Headers = context.UserContext;\r\n\t\t\t\t\tstring __id =  context.GetArgument<string>(\"IdentityID\");\r\n\t\t\t\t\tif(String.IsNullOrWhiteSpace(__id)){return null;}\r\n\t\t\t\t\treturn TestAPIResolver.GetSingle_Resolver(__id);\r\n\t\t\t\t}\r\n\t\t\t);\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/287/comments",
    "author": "pravinhabbu4u",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2017-03-01T19:56:26Z",
        "body": "You have it right.  `context.UserContext` in resolvers will be populated with the value assigned to `_.UserContext`.\r\n\r\nI would suggest to create a class so you can add other information later if needed, and you won't have to go back and edit everything.\r\n\r\n```csharp\r\npublic class GraphQLUserContext\r\n{\r\n    public IHeaderDictionary Headers { get; set; }\r\n}\r\n\r\n_.UserContext = new GraphQLUserContext { Headers = request.Headers };\r\n```"
      },
      {
        "user": "pravinhabbu4u",
        "created_at": "2017-03-01T20:10:24Z",
        "body": "@joemcbride That sounds cool. Thanks!"
      },
      {
        "user": "pravinhabbu4u",
        "created_at": "2017-03-02T21:32:51Z",
        "body": "I actually ended up using new user context to share config entries and also to share unique GraphQL request identifier that can be tagged on all API calls made under a single request."
      },
      {
        "user": "santoshpatro",
        "created_at": "2018-11-07T18:38:43Z",
        "body": "Hi Joe/Pravinhabbu4u,\r\n\r\nI have the same requirement as mentioned  in this question. After reading your suggestions, I created a class: GraphQLUserContext as mentioned by you and registered in the ConfigureServices method in the Startup.cs class.I see that even the UserContext is set with the headers in the GraphQLController but on using it in the TestQuery class, resolve method it is still returning null and leading to error. In short I am not getting the headers in the TestQuery class resolve method.\r\n\r\nCan you please help me how to fix this issue. \r\n\r\nOne more small request like in my current project where I am using Graphql.NET to create the new endpoints, I have to always pass the locale data by reading the incoming request headers to the business logic via the resolve methods. Since this is going to be repeated in almost every resolve method can you please guide me how to encapsulate it in one centralized place and implement it instead of repeating the duplicating the code in every resolve method.\r\n\r\nAny help on this is much appreciated.\r\n\r\n```\r\n// Utilties\r\npublic interface IGraphQLUserContext\r\n{\r\n\tIHeaderDictionary Headers\r\n\t{\r\n\t\tget;\r\n\t\tset;\r\n\t}\r\n//string GetCookieId();\r\n}\r\n\r\npublic class GraphQLUserContext : IGraphQLUserContext\r\n{\r\n\tpublic IHeaderDictionary Headers\r\n\t{\r\n\t\tget;\r\n\t\tset;\r\n\t}\r\n}\r\n\r\n// GraphQLController\r\n[HttpPost]\r\npublic async Task<IActionResult> Post([FromBody] GraphQLQuery query)\r\n{\r\n\tif (query == null)\r\n\t{\r\n\t\tthrow new ArgumentNullException(nameof(query));\r\n\t}\r\n\r\n\tvar inputs = query.Variables.ToInputs();\r\n\tvar executionOptions = new ExecutionOptions{Schema = _schema, Query = query.Query, Inputs = inputs, UserContext = new GraphQLUserContext{Headers = Request.Headers}};\r\n\tvar result = await _documentExecuter.ExecuteAsync(executionOptions).ConfigureAwait(false);\r\n\tif (result.Errors?.Count > 0)\r\n\t{\r\n\t\treturn BadRequest(result);\r\n\t}\r\n\r\n\treturn Ok(result);\r\n}\r\n\r\n// Startup.cs\r\npublic class Startup\r\n{\r\n\tpublic Startup(IConfiguration configuration)\r\n\t{\r\n\t\tConfiguration = configuration;\r\n\t}\r\n\r\n\tpublic IConfiguration Configuration\r\n\t{\r\n\t\tget;\r\n\t}\r\n\r\n\t// This method gets called by the runtime. Use this method to add services to the container.\r\n\tpublic void ConfigureServices(IServiceCollection services)\r\n\t{\r\n\t\tservices.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);\r\n\t\tservices.AddScoped(provider =>\r\n\t\t{\r\n\t\t\tvar connectionString = Configuration.GetConnectionString(\"TestDb\");\r\n\t\t\treturn new CMSDbContext(connectionString);\r\n\t\t}\r\n\r\n\t\t);\r\n\t\tservices.AddSingleton<IGraphQLUserContext, GraphQLUserContext>();\r\n\t\tservices.AddSingleton<ITestService, TestService>();\r\n\t\tservices.AddSingleton<IDocumentExecuter, DocumentExecuter>();\r\n\t\tservices.AddSingleton<TestSchema>();\r\n\t\tvar sp = services.BuildServiceProvider();\r\n\t\tservices.AddSingleton<ISchema>(new TestSchema(new FuncDependencyResolver(type => sp.GetService(type))));\r\n\t}\r\n\r\n\t// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\r\n\tpublic void Configure(IApplicationBuilder app, IHostingEnvironment env)\r\n\t{\r\n\t\tif (env.IsDevelopment())\r\n\t\t{\r\n\t\t\tapp.UseDeveloperExceptionPage();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tapp.UseHsts();\r\n\t\t}\r\n\r\n\t\tapp.UseGraphiQl();\r\n\t\tapp.UseHttpsRedirection();\r\n\t\tapp.UseMvc();\r\n\t}\r\n}\r\n\r\n// TestQuery\r\npublic class TestQuery : ObjectGraphType<object>\r\n{\r\n\tpublic TestQuery(ITestService testService, IGraphQLUserContext graphUserContext)\r\n\t{\r\n\t\tField<TestResultType>(\"result\", resolve: context =>\r\n\t\t{\r\n\t\t\tvar headers = graphQLUserContext.Headers;\r\n\t\t\t// Process headers to get the locale\r\n\t\t\treturn testService.GetDetailsForLocation(locale);\r\n\t\t}\r\n\r\n\t\t, description: \"Location details data\");\r\n\t}\r\n}\r\n```\r\n\r\n"
      }
    ]
  },
  {
    "number": 202,
    "title": "Any way to debug schema builder?",
    "created_at": "2016-10-29T01:15:10Z",
    "closed_at": "2016-11-28T18:21:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/202",
    "body": "How can I debug my schema building process? I'm working on very huge and complicated schema with a lot of connections and union types and many times received exception such as: \"Exception has been thrown by the target of an invocation\". How can I know what exactly going wrong?\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/202/comments",
    "author": "alerdenisov",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2016-10-29T01:26:15Z",
        "body": "I am currently adding some instrumentation code, though you won't be able to use that yet.\n\nHave you checked for any inner exceptions in debug mode?  That sounds like some null references or something like that.\n"
      },
      {
        "user": "alerdenisov",
        "created_at": "2016-10-29T01:45:46Z",
        "body": "I'm found \"way\" to debug. I just use DocumentValidator.Validate at begin of initializing my controller and throw Exception if document isn't valid. Work okay for me. \n\nBut.. Let's return to DEBUG environment? If I'm throwing serialized exception I got detailed info (with InnerException), but as Response I just having message field. I guess, is it problem on my side?\n"
      },
      {
        "user": "joemcbride",
        "created_at": "2016-10-29T02:32:39Z",
        "body": "The DocumentExecuter runs the DocumentValidator and does not execute if it is invalid.\n\nAre you running into parse exceptions parsing a Query or errors trying to resolve a field?\n\nThe ExecutionResult has a list of exceptions that should have full stack traces.  Those stacktraces are not shown when serialized to JSON.\n"
      },
      {
        "user": "joemcbride",
        "created_at": "2016-11-28T18:21:29Z",
        "body": "Going to close this, let me know if you have further questions."
      }
    ]
  },
  {
    "number": 81,
    "title": "Using GraphQLAbstractType as schema objects",
    "created_at": "2016-05-26T18:18:29Z",
    "closed_at": "2016-06-03T15:10:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/81",
    "body": "Hello,\n\nI've implemented a graphql object in the following way -\n\n`class DynamicTemplateType : GraphQLAbstractType`\n\nThis seems to work well for most purposes, and returns a dynamically resolved type through the use of the `GetObjectType` method on `GraphQLAbstractType`. I encounter a problem when using introspection however, as the `__Type` object is unable to resolve it's `TypeKind`. The code which determines this is as follows:\n\n```\npublic TypeKind KindForInstance(GraphType type)\n{\n    if (type is EnumerationGraphType)\n    {\n        return TypeKind.ENUM;\n    }\n    if (type is ScalarGraphType)\n    {\n        return TypeKind.SCALAR;\n    }\n    if (type is ObjectGraphType)\n    {\n        return TypeKind.OBJECT;\n    }\n    if (type is InterfaceGraphType)\n    {\n        return TypeKind.INTERFACE;\n    }\n    if (type is UnionGraphType)\n    {\n        return TypeKind.UNION;\n    }\n    if (type is InputObjectGraphType)\n    {\n        return TypeKind.INPUT_OBJECT;\n    }\n    if (type is ListGraphType)\n    {\n        return TypeKind.LIST;\n    }\n    if (type is NonNullGraphType)\n    {\n        return TypeKind.NON_NULL;\n    }\n\n    throw new ExecutionError(\"Unkown kind of type: {0}\".ToFormat(type));\n}\n```\n\nNote the lack of a comparison for `GraphQLAbstractType`. Was this an oversight, or is it intentional and I'm not meant to be using this type like this?\n\nCheers\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/81/comments",
    "author": "aaerox",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2016-05-26T21:04:40Z",
        "body": "That is intentional.  You should be able to use `UnionGraphType` or `InterfaceGraphType` for dynamic types.\n"
      },
      {
        "user": "joemcbride",
        "created_at": "2016-06-03T15:10:30Z",
        "body": "Going to close this, let me know if you have any other issues or questions.\n"
      }
    ]
  },
  {
    "number": 280,
    "title": "Are DocumentExecuter and ComplexityAnalyzer supposed to be thread-safe?",
    "created_at": "2017-02-20T16:54:10Z",
    "closed_at": "2018-08-02T05:10:55Z",
    "labels": [
      "enhancement",
      "help wanted"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/280",
    "body": "Hi,\r\n\r\nI'm wondering whether `DocumentExecuter` and `ComplexityAnalyzer` are supposed to be thread-safe? Or whether they are intended to be used one-off per request?\r\n\r\nThe `ComplexityAnalyzer` isn't thread-safe right now as it uses the field `_result` (which is replaced per request) to store data during execution/analysis (without any sync locks anywhere). In a multi-threaded environment this will lead to race-conditions (which I've been experiencing in my application).\r\n\r\nIf they aren't intended to be thread-safe I'll simply alter my code, but if it's a bug I thought I'd report it!\r\n\r\nThanks, great work! (:",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/280/comments",
    "author": "niklaskallander",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2017-02-21T17:12:02Z",
        "body": "Thanks for the report!  `DocumentExecuter` should be thread safe, so looks like we need to update the `ComplexityAnalyzer` to be so as well."
      },
      {
        "user": "joemcbride",
        "created_at": "2018-08-02T05:10:55Z",
        "body": "This should be fixed in #707 (Thanks @bittercoder!)"
      }
    ]
  },
  {
    "number": 49,
    "title": "Asp.net 5 Core",
    "created_at": "2016-02-25T13:30:21Z",
    "closed_at": "2016-03-07T16:07:50Z",
    "labels": [
      "enhancement",
      "help wanted"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/49",
    "body": "Would be nice to have a port for .net 5 Core.\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/49/comments",
    "author": "we4sz",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2016-02-25T23:27:01Z",
        "body": "Is this not the same as #43 ?\n"
      },
      {
        "user": "we4sz",
        "created_at": "2016-03-07T16:07:50Z",
        "body": "Yes indeed!\n"
      }
    ]
  }
]