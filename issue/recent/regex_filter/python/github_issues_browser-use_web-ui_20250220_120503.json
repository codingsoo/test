[
  {
    "number": 298,
    "title": "error: File not found: `requirements.txt`",
    "created_at": "2025-02-15T07:46:25Z",
    "closed_at": "2025-02-16T07:13:30Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/298",
    "body": "Stuck on 3rd step it can not find the requirements file",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/298/comments",
    "author": "Kaykode",
    "comments": [
      {
        "user": "marginal23326",
        "created_at": "2025-02-15T09:34:03Z",
        "body": "> Stuck on 3rd step it can not find the requirements file\n\nIs your terminal on the `web-ui` directory? Make sure you are not running the commands from a different directory. Also quickly check if there is a `requirements.txt` file inside the `web-ui` directory. It should be there if the cloning was successful."
      },
      {
        "user": "Kaykode",
        "created_at": "2025-02-16T07:13:30Z",
        "body": "Hey Thanks, it worked i skipped the cd web_ui step "
      }
    ]
  },
  {
    "number": 287,
    "title": "Feat/qwen support",
    "created_at": "2025-02-13T12:10:49Z",
    "closed_at": "2025-02-14T11:00:21Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/287",
    "body": null,
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/287/comments",
    "author": "maquannene",
    "comments": [
      {
        "user": "rahcom",
        "created_at": "2025-02-15T18:17:33Z",
        "body": "Error code 404"
      }
    ]
  },
  {
    "number": 278,
    "title": "feat: Enhance error handling and reporting in deep research module",
    "created_at": "2025-02-12T08:37:39Z",
    "closed_at": "2025-02-12T14:40:25Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/278",
    "body": "# Additional Information\r\n In my experiences, I've encountered rate limits from the AI provider or `context too long` errors after running `deep_research` for an extended period, resulting in the loss of all `research` work. I believe it would be an acceptable solution to generate a partial report when an error occurs.\r\n\r\n# Implementation\r\n- Refactored deep research process to separate report generation logic\r\n- Added error handling to generate partial reports when research is interrupted\r\n- Implemented error notification in generated markdown reports\r\n- Improved logging and error tracking during research process",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/278/comments",
    "author": "hoangnb24",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-02-12T14:40:22Z",
        "body": "LGTM"
      }
    ]
  },
  {
    "number": 215,
    "title": "How do you delete recordings?",
    "created_at": "2025-02-01T03:13:38Z",
    "closed_at": "2025-02-01T03:36:33Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/215",
    "body": "I don't see how to delete recordings. I am using it in Docker.",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/215/comments",
    "author": "kingfish65",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-02-01T03:17:04Z",
        "body": "> I don't see how to delete recordings. I am using it in Docker.\n\nNo such feature"
      },
      {
        "user": "kingfish65",
        "created_at": "2025-02-01T03:36:12Z",
        "body": "Thanks for the quick response. That now makes sense why I couldn't find it. For now I can manually go into the container and delete them from /app/tmp/record_videos."
      }
    ]
  },
  {
    "number": 214,
    "title": "refactor: use modern typing syntax",
    "created_at": "2025-02-01T01:02:00Z",
    "closed_at": "2025-02-01T02:32:49Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/214",
    "body": "Since this repo uses Python 3.11+, I updated the typing annotations to use the cleaner built-in generics like `list[str]`, `dict[str, Any]`, and `type[Something]` instead of the old `List[]`, `Dict[]`, and `Type[]`. Also replaced `Optional[]` with `| None` for better readability. As part of this, I removed most of the `typing` imports that were no longer needed after the change. Also removed redundant exception variables where they werenâ€™t needed.",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/214/comments",
    "author": "marginal23326",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-02-01T02:27:31Z",
        "body": "I think this refactoring is not particularly necessary at present. This format follows the official browser usage.\r\n"
      },
      {
        "user": "marginal23326",
        "created_at": "2025-02-01T02:29:51Z",
        "body": "got it. I will close the PR, then."
      }
    ]
  },
  {
    "number": 213,
    "title": "Fresh install error when running webui - ImportError lxml.html.clean",
    "created_at": "2025-01-31T21:15:47Z",
    "closed_at": "2025-02-01T02:24:30Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/213",
    "body": "Received this error after following install instructions:\n```\n\nImportError: lxml.html.clean module is now a separate project lxml_html_clean.\nInstall lxml[html_clean] or lxml_html_clean directly.\n```\n\nThis may have to be added as an additional requirement to requirements.txt.",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/213/comments",
    "author": "teddybear082",
    "comments": [
      {
        "user": "marginal23326",
        "created_at": "2025-02-01T00:21:12Z",
        "body": "This likely happened because **lxml** or another dependency was installed in an outdated version. Try reinstalling **browser-use** with:\n\n```bash\nuv pip install browser-use -U\n```  \n\nAlso, ensure you're using **Python 3.11+**, as older versions may install outdated dependencies."
      },
      {
        "user": "teddybear082",
        "created_at": "2025-02-01T02:24:30Z",
        "body": "I never had browser use (or browser use webui) installed before, this was my first install.  I believe I have python 3.11.7.  I was using a virtual environment (with venv) for install.  That said obviously I just installed the dependency as per the warning message and everything works fine but just wanted to report this.  Iâ€™ll close the issue."
      }
    ]
  },
  {
    "number": 209,
    "title": "ImportError: cannot import name 'AgentStepTelemetryEvent' from 'browser_use.telemetry.views'",
    "created_at": "2025-01-30T17:45:51Z",
    "closed_at": "2025-02-12T23:10:49Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/209",
    "body": "I am having importError when running python webui.py --ip 127.0.0.1 --port 7788\n```\nImportError: cannot import name 'AgentStepTelemetryEvent' from 'browser_use.telemetry.views' \nDid you mean: 'AgentEndTelemetryEvent'?\n\n```\nPC: windows 11\npython v- 3.12.8\n",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/209/comments",
    "author": "santosrai",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-31T00:51:28Z",
        "body": "update browser-use=0.1.29"
      },
      {
        "user": "santosrai",
        "created_at": "2025-02-12T23:10:33Z",
        "body": "Thank you. Update helped."
      }
    ]
  },
  {
    "number": 163,
    "title": "error when running with deepseek API",
    "created_at": "2025-01-26T11:22:11Z",
    "closed_at": "2025-01-27T01:15:19Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/163",
    "body": "Here is the message received when trying to use deepseek_r1 model\n```\n\nðŸ“ Step 1\nERROR    [agent] âŒ Result failed 1/5 times:\n Failed to deserialize the JSON body into the target type: messages[1]: data did not match any variant of untagged enum ChatCompletionRequestContent at line 1 column 18231\nINFO     [src.agent.custom_agent] \nðŸ“ Step \n```1\n\n",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/163/comments",
    "author": "marcNY",
    "comments": [
      {
        "user": "AlexAtmtit",
        "created_at": "2025-01-26T13:35:23Z",
        "body": "The same here, always receive this message with DeepSeek R1:\n`['Failed to deserialize the JSON body into the target type: messages[1]: data did not match any variant of untagged enum ChatCompletionRequestContent at line 1 column 20447', 'Failed to deserialize the JSON body into the target type: messages[1]: data did not match any variant of untagged enum ChatCompletionRequestContent at line 1 column 20447', 'Failed to deserialize the JSON body into the target type: messages[1]: data did not match any variant of untagged enum ChatCompletionRequestContent at line 1 column 20447', 'Failed to deserialize the JSON body into the target type: messages[1]: data did not match any variant of untagged enum ChatCompletionRequestContent at line 1 column 20447', 'Failed to deserialize the JSON body into the target type: messages[1]: data did not match any variant of untagged enum ChatCompletionRequestContent at line 1 column 20447']`"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-26T13:36:45Z",
        "body": "uncheck use visionï¼"
      },
      {
        "user": "AlexAtmtit",
        "created_at": "2025-01-26T13:57:38Z",
        "body": "> uncheck use visionï¼\n\nIt worked, thanks!"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-27T01:15:19Z",
        "body": "OK"
      }
    ]
  },
  {
    "number": 162,
    "title": "Donâ€™t know to to run on web",
    "created_at": "2025-01-26T05:24:43Z",
    "closed_at": "2025-02-02T22:58:11Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/162",
    "body": "Web ",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/162/comments",
    "author": "27bchaos",
    "comments": [
      {
        "user": "Vivek7038",
        "created_at": "2025-01-26T14:48:35Z",
        "body": "follow the readme file instructions "
      },
      {
        "user": "27bchaos",
        "created_at": "2025-01-26T15:06:21Z",
        "body": "> follow the readme file instructions\n\nI did "
      }
    ]
  },
  {
    "number": 142,
    "title": "model \"qwen2.5:7b\" not found",
    "created_at": "2025-01-24T12:13:20Z",
    "closed_at": "2025-01-24T14:28:09Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/142",
    "body": "Hi,\n\nI don't know why it's giving me this error:\nI downloaded the model with ollama, Is there any way to configure the model path or something?\n\n```\nðŸ“ Step 1\nERROR    [agent] âŒ Result failed 1/5 times:\n model \"qwen2.5:7b\" not found, try pulling it first (status code: 404)\nINFO     [src.agent.custom_agent]\nðŸ“ Step 1\nERROR    [agent] âŒ Result failed 2/5 times:\n model \"qwen2.5:7b\" not found, try pulling it first (status code: 404)\nINFO     [src.agent.custom_agent]\nðŸ“ Step 1\nERROR    [agent] âŒ Result failed 3/5 times:\n model \"qwen2.5:7b\" not found, try pulling it first (status code: 404)\nINFO     [src.agent.custom_agent]\nðŸ“ Step 1\nERROR    [agent] âŒ Result failed 4/5 times:\n model \"qwen2.5:7b\" not found, try pulling it first (status code: 404)\nINFO     [src.agent.custom_agent]\nðŸ“ Step 1\nERROR    [agent] âŒ Result failed 5/5 times:\n model \"qwen2.5:7b\" not found, try pulling it first (status code: 404)\nERROR    [agent] âŒ Stopping due to 5 consecutive failures\nINFO     [src.agent.custom_agent] Created GIF at agent_history.gif\n```",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/142/comments",
    "author": "imonedesign",
    "comments": [
      {
        "user": "vvincent1234",
        "created_at": "2025-01-24T14:00:09Z",
        "body": "update the latest codeï¼Œuncheck Use Tool Calls in Content and Use vision, setting Max Actions per Step=1. That works for me to use qwen2.5:7b, but the result is poor, try bigger model"
      },
      {
        "user": "imonedesign",
        "created_at": "2025-01-24T14:28:05Z",
        "body": "Sorry, I needed to use the custom model name I downloaded, which is \"deepseek-r1:14b\""
      },
      {
        "user": "sungmin-fdai",
        "created_at": "2025-01-24T17:36:54Z",
        "body": "> Sorry, I needed to use the custom model name I downloaded, which is \"deepseek-r1:14b\"\n\nDid you get it to work? I typed in the model name manually but doesn't work. qwen2.5:7b works so I am guessing the issue must be specific to deepseek-r1:14b."
      },
      {
        "user": "imonedesign",
        "created_at": "2025-01-24T17:44:24Z",
        "body": "> > Sorry, I needed to use the custom model name I downloaded, which is \"deepseek-r1:14b\"\n> \n> Did you get it to work? I typed in the model name manually but doesn't work. qwen2.5:7b works so I am guessing the issue must be specific to deepseek-r1:14b.\n\nIt turns out 'deepseek-r1:14b' is probably too much for my machine, it took forever in the first step. So, I switched to 'qwen2.5:7b.' It's not the best, but it works. Now, Iâ€™m experimenting with Gemini and OpenAI APIs, and the results are amazing and fast!"
      }
    ]
  },
  {
    "number": 120,
    "title": "No save button",
    "created_at": "2025-01-16T12:59:16Z",
    "closed_at": "2025-01-23T11:13:50Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/120",
    "body": "Allow saving current setting could be convenient.",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/120/comments",
    "author": "raydebug",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-16T13:24:40Z",
        "body": "I will consider it, but it might not be a priority at the moment. Or anyone want to take this PR,? let me know"
      }
    ]
  },
  {
    "number": 119,
    "title": "Browser communication issue",
    "created_at": "2025-01-16T12:55:47Z",
    "closed_at": "2025-01-17T03:55:15Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/119",
    "body": "browser is opened successfully while spinning on waiting for response, either chromnium or chrome",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/119/comments",
    "author": "raydebug",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-16T13:24:00Z",
        "body": "More infos please"
      },
      {
        "user": "raydebug",
        "created_at": "2025-01-17T03:55:15Z",
        "body": "sorry my fault, just because my Mac mini too slow, pls close this"
      }
    ]
  },
  {
    "number": 96,
    "title": "Stop Button Fix PR v2",
    "created_at": "2025-01-12T13:39:10Z",
    "closed_at": "2025-01-12T15:42:51Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/96",
    "body": "Fixed the stop button. Noted previous comments. It was easier to create a new PR.  Please, check ",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/96/comments",
    "author": "InCoB",
    "comments": [
      {
        "user": "InCoB",
        "created_at": "2025-01-12T14:16:38Z",
        "body": "BTW. Do you have any plans to think about modularity for the ease of contributing? I see that people are currently actively contributing. My plan is to 1) implement state and stop functionality (done), 2) idle mode (I see the kept browser is implemented, and 3) continuous instructions mode (i.e., the bot can finalise and drop what it does and switch to a new instruction while having all memories 4. Voice commands (chat function - with at least commands from the operator). 5. Second AI agent that provides commands to the first AI agent and controls it to achieve fully autonomous operation.  "
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-12T15:07:20Z",
        "body": "> BTW. Do you have any plans to think about modularity for the ease of contributing? I see that people are currently actively contributing. My plan is to 1) implement state and stop functionality (done), 2) idle mode (I see the kept browser is implemented, and 3) continuous instructions mode (i.e., the bot can finalise and drop what it does and switch to a new instruction while having all memories 4. Voice commands (chat function - with at least commands from the operator). 5. Second AI agent that provides commands to the first AI agent and controls it to achieve fully autonomous operation.\r\n\r\nGood suggestions. 3.4.5 are all I want to do, you can tell me which one do you prefer and plan to PR, I am so welcome.  Yeah, I will think about modularity for the ease of contributing, also post a PR rules soon"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-12T15:13:34Z",
        "body": "Do you have a discord, we can communicate directly"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-12T15:21:35Z",
        "body": "I can not pull your PR"
      },
      {
        "user": "InCoB",
        "created_at": "2025-01-12T15:22:59Z",
        "body": "what's the problem? P.S. I think I found myself\r\n"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-12T15:24:35Z",
        "body": "gh pr checkout 96\r\nFrom github.com:browser-use/web-ui\r\n ! [rejected]        refs/pull/96/head -> activation-of-stop-button-and-cache  (non-fast-forward)\r\nfailed to run git: exit status 1\r\n\r\nAny idea? It is OK when pulling other PRs"
      },
      {
        "user": "InCoB",
        "created_at": "2025-01-12T15:33:20Z",
        "body": "It worked in my copy. Hmm. Let me Try to create another one.  I think the problem might be with the branch and the way I deleted previous commits. "
      }
    ]
  },
  {
    "number": 91,
    "title": "The \"Stop\" button does not work at al",
    "created_at": "2025-01-11T22:15:57Z",
    "closed_at": "2025-01-13T14:05:07Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/91",
    "body": "In all my tests if I was pressing the Stop button nothing happened.\r\n\r\nUsing both Windows 11 and macOs 15.2",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/91/comments",
    "author": "stavarc",
    "comments": [
      {
        "user": "vvincent1234",
        "created_at": "2025-01-12T00:34:32Z",
        "body": "Still in PR, stay tuned!"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-12T15:55:35Z",
        "body": "Merged now, please update code and take a try."
      },
      {
        "user": "Volko61",
        "created_at": "2025-01-27T09:23:18Z",
        "body": "Still doesn't work for me ðŸ˜¥\nI'm stuck here : lla ice cream.\nVous avez terminÃ© le module, Module A\nVous avez terminÃ© le module, Module B\nModule maÃ®tre, SÃ©lectionnez un chapitre ci-dessous, 1 : Chapitre 1\nModule maÃ®tre > Chapitre 1, Test des redirections, L'Ã©tape suivante est une Ã©tape simple, Cette Ã©tape ne contient pas de mÃ©dia\n\nINFO     [controller] ðŸ–±ï¸  Clicked index 6\nINFO     [src.agent.custom_agent]\nðŸ“ Step 33\n"
      }
    ]
  },
  {
    "number": 85,
    "title": "Activation of stop button",
    "created_at": "2025-01-11T12:13:22Z",
    "closed_at": "2025-01-12T13:30:44Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/85",
    "body": "The Stop Button did not work for me, so I had to fix it.  Now, the button stops the agent. Additionally, I added the function to clean cache ",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/85/comments",
    "author": "InCoB",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-11T12:40:41Z",
        "body": "Good. I will review soon."
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-11T14:31:52Z",
        "body": "Hi, a fix of using own browser have to merge first. So please help to fix conflicts. Beside, cleanup_all button is kind of danger, please remove it in this PR."
      },
      {
        "user": "InCoB",
        "created_at": "2025-01-11T16:44:10Z",
        "body": "Please check, I removed clean cache. I used it, but maybe one can use a terminal to clean.  Made some UX changes.  The Stop button works, and history and gifs are created after the stop, and there is a log \"Stop requested by the user\""
      },
      {
        "user": "vvincent1234",
        "created_at": "2025-01-12T01:18:31Z",
        "body": "Some questions here:\r\n1. Please keep *.gif in .gitignore\r\n2. Some unnecessary changes, such as: if hasattr(self, 'generate_gif') and self.generate_gif, No need to verify: hasattr(self, 'generate_gif'). Please only focus on the feature you propose first, which can let me review faster.\r\n3. Why do you need to overwrite _create_task_frame and _add_overlay_to_image?\r\n4. Please do not use persistence_config = BrowserPersistenceConfig.from_env(), Use keep_browser_open instead."
      }
    ]
  },
  {
    "number": 78,
    "title": "docs: fix playwright install command",
    "created_at": "2025-01-10T15:52:07Z",
    "closed_at": "2025-01-11T04:05:37Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/78",
    "body": null,
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/78/comments",
    "author": "sigmaSd",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-11T01:08:31Z",
        "body": "Hi, just use `playwright install` should be enough"
      },
      {
        "user": "sigmaSd",
        "created_at": "2025-01-11T04:05:38Z",
        "body": "Hello, my bad I realize now I didn't run source .venv command, that's probably the issue, Thanks for your time "
      }
    ]
  },
  {
    "number": 77,
    "title": "Chore/clean code llm provider",
    "created_at": "2025-01-10T14:32:51Z",
    "closed_at": "2025-01-10T15:14:06Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/77",
    "body": "Generalized the llm provider and model using `utils.model_names` Dict in the dropdown menu.",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/77/comments",
    "author": "MeshkatShB",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-10T15:14:00Z",
        "body": "Good! That is exactly what I want"
      }
    ]
  },
  {
    "number": 74,
    "title": "feat: add llm provider and model default value to supperss `UserWarning`",
    "created_at": "2025-01-10T09:59:41Z",
    "closed_at": "2025-01-10T13:33:59Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/74",
    "body": "To suppress the below `UserWarning`, we can set a default value for `LLM Provider` and `LLM Model Name`. The `warning` was as below:\r\n\r\n```\r\nH:\\Documents\\Work\\browser-web-ui\\myenv\\Lib\\site-packages\\gradio\\components\\dropdown.py:226: UserWarning: The value passed into gr.Dropdown() is not in the list of choices. Please update the list of choices to include:  or set allow_custom_value=True.\r\n```",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/74/comments",
    "author": "MeshkatShB",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-10T12:07:51Z",
        "body": "Hi, Please set default llm_provider to openai, deafult llm_model_name to model_names['openai']"
      },
      {
        "user": "MeshkatShB",
        "created_at": "2025-01-10T13:39:49Z",
        "body": "> Hi, Please set default llm_provider to openai, deafult llm_model_name to model_names['openai']\r\n\r\nHi there. There was no model_name Dict so I hardcoded it. I can remove the hardcoding separately if you wish."
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-10T13:41:03Z",
        "body": "> > Hi, Please set default llm_provider to openai, deafult llm_model_name to model_names['openai']\r\n> \r\n> Hi there. There was no model_name Dict so I hardcoded it. I can remove the hardcoding separately if you wish.\r\n\r\nThat's OK"
      }
    ]
  },
  {
    "number": 73,
    "title": "Feat  add docker support and environment configuration updated",
    "created_at": "2025-01-10T09:21:19Z",
    "closed_at": "2025-01-10T11:14:24Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/73",
    "body": "# Browser Persistence and Docker Containerization\r\n\r\n## Changes Overview\r\n\r\n### 1. Browser Persistence Implementation\r\n- Added `BrowserPersistenceConfig` class to manage browser persistence settings\r\n- Implemented persistence checks in browser and context closing operations\r\n- Added environment variable support for `CHROME_PERSISTENT_SESSION`\r\n- Modified context manager to respect persistence settings\r\n- Maintained backward compatibility with non-persistent mode\r\n\r\n### 2. Code Structure Improvements\r\n- Created persistence configuration to local codebase (`src/browser/config.py`)\r\n- Updated imports to use local implementation\r\n- Added proper type hints and documentation\r\n- Maintained existing code style and formatting\r\n\r\n### 3. Docker Containerization\r\n- Added Docker support with browser persistence when required\r\n- Implemented VNC for browser visualization\r\n- Added environment variable configuration through Docker Compose\r\n\r\n## Key Features\r\n\r\n1. **Persistent Browser Sessions**\r\n   - Browser stays open between AI tasks when enabled\r\n   - Configurable through environment variable\r\n   - Maintains state and cookies across sessions\r\n\r\n2. **Docker Support**\r\n   - Easy deployment with Docker Compose\r\n   - VNC support for browser visualization\r\n   - Configurable through environment variables\r\n\r\n## Testing Done\r\n- Verified browser persistence with `CHROME_PERSISTENT_SESSION=true`\r\n- Tested both Docker and local environments\r\n- Verified compatibility with existing features\r\n- Tested with both custom and default browser modes\r\n- Added new test case `test_browser_persistence()` to verify persistence functionality\r\n\r\n\r\n## Notes\r\n- Browser persistence is optional and can be toggled via environment variable\r\n- All existing functionality is maintained\r\n- Code changes are minimal and focused\r\n- Proper error handling is implemented\r\n- Updated README.md with new instructions",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/73/comments",
    "author": "casistack",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-10T11:14:19Z",
        "body": "LGTM"
      }
    ]
  },
  {
    "number": 71,
    "title": "About the pop up functionality",
    "created_at": "2025-01-10T03:56:24Z",
    "closed_at": "2025-01-10T15:42:56Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/71",
    "body": "Hi all,\r\n\r\nThanks for contributing to this cool tool. \r\nI have a question that does this tool support the ability to interact with pop-up windows called from a webpage, such as performing actions like uploading files?\r\n\r\nThank you in advance.",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/71/comments",
    "author": "chiehpower",
    "comments": [
      {
        "user": "clemens6906",
        "created_at": "2025-01-10T09:42:54Z",
        "body": "At this time, the AI can only interact through the browser and cannot directly access files on your hard drive to upload them."
      },
      {
        "user": "chiehpower",
        "created_at": "2025-01-10T15:42:56Z",
        "body": "I see. Thanks for your information. Because I am considering using this application to test the \"upload\" function. "
      }
    ]
  },
  {
    "number": 70,
    "title": "award-winningï¼šUnboundLocalError: cannot access local variable 'browser' where it is not associated with a value",
    "created_at": "2025-01-10T03:53:51Z",
    "closed_at": "2025-01-10T15:14:10Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/70",
    "body": "When \"Use Own Browser\" is selected, it cannot be used, and the program reported an errorï¼šUnboundLocalError: cannot access local variable 'browser' where it is not associated with a value\r\n\r\nI tried Google Chrome and Edge browsers and got the same error. Hope it can be fixed!\r\n\r\nI followed the tutorial and closed all the specified browsers. I opened the UI with other browsers, but it didn't work properly. I could only use the built-in WebUI.",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/70/comments",
    "author": "hea7enn",
    "comments": [
      {
        "user": "clemens6906",
        "created_at": "2025-01-10T09:44:36Z",
        "body": "You need to specify the path to the .exe file in the `.env` file located in the web-ui folder. As of now, only Chrome is supported (to the best of my knowledge)."
      }
    ]
  },
  {
    "number": 67,
    "title": "Screenshots",
    "created_at": "2025-01-09T22:54:09Z",
    "closed_at": "2025-01-11T18:37:33Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/67",
    "body": "It'd be nice to have screenshots for each step.",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/67/comments",
    "author": "HakeemsGit",
    "comments": [
      {
        "user": "katiue",
        "created_at": "2025-01-10T17:29:29Z",
        "body": "i thought the function screenshot is built-in for browser-use library. it stored in the agent.history"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-11T01:11:41Z",
        "body": "Yeah, screenshots have already existed at agent.history as mentioned by katiue"
      }
    ]
  },
  {
    "number": 61,
    "title": "Save and replay LLM operations to avoid redundant calls",
    "created_at": "2025-01-09T08:54:24Z",
    "closed_at": "2025-02-04T08:25:27Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/61",
    "body": "Can we save the sequence of operations after completing a task with LLMs? This would allow users to replay saved operations instead of calling the LLM again.",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/61/comments",
    "author": "guojian0911",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-09T13:01:28Z",
        "body": "The sequence of operations are default to save at ./tmp/result_processing. Now you can specify path on WebUI.  Update code!"
      }
    ]
  },
  {
    "number": 60,
    "title": "Error when using `Use Own Browser` in `Browser Settings`",
    "created_at": "2025-01-09T07:58:03Z",
    "closed_at": "2025-01-10T15:14:09Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/60",
    "body": "While using the `Use Own Browser` setting, the below error is thrown:\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"H:\\Documents\\Work\\browser-web-ui\\myenv\\Lib\\site-packages\\gradio\\queueing.py\", line 625, in process_events\r\n    response = await route_utils.call_process_api(\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"H:\\Documents\\Work\\browser-web-ui\\myenv\\Lib\\site-packages\\gradio\\route_utils.py\", line 322, in call_process_api\r\n    output = await app.get_blocks().process_api(\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"H:\\Documents\\Work\\browser-web-ui\\myenv\\Lib\\site-packages\\gradio\\blocks.py\", line 2045, in process_api\r\n    result = await self.call_function(\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"H:\\Documents\\Work\\browser-web-ui\\myenv\\Lib\\site-packages\\gradio\\blocks.py\", line 1590, in call_function\r\n    prediction = await fn(*processed_input)\r\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"H:\\Documents\\Work\\browser-web-ui\\myenv\\Lib\\site-packages\\gradio\\utils.py\", line 837, in async_wrapper\r\n    response = await f(*args, **kwargs)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"H:\\Documents\\Work\\browser-web-ui\\webui.py\", line 99, in run_browser_agent\r\n    final_result, errors, model_actions, model_thoughts = await run_custom_agent(\r\n                                                          ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"H:\\Documents\\Work\\browser-web-ui\\webui.py\", line 283, in run_custom_agent\r\n    await browser.close()\r\n          ^^^^^^^\r\nUnboundLocalError: cannot access local variable 'browser' where it is not associated with a value\r\n```\r\n\r\nBut works perfectly fine without this option.",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/60/comments",
    "author": "MeshkatShB",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-09T12:23:57Z",
        "body": "Have you closed all chrome windows before clicking run button?"
      },
      {
        "user": "hea7enn",
        "created_at": "2025-01-10T03:29:39Z",
        "body": "> Have you closed all chrome windows before clicking run button?\r\n\r\nI Also Have The Same Problem As This One, The Error Message Is The Same, And I Specifically Closed All Google Browsers Before Starting It, But It Still Doesn'T Work."
      },
      {
        "user": "MeshkatShB",
        "created_at": "2025-01-10T08:08:32Z",
        "body": "> Have you closed all chrome windows before clicking run button?\r\n\r\nAfter I closed all the windows, it did work but with a slight change in the code. The actual code that is up and running, didn't work for me. I can req a pull req for the new code."
      },
      {
        "user": "MeshkatShB",
        "created_at": "2025-01-10T11:00:14Z",
        "body": "> > Have you closed all chrome windows before clicking run button?\n> \n> I Also Have The Same Problem As This One, The Error Message Is The Same, And I Specifically Closed All Google Browsers Before Starting It, But It Still Doesn'T Work.\n\nCan you try my pull req #75 and copy the changes and see if it works?"
      }
    ]
  },
  {
    "number": 59,
    "title": "feat: Add proxy support for browser automation.",
    "created_at": "2025-01-09T03:31:44Z",
    "closed_at": "2025-01-10T09:08:00Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/59",
    "body": "feat: Add proxy support for browser automation and fix TypeError: MessageManager.__init__() got an unexpected keyword argument 'tool_call_in_content'",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/59/comments",
    "author": "qitest",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-09T11:59:34Z",
        "body": "feat: Add proxy support for browser automation and fix TypeError: MessageManager.init() got an unexpected keyword argument 'tool_call_in_content'. \r\n\r\nThis is not an error. Please upgrade to browser-use>=0.1.18"
      },
      {
        "user": "qitest",
        "created_at": "2025-01-10T02:24:54Z",
        "body": "> feat: Add proxy support for browser automation and fix TypeError: MessageManager.init() got an unexpected keyword argument 'tool_call_in_content'.\r\n> \r\n> This is not an error. Please upgrade to browser-use>=0.1.18\r\n\r\nThanks for the suggestion. I've upgraded to browser-use>=0.1.18 "
      }
    ]
  },
  {
    "number": 56,
    "title": "Update test_playwright.py",
    "created_at": "2025-01-08T17:32:35Z",
    "closed_at": "2025-01-09T00:05:06Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/56",
    "body": "Added some translations",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/56/comments",
    "author": "pranavred",
    "comments": [
      {
        "user": "pranavred",
        "created_at": "2025-01-08T17:32:58Z",
        "body": "Added translations"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-09T00:05:02Z",
        "body": "Okay, Can you help me to translate other Chinese comment into English in webui.py or any files?"
      }
    ]
  },
  {
    "number": 55,
    "title": "Enable/Disable Recordings",
    "created_at": "2025-01-08T16:45:51Z",
    "closed_at": "2025-01-09T00:14:06Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/55",
    "body": "Browser Settings TAB\r\n\r\n--> Added check box for enable or disable recordings\r\n\r\nenable --> can edit the recordings path and videos are saved\r\ndisable --> cannot edit the recordings path and videos are not saved",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/55/comments",
    "author": "richard-devbot",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-09T00:14:03Z",
        "body": "LGTM"
      }
    ]
  },
  {
    "number": 54,
    "title": "Docs/update readme",
    "created_at": "2025-01-08T16:42:35Z",
    "closed_at": "2025-01-09T00:15:28Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/54",
    "body": "Added descriptions of the `--theme` and `--dark-mode` argument options in the `README.md` file as they were in the code.",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/54/comments",
    "author": "MeshkatShB",
    "comments": [
      {
        "user": "richard-devbot",
        "created_at": "2025-01-08T16:49:48Z",
        "body": "Awsome can you please add this point as well -- if possible \"Please uncheck the Use Vision option, because DeepSeek doesn't support Vision input\""
      }
    ]
  },
  {
    "number": 52,
    "title": "Auto closing when finished a designated Task",
    "created_at": "2025-01-08T15:29:04Z",
    "closed_at": "2025-01-13T14:06:49Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/52",
    "body": "Browser is auto closed when Agent has finished the designated tasks. It shall maintain flawless flow like continue to receive further commands for other open tabs also. ",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/52/comments",
    "author": "kawalpreet176",
    "comments": [
      {
        "user": "richard-devbot",
        "created_at": "2025-01-08T16:53:02Z",
        "body": "we are working on it [TODO-list]"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-13T14:06:49Z",
        "body": "supported now"
      }
    ]
  },
  {
    "number": 49,
    "title": "I can't run it - log",
    "created_at": "2025-01-08T14:21:59Z",
    "closed_at": "2025-01-08T22:59:09Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/49",
    "body": "Traceback (most recent call last):\r\n  File \"F:\\_browser use webai\\web-ui-main\\webui.py\", line 196, in run_custom_agent\r\n    browser_context_ = await playwright.chromium.launch_persistent_context(\r\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"F:\\_browser use webai\\web-ui-main\\.venv\\Lib\\site-packages\\playwright\\async_api\\_generated.py\", line 14681, in launch_persistent_context\r\n    await self._impl_obj.launch_persistent_context(\r\n  File \"F:\\_browser use webai\\web-ui-main\\.venv\\Lib\\site-packages\\playwright\\_impl\\_browser_type.py\", line 159, in launch_persistent_context\r\n    from_channel(await self._channel.send(\"launchPersistentContext\", params)),\r\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"F:\\_browser use webai\\web-ui-main\\.venv\\Lib\\site-packages\\playwright\\_impl\\_connection.py\", line 61, in send\r\n    return await self._connection.wrap_api_call(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"F:\\_browser use webai\\web-ui-main\\.venv\\Lib\\site-packages\\playwright\\_impl\\_connection.py\", line 528, in wrap_api_call\r\n    raise rewrite_error(error, f\"{parsed_st['apiName']}: {error}\") from None\r\nplaywright._impl._errors.TargetClosedError: BrowserType.launch_persistent_context: Target page, context or browser has been closed\r\nBrowser logs:\r\n\r\n<launching> C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe --disable-field-trial-config --disable-background-networking --disable-background-timer-throttling --disable-backgrounding-occluded-windows --disable-back-forward-cache --disable-breakpad --disable-client-side-phishing-detection --disable-component-extensions-with-background-pages --disable-component-update --no-default-browser-check --disable-default-apps --disable-dev-shm-usage --disable-extensions --disable-features=ImprovedCookieControls,LazyFrameLoading,GlobalMediaControls,DestroyProfileOnBrowserClose,MediaRouter,DialMediaRouteProvider,AcceptCHFrame,AutoExpandDetailsElement,CertificateTransparencyComponentUpdater,AvoidUnnecessaryBeforeUnloadCheckSync,Translate,HttpsUpgrades,PaintHolding,ThirdPartyStoragePartitioning,LensOverlay,PlzDedicatedWorker --allow-pre-commit-input --disable-hang-monitor --disable-ipc-flooding-protection --disable-popup-blocking --disable-prompt-on-repost --disable-renderer-backgrounding --force-color-profile=srgb --metrics-recording-only --no-first-run --enable-automation --password-store=basic --use-mock-keychain --no-service-autorun --export-tagged-pdf --disable-search-engine-choice-screen --unsafely-disable-devtools-self-xss-warnings --no-sandbox --user-data-dir=C:\\Users\\User\\AppData\\Local\\Google\\Chrome\\User Data --remote-debugging-pipe about:blank\r\n<launched> pid=19352\r\nCall log:\r\n  - <launching> C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe --disable-field-trial-config --disable-background-networking --disable-background-timer-throttling --disable-backgrounding-occluded-windows --disable-back-forward-cache --disable-breakpad --disable-client-side-phishing-detection --disable-component-extensions-with-background-pages --disable-component-update --no-default-browser-check --disable-default-apps --disable-dev-shm-usage --disable-extensions --disable-features=ImprovedCookieControls,LazyFrameLoading,GlobalMediaControls,DestroyProfileOnBrowserClose,MediaRouter,DialMediaRouteProvider,AcceptCHFrame,AutoExpandDetailsElement,CertificateTransparencyComponentUpdater,AvoidUnnecessaryBeforeUnloadCheckSync,Translate,HttpsUpgrades,PaintHolding,ThirdPartyStoragePartitioning,LensOverlay,PlzDedicatedWorker --allow-pre-commit-input --disable-hang-monitor --disable-ipc-flooding-protection --disable-popup-blocking --disable-prompt-on-repost --disable-renderer-backgrounding --force-color-profile=srgb --metrics-recording-only --no-first-run --enable-automation --password-store=basic --use-mock-keychain --no-service-autorun --export-tagged-pdf --disable-search-engine-choice-screen --unsafely-disable-devtools-self-xss-warnings --no-sandbox --user-data-dir=C:\\Users\\User\\AppData\\Local\\Google\\Chrome\\User Data --remote-debugging-pipe about:blank\r\n  -   - <launched> pid=19352\r\n\r\nTraceback (most recent call last):\r\n  File \"F:\\_browser use webai\\web-ui-main\\.venv\\Lib\\site-packages\\gradio\\queueing.py\", line 625, in process_events\r\n    response = await route_utils.call_process_api(\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"F:\\_browser use webai\\web-ui-main\\.venv\\Lib\\site-packages\\gradio\\route_utils.py\", line 322, in call_process_api\r\n    output = await app.get_blocks().process_api(\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"F:\\_browser use webai\\web-ui-main\\.venv\\Lib\\site-packages\\gradio\\blocks.py\", line 2045, in process_api\r\n    result = await self.call_function(\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"F:\\_browser use webai\\web-ui-main\\.venv\\Lib\\site-packages\\gradio\\blocks.py\", line 1590, in call_function\r\n    prediction = await fn(*processed_input)\r\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"F:\\_browser use webai\\web-ui-main\\.venv\\Lib\\site-packages\\gradio\\utils.py\", line 837, in async_wrapper\r\n    response = await f(*args, **kwargs)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"F:\\_browser use webai\\web-ui-main\\webui.py\", line 83, in run_browser_agent\r\n    final_result, errors, model_actions, model_thoughts = await run_custom_agent(\r\n                                                          ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"F:\\_browser use webai\\web-ui-main\\webui.py\", line 268, in run_custom_agent\r\n    await browser.close()\r\n          ^^^^^^^\r\nUnboundLocalError: cannot access local variable 'browser' where it is not associated with a value",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/49/comments",
    "author": "PaYo90",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-08T14:28:14Z",
        "body": "Have you closed all chrome windows before clicked the run button?"
      },
      {
        "user": "PaYo90",
        "created_at": "2025-01-08T21:52:06Z",
        "body": "it helped : ) thanks"
      }
    ]
  },
  {
    "number": 36,
    "title": "how i can disable recording?",
    "created_at": "2025-01-07T22:31:08Z",
    "closed_at": "2025-01-09T11:28:47Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/36",
    "body": "how i can disable recording?",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/36/comments",
    "author": "pierangelo04",
    "comments": [
      {
        "user": "richard-devbot",
        "created_at": "2025-01-08T04:15:16Z",
        "body": "> how i can disable recording?\r\n\r\nIts a great Idea, I will look into it [TODO-list]"
      },
      {
        "user": "richard-devbot",
        "created_at": "2025-01-08T16:47:39Z",
        "body": "Enable/Disable Recordings\r\n\r\nReady to merge PR #55"
      }
    ]
  },
  {
    "number": 34,
    "title": "fixed browser use version",
    "created_at": "2025-01-07T20:18:50Z",
    "closed_at": "2025-01-08T14:49:30Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/34",
    "body": "fixed browser use version",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/34/comments",
    "author": "GatienBoquet",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-08T11:39:31Z",
        "body": "Hi, thanks for your PR. But we have updated the code to adapt to new version of browser-use. Including update requirements.txt. You can find another issues to solve."
      }
    ]
  },
  {
    "number": 30,
    "title": "fix: log for own browser env var issues",
    "created_at": "2025-01-07T08:45:01Z",
    "closed_at": "2025-01-08T11:51:09Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/30",
    "body": "Add logs in case user selected on browser but either forgot to add the right env vars (CHROME_PATH, CHROME_USER_DATA) or set them to incorrect paths",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/30/comments",
    "author": "matthew1809",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-07T11:41:08Z",
        "body": "Hi, chrome_exe and chrome_use_data can actually be set to None. Currently, when the user doesn't specify them, they default to an empty string, which causes an error. You should change it to:\r\n\r\n1. If chrome_exe is an empty string (''), set it to None. Otherwise, check if the chrome_exe path exists, and only then raise an error if it doesn't.\r\n\r\n2. If chrome_use_data is an empty string (''), set it to None. There's no need to check if the chrome_use_data path exists because Playwright will automatically create it if it doesn't.\r\n\r\nThanks!"
      },
      {
        "user": "matthew1809",
        "created_at": "2025-01-07T16:41:24Z",
        "body": "Thanks @warmshao updated"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-08T11:51:17Z",
        "body": "LGTM"
      }
    ]
  },
  {
    "number": 28,
    "title": "Update LLM configuration Tab to display list of models",
    "created_at": "2025-01-07T06:41:05Z",
    "closed_at": "2025-01-08T15:38:58Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/28",
    "body": "updated LLM configuration TAB, for now i just tested it with Gemini LLM provider, to get the list of models user has to enter the API key in the UI, so that Gemini models will appear , please test it , I don't have other API keys to list out models",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/28/comments",
    "author": "richard-devbot",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-07T11:09:28Z",
        "body": "Hi Richard, here are some suggestions:\r\n\r\n1. Regarding the model name input: I suggest we keep the current model name input field. We can place your dropdown menu next to it. When the user selects a model from the dropdown, it should automatically update the model name input field. We should also allow users to manually type a model name into the input field. This approach provides flexibility while still offering guided selection.\r\n\r\n2. Regarding default models:\r\n\r\n- For Anthropic, the default return [claude-3-5-sonnet-20240620] .\r\n- For Deepseek, the default return [deepseek-chat] . Deepseek models are gaining popularity, and we should maintain support for them.\r\n\r\n3. Regarding the fetch_available_models function: Please move the fetch_available_models function to src/utils/utils.py. This helps maintain a consistent code structure and organization. "
      },
      {
        "user": "richard-devbot",
        "created_at": "2025-01-07T14:00:28Z",
        "body": "> Hi Richard, here are some suggestions:\r\n> \r\n> 1. Regarding the model name input: I suggest we keep the current model name input field. We can place your dropdown menu next to it. When the user selects a model from the dropdown, it should automatically update the model name input field. We should also allow users to manually type a model name into the input field. This approach provides flexibility while still offering guided selection.\r\n> 2. Regarding default models:\r\n> \r\n> * For Anthropic, the default return [claude-3-5-sonnet-20240620] .\r\n> * For Deepseek, the default return [deepseek-chat] . Deepseek models are gaining popularity, and we should maintain support for them.\r\n> \r\n> 3. Regarding the fetch_available_models function: Please move the fetch_available_models function to src/utils/utils.py. This helps maintain a consistent code structure and organization.\r\n\r\nYour ideas are really stunning, \r\n\r\nAdded the changes and updated--ready to test please verify"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-07T14:52:12Z",
        "body": "> > Hi Richard, here are some suggestions:\r\n> > \r\n> > 1. Regarding the model name input: I suggest we keep the current model name input field. We can place your dropdown menu next to it. When the user selects a model from the dropdown, it should automatically update the model name input field. We should also allow users to manually type a model name into the input field. This approach provides flexibility while still offering guided selection.\r\n> > 2. Regarding default models:\r\n> > \r\n> > \r\n> > * For Anthropic, the default return [claude-3-5-sonnet-20240620] .\r\n> > * For Deepseek, the default return [deepseek-chat] . Deepseek models are gaining popularity, and we should maintain support for them.\r\n> > \r\n> > \r\n> > 3. Regarding the fetch_available_models function: Please move the fetch_available_models function to src/utils/utils.py. This helps maintain a consistent code structure and organization.\r\n> \r\n> Your ideas are really stunning,\r\n> \r\n> Added the changes and updated--ready to test please verify\r\n\r\n1. llm_model_name is set as gr.Dropdown, user can not type a custom model name. Please keep to use gr.Textbox.\r\n2. On line 247, when api_key is empty, I noticed that you directly return an empty list ([]). This doesn't seem reasonable because many people will set the API_KEY in their .env file instead of using the api_key variable. Therefore, this conditional check should be removed.\r\n3. I tested the functions within fetch_available_models, and it seems there are some bugs. For example, with AzureOpenAI, I get the error: 'Must provide either the api_version argument or the OPENAI_API_VERSION environment variable.' I suggest predefining a model_names_dict and then simply returning the list of models based on the key. This would be simpler because the commonly used models are limited. If a model is not in the list, users can manually input it into llm_model_name. Such as:\r\n\r\n```\r\nmodel_names = {\r\n\"openai\": [\"gpt-4o\", \"gpt-4o-mini\"],\r\n\"gemini\": [\"gemini-2.0-flash-exp\", \"gemini-2.0-flash-thinking-exp-1219\"],\r\n...\r\n}\r\n```\r\n\r\nIf you still want to use your method, please make sure that the functions are tested thoroughly and can return model_names correctly. Additionally, you might need to obtain the values of base_url and api_key in a manner similar to how I did it in get_llm_model."
      },
      {
        "user": "richard-devbot",
        "created_at": "2025-01-08T04:18:26Z",
        "body": "> > > Hi Richard, here are some suggestions:\r\n> > > \r\n> > > 1. Regarding the model name input: I suggest we keep the current model name input field. We can place your dropdown menu next to it. When the user selects a model from the dropdown, it should automatically update the model name input field. We should also allow users to manually type a model name into the input field. This approach provides flexibility while still offering guided selection.\r\n> > > 2. Regarding default models:\r\n> > > \r\n> > > \r\n> > > * For Anthropic, the default return [claude-3-5-sonnet-20240620] .\r\n> > > * For Deepseek, the default return [deepseek-chat] . Deepseek models are gaining popularity, and we should maintain support for them.\r\n> > > \r\n> > > \r\n> > > 3. Regarding the fetch_available_models function: Please move the fetch_available_models function to src/utils/utils.py. This helps maintain a consistent code structure and organization.\r\n> > \r\n> > \r\n> > Your ideas are really stunning,\r\n> > Added the changes and updated--ready to test please verify\r\n> \r\n> 1. llm_model_name is set as gr.Dropdown, user can not type a custom model name. Please keep to use gr.Textbox.\r\n> 2. On line 247, when api_key is empty, I noticed that you directly return an empty list ([]). This doesn't seem reasonable because many people will set the API_KEY in their .env file instead of using the api_key variable. Therefore, this conditional check should be removed.\r\n> 3. I tested the functions within fetch_available_models, and it seems there are some bugs. For example, with AzureOpenAI, I get the error: 'Must provide either the api_version argument or the OPENAI_API_VERSION environment variable.' I suggest predefining a model_names_dict and then simply returning the list of models based on the key. This would be simpler because the commonly used models are limited. If a model is not in the list, users can manually input it into llm_model_name. Such as:\r\n> \r\n> ```\r\n> model_names = {\r\n> \"openai\": [\"gpt-4o\", \"gpt-4o-mini\"],\r\n> \"gemini\": [\"gemini-2.0-flash-exp\", \"gemini-2.0-flash-thinking-exp-1219\"],\r\n> ...\r\n> }\r\n> ```\r\n> \r\n> If you still want to use your method, please make sure that the functions are tested thoroughly and can return model_names correctly. Additionally, you might need to obtain the values of base_url and api_key in a manner similar to how I did it in get_llm_model.\r\n\r\nYeah even I thought the same, I'll adjust that, but I was thinking it better if we can fetch the models directly using the SDK so that we don't need to worry in the future if new models getting added, \r\n"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-08T11:49:50Z",
        "body": "> > > > Hi Richard, here are some suggestions:\r\n> > > > \r\n> > > > 1. Regarding the model name input: I suggest we keep the current model name input field. We can place your dropdown menu next to it. When the user selects a model from the dropdown, it should automatically update the model name input field. We should also allow users to manually type a model name into the input field. This approach provides flexibility while still offering guided selection.\r\n> > > > 2. Regarding default models:\r\n> > > > \r\n> > > > \r\n> > > > * For Anthropic, the default return [claude-3-5-sonnet-20240620] .\r\n> > > > * For Deepseek, the default return [deepseek-chat] . Deepseek models are gaining popularity, and we should maintain support for them.\r\n> > > > \r\n> > > > \r\n> > > > 3. Regarding the fetch_available_models function: Please move the fetch_available_models function to src/utils/utils.py. This helps maintain a consistent code structure and organization.\r\n> > > \r\n> > > \r\n> > > Your ideas are really stunning,\r\n> > > Added the changes and updated--ready to test please verify\r\n> > \r\n> > \r\n> > \r\n> > 1. llm_model_name is set as gr.Dropdown, user can not type a custom model name. Please keep to use gr.Textbox.\r\n> > 2. On line 247, when api_key is empty, I noticed that you directly return an empty list ([]). This doesn't seem reasonable because many people will set the API_KEY in their .env file instead of using the api_key variable. Therefore, this conditional check should be removed.\r\n> > 3. I tested the functions within fetch_available_models, and it seems there are some bugs. For example, with AzureOpenAI, I get the error: 'Must provide either the api_version argument or the OPENAI_API_VERSION environment variable.' I suggest predefining a model_names_dict and then simply returning the list of models based on the key. This would be simpler because the commonly used models are limited. If a model is not in the list, users can manually input it into llm_model_name. Such as:\r\n> > \r\n> > ```\r\n> > model_names = {\r\n> > \"openai\": [\"gpt-4o\", \"gpt-4o-mini\"],\r\n> > \"gemini\": [\"gemini-2.0-flash-exp\", \"gemini-2.0-flash-thinking-exp-1219\"],\r\n> > ...\r\n> > }\r\n> > ```\r\n> > \r\n> > \r\n> >     \r\n> >       \r\n> >     \r\n> > \r\n> >       \r\n> >     \r\n> > \r\n> >     \r\n> >   \r\n> > If you still want to use your method, please make sure that the functions are tested thoroughly and can return model_names correctly. Additionally, you might need to obtain the values of base_url and api_key in a manner similar to how I did it in get_llm_model.\r\n> \r\n> Yeah even I thought the same, I'll adjust that, but I was thinking it better if we can fetch the models directly using the SDK so that we don't need to worry in the future if new models getting added,\r\n\r\nYes, It's OK for me to  fetch the models directly using the SDK. Just make sure that the functions are tested thoroughly and can return model_names correctly. Additionally, you might need to obtain the values of base_url and api_key in a manner similar to how I did it in get_llm_model. Because many people set api_key and base_url in .env instead of webui.\r\n\r\nBTW, we have updated the code to adapt to the new version of browser-use. You may need to solve the conflicts."
      },
      {
        "user": "richard-devbot",
        "created_at": "2025-01-08T14:50:48Z",
        "body": "Hello Good Day, \r\n\r\nLLM configuration tab\r\n1- Added model dropdown option where user can select or edit in the same area\r\n2- added another feature named it feth models where the user can provide a base URL and API key in UI and fetch all the available models  which are available via SDK\r\n\r\nrenamed the \"recordings\" tab - to the \"results\" tab\r\n1- Recently executed video is shown in this Results tab along with model actions\r\n\r\nModified recordings tab - to show all the recordings available \r\n1- all the videos in the recordings folder will be displayed and played "
      }
    ]
  },
  {
    "number": 16,
    "title": "feat: add Docker support and environment configuration",
    "created_at": "2025-01-06T13:53:11Z",
    "closed_at": "2025-01-10T09:17:03Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/16",
    "body": "# Browser Persistence and Docker Containerization\r\n\r\n## Changes Overview\r\n\r\n### 1. Browser Persistence Implementation\r\n- Added `BrowserPersistenceConfig` class to manage browser persistence settings\r\n- Implemented persistence checks in browser and context closing operations\r\n- Added environment variable support for `CHROME_PERSISTENT_SESSION`\r\n- Modified context manager to respect persistence settings\r\n- Maintained backward compatibility with non-persistent mode\r\n\r\n### 2. Code Structure Improvements\r\n- Created persistence configuration to local codebase (`src/browser/config.py`)\r\n- Updated imports to use local implementation\r\n- Added proper type hints and documentation\r\n- Maintained existing code style and formatting\r\n\r\n### 3. Docker Containerization\r\n- Added Docker support with browser persistence when required\r\n- Implemented VNC for browser visualization\r\n- Added environment variable configuration through Docker Compose\r\n\r\n## Key Features\r\n\r\n1. **Persistent Browser Sessions**\r\n   - Browser stays open between AI tasks when enabled\r\n   - Configurable through environment variable\r\n   - Maintains state and cookies across sessions\r\n\r\n2. **Docker Support**\r\n   - Easy deployment with Docker Compose\r\n   - VNC support for browser visualization\r\n   - Configurable through environment variables\r\n\r\n## Testing Done\r\n- Verified browser persistence with `CHROME_PERSISTENT_SESSION=true`\r\n- Tested both Docker and local environments\r\n- Verified compatibility with existing features\r\n- Tested with both custom and default browser modes\r\n- Added new test case `test_browser_persistence()` to verify persistence functionality\r\n\r\n\r\n## Notes\r\n- Browser persistence is optional and can be toggled via environment variable\r\n- All existing functionality is maintained\r\n- Code changes are minimal and focused\r\n- Proper error handling is implemented\r\n- Updated README.md with new instructions",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/16/comments",
    "author": "casistack",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-06T14:08:19Z",
        "body": "> # Browser Persistence and Docker Containerization\r\n> ## Changes Overview\r\n> ### 1. Browser Persistence Implementation\r\n> * Added `BrowserPersistenceConfig` class to manage browser persistence settings\r\n> * Implemented persistence checks in browser and context closing operations\r\n> * Added environment variable support for `CHROME_PERSISTENT_SESSION`\r\n> * Modified context manager to respect persistence settings\r\n> * Maintained backward compatibility with non-persistent mode\r\n> \r\n> ### 2. Code Structure Improvements\r\n> * Created persistence configuration to local codebase (`src/browser/config.py`)\r\n> * Updated imports to use local implementation\r\n> * Added proper type hints and documentation\r\n> * Maintained existing code style and formatting\r\n> \r\n> ### 3. Docker Containerization\r\n> * Added Docker support with browser persistence when required\r\n> * Implemented VNC for browser visualization\r\n> * Added environment variable configuration through Docker Compose\r\n> \r\n> ## Key Features\r\n> 1. **Persistent Browser Sessions**\r\n>    \r\n>    * Browser stays open between AI tasks when enabled\r\n>    * Configurable through environment variable\r\n>    * Maintains state and cookies across sessions\r\n> 2. **Docker Support**\r\n>    \r\n>    * Easy deployment with Docker Compose\r\n>    * VNC support for browser visualization\r\n>    * Configurable through environment variables\r\n> \r\n> ## Testing Done\r\n> * Verified browser persistence with `CHROME_PERSISTENT_SESSION=true`\r\n> * Tested both Docker and local environments\r\n> * Verified compatibility with existing features\r\n> * Tested with both custom and default browser modes\r\n> * Added new test case `test_browser_persistence()` to verify persistence functionality\r\n> \r\n> ## Notes\r\n> * Browser persistence is optional and can be toggled via environment variable\r\n> * All existing functionality is maintained\r\n> * Code changes are minimal and focused\r\n> * Proper error handling is implemented\r\n> * Updated README.md with new instructions\r\n\r\nThank you! I will review it ASAP"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-06T14:39:01Z",
        "body": "I got an error when setting CHROME_PERSISTENT_SESSION=true and run second task. The browser still opened, but error happened and task failed:\r\n\r\nTraceback (most recent call last):\r\n  File \"E:\\my_projects\\browser-use-webui\\webui.py\", line 162, in run_custom_agent\r\n    browser_context_ = await playwright.chromium.launch_persistent_context(\r\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"D:\\softwares\\miniconda\\envs\\agent\\Lib\\site-packages\\playwright\\async_api\\_generated.py\", line 14681, in launch_persistent_context\r\n    await self._impl_obj.launch_persistent_context(\r\n  File \"D:\\softwares\\miniconda\\envs\\agent\\Lib\\site-packages\\playwright\\_impl\\_browser_type.py\", line 159, in launch_persistent_context\r\n    from_channel(await self._channel.send(\"launchPersistentContext\", params)),\r\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"D:\\softwares\\miniconda\\envs\\agent\\Lib\\site-packages\\playwright\\_impl\\_connection.py\", line 61, in send\r\n    return await self._connection.wrap_api_call(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"D:\\softwares\\miniconda\\envs\\agent\\Lib\\site-packages\\playwright\\_impl\\_connection.py\", line 528, in wrap_api_call\r\n    raise rewrite_error(error, f\"{parsed_st['apiName']}: {error}\") from None\r\nplaywright._impl._errors.TargetClosedError: BrowserType.launch_persistent_context: Target page, context or browser has been closed\r\nBrowser logs:\r\n\r\n<launching> C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe --disable-field-trial-config --disable-background-networking --disable-background-timer-throttling --disable-backgrounding-occluded-windows --disable-back-forward-cache --disable-breakpad --disable-client-side-phishing-detection --disable-component-extensions-with-background-pages --disable-component-update --no-default-browser-check --disable-default-apps --disable-dev-shm-usage --disable-extensions --disable-features=ImprovedCookieControls,LazyFrameLoading,GlobalMediaControls,DestroyProfileOnBrowserClose,MediaRouter,DialMediaRouteProvider,AcceptCHFrame,AutoExpandDetailsElement,CertificateTransparencyComponentUpdater,AvoidUnnecessaryBeforeUnloadCheckSync,Translate,HttpsUpgrades,PaintHolding,ThirdPartyStoragePartitioning,LensOverlay,PlzDedicatedWorker --allow-pre-commit-input --disable-hang-monitor --disable-ipc-flooding-protection --disable-popup-blocking --disable-prompt-on-repost --disable-renderer-backgrounding --force-color-profile=srgb --metrics-recording-only --no-first-run --enable-automation --password-store=basic --use-mock-keychain --no-service-autorun --export-tagged-pdf --disable-search-engine-choice-screen --unsafely-disable-devtools-self-xss-warnings --no-sandbox --user-data-dir=C:\\Users\\xxx\\AppData\\Local\\Google\\Chrome\\User Data --remote-debugging-pipe about:blank\r\n<launched> pid=19832\r\nCall log:\r\n  - <launching> C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe --disable-field-trial-config --disable-background-networking --disable-background-timer-throttling --disable-backgrounding-occluded-windows --disable-back-forward-cache --disable-breakpad --disable-client-side-phishing-detection --disable-component-extensions-with-background-pages --disable-component-update --no-default-browser-check --disable-default-apps --disable-dev-shm-usage --disable-extensions --disable-features=ImprovedCookieControls,LazyFrameLoading,GlobalMediaControls,DestroyProfileOnBrowserClose,MediaRouter,DialMediaRouteProvider,AcceptCHFrame,AutoExpandDetailsElement,CertificateTransparencyComponentUpdater,AvoidUnnecessaryBeforeUnloadCheckSync,Translate,HttpsUpgrades,PaintHolding,ThirdPartyStoragePartitioning,LensOverlay,PlzDedicatedWorker --allow-pre-commit-input --disable-hang-monitor --disable-ipc-flooding-protection --disable-popup-blocking --disable-prompt-on-repost --disable-renderer-backgrounding --force-color-profile=srgb --metrics-recording-only --no-first-run --enable-automation --password-store=basic --use-mock-keychain --no-service-autorun --export-tagged-pdf --disable-search-engine-choice-screen --unsafely-disable-devtools-self-xss-warnings --no-sandbox --user-data-dir=C:\\Users\\xxx\\AppData\\Local\\Google\\Chrome\\User Data --remote-debugging-pipe about:blank\r\n  -   - <launched> pid=19832"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-06T15:02:19Z",
        "body": "You can set a global browser_context_,like this:\r\n```\r\nglobal browser_context_\r\ntry:\r\n    if use_own_browser:\r\n        playwright = await async_playwright().start()\r\n        chrome_exe = os.getenv(\"CHROME_PATH\", \"\")\r\n        chrome_use_data = os.getenv(\"CHROME_USER_DATA\", \"\")\r\n        if browser_context_ is None:\r\n            browser_context_ = await playwright.chromium.launch_persistent_context(\r\n                user_data_dir=chrome_use_data,\r\n                executable_path=chrome_exe,\r\n                no_viewport=False,\r\n                headless=headless,  # ä¿æŒæµè§ˆå™¨çª—å£å¯è§\r\n                user_agent=(\r\n                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 '\r\n                    '(KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36'\r\n                ),\r\n                java_script_enabled=True,\r\n                bypass_csp=disable_security,\r\n                ignore_https_errors=disable_security,\r\n                record_video_dir=save_recording_path if save_recording_path else None,\r\n                record_video_size={'width': window_w, 'height': window_h}\r\n            )\r\n    else:\r\n        browser_context_ = None\r\n\r\n    browser = CustomBrowser(\r\n        config=BrowserConfig(\r\n            headless=headless,\r\n            disable_security=disable_security,\r\n            extra_chromium_args=[f'--window-size={window_w},{window_h}'],\r\n        )\r\n    )\r\n    async with await browser.new_context(\r\n            config=BrowserContextConfig(\r\n                trace_path='./tmp/result_processing',\r\n                save_recording_path=save_recording_path if save_recording_path else None,\r\n                no_viewport=False,\r\n                browser_window_size=BrowserContextWindowSize(width=window_w, height=window_h),\r\n            ),\r\n\r\n            context=browser_context_\r\n    ) as browser_context:\r\n        agent = CustomAgent(\r\n            task=task,\r\n            add_infos=add_infos,\r\n            use_vision=use_vision,\r\n            llm=llm,\r\n            browser_context=browser_context,\r\n            controller=controller,\r\n            system_prompt_class=CustomSystemPrompt\r\n        )\r\n        history = await agent.run(max_steps=max_steps)\r\n\r\n        final_result = history.final_result()\r\n        errors = history.errors()\r\n        model_actions = history.model_actions()\r\n        model_thoughts = history.model_thoughts()\r\n\r\nexcept Exception as e:\r\n    import traceback\r\n    traceback.print_exc()\r\n    final_result = \"\"\r\n    errors = str(e) + \"\\n\" + traceback.format_exc()\r\n    model_actions = \"\"\r\n    model_thoughts = \"\"\r\nfinally:\r\n    # æ˜¾å¼å…³é—­æŒä¹…åŒ–ä¸Šä¸‹æ–‡\r\n    persistence_enabled = (\r\n        os.getenv(\"CHROME_PERSISTENT_SESSION\", \"\").lower() == \"true\"\r\n    )\r\n    if not persistence_enabled:\r\n        if browser_context_:\r\n            await browser_context_.close()\r\n\r\n        # å…³é—­ Playwright å¯¹è±¡\r\n        if playwright:\r\n            await playwright.stop()\r\n        await browser.close()\r\n        browser_context_ = None\r\nreturn final_result, errors, model_actions, model_thoughts\r\n```\r\n\r\nThis works for me"
      },
      {
        "user": "casistack",
        "created_at": "2025-01-06T16:59:16Z",
        "body": "> You can set a global browser_context_,like this:\r\n> \r\n> ```\r\n> global browser_context_\r\n> try:\r\n>     if use_own_browser:\r\n>         playwright = await async_playwright().start()\r\n>         chrome_exe = os.getenv(\"CHROME_PATH\", \"\")\r\n>         chrome_use_data = os.getenv(\"CHROME_USER_DATA\", \"\")\r\n>         if browser_context_ is None:\r\n>             browser_context_ = await playwright.chromium.launch_persistent_context(\r\n>                 user_data_dir=chrome_use_data,\r\n>                 executable_path=chrome_exe,\r\n>                 no_viewport=False,\r\n>                 headless=headless,  # ä¿æŒæµè§ˆå™¨çª—å£å¯è§\r\n>                 user_agent=(\r\n>                     'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 '\r\n>                     '(KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36'\r\n>                 ),\r\n>                 java_script_enabled=True,\r\n>                 bypass_csp=disable_security,\r\n>                 ignore_https_errors=disable_security,\r\n>                 record_video_dir=save_recording_path if save_recording_path else None,\r\n>                 record_video_size={'width': window_w, 'height': window_h}\r\n>             )\r\n>     else:\r\n>         browser_context_ = None\r\n> \r\n>     browser = CustomBrowser(\r\n>         config=BrowserConfig(\r\n>             headless=headless,\r\n>             disable_security=disable_security,\r\n>             extra_chromium_args=[f'--window-size={window_w},{window_h}'],\r\n>         )\r\n>     )\r\n>     async with await browser.new_context(\r\n>             config=BrowserContextConfig(\r\n>                 trace_path='./tmp/result_processing',\r\n>                 save_recording_path=save_recording_path if save_recording_path else None,\r\n>                 no_viewport=False,\r\n>                 browser_window_size=BrowserContextWindowSize(width=window_w, height=window_h),\r\n>             ),\r\n> \r\n>             context=browser_context_\r\n>     ) as browser_context:\r\n>         agent = CustomAgent(\r\n>             task=task,\r\n>             add_infos=add_infos,\r\n>             use_vision=use_vision,\r\n>             llm=llm,\r\n>             browser_context=browser_context,\r\n>             controller=controller,\r\n>             system_prompt_class=CustomSystemPrompt\r\n>         )\r\n>         history = await agent.run(max_steps=max_steps)\r\n> \r\n>         final_result = history.final_result()\r\n>         errors = history.errors()\r\n>         model_actions = history.model_actions()\r\n>         model_thoughts = history.model_thoughts()\r\n> \r\n> except Exception as e:\r\n>     import traceback\r\n>     traceback.print_exc()\r\n>     final_result = \"\"\r\n>     errors = str(e) + \"\\n\" + traceback.format_exc()\r\n>     model_actions = \"\"\r\n>     model_thoughts = \"\"\r\n> finally:\r\n>     # æ˜¾å¼å…³é—­æŒä¹…åŒ–ä¸Šä¸‹æ–‡\r\n>     persistence_enabled = (\r\n>         os.getenv(\"CHROME_PERSISTENT_SESSION\", \"\").lower() == \"true\"\r\n>     )\r\n>     if not persistence_enabled:\r\n>         if browser_context_:\r\n>             await browser_context_.close()\r\n> \r\n>         # å…³é—­ Playwright å¯¹è±¡\r\n>         if playwright:\r\n>             await playwright.stop()\r\n>         await browser.close()\r\n>         browser_context_ = None\r\n> return final_result, errors, model_actions, model_thoughts\r\n> ```\r\n> \r\n> This works for me\r\n\r\nAh sorry i dont have access to windows only tested on linux and docker container.  is this happening in the container?"
      },
      {
        "user": "casistack",
        "created_at": "2025-01-06T17:34:09Z",
        "body": "I have applied your fix . Let me kno wif any issues"
      },
      {
        "user": "gregpr07",
        "created_at": "2025-01-06T18:24:10Z",
        "body": "Really cool job guys!"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-06T22:04:06Z",
        "body": "> > You can set a global browser_context_,like this:\r\n> > ```\r\n> > global browser_context_\r\n> > try:\r\n> >     if use_own_browser:\r\n> >         playwright = await async_playwright().start()\r\n> >         chrome_exe = os.getenv(\"CHROME_PATH\", \"\")\r\n> >         chrome_use_data = os.getenv(\"CHROME_USER_DATA\", \"\")\r\n> >         if browser_context_ is None:\r\n> >             browser_context_ = await playwright.chromium.launch_persistent_context(\r\n> >                 user_data_dir=chrome_use_data,\r\n> >                 executable_path=chrome_exe,\r\n> >                 no_viewport=False,\r\n> >                 headless=headless,  # ä¿æŒæµè§ˆå™¨çª—å£å¯è§\r\n> >                 user_agent=(\r\n> >                     'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 '\r\n> >                     '(KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36'\r\n> >                 ),\r\n> >                 java_script_enabled=True,\r\n> >                 bypass_csp=disable_security,\r\n> >                 ignore_https_errors=disable_security,\r\n> >                 record_video_dir=save_recording_path if save_recording_path else None,\r\n> >                 record_video_size={'width': window_w, 'height': window_h}\r\n> >             )\r\n> >     else:\r\n> >         browser_context_ = None\r\n> > \r\n> >     browser = CustomBrowser(\r\n> >         config=BrowserConfig(\r\n> >             headless=headless,\r\n> >             disable_security=disable_security,\r\n> >             extra_chromium_args=[f'--window-size={window_w},{window_h}'],\r\n> >         )\r\n> >     )\r\n> >     async with await browser.new_context(\r\n> >             config=BrowserContextConfig(\r\n> >                 trace_path='./tmp/result_processing',\r\n> >                 save_recording_path=save_recording_path if save_recording_path else None,\r\n> >                 no_viewport=False,\r\n> >                 browser_window_size=BrowserContextWindowSize(width=window_w, height=window_h),\r\n> >             ),\r\n> > \r\n> >             context=browser_context_\r\n> >     ) as browser_context:\r\n> >         agent = CustomAgent(\r\n> >             task=task,\r\n> >             add_infos=add_infos,\r\n> >             use_vision=use_vision,\r\n> >             llm=llm,\r\n> >             browser_context=browser_context,\r\n> >             controller=controller,\r\n> >             system_prompt_class=CustomSystemPrompt\r\n> >         )\r\n> >         history = await agent.run(max_steps=max_steps)\r\n> > \r\n> >         final_result = history.final_result()\r\n> >         errors = history.errors()\r\n> >         model_actions = history.model_actions()\r\n> >         model_thoughts = history.model_thoughts()\r\n> > \r\n> > except Exception as e:\r\n> >     import traceback\r\n> >     traceback.print_exc()\r\n> >     final_result = \"\"\r\n> >     errors = str(e) + \"\\n\" + traceback.format_exc()\r\n> >     model_actions = \"\"\r\n> >     model_thoughts = \"\"\r\n> > finally:\r\n> >     # æ˜¾å¼å…³é—­æŒä¹…åŒ–ä¸Šä¸‹æ–‡\r\n> >     persistence_enabled = (\r\n> >         os.getenv(\"CHROME_PERSISTENT_SESSION\", \"\").lower() == \"true\"\r\n> >     )\r\n> >     if not persistence_enabled:\r\n> >         if browser_context_:\r\n> >             await browser_context_.close()\r\n> > \r\n> >         # å…³é—­ Playwright å¯¹è±¡\r\n> >         if playwright:\r\n> >             await playwright.stop()\r\n> >         await browser.close()\r\n> >         browser_context_ = None\r\n> > return final_result, errors, model_actions, model_thoughts\r\n> > ```\r\n> > \r\n> > \r\n> >     \r\n> >       \r\n> >     \r\n> > \r\n> >       \r\n> >     \r\n> > \r\n> >     \r\n> >   \r\n> > This works for me\r\n> \r\n> Ah sorry i dont have access to windows only tested on linux and docker container. is this happening in the container?\r\n\r\nI run it directly on my Windows. "
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-07T00:09:02Z",
        "body": "Good job, I can run task by task in keeping one browser open. There are still some points to optimize:\r\n1. When uncheck Use Own Browser and set CHROME_PERSISTENT_SESSION=true, but not working, which still generate a new browser. I try to  modify the code and seems to work, you can refer:\r\n```\r\nasync def run_custom_agent(\r\n        llm,\r\n        use_own_browser,\r\n        headless,\r\n        disable_security,\r\n        window_w,\r\n        window_h,\r\n        save_recording_path,\r\n        task,\r\n        add_infos,\r\n        max_steps,\r\n        use_vision\r\n):\r\n    global global_browser_context_\r\n    global global_playwright\r\n\r\n    controller = CustomController()\r\n    final_result = \"\"\r\n    errors = \"\"\r\n    model_actions = \"\"\r\n    model_thoughts = \"\"\r\n    try:\r\n        global global_browser\r\n        if global_browser is None:\r\n            global_browser = CustomBrowser(\r\n                config=BrowserConfig(\r\n                    headless=headless,\r\n                    disable_security=disable_security,\r\n                    extra_chromium_args=[f'--window-size={window_w},{window_h}'],\r\n                )\r\n            )\r\n        if use_own_browser:\r\n            if global_browser_context_ is None:\r\n                global_playwright = await async_playwright().start()\r\n                chrome_exe = os.getenv(\"CHROME_PATH\", \"\")\r\n                chrome_use_data = os.getenv(\"CHROME_USER_DATA\", \"\")\r\n                browser_context_ = await global_playwright.chromium.launch_persistent_context(\r\n                    user_data_dir=chrome_use_data,\r\n                    executable_path=chrome_exe,\r\n                    no_viewport=False,\r\n                    headless=headless,  # Keep browser window visible\r\n                    user_agent=(\r\n                        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \"\r\n                        \"(KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36\"\r\n                    ),\r\n                    java_script_enabled=True,\r\n                    bypass_csp=disable_security,\r\n                    ignore_https_errors=disable_security,\r\n                    record_video_dir=(\r\n                        save_recording_path if save_recording_path else None\r\n                    ),\r\n                    record_video_size={\"width\": window_w, \"height\": window_h},\r\n                )\r\n                global_browser_context_ = await global_browser.new_context(\r\n                    config=BrowserContextConfig(\r\n                        trace_path=\"./tmp/result_processing\",\r\n                        save_recording_path=(\r\n                            save_recording_path if save_recording_path else None\r\n                        ),\r\n                        no_viewport=False,\r\n                        browser_window_size=BrowserContextWindowSize(\r\n                            width=window_w, height=window_h\r\n                        ),\r\n                    ),\r\n                    context=browser_context_,\r\n                )\r\n        else:\r\n            if global_browser_context_ is None:\r\n                global_browser_context_ = await global_browser.new_context(\r\n                    config=BrowserContextConfig(\r\n                        trace_path=\"./tmp/result_processing\",\r\n                        save_recording_path=(\r\n                            save_recording_path if save_recording_path else None\r\n                        ),\r\n                        no_viewport=False,\r\n                        browser_window_size=BrowserContextWindowSize(\r\n                            width=window_w, height=window_h\r\n                        ),\r\n                    ),\r\n                    context=None\r\n                )\r\n\r\n        agent = CustomAgent(\r\n            task=task,\r\n            add_infos=add_infos,\r\n            use_vision=use_vision,\r\n            llm=llm,\r\n            browser_context=global_browser_context_,\r\n            controller=controller,\r\n            system_prompt_class=CustomSystemPrompt\r\n        )\r\n        history = await agent.run(max_steps=max_steps)\r\n        final_result = history.final_result()\r\n        errors = history.errors()\r\n        model_actions = history.model_actions()\r\n        model_thoughts = history.model_thoughts()\r\n\r\n    except Exception as e:\r\n        import traceback\r\n        traceback.print_exc()\r\n        errors = str(e) + \"\\n\" + traceback.format_exc()\r\n    finally:\r\n        # æ˜¾å¼å…³é—­æŒä¹…åŒ–ä¸Šä¸‹æ–‡\r\n        persistence_enabled = (\r\n            os.getenv(\"CHROME_PERSISTENT_SESSION\", \"\").lower() == \"true\"\r\n        )\r\n        if not persistence_enabled:\r\n            if global_browser_context_:\r\n                await global_browser_context_.close()\r\n                global_browser_context_ = None\r\n\r\n            if global_playwright:\r\n                await global_playwright.stop()\r\n                global_playwright = None\r\n            if global_browser:\r\n                await global_browser.close()\r\n                global_browser = None\r\n        return final_result, errors, model_actions, model_thoughts\r\n```\r\n\r\n2. Could you add a listener to use_own_browser,  when use_own_browser changes, maybe you need to close the global global_browser_context_, global_playwright, etc.\r\n3. Could you add a option `keep_open` in Browser Setting to overwrite CHROME_PERSISTENT_SESSION in env?"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-07T11:46:22Z",
        "body": "Hi, any updated or need any helps?"
      },
      {
        "user": "casistack",
        "created_at": "2025-01-07T13:25:34Z",
        "body": "> Hi, any updated or need any helps?\r\n\r\nHey , i already updated see above "
      },
      {
        "user": "casistack",
        "created_at": "2025-01-07T13:26:02Z",
        "body": "> I have applied your fix . Let me kno wif any issues\r\n\r\nsee this"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-07T13:33:07Z",
        "body": "> Good job, I can run task by task in keeping one browser open. There are still some points to optimize:\r\n> \r\n> 1. When uncheck Use Own Browser and set CHROME_PERSISTENT_SESSION=true, but not working, which still generate a new browser. I try to  modify the code and seems to work, you can refer:\r\n> \r\n> ```\r\n> async def run_custom_agent(\r\n>         llm,\r\n>         use_own_browser,\r\n>         headless,\r\n>         disable_security,\r\n>         window_w,\r\n>         window_h,\r\n>         save_recording_path,\r\n>         task,\r\n>         add_infos,\r\n>         max_steps,\r\n>         use_vision\r\n> ):\r\n>     global global_browser_context_\r\n>     global global_playwright\r\n> \r\n>     controller = CustomController()\r\n>     final_result = \"\"\r\n>     errors = \"\"\r\n>     model_actions = \"\"\r\n>     model_thoughts = \"\"\r\n>     try:\r\n>         global global_browser\r\n>         if global_browser is None:\r\n>             global_browser = CustomBrowser(\r\n>                 config=BrowserConfig(\r\n>                     headless=headless,\r\n>                     disable_security=disable_security,\r\n>                     extra_chromium_args=[f'--window-size={window_w},{window_h}'],\r\n>                 )\r\n>             )\r\n>         if use_own_browser:\r\n>             if global_browser_context_ is None:\r\n>                 global_playwright = await async_playwright().start()\r\n>                 chrome_exe = os.getenv(\"CHROME_PATH\", \"\")\r\n>                 chrome_use_data = os.getenv(\"CHROME_USER_DATA\", \"\")\r\n>                 browser_context_ = await global_playwright.chromium.launch_persistent_context(\r\n>                     user_data_dir=chrome_use_data,\r\n>                     executable_path=chrome_exe,\r\n>                     no_viewport=False,\r\n>                     headless=headless,  # Keep browser window visible\r\n>                     user_agent=(\r\n>                         \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \"\r\n>                         \"(KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36\"\r\n>                     ),\r\n>                     java_script_enabled=True,\r\n>                     bypass_csp=disable_security,\r\n>                     ignore_https_errors=disable_security,\r\n>                     record_video_dir=(\r\n>                         save_recording_path if save_recording_path else None\r\n>                     ),\r\n>                     record_video_size={\"width\": window_w, \"height\": window_h},\r\n>                 )\r\n>                 global_browser_context_ = await global_browser.new_context(\r\n>                     config=BrowserContextConfig(\r\n>                         trace_path=\"./tmp/result_processing\",\r\n>                         save_recording_path=(\r\n>                             save_recording_path if save_recording_path else None\r\n>                         ),\r\n>                         no_viewport=False,\r\n>                         browser_window_size=BrowserContextWindowSize(\r\n>                             width=window_w, height=window_h\r\n>                         ),\r\n>                     ),\r\n>                     context=browser_context_,\r\n>                 )\r\n>         else:\r\n>             if global_browser_context_ is None:\r\n>                 global_browser_context_ = await global_browser.new_context(\r\n>                     config=BrowserContextConfig(\r\n>                         trace_path=\"./tmp/result_processing\",\r\n>                         save_recording_path=(\r\n>                             save_recording_path if save_recording_path else None\r\n>                         ),\r\n>                         no_viewport=False,\r\n>                         browser_window_size=BrowserContextWindowSize(\r\n>                             width=window_w, height=window_h\r\n>                         ),\r\n>                     ),\r\n>                     context=None\r\n>                 )\r\n> \r\n>         agent = CustomAgent(\r\n>             task=task,\r\n>             add_infos=add_infos,\r\n>             use_vision=use_vision,\r\n>             llm=llm,\r\n>             browser_context=global_browser_context_,\r\n>             controller=controller,\r\n>             system_prompt_class=CustomSystemPrompt\r\n>         )\r\n>         history = await agent.run(max_steps=max_steps)\r\n>         final_result = history.final_result()\r\n>         errors = history.errors()\r\n>         model_actions = history.model_actions()\r\n>         model_thoughts = history.model_thoughts()\r\n> \r\n>     except Exception as e:\r\n>         import traceback\r\n>         traceback.print_exc()\r\n>         errors = str(e) + \"\\n\" + traceback.format_exc()\r\n>     finally:\r\n>         # æ˜¾å¼å…³é—­æŒä¹…åŒ–ä¸Šä¸‹æ–‡\r\n>         persistence_enabled = (\r\n>             os.getenv(\"CHROME_PERSISTENT_SESSION\", \"\").lower() == \"true\"\r\n>         )\r\n>         if not persistence_enabled:\r\n>             if global_browser_context_:\r\n>                 await global_browser_context_.close()\r\n>                 global_browser_context_ = None\r\n> \r\n>             if global_playwright:\r\n>                 await global_playwright.stop()\r\n>                 global_playwright = None\r\n>             if global_browser:\r\n>                 await global_browser.close()\r\n>                 global_browser = None\r\n>         return final_result, errors, model_actions, model_thoughts\r\n> ```\r\n> \r\n> 2. Could you add a listener to use_own_browser,  when use_own_browser changes, maybe you need to close the global global_browser_context_, global_playwright, etc.\r\n> 3. Could you add a option `keep_open` in Browser Setting to overwrite CHROME_PERSISTENT_SESSION in env?\r\n\r\nHere, some new issues"
      },
      {
        "user": "casistack",
        "created_at": "2025-01-07T13:44:32Z",
        "body": "> > Good job, I can run task by task in keeping one browser open. There are still some points to optimize:\r\n> > \r\n> > 1. When uncheck Use Own Browser and set CHROME_PERSISTENT_SESSION=true, but not working, which still generate a new browser. I try to  modify the code and seems to work, you can refer:\r\n> > \r\n> > ```\r\n> > async def run_custom_agent(\r\n> >         llm,\r\n> >         use_own_browser,\r\n> >         headless,\r\n> >         disable_security,\r\n> >         window_w,\r\n> >         window_h,\r\n> >         save_recording_path,\r\n> >         task,\r\n> >         add_infos,\r\n> >         max_steps,\r\n> >         use_vision\r\n> > ):\r\n> >     global global_browser_context_\r\n> >     global global_playwright\r\n> > \r\n> >     controller = CustomController()\r\n> >     final_result = \"\"\r\n> >     errors = \"\"\r\n> >     model_actions = \"\"\r\n> >     model_thoughts = \"\"\r\n> >     try:\r\n> >         global global_browser\r\n> >         if global_browser is None:\r\n> >             global_browser = CustomBrowser(\r\n> >                 config=BrowserConfig(\r\n> >                     headless=headless,\r\n> >                     disable_security=disable_security,\r\n> >                     extra_chromium_args=[f'--window-size={window_w},{window_h}'],\r\n> >                 )\r\n> >             )\r\n> >         if use_own_browser:\r\n> >             if global_browser_context_ is None:\r\n> >                 global_playwright = await async_playwright().start()\r\n> >                 chrome_exe = os.getenv(\"CHROME_PATH\", \"\")\r\n> >                 chrome_use_data = os.getenv(\"CHROME_USER_DATA\", \"\")\r\n> >                 browser_context_ = await global_playwright.chromium.launch_persistent_context(\r\n> >                     user_data_dir=chrome_use_data,\r\n> >                     executable_path=chrome_exe,\r\n> >                     no_viewport=False,\r\n> >                     headless=headless,  # Keep browser window visible\r\n> >                     user_agent=(\r\n> >                         \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \"\r\n> >                         \"(KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36\"\r\n> >                     ),\r\n> >                     java_script_enabled=True,\r\n> >                     bypass_csp=disable_security,\r\n> >                     ignore_https_errors=disable_security,\r\n> >                     record_video_dir=(\r\n> >                         save_recording_path if save_recording_path else None\r\n> >                     ),\r\n> >                     record_video_size={\"width\": window_w, \"height\": window_h},\r\n> >                 )\r\n> >                 global_browser_context_ = await global_browser.new_context(\r\n> >                     config=BrowserContextConfig(\r\n> >                         trace_path=\"./tmp/result_processing\",\r\n> >                         save_recording_path=(\r\n> >                             save_recording_path if save_recording_path else None\r\n> >                         ),\r\n> >                         no_viewport=False,\r\n> >                         browser_window_size=BrowserContextWindowSize(\r\n> >                             width=window_w, height=window_h\r\n> >                         ),\r\n> >                     ),\r\n> >                     context=browser_context_,\r\n> >                 )\r\n> >         else:\r\n> >             if global_browser_context_ is None:\r\n> >                 global_browser_context_ = await global_browser.new_context(\r\n> >                     config=BrowserContextConfig(\r\n> >                         trace_path=\"./tmp/result_processing\",\r\n> >                         save_recording_path=(\r\n> >                             save_recording_path if save_recording_path else None\r\n> >                         ),\r\n> >                         no_viewport=False,\r\n> >                         browser_window_size=BrowserContextWindowSize(\r\n> >                             width=window_w, height=window_h\r\n> >                         ),\r\n> >                     ),\r\n> >                     context=None\r\n> >                 )\r\n> > \r\n> >         agent = CustomAgent(\r\n> >             task=task,\r\n> >             add_infos=add_infos,\r\n> >             use_vision=use_vision,\r\n> >             llm=llm,\r\n> >             browser_context=global_browser_context_,\r\n> >             controller=controller,\r\n> >             system_prompt_class=CustomSystemPrompt\r\n> >         )\r\n> >         history = await agent.run(max_steps=max_steps)\r\n> >         final_result = history.final_result()\r\n> >         errors = history.errors()\r\n> >         model_actions = history.model_actions()\r\n> >         model_thoughts = history.model_thoughts()\r\n> > \r\n> >     except Exception as e:\r\n> >         import traceback\r\n> >         traceback.print_exc()\r\n> >         errors = str(e) + \"\\n\" + traceback.format_exc()\r\n> >     finally:\r\n> >         # æ˜¾å¼å…³é—­æŒä¹…åŒ–ä¸Šä¸‹æ–‡\r\n> >         persistence_enabled = (\r\n> >             os.getenv(\"CHROME_PERSISTENT_SESSION\", \"\").lower() == \"true\"\r\n> >         )\r\n> >         if not persistence_enabled:\r\n> >             if global_browser_context_:\r\n> >                 await global_browser_context_.close()\r\n> >                 global_browser_context_ = None\r\n> > \r\n> >             if global_playwright:\r\n> >                 await global_playwright.stop()\r\n> >                 global_playwright = None\r\n> >             if global_browser:\r\n> >                 await global_browser.close()\r\n> >                 global_browser = None\r\n> >         return final_result, errors, model_actions, model_thoughts\r\n> > ```\r\n> > \r\n> > \r\n> >     \r\n> >       \r\n> >     \r\n> > \r\n> >       \r\n> >     \r\n> > \r\n> >     \r\n> >   \r\n> > \r\n> > 2. Could you add a listener to use_own_browser,  when use_own_browser changes, maybe you need to close the global global_browser_context_, global_playwright, etc.\r\n> > 3. Could you add a option `keep_open` in Browser Setting to overwrite CHROME_PERSISTENT_SESSION in env?\r\n> \r\n> Here, some new issues\r\n\r\n can have a look but busy with work till weekend . If you have time Can you edit code please how you want it . "
      },
      {
        "user": "casistack",
        "created_at": "2025-01-07T13:50:11Z",
        "body": "> > > Good job, I can run task by task in keeping one browser open. There are still some points to optimize:\r\n> > > \r\n> > > 1. When uncheck Use Own Browser and set CHROME_PERSISTENT_SESSION=true, but not working, which still generate a new browser. I try to  modify the code and seems to work, you can refer:\r\n> > > \r\n> > > ```\r\n> > > async def run_custom_agent(\r\n> > >         llm,\r\n> > >         use_own_browser,\r\n> > >         headless,\r\n> > >         disable_security,\r\n> > >         window_w,\r\n> > >         window_h,\r\n> > >         save_recording_path,\r\n> > >         task,\r\n> > >         add_infos,\r\n> > >         max_steps,\r\n> > >         use_vision\r\n> > > ):\r\n> > >     global global_browser_context_\r\n> > >     global global_playwright\r\n> > > \r\n> > >     controller = CustomController()\r\n> > >     final_result = \"\"\r\n> > >     errors = \"\"\r\n> > >     model_actions = \"\"\r\n> > >     model_thoughts = \"\"\r\n> > >     try:\r\n> > >         global global_browser\r\n> > >         if global_browser is None:\r\n> > >             global_browser = CustomBrowser(\r\n> > >                 config=BrowserConfig(\r\n> > >                     headless=headless,\r\n> > >                     disable_security=disable_security,\r\n> > >                     extra_chromium_args=[f'--window-size={window_w},{window_h}'],\r\n> > >                 )\r\n> > >             )\r\n> > >         if use_own_browser:\r\n> > >             if global_browser_context_ is None:\r\n> > >                 global_playwright = await async_playwright().start()\r\n> > >                 chrome_exe = os.getenv(\"CHROME_PATH\", \"\")\r\n> > >                 chrome_use_data = os.getenv(\"CHROME_USER_DATA\", \"\")\r\n> > >                 browser_context_ = await global_playwright.chromium.launch_persistent_context(\r\n> > >                     user_data_dir=chrome_use_data,\r\n> > >                     executable_path=chrome_exe,\r\n> > >                     no_viewport=False,\r\n> > >                     headless=headless,  # Keep browser window visible\r\n> > >                     user_agent=(\r\n> > >                         \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \"\r\n> > >                         \"(KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36\"\r\n> > >                     ),\r\n> > >                     java_script_enabled=True,\r\n> > >                     bypass_csp=disable_security,\r\n> > >                     ignore_https_errors=disable_security,\r\n> > >                     record_video_dir=(\r\n> > >                         save_recording_path if save_recording_path else None\r\n> > >                     ),\r\n> > >                     record_video_size={\"width\": window_w, \"height\": window_h},\r\n> > >                 )\r\n> > >                 global_browser_context_ = await global_browser.new_context(\r\n> > >                     config=BrowserContextConfig(\r\n> > >                         trace_path=\"./tmp/result_processing\",\r\n> > >                         save_recording_path=(\r\n> > >                             save_recording_path if save_recording_path else None\r\n> > >                         ),\r\n> > >                         no_viewport=False,\r\n> > >                         browser_window_size=BrowserContextWindowSize(\r\n> > >                             width=window_w, height=window_h\r\n> > >                         ),\r\n> > >                     ),\r\n> > >                     context=browser_context_,\r\n> > >                 )\r\n> > >         else:\r\n> > >             if global_browser_context_ is None:\r\n> > >                 global_browser_context_ = await global_browser.new_context(\r\n> > >                     config=BrowserContextConfig(\r\n> > >                         trace_path=\"./tmp/result_processing\",\r\n> > >                         save_recording_path=(\r\n> > >                             save_recording_path if save_recording_path else None\r\n> > >                         ),\r\n> > >                         no_viewport=False,\r\n> > >                         browser_window_size=BrowserContextWindowSize(\r\n> > >                             width=window_w, height=window_h\r\n> > >                         ),\r\n> > >                     ),\r\n> > >                     context=None\r\n> > >                 )\r\n> > > \r\n> > >         agent = CustomAgent(\r\n> > >             task=task,\r\n> > >             add_infos=add_infos,\r\n> > >             use_vision=use_vision,\r\n> > >             llm=llm,\r\n> > >             browser_context=global_browser_context_,\r\n> > >             controller=controller,\r\n> > >             system_prompt_class=CustomSystemPrompt\r\n> > >         )\r\n> > >         history = await agent.run(max_steps=max_steps)\r\n> > >         final_result = history.final_result()\r\n> > >         errors = history.errors()\r\n> > >         model_actions = history.model_actions()\r\n> > >         model_thoughts = history.model_thoughts()\r\n> > > \r\n> > >     except Exception as e:\r\n> > >         import traceback\r\n> > >         traceback.print_exc()\r\n> > >         errors = str(e) + \"\\n\" + traceback.format_exc()\r\n> > >     finally:\r\n> > >         # æ˜¾å¼å…³é—­æŒä¹…åŒ–ä¸Šä¸‹æ–‡\r\n> > >         persistence_enabled = (\r\n> > >             os.getenv(\"CHROME_PERSISTENT_SESSION\", \"\").lower() == \"true\"\r\n> > >         )\r\n> > >         if not persistence_enabled:\r\n> > >             if global_browser_context_:\r\n> > >                 await global_browser_context_.close()\r\n> > >                 global_browser_context_ = None\r\n> > > \r\n> > >             if global_playwright:\r\n> > >                 await global_playwright.stop()\r\n> > >                 global_playwright = None\r\n> > >             if global_browser:\r\n> > >                 await global_browser.close()\r\n> > >                 global_browser = None\r\n> > >         return final_result, errors, model_actions, model_thoughts\r\n> > > ```\r\n> > > \r\n> > > \r\n> > >     \r\n> > >       \r\n> > >     \r\n> > > \r\n> > >       \r\n> > >     \r\n> > > \r\n> > >     \r\n> > >   \r\n> > > \r\n> > > 2. Could you add a listener to use_own_browser,  when use_own_browser changes, maybe you need to close the global global_browser_context_, global_playwright, etc.\r\n> > > 3. Could you add a option `keep_open` in Browser Setting to overwrite CHROME_PERSISTENT_SESSION in env?\r\n> > \r\n> > \r\n> > Here, some new issues\r\n> \r\n> can have a look but busy with work till weekend . If you have time Can you edit code please how you want it .\r\n\r\nOh quick one too. i tried to abstract CHROME_PERSISTENT_SESSION away from the main code. so setting CHROME_PERSISTENT_SESSION=true should keep browser open but CHROME_PERSISTENT_SESSION=false should default to the behaviour you have in code which is browse closes after every session. so on \"Could you add a option `keep_open` in Browser Setting to overwrite CHROME_PERSISTENT_SESSION in env\" i'm not sure what you mean by this?"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-07T13:50:35Z",
        "body": "> > > Good job, I can run task by task in keeping one browser open. There are still some points to optimize:\r\n> > > \r\n> > > 1. When uncheck Use Own Browser and set CHROME_PERSISTENT_SESSION=true, but not working, which still generate a new browser. I try to  modify the code and seems to work, you can refer:\r\n> > > \r\n> > > ```\r\n> > > async def run_custom_agent(\r\n> > >         llm,\r\n> > >         use_own_browser,\r\n> > >         headless,\r\n> > >         disable_security,\r\n> > >         window_w,\r\n> > >         window_h,\r\n> > >         save_recording_path,\r\n> > >         task,\r\n> > >         add_infos,\r\n> > >         max_steps,\r\n> > >         use_vision\r\n> > > ):\r\n> > >     global global_browser_context_\r\n> > >     global global_playwright\r\n> > > \r\n> > >     controller = CustomController()\r\n> > >     final_result = \"\"\r\n> > >     errors = \"\"\r\n> > >     model_actions = \"\"\r\n> > >     model_thoughts = \"\"\r\n> > >     try:\r\n> > >         global global_browser\r\n> > >         if global_browser is None:\r\n> > >             global_browser = CustomBrowser(\r\n> > >                 config=BrowserConfig(\r\n> > >                     headless=headless,\r\n> > >                     disable_security=disable_security,\r\n> > >                     extra_chromium_args=[f'--window-size={window_w},{window_h}'],\r\n> > >                 )\r\n> > >             )\r\n> > >         if use_own_browser:\r\n> > >             if global_browser_context_ is None:\r\n> > >                 global_playwright = await async_playwright().start()\r\n> > >                 chrome_exe = os.getenv(\"CHROME_PATH\", \"\")\r\n> > >                 chrome_use_data = os.getenv(\"CHROME_USER_DATA\", \"\")\r\n> > >                 browser_context_ = await global_playwright.chromium.launch_persistent_context(\r\n> > >                     user_data_dir=chrome_use_data,\r\n> > >                     executable_path=chrome_exe,\r\n> > >                     no_viewport=False,\r\n> > >                     headless=headless,  # Keep browser window visible\r\n> > >                     user_agent=(\r\n> > >                         \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \"\r\n> > >                         \"(KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36\"\r\n> > >                     ),\r\n> > >                     java_script_enabled=True,\r\n> > >                     bypass_csp=disable_security,\r\n> > >                     ignore_https_errors=disable_security,\r\n> > >                     record_video_dir=(\r\n> > >                         save_recording_path if save_recording_path else None\r\n> > >                     ),\r\n> > >                     record_video_size={\"width\": window_w, \"height\": window_h},\r\n> > >                 )\r\n> > >                 global_browser_context_ = await global_browser.new_context(\r\n> > >                     config=BrowserContextConfig(\r\n> > >                         trace_path=\"./tmp/result_processing\",\r\n> > >                         save_recording_path=(\r\n> > >                             save_recording_path if save_recording_path else None\r\n> > >                         ),\r\n> > >                         no_viewport=False,\r\n> > >                         browser_window_size=BrowserContextWindowSize(\r\n> > >                             width=window_w, height=window_h\r\n> > >                         ),\r\n> > >                     ),\r\n> > >                     context=browser_context_,\r\n> > >                 )\r\n> > >         else:\r\n> > >             if global_browser_context_ is None:\r\n> > >                 global_browser_context_ = await global_browser.new_context(\r\n> > >                     config=BrowserContextConfig(\r\n> > >                         trace_path=\"./tmp/result_processing\",\r\n> > >                         save_recording_path=(\r\n> > >                             save_recording_path if save_recording_path else None\r\n> > >                         ),\r\n> > >                         no_viewport=False,\r\n> > >                         browser_window_size=BrowserContextWindowSize(\r\n> > >                             width=window_w, height=window_h\r\n> > >                         ),\r\n> > >                     ),\r\n> > >                     context=None\r\n> > >                 )\r\n> > > \r\n> > >         agent = CustomAgent(\r\n> > >             task=task,\r\n> > >             add_infos=add_infos,\r\n> > >             use_vision=use_vision,\r\n> > >             llm=llm,\r\n> > >             browser_context=global_browser_context_,\r\n> > >             controller=controller,\r\n> > >             system_prompt_class=CustomSystemPrompt\r\n> > >         )\r\n> > >         history = await agent.run(max_steps=max_steps)\r\n> > >         final_result = history.final_result()\r\n> > >         errors = history.errors()\r\n> > >         model_actions = history.model_actions()\r\n> > >         model_thoughts = history.model_thoughts()\r\n> > > \r\n> > >     except Exception as e:\r\n> > >         import traceback\r\n> > >         traceback.print_exc()\r\n> > >         errors = str(e) + \"\\n\" + traceback.format_exc()\r\n> > >     finally:\r\n> > >         # æ˜¾å¼å…³é—­æŒä¹…åŒ–ä¸Šä¸‹æ–‡\r\n> > >         persistence_enabled = (\r\n> > >             os.getenv(\"CHROME_PERSISTENT_SESSION\", \"\").lower() == \"true\"\r\n> > >         )\r\n> > >         if not persistence_enabled:\r\n> > >             if global_browser_context_:\r\n> > >                 await global_browser_context_.close()\r\n> > >                 global_browser_context_ = None\r\n> > > \r\n> > >             if global_playwright:\r\n> > >                 await global_playwright.stop()\r\n> > >                 global_playwright = None\r\n> > >             if global_browser:\r\n> > >                 await global_browser.close()\r\n> > >                 global_browser = None\r\n> > >         return final_result, errors, model_actions, model_thoughts\r\n> > > ```\r\n> > > \r\n> > > \r\n> > >     \r\n> > >       \r\n> > >     \r\n> > > \r\n> > >       \r\n> > >     \r\n> > > \r\n> > >     \r\n> > >   \r\n> > > \r\n> > > 2. Could you add a listener to use_own_browser,  when use_own_browser changes, maybe you need to close the global global_browser_context_, global_playwright, etc.\r\n> > > 3. Could you add a option `keep_open` in Browser Setting to overwrite CHROME_PERSISTENT_SESSION in env?\r\n> > \r\n> > \r\n> > Here, some new issues\r\n> \r\n> can have a look but busy with work till weekend . If you have time Can you edit code please how you want it .\r\n\r\nOK, I will help to edit code"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-07T13:57:11Z",
        "body": "> > > > Good job, I can run task by task in keeping one browser open. There are still some points to optimize:\r\n> > > > \r\n> > > > 1. When uncheck Use Own Browser and set CHROME_PERSISTENT_SESSION=true, but not working, which still generate a new browser. I try to  modify the code and seems to work, you can refer:\r\n> > > > \r\n> > > > ```\r\n> > > > async def run_custom_agent(\r\n> > > >         llm,\r\n> > > >         use_own_browser,\r\n> > > >         headless,\r\n> > > >         disable_security,\r\n> > > >         window_w,\r\n> > > >         window_h,\r\n> > > >         save_recording_path,\r\n> > > >         task,\r\n> > > >         add_infos,\r\n> > > >         max_steps,\r\n> > > >         use_vision\r\n> > > > ):\r\n> > > >     global global_browser_context_\r\n> > > >     global global_playwright\r\n> > > > \r\n> > > >     controller = CustomController()\r\n> > > >     final_result = \"\"\r\n> > > >     errors = \"\"\r\n> > > >     model_actions = \"\"\r\n> > > >     model_thoughts = \"\"\r\n> > > >     try:\r\n> > > >         global global_browser\r\n> > > >         if global_browser is None:\r\n> > > >             global_browser = CustomBrowser(\r\n> > > >                 config=BrowserConfig(\r\n> > > >                     headless=headless,\r\n> > > >                     disable_security=disable_security,\r\n> > > >                     extra_chromium_args=[f'--window-size={window_w},{window_h}'],\r\n> > > >                 )\r\n> > > >             )\r\n> > > >         if use_own_browser:\r\n> > > >             if global_browser_context_ is None:\r\n> > > >                 global_playwright = await async_playwright().start()\r\n> > > >                 chrome_exe = os.getenv(\"CHROME_PATH\", \"\")\r\n> > > >                 chrome_use_data = os.getenv(\"CHROME_USER_DATA\", \"\")\r\n> > > >                 browser_context_ = await global_playwright.chromium.launch_persistent_context(\r\n> > > >                     user_data_dir=chrome_use_data,\r\n> > > >                     executable_path=chrome_exe,\r\n> > > >                     no_viewport=False,\r\n> > > >                     headless=headless,  # Keep browser window visible\r\n> > > >                     user_agent=(\r\n> > > >                         \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \"\r\n> > > >                         \"(KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36\"\r\n> > > >                     ),\r\n> > > >                     java_script_enabled=True,\r\n> > > >                     bypass_csp=disable_security,\r\n> > > >                     ignore_https_errors=disable_security,\r\n> > > >                     record_video_dir=(\r\n> > > >                         save_recording_path if save_recording_path else None\r\n> > > >                     ),\r\n> > > >                     record_video_size={\"width\": window_w, \"height\": window_h},\r\n> > > >                 )\r\n> > > >                 global_browser_context_ = await global_browser.new_context(\r\n> > > >                     config=BrowserContextConfig(\r\n> > > >                         trace_path=\"./tmp/result_processing\",\r\n> > > >                         save_recording_path=(\r\n> > > >                             save_recording_path if save_recording_path else None\r\n> > > >                         ),\r\n> > > >                         no_viewport=False,\r\n> > > >                         browser_window_size=BrowserContextWindowSize(\r\n> > > >                             width=window_w, height=window_h\r\n> > > >                         ),\r\n> > > >                     ),\r\n> > > >                     context=browser_context_,\r\n> > > >                 )\r\n> > > >         else:\r\n> > > >             if global_browser_context_ is None:\r\n> > > >                 global_browser_context_ = await global_browser.new_context(\r\n> > > >                     config=BrowserContextConfig(\r\n> > > >                         trace_path=\"./tmp/result_processing\",\r\n> > > >                         save_recording_path=(\r\n> > > >                             save_recording_path if save_recording_path else None\r\n> > > >                         ),\r\n> > > >                         no_viewport=False,\r\n> > > >                         browser_window_size=BrowserContextWindowSize(\r\n> > > >                             width=window_w, height=window_h\r\n> > > >                         ),\r\n> > > >                     ),\r\n> > > >                     context=None\r\n> > > >                 )\r\n> > > > \r\n> > > >         agent = CustomAgent(\r\n> > > >             task=task,\r\n> > > >             add_infos=add_infos,\r\n> > > >             use_vision=use_vision,\r\n> > > >             llm=llm,\r\n> > > >             browser_context=global_browser_context_,\r\n> > > >             controller=controller,\r\n> > > >             system_prompt_class=CustomSystemPrompt\r\n> > > >         )\r\n> > > >         history = await agent.run(max_steps=max_steps)\r\n> > > >         final_result = history.final_result()\r\n> > > >         errors = history.errors()\r\n> > > >         model_actions = history.model_actions()\r\n> > > >         model_thoughts = history.model_thoughts()\r\n> > > > \r\n> > > >     except Exception as e:\r\n> > > >         import traceback\r\n> > > >         traceback.print_exc()\r\n> > > >         errors = str(e) + \"\\n\" + traceback.format_exc()\r\n> > > >     finally:\r\n> > > >         # æ˜¾å¼å…³é—­æŒä¹…åŒ–ä¸Šä¸‹æ–‡\r\n> > > >         persistence_enabled = (\r\n> > > >             os.getenv(\"CHROME_PERSISTENT_SESSION\", \"\").lower() == \"true\"\r\n> > > >         )\r\n> > > >         if not persistence_enabled:\r\n> > > >             if global_browser_context_:\r\n> > > >                 await global_browser_context_.close()\r\n> > > >                 global_browser_context_ = None\r\n> > > > \r\n> > > >             if global_playwright:\r\n> > > >                 await global_playwright.stop()\r\n> > > >                 global_playwright = None\r\n> > > >             if global_browser:\r\n> > > >                 await global_browser.close()\r\n> > > >                 global_browser = None\r\n> > > >         return final_result, errors, model_actions, model_thoughts\r\n> > > > ```\r\n> > > > \r\n> > > > \r\n> > > >     \r\n> > > >       \r\n> > > >     \r\n> > > > \r\n> > > >       \r\n> > > >     \r\n> > > > \r\n> > > >     \r\n> > > >   \r\n> > > > \r\n> > > > 2. Could you add a listener to use_own_browser,  when use_own_browser changes, maybe you need to close the global global_browser_context_, global_playwright, etc.\r\n> > > > 3. Could you add a option `keep_open` in Browser Setting to overwrite CHROME_PERSISTENT_SESSION in env?\r\n> > > \r\n> > > \r\n> > > Here, some new issues\r\n> > \r\n> > \r\n> > can have a look but busy with work till weekend . If you have time Can you edit code please how you want it .\r\n> \r\n> Oh quick one too. i tried to abstract CHROME_PERSISTENT_SESSION away from the main code. so setting CHROME_PERSISTENT_SESSION=true should keep browser open but CHROME_PERSISTENT_SESSION=false should default to the behaviour you have in code which is browse closes after every session. so on \"Could you add a option `keep_open` in Browser Setting to overwrite CHROME_PERSISTENT_SESSION in env\" i'm not sure what you mean by this?\r\n\r\nI want to add a \"keep_open\" option on WebUI, with same effect as setting CHROME_PERSISTENT_SESSION  in the .env file. Never mind, let me help to complete the code"
      },
      {
        "user": "casistack",
        "created_at": "2025-01-08T14:02:55Z",
        "body": "Hey any update on this . do you need me to do something?"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-08T14:14:41Z",
        "body": "> Hey any update on this . do you need me to do something?\r\n\r\nNot yet. I am busy with handing other issues. You can continue to do this job. Looking forward to it!"
      },
      {
        "user": "warmshao",
        "created_at": "2025-01-09T13:07:53Z",
        "body": "I think this feature is very Cool! I want to make it online soon, do you have a discord, we can discuss directly."
      },
      {
        "user": "casistack",
        "created_at": "2025-01-09T13:33:05Z",
        "body": "> I think this feature is very Cool! I want to make it online soon, do you have a discord, we can discuss directly.\r\nYes will join your discord and message you"
      },
      {
        "user": "casistack",
        "created_at": "2025-01-09T13:41:50Z",
        "body": "> > I think this feature is very Cool! I want to make it online soon, do you have a discord, we can discuss directly.\r\n> > Yes will join your discord and message you\r\n\r\nI have messaged you on discord"
      }
    ]
  },
  {
    "number": 15,
    "title": "how to use my own browser instead of testing browser ?",
    "created_at": "2025-01-06T13:02:17Z",
    "closed_at": "2025-02-04T08:26:13Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/issues/15",
    "body": null,
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/15/comments",
    "author": "klei30",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-06T13:04:05Z",
        "body": "Please refer the readme to learn  using your own browser"
      },
      {
        "user": "richard-devbot",
        "created_at": "2025-01-06T13:32:09Z",
        "body": "Hey @klei30 you can set your Chrome path in the .env file like this\r\n CHROME_PATH=C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\r\nCHROME_USER_DATA=C:\\Users\\<username>\\AppData\\Local\\Google\\Chrome\\User Data\r\n\r\nand select the check box \"use own browser\" in the UI inside Browser settings Tab"
      },
      {
        "user": "rowbot1",
        "created_at": "2025-01-06T20:21:48Z",
        "body": "does this work with edge?"
      },
      {
        "user": "rmensing",
        "created_at": "2025-01-06T20:53:12Z",
        "body": "yes, it works with Edge.\r\n\r\nExample .env setting:\r\n\r\n```\r\nCHROME_PATH=C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\r\nCHROME_USER_DATA=C:\\Users\\<USER_NAME>\\AppData\\Local\\Microsoft\\Edge\\User Data\r\n```\r\n\r\nI assumer it will work with any Chromium based browser.\r\n\r\nI have not tested non-Cromium based browsers."
      }
    ]
  },
  {
    "number": 9,
    "title": "chore: update custom_prompts.py",
    "created_at": "2025-01-05T07:58:55Z",
    "closed_at": "2025-01-05T08:00:44Z",
    "labels": [],
    "url": "https://github.com/browser-use/web-ui/pull/9",
    "body": "minor fix",
    "comments_url": "https://api.github.com/repos/browser-use/web-ui/issues/9/comments",
    "author": "eltociear",
    "comments": [
      {
        "user": "warmshao",
        "created_at": "2025-01-05T08:00:41Z",
        "body": "LGTM"
      }
    ]
  }
]